/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

struct __anonstruct____missing_field_name_2 {
   unsigned long correct ;
   unsigned long incorrect ;
};
struct __anonstruct____missing_field_name_3 {
   unsigned long miss ;
   unsigned long hit ;
};
union __anonunion____missing_field_name_1 {
   struct __anonstruct____missing_field_name_2 __annonCompField1 ;
   struct __anonstruct____missing_field_name_3 __annonCompField2 ;
   unsigned long miss_hit[2] ;
};
struct ftrace_branch_data {
   char const   *func ;
   char const   *file ;
   unsigned int line ;
   union __anonunion____missing_field_name_1 __annonCompField3 ;
};
enum __anonenum_4 {
    false = 0,
    true = 1
} ;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef unsigned short umode_t;
typedef u64 dma64_addr_t;
typedef u32 dma_addr_t;
struct __anonstruct___kernel_fd_set_5 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___kernel_fd_set_5 __kernel_fd_set;
typedef void (*__kernel_sighandler_t)(int  );
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char *__kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;
typedef long long __kernel_loff_t;
struct __anonstruct___kernel_fsid_t_6 {
   int val[2] ;
};
typedef struct __anonstruct___kernel_fsid_t_6 __kernel_fsid_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
typedef unsigned long uintptr_t;
typedef __kernel_old_uid_t old_uid_t;
typedef __kernel_old_gid_t old_gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_ptrdiff_t ptrdiff_t;
typedef __kernel_time_t time_t;
typedef __kernel_clock_t clock_t;
typedef __kernel_caddr_t caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef u32 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
typedef struct __anonstruct_atomic_t_7 atomic_t;
struct ustat {
   __kernel_daddr_t f_tfree ;
   __kernel_ino_t f_tinode ;
   char f_fname[6] ;
   char f_fpack[6] ;
};
struct task_struct;
struct mm_struct;
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct revectored_struct {
   unsigned long __map[8] ;
};
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
struct vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
struct vm86plus_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
};
struct ptrace_bts_config {
   __u32 size ;
   __u32 flags ;
   __u32 signal ;
   __u32 bts_size ;
};
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);
struct obs_kernel_param {
   char const   *str ;
   int (*setup_func)(char * ) ;
   int early ;
};
struct cpuinfo_x86;
struct user_desc;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct kernel_vm86_struct {
   struct kernel_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
   struct pt_regs *regs32 ;
};
union __anonunion____missing_field_name_8 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
struct _fpx_sw_bytes {
   __u32 magic1 ;
   __u32 extended_size ;
   __u64 xstate_bv ;
   __u32 xstate_size ;
   __u32 padding[7] ;
};
union __anonunion____missing_field_name_9 {
   __u32 reserved3[12] ;
   struct _fpx_sw_bytes sw_reserved ;
};
struct _fpstate {
   __u16 cwd ;
   __u16 swd ;
   __u16 twd ;
   __u16 fop ;
   __u64 rip ;
   __u64 rdp ;
   __u32 mxcsr ;
   __u32 mxcsr_mask ;
   __u32 st_space[32] ;
   __u32 xmm_space[64] ;
   __u32 reserved2[12] ;
   union __anonunion____missing_field_name_9 __annonCompField5 ;
};
struct sigcontext {
   unsigned long r8 ;
   unsigned long r9 ;
   unsigned long r10 ;
   unsigned long r11 ;
   unsigned long r12 ;
   unsigned long r13 ;
   unsigned long r14 ;
   unsigned long r15 ;
   unsigned long di ;
   unsigned long si ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long dx ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long sp ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   unsigned long err ;
   unsigned long trapno ;
   unsigned long oldmask ;
   unsigned long cr2 ;
   void *fpstate ;
   unsigned long reserved1[8] ;
};
struct _xsave_hdr {
   __u64 xstate_bv ;
   __u64 reserved1[2] ;
   __u64 reserved2[5] ;
};
struct _ymmh_state {
   __u32 ymmh_space[64] ;
};
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
struct alt_instr {
   u8 *instr ;
   u8 *replacement ;
   u8 cpuid ;
   u8 instrlen ;
   u8 replacementlen ;
   u8 pad1 ;
};
struct module;
struct paravirt_patch_site;
struct __xchg_dummy {
   unsigned long a[100] ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct ratelimit_state {
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   char primary_hash ;
   char secondary_hash ;
   unsigned int lineno : 24 ;
   unsigned int flags : 8 ;
} __attribute__((__aligned__(8))) ;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct user;
struct atomic_notifier_head;
struct pid;
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4,
    SYSTEM_SUSPEND_DISK = 5
} ;
enum __anonenum_10 {
    DUMP_PREFIX_NONE = 0,
    DUMP_PREFIX_ADDRESS = 1,
    DUMP_PREFIX_OFFSET = 2
} ;
struct sysinfo;
struct sysinfo {
   long uptime ;
   unsigned long loads[3] ;
   unsigned long totalram ;
   unsigned long freeram ;
   unsigned long sharedram ;
   unsigned long bufferram ;
   unsigned long totalswap ;
   unsigned long freeswap ;
   unsigned short procs ;
   unsigned short pad ;
   unsigned long totalhigh ;
   unsigned long freehigh ;
   unsigned int mem_unit ;
   char _f[(20UL - 2UL * sizeof(long )) - sizeof(int )] ;
};
struct tss_struct;
struct page;
typedef unsigned long pteval_t;
typedef unsigned long pmdval_t;
typedef unsigned long pudval_t;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
union __anonunion_pte_t_11 {
   pteval_t pte ;
   pteval_t pte_low ;
};
typedef union __anonunion_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct __anonstruct_pud_t_13 {
   pgd_t pgd ;
};
typedef struct __anonstruct_pud_t_13 pud_t;
struct __anonstruct_pmd_t_14 {
   pud_t pud ;
};
typedef struct __anonstruct_pmd_t_14 pmd_t;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
enum __anonenum_15 {
    PG_LEVEL_NONE = 0,
    PG_LEVEL_4K = 1,
    PG_LEVEL_2M = 2,
    PG_LEVEL_1G = 3,
    PG_LEVEL_NUM = 4
} ;
struct __anonstruct____missing_field_name_17 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct____missing_field_name_18 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
union __anonunion____missing_field_name_16 {
   struct __anonstruct____missing_field_name_17 __annonCompField6 ;
   struct __anonstruct____missing_field_name_18 __annonCompField7 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_16 __annonCompField8 ;
} __attribute__((__packed__)) ;
enum __anonenum_19 {
    GATE_INTERRUPT = 14,
    GATE_TRAP = 15,
    GATE_CALL = 12,
    GATE_TASK = 5
} ;
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned int ist : 3 ;
   unsigned int zero0 : 5 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
enum __anonenum_20 {
    DESC_TSS = 9,
    DESC_LDT = 2,
    DESCTYPE_S = 16
} ;
struct ldttss_desc64 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit1 : 4 ;
   unsigned int zero0 : 3 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
   u32 base3 ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
typedef struct desc_struct gate_desc;
typedef struct desc_struct ldt_desc;
typedef struct desc_struct tss_desc;
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
} __attribute__((__packed__)) ;
struct exec_domain;
enum __anonenum_21 {
    ADDR_NO_RANDOMIZE = 262144,
    FDPIC_FUNCPTRS = 524288,
    MMAP_PAGE_ZERO = 1048576,
    ADDR_COMPAT_LAYOUT = 2097152,
    READ_IMPLIES_EXEC = 4194304,
    ADDR_LIMIT_32BIT = 8388608,
    SHORT_INODE = 16777216,
    WHOLE_SECONDS = 33554432,
    STICKY_TIMEOUTS = 67108864,
    ADDR_LIMIT_3GB = 134217728
} ;
enum __anonenum_22 {
    PER_LINUX = 0,
    PER_LINUX_32BIT = 8388608,
    PER_LINUX_FDPIC = 524288,
    PER_SVR4 = 68157441,
    PER_SVR3 = 83886082,
    PER_SCOSVR3 = 117440515,
    PER_OSR5 = 100663299,
    PER_WYSEV386 = 83886084,
    PER_ISCR4 = 67108869,
    PER_BSD = 6,
    PER_SUNOS = 67108870,
    PER_XENIX = 83886087,
    PER_LINUX32 = 8,
    PER_LINUX32_3GB = 134217736,
    PER_IRIX32 = 67108873,
    PER_IRIXN32 = 67108874,
    PER_IRIX64 = 67108875,
    PER_RISCOS = 12,
    PER_SOLARIS = 67108877,
    PER_UW7 = 68157454,
    PER_OSF4 = 15,
    PER_HPUX = 16,
    PER_MASK = 255
} ;
typedef void (*handler_t)(int  , struct pt_regs * );
struct map_segment;
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
struct cpumask {
   unsigned long bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask cpumask_var_t[1];
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   char wp_works_ok ;
   char hlt_works_ok ;
   char hard_math ;
   char rfu ;
   char fdiv_bug ;
   char f00f_bug ;
   char coma_bug ;
   char pad0 ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[9] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   cpumask_var_t llc_shared_map ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u16 cpu_index ;
   unsigned int x86_hyper_vendor ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct seq_operations;
struct x86_hw_tss {
   unsigned short back_link ;
   unsigned short __blh ;
   unsigned long sp0 ;
   unsigned short ss0 ;
   unsigned short __ss0h ;
   unsigned long sp1 ;
   unsigned short ss1 ;
   unsigned short __ss1h ;
   unsigned long sp2 ;
   unsigned short ss2 ;
   unsigned short __ss2h ;
   unsigned long __cr3 ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long bx ;
   unsigned long sp ;
   unsigned long bp ;
   unsigned long si ;
   unsigned long di ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short ldt ;
   unsigned short __ldth ;
   unsigned short trace ;
   unsigned short io_bitmap_base ;
} __attribute__((__packed__)) ;
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[8192UL / sizeof(long ) + 1UL] ;
   unsigned long stack[64] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct orig_ist {
   unsigned long ist[7] ;
};
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_24 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_25 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_23 {
   struct __anonstruct____missing_field_name_24 __annonCompField9 ;
   struct __anonstruct____missing_field_name_25 __annonCompField10 ;
};
union __anonunion____missing_field_name_26 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_23 __annonCompField11 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_26 __annonCompField12 ;
} __attribute__((__aligned__(16))) ;
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
} __attribute__((__packed__, __aligned__(64))) ;
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
struct kmem_cache;
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long sysenter_cs ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_sp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
};
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct stat {
   unsigned long st_dev ;
   unsigned long st_ino ;
   unsigned long st_nlink ;
   unsigned int st_mode ;
   unsigned int st_uid ;
   unsigned int st_gid ;
   unsigned int __pad0 ;
   unsigned long st_rdev ;
   long st_size ;
   long st_blksize ;
   long st_blocks ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned long st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   long __unused[3] ;
};
struct __old_kernel_stat {
   unsigned short st_dev ;
   unsigned short st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned short st_rdev ;
   unsigned int st_size ;
   unsigned int st_atime ;
   unsigned int st_mtime ;
   unsigned int st_ctime ;
};
struct timespec;
struct compat_timespec;
struct __anonstruct____missing_field_name_29 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
struct __anonstruct_futex_30 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
struct __anonstruct_nanosleep_31 {
   clockid_t index ;
   struct timespec *rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_32 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField13 ;
   struct __anonstruct_futex_30 futex ;
   struct __anonstruct_nanosleep_31 nanosleep ;
   struct __anonstruct_poll_32 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
};
typedef atomic_t atomic_long_t;
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
   int uaccess_err ;
};
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_raw_rwlock_t_33 {
   unsigned int lock ;
};
typedef struct __anonstruct_raw_rwlock_t_33 raw_rwlock_t;
struct lockdep_map;
struct lock_class_key {

};
struct __anonstruct_spinlock_t_34 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_34 spinlock_t;
struct __anonstruct_rwlock_t_35 {
   raw_rwlock_t raw_lock ;
};
typedef struct __anonstruct_rwlock_t_35 rwlock_t;
struct __anonstruct_seqlock_t_36 {
   unsigned int sequence ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_36 seqlock_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
union __anonunion_d_37 {
   u64 v64 ;
   u32 v32[2] ;
};
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
struct itimerval;
struct tms;
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key );
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
struct wait_bit_key {
   void *flags ;
   int bit_nr ;
};
struct wait_bit_queue {
   struct wait_bit_key key ;
   wait_queue_t wait ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_38 {
   unsigned long bits[((1UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct __anonstruct_nodemask_t_38 nodemask_t;
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
} ;
enum pageblock_bits {
    PB_migrate = 0,
    PB_migrate_end = 2,
    NR_PAGEBLOCK_BITS = 3
} ;
struct free_area {
   struct list_head free_list[5] ;
   unsigned long nr_free ;
};
struct pglist_data;
struct zone_padding {
   char x[0] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum zone_stat_item {
    NR_FREE_PAGES = 0,
    NR_LRU_BASE = 1,
    NR_INACTIVE_ANON = 1,
    NR_ACTIVE_ANON = 2,
    NR_INACTIVE_FILE = 3,
    NR_ACTIVE_FILE = 4,
    NR_UNEVICTABLE = 5,
    NR_MLOCK = 6,
    NR_ANON_PAGES = 7,
    NR_FILE_MAPPED = 8,
    NR_FILE_PAGES = 9,
    NR_FILE_DIRTY = 10,
    NR_WRITEBACK = 11,
    NR_SLAB_RECLAIMABLE = 12,
    NR_SLAB_UNRECLAIMABLE = 13,
    NR_PAGETABLE = 14,
    NR_UNSTABLE_NFS = 15,
    NR_BOUNCE = 16,
    NR_VMSCAN_WRITE = 17,
    NR_WRITEBACK_TEMP = 18,
    NR_VM_ZONE_STAT_ITEMS = 19
} ;
enum lru_list {
    LRU_INACTIVE_ANON = 0,
    LRU_ACTIVE_ANON = 1,
    LRU_INACTIVE_FILE = 2,
    LRU_ACTIVE_FILE = 3,
    LRU_UNEVICTABLE = 4,
    NR_LRU_LISTS = 5
} ;
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head list ;
};
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 stat_threshold ;
   s8 vm_stat_diff[19] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum zone_type {
    ZONE_DMA = 0,
    ZONE_NORMAL = 1,
    ZONE_HIGHMEM = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
struct zone_reclaim_stat {
   unsigned long recent_rotated[2] ;
   unsigned long recent_scanned[2] ;
};
struct __anonstruct_lru_39 {
   struct list_head list ;
   unsigned long nr_scan ;
};
struct zone {
   unsigned long pages_min ;
   unsigned long pages_low ;
   unsigned long pages_high ;
   unsigned long lowmem_reserve[4] ;
   struct per_cpu_pageset pageset[8] ;
   spinlock_t lock ;
   struct free_area free_area[11] ;
   unsigned long *pageblock_flags ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   struct __anonstruct_lru_39 lru[5] ;
   struct zone_reclaim_stat reclaim_stat ;
   unsigned long pages_scanned ;
   unsigned long flags ;
   atomic_long_t vm_stat[19] ;
   int prev_priority ;
   unsigned int inactive_ratio ;
   struct zone_padding _pad2_ ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct pglist_data *zone_pgdat ;
   unsigned long zone_start_pfn ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum __anonenum_zone_flags_t_40 {
    ZONE_ALL_UNRECLAIMABLE = 0,
    ZONE_RECLAIM_LOCKED = 1,
    ZONE_OOM_LOCKED = 2
} ;
typedef enum __anonenum_zone_flags_t_40 zone_flags_t;
struct zonelist_cache;
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[5] ;
};
struct node_active_region {
   unsigned long start_pfn ;
   unsigned long end_pfn ;
   int nid ;
};
struct bootmem_data;
struct pglist_data {
   struct zone node_zones[4] ;
   struct zonelist node_zonelists[1] ;
   int nr_zones ;
   struct page *node_mem_map ;
   struct bootmem_data *bdata ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
};
typedef struct pglist_data pg_data_t;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
};
struct rw_semaphore;
struct rwsem_waiter;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct srcu_struct_array {
   int c[2] ;
};
struct srcu_struct {
   int completed ;
   struct srcu_struct_array *per_cpu_ref ;
   struct mutex mutex ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct atomic_notifier_head {
   spinlock_t lock ;
   struct notifier_block *head ;
};
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
struct raw_notifier_head {
   struct notifier_block *head ;
};
struct srcu_notifier_head {
   struct mutex mutex ;
   struct srcu_struct srcu ;
   struct notifier_block *head ;
};
struct mem_section;
enum memmap_context {
    MEMMAP_EARLY = 0,
    MEMMAP_HOTPLUG = 1
} ;
struct ctl_table;
struct call_single_data {
   struct list_head list ;
   void (*func)(void *info ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
struct mpf_intel {
   char signature[4] ;
   unsigned int physptr ;
   unsigned char length ;
   unsigned char specification ;
   unsigned char checksum ;
   unsigned char feature1 ;
   unsigned char feature2 ;
   unsigned char feature3 ;
   unsigned char feature4 ;
   unsigned char feature5 ;
};
struct mpc_table {
   char signature[4] ;
   unsigned short length ;
   char spec ;
   char checksum ;
   char oem[8] ;
   char productid[12] ;
   unsigned int oemptr ;
   unsigned short oemsize ;
   unsigned short oemcount ;
   unsigned int lapic ;
   unsigned int reserved ;
};
struct mpc_cpu {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char cpuflag ;
   unsigned int cpufeature ;
   unsigned int featureflag ;
   unsigned int reserved[2] ;
};
struct mpc_bus {
   unsigned char type ;
   unsigned char busid ;
   unsigned char bustype[6] ;
};
struct mpc_ioapic {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char flags ;
   unsigned int apicaddr ;
};
struct mpc_intsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbus ;
   unsigned char srcbusirq ;
   unsigned char dstapic ;
   unsigned char dstirq ;
};
enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3
} ;
struct mpc_lintsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbusid ;
   unsigned char srcbusirq ;
   unsigned char destapic ;
   unsigned char destapiclint ;
};
struct mpc_oemtable {
   char signature[4] ;
   unsigned short length ;
   char rev ;
   char checksum ;
   char mpc[8] ;
};
enum mp_bustype {
    MP_BUS_ISA = 1,
    MP_BUS_EISA = 2,
    MP_BUS_PCI = 3,
    MP_BUS_MCA = 4
} ;
struct physid_mask {
   unsigned long mask[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct physid_mask physid_mask_t;
struct device;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3
} ;
struct __anonstruct___reserved_01_41 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_02_42 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_id_43 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_apic_id : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_version_44 {
   unsigned int version : 8 ;
   unsigned int __reserved_1 : 8 ;
   unsigned int max_lvt : 8 ;
   unsigned int __reserved_2 : 8 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_03_45 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_04_46 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_05_47 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_06_48 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_tpr_49 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_apr_50 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_ppr_51 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_eoi_52 {
   unsigned int eoi ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_07_53 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_ldr_54 {
   unsigned int __reserved_1 : 24 ;
   unsigned int logical_dest : 8 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_dfr_55 {
   unsigned int __reserved_1 : 28 ;
   unsigned int model : 4 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_svr_56 {
   unsigned int spurious_vector : 8 ;
   unsigned int apic_enabled : 1 ;
   unsigned int focus_cpu : 1 ;
   unsigned int __reserved_2 : 22 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_isr_57 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_tmr_58 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_irr_59 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_error_bits_61 {
   unsigned int send_cs_error : 1 ;
   unsigned int receive_cs_error : 1 ;
   unsigned int send_accept_error : 1 ;
   unsigned int receive_accept_error : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int send_illegal_vector : 1 ;
   unsigned int receive_illegal_vector : 1 ;
   unsigned int illegal_register_address : 1 ;
   unsigned int __reserved_2 : 24 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_all_errors_62 {
   unsigned int errors ;
   unsigned int __reserved_3[3] ;
};
union __anonunion_esr_60 {
   struct __anonstruct_error_bits_61 error_bits ;
   struct __anonstruct_all_errors_62 all_errors ;
};
struct __anonstruct___reserved_08_63 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_09_64 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_10_65 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_11_66 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_12_67 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_13_68 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_14_69 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_icr1_70 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int destination_mode : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int level : 1 ;
   unsigned int trigger : 1 ;
   unsigned int __reserved_2 : 2 ;
   unsigned int shorthand : 2 ;
   unsigned int __reserved_3 : 12 ;
   unsigned int __reserved_4[3] ;
};
union __anonunion_dest_72 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_dest : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved_3 : 24 ;
   unsigned int logical_dest : 8 ;
};
struct __anonstruct_icr2_71 {
   union __anonunion_dest_72 dest ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_timer_73 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int timer_mode : 1 ;
   unsigned int __reserved_3 : 14 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_thermal_74 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_pc_75 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_lint0_76 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_lint1_77 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_error_78 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_timer_icr_79 {
   unsigned int initial_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_timer_ccr_80 {
   unsigned int curr_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_16_81 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_17_82 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_18_83 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_19_84 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_timer_dcr_85 {
   unsigned int divisor : 4 ;
   unsigned int __reserved_1 : 28 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_20_86 {
   unsigned int __reserved[4] ;
};
struct local_apic {
   struct __anonstruct___reserved_01_41 __reserved_01 ;
   struct __anonstruct___reserved_02_42 __reserved_02 ;
   struct __anonstruct_id_43 id ;
   struct __anonstruct_version_44  const  version ;
   struct __anonstruct___reserved_03_45 __reserved_03 ;
   struct __anonstruct___reserved_04_46 __reserved_04 ;
   struct __anonstruct___reserved_05_47 __reserved_05 ;
   struct __anonstruct___reserved_06_48 __reserved_06 ;
   struct __anonstruct_tpr_49 tpr ;
   struct __anonstruct_apr_50  const  apr ;
   struct __anonstruct_ppr_51  const  ppr ;
   struct __anonstruct_eoi_52 eoi ;
   struct __anonstruct___reserved_07_53 __reserved_07 ;
   struct __anonstruct_ldr_54 ldr ;
   struct __anonstruct_dfr_55 dfr ;
   struct __anonstruct_svr_56 svr ;
   struct __anonstruct_isr_57 isr[8] ;
   struct __anonstruct_tmr_58 tmr[8] ;
   struct __anonstruct_irr_59 irr[8] ;
   union __anonunion_esr_60 esr ;
   struct __anonstruct___reserved_08_63 __reserved_08 ;
   struct __anonstruct___reserved_09_64 __reserved_09 ;
   struct __anonstruct___reserved_10_65 __reserved_10 ;
   struct __anonstruct___reserved_11_66 __reserved_11 ;
   struct __anonstruct___reserved_12_67 __reserved_12 ;
   struct __anonstruct___reserved_13_68 __reserved_13 ;
   struct __anonstruct___reserved_14_69 __reserved_14 ;
   struct __anonstruct_icr1_70 icr1 ;
   struct __anonstruct_icr2_71 icr2 ;
   struct __anonstruct_lvt_timer_73 lvt_timer ;
   struct __anonstruct_lvt_thermal_74 lvt_thermal ;
   struct __anonstruct_lvt_pc_75 lvt_pc ;
   struct __anonstruct_lvt_lint0_76 lvt_lint0 ;
   struct __anonstruct_lvt_lint1_77 lvt_lint1 ;
   struct __anonstruct_lvt_error_78 lvt_error ;
   struct __anonstruct_timer_icr_79 timer_icr ;
   struct __anonstruct_timer_ccr_80  const  timer_ccr ;
   struct __anonstruct___reserved_16_81 __reserved_16 ;
   struct __anonstruct___reserved_17_82 __reserved_17 ;
   struct __anonstruct___reserved_18_83 __reserved_18 ;
   struct __anonstruct___reserved_19_84 __reserved_19 ;
   struct __anonstruct_timer_dcr_85 timer_dcr ;
   struct __anonstruct___reserved_20_86 __reserved_20 ;
} __attribute__((__packed__)) ;
struct __anonstruct_mm_context_t_87 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_87 mm_context_t;
struct bootnode;
enum km_type {
    KM_BOUNCE_READ = 0,
    KM_SKB_SUNRPC_DATA = 1,
    KM_SKB_DATA_SOFTIRQ = 2,
    KM_USER0 = 3,
    KM_USER1 = 4,
    KM_BIO_SRC_IRQ = 5,
    KM_BIO_DST_IRQ = 6,
    KM_PTE0 = 7,
    KM_PTE1 = 8,
    KM_IRQ0 = 9,
    KM_IRQ1 = 10,
    KM_SOFTIRQ0 = 11,
    KM_SOFTIRQ1 = 12,
    KM_TYPE_NR = 13
} ;
enum fixed_addresses {
    FIX_HOLE = 0,
    FIX_VDSO = 1,
    FIX_DBGP_BASE = 2,
    FIX_EARLYCON_MEM_BASE = 3,
    FIX_APIC_BASE = 4,
    FIX_IO_APIC_BASE_0 = 5,
    FIX_IO_APIC_BASE_END = 68,
    FIX_KMAP_BEGIN = 69,
    FIX_KMAP_END = 172,
    FIX_PCIE_MCFG = 173,
    FIX_TEXT_POKE0 = 174,
    FIX_TEXT_POKE1 = 175,
    __end_of_permanent_fixed_addresses = 176,
    FIX_OHCI1394_BASE = 177,
    FIX_BTMAP_END = 256,
    FIX_BTMAP_BEGIN = 511,
    FIX_WP_TEST = 512,
    __end_of_fixed_addresses = 513
} ;
struct apic {
   char *name ;
   int (*probe)(void) ;
   int (*acpi_madt_oem_check)(char *oem_id , char *oem_table_id ) ;
   int (*apic_id_registered)(void) ;
   u32 irq_delivery_mode ;
   u32 irq_dest_mode ;
   struct cpumask  const  *(*target_cpus)(void) ;
   int disable_esr ;
   int dest_logical ;
   unsigned long (*check_apicid_used)(physid_mask_t bitmap , int apicid ) ;
   unsigned long (*check_apicid_present)(int apicid ) ;
   void (*vector_allocation_domain)(int cpu , struct cpumask *retmask ) ;
   void (*init_apic_ldr)(void) ;
   physid_mask_t (*ioapic_phys_id_map)(physid_mask_t map ) ;
   void (*setup_apic_routing)(void) ;
   int (*multi_timer_check)(int apic , int irq ) ;
   int (*apicid_to_node)(int logical_apicid ) ;
   int (*cpu_to_logical_apicid)(int cpu ) ;
   int (*cpu_present_to_apicid)(int mps_cpu ) ;
   physid_mask_t (*apicid_to_cpu_present)(int phys_apicid ) ;
   void (*setup_portio_remap)(void) ;
   int (*check_phys_apicid_present)(int boot_cpu_physical_apicid ) ;
   void (*enable_apic_mode)(void) ;
   int (*phys_pkg_id)(int cpuid_apic , int index_msb ) ;
   int (*mps_oem_check)(struct mpc_table *mpc , char *oem , char *productid ) ;
   unsigned int (*get_apic_id)(unsigned long x ) ;
   unsigned long (*set_apic_id)(unsigned int id ) ;
   unsigned long apic_id_mask ;
   unsigned int (*cpu_mask_to_apicid)(struct cpumask  const  *cpumask ) ;
   unsigned int (*cpu_mask_to_apicid_and)(struct cpumask  const  *cpumask , struct cpumask  const  *andmask ) ;
   void (*send_IPI_mask)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_mask_allbutself)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_allbutself)(int vector ) ;
   void (*send_IPI_all)(int vector ) ;
   void (*send_IPI_self)(int vector ) ;
   int (*wakeup_secondary_cpu)(int apicid , unsigned long start_eip ) ;
   int trampoline_phys_low ;
   int trampoline_phys_high ;
   void (*wait_for_init_deassert)(atomic_t *deassert ) ;
   void (*smp_callin_clear_local_apic)(void) ;
   void (*inquire_remote_apic)(int apicid ) ;
   u32 (*read)(u32 reg ) ;
   void (*write)(u32 reg , u32 v ) ;
   u64 (*icr_read)(void) ;
   void (*icr_write)(u32 low , u32 high ) ;
   void (*wait_icr_idle)(void) ;
   u32 (*safe_wait_icr_idle)(void) ;
};
struct __anonstruct_bits_88 {
   u32 __reserved_2 : 14 ;
   u32 LTS : 1 ;
   u32 delivery_type : 1 ;
   u32 __reserved_1 : 8 ;
   u32 ID : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_00 {
   u32 raw ;
   struct __anonstruct_bits_88 bits ;
};
struct __anonstruct_bits_89 {
   u32 version : 8 ;
   u32 __reserved_2 : 7 ;
   u32 PRQ : 1 ;
   u32 entries : 8 ;
   u32 __reserved_1 : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_01 {
   u32 raw ;
   struct __anonstruct_bits_89 bits ;
};
struct __anonstruct_bits_90 {
   u32 __reserved_2 : 24 ;
   u32 arbitration : 4 ;
   u32 __reserved_1 : 4 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_02 {
   u32 raw ;
   struct __anonstruct_bits_90 bits ;
};
struct __anonstruct_bits_91 {
   u32 boot_DT : 1 ;
   u32 __reserved_1 : 31 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_03 {
   u32 raw ;
   struct __anonstruct_bits_91 bits ;
};
enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7
} ;
struct IO_APIC_route_entry {
   __u32 vector : 8 ;
   __u32 delivery_mode : 3 ;
   __u32 dest_mode : 1 ;
   __u32 delivery_status : 1 ;
   __u32 polarity : 1 ;
   __u32 irr : 1 ;
   __u32 trigger : 1 ;
   __u32 mask : 1 ;
   __u32 __reserved_2 : 15 ;
   __u32 __reserved_3 : 24 ;
   __u32 dest : 8 ;
} __attribute__((__packed__)) ;
struct IR_IO_APIC_route_entry {
   __u64 vector : 8 ;
   __u64 zero : 3 ;
   __u64 index2 : 1 ;
   __u64 delivery_status : 1 ;
   __u64 polarity : 1 ;
   __u64 irr : 1 ;
   __u64 trigger : 1 ;
   __u64 mask : 1 ;
   __u64 reserved : 31 ;
   __u64 format : 1 ;
   __u64 index : 15 ;
} __attribute__((__packed__)) ;
struct __anonstruct_stack_start_92 {
   void *sp ;
   unsigned short ss ;
};
struct smp_ops {
   void (*smp_prepare_boot_cpu)(void) ;
   void (*smp_prepare_cpus)(unsigned int max_cpus ) ;
   void (*smp_cpus_done)(unsigned int max_cpus ) ;
   void (*smp_send_stop)(void) ;
   void (*smp_send_reschedule)(int cpu ) ;
   int (*cpu_up)(unsigned int cpu ) ;
   int (*cpu_disable)(void) ;
   void (*cpu_die)(unsigned int cpu ) ;
   void (*play_dead)(void) ;
   void (*send_call_func_ipi)(struct cpumask  const  *mask ) ;
   void (*send_call_func_single_ipi)(int cpu ) ;
};
struct pci_bus;
struct vm_area_struct;
struct key;
struct subprocess_info;
enum umh_wait {
    UMH_NO_WAIT = -1,
    UMH_WAIT_EXEC = 0,
    UMH_WAIT_PROC = 1
} ;
struct user_i387_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
};
struct user_fxsr_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long reserved ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
};
struct user_regs_struct {
   unsigned long bx ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long bp ;
   unsigned long ax ;
   unsigned long ds ;
   unsigned long es ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   struct user_i387_struct i387 ;
   unsigned long u_tsize ;
   unsigned long u_dsize ;
   unsigned long u_ssize ;
   unsigned long start_code ;
   unsigned long start_stack ;
   long signal ;
   int reserved ;
   unsigned long u_ar0 ;
   struct user_i387_struct *u_fpstate ;
   unsigned long magic ;
   char u_comm[32] ;
   int u_debugreg[8] ;
};
typedef unsigned long elf_greg_t;
typedef elf_greg_t elf_gregset_t[sizeof(struct user_regs_struct ) / sizeof(elf_greg_t )];
typedef struct user_i387_struct elf_fpregset_t;
struct user_desc {
   unsigned int entry_number ;
   unsigned int base_addr ;
   unsigned int limit ;
   unsigned int seg_32bit : 1 ;
   unsigned int contents : 2 ;
   unsigned int read_exec_only : 1 ;
   unsigned int limit_in_pages : 1 ;
   unsigned int seg_not_present : 1 ;
   unsigned int useable : 1 ;
   unsigned int lm : 1 ;
};
struct gdt_page {
   struct desc_struct gdt[32] ;
} __attribute__((__aligned__((1) <<  (12) ))) ;
struct linux_binprm;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Off;
typedef __s32 Elf32_Sword;
typedef __u32 Elf32_Word;
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __s16 Elf64_SHalf;
typedef __u64 Elf64_Off;
typedef __s32 Elf64_Sword;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
typedef __s64 Elf64_Sxword;
union __anonunion_d_un_93 {
   Elf32_Sword d_val ;
   Elf32_Addr d_ptr ;
};
struct dynamic {
   Elf32_Sword d_tag ;
   union __anonunion_d_un_93 d_un ;
};
typedef struct dynamic Elf32_Dyn;
union __anonunion_d_un_95 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
struct __anonstruct_Elf64_Dyn_94 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_95 d_un ;
};
typedef struct __anonstruct_Elf64_Dyn_94 Elf64_Dyn;
struct elf32_rel {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
typedef struct elf32_rel Elf32_Rel;
struct elf64_rel {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
};
typedef struct elf64_rel Elf64_Rel;
struct elf32_rela {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
   Elf32_Sword r_addend ;
};
typedef struct elf32_rela Elf32_Rela;
struct elf64_rela {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
typedef struct elf64_rela Elf64_Rela;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
typedef struct elf32_hdr Elf32_Ehdr;
struct elf64_hdr {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
typedef struct elf64_hdr Elf64_Ehdr;
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
typedef struct elf32_phdr Elf32_Phdr;
struct elf64_phdr {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
typedef struct elf64_phdr Elf64_Phdr;
struct __anonstruct_Elf32_Shdr_96 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
typedef struct __anonstruct_Elf32_Shdr_96 Elf32_Shdr;
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
typedef struct elf64_shdr Elf64_Shdr;
struct elf32_note {
   Elf32_Word n_namesz ;
   Elf32_Word n_descsz ;
   Elf32_Word n_type ;
};
typedef struct elf32_note Elf32_Nhdr;
struct elf64_note {
   Elf64_Word n_namesz ;
   Elf64_Word n_descsz ;
   Elf64_Word n_type ;
};
typedef struct elf64_note Elf64_Nhdr;
struct kobject;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct sysfs_dirent;
struct kref {
   atomic_t refcount ;
};
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kobj_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct kobject *kobj , struct kobj_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct kobject *kobj , struct kobj_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct kernel_param;
typedef int (*param_set_fn)(char const   *val , struct kernel_param *kp );
typedef int (*param_get_fn)(char *buffer , struct kernel_param *kp );
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_97 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_97 __annonCompField15 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
struct marker;
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
struct rcu_dynticks {
   int dynticks_nesting ;
   int dynticks ;
   int dynticks_nmi ;
};
struct rcu_node {
   spinlock_t lock ;
   unsigned long qsmask ;
   unsigned long qsmaskinit ;
   unsigned long grpmask ;
   int grplo ;
   int grphi ;
   u8 grpnum ;
   u8 level ;
   struct rcu_node *parent ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct rcu_data {
   long completed ;
   long gpnum ;
   long passed_quiesc_completed ;
   bool passed_quiesc ;
   bool qs_pending ;
   bool beenonline ;
   struct rcu_node *mynode ;
   unsigned long grpmask ;
   struct rcu_head *nxtlist ;
   struct rcu_head **nxttail[4] ;
   long qlen ;
   long blimit ;
   struct rcu_dynticks *dynticks ;
   int dynticks_snap ;
   int dynticks_nmi_snap ;
   unsigned long dynticks_fqs ;
   unsigned long offline_fqs ;
   unsigned long resched_ipi ;
   long n_rcu_pending ;
   int cpu ;
};
struct rcu_state {
   struct rcu_node node[1] ;
   struct rcu_node *level[1] ;
   u32 levelcnt[4] ;
   u8 levelspread[1] ;
   struct rcu_data *rda[8] ;
   u8 signaled  __attribute__((__aligned__((1) <<  (5) ))) ;
   long gpnum ;
   long completed ;
   spinlock_t onofflock ;
   spinlock_t fqslock ;
   unsigned long jiffies_force_qs ;
   unsigned long n_force_qs ;
   unsigned long n_force_qs_lh ;
   unsigned long n_force_qs_ngp ;
   long dynticks_completed ;
};
struct rcu_synchronize {
   struct rcu_head head ;
   struct completion completion ;
};
struct tracepoint;
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
struct tracepoint_iter {
   struct module *module ;
   struct tracepoint *tracepoint ;
};
struct timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
typedef unsigned long long cycles_t;
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
enum debug_obj_state {
    ODEBUG_STATE_NONE = 0,
    ODEBUG_STATE_INIT = 1,
    ODEBUG_STATE_INACTIVE = 2,
    ODEBUG_STATE_ACTIVE = 3,
    ODEBUG_STATE_DESTROYED = 4,
    ODEBUG_STATE_NOTAVAILABLE = 5,
    ODEBUG_STATE_MAX = 6
} ;
struct debug_obj_descr;
struct debug_obj {
   struct hlist_node node ;
   enum debug_obj_state state ;
   void *object ;
   struct debug_obj_descr *descr ;
};
struct debug_obj_descr {
   char const   *name ;
   int (*fixup_init)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_activate)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_destroy)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_free)(void *addr , enum debug_obj_state state ) ;
};
struct tvec_base;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
   void *start_site ;
   char start_comm[16] ;
   int start_pid ;
};
struct hrtimer;
enum hrtimer_restart;
struct workqueue_struct;
struct work_struct;
typedef void (*work_func_t)(struct work_struct *work );
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
struct execute_work {
   struct work_struct work ;
};
enum stat_item {
    ALLOC_FASTPATH = 0,
    ALLOC_SLOWPATH = 1,
    FREE_FASTPATH = 2,
    FREE_SLOWPATH = 3,
    FREE_FROZEN = 4,
    FREE_ADD_PARTIAL = 5,
    FREE_REMOVE_PARTIAL = 6,
    ALLOC_FROM_PARTIAL = 7,
    ALLOC_SLAB = 8,
    ALLOC_REFILL = 9,
    FREE_SLAB = 10,
    CPUSLAB_FLUSH = 11,
    DEACTIVATE_FULL = 12,
    DEACTIVATE_EMPTY = 13,
    DEACTIVATE_TO_HEAD = 14,
    DEACTIVATE_TO_TAIL = 15,
    DEACTIVATE_REMOTE_FREES = 16,
    ORDER_FALLBACK = 17,
    NR_SLUB_STAT_ITEMS = 18
} ;
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   unsigned long min_partial ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct kmem_cache_cpu *cpu_slab[8] ;
};
typedef struct page *(*pcpu_get_page_fn_t)(unsigned int cpu , int pageno );
typedef void (*pcpu_populate_pte_fn_t)(unsigned long addr );
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_98 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct modversion_info {
   unsigned long crc ;
   char name[64UL - sizeof(unsigned long )] ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   char const   **trace_bprintk_fmt_start ;
   unsigned int num_trace_bprintk_fmt ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
enum __anonenum_licence_99 {
    NOT_GPL_ONLY = 0,
    GPL_ONLY = 1,
    WILL_BE_GPL_ONLY = 2
} ;
struct symsearch {
   struct kernel_symbol  const  *start ;
   struct kernel_symbol  const  *stop ;
   unsigned long const   *crcs ;
   enum __anonenum_licence_99 licence ;
   bool unused ;
};
struct device_driver;
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct resource_list {
   struct resource_list *next ;
   struct resource *res ;
   struct pci_dev *dev ;
};
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct klist_iter {
   struct klist *i_klist ;
   struct klist_node *i_cur ;
};
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device_private;
struct driver_private;
struct class;
struct class_private;
struct bus_type;
struct bus_type_private;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
struct device_type;
struct class_dev_iter {
   struct klist_iter ki ;
   struct device_type  const  *type ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
struct class_interface {
   struct list_head node ;
   struct class *class ;
   int (*add_dev)(struct device * , struct class_interface * ) ;
   void (*remove_dev)(struct device * , struct class_interface * ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
typedef void (*dr_release_t)(struct device *dev , void *res );
typedef int (*dr_match_t)(struct device *dev , void *res , void *match_data );
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct rb_root {
   struct rb_node *rb_node ;
};
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
struct prio_tree_iter {
   struct prio_tree_node *cur ;
   unsigned long mask ;
   unsigned long value ;
   int size_level ;
   struct prio_tree_root *root ;
   unsigned long r_index ;
   unsigned long h_index ;
};
enum page_debug_flags {
    PAGE_DEBUG_FLAG_POISON = 0
} ;
struct address_space;
typedef atomic_long_t mm_counter_t;
struct __anonstruct____missing_field_name_101 {
   u16 inuse ;
   u16 objects ;
};
union __anonunion____missing_field_name_100 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_101 __annonCompField16 ;
};
struct __anonstruct____missing_field_name_103 {
   unsigned long private ;
   struct address_space *mapping ;
};
union __anonunion____missing_field_name_102 {
   struct __anonstruct____missing_field_name_103 __annonCompField18 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
union __anonunion____missing_field_name_104 {
   unsigned long index ;
   void *freelist ;
};
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_100 __annonCompField17 ;
   union __anonunion____missing_field_name_102 __annonCompField19 ;
   union __anonunion____missing_field_name_104 __annonCompField20 ;
   struct list_head lru ;
};
struct vm_region {
   struct rb_node vm_rb ;
   unsigned long vm_flags ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   unsigned long vm_top ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   atomic_t vm_usage ;
};
struct __anonstruct_vm_set_106 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_105 {
   struct __anonstruct_vm_set_106 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct vm_operations_struct;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_105 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[42] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
struct mempolicy;
struct file_ra_state;
struct user_struct;
struct writeback_control;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
};
struct mmu_gather;
struct inode;
enum pageflags {
    PG_locked = 0,
    PG_error = 1,
    PG_referenced = 2,
    PG_uptodate = 3,
    PG_dirty = 4,
    PG_lru = 5,
    PG_active = 6,
    PG_slab = 7,
    PG_owner_priv_1 = 8,
    PG_arch_1 = 9,
    PG_reserved = 10,
    PG_private = 11,
    PG_private_2 = 12,
    PG_writeback = 13,
    PG_head = 14,
    PG_tail = 15,
    PG_swapcache = 16,
    PG_mappedtodisk = 17,
    PG_reclaim = 18,
    PG_buddy = 19,
    PG_swapbacked = 20,
    PG_unevictable = 21,
    PG_mlocked = 22,
    __NR_PAGEFLAGS = 23,
    PG_checked = 8,
    PG_fscache = 12,
    PG_pinned = 8,
    PG_savepinned = 4,
    PG_slob_page = 6,
    PG_slob_free = 11,
    PG_slub_frozen = 6,
    PG_slub_debug = 1
} ;
typedef void compound_page_dtor(struct page * );
enum vm_event_item {
    PGPGIN = 0,
    PGPGOUT = 1,
    PSWPIN = 2,
    PSWPOUT = 3,
    PGALLOC_DMA = 4,
    PGALLOC_NORMAL = 5,
    PGALLOC_HIGH = 6,
    PGALLOC_MOVABLE = 7,
    PGFREE = 8,
    PGACTIVATE = 9,
    PGDEACTIVATE = 10,
    PGFAULT = 11,
    PGMAJFAULT = 12,
    PGREFILL_DMA = 13,
    PGREFILL_NORMAL = 14,
    PGREFILL_HIGH = 15,
    PGREFILL_MOVABLE = 16,
    PGSTEAL_DMA = 17,
    PGSTEAL_NORMAL = 18,
    PGSTEAL_HIGH = 19,
    PGSTEAL_MOVABLE = 20,
    PGSCAN_KSWAPD_DMA = 21,
    PGSCAN_KSWAPD_NORMAL = 22,
    PGSCAN_KSWAPD_HIGH = 23,
    PGSCAN_KSWAPD_MOVABLE = 24,
    PGSCAN_DIRECT_DMA = 25,
    PGSCAN_DIRECT_NORMAL = 26,
    PGSCAN_DIRECT_HIGH = 27,
    PGSCAN_DIRECT_MOVABLE = 28,
    PGINODESTEAL = 29,
    SLABS_SCANNED = 30,
    KSWAPD_STEAL = 31,
    KSWAPD_INODESTEAL = 32,
    PAGEOUTRUN = 33,
    ALLOCSTALL = 34,
    PGROTATED = 35,
    HTLB_BUDDY_PGALLOC = 36,
    HTLB_BUDDY_PGALLOC_FAIL = 37,
    UNEVICTABLE_PGCULLED = 38,
    UNEVICTABLE_PGSCANNED = 39,
    UNEVICTABLE_PGRESCUED = 40,
    UNEVICTABLE_PGMLOCKED = 41,
    UNEVICTABLE_PGMUNLOCKED = 42,
    UNEVICTABLE_PGCLEARED = 43,
    UNEVICTABLE_PGSTRANDED = 44,
    UNEVICTABLE_MLOCKFREED = 45,
    NR_VM_EVENT_ITEMS = 46
} ;
struct vm_event_state {
   unsigned long event[46] ;
};
struct zap_details {
   struct vm_area_struct *nonlinear_vma ;
   struct address_space *check_mapping ;
   unsigned long first_index ;
   unsigned long last_index ;
   spinlock_t *i_mmap_lock ;
   unsigned long truncate_count ;
};
struct mm_walk {
   int (*pgd_entry)(pgd_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pud_entry)(pud_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pmd_entry)(pmd_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pte_entry)(pte_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pte_hole)(unsigned long  , unsigned long  , struct mm_walk * ) ;
   struct mm_struct *mm ;
   void *private ;
};
struct shrinker {
   int (*shrink)(int nr_to_scan , gfp_t gfp_mask ) ;
   int seeks ;
   struct list_head list ;
   long nr ;
};
typedef int (*work_fn_t)(unsigned long  , unsigned long  , void * );
typedef int (*pte_fn_t)(pte_t *pte , pgtable_t token , unsigned long addr , void *data );
struct vm_struct {
   struct vm_struct *next ;
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   unsigned long phys_addr ;
   void *caller ;
};
enum bug_trap_type {
    BUG_TRAP_TYPE_NONE = 0,
    BUG_TRAP_TYPE_WARN = 1,
    BUG_TRAP_TYPE_BUG = 2
} ;
enum dma_attr {
    DMA_ATTR_WRITE_BARRIER = 0,
    DMA_ATTR_WEAK_ORDERING = 1,
    DMA_ATTR_MAX = 2
} ;
struct dma_attrs {
   unsigned long flags[((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
typedef struct scatterlist *sg_alloc_fn(unsigned int  , gfp_t  );
typedef void sg_free_fn(struct scatterlist * , unsigned int  );
struct sg_mapping_iter {
   struct page *page ;
   void *addr ;
   size_t length ;
   size_t consumed ;
   struct scatterlist *__sg ;
   unsigned int __nents ;
   unsigned int __offset ;
   unsigned int __flags ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc_coherent)(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                           gfp_t gfp ) ;
   void (*free_coherent)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
   dma_addr_t (*map_page)(struct device *dev , struct page *page , unsigned long offset ,
                          size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
   void (*unmap_page)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
   int (*map_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                 struct dma_attrs *attrs ) ;
   void (*unmap_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                    struct dma_attrs *attrs ) ;
   void (*sync_single_for_cpu)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                               enum dma_data_direction dir ) ;
   void (*sync_single_for_device)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                                  enum dma_data_direction dir ) ;
   void (*sync_single_range_for_cpu)(struct device *dev , dma_addr_t dma_handle ,
                                     unsigned long offset , size_t size , enum dma_data_direction dir ) ;
   void (*sync_single_range_for_device)(struct device *dev , dma_addr_t dma_handle ,
                                        unsigned long offset , size_t size , enum dma_data_direction dir ) ;
   void (*sync_sg_for_cpu)(struct device *dev , struct scatterlist *sg , int nents ,
                           enum dma_data_direction dir ) ;
   void (*sync_sg_for_device)(struct device *dev , struct scatterlist *sg , int nents ,
                              enum dma_data_direction dir ) ;
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   int (*dma_supported)(struct device *dev , u64 mask ) ;
   int is_phys ;
};
struct dma_pool;
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct ieee1394_device_id {
   __u32 match_flags ;
   __u32 vendor_id ;
   __u32 model_id ;
   __u32 specifier_id ;
   __u32 version ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   kernel_ulong_t driver_info ;
};
struct hid_device_id {
   __u16 bus ;
   __u16 pad1 ;
   __u32 vendor ;
   __u32 product ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct ccw_device_id {
   __u16 match_flags ;
   __u16 cu_type ;
   __u16 dev_type ;
   __u8 cu_model ;
   __u8 dev_model ;
   kernel_ulong_t driver_info ;
};
struct ap_device_id {
   __u16 match_flags ;
   __u8 dev_type ;
   __u8 pad1 ;
   __u32 pad2 ;
   kernel_ulong_t driver_info ;
};
struct css_device_id {
   __u8 match_flags ;
   __u8 type ;
   __u16 pad2 ;
   __u32 pad3 ;
   kernel_ulong_t driver_data ;
};
struct acpi_device_id {
   __u8 id[16] ;
   kernel_ulong_t driver_data ;
};
struct pnp_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
};
struct __anonstruct_devs_107 {
   __u8 id[8] ;
};
struct pnp_card_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
   struct __anonstruct_devs_107 devs[8] ;
};
struct serio_device_id {
   __u8 type ;
   __u8 extra ;
   __u8 id ;
   __u8 proto ;
};
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void *data ;
};
struct vio_device_id {
   char type[32] ;
   char compat[32] ;
};
struct pcmcia_device_id {
   __u16 match_flags ;
   __u16 manf_id ;
   __u16 card_id ;
   __u8 func_id ;
   __u8 function ;
   __u8 device_no ;
   __u32 prod_id_hash[4]  __attribute__((__aligned__(sizeof(__u32 )))) ;
   char const   *prod_id[4] ;
   kernel_ulong_t driver_info ;
   char *cisfile ;
};
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1] ;
   kernel_ulong_t keybit[24] ;
   kernel_ulong_t relbit[1] ;
   kernel_ulong_t absbit[2] ;
   kernel_ulong_t mscbit[1] ;
   kernel_ulong_t ledbit[1] ;
   kernel_ulong_t sndbit[1] ;
   kernel_ulong_t ffbit[4] ;
   kernel_ulong_t swbit[1] ;
   kernel_ulong_t driver_info ;
};
struct eisa_device_id {
   char sig[8] ;
   kernel_ulong_t driver_data ;
};
struct parisc_device_id {
   __u8 hw_type ;
   __u8 hversion_rev ;
   __u16 hversion ;
   __u32 sversion ;
};
struct sdio_device_id {
   __u8 class ;
   __u16 vendor ;
   __u16 device ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct ssb_device_id {
   __u16 vendor ;
   __u16 coreid ;
   __u8 revision ;
};
struct virtio_device_id {
   __u32 device ;
   __u32 vendor ;
};
struct i2c_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
enum dmi_field {
    DMI_NONE = 0,
    DMI_BIOS_VENDOR = 1,
    DMI_BIOS_VERSION = 2,
    DMI_BIOS_DATE = 3,
    DMI_SYS_VENDOR = 4,
    DMI_PRODUCT_NAME = 5,
    DMI_PRODUCT_VERSION = 6,
    DMI_PRODUCT_SERIAL = 7,
    DMI_PRODUCT_UUID = 8,
    DMI_BOARD_VENDOR = 9,
    DMI_BOARD_NAME = 10,
    DMI_BOARD_VERSION = 11,
    DMI_BOARD_SERIAL = 12,
    DMI_BOARD_ASSET_TAG = 13,
    DMI_CHASSIS_VENDOR = 14,
    DMI_CHASSIS_TYPE = 15,
    DMI_CHASSIS_VERSION = 16,
    DMI_CHASSIS_SERIAL = 17,
    DMI_CHASSIS_ASSET_TAG = 18,
    DMI_STRING_MAX = 19
} ;
struct dmi_strmatch {
   unsigned char slot ;
   char substr[79] ;
};
struct dmi_system_id {
   int (*callback)(struct dmi_system_id  const  * ) ;
   char const   *ident ;
   struct dmi_strmatch matches[4] ;
   void *driver_data ;
};
struct platform_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct usb_ctrlrequest {
   __u8 bRequestType ;
   __u8 bRequest ;
   __le16 wValue ;
   __le16 wIndex ;
   __le16 wLength ;
} __attribute__((__packed__)) ;
struct usb_descriptor_header {
   __u8 bLength ;
   __u8 bDescriptorType ;
} __attribute__((__packed__)) ;
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
} __attribute__((__packed__)) ;
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
} __attribute__((__packed__)) ;
struct usb_string_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wData[1] ;
} __attribute__((__packed__)) ;
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
} __attribute__((__packed__)) ;
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
} __attribute__((__packed__)) ;
struct usb_qualifier_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __u8 bNumConfigurations ;
   __u8 bRESERVED ;
} __attribute__((__packed__)) ;
struct usb_otg_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bmAttributes ;
} __attribute__((__packed__)) ;
struct usb_debug_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDebugInEndpoint ;
   __u8 bDebugOutEndpoint ;
} __attribute__((__packed__)) ;
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
} __attribute__((__packed__)) ;
struct usb_security_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumEncryptionTypes ;
} __attribute__((__packed__)) ;
struct usb_key_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 tTKID[3] ;
   __u8 bReserved ;
   __u8 bKeyData[0] ;
} __attribute__((__packed__)) ;
struct usb_encryption_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEncryptionType ;
   __u8 bEncryptionValue ;
   __u8 bAuthKeyIndex ;
} __attribute__((__packed__)) ;
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
} __attribute__((__packed__)) ;
struct usb_dev_cap_header {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
} __attribute__((__packed__)) ;
struct usb_wireless_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wPHYRates ;
   __u8 bmTFITXPowerInfo ;
   __u8 bmFFITXPowerInfo ;
   __le16 bmBandGroup ;
   __u8 bReserved ;
} __attribute__((__packed__)) ;
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
} __attribute__((__packed__)) ;
struct usb_wireless_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bMaxSequence ;
   __le16 wMaxStreamDelay ;
   __le16 wOverTheAirPacketSize ;
   __u8 bOverTheAirInterval ;
   __u8 bmCompAttributes ;
} __attribute__((__packed__)) ;
struct usb_handshake {
   __u8 bMessageNumber ;
   __u8 bStatus ;
   __u8 tTKID[3] ;
   __u8 bReserved ;
   __u8 CDID[16] ;
   __u8 nonce[16] ;
   __u8 MIC[8] ;
} __attribute__((__packed__)) ;
struct usb_connection_context {
   __u8 CHID[16] ;
   __u8 CDID[16] ;
   __u8 CK[16] ;
} __attribute__((__packed__)) ;
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_VARIABLE = 4
} ;
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct irq_desc;
struct sched_param {
   int sched_priority ;
};
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
typedef struct __user_cap_header_struct *cap_user_header_t;
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
typedef struct __user_cap_data_struct *cap_user_data_t;
struct __anonstruct_data_108 {
   __le32 permitted ;
   __le32 inheritable ;
};
struct vfs_cap_data {
   __le32 magic_etc ;
   struct __anonstruct_data_108 data[2] ;
};
struct kernel_cap_struct {
   __u32 cap[2] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct cpu_vfs_cap_data {
   __u32 magic_etc ;
   kernel_cap_t permitted ;
   kernel_cap_t inheritable ;
};
struct dentry;
typedef unsigned long cputime_t;
typedef u64 cputime64_t;
struct ipc_perm {
   __kernel_key_t key ;
   __kernel_uid_t uid ;
   __kernel_gid_t gid ;
   __kernel_uid_t cuid ;
   __kernel_gid_t cgid ;
   __kernel_mode_t mode ;
   unsigned short seq ;
};
struct ipc64_perm {
   __kernel_key_t key ;
   __kernel_uid32_t uid ;
   __kernel_gid32_t gid ;
   __kernel_uid32_t cuid ;
   __kernel_gid32_t cgid ;
   __kernel_mode_t mode ;
   unsigned short __pad1 ;
   unsigned short seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
struct msgbuf;
struct ipc_kludge {
   struct msgbuf *msgp ;
   long msgtyp ;
};
struct kern_ipc_perm {
   spinlock_t lock ;
   int deleted ;
   int id ;
   key_t key ;
   uid_t uid ;
   gid_t gid ;
   uid_t cuid ;
   gid_t cgid ;
   mode_t mode ;
   unsigned long seq ;
   void *security ;
};
struct sem;
struct sem_queue;
struct sem_undo;
struct semid_ds {
   struct ipc_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned short sem_nsems ;
};
struct semid64_ds {
   struct ipc64_perm sem_perm ;
   __kernel_time_t sem_otime ;
   unsigned long __unused1 ;
   __kernel_time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
struct seminfo;
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
   void *__pad ;
};
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
struct sem {
   int semval ;
   int sempid ;
};
struct sem_array {
   struct kern_ipc_perm sem_perm ;
   time_t sem_otime ;
   time_t sem_ctime ;
   struct sem *sem_base ;
   struct list_head sem_pending ;
   struct list_head list_id ;
   unsigned long sem_nsems ;
};
struct sem_queue {
   struct list_head list ;
   struct task_struct *sleeper ;
   struct sem_undo *undo ;
   int pid ;
   int status ;
   struct sembuf *sops ;
   int nsops ;
   int alter ;
};
struct sem_undo_list;
struct sem_undo {
   struct list_head list_proc ;
   struct rcu_head rcu ;
   struct sem_undo_list *ulp ;
   struct list_head list_id ;
   int semid ;
   short *semadj ;
};
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct siginfo;
typedef unsigned long old_sigset_t;
struct __anonstruct_sigset_t_109 {
   unsigned long sig[1] ;
};
typedef struct __anonstruct_sigset_t_109 sigset_t;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
typedef struct sigaltstack stack_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_111 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_112 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_113 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_114 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__sigfault_115 {
   void *_addr ;
};
struct __anonstruct__sigpoll_116 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_110 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_111 _kill ;
   struct __anonstruct__timer_112 _timer ;
   struct __anonstruct__rt_113 _rt ;
   struct __anonstruct__sigchld_114 _sigchld ;
   struct __anonstruct__sigfault_115 _sigfault ;
   struct __anonstruct__sigpoll_116 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_110 _sifields ;
};
typedef struct siginfo siginfo_t;
struct __anonstruct__sigev_thread_118 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
union __anonunion__sigev_un_117 {
   int _pad[(64UL - (sizeof(int ) * 2UL + sizeof(sigval_t ))) / sizeof(int )] ;
   int _tid ;
   struct __anonstruct__sigev_thread_118 _sigev_thread ;
};
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_117 _sigev_un ;
};
typedef struct sigevent sigevent_t;
struct sigqueue {
   struct list_head list ;
   int flags ;
   siginfo_t info ;
   struct user_struct *user ;
};
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct vfsmount;
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct percpu_counter {
   spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct prop_global {
   int shift ;
   struct percpu_counter events ;
};
struct prop_descriptor {
   int index ;
   struct prop_global pg[2] ;
   struct mutex mutex ;
};
struct prop_local_percpu {
   struct percpu_counter events ;
   int shift ;
   unsigned long period ;
   spinlock_t lock ;
};
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
struct __anonstruct_seccomp_t_119 {
   int mode ;
};
typedef struct __anonstruct_seccomp_t_119 seccomp_t;
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct plist_node {
   int prio ;
   struct plist_head plist ;
};
struct rt_mutex {
   spinlock_t wait_lock ;
   struct plist_head wait_list ;
   struct task_struct *owner ;
};
struct rt_mutex_waiter;
struct hrtimer_sleeper;
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_mode {
    HRTIMER_MODE_ABS = 0,
    HRTIMER_MODE_REL = 1
} ;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
struct hrtimer_sleeper {
   struct hrtimer timer ;
   struct task_struct *task ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
   ktime_t expires_next ;
   int hres_active ;
   unsigned long nr_events ;
};
struct clock_event_device;
struct tick_device;
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct __sysctl_args {
   int *name ;
   int nlen ;
   void *oldval ;
   size_t *oldlenp ;
   void *newval ;
   size_t newlen ;
   unsigned long __unused[4] ;
};
enum __anonenum_120 {
    CTL_KERN = 1,
    CTL_VM = 2,
    CTL_NET = 3,
    CTL_PROC = 4,
    CTL_FS = 5,
    CTL_DEBUG = 6,
    CTL_DEV = 7,
    CTL_BUS = 8,
    CTL_ABI = 9,
    CTL_CPU = 10,
    CTL_ARLAN = 254,
    CTL_S390DBF = 5677,
    CTL_SUNRPC = 7249,
    CTL_PM = 9899,
    CTL_FRV = 9898
} ;
enum __anonenum_121 {
    CTL_BUS_ISA = 1
} ;
enum __anonenum_122 {
    INOTIFY_MAX_USER_INSTANCES = 1,
    INOTIFY_MAX_USER_WATCHES = 2,
    INOTIFY_MAX_QUEUED_EVENTS = 3
} ;
enum __anonenum_123 {
    KERN_OSTYPE = 1,
    KERN_OSRELEASE = 2,
    KERN_OSREV = 3,
    KERN_VERSION = 4,
    KERN_SECUREMASK = 5,
    KERN_PROF = 6,
    KERN_NODENAME = 7,
    KERN_DOMAINNAME = 8,
    KERN_PANIC = 15,
    KERN_REALROOTDEV = 16,
    KERN_SPARC_REBOOT = 21,
    KERN_CTLALTDEL = 22,
    KERN_PRINTK = 23,
    KERN_NAMETRANS = 24,
    KERN_PPC_HTABRECLAIM = 25,
    KERN_PPC_ZEROPAGED = 26,
    KERN_PPC_POWERSAVE_NAP = 27,
    KERN_MODPROBE = 28,
    KERN_SG_BIG_BUFF = 29,
    KERN_ACCT = 30,
    KERN_PPC_L2CR = 31,
    KERN_RTSIGNR = 32,
    KERN_RTSIGMAX = 33,
    KERN_SHMMAX = 34,
    KERN_MSGMAX = 35,
    KERN_MSGMNB = 36,
    KERN_MSGPOOL = 37,
    KERN_SYSRQ = 38,
    KERN_MAX_THREADS = 39,
    KERN_RANDOM = 40,
    KERN_SHMALL = 41,
    KERN_MSGMNI = 42,
    KERN_SEM = 43,
    KERN_SPARC_STOP_A = 44,
    KERN_SHMMNI = 45,
    KERN_OVERFLOWUID = 46,
    KERN_OVERFLOWGID = 47,
    KERN_SHMPATH = 48,
    KERN_HOTPLUG = 49,
    KERN_IEEE_EMULATION_WARNINGS = 50,
    KERN_S390_USER_DEBUG_LOGGING = 51,
    KERN_CORE_USES_PID = 52,
    KERN_TAINTED = 53,
    KERN_CADPID = 54,
    KERN_PIDMAX = 55,
    KERN_CORE_PATTERN = 56,
    KERN_PANIC_ON_OOPS = 57,
    KERN_HPPA_PWRSW = 58,
    KERN_HPPA_UNALIGNED = 59,
    KERN_PRINTK_RATELIMIT = 60,
    KERN_PRINTK_RATELIMIT_BURST = 61,
    KERN_PTY = 62,
    KERN_NGROUPS_MAX = 63,
    KERN_SPARC_SCONS_PWROFF = 64,
    KERN_HZ_TIMER = 65,
    KERN_UNKNOWN_NMI_PANIC = 66,
    KERN_BOOTLOADER_TYPE = 67,
    KERN_RANDOMIZE = 68,
    KERN_SETUID_DUMPABLE = 69,
    KERN_SPIN_RETRY = 70,
    KERN_ACPI_VIDEO_FLAGS = 71,
    KERN_IA64_UNALIGNED = 72,
    KERN_COMPAT_LOG = 73,
    KERN_MAX_LOCK_DEPTH = 74,
    KERN_NMI_WATCHDOG = 75,
    KERN_PANIC_ON_NMI = 76
} ;
enum __anonenum_124 {
    VM_UNUSED1 = 1,
    VM_UNUSED2 = 2,
    VM_UNUSED3 = 3,
    VM_UNUSED4 = 4,
    VM_OVERCOMMIT_MEMORY = 5,
    VM_UNUSED5 = 6,
    VM_UNUSED7 = 7,
    VM_UNUSED8 = 8,
    VM_UNUSED9 = 9,
    VM_PAGE_CLUSTER = 10,
    VM_DIRTY_BACKGROUND = 11,
    VM_DIRTY_RATIO = 12,
    VM_DIRTY_WB_CS = 13,
    VM_DIRTY_EXPIRE_CS = 14,
    VM_NR_PDFLUSH_THREADS = 15,
    VM_OVERCOMMIT_RATIO = 16,
    VM_PAGEBUF = 17,
    VM_HUGETLB_PAGES = 18,
    VM_SWAPPINESS = 19,
    VM_LOWMEM_RESERVE_RATIO = 20,
    VM_MIN_FREE_KBYTES = 21,
    VM_MAX_MAP_COUNT = 22,
    VM_LAPTOP_MODE = 23,
    VM_BLOCK_DUMP = 24,
    VM_HUGETLB_GROUP = 25,
    VM_VFS_CACHE_PRESSURE = 26,
    VM_LEGACY_VA_LAYOUT = 27,
    VM_SWAP_TOKEN_TIMEOUT = 28,
    VM_DROP_PAGECACHE = 29,
    VM_PERCPU_PAGELIST_FRACTION = 30,
    VM_ZONE_RECLAIM_MODE = 31,
    VM_MIN_UNMAPPED = 32,
    VM_PANIC_ON_OOM = 33,
    VM_VDSO_ENABLED = 34,
    VM_MIN_SLAB = 35
} ;
enum __anonenum_125 {
    NET_CORE = 1,
    NET_ETHER = 2,
    NET_802 = 3,
    NET_UNIX = 4,
    NET_IPV4 = 5,
    NET_IPX = 6,
    NET_ATALK = 7,
    NET_NETROM = 8,
    NET_AX25 = 9,
    NET_BRIDGE = 10,
    NET_ROSE = 11,
    NET_IPV6 = 12,
    NET_X25 = 13,
    NET_TR = 14,
    NET_DECNET = 15,
    NET_ECONET = 16,
    NET_SCTP = 17,
    NET_LLC = 18,
    NET_NETFILTER = 19,
    NET_DCCP = 20,
    NET_IRDA = 412
} ;
enum __anonenum_126 {
    RANDOM_POOLSIZE = 1,
    RANDOM_ENTROPY_COUNT = 2,
    RANDOM_READ_THRESH = 3,
    RANDOM_WRITE_THRESH = 4,
    RANDOM_BOOT_ID = 5,
    RANDOM_UUID = 6
} ;
enum __anonenum_127 {
    PTY_MAX = 1,
    PTY_NR = 2
} ;
enum __anonenum_128 {
    BUS_ISA_MEM_BASE = 1,
    BUS_ISA_PORT_BASE = 2,
    BUS_ISA_PORT_SHIFT = 3
} ;
enum __anonenum_129 {
    NET_CORE_WMEM_MAX = 1,
    NET_CORE_RMEM_MAX = 2,
    NET_CORE_WMEM_DEFAULT = 3,
    NET_CORE_RMEM_DEFAULT = 4,
    NET_CORE_MAX_BACKLOG = 6,
    NET_CORE_FASTROUTE = 7,
    NET_CORE_MSG_COST = 8,
    NET_CORE_MSG_BURST = 9,
    NET_CORE_OPTMEM_MAX = 10,
    NET_CORE_HOT_LIST_LENGTH = 11,
    NET_CORE_DIVERT_VERSION = 12,
    NET_CORE_NO_CONG_THRESH = 13,
    NET_CORE_NO_CONG = 14,
    NET_CORE_LO_CONG = 15,
    NET_CORE_MOD_CONG = 16,
    NET_CORE_DEV_WEIGHT = 17,
    NET_CORE_SOMAXCONN = 18,
    NET_CORE_BUDGET = 19,
    NET_CORE_AEVENT_ETIME = 20,
    NET_CORE_AEVENT_RSEQTH = 21,
    NET_CORE_WARNINGS = 22
} ;
enum __anonenum_130 {
    NET_UNIX_DESTROY_DELAY = 1,
    NET_UNIX_DELETE_DELAY = 2,
    NET_UNIX_MAX_DGRAM_QLEN = 3
} ;
enum __anonenum_131 {
    NET_NF_CONNTRACK_MAX = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_NF_CONNTRACK_BUCKETS = 14,
    NET_NF_CONNTRACK_LOG_INVALID = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_NF_CONNTRACK_COUNT = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
    NET_NF_CONNTRACK_CHECKSUM = 32
} ;
enum __anonenum_132 {
    NET_IPV4_FORWARD = 8,
    NET_IPV4_DYNADDR = 9,
    NET_IPV4_CONF = 16,
    NET_IPV4_NEIGH = 17,
    NET_IPV4_ROUTE = 18,
    NET_IPV4_FIB_HASH = 19,
    NET_IPV4_NETFILTER = 20,
    NET_IPV4_TCP_TIMESTAMPS = 33,
    NET_IPV4_TCP_WINDOW_SCALING = 34,
    NET_IPV4_TCP_SACK = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
    NET_IPV4_DEFAULT_TTL = 37,
    NET_IPV4_AUTOCONFIG = 38,
    NET_IPV4_NO_PMTU_DISC = 39,
    NET_IPV4_TCP_SYN_RETRIES = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH = 41,
    NET_IPV4_IPFRAG_LOW_THRESH = 42,
    NET_IPV4_IPFRAG_TIME = 43,
    NET_IPV4_TCP_MAX_KA_PROBES = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
    NET_IPV4_TCP_RETRIES1 = 47,
    NET_IPV4_TCP_RETRIES2 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT = 49,
    NET_IPV4_IP_MASQ_DEBUG = 50,
    NET_TCP_SYNCOOKIES = 51,
    NET_TCP_STDURG = 52,
    NET_TCP_RFC1337 = 53,
    NET_TCP_SYN_TAILDROP = 54,
    NET_TCP_MAX_SYN_BACKLOG = 55,
    NET_IPV4_LOCAL_PORT_RANGE = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
    NET_TCP_TW_RECYCLE = 66,
    NET_IPV4_ALWAYS_DEFRAG = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
    NET_IPV4_INET_PEER_THRESHOLD = 69,
    NET_IPV4_INET_PEER_MINTTL = 70,
    NET_IPV4_INET_PEER_MAXTTL = 71,
    NET_IPV4_INET_PEER_GC_MINTIME = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME = 73,
    NET_TCP_ORPHAN_RETRIES = 74,
    NET_TCP_ABORT_ON_OVERFLOW = 75,
    NET_TCP_SYNACK_RETRIES = 76,
    NET_TCP_MAX_ORPHANS = 77,
    NET_TCP_MAX_TW_BUCKETS = 78,
    NET_TCP_FACK = 79,
    NET_TCP_REORDERING = 80,
    NET_TCP_ECN = 81,
    NET_TCP_DSACK = 82,
    NET_TCP_MEM = 83,
    NET_TCP_WMEM = 84,
    NET_TCP_RMEM = 85,
    NET_TCP_APP_WIN = 86,
    NET_TCP_ADV_WIN_SCALE = 87,
    NET_IPV4_NONLOCAL_BIND = 88,
    NET_IPV4_ICMP_RATELIMIT = 89,
    NET_IPV4_ICMP_RATEMASK = 90,
    NET_TCP_TW_REUSE = 91,
    NET_TCP_FRTO = 92,
    NET_TCP_LOW_LATENCY = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
    NET_IPV4_IGMP_MAX_MSF = 96,
    NET_TCP_NO_METRICS_SAVE = 97,
    NET_TCP_DEFAULT_WIN_SCALE = 105,
    NET_TCP_MODERATE_RCVBUF = 106,
    NET_TCP_TSO_WIN_DIVISOR = 107,
    NET_TCP_BIC_BETA = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
    NET_TCP_CONG_CONTROL = 110,
    NET_TCP_ABC = 111,
    NET_IPV4_IPFRAG_MAX_DIST = 112,
    NET_TCP_MTU_PROBING = 113,
    NET_TCP_BASE_MSS = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
    NET_TCP_DMA_COPYBREAK = 116,
    NET_TCP_SLOW_START_AFTER_IDLE = 117,
    NET_CIPSOV4_CACHE_ENABLE = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
    NET_CIPSOV4_RBM_OPTFMT = 120,
    NET_CIPSOV4_RBM_STRICTVALID = 121,
    NET_TCP_AVAIL_CONG_CONTROL = 122,
    NET_TCP_ALLOWED_CONG_CONTROL = 123,
    NET_TCP_MAX_SSTHRESH = 124,
    NET_TCP_FRTO_RESPONSE = 125
} ;
enum __anonenum_133 {
    NET_IPV4_ROUTE_FLUSH = 1,
    NET_IPV4_ROUTE_MIN_DELAY = 2,
    NET_IPV4_ROUTE_MAX_DELAY = 3,
    NET_IPV4_ROUTE_GC_THRESH = 4,
    NET_IPV4_ROUTE_MAX_SIZE = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT = 7,
    NET_IPV4_ROUTE_GC_INTERVAL = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
    NET_IPV4_ROUTE_ERROR_COST = 12,
    NET_IPV4_ROUTE_ERROR_BURST = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES = 15,
    NET_IPV4_ROUTE_MIN_PMTU = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19
} ;
enum __anonenum_134 {
    NET_PROTO_CONF_ALL = -2,
    NET_PROTO_CONF_DEFAULT = -3
} ;
enum __anonenum_135 {
    NET_IPV4_CONF_FORWARDING = 1,
    NET_IPV4_CONF_MC_FORWARDING = 2,
    NET_IPV4_CONF_PROXY_ARP = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS = 5,
    NET_IPV4_CONF_SEND_REDIRECTS = 6,
    NET_IPV4_CONF_SHARED_MEDIA = 7,
    NET_IPV4_CONF_RP_FILTER = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
    NET_IPV4_CONF_BOOTP_RELAY = 10,
    NET_IPV4_CONF_LOG_MARTIANS = 11,
    NET_IPV4_CONF_TAG = 12,
    NET_IPV4_CONF_ARPFILTER = 13,
    NET_IPV4_CONF_MEDIUM_ID = 14,
    NET_IPV4_CONF_NOXFRM = 15,
    NET_IPV4_CONF_NOPOLICY = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE = 18,
    NET_IPV4_CONF_ARP_IGNORE = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
    NET_IPV4_CONF_ARP_ACCEPT = 21,
    NET_IPV4_CONF_ARP_NOTIFY = 22,
    __NET_IPV4_CONF_MAX = 23
} ;
enum __anonenum_136 {
    NET_IPV4_NF_CONNTRACK_MAX = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_IPV4_NF_CONNTRACK_COUNT = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM = 28
} ;
enum __anonenum_137 {
    NET_IPV6_CONF = 16,
    NET_IPV6_NEIGH = 17,
    NET_IPV6_ROUTE = 18,
    NET_IPV6_ICMP = 19,
    NET_IPV6_BINDV6ONLY = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH = 22,
    NET_IPV6_IP6FRAG_TIME = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
    NET_IPV6_MLD_MAX_MSF = 25
} ;
enum __anonenum_138 {
    NET_IPV6_ROUTE_FLUSH = 1,
    NET_IPV6_ROUTE_GC_THRESH = 2,
    NET_IPV6_ROUTE_MAX_SIZE = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT = 5,
    NET_IPV6_ROUTE_GC_INTERVAL = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10
} ;
enum __anonenum_139 {
    NET_IPV6_FORWARDING = 1,
    NET_IPV6_HOP_LIMIT = 2,
    NET_IPV6_MTU = 3,
    NET_IPV6_ACCEPT_RA = 4,
    NET_IPV6_ACCEPT_REDIRECTS = 5,
    NET_IPV6_AUTOCONF = 6,
    NET_IPV6_DAD_TRANSMITS = 7,
    NET_IPV6_RTR_SOLICITS = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
    NET_IPV6_RTR_SOLICIT_DELAY = 10,
    NET_IPV6_USE_TEMPADDR = 11,
    NET_IPV6_TEMP_VALID_LFT = 12,
    NET_IPV6_TEMP_PREFERED_LFT = 13,
    NET_IPV6_REGEN_MAX_RETRY = 14,
    NET_IPV6_MAX_DESYNC_FACTOR = 15,
    NET_IPV6_MAX_ADDRESSES = 16,
    NET_IPV6_FORCE_MLD_VERSION = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR = 18,
    NET_IPV6_ACCEPT_RA_PINFO = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
    NET_IPV6_RTR_PROBE_INTERVAL = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
    NET_IPV6_PROXY_NDP = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
    __NET_IPV6_MAX = 26
} ;
enum __anonenum_140 {
    NET_IPV6_ICMP_RATELIMIT = 1
} ;
enum __anonenum_141 {
    NET_NEIGH_MCAST_SOLICIT = 1,
    NET_NEIGH_UCAST_SOLICIT = 2,
    NET_NEIGH_APP_SOLICIT = 3,
    NET_NEIGH_RETRANS_TIME = 4,
    NET_NEIGH_REACHABLE_TIME = 5,
    NET_NEIGH_DELAY_PROBE_TIME = 6,
    NET_NEIGH_GC_STALE_TIME = 7,
    NET_NEIGH_UNRES_QLEN = 8,
    NET_NEIGH_PROXY_QLEN = 9,
    NET_NEIGH_ANYCAST_DELAY = 10,
    NET_NEIGH_PROXY_DELAY = 11,
    NET_NEIGH_LOCKTIME = 12,
    NET_NEIGH_GC_INTERVAL = 13,
    NET_NEIGH_GC_THRESH1 = 14,
    NET_NEIGH_GC_THRESH2 = 15,
    NET_NEIGH_GC_THRESH3 = 16,
    NET_NEIGH_RETRANS_TIME_MS = 17,
    NET_NEIGH_REACHABLE_TIME_MS = 18,
    __NET_NEIGH_MAX = 19
} ;
enum __anonenum_142 {
    NET_DCCP_DEFAULT = 1
} ;
enum __anonenum_143 {
    NET_IPX_PPROP_BROADCASTING = 1,
    NET_IPX_FORWARDING = 2
} ;
enum __anonenum_144 {
    NET_LLC2 = 1,
    NET_LLC_STATION = 2
} ;
enum __anonenum_145 {
    NET_LLC2_TIMEOUT = 1
} ;
enum __anonenum_146 {
    NET_LLC_STATION_ACK_TIMEOUT = 1
} ;
enum __anonenum_147 {
    NET_LLC2_ACK_TIMEOUT = 1,
    NET_LLC2_P_TIMEOUT = 2,
    NET_LLC2_REJ_TIMEOUT = 3,
    NET_LLC2_BUSY_TIMEOUT = 4
} ;
enum __anonenum_148 {
    NET_ATALK_AARP_EXPIRY_TIME = 1,
    NET_ATALK_AARP_TICK_TIME = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
    NET_ATALK_AARP_RESOLVE_TIME = 4
} ;
enum __anonenum_149 {
    NET_NETROM_DEFAULT_PATH_QUALITY = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER = 3,
    NET_NETROM_TRANSPORT_TIMEOUT = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
    NET_NETROM_ROUTING_CONTROL = 10,
    NET_NETROM_LINK_FAILS_COUNT = 11,
    NET_NETROM_RESET = 12
} ;
enum __anonenum_150 {
    NET_AX25_IP_DEFAULT_MODE = 1,
    NET_AX25_DEFAULT_MODE = 2,
    NET_AX25_BACKOFF_TYPE = 3,
    NET_AX25_CONNECT_MODE = 4,
    NET_AX25_STANDARD_WINDOW = 5,
    NET_AX25_EXTENDED_WINDOW = 6,
    NET_AX25_T1_TIMEOUT = 7,
    NET_AX25_T2_TIMEOUT = 8,
    NET_AX25_T3_TIMEOUT = 9,
    NET_AX25_IDLE_TIMEOUT = 10,
    NET_AX25_N2 = 11,
    NET_AX25_PACLEN = 12,
    NET_AX25_PROTOCOL = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT = 14
} ;
enum __anonenum_151 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_ROSE_ROUTING_CONTROL = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT = 7,
    NET_ROSE_MAX_VCS = 8,
    NET_ROSE_WINDOW_SIZE = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT = 10
} ;
enum __anonenum_152 {
    NET_X25_RESTART_REQUEST_TIMEOUT = 1,
    NET_X25_CALL_REQUEST_TIMEOUT = 2,
    NET_X25_RESET_REQUEST_TIMEOUT = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_X25_FORWARD = 6
} ;
enum __anonenum_153 {
    NET_TR_RIF_TIMEOUT = 1
} ;
enum __anonenum_154 {
    NET_DECNET_NODE_TYPE = 1,
    NET_DECNET_NODE_ADDRESS = 2,
    NET_DECNET_NODE_NAME = 3,
    NET_DECNET_DEFAULT_DEVICE = 4,
    NET_DECNET_TIME_WAIT = 5,
    NET_DECNET_DN_COUNT = 6,
    NET_DECNET_DI_COUNT = 7,
    NET_DECNET_DR_COUNT = 8,
    NET_DECNET_DST_GC_INTERVAL = 9,
    NET_DECNET_CONF = 10,
    NET_DECNET_NO_FC_MAX_CWND = 11,
    NET_DECNET_MEM = 12,
    NET_DECNET_RMEM = 13,
    NET_DECNET_WMEM = 14,
    NET_DECNET_DEBUG_LEVEL = 255
} ;
enum __anonenum_155 {
    NET_DECNET_CONF_LOOPBACK = -2,
    NET_DECNET_CONF_DDCMP = -3,
    NET_DECNET_CONF_PPP = -4,
    NET_DECNET_CONF_X25 = -5,
    NET_DECNET_CONF_GRE = -6,
    NET_DECNET_CONF_ETHER = -7
} ;
enum __anonenum_156 {
    NET_DECNET_CONF_DEV_PRIORITY = 1,
    NET_DECNET_CONF_DEV_T1 = 2,
    NET_DECNET_CONF_DEV_T2 = 3,
    NET_DECNET_CONF_DEV_T3 = 4,
    NET_DECNET_CONF_DEV_FORWARDING = 5,
    NET_DECNET_CONF_DEV_BLKSIZE = 6,
    NET_DECNET_CONF_DEV_STATE = 7
} ;
enum __anonenum_157 {
    NET_SCTP_RTO_INITIAL = 1,
    NET_SCTP_RTO_MIN = 2,
    NET_SCTP_RTO_MAX = 3,
    NET_SCTP_RTO_ALPHA = 4,
    NET_SCTP_RTO_BETA = 5,
    NET_SCTP_VALID_COOKIE_LIFE = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
    NET_SCTP_PATH_MAX_RETRANS = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS = 9,
    NET_SCTP_HB_INTERVAL = 10,
    NET_SCTP_PRESERVE_ENABLE = 11,
    NET_SCTP_MAX_BURST = 12,
    NET_SCTP_ADDIP_ENABLE = 13,
    NET_SCTP_PRSCTP_ENABLE = 14,
    NET_SCTP_SNDBUF_POLICY = 15,
    NET_SCTP_SACK_TIMEOUT = 16,
    NET_SCTP_RCVBUF_POLICY = 17
} ;
enum __anonenum_158 {
    NET_BRIDGE_NF_CALL_ARPTABLES = 1,
    NET_BRIDGE_NF_CALL_IPTABLES = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5
} ;
enum __anonenum_159 {
    NET_IRDA_DISCOVERY = 1,
    NET_IRDA_DEVNAME = 2,
    NET_IRDA_DEBUG = 3,
    NET_IRDA_FAST_POLL = 4,
    NET_IRDA_DISCOVERY_SLOTS = 5,
    NET_IRDA_DISCOVERY_TIMEOUT = 6,
    NET_IRDA_SLOT_TIMEOUT = 7,
    NET_IRDA_MAX_BAUD_RATE = 8,
    NET_IRDA_MIN_TX_TURN_TIME = 9,
    NET_IRDA_MAX_TX_DATA_SIZE = 10,
    NET_IRDA_MAX_TX_WINDOW = 11,
    NET_IRDA_MAX_NOREPLY_TIME = 12,
    NET_IRDA_WARN_NOREPLY_TIME = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME = 14
} ;
enum __anonenum_160 {
    FS_NRINODE = 1,
    FS_STATINODE = 2,
    FS_MAXINODE = 3,
    FS_NRDQUOT = 4,
    FS_MAXDQUOT = 5,
    FS_NRFILE = 6,
    FS_MAXFILE = 7,
    FS_DENTRY = 8,
    FS_NRSUPER = 9,
    FS_MAXSUPER = 10,
    FS_OVERFLOWUID = 11,
    FS_OVERFLOWGID = 12,
    FS_LEASES = 13,
    FS_DIR_NOTIFY = 14,
    FS_LEASE_TIME = 15,
    FS_DQSTATS = 16,
    FS_XFS = 17,
    FS_AIO_NR = 18,
    FS_AIO_MAX_NR = 19,
    FS_INOTIFY = 20,
    FS_OCFS2 = 988
} ;
enum __anonenum_161 {
    FS_DQ_LOOKUPS = 1,
    FS_DQ_DROPS = 2,
    FS_DQ_READS = 3,
    FS_DQ_WRITES = 4,
    FS_DQ_CACHE_HITS = 5,
    FS_DQ_ALLOCATED = 6,
    FS_DQ_FREE = 7,
    FS_DQ_SYNCS = 8,
    FS_DQ_WARNINGS = 9
} ;
enum __anonenum_162 {
    DEV_CDROM = 1,
    DEV_HWMON = 2,
    DEV_PARPORT = 3,
    DEV_RAID = 4,
    DEV_MAC_HID = 5,
    DEV_SCSI = 6,
    DEV_IPMI = 7
} ;
enum __anonenum_163 {
    DEV_CDROM_INFO = 1,
    DEV_CDROM_AUTOCLOSE = 2,
    DEV_CDROM_AUTOEJECT = 3,
    DEV_CDROM_DEBUG = 4,
    DEV_CDROM_LOCK = 5,
    DEV_CDROM_CHECK_MEDIA = 6
} ;
enum __anonenum_164 {
    DEV_PARPORT_DEFAULT = -3
} ;
enum __anonenum_165 {
    DEV_RAID_SPEED_LIMIT_MIN = 1,
    DEV_RAID_SPEED_LIMIT_MAX = 2
} ;
enum __anonenum_166 {
    DEV_PARPORT_DEFAULT_TIMESLICE = 1,
    DEV_PARPORT_DEFAULT_SPINTIME = 2
} ;
enum __anonenum_167 {
    DEV_PARPORT_SPINTIME = 1,
    DEV_PARPORT_BASE_ADDR = 2,
    DEV_PARPORT_IRQ = 3,
    DEV_PARPORT_DMA = 4,
    DEV_PARPORT_MODES = 5,
    DEV_PARPORT_DEVICES = 6,
    DEV_PARPORT_AUTOPROBE = 16
} ;
enum __anonenum_168 {
    DEV_PARPORT_DEVICES_ACTIVE = -3
} ;
enum __anonenum_169 {
    DEV_PARPORT_DEVICE_TIMESLICE = 1
} ;
enum __anonenum_170 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6
} ;
enum __anonenum_171 {
    DEV_SCSI_LOGGING_LEVEL = 1
} ;
enum __anonenum_172 {
    DEV_IPMI_POWEROFF_POWERCYCLE = 1
} ;
enum __anonenum_173 {
    ABI_DEFHANDLER_COFF = 1,
    ABI_DEFHANDLER_ELF = 2,
    ABI_DEFHANDLER_LCALL7 = 3,
    ABI_DEFHANDLER_LIBCSO = 4,
    ABI_TRACE = 5,
    ABI_FAKE_UTSNAME = 6
} ;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_set {
   struct list_head list ;
   struct ctl_table_set *parent ;
   int (*is_seen)(struct ctl_table_set * ) ;
};
struct ctl_table_header;
typedef struct ctl_table ctl_table;
typedef int ctl_handler(struct ctl_table *table , void *oldval , size_t *oldlenp ,
                        void *newval , size_t newlen );
typedef int proc_handler(struct ctl_table *ctl , int write , struct file *filp , void *buffer ,
                         size_t *lenp , loff_t *ppos );
struct ctl_table {
   int ctl_name ;
   char const   *procname ;
   void *data ;
   int maxlen ;
   mode_t mode ;
   struct ctl_table *child ;
   struct ctl_table *parent ;
   proc_handler *proc_handler ;
   ctl_handler *strategy ;
   void *extra1 ;
   void *extra2 ;
};
struct ctl_table_root {
   struct list_head root_list ;
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *root , struct nsproxy *namespaces ) ;
   int (*permissions)(struct ctl_table_root *root , struct nsproxy *namespaces , struct ctl_table *table ) ;
};
struct ctl_table_header {
   struct ctl_table *ctl_table ;
   struct list_head ctl_entry ;
   int used ;
   int count ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_table *attached_by ;
   struct ctl_table *attached_to ;
   struct ctl_table_header *parent ;
};
struct ctl_path {
   char const   *procname ;
   int ctl_name ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct signal_struct;
struct cred;
struct key_type;
struct key_owner;
struct keyring_list;
struct keyring_name;
struct __key_reference_with_attributes;
typedef struct __key_reference_with_attributes *key_ref_t;
struct key_user;
union __anonunion_type_data_174 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
union __anonunion_payload_175 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_174 type_data ;
   union __anonunion_payload_175 payload ;
};
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
struct mem_cgroup;
struct futex_pi_state;
struct robust_list_head;
struct bio;
struct bts_tracer;
struct fs_struct;
struct cfs_rq;
struct task_group;
struct user_namespace;
typedef unsigned long aio_context_t;
enum __anonenum_176 {
    IOCB_CMD_PREAD = 0,
    IOCB_CMD_PWRITE = 1,
    IOCB_CMD_FSYNC = 2,
    IOCB_CMD_FDSYNC = 3,
    IOCB_CMD_NOOP = 6,
    IOCB_CMD_PREADV = 7,
    IOCB_CMD_PWRITEV = 8
} ;
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
struct iocb {
   __u64 aio_data ;
   __u32 aio_key ;
   __u32 aio_reserved1 ;
   __u16 aio_lio_opcode ;
   __s16 aio_reqprio ;
   __u32 aio_fildes ;
   __u64 aio_buf ;
   __u64 aio_nbytes ;
   __s64 aio_offset ;
   __u64 aio_reserved2 ;
   __u32 aio_flags ;
   __u32 aio_resfd ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
struct kioctx;
union __anonunion_ki_obj_177 {
   void *user ;
   struct task_struct *tsk ;
};
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_177 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
struct aio_ring {
   unsigned int id ;
   unsigned int nr ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int magic ;
   unsigned int compat_features ;
   unsigned int incompat_features ;
   unsigned int header_length ;
   struct io_event io_events[0] ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
struct backing_dev_info;
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
enum powersavings_balance_level {
    POWERSAVINGS_BALANCE_NONE = 0,
    POWERSAVINGS_BALANCE_BASIC = 1,
    POWERSAVINGS_BALANCE_WAKEUP = 2,
    MAX_POWERSAVINGS_BALANCE_LEVELS = 3
} ;
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
struct sched_domain_attr {
   int relax_domain_level ;
};
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   unsigned long span[] ;
};
struct io_context;
struct audit_context;
struct pipe_inode_info;
struct uts_namespace;
struct rq;
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   int (*needs_post_schedule)(struct rq *this_rq ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
   void (*moved_group)(struct task_struct *p ) ;
};
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 start_runtime ;
   u64 avg_wakeup ;
   u64 nr_migrations ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
struct linux_binfmt;
struct files_struct;
struct irqaction;
struct css_set;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   int cpuset_mems_generation ;
   int cpuset_mem_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   struct prop_local_single dirties ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
union thread_union {
   struct thread_info thread_info ;
   unsigned long stack[((1UL << 12) << 1) / sizeof(long )] ;
};
typedef struct pt_regs *T__;
typedef void (*irq_flow_handler_t)(unsigned int irq , struct irq_desc *desc );
struct proc_dir_entry;
struct msi_desc;
struct irq_chip {
   char const   *name ;
   unsigned int (*startup)(unsigned int irq ) ;
   void (*shutdown)(unsigned int irq ) ;
   void (*enable)(unsigned int irq ) ;
   void (*disable)(unsigned int irq ) ;
   void (*ack)(unsigned int irq ) ;
   void (*mask)(unsigned int irq ) ;
   void (*mask_ack)(unsigned int irq ) ;
   void (*unmask)(unsigned int irq ) ;
   void (*eoi)(unsigned int irq ) ;
   void (*end)(unsigned int irq ) ;
   void (*set_affinity)(unsigned int irq , struct cpumask  const  *dest ) ;
   int (*retrigger)(unsigned int irq ) ;
   int (*set_type)(unsigned int irq , unsigned int flow_type ) ;
   int (*set_wake)(unsigned int irq , unsigned int on ) ;
   char const   *typename ;
};
struct timer_rand_state;
struct irq_2_iommu;
struct irq_desc {
   unsigned int irq ;
   struct timer_rand_state *timer_rand_state ;
   unsigned int *kstat_irqs ;
   void (*handle_irq)(unsigned int irq , struct irq_desc *desc ) ;
   struct irq_chip *chip ;
   struct msi_desc *msi_desc ;
   void *handler_data ;
   void *chip_data ;
   struct irqaction *action ;
   unsigned int status ;
   unsigned int depth ;
   unsigned int wake_depth ;
   unsigned int irq_count ;
   unsigned long last_unhandled ;
   unsigned int irqs_unhandled ;
   spinlock_t lock ;
   cpumask_var_t affinity ;
   unsigned int cpu ;
   cpumask_var_t pending_mask ;
   atomic_t threads_active ;
   wait_queue_head_t wait_for_threads ;
   struct proc_dir_entry *dir ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct irq_desc irq_desc_t;
enum profile_type {
    PROFILE_TASK_EXIT = 0,
    PROFILE_MUNMAP = 1
} ;
typedef int vector_irq_t[256];
struct __anonstruct_irq_cpustat_t_178 {
   unsigned int __softirq_pending ;
   unsigned int __nmi_count ;
   unsigned int irq0_irqs ;
   unsigned int apic_timer_irqs ;
   unsigned int irq_spurious_count ;
   unsigned int generic_irqs ;
   unsigned int irq_resched_count ;
   unsigned int irq_call_count ;
   unsigned int irq_tlb_count ;
   unsigned int irq_thermal_count ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct __anonstruct_irq_cpustat_t_178 irq_cpustat_t;
enum __anonenum_179 {
    IRQTF_RUNTHREAD = 0,
    IRQTF_DIED = 1,
    IRQTF_WARNED = 2
} ;
typedef irqreturn_t (*irq_handler_t)(int  , void * );
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   unsigned long flags ;
   cpumask_t mask ;
   char const   *name ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   struct proc_dir_entry *dir ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
};
enum __anonenum_180 {
    HI_SOFTIRQ = 0,
    TIMER_SOFTIRQ = 1,
    NET_TX_SOFTIRQ = 2,
    NET_RX_SOFTIRQ = 3,
    BLOCK_SOFTIRQ = 4,
    TASKLET_SOFTIRQ = 5,
    SCHED_SOFTIRQ = 6,
    HRTIMER_SOFTIRQ = 7,
    RCU_SOFTIRQ = 8,
    NR_SOFTIRQS = 9
} ;
struct softirq_action {
   void (*action)(struct softirq_action * ) ;
};
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
enum __anonenum_181 {
    TASKLET_STATE_SCHED = 0,
    TASKLET_STATE_RUN = 1
} ;
struct files_stat_struct {
   int nr_files ;
   int nr_free_files ;
   int max_files ;
};
struct inodes_stat_t {
   int nr_inodes ;
   int nr_unused ;
   int dummy[5] ;
};
struct nameidata;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
struct dentry_stat_t {
   int nr_dentry ;
   int nr_unused ;
   int age_limit ;
   int want_pages ;
   int dummy[2] ;
};
union __anonunion_d_u_182 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry_operations;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_182 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[40] ;
};
enum dentry_d_lock_class {
    DENTRY_D_LOCK_NORMAL = 0,
    DENTRY_D_LOCK_NESTED = 1
} ;
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
struct fiemap {
   __u64 fm_start ;
   __u64 fm_length ;
   __u32 fm_flags ;
   __u32 fm_mapped_extents ;
   __u32 fm_extent_count ;
   __u32 fm_reserved ;
   struct fiemap_extent fm_extents[0] ;
};
struct export_operations;
struct hd_geometry;
struct poll_table_struct;
struct kstatfs;
struct buffer_head;
typedef int get_block_t(struct inode *inode , sector_t iblock , struct buffer_head *bh_result ,
                        int create );
typedef void dio_iodone_t(struct kiocb *iocb , loff_t offset , ssize_t bytes , void *private );
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
enum __anonenum_183 {
    QIF_BLIMITS_B = 0,
    QIF_SPACE_B = 1,
    QIF_ILIMITS_B = 2,
    QIF_INODES_B = 3,
    QIF_BTIME_B = 4,
    QIF_ITIME_B = 5
} ;
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
enum __anonenum_184 {
    QUOTA_NL_C_UNSPEC = 0,
    QUOTA_NL_C_WARNING = 1,
    __QUOTA_NL_C_MAX = 2
} ;
enum __anonenum_185 {
    QUOTA_NL_A_UNSPEC = 0,
    QUOTA_NL_A_QTYPE = 1,
    QUOTA_NL_A_EXCESS_ID = 2,
    QUOTA_NL_A_WARNING = 3,
    QUOTA_NL_A_DEV_MAJOR = 4,
    QUOTA_NL_A_DEV_MINOR = 5,
    QUOTA_NL_A_CAUSED_ID = 6,
    __QUOTA_NL_A_MAX = 7
} ;
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
typedef struct fs_disk_quota fs_disk_quota_t;
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
typedef struct fs_quota_stat fs_quota_stat_t;
struct dquot;
struct qtree_fmt_operations {
   void (*mem2disk_dqblk)(void *disk , struct dquot *dquot ) ;
   void (*disk2mem_dqblk)(struct dquot *dquot , void *disk ) ;
   int (*is_id)(void *disk , struct dquot *dquot ) ;
};
struct qtree_mem_dqinfo {
   struct super_block *dqi_sb ;
   int dqi_type ;
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
   unsigned int dqi_blocksize_bits ;
   unsigned int dqi_entry_size ;
   unsigned int dqi_usable_bs ;
   unsigned int dqi_qtree_depth ;
   struct qtree_fmt_operations *dqi_ops ;
};
typedef __kernel_uid32_t qid_t;
typedef long long qsize_t;
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
struct dqstats {
   int lookups ;
   int drops ;
   int reads ;
   int writes ;
   int cache_hits ;
   int allocated_dquots ;
   int free_dquots ;
   int syncs ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   int (*reserve_space)(struct inode * , qsize_t  , int  ) ;
   int (*claim_space)(struct inode * , qsize_t  ) ;
   void (*release_rsv)(struct inode * , qsize_t  ) ;
   qsize_t (*get_reserved_space)(struct inode * ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
enum __anonenum_186 {
    _DQUOT_USAGE_ENABLED = 0,
    _DQUOT_LIMITS_ENABLED = 1,
    _DQUOT_SUSPENDED = 2,
    _DQUOT_STATE_FLAGS = 3
} ;
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
struct quota_module_name {
   int qm_fmt_id ;
   char *qm_mod_name ;
};
enum positive_aop_returns {
    AOP_WRITEPAGE_ACTIVATE = 524288,
    AOP_TRUNCATED_PAGE = 524289
} ;
struct iov_iter {
   struct iovec  const  *iov ;
   unsigned long nr_segs ;
   size_t iov_offset ;
   size_t count ;
};
union __anonunion_arg_188 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_187 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_188 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_187 read_descriptor_t;
typedef int (*read_actor_t)(read_descriptor_t * , struct page * , unsigned long  ,
                            unsigned long  );
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct inode_operations;
struct file_operations;
struct file_lock;
struct cdev;
union __anonunion____missing_field_name_189 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct dnotify_struct;
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_189 __annonCompField21 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
enum inode_i_mutex_lock_class {
    I_MUTEX_NORMAL = 0,
    I_MUTEX_PARENT = 1,
    I_MUTEX_CHILD = 2,
    I_MUTEX_XATTR = 3,
    I_MUTEX_QUOTA = 4
} ;
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_190 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_190 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
};
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
struct lock_manager {
   struct list_head list ;
};
enum nfs_stat {
    NFS_OK = 0,
    NFSERR_PERM = 1,
    NFSERR_NOENT = 2,
    NFSERR_IO = 5,
    NFSERR_NXIO = 6,
    NFSERR_EAGAIN = 11,
    NFSERR_ACCES = 13,
    NFSERR_EXIST = 17,
    NFSERR_XDEV = 18,
    NFSERR_NODEV = 19,
    NFSERR_NOTDIR = 20,
    NFSERR_ISDIR = 21,
    NFSERR_INVAL = 22,
    NFSERR_FBIG = 27,
    NFSERR_NOSPC = 28,
    NFSERR_ROFS = 30,
    NFSERR_MLINK = 31,
    NFSERR_OPNOTSUPP = 45,
    NFSERR_NAMETOOLONG = 63,
    NFSERR_NOTEMPTY = 66,
    NFSERR_DQUOT = 69,
    NFSERR_STALE = 70,
    NFSERR_REMOTE = 71,
    NFSERR_WFLUSH = 99,
    NFSERR_BADHANDLE = 10001,
    NFSERR_NOT_SYNC = 10002,
    NFSERR_BAD_COOKIE = 10003,
    NFSERR_NOTSUPP = 10004,
    NFSERR_TOOSMALL = 10005,
    NFSERR_SERVERFAULT = 10006,
    NFSERR_BADTYPE = 10007,
    NFSERR_JUKEBOX = 10008,
    NFSERR_SAME = 10009,
    NFSERR_DENIED = 10010,
    NFSERR_EXPIRED = 10011,
    NFSERR_LOCKED = 10012,
    NFSERR_GRACE = 10013,
    NFSERR_FHEXPIRED = 10014,
    NFSERR_SHARE_DENIED = 10015,
    NFSERR_WRONGSEC = 10016,
    NFSERR_CLID_INUSE = 10017,
    NFSERR_RESOURCE = 10018,
    NFSERR_MOVED = 10019,
    NFSERR_NOFILEHANDLE = 10020,
    NFSERR_MINOR_VERS_MISMATCH = 10021,
    NFSERR_STALE_CLIENTID = 10022,
    NFSERR_STALE_STATEID = 10023,
    NFSERR_OLD_STATEID = 10024,
    NFSERR_BAD_STATEID = 10025,
    NFSERR_BAD_SEQID = 10026,
    NFSERR_NOT_SAME = 10027,
    NFSERR_LOCK_RANGE = 10028,
    NFSERR_SYMLINK = 10029,
    NFSERR_RESTOREFH = 10030,
    NFSERR_LEASE_MOVED = 10031,
    NFSERR_ATTRNOTSUPP = 10032,
    NFSERR_NO_GRACE = 10033,
    NFSERR_RECLAIM_BAD = 10034,
    NFSERR_RECLAIM_CONFLICT = 10035,
    NFSERR_BAD_XDR = 10036,
    NFSERR_LOCKS_HELD = 10037,
    NFSERR_OPENMODE = 10038,
    NFSERR_BADOWNER = 10039,
    NFSERR_BADCHAR = 10040,
    NFSERR_BADNAME = 10041,
    NFSERR_BAD_RANGE = 10042,
    NFSERR_LOCK_NOTSUPP = 10043,
    NFSERR_OP_ILLEGAL = 10044,
    NFSERR_DEADLOCK = 10045,
    NFSERR_FILE_OPEN = 10046,
    NFSERR_ADMIN_REVOKED = 10047,
    NFSERR_CB_PATH_DOWN = 10048
} ;
enum nfs_ftype {
    NFNON = 0,
    NFREG = 1,
    NFDIR = 2,
    NFBLK = 3,
    NFCHR = 4,
    NFLNK = 5,
    NFSOCK = 6,
    NFBAD = 7,
    NFFIFO = 8
} ;
typedef u32 rpc_authflavor_t;
enum rpc_auth_flavors {
    RPC_AUTH_NULL = 0,
    RPC_AUTH_UNIX = 1,
    RPC_AUTH_SHORT = 2,
    RPC_AUTH_DES = 3,
    RPC_AUTH_KRB = 4,
    RPC_AUTH_GSS = 6,
    RPC_AUTH_MAXFLAVOR = 8,
    RPC_AUTH_GSS_KRB5 = 390003,
    RPC_AUTH_GSS_KRB5I = 390004,
    RPC_AUTH_GSS_KRB5P = 390005,
    RPC_AUTH_GSS_LKEY = 390006,
    RPC_AUTH_GSS_LKEYI = 390007,
    RPC_AUTH_GSS_LKEYP = 390008,
    RPC_AUTH_GSS_SPKM = 390009,
    RPC_AUTH_GSS_SPKMI = 390010,
    RPC_AUTH_GSS_SPKMP = 390011
} ;
enum rpc_msg_type {
    RPC_CALL = 0,
    RPC_REPLY = 1
} ;
enum rpc_reply_stat {
    RPC_MSG_ACCEPTED = 0,
    RPC_MSG_DENIED = 1
} ;
enum rpc_accept_stat {
    RPC_SUCCESS = 0,
    RPC_PROG_UNAVAIL = 1,
    RPC_PROG_MISMATCH = 2,
    RPC_PROC_UNAVAIL = 3,
    RPC_GARBAGE_ARGS = 4,
    RPC_SYSTEM_ERR = 5,
    RPC_DROP_REPLY = 60000
} ;
enum rpc_reject_stat {
    RPC_MISMATCH = 0,
    RPC_AUTH_ERROR = 1
} ;
enum rpc_auth_stat {
    RPC_AUTH_OK = 0,
    RPC_AUTH_BADCRED = 1,
    RPC_AUTH_REJECTEDCRED = 2,
    RPC_AUTH_BADVERF = 3,
    RPC_AUTH_REJECTEDVERF = 4,
    RPC_AUTH_TOOWEAK = 5,
    RPCSEC_GSS_CREDPROBLEM = 13,
    RPCSEC_GSS_CTXPROBLEM = 14
} ;
typedef __be32 rpc_fraghdr;
struct nfs_fh {
   unsigned short size ;
   unsigned char data[128] ;
};
enum nfs3_stable_how {
    NFS_UNSTABLE = 0,
    NFS_DATA_SYNC = 1,
    NFS_FILE_SYNC = 2
} ;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_192 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_191 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_192 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_191 fl_u ;
};
struct flock {
   short l_type ;
   short l_whence ;
   __kernel_off_t l_start ;
   __kernel_off_t l_len ;
   __kernel_pid_t l_pid ;
};
struct flock64 {
   short l_type ;
   short l_whence ;
   __kernel_loff_t l_start ;
   __kernel_loff_t l_len ;
   __kernel_pid_t l_pid ;
};
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
struct file_system_type;
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
enum __anonenum_193 {
    SB_UNFROZEN = 0,
    SB_FREEZE_WRITE = 1,
    SB_FREEZE_TRANS = 2
} ;
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
typedef int (*filldir_t)(void * , char const   * , int  , loff_t  , u64  , unsigned int  );
struct block_device_operations;
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
enum __anonenum_194 {
    DIO_LOCKING = 1,
    DIO_NO_LOCKING = 2,
    DIO_OWN_LOCKING = 3
} ;
struct tree_descr {
   char *name ;
   struct file_operations  const  *ops ;
   int mode ;
};
struct simple_transaction_argresp {
   ssize_t size ;
   char data[0] ;
};
struct usb_device;
struct usb_driver;
struct wusb_dev;
struct ep_device;
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
};
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
   unsigned char *extra ;
   int extralen ;
};
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned int is_active : 1 ;
   unsigned int sysfs_files_created : 1 ;
   unsigned int ep_devs_created : 1 ;
   unsigned int unregistering : 1 ;
   unsigned int needs_remote_wakeup : 1 ;
   unsigned int needs_altsetting0 : 1 ;
   unsigned int needs_binding : 1 ;
   unsigned int reset_running : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   int pm_usage_cnt ;
   struct work_struct reset_ws ;
};
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0] ;
};
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16] ;
   struct usb_interface *interface[32] ;
   struct usb_interface_cache *intf_cache[32] ;
   unsigned char *extra ;
   int extralen ;
};
struct usb_devmap {
   unsigned long devicemap[128UL / (8UL * sizeof(unsigned long ))] ;
};
struct mon_bus;
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 otg_port ;
   unsigned int is_b_host : 1 ;
   unsigned int b_hnp_enable : 1 ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   struct dentry *usbfs_dentry ;
   struct device *dev ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
struct usb_tt;
struct usb_device {
   int devnum ;
   char devpath[16] ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16] ;
   struct usb_host_endpoint *ep_out[16] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned int can_submit : 1 ;
   unsigned int discon_suspended : 1 ;
   unsigned int persist_enabled : 1 ;
   unsigned int have_langid : 1 ;
   unsigned int authorized : 1 ;
   unsigned int authenticated : 1 ;
   unsigned int wusb : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   struct dentry *usbfs_dentry ;
   int maxchild ;
   struct usb_device *children[31] ;
   int pm_usage_cnt ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   struct delayed_work autosuspend ;
   struct work_struct autoresume ;
   struct mutex pm_mutex ;
   unsigned long last_busy ;
   int autosuspend_delay ;
   unsigned long connect_time ;
   unsigned int auto_pm : 1 ;
   unsigned int do_remote_wakeup : 1 ;
   unsigned int reset_resume : 1 ;
   unsigned int autosuspend_disabled : 1 ;
   unsigned int autoresume_disabled : 1 ;
   unsigned int skip_sys_resume : 1 ;
   struct wusb_dev *wusb_dev ;
};
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
struct usb_dynid {
   struct list_head node ;
   struct usb_device_id id ;
};
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface *intf , struct usb_device_id  const  *id ) ;
   void (*disconnect)(struct usb_interface *intf ) ;
   int (*ioctl)(struct usb_interface *intf , unsigned int code , void *buf ) ;
   int (*suspend)(struct usb_interface *intf , pm_message_t message ) ;
   int (*resume)(struct usb_interface *intf ) ;
   int (*reset_resume)(struct usb_interface *intf ) ;
   int (*pre_reset)(struct usb_interface *intf ) ;
   int (*post_reset)(struct usb_interface *intf ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned int no_dynamic_id : 1 ;
   unsigned int supports_autosuspend : 1 ;
   unsigned int soft_unbind : 1 ;
};
struct usb_device_driver {
   char const   *name ;
   int (*probe)(struct usb_device *udev ) ;
   void (*disconnect)(struct usb_device *udev ) ;
   int (*suspend)(struct usb_device *udev , pm_message_t message ) ;
   int (*resume)(struct usb_device *udev , pm_message_t message ) ;
   struct usbdrv_wrap drvwrap ;
   unsigned int supports_autosuspend : 1 ;
};
struct usb_class_driver {
   char *name ;
   struct file_operations  const  *fops ;
   int minor_base ;
};
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
struct urb;
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned int poisoned : 1 ;
};
typedef void (*usb_complete_t)(struct urb * );
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0] ;
};
struct usb_sg_request {
   int status ;
   size_t bytes ;
   spinlock_t lock ;
   struct usb_device *dev ;
   int pipe ;
   struct scatterlist *sg ;
   int nents ;
   int entries ;
   struct urb **urbs ;
   int count ;
   struct completion complete ;
};
struct hc_driver;
struct usb_hcd {
   struct usb_bus self ;
   struct kref kref ;
   char const   *product_desc ;
   char irq_descr[24] ;
   struct timer_list rh_timer ;
   struct urb *status_urb ;
   struct work_struct wakeup_work ;
   struct hc_driver  const  *driver ;
   unsigned long flags ;
   unsigned int rh_registered : 1 ;
   unsigned int uses_new_polling : 1 ;
   unsigned int poll_rh : 1 ;
   unsigned int poll_pending : 1 ;
   unsigned int wireless : 1 ;
   unsigned int authorized_default : 1 ;
   unsigned int has_tt : 1 ;
   int irq ;
   void *regs ;
   u64 rsrc_start ;
   u64 rsrc_len ;
   unsigned int power_budget ;
   struct dma_pool *pool[4] ;
   int state ;
   unsigned long hcd_priv[0]  __attribute__((__aligned__(sizeof(unsigned long )))) ;
};
struct hcd_timeout {
   struct list_head timeout_list ;
   struct timer_list timer ;
};
struct hc_driver {
   char const   *description ;
   char const   *product_desc ;
   size_t hcd_priv_size ;
   irqreturn_t (*irq)(struct usb_hcd *hcd ) ;
   int flags ;
   int (*reset)(struct usb_hcd *hcd ) ;
   int (*start)(struct usb_hcd *hcd ) ;
   int (*pci_suspend)(struct usb_hcd *hcd , pm_message_t message ) ;
   int (*pci_resume)(struct usb_hcd *hcd ) ;
   void (*stop)(struct usb_hcd *hcd ) ;
   void (*shutdown)(struct usb_hcd *hcd ) ;
   int (*get_frame_number)(struct usb_hcd *hcd ) ;
   int (*urb_enqueue)(struct usb_hcd *hcd , struct urb *urb , gfp_t mem_flags ) ;
   int (*urb_dequeue)(struct usb_hcd *hcd , struct urb *urb , int status ) ;
   void (*endpoint_disable)(struct usb_hcd *hcd , struct usb_host_endpoint *ep ) ;
   void (*endpoint_reset)(struct usb_hcd *hcd , struct usb_host_endpoint *ep ) ;
   int (*hub_status_data)(struct usb_hcd *hcd , char *buf ) ;
   int (*hub_control)(struct usb_hcd *hcd , u16 typeReq , u16 wValue , u16 wIndex ,
                      char *buf , u16 wLength ) ;
   int (*bus_suspend)(struct usb_hcd * ) ;
   int (*bus_resume)(struct usb_hcd * ) ;
   int (*start_port_reset)(struct usb_hcd * , unsigned int port_num ) ;
   void (*relinquish_port)(struct usb_hcd * , int  ) ;
   int (*port_handed_over)(struct usb_hcd * , int  ) ;
   void (*clear_tt_buffer_complete)(struct usb_hcd * , struct usb_host_endpoint * ) ;
};
struct platform_device;
struct usb_port_status {
   __le16 wPortStatus ;
   __le16 wPortChange ;
} __attribute__((__packed__)) ;
struct usb_hub_status {
   __le16 wHubStatus ;
   __le16 wHubChange ;
} __attribute__((__packed__)) ;
struct usb_hub_descriptor {
   __u8 bDescLength ;
   __u8 bDescriptorType ;
   __u8 bNbrPorts ;
   __le16 wHubCharacteristics ;
   __u8 bPwrOn2PwrGood ;
   __u8 bHubContrCurrent ;
   __u8 DeviceRemovable[4] ;
   __u8 PortPwrCtrlMask[4] ;
} __attribute__((__packed__)) ;
enum hub_led_mode {
    INDICATOR_AUTO = 0,
    INDICATOR_CYCLE = 1,
    INDICATOR_GREEN_BLINK = 2,
    INDICATOR_GREEN_BLINK_OFF = 3,
    INDICATOR_AMBER_BLINK = 4,
    INDICATOR_AMBER_BLINK_OFF = 5,
    INDICATOR_ALT_BLINK = 6,
    INDICATOR_ALT_BLINK_OFF = 7
}  __attribute__((__packed__)) ;
struct usb_tt {
   struct usb_device *hub ;
   int multi ;
   unsigned int think_time ;
   spinlock_t lock ;
   struct list_head clear_list ;
   struct work_struct clear_work ;
};
struct usb_tt_clear {
   struct list_head clear_list ;
   unsigned int tt ;
   u16 devinfo ;
   struct usb_hcd *hcd ;
   struct usb_host_endpoint *ep ;
};
struct usb_mon_operations {
   void (*urb_submit)(struct usb_bus *bus , struct urb *urb ) ;
   void (*urb_submit_error)(struct usb_bus *bus , struct urb *urb , int err ) ;
   void (*urb_complete)(struct usb_bus *bus , struct urb *urb , int status ) ;
};
enum __anonenum_4___0 {
    false___0 = 0,
    true___0 = 1
} ;
enum __anonenum_9 {
    DUMP_PREFIX_NONE___0 = 0,
    DUMP_PREFIX_ADDRESS___0 = 1,
    DUMP_PREFIX_OFFSET___0 = 2
} ;
enum __anonenum_21___0 {
    PG_LEVEL_NONE___0 = 0,
    PG_LEVEL_4K___0 = 1,
    PG_LEVEL_2M___0 = 2,
    PG_LEVEL_1G___0 = 3,
    PG_LEVEL_NUM___0 = 4
} ;
enum __anonenum_25 {
    GATE_INTERRUPT___0 = 14,
    GATE_TRAP___0 = 15,
    GATE_CALL___0 = 12,
    GATE_TASK___0 = 5
} ;
enum __anonenum_26 {
    DESC_TSS___0 = 9,
    DESC_LDT___0 = 2,
    DESCTYPE_S___0 = 16
} ;
enum __anonenum_27 {
    ADDR_NO_RANDOMIZE___0 = 262144,
    FDPIC_FUNCPTRS___0 = 524288,
    MMAP_PAGE_ZERO___0 = 1048576,
    ADDR_COMPAT_LAYOUT___0 = 2097152,
    READ_IMPLIES_EXEC___0 = 4194304,
    ADDR_LIMIT_32BIT___0 = 8388608,
    SHORT_INODE___0 = 16777216,
    WHOLE_SECONDS___0 = 33554432,
    STICKY_TIMEOUTS___0 = 67108864,
    ADDR_LIMIT_3GB___0 = 134217728
} ;
enum __anonenum_28 {
    PER_LINUX___0 = 0,
    PER_LINUX_32BIT___0 = 8388608,
    PER_LINUX_FDPIC___0 = 524288,
    PER_SVR4___0 = 68157441,
    PER_SVR3___0 = 83886082,
    PER_SCOSVR3___0 = 117440515,
    PER_OSR5___0 = 100663299,
    PER_WYSEV386___0 = 83886084,
    PER_ISCR4___0 = 67108869,
    PER_BSD___0 = 6,
    PER_SUNOS___0 = 67108870,
    PER_XENIX___0 = 83886087,
    PER_LINUX32___0 = 8,
    PER_LINUX32_3GB___0 = 134217736,
    PER_IRIX32___0 = 67108873,
    PER_IRIXN32___0 = 67108874,
    PER_IRIX64___0 = 67108875,
    PER_RISCOS___0 = 12,
    PER_SOLARIS___0 = 67108877,
    PER_UW7___0 = 68157454,
    PER_OSF4___0 = 15,
    PER_HPUX___0 = 16,
    PER_MASK___0 = 255
} ;
union __anonunion_d_39 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_113 {
    CTL_KERN___0 = 1,
    CTL_VM___0 = 2,
    CTL_NET___0 = 3,
    CTL_PROC___0 = 4,
    CTL_FS___0 = 5,
    CTL_DEBUG___0 = 6,
    CTL_DEV___0 = 7,
    CTL_BUS___0 = 8,
    CTL_ABI___0 = 9,
    CTL_CPU___0 = 10,
    CTL_ARLAN___0 = 254,
    CTL_S390DBF___0 = 5677,
    CTL_SUNRPC___0 = 7249,
    CTL_PM___0 = 9899,
    CTL_FRV___0 = 9898
} ;
enum __anonenum_114 {
    CTL_BUS_ISA___0 = 1
} ;
enum __anonenum_115 {
    INOTIFY_MAX_USER_INSTANCES___0 = 1,
    INOTIFY_MAX_USER_WATCHES___0 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___0 = 3
} ;
enum __anonenum_116 {
    KERN_OSTYPE___0 = 1,
    KERN_OSRELEASE___0 = 2,
    KERN_OSREV___0 = 3,
    KERN_VERSION___0 = 4,
    KERN_SECUREMASK___0 = 5,
    KERN_PROF___0 = 6,
    KERN_NODENAME___0 = 7,
    KERN_DOMAINNAME___0 = 8,
    KERN_PANIC___0 = 15,
    KERN_REALROOTDEV___0 = 16,
    KERN_SPARC_REBOOT___0 = 21,
    KERN_CTLALTDEL___0 = 22,
    KERN_PRINTK___0 = 23,
    KERN_NAMETRANS___0 = 24,
    KERN_PPC_HTABRECLAIM___0 = 25,
    KERN_PPC_ZEROPAGED___0 = 26,
    KERN_PPC_POWERSAVE_NAP___0 = 27,
    KERN_MODPROBE___0 = 28,
    KERN_SG_BIG_BUFF___0 = 29,
    KERN_ACCT___0 = 30,
    KERN_PPC_L2CR___0 = 31,
    KERN_RTSIGNR___0 = 32,
    KERN_RTSIGMAX___0 = 33,
    KERN_SHMMAX___0 = 34,
    KERN_MSGMAX___0 = 35,
    KERN_MSGMNB___0 = 36,
    KERN_MSGPOOL___0 = 37,
    KERN_SYSRQ___0 = 38,
    KERN_MAX_THREADS___0 = 39,
    KERN_RANDOM___0 = 40,
    KERN_SHMALL___0 = 41,
    KERN_MSGMNI___0 = 42,
    KERN_SEM___0 = 43,
    KERN_SPARC_STOP_A___0 = 44,
    KERN_SHMMNI___0 = 45,
    KERN_OVERFLOWUID___0 = 46,
    KERN_OVERFLOWGID___0 = 47,
    KERN_SHMPATH___0 = 48,
    KERN_HOTPLUG___0 = 49,
    KERN_IEEE_EMULATION_WARNINGS___0 = 50,
    KERN_S390_USER_DEBUG_LOGGING___0 = 51,
    KERN_CORE_USES_PID___0 = 52,
    KERN_TAINTED___0 = 53,
    KERN_CADPID___0 = 54,
    KERN_PIDMAX___0 = 55,
    KERN_CORE_PATTERN___0 = 56,
    KERN_PANIC_ON_OOPS___0 = 57,
    KERN_HPPA_PWRSW___0 = 58,
    KERN_HPPA_UNALIGNED___0 = 59,
    KERN_PRINTK_RATELIMIT___0 = 60,
    KERN_PRINTK_RATELIMIT_BURST___0 = 61,
    KERN_PTY___0 = 62,
    KERN_NGROUPS_MAX___0 = 63,
    KERN_SPARC_SCONS_PWROFF___0 = 64,
    KERN_HZ_TIMER___0 = 65,
    KERN_UNKNOWN_NMI_PANIC___0 = 66,
    KERN_BOOTLOADER_TYPE___0 = 67,
    KERN_RANDOMIZE___0 = 68,
    KERN_SETUID_DUMPABLE___0 = 69,
    KERN_SPIN_RETRY___0 = 70,
    KERN_ACPI_VIDEO_FLAGS___0 = 71,
    KERN_IA64_UNALIGNED___0 = 72,
    KERN_COMPAT_LOG___0 = 73,
    KERN_MAX_LOCK_DEPTH___0 = 74,
    KERN_NMI_WATCHDOG___0 = 75,
    KERN_PANIC_ON_NMI___0 = 76
} ;
enum __anonenum_117 {
    VM_UNUSED1___0 = 1,
    VM_UNUSED2___0 = 2,
    VM_UNUSED3___0 = 3,
    VM_UNUSED4___0 = 4,
    VM_OVERCOMMIT_MEMORY___0 = 5,
    VM_UNUSED5___0 = 6,
    VM_UNUSED7___0 = 7,
    VM_UNUSED8___0 = 8,
    VM_UNUSED9___0 = 9,
    VM_PAGE_CLUSTER___0 = 10,
    VM_DIRTY_BACKGROUND___0 = 11,
    VM_DIRTY_RATIO___0 = 12,
    VM_DIRTY_WB_CS___0 = 13,
    VM_DIRTY_EXPIRE_CS___0 = 14,
    VM_NR_PDFLUSH_THREADS___0 = 15,
    VM_OVERCOMMIT_RATIO___0 = 16,
    VM_PAGEBUF___0 = 17,
    VM_HUGETLB_PAGES___0 = 18,
    VM_SWAPPINESS___0 = 19,
    VM_LOWMEM_RESERVE_RATIO___0 = 20,
    VM_MIN_FREE_KBYTES___0 = 21,
    VM_MAX_MAP_COUNT___0 = 22,
    VM_LAPTOP_MODE___0 = 23,
    VM_BLOCK_DUMP___0 = 24,
    VM_HUGETLB_GROUP___0 = 25,
    VM_VFS_CACHE_PRESSURE___0 = 26,
    VM_LEGACY_VA_LAYOUT___0 = 27,
    VM_SWAP_TOKEN_TIMEOUT___0 = 28,
    VM_DROP_PAGECACHE___0 = 29,
    VM_PERCPU_PAGELIST_FRACTION___0 = 30,
    VM_ZONE_RECLAIM_MODE___0 = 31,
    VM_MIN_UNMAPPED___0 = 32,
    VM_PANIC_ON_OOM___0 = 33,
    VM_VDSO_ENABLED___0 = 34,
    VM_MIN_SLAB___0 = 35
} ;
enum __anonenum_118 {
    NET_CORE___0 = 1,
    NET_ETHER___0 = 2,
    NET_802___0 = 3,
    NET_UNIX___0 = 4,
    NET_IPV4___0 = 5,
    NET_IPX___0 = 6,
    NET_ATALK___0 = 7,
    NET_NETROM___0 = 8,
    NET_AX25___0 = 9,
    NET_BRIDGE___0 = 10,
    NET_ROSE___0 = 11,
    NET_IPV6___0 = 12,
    NET_X25___0 = 13,
    NET_TR___0 = 14,
    NET_DECNET___0 = 15,
    NET_ECONET___0 = 16,
    NET_SCTP___0 = 17,
    NET_LLC___0 = 18,
    NET_NETFILTER___0 = 19,
    NET_DCCP___0 = 20,
    NET_IRDA___0 = 412
} ;
enum __anonenum_119 {
    RANDOM_POOLSIZE___0 = 1,
    RANDOM_ENTROPY_COUNT___0 = 2,
    RANDOM_READ_THRESH___0 = 3,
    RANDOM_WRITE_THRESH___0 = 4,
    RANDOM_BOOT_ID___0 = 5,
    RANDOM_UUID___0 = 6
} ;
enum __anonenum_120___0 {
    PTY_MAX___0 = 1,
    PTY_NR___0 = 2
} ;
enum __anonenum_121___0 {
    BUS_ISA_MEM_BASE___0 = 1,
    BUS_ISA_PORT_BASE___0 = 2,
    BUS_ISA_PORT_SHIFT___0 = 3
} ;
enum __anonenum_122___0 {
    NET_CORE_WMEM_MAX___0 = 1,
    NET_CORE_RMEM_MAX___0 = 2,
    NET_CORE_WMEM_DEFAULT___0 = 3,
    NET_CORE_RMEM_DEFAULT___0 = 4,
    NET_CORE_MAX_BACKLOG___0 = 6,
    NET_CORE_FASTROUTE___0 = 7,
    NET_CORE_MSG_COST___0 = 8,
    NET_CORE_MSG_BURST___0 = 9,
    NET_CORE_OPTMEM_MAX___0 = 10,
    NET_CORE_HOT_LIST_LENGTH___0 = 11,
    NET_CORE_DIVERT_VERSION___0 = 12,
    NET_CORE_NO_CONG_THRESH___0 = 13,
    NET_CORE_NO_CONG___0 = 14,
    NET_CORE_LO_CONG___0 = 15,
    NET_CORE_MOD_CONG___0 = 16,
    NET_CORE_DEV_WEIGHT___0 = 17,
    NET_CORE_SOMAXCONN___0 = 18,
    NET_CORE_BUDGET___0 = 19,
    NET_CORE_AEVENT_ETIME___0 = 20,
    NET_CORE_AEVENT_RSEQTH___0 = 21,
    NET_CORE_WARNINGS___0 = 22
} ;
enum __anonenum_123___0 {
    NET_UNIX_DESTROY_DELAY___0 = 1,
    NET_UNIX_DELETE_DELAY___0 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___0 = 3
} ;
enum __anonenum_124___0 {
    NET_NF_CONNTRACK_MAX___0 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___0 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___0 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___0 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___0 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___0 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___0 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___0 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___0 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___0 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___0 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___0 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___0 = 13,
    NET_NF_CONNTRACK_BUCKETS___0 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___0 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___0 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___0 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___0 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___0 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___0 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___0 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___0 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___0 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___0 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___0 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___0 = 26,
    NET_NF_CONNTRACK_COUNT___0 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___0 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___0 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___0 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___0 = 31,
    NET_NF_CONNTRACK_CHECKSUM___0 = 32
} ;
enum __anonenum_125___0 {
    NET_IPV4_FORWARD___0 = 8,
    NET_IPV4_DYNADDR___0 = 9,
    NET_IPV4_CONF___0 = 16,
    NET_IPV4_NEIGH___0 = 17,
    NET_IPV4_ROUTE___0 = 18,
    NET_IPV4_FIB_HASH___0 = 19,
    NET_IPV4_NETFILTER___0 = 20,
    NET_IPV4_TCP_TIMESTAMPS___0 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___0 = 34,
    NET_IPV4_TCP_SACK___0 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___0 = 36,
    NET_IPV4_DEFAULT_TTL___0 = 37,
    NET_IPV4_AUTOCONFIG___0 = 38,
    NET_IPV4_NO_PMTU_DISC___0 = 39,
    NET_IPV4_TCP_SYN_RETRIES___0 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___0 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___0 = 42,
    NET_IPV4_IPFRAG_TIME___0 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___0 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___0 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___0 = 46,
    NET_IPV4_TCP_RETRIES1___0 = 47,
    NET_IPV4_TCP_RETRIES2___0 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___0 = 49,
    NET_IPV4_IP_MASQ_DEBUG___0 = 50,
    NET_TCP_SYNCOOKIES___0 = 51,
    NET_TCP_STDURG___0 = 52,
    NET_TCP_RFC1337___0 = 53,
    NET_TCP_SYN_TAILDROP___0 = 54,
    NET_TCP_MAX_SYN_BACKLOG___0 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___0 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___0 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___0 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___0 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___0 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___0 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___0 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___0 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___0 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___0 = 65,
    NET_TCP_TW_RECYCLE___0 = 66,
    NET_IPV4_ALWAYS_DEFRAG___0 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___0 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___0 = 69,
    NET_IPV4_INET_PEER_MINTTL___0 = 70,
    NET_IPV4_INET_PEER_MAXTTL___0 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___0 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___0 = 73,
    NET_TCP_ORPHAN_RETRIES___0 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___0 = 75,
    NET_TCP_SYNACK_RETRIES___0 = 76,
    NET_TCP_MAX_ORPHANS___0 = 77,
    NET_TCP_MAX_TW_BUCKETS___0 = 78,
    NET_TCP_FACK___0 = 79,
    NET_TCP_REORDERING___0 = 80,
    NET_TCP_ECN___0 = 81,
    NET_TCP_DSACK___0 = 82,
    NET_TCP_MEM___0 = 83,
    NET_TCP_WMEM___0 = 84,
    NET_TCP_RMEM___0 = 85,
    NET_TCP_APP_WIN___0 = 86,
    NET_TCP_ADV_WIN_SCALE___0 = 87,
    NET_IPV4_NONLOCAL_BIND___0 = 88,
    NET_IPV4_ICMP_RATELIMIT___0 = 89,
    NET_IPV4_ICMP_RATEMASK___0 = 90,
    NET_TCP_TW_REUSE___0 = 91,
    NET_TCP_FRTO___0 = 92,
    NET_TCP_LOW_LATENCY___0 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___0 = 94,
    NET_IPV4_IGMP_MAX_MSF___0 = 96,
    NET_TCP_NO_METRICS_SAVE___0 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___0 = 105,
    NET_TCP_MODERATE_RCVBUF___0 = 106,
    NET_TCP_TSO_WIN_DIVISOR___0 = 107,
    NET_TCP_BIC_BETA___0 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___0 = 109,
    NET_TCP_CONG_CONTROL___0 = 110,
    NET_TCP_ABC___0 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___0 = 112,
    NET_TCP_MTU_PROBING___0 = 113,
    NET_TCP_BASE_MSS___0 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___0 = 115,
    NET_TCP_DMA_COPYBREAK___0 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___0 = 117,
    NET_CIPSOV4_CACHE_ENABLE___0 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___0 = 119,
    NET_CIPSOV4_RBM_OPTFMT___0 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___0 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___0 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___0 = 123,
    NET_TCP_MAX_SSTHRESH___0 = 124,
    NET_TCP_FRTO_RESPONSE___0 = 125
} ;
enum __anonenum_126___0 {
    NET_IPV4_ROUTE_FLUSH___0 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___0 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___0 = 3,
    NET_IPV4_ROUTE_GC_THRESH___0 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___0 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___0 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___0 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___0 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___0 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___0 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___0 = 11,
    NET_IPV4_ROUTE_ERROR_COST___0 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___0 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___0 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___0 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___0 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___0 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___0 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___0 = 19
} ;
enum __anonenum_127___0 {
    NET_PROTO_CONF_ALL___0 = -2,
    NET_PROTO_CONF_DEFAULT___0 = -3
} ;
enum __anonenum_128___0 {
    NET_IPV4_CONF_FORWARDING___0 = 1,
    NET_IPV4_CONF_MC_FORWARDING___0 = 2,
    NET_IPV4_CONF_PROXY_ARP___0 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___0 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___0 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___0 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___0 = 7,
    NET_IPV4_CONF_RP_FILTER___0 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___0 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___0 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___0 = 11,
    NET_IPV4_CONF_TAG___0 = 12,
    NET_IPV4_CONF_ARPFILTER___0 = 13,
    NET_IPV4_CONF_MEDIUM_ID___0 = 14,
    NET_IPV4_CONF_NOXFRM___0 = 15,
    NET_IPV4_CONF_NOPOLICY___0 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___0 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___0 = 18,
    NET_IPV4_CONF_ARP_IGNORE___0 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___0 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___0 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___0 = 22,
    __NET_IPV4_CONF_MAX___0 = 23
} ;
enum __anonenum_129___0 {
    NET_IPV4_NF_CONNTRACK_MAX___0 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___0 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___0 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___0 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___0 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___0 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___0 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___0 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___0 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___0 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___0 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___0 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___0 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___0 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___0 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___0 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___0 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___0 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___0 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___0 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___0 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___0 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___0 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___0 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___0 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___0 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___0 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___0 = 28
} ;
enum __anonenum_130___0 {
    NET_IPV6_CONF___0 = 16,
    NET_IPV6_NEIGH___0 = 17,
    NET_IPV6_ROUTE___0 = 18,
    NET_IPV6_ICMP___0 = 19,
    NET_IPV6_BINDV6ONLY___0 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___0 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___0 = 22,
    NET_IPV6_IP6FRAG_TIME___0 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___0 = 24,
    NET_IPV6_MLD_MAX_MSF___0 = 25
} ;
enum __anonenum_131___0 {
    NET_IPV6_ROUTE_FLUSH___0 = 1,
    NET_IPV6_ROUTE_GC_THRESH___0 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___0 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___0 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___0 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___0 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___0 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___0 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___0 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___0 = 10
} ;
enum __anonenum_132___0 {
    NET_IPV6_FORWARDING___0 = 1,
    NET_IPV6_HOP_LIMIT___0 = 2,
    NET_IPV6_MTU___0 = 3,
    NET_IPV6_ACCEPT_RA___0 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___0 = 5,
    NET_IPV6_AUTOCONF___0 = 6,
    NET_IPV6_DAD_TRANSMITS___0 = 7,
    NET_IPV6_RTR_SOLICITS___0 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___0 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___0 = 10,
    NET_IPV6_USE_TEMPADDR___0 = 11,
    NET_IPV6_TEMP_VALID_LFT___0 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___0 = 13,
    NET_IPV6_REGEN_MAX_RETRY___0 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___0 = 15,
    NET_IPV6_MAX_ADDRESSES___0 = 16,
    NET_IPV6_FORCE_MLD_VERSION___0 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___0 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___0 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___0 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___0 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___0 = 22,
    NET_IPV6_PROXY_NDP___0 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___0 = 25,
    __NET_IPV6_MAX___0 = 26
} ;
enum __anonenum_133___0 {
    NET_IPV6_ICMP_RATELIMIT___0 = 1
} ;
enum __anonenum_134___0 {
    NET_NEIGH_MCAST_SOLICIT___0 = 1,
    NET_NEIGH_UCAST_SOLICIT___0 = 2,
    NET_NEIGH_APP_SOLICIT___0 = 3,
    NET_NEIGH_RETRANS_TIME___0 = 4,
    NET_NEIGH_REACHABLE_TIME___0 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___0 = 6,
    NET_NEIGH_GC_STALE_TIME___0 = 7,
    NET_NEIGH_UNRES_QLEN___0 = 8,
    NET_NEIGH_PROXY_QLEN___0 = 9,
    NET_NEIGH_ANYCAST_DELAY___0 = 10,
    NET_NEIGH_PROXY_DELAY___0 = 11,
    NET_NEIGH_LOCKTIME___0 = 12,
    NET_NEIGH_GC_INTERVAL___0 = 13,
    NET_NEIGH_GC_THRESH1___0 = 14,
    NET_NEIGH_GC_THRESH2___0 = 15,
    NET_NEIGH_GC_THRESH3___0 = 16,
    NET_NEIGH_RETRANS_TIME_MS___0 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___0 = 18,
    __NET_NEIGH_MAX___0 = 19
} ;
enum __anonenum_135___0 {
    NET_DCCP_DEFAULT___0 = 1
} ;
enum __anonenum_136___0 {
    NET_IPX_PPROP_BROADCASTING___0 = 1,
    NET_IPX_FORWARDING___0 = 2
} ;
enum __anonenum_137___0 {
    NET_LLC2___0 = 1,
    NET_LLC_STATION___0 = 2
} ;
enum __anonenum_138___0 {
    NET_LLC2_TIMEOUT___0 = 1
} ;
enum __anonenum_139___0 {
    NET_LLC_STATION_ACK_TIMEOUT___0 = 1
} ;
enum __anonenum_140___0 {
    NET_LLC2_ACK_TIMEOUT___0 = 1,
    NET_LLC2_P_TIMEOUT___0 = 2,
    NET_LLC2_REJ_TIMEOUT___0 = 3,
    NET_LLC2_BUSY_TIMEOUT___0 = 4
} ;
enum __anonenum_141___0 {
    NET_ATALK_AARP_EXPIRY_TIME___0 = 1,
    NET_ATALK_AARP_TICK_TIME___0 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___0 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___0 = 4
} ;
enum __anonenum_142___0 {
    NET_NETROM_DEFAULT_PATH_QUALITY___0 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___0 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___0 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___0 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___0 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___0 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___0 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___0 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___0 = 9,
    NET_NETROM_ROUTING_CONTROL___0 = 10,
    NET_NETROM_LINK_FAILS_COUNT___0 = 11,
    NET_NETROM_RESET___0 = 12
} ;
enum __anonenum_143___0 {
    NET_AX25_IP_DEFAULT_MODE___0 = 1,
    NET_AX25_DEFAULT_MODE___0 = 2,
    NET_AX25_BACKOFF_TYPE___0 = 3,
    NET_AX25_CONNECT_MODE___0 = 4,
    NET_AX25_STANDARD_WINDOW___0 = 5,
    NET_AX25_EXTENDED_WINDOW___0 = 6,
    NET_AX25_T1_TIMEOUT___0 = 7,
    NET_AX25_T2_TIMEOUT___0 = 8,
    NET_AX25_T3_TIMEOUT___0 = 9,
    NET_AX25_IDLE_TIMEOUT___0 = 10,
    NET_AX25_N2___0 = 11,
    NET_AX25_PACLEN___0 = 12,
    NET_AX25_PROTOCOL___0 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___0 = 14
} ;
enum __anonenum_144___0 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___0 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___0 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___0 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___0 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___0 = 5,
    NET_ROSE_ROUTING_CONTROL___0 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___0 = 7,
    NET_ROSE_MAX_VCS___0 = 8,
    NET_ROSE_WINDOW_SIZE___0 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___0 = 10
} ;
enum __anonenum_145___0 {
    NET_X25_RESTART_REQUEST_TIMEOUT___0 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___0 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___0 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___0 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___0 = 5,
    NET_X25_FORWARD___0 = 6
} ;
enum __anonenum_146___0 {
    NET_TR_RIF_TIMEOUT___0 = 1
} ;
enum __anonenum_147___0 {
    NET_DECNET_NODE_TYPE___0 = 1,
    NET_DECNET_NODE_ADDRESS___0 = 2,
    NET_DECNET_NODE_NAME___0 = 3,
    NET_DECNET_DEFAULT_DEVICE___0 = 4,
    NET_DECNET_TIME_WAIT___0 = 5,
    NET_DECNET_DN_COUNT___0 = 6,
    NET_DECNET_DI_COUNT___0 = 7,
    NET_DECNET_DR_COUNT___0 = 8,
    NET_DECNET_DST_GC_INTERVAL___0 = 9,
    NET_DECNET_CONF___0 = 10,
    NET_DECNET_NO_FC_MAX_CWND___0 = 11,
    NET_DECNET_MEM___0 = 12,
    NET_DECNET_RMEM___0 = 13,
    NET_DECNET_WMEM___0 = 14,
    NET_DECNET_DEBUG_LEVEL___0 = 255
} ;
enum __anonenum_148___0 {
    NET_DECNET_CONF_LOOPBACK___0 = -2,
    NET_DECNET_CONF_DDCMP___0 = -3,
    NET_DECNET_CONF_PPP___0 = -4,
    NET_DECNET_CONF_X25___0 = -5,
    NET_DECNET_CONF_GRE___0 = -6,
    NET_DECNET_CONF_ETHER___0 = -7
} ;
enum __anonenum_149___0 {
    NET_DECNET_CONF_DEV_PRIORITY___0 = 1,
    NET_DECNET_CONF_DEV_T1___0 = 2,
    NET_DECNET_CONF_DEV_T2___0 = 3,
    NET_DECNET_CONF_DEV_T3___0 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___0 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___0 = 6,
    NET_DECNET_CONF_DEV_STATE___0 = 7
} ;
enum __anonenum_150___0 {
    NET_SCTP_RTO_INITIAL___0 = 1,
    NET_SCTP_RTO_MIN___0 = 2,
    NET_SCTP_RTO_MAX___0 = 3,
    NET_SCTP_RTO_ALPHA___0 = 4,
    NET_SCTP_RTO_BETA___0 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___0 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___0 = 7,
    NET_SCTP_PATH_MAX_RETRANS___0 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___0 = 9,
    NET_SCTP_HB_INTERVAL___0 = 10,
    NET_SCTP_PRESERVE_ENABLE___0 = 11,
    NET_SCTP_MAX_BURST___0 = 12,
    NET_SCTP_ADDIP_ENABLE___0 = 13,
    NET_SCTP_PRSCTP_ENABLE___0 = 14,
    NET_SCTP_SNDBUF_POLICY___0 = 15,
    NET_SCTP_SACK_TIMEOUT___0 = 16,
    NET_SCTP_RCVBUF_POLICY___0 = 17
} ;
enum __anonenum_151___0 {
    NET_BRIDGE_NF_CALL_ARPTABLES___0 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___0 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___0 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___0 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___0 = 5
} ;
enum __anonenum_152___0 {
    NET_IRDA_DISCOVERY___0 = 1,
    NET_IRDA_DEVNAME___0 = 2,
    NET_IRDA_DEBUG___0 = 3,
    NET_IRDA_FAST_POLL___0 = 4,
    NET_IRDA_DISCOVERY_SLOTS___0 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___0 = 6,
    NET_IRDA_SLOT_TIMEOUT___0 = 7,
    NET_IRDA_MAX_BAUD_RATE___0 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___0 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___0 = 10,
    NET_IRDA_MAX_TX_WINDOW___0 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___0 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___0 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___0 = 14
} ;
enum __anonenum_153___0 {
    FS_NRINODE___0 = 1,
    FS_STATINODE___0 = 2,
    FS_MAXINODE___0 = 3,
    FS_NRDQUOT___0 = 4,
    FS_MAXDQUOT___0 = 5,
    FS_NRFILE___0 = 6,
    FS_MAXFILE___0 = 7,
    FS_DENTRY___0 = 8,
    FS_NRSUPER___0 = 9,
    FS_MAXSUPER___0 = 10,
    FS_OVERFLOWUID___0 = 11,
    FS_OVERFLOWGID___0 = 12,
    FS_LEASES___0 = 13,
    FS_DIR_NOTIFY___0 = 14,
    FS_LEASE_TIME___0 = 15,
    FS_DQSTATS___0 = 16,
    FS_XFS___0 = 17,
    FS_AIO_NR___0 = 18,
    FS_AIO_MAX_NR___0 = 19,
    FS_INOTIFY___0 = 20,
    FS_OCFS2___0 = 988
} ;
enum __anonenum_154___0 {
    FS_DQ_LOOKUPS___0 = 1,
    FS_DQ_DROPS___0 = 2,
    FS_DQ_READS___0 = 3,
    FS_DQ_WRITES___0 = 4,
    FS_DQ_CACHE_HITS___0 = 5,
    FS_DQ_ALLOCATED___0 = 6,
    FS_DQ_FREE___0 = 7,
    FS_DQ_SYNCS___0 = 8,
    FS_DQ_WARNINGS___0 = 9
} ;
enum __anonenum_155___0 {
    DEV_CDROM___0 = 1,
    DEV_HWMON___0 = 2,
    DEV_PARPORT___0 = 3,
    DEV_RAID___0 = 4,
    DEV_MAC_HID___0 = 5,
    DEV_SCSI___0 = 6,
    DEV_IPMI___0 = 7
} ;
enum __anonenum_156___0 {
    DEV_CDROM_INFO___0 = 1,
    DEV_CDROM_AUTOCLOSE___0 = 2,
    DEV_CDROM_AUTOEJECT___0 = 3,
    DEV_CDROM_DEBUG___0 = 4,
    DEV_CDROM_LOCK___0 = 5,
    DEV_CDROM_CHECK_MEDIA___0 = 6
} ;
enum __anonenum_157___0 {
    DEV_PARPORT_DEFAULT___0 = -3
} ;
enum __anonenum_158___0 {
    DEV_RAID_SPEED_LIMIT_MIN___0 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___0 = 2
} ;
enum __anonenum_159___0 {
    DEV_PARPORT_DEFAULT_TIMESLICE___0 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___0 = 2
} ;
enum __anonenum_160___0 {
    DEV_PARPORT_SPINTIME___0 = 1,
    DEV_PARPORT_BASE_ADDR___0 = 2,
    DEV_PARPORT_IRQ___0 = 3,
    DEV_PARPORT_DMA___0 = 4,
    DEV_PARPORT_MODES___0 = 5,
    DEV_PARPORT_DEVICES___0 = 6,
    DEV_PARPORT_AUTOPROBE___0 = 16
} ;
enum __anonenum_161___0 {
    DEV_PARPORT_DEVICES_ACTIVE___0 = -3
} ;
enum __anonenum_162___0 {
    DEV_PARPORT_DEVICE_TIMESLICE___0 = 1
} ;
enum __anonenum_163___0 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___0 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___0 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___0 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___0 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___0 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___0 = 6
} ;
enum __anonenum_164___0 {
    DEV_SCSI_LOGGING_LEVEL___0 = 1
} ;
enum __anonenum_165___0 {
    DEV_IPMI_POWEROFF_POWERCYCLE___0 = 1
} ;
enum __anonenum_166___0 {
    ABI_DEFHANDLER_COFF___0 = 1,
    ABI_DEFHANDLER_ELF___0 = 2,
    ABI_DEFHANDLER_LCALL7___0 = 3,
    ABI_DEFHANDLER_LIBCSO___0 = 4,
    ABI_TRACE___0 = 5,
    ABI_FAKE_UTSNAME___0 = 6
} ;
enum __anonenum_169___0 {
    IOCB_CMD_PREAD___0 = 0,
    IOCB_CMD_PWRITE___0 = 1,
    IOCB_CMD_FSYNC___0 = 2,
    IOCB_CMD_FDSYNC___0 = 3,
    IOCB_CMD_NOOP___0 = 6,
    IOCB_CMD_PREADV___0 = 7,
    IOCB_CMD_PWRITEV___0 = 8
} ;
enum __anonenum_172___0 {
    IRQTF_RUNTHREAD___0 = 0,
    IRQTF_DIED___0 = 1,
    IRQTF_WARNED___0 = 2
} ;
enum __anonenum_173___0 {
    HI_SOFTIRQ___0 = 0,
    TIMER_SOFTIRQ___0 = 1,
    NET_TX_SOFTIRQ___0 = 2,
    NET_RX_SOFTIRQ___0 = 3,
    BLOCK_SOFTIRQ___0 = 4,
    TASKLET_SOFTIRQ___0 = 5,
    SCHED_SOFTIRQ___0 = 6,
    HRTIMER_SOFTIRQ___0 = 7,
    RCU_SOFTIRQ___0 = 8,
    NR_SOFTIRQS___0 = 9
} ;
enum __anonenum_174 {
    TASKLET_STATE_SCHED___0 = 0,
    TASKLET_STATE_RUN___0 = 1
} ;
enum __anonenum_183___0 {
    QIF_BLIMITS_B___0 = 0,
    QIF_SPACE_B___0 = 1,
    QIF_ILIMITS_B___0 = 2,
    QIF_INODES_B___0 = 3,
    QIF_BTIME_B___0 = 4,
    QIF_ITIME_B___0 = 5
} ;
enum __anonenum_184___0 {
    QUOTA_NL_C_UNSPEC___0 = 0,
    QUOTA_NL_C_WARNING___0 = 1,
    __QUOTA_NL_C_MAX___0 = 2
} ;
enum __anonenum_185___0 {
    QUOTA_NL_A_UNSPEC___0 = 0,
    QUOTA_NL_A_QTYPE___0 = 1,
    QUOTA_NL_A_EXCESS_ID___0 = 2,
    QUOTA_NL_A_WARNING___0 = 3,
    QUOTA_NL_A_DEV_MAJOR___0 = 4,
    QUOTA_NL_A_DEV_MINOR___0 = 5,
    QUOTA_NL_A_CAUSED_ID___0 = 6,
    __QUOTA_NL_A_MAX___0 = 7
} ;
enum __anonenum_186___0 {
    _DQUOT_USAGE_ENABLED___0 = 0,
    _DQUOT_LIMITS_ENABLED___0 = 1,
    _DQUOT_SUSPENDED___0 = 2,
    _DQUOT_STATE_FLAGS___0 = 3
} ;
enum __anonenum_193___0 {
    SB_UNFROZEN___0 = 0,
    SB_FREEZE_WRITE___0 = 1,
    SB_FREEZE_TRANS___0 = 2
} ;
enum __anonenum_194___0 {
    DIO_LOCKING___0 = 1,
    DIO_NO_LOCKING___0 = 2,
    DIO_OWN_LOCKING___0 = 3
} ;
enum __anonenum_4___1 {
    false___1 = 0,
    true___1 = 1
} ;
enum __anonenum_10___0 {
    DUMP_PREFIX_NONE___1 = 0,
    DUMP_PREFIX_ADDRESS___1 = 1,
    DUMP_PREFIX_OFFSET___1 = 2
} ;
enum __anonenum_15___0 {
    PG_LEVEL_NONE___1 = 0,
    PG_LEVEL_4K___1 = 1,
    PG_LEVEL_2M___1 = 2,
    PG_LEVEL_1G___1 = 3,
    PG_LEVEL_NUM___1 = 4
} ;
enum __anonenum_19___0 {
    GATE_INTERRUPT___1 = 14,
    GATE_TRAP___1 = 15,
    GATE_CALL___1 = 12,
    GATE_TASK___1 = 5
} ;
enum __anonenum_20___0 {
    DESC_TSS___1 = 9,
    DESC_LDT___1 = 2,
    DESCTYPE_S___1 = 16
} ;
enum __anonenum_21___1 {
    ADDR_NO_RANDOMIZE___1 = 262144,
    FDPIC_FUNCPTRS___1 = 524288,
    MMAP_PAGE_ZERO___1 = 1048576,
    ADDR_COMPAT_LAYOUT___1 = 2097152,
    READ_IMPLIES_EXEC___1 = 4194304,
    ADDR_LIMIT_32BIT___1 = 8388608,
    SHORT_INODE___1 = 16777216,
    WHOLE_SECONDS___1 = 33554432,
    STICKY_TIMEOUTS___1 = 67108864,
    ADDR_LIMIT_3GB___1 = 134217728
} ;
enum __anonenum_22___0 {
    PER_LINUX___1 = 0,
    PER_LINUX_32BIT___1 = 8388608,
    PER_LINUX_FDPIC___1 = 524288,
    PER_SVR4___1 = 68157441,
    PER_SVR3___1 = 83886082,
    PER_SCOSVR3___1 = 117440515,
    PER_OSR5___1 = 100663299,
    PER_WYSEV386___1 = 83886084,
    PER_ISCR4___1 = 67108869,
    PER_BSD___1 = 6,
    PER_SUNOS___1 = 67108870,
    PER_XENIX___1 = 83886087,
    PER_LINUX32___1 = 8,
    PER_LINUX32_3GB___1 = 134217736,
    PER_IRIX32___1 = 67108873,
    PER_IRIXN32___1 = 67108874,
    PER_IRIX64___1 = 67108875,
    PER_RISCOS___1 = 12,
    PER_SOLARIS___1 = 67108877,
    PER_UW7___1 = 68157454,
    PER_OSF4___1 = 15,
    PER_HPUX___1 = 16,
    PER_MASK___1 = 255
} ;
union __anonunion_d_38 {
   u64 v64 ;
   u32 v32[2] ;
};
enum __anonenum_40 {
    QIF_BLIMITS_B___1 = 0,
    QIF_SPACE_B___1 = 1,
    QIF_ILIMITS_B___1 = 2,
    QIF_INODES_B___1 = 3,
    QIF_BTIME_B___1 = 4,
    QIF_ITIME_B___1 = 5
} ;
enum __anonenum_41 {
    QUOTA_NL_C_UNSPEC___1 = 0,
    QUOTA_NL_C_WARNING___1 = 1,
    __QUOTA_NL_C_MAX___1 = 2
} ;
enum __anonenum_42 {
    QUOTA_NL_A_UNSPEC___1 = 0,
    QUOTA_NL_A_QTYPE___1 = 1,
    QUOTA_NL_A_EXCESS_ID___1 = 2,
    QUOTA_NL_A_WARNING___1 = 3,
    QUOTA_NL_A_DEV_MAJOR___1 = 4,
    QUOTA_NL_A_DEV_MINOR___1 = 5,
    QUOTA_NL_A_CAUSED_ID___1 = 6,
    __QUOTA_NL_A_MAX___1 = 7
} ;
enum __anonenum_43 {
    _DQUOT_USAGE_ENABLED___1 = 0,
    _DQUOT_LIMITS_ENABLED___1 = 1,
    _DQUOT_SUSPENDED___1 = 2,
    _DQUOT_STATE_FLAGS___1 = 3
} ;
enum __anonenum_50 {
    SB_UNFROZEN___1 = 0,
    SB_FREEZE_WRITE___1 = 1,
    SB_FREEZE_TRANS___1 = 2
} ;
enum __anonenum_51 {
    DIO_LOCKING___1 = 1,
    DIO_NO_LOCKING___1 = 2,
    DIO_OWN_LOCKING___1 = 3
} ;
enum hrtimer_restart;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
enum __anonenum_125___1 {
    CTL_KERN___1 = 1,
    CTL_VM___1 = 2,
    CTL_NET___1 = 3,
    CTL_PROC___1 = 4,
    CTL_FS___1 = 5,
    CTL_DEBUG___1 = 6,
    CTL_DEV___1 = 7,
    CTL_BUS___1 = 8,
    CTL_ABI___1 = 9,
    CTL_CPU___1 = 10,
    CTL_ARLAN___1 = 254,
    CTL_S390DBF___1 = 5677,
    CTL_SUNRPC___1 = 7249,
    CTL_PM___1 = 9899,
    CTL_FRV___1 = 9898
} ;
enum __anonenum_126___1 {
    CTL_BUS_ISA___1 = 1
} ;
enum __anonenum_127___1 {
    INOTIFY_MAX_USER_INSTANCES___1 = 1,
    INOTIFY_MAX_USER_WATCHES___1 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___1 = 3
} ;
enum __anonenum_128___1 {
    KERN_OSTYPE___1 = 1,
    KERN_OSRELEASE___1 = 2,
    KERN_OSREV___1 = 3,
    KERN_VERSION___1 = 4,
    KERN_SECUREMASK___1 = 5,
    KERN_PROF___1 = 6,
    KERN_NODENAME___1 = 7,
    KERN_DOMAINNAME___1 = 8,
    KERN_PANIC___1 = 15,
    KERN_REALROOTDEV___1 = 16,
    KERN_SPARC_REBOOT___1 = 21,
    KERN_CTLALTDEL___1 = 22,
    KERN_PRINTK___1 = 23,
    KERN_NAMETRANS___1 = 24,
    KERN_PPC_HTABRECLAIM___1 = 25,
    KERN_PPC_ZEROPAGED___1 = 26,
    KERN_PPC_POWERSAVE_NAP___1 = 27,
    KERN_MODPROBE___1 = 28,
    KERN_SG_BIG_BUFF___1 = 29,
    KERN_ACCT___1 = 30,
    KERN_PPC_L2CR___1 = 31,
    KERN_RTSIGNR___1 = 32,
    KERN_RTSIGMAX___1 = 33,
    KERN_SHMMAX___1 = 34,
    KERN_MSGMAX___1 = 35,
    KERN_MSGMNB___1 = 36,
    KERN_MSGPOOL___1 = 37,
    KERN_SYSRQ___1 = 38,
    KERN_MAX_THREADS___1 = 39,
    KERN_RANDOM___1 = 40,
    KERN_SHMALL___1 = 41,
    KERN_MSGMNI___1 = 42,
    KERN_SEM___1 = 43,
    KERN_SPARC_STOP_A___1 = 44,
    KERN_SHMMNI___1 = 45,
    KERN_OVERFLOWUID___1 = 46,
    KERN_OVERFLOWGID___1 = 47,
    KERN_SHMPATH___1 = 48,
    KERN_HOTPLUG___1 = 49,
    KERN_IEEE_EMULATION_WARNINGS___1 = 50,
    KERN_S390_USER_DEBUG_LOGGING___1 = 51,
    KERN_CORE_USES_PID___1 = 52,
    KERN_TAINTED___1 = 53,
    KERN_CADPID___1 = 54,
    KERN_PIDMAX___1 = 55,
    KERN_CORE_PATTERN___1 = 56,
    KERN_PANIC_ON_OOPS___1 = 57,
    KERN_HPPA_PWRSW___1 = 58,
    KERN_HPPA_UNALIGNED___1 = 59,
    KERN_PRINTK_RATELIMIT___1 = 60,
    KERN_PRINTK_RATELIMIT_BURST___1 = 61,
    KERN_PTY___1 = 62,
    KERN_NGROUPS_MAX___1 = 63,
    KERN_SPARC_SCONS_PWROFF___1 = 64,
    KERN_HZ_TIMER___1 = 65,
    KERN_UNKNOWN_NMI_PANIC___1 = 66,
    KERN_BOOTLOADER_TYPE___1 = 67,
    KERN_RANDOMIZE___1 = 68,
    KERN_SETUID_DUMPABLE___1 = 69,
    KERN_SPIN_RETRY___1 = 70,
    KERN_ACPI_VIDEO_FLAGS___1 = 71,
    KERN_IA64_UNALIGNED___1 = 72,
    KERN_COMPAT_LOG___1 = 73,
    KERN_MAX_LOCK_DEPTH___1 = 74,
    KERN_NMI_WATCHDOG___1 = 75,
    KERN_PANIC_ON_NMI___1 = 76
} ;
enum __anonenum_129___1 {
    VM_UNUSED1___1 = 1,
    VM_UNUSED2___1 = 2,
    VM_UNUSED3___1 = 3,
    VM_UNUSED4___1 = 4,
    VM_OVERCOMMIT_MEMORY___1 = 5,
    VM_UNUSED5___1 = 6,
    VM_UNUSED7___1 = 7,
    VM_UNUSED8___1 = 8,
    VM_UNUSED9___1 = 9,
    VM_PAGE_CLUSTER___1 = 10,
    VM_DIRTY_BACKGROUND___1 = 11,
    VM_DIRTY_RATIO___1 = 12,
    VM_DIRTY_WB_CS___1 = 13,
    VM_DIRTY_EXPIRE_CS___1 = 14,
    VM_NR_PDFLUSH_THREADS___1 = 15,
    VM_OVERCOMMIT_RATIO___1 = 16,
    VM_PAGEBUF___1 = 17,
    VM_HUGETLB_PAGES___1 = 18,
    VM_SWAPPINESS___1 = 19,
    VM_LOWMEM_RESERVE_RATIO___1 = 20,
    VM_MIN_FREE_KBYTES___1 = 21,
    VM_MAX_MAP_COUNT___1 = 22,
    VM_LAPTOP_MODE___1 = 23,
    VM_BLOCK_DUMP___1 = 24,
    VM_HUGETLB_GROUP___1 = 25,
    VM_VFS_CACHE_PRESSURE___1 = 26,
    VM_LEGACY_VA_LAYOUT___1 = 27,
    VM_SWAP_TOKEN_TIMEOUT___1 = 28,
    VM_DROP_PAGECACHE___1 = 29,
    VM_PERCPU_PAGELIST_FRACTION___1 = 30,
    VM_ZONE_RECLAIM_MODE___1 = 31,
    VM_MIN_UNMAPPED___1 = 32,
    VM_PANIC_ON_OOM___1 = 33,
    VM_VDSO_ENABLED___1 = 34,
    VM_MIN_SLAB___1 = 35
} ;
enum __anonenum_130___1 {
    NET_CORE___1 = 1,
    NET_ETHER___1 = 2,
    NET_802___1 = 3,
    NET_UNIX___1 = 4,
    NET_IPV4___1 = 5,
    NET_IPX___1 = 6,
    NET_ATALK___1 = 7,
    NET_NETROM___1 = 8,
    NET_AX25___1 = 9,
    NET_BRIDGE___1 = 10,
    NET_ROSE___1 = 11,
    NET_IPV6___1 = 12,
    NET_X25___1 = 13,
    NET_TR___1 = 14,
    NET_DECNET___1 = 15,
    NET_ECONET___1 = 16,
    NET_SCTP___1 = 17,
    NET_LLC___1 = 18,
    NET_NETFILTER___1 = 19,
    NET_DCCP___1 = 20,
    NET_IRDA___1 = 412
} ;
enum __anonenum_131___1 {
    RANDOM_POOLSIZE___1 = 1,
    RANDOM_ENTROPY_COUNT___1 = 2,
    RANDOM_READ_THRESH___1 = 3,
    RANDOM_WRITE_THRESH___1 = 4,
    RANDOM_BOOT_ID___1 = 5,
    RANDOM_UUID___1 = 6
} ;
enum __anonenum_132___1 {
    PTY_MAX___1 = 1,
    PTY_NR___1 = 2
} ;
enum __anonenum_133___1 {
    BUS_ISA_MEM_BASE___1 = 1,
    BUS_ISA_PORT_BASE___1 = 2,
    BUS_ISA_PORT_SHIFT___1 = 3
} ;
enum __anonenum_134___1 {
    NET_CORE_WMEM_MAX___1 = 1,
    NET_CORE_RMEM_MAX___1 = 2,
    NET_CORE_WMEM_DEFAULT___1 = 3,
    NET_CORE_RMEM_DEFAULT___1 = 4,
    NET_CORE_MAX_BACKLOG___1 = 6,
    NET_CORE_FASTROUTE___1 = 7,
    NET_CORE_MSG_COST___1 = 8,
    NET_CORE_MSG_BURST___1 = 9,
    NET_CORE_OPTMEM_MAX___1 = 10,
    NET_CORE_HOT_LIST_LENGTH___1 = 11,
    NET_CORE_DIVERT_VERSION___1 = 12,
    NET_CORE_NO_CONG_THRESH___1 = 13,
    NET_CORE_NO_CONG___1 = 14,
    NET_CORE_LO_CONG___1 = 15,
    NET_CORE_MOD_CONG___1 = 16,
    NET_CORE_DEV_WEIGHT___1 = 17,
    NET_CORE_SOMAXCONN___1 = 18,
    NET_CORE_BUDGET___1 = 19,
    NET_CORE_AEVENT_ETIME___1 = 20,
    NET_CORE_AEVENT_RSEQTH___1 = 21,
    NET_CORE_WARNINGS___1 = 22
} ;
enum __anonenum_135___1 {
    NET_UNIX_DESTROY_DELAY___1 = 1,
    NET_UNIX_DELETE_DELAY___1 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___1 = 3
} ;
enum __anonenum_136___1 {
    NET_NF_CONNTRACK_MAX___1 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___1 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___1 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___1 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___1 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___1 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___1 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___1 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___1 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___1 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___1 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___1 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___1 = 13,
    NET_NF_CONNTRACK_BUCKETS___1 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___1 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___1 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___1 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___1 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___1 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___1 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___1 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___1 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___1 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___1 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___1 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___1 = 26,
    NET_NF_CONNTRACK_COUNT___1 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___1 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___1 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___1 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___1 = 31,
    NET_NF_CONNTRACK_CHECKSUM___1 = 32
} ;
enum __anonenum_137___1 {
    NET_IPV4_FORWARD___1 = 8,
    NET_IPV4_DYNADDR___1 = 9,
    NET_IPV4_CONF___1 = 16,
    NET_IPV4_NEIGH___1 = 17,
    NET_IPV4_ROUTE___1 = 18,
    NET_IPV4_FIB_HASH___1 = 19,
    NET_IPV4_NETFILTER___1 = 20,
    NET_IPV4_TCP_TIMESTAMPS___1 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___1 = 34,
    NET_IPV4_TCP_SACK___1 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___1 = 36,
    NET_IPV4_DEFAULT_TTL___1 = 37,
    NET_IPV4_AUTOCONFIG___1 = 38,
    NET_IPV4_NO_PMTU_DISC___1 = 39,
    NET_IPV4_TCP_SYN_RETRIES___1 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___1 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___1 = 42,
    NET_IPV4_IPFRAG_TIME___1 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___1 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___1 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___1 = 46,
    NET_IPV4_TCP_RETRIES1___1 = 47,
    NET_IPV4_TCP_RETRIES2___1 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___1 = 49,
    NET_IPV4_IP_MASQ_DEBUG___1 = 50,
    NET_TCP_SYNCOOKIES___1 = 51,
    NET_TCP_STDURG___1 = 52,
    NET_TCP_RFC1337___1 = 53,
    NET_TCP_SYN_TAILDROP___1 = 54,
    NET_TCP_MAX_SYN_BACKLOG___1 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___1 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___1 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___1 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___1 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___1 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___1 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___1 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___1 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___1 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___1 = 65,
    NET_TCP_TW_RECYCLE___1 = 66,
    NET_IPV4_ALWAYS_DEFRAG___1 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___1 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___1 = 69,
    NET_IPV4_INET_PEER_MINTTL___1 = 70,
    NET_IPV4_INET_PEER_MAXTTL___1 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___1 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___1 = 73,
    NET_TCP_ORPHAN_RETRIES___1 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___1 = 75,
    NET_TCP_SYNACK_RETRIES___1 = 76,
    NET_TCP_MAX_ORPHANS___1 = 77,
    NET_TCP_MAX_TW_BUCKETS___1 = 78,
    NET_TCP_FACK___1 = 79,
    NET_TCP_REORDERING___1 = 80,
    NET_TCP_ECN___1 = 81,
    NET_TCP_DSACK___1 = 82,
    NET_TCP_MEM___1 = 83,
    NET_TCP_WMEM___1 = 84,
    NET_TCP_RMEM___1 = 85,
    NET_TCP_APP_WIN___1 = 86,
    NET_TCP_ADV_WIN_SCALE___1 = 87,
    NET_IPV4_NONLOCAL_BIND___1 = 88,
    NET_IPV4_ICMP_RATELIMIT___1 = 89,
    NET_IPV4_ICMP_RATEMASK___1 = 90,
    NET_TCP_TW_REUSE___1 = 91,
    NET_TCP_FRTO___1 = 92,
    NET_TCP_LOW_LATENCY___1 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___1 = 94,
    NET_IPV4_IGMP_MAX_MSF___1 = 96,
    NET_TCP_NO_METRICS_SAVE___1 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___1 = 105,
    NET_TCP_MODERATE_RCVBUF___1 = 106,
    NET_TCP_TSO_WIN_DIVISOR___1 = 107,
    NET_TCP_BIC_BETA___1 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___1 = 109,
    NET_TCP_CONG_CONTROL___1 = 110,
    NET_TCP_ABC___1 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___1 = 112,
    NET_TCP_MTU_PROBING___1 = 113,
    NET_TCP_BASE_MSS___1 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___1 = 115,
    NET_TCP_DMA_COPYBREAK___1 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___1 = 117,
    NET_CIPSOV4_CACHE_ENABLE___1 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___1 = 119,
    NET_CIPSOV4_RBM_OPTFMT___1 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___1 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___1 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___1 = 123,
    NET_TCP_MAX_SSTHRESH___1 = 124,
    NET_TCP_FRTO_RESPONSE___1 = 125
} ;
enum __anonenum_138___1 {
    NET_IPV4_ROUTE_FLUSH___1 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___1 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___1 = 3,
    NET_IPV4_ROUTE_GC_THRESH___1 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___1 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___1 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___1 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___1 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___1 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___1 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___1 = 11,
    NET_IPV4_ROUTE_ERROR_COST___1 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___1 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___1 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___1 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___1 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___1 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___1 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___1 = 19
} ;
enum __anonenum_139___1 {
    NET_PROTO_CONF_ALL___1 = -2,
    NET_PROTO_CONF_DEFAULT___1 = -3
} ;
enum __anonenum_140___1 {
    NET_IPV4_CONF_FORWARDING___1 = 1,
    NET_IPV4_CONF_MC_FORWARDING___1 = 2,
    NET_IPV4_CONF_PROXY_ARP___1 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___1 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___1 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___1 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___1 = 7,
    NET_IPV4_CONF_RP_FILTER___1 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___1 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___1 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___1 = 11,
    NET_IPV4_CONF_TAG___1 = 12,
    NET_IPV4_CONF_ARPFILTER___1 = 13,
    NET_IPV4_CONF_MEDIUM_ID___1 = 14,
    NET_IPV4_CONF_NOXFRM___1 = 15,
    NET_IPV4_CONF_NOPOLICY___1 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___1 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___1 = 18,
    NET_IPV4_CONF_ARP_IGNORE___1 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___1 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___1 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___1 = 22,
    __NET_IPV4_CONF_MAX___1 = 23
} ;
enum __anonenum_141___1 {
    NET_IPV4_NF_CONNTRACK_MAX___1 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___1 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___1 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___1 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___1 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___1 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___1 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___1 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___1 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___1 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___1 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___1 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___1 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___1 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___1 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___1 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___1 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___1 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___1 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___1 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___1 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___1 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___1 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___1 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___1 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___1 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___1 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___1 = 28
} ;
enum __anonenum_142___1 {
    NET_IPV6_CONF___1 = 16,
    NET_IPV6_NEIGH___1 = 17,
    NET_IPV6_ROUTE___1 = 18,
    NET_IPV6_ICMP___1 = 19,
    NET_IPV6_BINDV6ONLY___1 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___1 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___1 = 22,
    NET_IPV6_IP6FRAG_TIME___1 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___1 = 24,
    NET_IPV6_MLD_MAX_MSF___1 = 25
} ;
enum __anonenum_143___1 {
    NET_IPV6_ROUTE_FLUSH___1 = 1,
    NET_IPV6_ROUTE_GC_THRESH___1 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___1 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___1 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___1 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___1 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___1 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___1 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___1 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___1 = 10
} ;
enum __anonenum_144___1 {
    NET_IPV6_FORWARDING___1 = 1,
    NET_IPV6_HOP_LIMIT___1 = 2,
    NET_IPV6_MTU___1 = 3,
    NET_IPV6_ACCEPT_RA___1 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___1 = 5,
    NET_IPV6_AUTOCONF___1 = 6,
    NET_IPV6_DAD_TRANSMITS___1 = 7,
    NET_IPV6_RTR_SOLICITS___1 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___1 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___1 = 10,
    NET_IPV6_USE_TEMPADDR___1 = 11,
    NET_IPV6_TEMP_VALID_LFT___1 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___1 = 13,
    NET_IPV6_REGEN_MAX_RETRY___1 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___1 = 15,
    NET_IPV6_MAX_ADDRESSES___1 = 16,
    NET_IPV6_FORCE_MLD_VERSION___1 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___1 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___1 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___1 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___1 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___1 = 22,
    NET_IPV6_PROXY_NDP___1 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___1 = 25,
    __NET_IPV6_MAX___1 = 26
} ;
enum __anonenum_145___1 {
    NET_IPV6_ICMP_RATELIMIT___1 = 1
} ;
enum __anonenum_146___1 {
    NET_NEIGH_MCAST_SOLICIT___1 = 1,
    NET_NEIGH_UCAST_SOLICIT___1 = 2,
    NET_NEIGH_APP_SOLICIT___1 = 3,
    NET_NEIGH_RETRANS_TIME___1 = 4,
    NET_NEIGH_REACHABLE_TIME___1 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___1 = 6,
    NET_NEIGH_GC_STALE_TIME___1 = 7,
    NET_NEIGH_UNRES_QLEN___1 = 8,
    NET_NEIGH_PROXY_QLEN___1 = 9,
    NET_NEIGH_ANYCAST_DELAY___1 = 10,
    NET_NEIGH_PROXY_DELAY___1 = 11,
    NET_NEIGH_LOCKTIME___1 = 12,
    NET_NEIGH_GC_INTERVAL___1 = 13,
    NET_NEIGH_GC_THRESH1___1 = 14,
    NET_NEIGH_GC_THRESH2___1 = 15,
    NET_NEIGH_GC_THRESH3___1 = 16,
    NET_NEIGH_RETRANS_TIME_MS___1 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___1 = 18,
    __NET_NEIGH_MAX___1 = 19
} ;
enum __anonenum_147___1 {
    NET_DCCP_DEFAULT___1 = 1
} ;
enum __anonenum_148___1 {
    NET_IPX_PPROP_BROADCASTING___1 = 1,
    NET_IPX_FORWARDING___1 = 2
} ;
enum __anonenum_149___1 {
    NET_LLC2___1 = 1,
    NET_LLC_STATION___1 = 2
} ;
enum __anonenum_150___1 {
    NET_LLC2_TIMEOUT___1 = 1
} ;
enum __anonenum_151___1 {
    NET_LLC_STATION_ACK_TIMEOUT___1 = 1
} ;
enum __anonenum_152___1 {
    NET_LLC2_ACK_TIMEOUT___1 = 1,
    NET_LLC2_P_TIMEOUT___1 = 2,
    NET_LLC2_REJ_TIMEOUT___1 = 3,
    NET_LLC2_BUSY_TIMEOUT___1 = 4
} ;
enum __anonenum_153___1 {
    NET_ATALK_AARP_EXPIRY_TIME___1 = 1,
    NET_ATALK_AARP_TICK_TIME___1 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___1 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___1 = 4
} ;
enum __anonenum_154___1 {
    NET_NETROM_DEFAULT_PATH_QUALITY___1 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___1 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___1 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___1 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___1 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___1 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___1 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___1 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___1 = 9,
    NET_NETROM_ROUTING_CONTROL___1 = 10,
    NET_NETROM_LINK_FAILS_COUNT___1 = 11,
    NET_NETROM_RESET___1 = 12
} ;
enum __anonenum_155___1 {
    NET_AX25_IP_DEFAULT_MODE___1 = 1,
    NET_AX25_DEFAULT_MODE___1 = 2,
    NET_AX25_BACKOFF_TYPE___1 = 3,
    NET_AX25_CONNECT_MODE___1 = 4,
    NET_AX25_STANDARD_WINDOW___1 = 5,
    NET_AX25_EXTENDED_WINDOW___1 = 6,
    NET_AX25_T1_TIMEOUT___1 = 7,
    NET_AX25_T2_TIMEOUT___1 = 8,
    NET_AX25_T3_TIMEOUT___1 = 9,
    NET_AX25_IDLE_TIMEOUT___1 = 10,
    NET_AX25_N2___1 = 11,
    NET_AX25_PACLEN___1 = 12,
    NET_AX25_PROTOCOL___1 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___1 = 14
} ;
enum __anonenum_156___1 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___1 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___1 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___1 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___1 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___1 = 5,
    NET_ROSE_ROUTING_CONTROL___1 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___1 = 7,
    NET_ROSE_MAX_VCS___1 = 8,
    NET_ROSE_WINDOW_SIZE___1 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___1 = 10
} ;
enum __anonenum_157___1 {
    NET_X25_RESTART_REQUEST_TIMEOUT___1 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___1 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___1 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___1 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___1 = 5,
    NET_X25_FORWARD___1 = 6
} ;
enum __anonenum_158___1 {
    NET_TR_RIF_TIMEOUT___1 = 1
} ;
enum __anonenum_159___1 {
    NET_DECNET_NODE_TYPE___1 = 1,
    NET_DECNET_NODE_ADDRESS___1 = 2,
    NET_DECNET_NODE_NAME___1 = 3,
    NET_DECNET_DEFAULT_DEVICE___1 = 4,
    NET_DECNET_TIME_WAIT___1 = 5,
    NET_DECNET_DN_COUNT___1 = 6,
    NET_DECNET_DI_COUNT___1 = 7,
    NET_DECNET_DR_COUNT___1 = 8,
    NET_DECNET_DST_GC_INTERVAL___1 = 9,
    NET_DECNET_CONF___1 = 10,
    NET_DECNET_NO_FC_MAX_CWND___1 = 11,
    NET_DECNET_MEM___1 = 12,
    NET_DECNET_RMEM___1 = 13,
    NET_DECNET_WMEM___1 = 14,
    NET_DECNET_DEBUG_LEVEL___1 = 255
} ;
enum __anonenum_160___1 {
    NET_DECNET_CONF_LOOPBACK___1 = -2,
    NET_DECNET_CONF_DDCMP___1 = -3,
    NET_DECNET_CONF_PPP___1 = -4,
    NET_DECNET_CONF_X25___1 = -5,
    NET_DECNET_CONF_GRE___1 = -6,
    NET_DECNET_CONF_ETHER___1 = -7
} ;
enum __anonenum_161___1 {
    NET_DECNET_CONF_DEV_PRIORITY___1 = 1,
    NET_DECNET_CONF_DEV_T1___1 = 2,
    NET_DECNET_CONF_DEV_T2___1 = 3,
    NET_DECNET_CONF_DEV_T3___1 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___1 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___1 = 6,
    NET_DECNET_CONF_DEV_STATE___1 = 7
} ;
enum __anonenum_162___1 {
    NET_SCTP_RTO_INITIAL___1 = 1,
    NET_SCTP_RTO_MIN___1 = 2,
    NET_SCTP_RTO_MAX___1 = 3,
    NET_SCTP_RTO_ALPHA___1 = 4,
    NET_SCTP_RTO_BETA___1 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___1 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___1 = 7,
    NET_SCTP_PATH_MAX_RETRANS___1 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___1 = 9,
    NET_SCTP_HB_INTERVAL___1 = 10,
    NET_SCTP_PRESERVE_ENABLE___1 = 11,
    NET_SCTP_MAX_BURST___1 = 12,
    NET_SCTP_ADDIP_ENABLE___1 = 13,
    NET_SCTP_PRSCTP_ENABLE___1 = 14,
    NET_SCTP_SNDBUF_POLICY___1 = 15,
    NET_SCTP_SACK_TIMEOUT___1 = 16,
    NET_SCTP_RCVBUF_POLICY___1 = 17
} ;
enum __anonenum_163___1 {
    NET_BRIDGE_NF_CALL_ARPTABLES___1 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___1 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___1 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___1 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___1 = 5
} ;
enum __anonenum_164___1 {
    NET_IRDA_DISCOVERY___1 = 1,
    NET_IRDA_DEVNAME___1 = 2,
    NET_IRDA_DEBUG___1 = 3,
    NET_IRDA_FAST_POLL___1 = 4,
    NET_IRDA_DISCOVERY_SLOTS___1 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___1 = 6,
    NET_IRDA_SLOT_TIMEOUT___1 = 7,
    NET_IRDA_MAX_BAUD_RATE___1 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___1 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___1 = 10,
    NET_IRDA_MAX_TX_WINDOW___1 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___1 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___1 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___1 = 14
} ;
enum __anonenum_165___1 {
    FS_NRINODE___1 = 1,
    FS_STATINODE___1 = 2,
    FS_MAXINODE___1 = 3,
    FS_NRDQUOT___1 = 4,
    FS_MAXDQUOT___1 = 5,
    FS_NRFILE___1 = 6,
    FS_MAXFILE___1 = 7,
    FS_DENTRY___1 = 8,
    FS_NRSUPER___1 = 9,
    FS_MAXSUPER___1 = 10,
    FS_OVERFLOWUID___1 = 11,
    FS_OVERFLOWGID___1 = 12,
    FS_LEASES___1 = 13,
    FS_DIR_NOTIFY___1 = 14,
    FS_LEASE_TIME___1 = 15,
    FS_DQSTATS___1 = 16,
    FS_XFS___1 = 17,
    FS_AIO_NR___1 = 18,
    FS_AIO_MAX_NR___1 = 19,
    FS_INOTIFY___1 = 20,
    FS_OCFS2___1 = 988
} ;
enum __anonenum_166___1 {
    FS_DQ_LOOKUPS___1 = 1,
    FS_DQ_DROPS___1 = 2,
    FS_DQ_READS___1 = 3,
    FS_DQ_WRITES___1 = 4,
    FS_DQ_CACHE_HITS___1 = 5,
    FS_DQ_ALLOCATED___1 = 6,
    FS_DQ_FREE___1 = 7,
    FS_DQ_SYNCS___1 = 8,
    FS_DQ_WARNINGS___1 = 9
} ;
enum __anonenum_167___0 {
    DEV_CDROM___1 = 1,
    DEV_HWMON___1 = 2,
    DEV_PARPORT___1 = 3,
    DEV_RAID___1 = 4,
    DEV_MAC_HID___1 = 5,
    DEV_SCSI___1 = 6,
    DEV_IPMI___1 = 7
} ;
enum __anonenum_168___0 {
    DEV_CDROM_INFO___1 = 1,
    DEV_CDROM_AUTOCLOSE___1 = 2,
    DEV_CDROM_AUTOEJECT___1 = 3,
    DEV_CDROM_DEBUG___1 = 4,
    DEV_CDROM_LOCK___1 = 5,
    DEV_CDROM_CHECK_MEDIA___1 = 6
} ;
enum __anonenum_169___1 {
    DEV_PARPORT_DEFAULT___1 = -3
} ;
enum __anonenum_170___0 {
    DEV_RAID_SPEED_LIMIT_MIN___1 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___1 = 2
} ;
enum __anonenum_171___0 {
    DEV_PARPORT_DEFAULT_TIMESLICE___1 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___1 = 2
} ;
enum __anonenum_172___1 {
    DEV_PARPORT_SPINTIME___1 = 1,
    DEV_PARPORT_BASE_ADDR___1 = 2,
    DEV_PARPORT_IRQ___1 = 3,
    DEV_PARPORT_DMA___1 = 4,
    DEV_PARPORT_MODES___1 = 5,
    DEV_PARPORT_DEVICES___1 = 6,
    DEV_PARPORT_AUTOPROBE___1 = 16
} ;
enum __anonenum_173___1 {
    DEV_PARPORT_DEVICES_ACTIVE___1 = -3
} ;
enum __anonenum_174___0 {
    DEV_PARPORT_DEVICE_TIMESLICE___1 = 1
} ;
enum __anonenum_175 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___1 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___1 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___1 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___1 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___1 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___1 = 6
} ;
enum __anonenum_176___0 {
    DEV_SCSI_LOGGING_LEVEL___1 = 1
} ;
enum __anonenum_177 {
    DEV_IPMI_POWEROFF_POWERCYCLE___1 = 1
} ;
enum __anonenum_178 {
    ABI_DEFHANDLER_COFF___1 = 1,
    ABI_DEFHANDLER_ELF___1 = 2,
    ABI_DEFHANDLER_LCALL7___1 = 3,
    ABI_DEFHANDLER_LIBCSO___1 = 4,
    ABI_TRACE___1 = 5,
    ABI_FAKE_UTSNAME___1 = 6
} ;
enum __anonenum_181___0 {
    IOCB_CMD_PREAD___1 = 0,
    IOCB_CMD_PWRITE___1 = 1,
    IOCB_CMD_FSYNC___1 = 2,
    IOCB_CMD_FDSYNC___1 = 3,
    IOCB_CMD_NOOP___1 = 6,
    IOCB_CMD_PREADV___1 = 7,
    IOCB_CMD_PWRITEV___1 = 8
} ;
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
struct __large_struct {
   unsigned long buf[100] ;
};
struct movsl_mask {
   int mask ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef void (*poll_queue_proc)(struct file * , wait_queue_head_t * , struct poll_table_struct * );
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
typedef struct poll_table_struct poll_table;
struct poll_table_entry {
   struct file *filp ;
   wait_queue_t wait ;
   wait_queue_head_t *wait_address ;
};
struct poll_table_page;
struct poll_wqueues {
   poll_table pt ;
   struct poll_table_page *table ;
   struct task_struct *polling_task ;
   int triggered ;
   int error ;
   int inline_index ;
   struct poll_table_entry inline_entries[576UL / sizeof(struct poll_table_entry )] ;
};
struct __anonstruct_fd_set_bits_183 {
   unsigned long *in ;
   unsigned long *out ;
   unsigned long *ex ;
   unsigned long *res_in ;
   unsigned long *res_out ;
   unsigned long *res_ex ;
};
typedef struct __anonstruct_fd_set_bits_183 fd_set_bits;
enum __anonenum_186___1 {
    IRQTF_RUNTHREAD___1 = 0,
    IRQTF_DIED___1 = 1,
    IRQTF_WARNED___1 = 2
} ;
enum __anonenum_187 {
    HI_SOFTIRQ___1 = 0,
    TIMER_SOFTIRQ___1 = 1,
    NET_TX_SOFTIRQ___1 = 2,
    NET_RX_SOFTIRQ___1 = 3,
    BLOCK_SOFTIRQ___1 = 4,
    TASKLET_SOFTIRQ___1 = 5,
    SCHED_SOFTIRQ___1 = 6,
    HRTIMER_SOFTIRQ___1 = 7,
    RCU_SOFTIRQ___1 = 8,
    NR_SOFTIRQS___1 = 9
} ;
enum __anonenum_188 {
    TASKLET_STATE_SCHED___1 = 0,
    TASKLET_STATE_RUN___1 = 1
} ;
struct usbdevfs_ctrltransfer {
   __u8 bRequestType ;
   __u8 bRequest ;
   __u16 wValue ;
   __u16 wIndex ;
   __u16 wLength ;
   __u32 timeout ;
   void *data ;
};
struct usbdevfs_bulktransfer {
   unsigned int ep ;
   unsigned int len ;
   unsigned int timeout ;
   void *data ;
};
struct usbdevfs_setinterface {
   unsigned int interface ;
   unsigned int altsetting ;
};
struct usbdevfs_disconnectsignal {
   unsigned int signr ;
   void *context ;
};
struct usbdevfs_getdriver {
   unsigned int interface ;
   char driver[256] ;
};
struct usbdevfs_connectinfo {
   unsigned int devnum ;
   unsigned char slow ;
};
struct usbdevfs_iso_packet_desc {
   unsigned int length ;
   unsigned int actual_length ;
   unsigned int status ;
};
struct usbdevfs_urb {
   unsigned char type ;
   unsigned char endpoint ;
   int status ;
   unsigned int flags ;
   void *buffer ;
   int buffer_length ;
   int actual_length ;
   int start_frame ;
   int number_of_packets ;
   int error_count ;
   unsigned int signr ;
   void *usercontext ;
   struct usbdevfs_iso_packet_desc iso_frame_desc[0] ;
};
struct usbdevfs_ioctl {
   int ifno ;
   int ioctl_code ;
   void *data ;
};
struct usbdevfs_hub_portinfo {
   char nports ;
   char port[127] ;
};
struct usb_device_status {
   unsigned int lastev ;
};
struct class_info {
   int class ;
   char *class_name ;
};
enum __anonenum_4___2 {
    false___2 = 0,
    true___2 = 1
} ;
enum __anonenum_10___1 {
    DUMP_PREFIX_NONE___2 = 0,
    DUMP_PREFIX_ADDRESS___2 = 1,
    DUMP_PREFIX_OFFSET___2 = 2
} ;
enum __anonenum_15___1 {
    PG_LEVEL_NONE___2 = 0,
    PG_LEVEL_4K___2 = 1,
    PG_LEVEL_2M___2 = 2,
    PG_LEVEL_1G___2 = 3,
    PG_LEVEL_NUM___2 = 4
} ;
enum __anonenum_19___1 {
    GATE_INTERRUPT___2 = 14,
    GATE_TRAP___2 = 15,
    GATE_CALL___2 = 12,
    GATE_TASK___2 = 5
} ;
enum __anonenum_20___1 {
    DESC_TSS___2 = 9,
    DESC_LDT___2 = 2,
    DESCTYPE_S___2 = 16
} ;
enum __anonenum_21___2 {
    ADDR_NO_RANDOMIZE___2 = 262144,
    FDPIC_FUNCPTRS___2 = 524288,
    MMAP_PAGE_ZERO___2 = 1048576,
    ADDR_COMPAT_LAYOUT___2 = 2097152,
    READ_IMPLIES_EXEC___2 = 4194304,
    ADDR_LIMIT_32BIT___2 = 8388608,
    SHORT_INODE___2 = 16777216,
    WHOLE_SECONDS___2 = 33554432,
    STICKY_TIMEOUTS___2 = 67108864,
    ADDR_LIMIT_3GB___2 = 134217728
} ;
enum __anonenum_22___1 {
    PER_LINUX___2 = 0,
    PER_LINUX_32BIT___2 = 8388608,
    PER_LINUX_FDPIC___2 = 524288,
    PER_SVR4___2 = 68157441,
    PER_SVR3___2 = 83886082,
    PER_SCOSVR3___2 = 117440515,
    PER_OSR5___2 = 100663299,
    PER_WYSEV386___2 = 83886084,
    PER_ISCR4___2 = 67108869,
    PER_BSD___2 = 6,
    PER_SUNOS___2 = 67108870,
    PER_XENIX___2 = 83886087,
    PER_LINUX32___2 = 8,
    PER_LINUX32_3GB___2 = 134217736,
    PER_IRIX32___2 = 67108873,
    PER_IRIXN32___2 = 67108874,
    PER_IRIX64___2 = 67108875,
    PER_RISCOS___2 = 12,
    PER_SOLARIS___2 = 67108877,
    PER_UW7___2 = 68157454,
    PER_OSF4___2 = 15,
    PER_HPUX___2 = 16,
    PER_MASK___2 = 255
} ;
union __anonunion_d_38___0 {
   u64 v64 ;
   u32 v32[2] ;
};
enum __anonenum_40___0 {
    QIF_BLIMITS_B___2 = 0,
    QIF_SPACE_B___2 = 1,
    QIF_ILIMITS_B___2 = 2,
    QIF_INODES_B___2 = 3,
    QIF_BTIME_B___2 = 4,
    QIF_ITIME_B___2 = 5
} ;
enum __anonenum_41___0 {
    QUOTA_NL_C_UNSPEC___2 = 0,
    QUOTA_NL_C_WARNING___2 = 1,
    __QUOTA_NL_C_MAX___2 = 2
} ;
enum __anonenum_42___0 {
    QUOTA_NL_A_UNSPEC___2 = 0,
    QUOTA_NL_A_QTYPE___2 = 1,
    QUOTA_NL_A_EXCESS_ID___2 = 2,
    QUOTA_NL_A_WARNING___2 = 3,
    QUOTA_NL_A_DEV_MAJOR___2 = 4,
    QUOTA_NL_A_DEV_MINOR___2 = 5,
    QUOTA_NL_A_CAUSED_ID___2 = 6,
    __QUOTA_NL_A_MAX___2 = 7
} ;
enum __anonenum_43___0 {
    _DQUOT_USAGE_ENABLED___2 = 0,
    _DQUOT_LIMITS_ENABLED___2 = 1,
    _DQUOT_SUSPENDED___2 = 2,
    _DQUOT_STATE_FLAGS___2 = 3
} ;
enum __anonenum_50___0 {
    SB_UNFROZEN___2 = 0,
    SB_FREEZE_WRITE___2 = 1,
    SB_FREEZE_TRANS___2 = 2
} ;
enum __anonenum_51___0 {
    DIO_LOCKING___2 = 1,
    DIO_NO_LOCKING___2 = 2,
    DIO_OWN_LOCKING___2 = 3
} ;
enum hrtimer_restart;
enum __anonenum_125___2 {
    CTL_KERN___2 = 1,
    CTL_VM___2 = 2,
    CTL_NET___2 = 3,
    CTL_PROC___2 = 4,
    CTL_FS___2 = 5,
    CTL_DEBUG___2 = 6,
    CTL_DEV___2 = 7,
    CTL_BUS___2 = 8,
    CTL_ABI___2 = 9,
    CTL_CPU___2 = 10,
    CTL_ARLAN___2 = 254,
    CTL_S390DBF___2 = 5677,
    CTL_SUNRPC___2 = 7249,
    CTL_PM___2 = 9899,
    CTL_FRV___2 = 9898
} ;
enum __anonenum_126___2 {
    CTL_BUS_ISA___2 = 1
} ;
enum __anonenum_127___2 {
    INOTIFY_MAX_USER_INSTANCES___2 = 1,
    INOTIFY_MAX_USER_WATCHES___2 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___2 = 3
} ;
enum __anonenum_128___2 {
    KERN_OSTYPE___2 = 1,
    KERN_OSRELEASE___2 = 2,
    KERN_OSREV___2 = 3,
    KERN_VERSION___2 = 4,
    KERN_SECUREMASK___2 = 5,
    KERN_PROF___2 = 6,
    KERN_NODENAME___2 = 7,
    KERN_DOMAINNAME___2 = 8,
    KERN_PANIC___2 = 15,
    KERN_REALROOTDEV___2 = 16,
    KERN_SPARC_REBOOT___2 = 21,
    KERN_CTLALTDEL___2 = 22,
    KERN_PRINTK___2 = 23,
    KERN_NAMETRANS___2 = 24,
    KERN_PPC_HTABRECLAIM___2 = 25,
    KERN_PPC_ZEROPAGED___2 = 26,
    KERN_PPC_POWERSAVE_NAP___2 = 27,
    KERN_MODPROBE___2 = 28,
    KERN_SG_BIG_BUFF___2 = 29,
    KERN_ACCT___2 = 30,
    KERN_PPC_L2CR___2 = 31,
    KERN_RTSIGNR___2 = 32,
    KERN_RTSIGMAX___2 = 33,
    KERN_SHMMAX___2 = 34,
    KERN_MSGMAX___2 = 35,
    KERN_MSGMNB___2 = 36,
    KERN_MSGPOOL___2 = 37,
    KERN_SYSRQ___2 = 38,
    KERN_MAX_THREADS___2 = 39,
    KERN_RANDOM___2 = 40,
    KERN_SHMALL___2 = 41,
    KERN_MSGMNI___2 = 42,
    KERN_SEM___2 = 43,
    KERN_SPARC_STOP_A___2 = 44,
    KERN_SHMMNI___2 = 45,
    KERN_OVERFLOWUID___2 = 46,
    KERN_OVERFLOWGID___2 = 47,
    KERN_SHMPATH___2 = 48,
    KERN_HOTPLUG___2 = 49,
    KERN_IEEE_EMULATION_WARNINGS___2 = 50,
    KERN_S390_USER_DEBUG_LOGGING___2 = 51,
    KERN_CORE_USES_PID___2 = 52,
    KERN_TAINTED___2 = 53,
    KERN_CADPID___2 = 54,
    KERN_PIDMAX___2 = 55,
    KERN_CORE_PATTERN___2 = 56,
    KERN_PANIC_ON_OOPS___2 = 57,
    KERN_HPPA_PWRSW___2 = 58,
    KERN_HPPA_UNALIGNED___2 = 59,
    KERN_PRINTK_RATELIMIT___2 = 60,
    KERN_PRINTK_RATELIMIT_BURST___2 = 61,
    KERN_PTY___2 = 62,
    KERN_NGROUPS_MAX___2 = 63,
    KERN_SPARC_SCONS_PWROFF___2 = 64,
    KERN_HZ_TIMER___2 = 65,
    KERN_UNKNOWN_NMI_PANIC___2 = 66,
    KERN_BOOTLOADER_TYPE___2 = 67,
    KERN_RANDOMIZE___2 = 68,
    KERN_SETUID_DUMPABLE___2 = 69,
    KERN_SPIN_RETRY___2 = 70,
    KERN_ACPI_VIDEO_FLAGS___2 = 71,
    KERN_IA64_UNALIGNED___2 = 72,
    KERN_COMPAT_LOG___2 = 73,
    KERN_MAX_LOCK_DEPTH___2 = 74,
    KERN_NMI_WATCHDOG___2 = 75,
    KERN_PANIC_ON_NMI___2 = 76
} ;
enum __anonenum_129___2 {
    VM_UNUSED1___2 = 1,
    VM_UNUSED2___2 = 2,
    VM_UNUSED3___2 = 3,
    VM_UNUSED4___2 = 4,
    VM_OVERCOMMIT_MEMORY___2 = 5,
    VM_UNUSED5___2 = 6,
    VM_UNUSED7___2 = 7,
    VM_UNUSED8___2 = 8,
    VM_UNUSED9___2 = 9,
    VM_PAGE_CLUSTER___2 = 10,
    VM_DIRTY_BACKGROUND___2 = 11,
    VM_DIRTY_RATIO___2 = 12,
    VM_DIRTY_WB_CS___2 = 13,
    VM_DIRTY_EXPIRE_CS___2 = 14,
    VM_NR_PDFLUSH_THREADS___2 = 15,
    VM_OVERCOMMIT_RATIO___2 = 16,
    VM_PAGEBUF___2 = 17,
    VM_HUGETLB_PAGES___2 = 18,
    VM_SWAPPINESS___2 = 19,
    VM_LOWMEM_RESERVE_RATIO___2 = 20,
    VM_MIN_FREE_KBYTES___2 = 21,
    VM_MAX_MAP_COUNT___2 = 22,
    VM_LAPTOP_MODE___2 = 23,
    VM_BLOCK_DUMP___2 = 24,
    VM_HUGETLB_GROUP___2 = 25,
    VM_VFS_CACHE_PRESSURE___2 = 26,
    VM_LEGACY_VA_LAYOUT___2 = 27,
    VM_SWAP_TOKEN_TIMEOUT___2 = 28,
    VM_DROP_PAGECACHE___2 = 29,
    VM_PERCPU_PAGELIST_FRACTION___2 = 30,
    VM_ZONE_RECLAIM_MODE___2 = 31,
    VM_MIN_UNMAPPED___2 = 32,
    VM_PANIC_ON_OOM___2 = 33,
    VM_VDSO_ENABLED___2 = 34,
    VM_MIN_SLAB___2 = 35
} ;
enum __anonenum_130___2 {
    NET_CORE___2 = 1,
    NET_ETHER___2 = 2,
    NET_802___2 = 3,
    NET_UNIX___2 = 4,
    NET_IPV4___2 = 5,
    NET_IPX___2 = 6,
    NET_ATALK___2 = 7,
    NET_NETROM___2 = 8,
    NET_AX25___2 = 9,
    NET_BRIDGE___2 = 10,
    NET_ROSE___2 = 11,
    NET_IPV6___2 = 12,
    NET_X25___2 = 13,
    NET_TR___2 = 14,
    NET_DECNET___2 = 15,
    NET_ECONET___2 = 16,
    NET_SCTP___2 = 17,
    NET_LLC___2 = 18,
    NET_NETFILTER___2 = 19,
    NET_DCCP___2 = 20,
    NET_IRDA___2 = 412
} ;
enum __anonenum_131___2 {
    RANDOM_POOLSIZE___2 = 1,
    RANDOM_ENTROPY_COUNT___2 = 2,
    RANDOM_READ_THRESH___2 = 3,
    RANDOM_WRITE_THRESH___2 = 4,
    RANDOM_BOOT_ID___2 = 5,
    RANDOM_UUID___2 = 6
} ;
enum __anonenum_132___2 {
    PTY_MAX___2 = 1,
    PTY_NR___2 = 2
} ;
enum __anonenum_133___2 {
    BUS_ISA_MEM_BASE___2 = 1,
    BUS_ISA_PORT_BASE___2 = 2,
    BUS_ISA_PORT_SHIFT___2 = 3
} ;
enum __anonenum_134___2 {
    NET_CORE_WMEM_MAX___2 = 1,
    NET_CORE_RMEM_MAX___2 = 2,
    NET_CORE_WMEM_DEFAULT___2 = 3,
    NET_CORE_RMEM_DEFAULT___2 = 4,
    NET_CORE_MAX_BACKLOG___2 = 6,
    NET_CORE_FASTROUTE___2 = 7,
    NET_CORE_MSG_COST___2 = 8,
    NET_CORE_MSG_BURST___2 = 9,
    NET_CORE_OPTMEM_MAX___2 = 10,
    NET_CORE_HOT_LIST_LENGTH___2 = 11,
    NET_CORE_DIVERT_VERSION___2 = 12,
    NET_CORE_NO_CONG_THRESH___2 = 13,
    NET_CORE_NO_CONG___2 = 14,
    NET_CORE_LO_CONG___2 = 15,
    NET_CORE_MOD_CONG___2 = 16,
    NET_CORE_DEV_WEIGHT___2 = 17,
    NET_CORE_SOMAXCONN___2 = 18,
    NET_CORE_BUDGET___2 = 19,
    NET_CORE_AEVENT_ETIME___2 = 20,
    NET_CORE_AEVENT_RSEQTH___2 = 21,
    NET_CORE_WARNINGS___2 = 22
} ;
enum __anonenum_135___2 {
    NET_UNIX_DESTROY_DELAY___2 = 1,
    NET_UNIX_DELETE_DELAY___2 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___2 = 3
} ;
enum __anonenum_136___2 {
    NET_NF_CONNTRACK_MAX___2 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___2 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___2 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___2 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___2 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___2 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___2 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___2 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___2 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___2 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___2 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___2 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___2 = 13,
    NET_NF_CONNTRACK_BUCKETS___2 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___2 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___2 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___2 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___2 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___2 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___2 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___2 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___2 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___2 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___2 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___2 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___2 = 26,
    NET_NF_CONNTRACK_COUNT___2 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___2 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___2 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___2 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___2 = 31,
    NET_NF_CONNTRACK_CHECKSUM___2 = 32
} ;
enum __anonenum_137___2 {
    NET_IPV4_FORWARD___2 = 8,
    NET_IPV4_DYNADDR___2 = 9,
    NET_IPV4_CONF___2 = 16,
    NET_IPV4_NEIGH___2 = 17,
    NET_IPV4_ROUTE___2 = 18,
    NET_IPV4_FIB_HASH___2 = 19,
    NET_IPV4_NETFILTER___2 = 20,
    NET_IPV4_TCP_TIMESTAMPS___2 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___2 = 34,
    NET_IPV4_TCP_SACK___2 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___2 = 36,
    NET_IPV4_DEFAULT_TTL___2 = 37,
    NET_IPV4_AUTOCONFIG___2 = 38,
    NET_IPV4_NO_PMTU_DISC___2 = 39,
    NET_IPV4_TCP_SYN_RETRIES___2 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___2 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___2 = 42,
    NET_IPV4_IPFRAG_TIME___2 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___2 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___2 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___2 = 46,
    NET_IPV4_TCP_RETRIES1___2 = 47,
    NET_IPV4_TCP_RETRIES2___2 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___2 = 49,
    NET_IPV4_IP_MASQ_DEBUG___2 = 50,
    NET_TCP_SYNCOOKIES___2 = 51,
    NET_TCP_STDURG___2 = 52,
    NET_TCP_RFC1337___2 = 53,
    NET_TCP_SYN_TAILDROP___2 = 54,
    NET_TCP_MAX_SYN_BACKLOG___2 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___2 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___2 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___2 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___2 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___2 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___2 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___2 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___2 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___2 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___2 = 65,
    NET_TCP_TW_RECYCLE___2 = 66,
    NET_IPV4_ALWAYS_DEFRAG___2 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___2 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___2 = 69,
    NET_IPV4_INET_PEER_MINTTL___2 = 70,
    NET_IPV4_INET_PEER_MAXTTL___2 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___2 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___2 = 73,
    NET_TCP_ORPHAN_RETRIES___2 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___2 = 75,
    NET_TCP_SYNACK_RETRIES___2 = 76,
    NET_TCP_MAX_ORPHANS___2 = 77,
    NET_TCP_MAX_TW_BUCKETS___2 = 78,
    NET_TCP_FACK___2 = 79,
    NET_TCP_REORDERING___2 = 80,
    NET_TCP_ECN___2 = 81,
    NET_TCP_DSACK___2 = 82,
    NET_TCP_MEM___2 = 83,
    NET_TCP_WMEM___2 = 84,
    NET_TCP_RMEM___2 = 85,
    NET_TCP_APP_WIN___2 = 86,
    NET_TCP_ADV_WIN_SCALE___2 = 87,
    NET_IPV4_NONLOCAL_BIND___2 = 88,
    NET_IPV4_ICMP_RATELIMIT___2 = 89,
    NET_IPV4_ICMP_RATEMASK___2 = 90,
    NET_TCP_TW_REUSE___2 = 91,
    NET_TCP_FRTO___2 = 92,
    NET_TCP_LOW_LATENCY___2 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___2 = 94,
    NET_IPV4_IGMP_MAX_MSF___2 = 96,
    NET_TCP_NO_METRICS_SAVE___2 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___2 = 105,
    NET_TCP_MODERATE_RCVBUF___2 = 106,
    NET_TCP_TSO_WIN_DIVISOR___2 = 107,
    NET_TCP_BIC_BETA___2 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___2 = 109,
    NET_TCP_CONG_CONTROL___2 = 110,
    NET_TCP_ABC___2 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___2 = 112,
    NET_TCP_MTU_PROBING___2 = 113,
    NET_TCP_BASE_MSS___2 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___2 = 115,
    NET_TCP_DMA_COPYBREAK___2 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___2 = 117,
    NET_CIPSOV4_CACHE_ENABLE___2 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___2 = 119,
    NET_CIPSOV4_RBM_OPTFMT___2 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___2 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___2 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___2 = 123,
    NET_TCP_MAX_SSTHRESH___2 = 124,
    NET_TCP_FRTO_RESPONSE___2 = 125
} ;
enum __anonenum_138___2 {
    NET_IPV4_ROUTE_FLUSH___2 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___2 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___2 = 3,
    NET_IPV4_ROUTE_GC_THRESH___2 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___2 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___2 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___2 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___2 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___2 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___2 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___2 = 11,
    NET_IPV4_ROUTE_ERROR_COST___2 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___2 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___2 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___2 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___2 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___2 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___2 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___2 = 19
} ;
enum __anonenum_139___2 {
    NET_PROTO_CONF_ALL___2 = -2,
    NET_PROTO_CONF_DEFAULT___2 = -3
} ;
enum __anonenum_140___2 {
    NET_IPV4_CONF_FORWARDING___2 = 1,
    NET_IPV4_CONF_MC_FORWARDING___2 = 2,
    NET_IPV4_CONF_PROXY_ARP___2 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___2 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___2 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___2 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___2 = 7,
    NET_IPV4_CONF_RP_FILTER___2 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___2 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___2 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___2 = 11,
    NET_IPV4_CONF_TAG___2 = 12,
    NET_IPV4_CONF_ARPFILTER___2 = 13,
    NET_IPV4_CONF_MEDIUM_ID___2 = 14,
    NET_IPV4_CONF_NOXFRM___2 = 15,
    NET_IPV4_CONF_NOPOLICY___2 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___2 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___2 = 18,
    NET_IPV4_CONF_ARP_IGNORE___2 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___2 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___2 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___2 = 22,
    __NET_IPV4_CONF_MAX___2 = 23
} ;
enum __anonenum_141___2 {
    NET_IPV4_NF_CONNTRACK_MAX___2 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___2 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___2 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___2 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___2 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___2 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___2 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___2 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___2 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___2 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___2 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___2 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___2 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___2 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___2 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___2 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___2 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___2 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___2 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___2 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___2 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___2 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___2 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___2 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___2 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___2 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___2 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___2 = 28
} ;
enum __anonenum_142___2 {
    NET_IPV6_CONF___2 = 16,
    NET_IPV6_NEIGH___2 = 17,
    NET_IPV6_ROUTE___2 = 18,
    NET_IPV6_ICMP___2 = 19,
    NET_IPV6_BINDV6ONLY___2 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___2 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___2 = 22,
    NET_IPV6_IP6FRAG_TIME___2 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___2 = 24,
    NET_IPV6_MLD_MAX_MSF___2 = 25
} ;
enum __anonenum_143___2 {
    NET_IPV6_ROUTE_FLUSH___2 = 1,
    NET_IPV6_ROUTE_GC_THRESH___2 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___2 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___2 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___2 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___2 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___2 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___2 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___2 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___2 = 10
} ;
enum __anonenum_144___2 {
    NET_IPV6_FORWARDING___2 = 1,
    NET_IPV6_HOP_LIMIT___2 = 2,
    NET_IPV6_MTU___2 = 3,
    NET_IPV6_ACCEPT_RA___2 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___2 = 5,
    NET_IPV6_AUTOCONF___2 = 6,
    NET_IPV6_DAD_TRANSMITS___2 = 7,
    NET_IPV6_RTR_SOLICITS___2 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___2 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___2 = 10,
    NET_IPV6_USE_TEMPADDR___2 = 11,
    NET_IPV6_TEMP_VALID_LFT___2 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___2 = 13,
    NET_IPV6_REGEN_MAX_RETRY___2 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___2 = 15,
    NET_IPV6_MAX_ADDRESSES___2 = 16,
    NET_IPV6_FORCE_MLD_VERSION___2 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___2 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___2 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___2 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___2 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___2 = 22,
    NET_IPV6_PROXY_NDP___2 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___2 = 25,
    __NET_IPV6_MAX___2 = 26
} ;
enum __anonenum_145___2 {
    NET_IPV6_ICMP_RATELIMIT___2 = 1
} ;
enum __anonenum_146___2 {
    NET_NEIGH_MCAST_SOLICIT___2 = 1,
    NET_NEIGH_UCAST_SOLICIT___2 = 2,
    NET_NEIGH_APP_SOLICIT___2 = 3,
    NET_NEIGH_RETRANS_TIME___2 = 4,
    NET_NEIGH_REACHABLE_TIME___2 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___2 = 6,
    NET_NEIGH_GC_STALE_TIME___2 = 7,
    NET_NEIGH_UNRES_QLEN___2 = 8,
    NET_NEIGH_PROXY_QLEN___2 = 9,
    NET_NEIGH_ANYCAST_DELAY___2 = 10,
    NET_NEIGH_PROXY_DELAY___2 = 11,
    NET_NEIGH_LOCKTIME___2 = 12,
    NET_NEIGH_GC_INTERVAL___2 = 13,
    NET_NEIGH_GC_THRESH1___2 = 14,
    NET_NEIGH_GC_THRESH2___2 = 15,
    NET_NEIGH_GC_THRESH3___2 = 16,
    NET_NEIGH_RETRANS_TIME_MS___2 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___2 = 18,
    __NET_NEIGH_MAX___2 = 19
} ;
enum __anonenum_147___2 {
    NET_DCCP_DEFAULT___2 = 1
} ;
enum __anonenum_148___2 {
    NET_IPX_PPROP_BROADCASTING___2 = 1,
    NET_IPX_FORWARDING___2 = 2
} ;
enum __anonenum_149___2 {
    NET_LLC2___2 = 1,
    NET_LLC_STATION___2 = 2
} ;
enum __anonenum_150___2 {
    NET_LLC2_TIMEOUT___2 = 1
} ;
enum __anonenum_151___2 {
    NET_LLC_STATION_ACK_TIMEOUT___2 = 1
} ;
enum __anonenum_152___2 {
    NET_LLC2_ACK_TIMEOUT___2 = 1,
    NET_LLC2_P_TIMEOUT___2 = 2,
    NET_LLC2_REJ_TIMEOUT___2 = 3,
    NET_LLC2_BUSY_TIMEOUT___2 = 4
} ;
enum __anonenum_153___2 {
    NET_ATALK_AARP_EXPIRY_TIME___2 = 1,
    NET_ATALK_AARP_TICK_TIME___2 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___2 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___2 = 4
} ;
enum __anonenum_154___2 {
    NET_NETROM_DEFAULT_PATH_QUALITY___2 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___2 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___2 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___2 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___2 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___2 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___2 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___2 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___2 = 9,
    NET_NETROM_ROUTING_CONTROL___2 = 10,
    NET_NETROM_LINK_FAILS_COUNT___2 = 11,
    NET_NETROM_RESET___2 = 12
} ;
enum __anonenum_155___2 {
    NET_AX25_IP_DEFAULT_MODE___2 = 1,
    NET_AX25_DEFAULT_MODE___2 = 2,
    NET_AX25_BACKOFF_TYPE___2 = 3,
    NET_AX25_CONNECT_MODE___2 = 4,
    NET_AX25_STANDARD_WINDOW___2 = 5,
    NET_AX25_EXTENDED_WINDOW___2 = 6,
    NET_AX25_T1_TIMEOUT___2 = 7,
    NET_AX25_T2_TIMEOUT___2 = 8,
    NET_AX25_T3_TIMEOUT___2 = 9,
    NET_AX25_IDLE_TIMEOUT___2 = 10,
    NET_AX25_N2___2 = 11,
    NET_AX25_PACLEN___2 = 12,
    NET_AX25_PROTOCOL___2 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___2 = 14
} ;
enum __anonenum_156___2 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___2 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___2 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___2 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___2 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___2 = 5,
    NET_ROSE_ROUTING_CONTROL___2 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___2 = 7,
    NET_ROSE_MAX_VCS___2 = 8,
    NET_ROSE_WINDOW_SIZE___2 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___2 = 10
} ;
enum __anonenum_157___2 {
    NET_X25_RESTART_REQUEST_TIMEOUT___2 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___2 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___2 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___2 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___2 = 5,
    NET_X25_FORWARD___2 = 6
} ;
enum __anonenum_158___2 {
    NET_TR_RIF_TIMEOUT___2 = 1
} ;
enum __anonenum_159___2 {
    NET_DECNET_NODE_TYPE___2 = 1,
    NET_DECNET_NODE_ADDRESS___2 = 2,
    NET_DECNET_NODE_NAME___2 = 3,
    NET_DECNET_DEFAULT_DEVICE___2 = 4,
    NET_DECNET_TIME_WAIT___2 = 5,
    NET_DECNET_DN_COUNT___2 = 6,
    NET_DECNET_DI_COUNT___2 = 7,
    NET_DECNET_DR_COUNT___2 = 8,
    NET_DECNET_DST_GC_INTERVAL___2 = 9,
    NET_DECNET_CONF___2 = 10,
    NET_DECNET_NO_FC_MAX_CWND___2 = 11,
    NET_DECNET_MEM___2 = 12,
    NET_DECNET_RMEM___2 = 13,
    NET_DECNET_WMEM___2 = 14,
    NET_DECNET_DEBUG_LEVEL___2 = 255
} ;
enum __anonenum_160___2 {
    NET_DECNET_CONF_LOOPBACK___2 = -2,
    NET_DECNET_CONF_DDCMP___2 = -3,
    NET_DECNET_CONF_PPP___2 = -4,
    NET_DECNET_CONF_X25___2 = -5,
    NET_DECNET_CONF_GRE___2 = -6,
    NET_DECNET_CONF_ETHER___2 = -7
} ;
enum __anonenum_161___2 {
    NET_DECNET_CONF_DEV_PRIORITY___2 = 1,
    NET_DECNET_CONF_DEV_T1___2 = 2,
    NET_DECNET_CONF_DEV_T2___2 = 3,
    NET_DECNET_CONF_DEV_T3___2 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___2 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___2 = 6,
    NET_DECNET_CONF_DEV_STATE___2 = 7
} ;
enum __anonenum_162___2 {
    NET_SCTP_RTO_INITIAL___2 = 1,
    NET_SCTP_RTO_MIN___2 = 2,
    NET_SCTP_RTO_MAX___2 = 3,
    NET_SCTP_RTO_ALPHA___2 = 4,
    NET_SCTP_RTO_BETA___2 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___2 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___2 = 7,
    NET_SCTP_PATH_MAX_RETRANS___2 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___2 = 9,
    NET_SCTP_HB_INTERVAL___2 = 10,
    NET_SCTP_PRESERVE_ENABLE___2 = 11,
    NET_SCTP_MAX_BURST___2 = 12,
    NET_SCTP_ADDIP_ENABLE___2 = 13,
    NET_SCTP_PRSCTP_ENABLE___2 = 14,
    NET_SCTP_SNDBUF_POLICY___2 = 15,
    NET_SCTP_SACK_TIMEOUT___2 = 16,
    NET_SCTP_RCVBUF_POLICY___2 = 17
} ;
enum __anonenum_163___2 {
    NET_BRIDGE_NF_CALL_ARPTABLES___2 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___2 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___2 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___2 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___2 = 5
} ;
enum __anonenum_164___2 {
    NET_IRDA_DISCOVERY___2 = 1,
    NET_IRDA_DEVNAME___2 = 2,
    NET_IRDA_DEBUG___2 = 3,
    NET_IRDA_FAST_POLL___2 = 4,
    NET_IRDA_DISCOVERY_SLOTS___2 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___2 = 6,
    NET_IRDA_SLOT_TIMEOUT___2 = 7,
    NET_IRDA_MAX_BAUD_RATE___2 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___2 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___2 = 10,
    NET_IRDA_MAX_TX_WINDOW___2 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___2 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___2 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___2 = 14
} ;
enum __anonenum_165___2 {
    FS_NRINODE___2 = 1,
    FS_STATINODE___2 = 2,
    FS_MAXINODE___2 = 3,
    FS_NRDQUOT___2 = 4,
    FS_MAXDQUOT___2 = 5,
    FS_NRFILE___2 = 6,
    FS_MAXFILE___2 = 7,
    FS_DENTRY___2 = 8,
    FS_NRSUPER___2 = 9,
    FS_MAXSUPER___2 = 10,
    FS_OVERFLOWUID___2 = 11,
    FS_OVERFLOWGID___2 = 12,
    FS_LEASES___2 = 13,
    FS_DIR_NOTIFY___2 = 14,
    FS_LEASE_TIME___2 = 15,
    FS_DQSTATS___2 = 16,
    FS_XFS___2 = 17,
    FS_AIO_NR___2 = 18,
    FS_AIO_MAX_NR___2 = 19,
    FS_INOTIFY___2 = 20,
    FS_OCFS2___2 = 988
} ;
enum __anonenum_166___2 {
    FS_DQ_LOOKUPS___2 = 1,
    FS_DQ_DROPS___2 = 2,
    FS_DQ_READS___2 = 3,
    FS_DQ_WRITES___2 = 4,
    FS_DQ_CACHE_HITS___2 = 5,
    FS_DQ_ALLOCATED___2 = 6,
    FS_DQ_FREE___2 = 7,
    FS_DQ_SYNCS___2 = 8,
    FS_DQ_WARNINGS___2 = 9
} ;
enum __anonenum_167___1 {
    DEV_CDROM___2 = 1,
    DEV_HWMON___2 = 2,
    DEV_PARPORT___2 = 3,
    DEV_RAID___2 = 4,
    DEV_MAC_HID___2 = 5,
    DEV_SCSI___2 = 6,
    DEV_IPMI___2 = 7
} ;
enum __anonenum_168___1 {
    DEV_CDROM_INFO___2 = 1,
    DEV_CDROM_AUTOCLOSE___2 = 2,
    DEV_CDROM_AUTOEJECT___2 = 3,
    DEV_CDROM_DEBUG___2 = 4,
    DEV_CDROM_LOCK___2 = 5,
    DEV_CDROM_CHECK_MEDIA___2 = 6
} ;
enum __anonenum_169___2 {
    DEV_PARPORT_DEFAULT___2 = -3
} ;
enum __anonenum_170___1 {
    DEV_RAID_SPEED_LIMIT_MIN___2 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___2 = 2
} ;
enum __anonenum_171___1 {
    DEV_PARPORT_DEFAULT_TIMESLICE___2 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___2 = 2
} ;
enum __anonenum_172___2 {
    DEV_PARPORT_SPINTIME___2 = 1,
    DEV_PARPORT_BASE_ADDR___2 = 2,
    DEV_PARPORT_IRQ___2 = 3,
    DEV_PARPORT_DMA___2 = 4,
    DEV_PARPORT_MODES___2 = 5,
    DEV_PARPORT_DEVICES___2 = 6,
    DEV_PARPORT_AUTOPROBE___2 = 16
} ;
enum __anonenum_173___2 {
    DEV_PARPORT_DEVICES_ACTIVE___2 = -3
} ;
enum __anonenum_174___1 {
    DEV_PARPORT_DEVICE_TIMESLICE___2 = 1
} ;
enum __anonenum_175___0 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___2 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___2 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___2 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___2 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___2 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___2 = 6
} ;
enum __anonenum_176___1 {
    DEV_SCSI_LOGGING_LEVEL___2 = 1
} ;
enum __anonenum_177___0 {
    DEV_IPMI_POWEROFF_POWERCYCLE___2 = 1
} ;
enum __anonenum_178___0 {
    ABI_DEFHANDLER_COFF___2 = 1,
    ABI_DEFHANDLER_ELF___2 = 2,
    ABI_DEFHANDLER_LCALL7___2 = 3,
    ABI_DEFHANDLER_LIBCSO___2 = 4,
    ABI_TRACE___2 = 5,
    ABI_FAKE_UTSNAME___2 = 6
} ;
enum __anonenum_181___1 {
    IOCB_CMD_PREAD___2 = 0,
    IOCB_CMD_PWRITE___2 = 1,
    IOCB_CMD_FSYNC___2 = 2,
    IOCB_CMD_FDSYNC___2 = 3,
    IOCB_CMD_NOOP___2 = 6,
    IOCB_CMD_PREADV___2 = 7,
    IOCB_CMD_PWRITEV___2 = 8
} ;
enum __anonenum_193___1 {
    IRQTF_RUNTHREAD___2 = 0,
    IRQTF_DIED___2 = 1,
    IRQTF_WARNED___2 = 2
} ;
enum __anonenum_194___1 {
    HI_SOFTIRQ___2 = 0,
    TIMER_SOFTIRQ___2 = 1,
    NET_TX_SOFTIRQ___2 = 2,
    NET_RX_SOFTIRQ___2 = 3,
    BLOCK_SOFTIRQ___2 = 4,
    TASKLET_SOFTIRQ___2 = 5,
    SCHED_SOFTIRQ___2 = 6,
    HRTIMER_SOFTIRQ___2 = 7,
    RCU_SOFTIRQ___2 = 8,
    NR_SOFTIRQS___2 = 9
} ;
enum __anonenum_195 {
    TASKLET_STATE_SCHED___2 = 0,
    TASKLET_STATE_RUN___2 = 1
} ;
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
struct linux_binprm {
   char buf[128] ;
   struct vm_area_struct *vma ;
   struct mm_struct *mm ;
   unsigned long p ;
   unsigned int cred_prepared : 1 ;
   unsigned int cap_effective : 1 ;
   unsigned int recursion_depth ;
   struct file *file ;
   struct cred *cred ;
   int unsafe ;
   unsigned int per_clear ;
   int argc ;
   int envc ;
   char *filename ;
   char *interp ;
   unsigned int interp_flags ;
   unsigned int interp_data ;
   unsigned long loader ;
   unsigned long exec ;
};
struct linux_binfmt {
   struct list_head lh ;
   struct module *module ;
   int (*load_binary)(struct linux_binprm * , struct pt_regs *regs ) ;
   int (*load_shlib)(struct file * ) ;
   int (*core_dump)(long signr , struct pt_regs *regs , struct file *file , unsigned long limit ) ;
   unsigned long min_coredump ;
   int hasvdso ;
};
struct shmid_ds {
   struct ipc_perm shm_perm ;
   int shm_segsz ;
   __kernel_time_t shm_atime ;
   __kernel_time_t shm_dtime ;
   __kernel_time_t shm_ctime ;
   __kernel_ipc_pid_t shm_cpid ;
   __kernel_ipc_pid_t shm_lpid ;
   unsigned short shm_nattch ;
   unsigned short shm_unused ;
   void *shm_unused2 ;
   void *shm_unused3 ;
};
struct shmid64_ds {
   struct ipc64_perm shm_perm ;
   size_t shm_segsz ;
   __kernel_time_t shm_atime ;
   __kernel_time_t shm_dtime ;
   __kernel_time_t shm_ctime ;
   __kernel_pid_t shm_cpid ;
   __kernel_pid_t shm_lpid ;
   unsigned long shm_nattch ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct shminfo64 {
   unsigned long shmmax ;
   unsigned long shmmin ;
   unsigned long shmmni ;
   unsigned long shmseg ;
   unsigned long shmall ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct shminfo {
   int shmmax ;
   int shmmin ;
   int shmmni ;
   int shmseg ;
   int shmall ;
};
struct shm_info {
   int used_ids ;
   unsigned long shm_tot ;
   unsigned long shm_rss ;
   unsigned long shm_swp ;
   unsigned long swap_attempts ;
   unsigned long swap_successes ;
};
struct shmid_kernel {
   struct kern_ipc_perm shm_perm ;
   struct file *shm_file ;
   unsigned long shm_nattch ;
   unsigned long shm_segsz ;
   time_t shm_atim ;
   time_t shm_dtim ;
   time_t shm_ctim ;
   pid_t shm_cprid ;
   pid_t shm_lprid ;
   struct user_struct *mlock_user ;
};
struct msg;
struct msqid_ds {
   struct ipc_perm msg_perm ;
   struct msg *msg_first ;
   struct msg *msg_last ;
   __kernel_time_t msg_stime ;
   __kernel_time_t msg_rtime ;
   __kernel_time_t msg_ctime ;
   unsigned long msg_lcbytes ;
   unsigned long msg_lqbytes ;
   unsigned short msg_cbytes ;
   unsigned short msg_qnum ;
   unsigned short msg_qbytes ;
   __kernel_ipc_pid_t msg_lspid ;
   __kernel_ipc_pid_t msg_lrpid ;
};
struct msqid64_ds {
   struct ipc64_perm msg_perm ;
   __kernel_time_t msg_stime ;
   __kernel_time_t msg_rtime ;
   __kernel_time_t msg_ctime ;
   unsigned long msg_cbytes ;
   unsigned long msg_qnum ;
   unsigned long msg_qbytes ;
   __kernel_pid_t msg_lspid ;
   __kernel_pid_t msg_lrpid ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct msgbuf {
   long mtype ;
   char mtext[1] ;
};
struct msginfo {
   int msgpool ;
   int msgmap ;
   int msgmax ;
   int msgmnb ;
   int msgmni ;
   int msgssz ;
   int msgtql ;
   unsigned short msgseg ;
};
struct msg_msgseg;
struct msg_msg {
   struct list_head m_list ;
   long m_type ;
   int m_ts ;
   struct msg_msgseg *next ;
   void *security ;
};
struct msg_queue {
   struct kern_ipc_perm q_perm ;
   time_t q_stime ;
   time_t q_rtime ;
   time_t q_ctime ;
   unsigned long q_cbytes ;
   unsigned long q_qnum ;
   unsigned long q_qbytes ;
   pid_t q_lspid ;
   pid_t q_lrpid ;
   struct list_head q_messages ;
   struct list_head q_receivers ;
   struct list_head q_senders ;
};
union __anonunion_xfrm_address_t_196 {
   __be32 a4 ;
   __be32 a6[4] ;
};
typedef union __anonunion_xfrm_address_t_196 xfrm_address_t;
struct xfrm_id {
   xfrm_address_t daddr ;
   __be32 spi ;
   __u8 proto ;
};
struct xfrm_sec_ctx {
   __u8 ctx_doi ;
   __u8 ctx_alg ;
   __u16 ctx_len ;
   __u32 ctx_sid ;
   char ctx_str[0] ;
};
struct xfrm_selector {
   xfrm_address_t daddr ;
   xfrm_address_t saddr ;
   __be16 dport ;
   __be16 dport_mask ;
   __be16 sport ;
   __be16 sport_mask ;
   __u16 family ;
   __u8 prefixlen_d ;
   __u8 prefixlen_s ;
   __u8 proto ;
   int ifindex ;
   __kernel_uid32_t user ;
};
struct xfrm_lifetime_cfg {
   __u64 soft_byte_limit ;
   __u64 hard_byte_limit ;
   __u64 soft_packet_limit ;
   __u64 hard_packet_limit ;
   __u64 soft_add_expires_seconds ;
   __u64 hard_add_expires_seconds ;
   __u64 soft_use_expires_seconds ;
   __u64 hard_use_expires_seconds ;
};
struct xfrm_lifetime_cur {
   __u64 bytes ;
   __u64 packets ;
   __u64 add_time ;
   __u64 use_time ;
};
struct xfrm_replay_state {
   __u32 oseq ;
   __u32 seq ;
   __u32 bitmap ;
};
struct xfrm_algo {
   char alg_name[64] ;
   unsigned int alg_key_len ;
   char alg_key[0] ;
};
struct xfrm_algo_aead {
   char alg_name[64] ;
   unsigned int alg_key_len ;
   unsigned int alg_icv_len ;
   char alg_key[0] ;
};
struct xfrm_stats {
   __u32 replay_window ;
   __u32 replay ;
   __u32 integrity_failed ;
};
enum __anonenum_197 {
    XFRM_POLICY_TYPE_MAIN = 0,
    XFRM_POLICY_TYPE_SUB = 1,
    XFRM_POLICY_TYPE_MAX = 2,
    XFRM_POLICY_TYPE_ANY = 255
} ;
enum __anonenum_198 {
    XFRM_POLICY_IN = 0,
    XFRM_POLICY_OUT = 1,
    XFRM_POLICY_FWD = 2,
    XFRM_POLICY_MASK = 3,
    XFRM_POLICY_MAX = 3
} ;
enum __anonenum_199 {
    XFRM_SHARE_ANY = 0,
    XFRM_SHARE_SESSION = 1,
    XFRM_SHARE_USER = 2,
    XFRM_SHARE_UNIQUE = 3
} ;
enum __anonenum_200 {
    XFRM_MSG_BASE = 16,
    XFRM_MSG_NEWSA = 16,
    XFRM_MSG_DELSA = 17,
    XFRM_MSG_GETSA = 18,
    XFRM_MSG_NEWPOLICY = 19,
    XFRM_MSG_DELPOLICY = 20,
    XFRM_MSG_GETPOLICY = 21,
    XFRM_MSG_ALLOCSPI = 22,
    XFRM_MSG_ACQUIRE = 23,
    XFRM_MSG_EXPIRE = 24,
    XFRM_MSG_UPDPOLICY = 25,
    XFRM_MSG_UPDSA = 26,
    XFRM_MSG_POLEXPIRE = 27,
    XFRM_MSG_FLUSHSA = 28,
    XFRM_MSG_FLUSHPOLICY = 29,
    XFRM_MSG_NEWAE = 30,
    XFRM_MSG_GETAE = 31,
    XFRM_MSG_REPORT = 32,
    XFRM_MSG_MIGRATE = 33,
    XFRM_MSG_NEWSADINFO = 34,
    XFRM_MSG_GETSADINFO = 35,
    XFRM_MSG_NEWSPDINFO = 36,
    XFRM_MSG_GETSPDINFO = 37,
    XFRM_MSG_MAPPING = 38,
    __XFRM_MSG_MAX = 39
} ;
struct xfrm_user_sec_ctx {
   __u16 len ;
   __u16 exttype ;
   __u8 ctx_alg ;
   __u8 ctx_doi ;
   __u16 ctx_len ;
};
struct xfrm_user_tmpl {
   struct xfrm_id id ;
   __u16 family ;
   xfrm_address_t saddr ;
   __u32 reqid ;
   __u8 mode ;
   __u8 share ;
   __u8 optional ;
   __u32 aalgos ;
   __u32 ealgos ;
   __u32 calgos ;
};
struct xfrm_encap_tmpl {
   __u16 encap_type ;
   __be16 encap_sport ;
   __be16 encap_dport ;
   xfrm_address_t encap_oa ;
};
enum xfrm_ae_ftype_t {
    XFRM_AE_UNSPEC = 0,
    XFRM_AE_RTHR = 1,
    XFRM_AE_RVAL = 2,
    XFRM_AE_LVAL = 4,
    XFRM_AE_ETHR = 8,
    XFRM_AE_CR = 16,
    XFRM_AE_CE = 32,
    XFRM_AE_CU = 64,
    __XFRM_AE_MAX = 65
} ;
struct xfrm_userpolicy_type {
   __u8 type ;
   __u16 reserved1 ;
   __u8 reserved2 ;
};
enum xfrm_attr_type_t {
    XFRMA_UNSPEC = 0,
    XFRMA_ALG_AUTH = 1,
    XFRMA_ALG_CRYPT = 2,
    XFRMA_ALG_COMP = 3,
    XFRMA_ENCAP = 4,
    XFRMA_TMPL = 5,
    XFRMA_SA = 6,
    XFRMA_POLICY = 7,
    XFRMA_SEC_CTX = 8,
    XFRMA_LTIME_VAL = 9,
    XFRMA_REPLAY_VAL = 10,
    XFRMA_REPLAY_THRESH = 11,
    XFRMA_ETIMER_THRESH = 12,
    XFRMA_SRCADDR = 13,
    XFRMA_COADDR = 14,
    XFRMA_LASTUSED = 15,
    XFRMA_POLICY_TYPE = 16,
    XFRMA_MIGRATE = 17,
    XFRMA_ALG_AEAD = 18,
    XFRMA_KMADDRESS = 19,
    __XFRMA_MAX = 20
} ;
enum xfrm_sadattr_type_t {
    XFRMA_SAD_UNSPEC = 0,
    XFRMA_SAD_CNT = 1,
    XFRMA_SAD_HINFO = 2,
    __XFRMA_SAD_MAX = 3
} ;
struct xfrmu_sadhinfo {
   __u32 sadhcnt ;
   __u32 sadhmcnt ;
};
enum xfrm_spdattr_type_t {
    XFRMA_SPD_UNSPEC = 0,
    XFRMA_SPD_INFO = 1,
    XFRMA_SPD_HINFO = 2,
    __XFRMA_SPD_MAX = 3
} ;
struct xfrmu_spdinfo {
   __u32 incnt ;
   __u32 outcnt ;
   __u32 fwdcnt ;
   __u32 inscnt ;
   __u32 outscnt ;
   __u32 fwdscnt ;
};
struct xfrmu_spdhinfo {
   __u32 spdhcnt ;
   __u32 spdhmcnt ;
};
struct xfrm_usersa_info {
   struct xfrm_selector sel ;
   struct xfrm_id id ;
   xfrm_address_t saddr ;
   struct xfrm_lifetime_cfg lft ;
   struct xfrm_lifetime_cur curlft ;
   struct xfrm_stats stats ;
   __u32 seq ;
   __u32 reqid ;
   __u16 family ;
   __u8 mode ;
   __u8 replay_window ;
   __u8 flags ;
};
struct xfrm_usersa_id {
   xfrm_address_t daddr ;
   __be32 spi ;
   __u16 family ;
   __u8 proto ;
};
struct xfrm_aevent_id {
   struct xfrm_usersa_id sa_id ;
   xfrm_address_t saddr ;
   __u32 flags ;
   __u32 reqid ;
};
struct xfrm_userspi_info {
   struct xfrm_usersa_info info ;
   __u32 min ;
   __u32 max ;
};
struct xfrm_userpolicy_info {
   struct xfrm_selector sel ;
   struct xfrm_lifetime_cfg lft ;
   struct xfrm_lifetime_cur curlft ;
   __u32 priority ;
   __u32 index ;
   __u8 dir ;
   __u8 action ;
   __u8 flags ;
   __u8 share ;
};
struct xfrm_userpolicy_id {
   struct xfrm_selector sel ;
   __u32 index ;
   __u8 dir ;
};
struct xfrm_user_acquire {
   struct xfrm_id id ;
   xfrm_address_t saddr ;
   struct xfrm_selector sel ;
   struct xfrm_userpolicy_info policy ;
   __u32 aalgos ;
   __u32 ealgos ;
   __u32 calgos ;
   __u32 seq ;
};
struct xfrm_user_expire {
   struct xfrm_usersa_info state ;
   __u8 hard ;
};
struct xfrm_user_polexpire {
   struct xfrm_userpolicy_info pol ;
   __u8 hard ;
};
struct xfrm_usersa_flush {
   __u8 proto ;
};
struct xfrm_user_report {
   __u8 proto ;
   struct xfrm_selector sel ;
};
struct xfrm_user_kmaddress {
   xfrm_address_t local ;
   xfrm_address_t remote ;
   __u32 reserved ;
   __u16 family ;
};
struct xfrm_user_migrate {
   xfrm_address_t old_daddr ;
   xfrm_address_t old_saddr ;
   xfrm_address_t new_daddr ;
   xfrm_address_t new_saddr ;
   __u8 proto ;
   __u8 mode ;
   __u16 reserved ;
   __u32 reqid ;
   __u16 old_family ;
   __u16 new_family ;
};
struct xfrm_user_mapping {
   struct xfrm_usersa_id id ;
   __u32 reqid ;
   xfrm_address_t old_saddr ;
   xfrm_address_t new_saddr ;
   __be16 old_sport ;
   __be16 new_sport ;
};
enum xfrm_nlgroups {
    XFRMNLGRP_NONE = 0,
    XFRMNLGRP_ACQUIRE = 1,
    XFRMNLGRP_EXPIRE = 2,
    XFRMNLGRP_SA = 3,
    XFRMNLGRP_POLICY = 4,
    XFRMNLGRP_AEVENTS = 5,
    XFRMNLGRP_REPORT = 6,
    XFRMNLGRP_MIGRATE = 7,
    XFRMNLGRP_MAPPING = 8,
    __XFRMNLGRP_MAX = 9
} ;
union __anonunion_in6_u_201 {
   __u8 u6_addr8[16] ;
   __be16 u6_addr16[8] ;
   __be32 u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion_in6_u_201 in6_u ;
};
struct sockaddr_in6 {
   unsigned short sin6_family ;
   __be16 sin6_port ;
   __be32 sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   __u32 sin6_scope_id ;
};
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   int ipv6mr_ifindex ;
};
struct in6_flowlabel_req {
   struct in6_addr flr_dst ;
   __be32 flr_label ;
   __u8 flr_action ;
   __u8 flr_share ;
   __u16 flr_flags ;
   __u16 flr_expires ;
   __u16 flr_linger ;
   __u32 __flr_pad ;
};
struct __anonstruct_ip4_u_203 {
   __be32 daddr ;
   __be32 saddr ;
   __u8 tos ;
   __u8 scope ;
};
struct __anonstruct_ip6_u_204 {
   struct in6_addr daddr ;
   struct in6_addr saddr ;
   __be32 flowlabel ;
};
struct __anonstruct_dn_u_205 {
   __le16 daddr ;
   __le16 saddr ;
   __u8 scope ;
};
union __anonunion_nl_u_202 {
   struct __anonstruct_ip4_u_203 ip4_u ;
   struct __anonstruct_ip6_u_204 ip6_u ;
   struct __anonstruct_dn_u_205 dn_u ;
};
struct __anonstruct_ports_207 {
   __be16 sport ;
   __be16 dport ;
};
struct __anonstruct_icmpt_208 {
   __u8 type ;
   __u8 code ;
};
struct __anonstruct_dnports_209 {
   __le16 sport ;
   __le16 dport ;
};
struct __anonstruct_mht_210 {
   __u8 type ;
};
union __anonunion_uli_u_206 {
   struct __anonstruct_ports_207 ports ;
   struct __anonstruct_icmpt_208 icmpt ;
   struct __anonstruct_dnports_209 dnports ;
   __be32 spi ;
   struct __anonstruct_mht_210 mht ;
};
struct flowi {
   int oif ;
   int iif ;
   __u32 mark ;
   union __anonunion_nl_u_202 nl_u ;
   __u8 proto ;
   __u8 flags ;
   union __anonunion_uli_u_206 uli_u ;
   __u32 secid ;
} __attribute__((__aligned__((32) /  (8) ))) ;
struct net;
struct sock;
typedef int (*flow_resolve_t)(struct net *net , struct flowi *key , u16 family , u8 dir ,
                              void **objp , atomic_t **obj_refp );
struct audit_krule;
struct msghdr;
struct sk_buff;
struct sockaddr;
struct socket;
struct dst_entry;
struct xfrm_policy;
struct xfrm_state;
struct request_sock;
struct security_mnt_opts {
   char **mnt_opts ;
   int *mnt_opts_flags ;
   int num_mnt_opts ;
};
struct security_operations {
   char name[11] ;
   int (*ptrace_may_access)(struct task_struct *child , unsigned int mode ) ;
   int (*ptrace_traceme)(struct task_struct *parent ) ;
   int (*capget)(struct task_struct *target , kernel_cap_t *effective , kernel_cap_t *inheritable ,
                 kernel_cap_t *permitted ) ;
   int (*capset)(struct cred *new , struct cred  const  *old , kernel_cap_t const   *effective ,
                 kernel_cap_t const   *inheritable , kernel_cap_t const   *permitted ) ;
   int (*capable)(struct task_struct *tsk , struct cred  const  *cred , int cap ,
                  int audit ) ;
   int (*acct)(struct file *file ) ;
   int (*sysctl)(struct ctl_table *table , int op ) ;
   int (*quotactl)(int cmds , int type , int id , struct super_block *sb ) ;
   int (*quota_on)(struct dentry *dentry ) ;
   int (*syslog)(int type ) ;
   int (*settime)(struct timespec *ts , struct timezone *tz ) ;
   int (*vm_enough_memory)(struct mm_struct *mm , long pages ) ;
   int (*bprm_set_creds)(struct linux_binprm *bprm ) ;
   int (*bprm_check_security)(struct linux_binprm *bprm ) ;
   int (*bprm_secureexec)(struct linux_binprm *bprm ) ;
   void (*bprm_committing_creds)(struct linux_binprm *bprm ) ;
   void (*bprm_committed_creds)(struct linux_binprm *bprm ) ;
   int (*sb_alloc_security)(struct super_block *sb ) ;
   void (*sb_free_security)(struct super_block *sb ) ;
   int (*sb_copy_data)(char *orig , char *copy ) ;
   int (*sb_kern_mount)(struct super_block *sb , int flags , void *data ) ;
   int (*sb_show_options)(struct seq_file *m , struct super_block *sb ) ;
   int (*sb_statfs)(struct dentry *dentry ) ;
   int (*sb_mount)(char *dev_name , struct path *path , char *type , unsigned long flags ,
                   void *data ) ;
   int (*sb_check_sb)(struct vfsmount *mnt , struct path *path ) ;
   int (*sb_umount)(struct vfsmount *mnt , int flags ) ;
   void (*sb_umount_close)(struct vfsmount *mnt ) ;
   void (*sb_umount_busy)(struct vfsmount *mnt ) ;
   void (*sb_post_remount)(struct vfsmount *mnt , unsigned long flags , void *data ) ;
   void (*sb_post_addmount)(struct vfsmount *mnt , struct path *mountpoint ) ;
   int (*sb_pivotroot)(struct path *old_path , struct path *new_path ) ;
   void (*sb_post_pivotroot)(struct path *old_path , struct path *new_path ) ;
   int (*sb_set_mnt_opts)(struct super_block *sb , struct security_mnt_opts *opts ) ;
   void (*sb_clone_mnt_opts)(struct super_block  const  *oldsb , struct super_block *newsb ) ;
   int (*sb_parse_opts_str)(char *options , struct security_mnt_opts *opts ) ;
   int (*inode_alloc_security)(struct inode *inode ) ;
   void (*inode_free_security)(struct inode *inode ) ;
   int (*inode_init_security)(struct inode *inode , struct inode *dir , char **name ,
                              void **value , size_t *len ) ;
   int (*inode_create)(struct inode *dir , struct dentry *dentry , int mode ) ;
   int (*inode_link)(struct dentry *old_dentry , struct inode *dir , struct dentry *new_dentry ) ;
   int (*inode_unlink)(struct inode *dir , struct dentry *dentry ) ;
   int (*inode_symlink)(struct inode *dir , struct dentry *dentry , char const   *old_name ) ;
   int (*inode_mkdir)(struct inode *dir , struct dentry *dentry , int mode ) ;
   int (*inode_rmdir)(struct inode *dir , struct dentry *dentry ) ;
   int (*inode_mknod)(struct inode *dir , struct dentry *dentry , int mode , dev_t dev ) ;
   int (*inode_rename)(struct inode *old_dir , struct dentry *old_dentry , struct inode *new_dir ,
                       struct dentry *new_dentry ) ;
   int (*inode_readlink)(struct dentry *dentry ) ;
   int (*inode_follow_link)(struct dentry *dentry , struct nameidata *nd ) ;
   int (*inode_permission)(struct inode *inode , int mask ) ;
   int (*inode_setattr)(struct dentry *dentry , struct iattr *attr ) ;
   int (*inode_getattr)(struct vfsmount *mnt , struct dentry *dentry ) ;
   void (*inode_delete)(struct inode *inode ) ;
   int (*inode_setxattr)(struct dentry *dentry , char const   *name , void const   *value ,
                         size_t size , int flags ) ;
   void (*inode_post_setxattr)(struct dentry *dentry , char const   *name , void const   *value ,
                               size_t size , int flags ) ;
   int (*inode_getxattr)(struct dentry *dentry , char const   *name ) ;
   int (*inode_listxattr)(struct dentry *dentry ) ;
   int (*inode_removexattr)(struct dentry *dentry , char const   *name ) ;
   int (*inode_need_killpriv)(struct dentry *dentry ) ;
   int (*inode_killpriv)(struct dentry *dentry ) ;
   int (*inode_getsecurity)(struct inode  const  *inode , char const   *name , void **buffer ,
                            bool alloc ) ;
   int (*inode_setsecurity)(struct inode *inode , char const   *name , void const   *value ,
                            size_t size , int flags ) ;
   int (*inode_listsecurity)(struct inode *inode , char *buffer , size_t buffer_size ) ;
   void (*inode_getsecid)(struct inode  const  *inode , u32 *secid ) ;
   int (*file_permission)(struct file *file , int mask ) ;
   int (*file_alloc_security)(struct file *file ) ;
   void (*file_free_security)(struct file *file ) ;
   int (*file_ioctl)(struct file *file , unsigned int cmd , unsigned long arg ) ;
   int (*file_mmap)(struct file *file , unsigned long reqprot , unsigned long prot ,
                    unsigned long flags , unsigned long addr , unsigned long addr_only ) ;
   int (*file_mprotect)(struct vm_area_struct *vma , unsigned long reqprot , unsigned long prot ) ;
   int (*file_lock)(struct file *file , unsigned int cmd ) ;
   int (*file_fcntl)(struct file *file , unsigned int cmd , unsigned long arg ) ;
   int (*file_set_fowner)(struct file *file ) ;
   int (*file_send_sigiotask)(struct task_struct *tsk , struct fown_struct *fown ,
                              int sig ) ;
   int (*file_receive)(struct file *file ) ;
   int (*dentry_open)(struct file *file , struct cred  const  *cred ) ;
   int (*task_create)(unsigned long clone_flags ) ;
   void (*cred_free)(struct cred *cred ) ;
   int (*cred_prepare)(struct cred *new , struct cred  const  *old , gfp_t gfp ) ;
   void (*cred_commit)(struct cred *new , struct cred  const  *old ) ;
   int (*kernel_act_as)(struct cred *new , u32 secid ) ;
   int (*kernel_create_files_as)(struct cred *new , struct inode *inode ) ;
   int (*task_setuid)(uid_t id0 , uid_t id1 , uid_t id2 , int flags ) ;
   int (*task_fix_setuid)(struct cred *new , struct cred  const  *old , int flags ) ;
   int (*task_setgid)(gid_t id0 , gid_t id1 , gid_t id2 , int flags ) ;
   int (*task_setpgid)(struct task_struct *p , pid_t pgid ) ;
   int (*task_getpgid)(struct task_struct *p ) ;
   int (*task_getsid)(struct task_struct *p ) ;
   void (*task_getsecid)(struct task_struct *p , u32 *secid ) ;
   int (*task_setgroups)(struct group_info *group_info ) ;
   int (*task_setnice)(struct task_struct *p , int nice ) ;
   int (*task_setioprio)(struct task_struct *p , int ioprio ) ;
   int (*task_getioprio)(struct task_struct *p ) ;
   int (*task_setrlimit)(unsigned int resource , struct rlimit *new_rlim ) ;
   int (*task_setscheduler)(struct task_struct *p , int policy , struct sched_param *lp ) ;
   int (*task_getscheduler)(struct task_struct *p ) ;
   int (*task_movememory)(struct task_struct *p ) ;
   int (*task_kill)(struct task_struct *p , struct siginfo *info , int sig , u32 secid ) ;
   int (*task_wait)(struct task_struct *p ) ;
   int (*task_prctl)(int option , unsigned long arg2 , unsigned long arg3 , unsigned long arg4 ,
                     unsigned long arg5 ) ;
   void (*task_to_inode)(struct task_struct *p , struct inode *inode ) ;
   int (*ipc_permission)(struct kern_ipc_perm *ipcp , short flag ) ;
   void (*ipc_getsecid)(struct kern_ipc_perm *ipcp , u32 *secid ) ;
   int (*msg_msg_alloc_security)(struct msg_msg *msg ) ;
   void (*msg_msg_free_security)(struct msg_msg *msg ) ;
   int (*msg_queue_alloc_security)(struct msg_queue *msq ) ;
   void (*msg_queue_free_security)(struct msg_queue *msq ) ;
   int (*msg_queue_associate)(struct msg_queue *msq , int msqflg ) ;
   int (*msg_queue_msgctl)(struct msg_queue *msq , int cmd ) ;
   int (*msg_queue_msgsnd)(struct msg_queue *msq , struct msg_msg *msg , int msqflg ) ;
   int (*msg_queue_msgrcv)(struct msg_queue *msq , struct msg_msg *msg , struct task_struct *target ,
                           long type , int mode ) ;
   int (*shm_alloc_security)(struct shmid_kernel *shp ) ;
   void (*shm_free_security)(struct shmid_kernel *shp ) ;
   int (*shm_associate)(struct shmid_kernel *shp , int shmflg ) ;
   int (*shm_shmctl)(struct shmid_kernel *shp , int cmd ) ;
   int (*shm_shmat)(struct shmid_kernel *shp , char *shmaddr , int shmflg ) ;
   int (*sem_alloc_security)(struct sem_array *sma ) ;
   void (*sem_free_security)(struct sem_array *sma ) ;
   int (*sem_associate)(struct sem_array *sma , int semflg ) ;
   int (*sem_semctl)(struct sem_array *sma , int cmd ) ;
   int (*sem_semop)(struct sem_array *sma , struct sembuf *sops , unsigned int nsops ,
                    int alter ) ;
   int (*netlink_send)(struct sock *sk , struct sk_buff *skb ) ;
   int (*netlink_recv)(struct sk_buff *skb , int cap ) ;
   void (*d_instantiate)(struct dentry *dentry , struct inode *inode ) ;
   int (*getprocattr)(struct task_struct *p , char *name , char **value ) ;
   int (*setprocattr)(struct task_struct *p , char *name , void *value , size_t size ) ;
   int (*secid_to_secctx)(u32 secid , char **secdata , u32 *seclen ) ;
   int (*secctx_to_secid)(char const   *secdata , u32 seclen , u32 *secid ) ;
   void (*release_secctx)(char *secdata , u32 seclen ) ;
   int (*unix_stream_connect)(struct socket *sock , struct socket *other , struct sock *newsk ) ;
   int (*unix_may_send)(struct socket *sock , struct socket *other ) ;
   int (*socket_create)(int family , int type , int protocol , int kern ) ;
   int (*socket_post_create)(struct socket *sock , int family , int type , int protocol ,
                             int kern ) ;
   int (*socket_bind)(struct socket *sock , struct sockaddr *address , int addrlen ) ;
   int (*socket_connect)(struct socket *sock , struct sockaddr *address , int addrlen ) ;
   int (*socket_listen)(struct socket *sock , int backlog ) ;
   int (*socket_accept)(struct socket *sock , struct socket *newsock ) ;
   int (*socket_sendmsg)(struct socket *sock , struct msghdr *msg , int size ) ;
   int (*socket_recvmsg)(struct socket *sock , struct msghdr *msg , int size , int flags ) ;
   int (*socket_getsockname)(struct socket *sock ) ;
   int (*socket_getpeername)(struct socket *sock ) ;
   int (*socket_getsockopt)(struct socket *sock , int level , int optname ) ;
   int (*socket_setsockopt)(struct socket *sock , int level , int optname ) ;
   int (*socket_shutdown)(struct socket *sock , int how ) ;
   int (*socket_sock_rcv_skb)(struct sock *sk , struct sk_buff *skb ) ;
   int (*socket_getpeersec_stream)(struct socket *sock , char *optval , int *optlen ,
                                   unsigned int len ) ;
   int (*socket_getpeersec_dgram)(struct socket *sock , struct sk_buff *skb , u32 *secid ) ;
   int (*sk_alloc_security)(struct sock *sk , int family , gfp_t priority ) ;
   void (*sk_free_security)(struct sock *sk ) ;
   void (*sk_clone_security)(struct sock  const  *sk , struct sock *newsk ) ;
   void (*sk_getsecid)(struct sock *sk , u32 *secid ) ;
   void (*sock_graft)(struct sock *sk , struct socket *parent ) ;
   int (*inet_conn_request)(struct sock *sk , struct sk_buff *skb , struct request_sock *req ) ;
   void (*inet_csk_clone)(struct sock *newsk , struct request_sock  const  *req ) ;
   void (*inet_conn_established)(struct sock *sk , struct sk_buff *skb ) ;
   void (*req_classify_flow)(struct request_sock  const  *req , struct flowi *fl ) ;
   int (*key_alloc)(struct key *key , struct cred  const  *cred , unsigned long flags ) ;
   void (*key_free)(struct key *key ) ;
   int (*key_permission)(key_ref_t key_ref , struct cred  const  *cred , key_perm_t perm ) ;
   int (*key_getsecurity)(struct key *key , char **_buffer ) ;
   int (*audit_rule_init)(u32 field , u32 op , char *rulestr , void **lsmrule ) ;
   int (*audit_rule_known)(struct audit_krule *krule ) ;
   int (*audit_rule_match)(u32 secid , u32 field , u32 op , void *lsmrule , struct audit_context *actx ) ;
   void (*audit_rule_free)(void *lsmrule ) ;
};
struct dev_state {
   struct list_head list ;
   struct usb_device *dev ;
   struct file *file ;
   spinlock_t lock ;
   struct list_head async_pending ;
   struct list_head async_completed ;
   wait_queue_head_t wait ;
   unsigned int discsignr ;
   struct pid *disc_pid ;
   uid_t disc_uid ;
   uid_t disc_euid ;
   void *disccontext ;
   unsigned long ifclaimed ;
   u32 secid ;
};
struct async {
   struct list_head asynclist ;
   struct dev_state *ps ;
   struct pid *pid ;
   uid_t uid ;
   uid_t euid ;
   unsigned int signr ;
   unsigned int ifnum ;
   void *userbuffer ;
   void *userurb ;
   struct urb *urb ;
   int status ;
   u32 secid ;
};
enum __anonenum_4___3 {
    false___3 = 0,
    true___3 = 1
} ;
enum __anonenum_10___2 {
    DUMP_PREFIX_NONE___3 = 0,
    DUMP_PREFIX_ADDRESS___3 = 1,
    DUMP_PREFIX_OFFSET___3 = 2
} ;
enum __anonenum_15___2 {
    PG_LEVEL_NONE___3 = 0,
    PG_LEVEL_4K___3 = 1,
    PG_LEVEL_2M___3 = 2,
    PG_LEVEL_1G___3 = 3,
    PG_LEVEL_NUM___3 = 4
} ;
enum __anonenum_19___2 {
    GATE_INTERRUPT___3 = 14,
    GATE_TRAP___3 = 15,
    GATE_CALL___3 = 12,
    GATE_TASK___3 = 5
} ;
enum __anonenum_20___2 {
    DESC_TSS___3 = 9,
    DESC_LDT___3 = 2,
    DESCTYPE_S___3 = 16
} ;
enum __anonenum_21___3 {
    ADDR_NO_RANDOMIZE___3 = 262144,
    FDPIC_FUNCPTRS___3 = 524288,
    MMAP_PAGE_ZERO___3 = 1048576,
    ADDR_COMPAT_LAYOUT___3 = 2097152,
    READ_IMPLIES_EXEC___3 = 4194304,
    ADDR_LIMIT_32BIT___3 = 8388608,
    SHORT_INODE___3 = 16777216,
    WHOLE_SECONDS___3 = 33554432,
    STICKY_TIMEOUTS___3 = 67108864,
    ADDR_LIMIT_3GB___3 = 134217728
} ;
enum __anonenum_22___2 {
    PER_LINUX___3 = 0,
    PER_LINUX_32BIT___3 = 8388608,
    PER_LINUX_FDPIC___3 = 524288,
    PER_SVR4___3 = 68157441,
    PER_SVR3___3 = 83886082,
    PER_SCOSVR3___3 = 117440515,
    PER_OSR5___3 = 100663299,
    PER_WYSEV386___3 = 83886084,
    PER_ISCR4___3 = 67108869,
    PER_BSD___3 = 6,
    PER_SUNOS___3 = 67108870,
    PER_XENIX___3 = 83886087,
    PER_LINUX32___3 = 8,
    PER_LINUX32_3GB___3 = 134217736,
    PER_IRIX32___3 = 67108873,
    PER_IRIXN32___3 = 67108874,
    PER_IRIX64___3 = 67108875,
    PER_RISCOS___3 = 12,
    PER_SOLARIS___3 = 67108877,
    PER_UW7___3 = 68157454,
    PER_OSF4___3 = 15,
    PER_HPUX___3 = 16,
    PER_MASK___3 = 255
} ;
union __anonunion_d_37___0 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_120___1 {
    CTL_KERN___3 = 1,
    CTL_VM___3 = 2,
    CTL_NET___3 = 3,
    CTL_PROC___3 = 4,
    CTL_FS___3 = 5,
    CTL_DEBUG___3 = 6,
    CTL_DEV___3 = 7,
    CTL_BUS___3 = 8,
    CTL_ABI___3 = 9,
    CTL_CPU___3 = 10,
    CTL_ARLAN___3 = 254,
    CTL_S390DBF___3 = 5677,
    CTL_SUNRPC___3 = 7249,
    CTL_PM___3 = 9899,
    CTL_FRV___3 = 9898
} ;
enum __anonenum_121___1 {
    CTL_BUS_ISA___3 = 1
} ;
enum __anonenum_122___1 {
    INOTIFY_MAX_USER_INSTANCES___3 = 1,
    INOTIFY_MAX_USER_WATCHES___3 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___3 = 3
} ;
enum __anonenum_123___1 {
    KERN_OSTYPE___3 = 1,
    KERN_OSRELEASE___3 = 2,
    KERN_OSREV___3 = 3,
    KERN_VERSION___3 = 4,
    KERN_SECUREMASK___3 = 5,
    KERN_PROF___3 = 6,
    KERN_NODENAME___3 = 7,
    KERN_DOMAINNAME___3 = 8,
    KERN_PANIC___3 = 15,
    KERN_REALROOTDEV___3 = 16,
    KERN_SPARC_REBOOT___3 = 21,
    KERN_CTLALTDEL___3 = 22,
    KERN_PRINTK___3 = 23,
    KERN_NAMETRANS___3 = 24,
    KERN_PPC_HTABRECLAIM___3 = 25,
    KERN_PPC_ZEROPAGED___3 = 26,
    KERN_PPC_POWERSAVE_NAP___3 = 27,
    KERN_MODPROBE___3 = 28,
    KERN_SG_BIG_BUFF___3 = 29,
    KERN_ACCT___3 = 30,
    KERN_PPC_L2CR___3 = 31,
    KERN_RTSIGNR___3 = 32,
    KERN_RTSIGMAX___3 = 33,
    KERN_SHMMAX___3 = 34,
    KERN_MSGMAX___3 = 35,
    KERN_MSGMNB___3 = 36,
    KERN_MSGPOOL___3 = 37,
    KERN_SYSRQ___3 = 38,
    KERN_MAX_THREADS___3 = 39,
    KERN_RANDOM___3 = 40,
    KERN_SHMALL___3 = 41,
    KERN_MSGMNI___3 = 42,
    KERN_SEM___3 = 43,
    KERN_SPARC_STOP_A___3 = 44,
    KERN_SHMMNI___3 = 45,
    KERN_OVERFLOWUID___3 = 46,
    KERN_OVERFLOWGID___3 = 47,
    KERN_SHMPATH___3 = 48,
    KERN_HOTPLUG___3 = 49,
    KERN_IEEE_EMULATION_WARNINGS___3 = 50,
    KERN_S390_USER_DEBUG_LOGGING___3 = 51,
    KERN_CORE_USES_PID___3 = 52,
    KERN_TAINTED___3 = 53,
    KERN_CADPID___3 = 54,
    KERN_PIDMAX___3 = 55,
    KERN_CORE_PATTERN___3 = 56,
    KERN_PANIC_ON_OOPS___3 = 57,
    KERN_HPPA_PWRSW___3 = 58,
    KERN_HPPA_UNALIGNED___3 = 59,
    KERN_PRINTK_RATELIMIT___3 = 60,
    KERN_PRINTK_RATELIMIT_BURST___3 = 61,
    KERN_PTY___3 = 62,
    KERN_NGROUPS_MAX___3 = 63,
    KERN_SPARC_SCONS_PWROFF___3 = 64,
    KERN_HZ_TIMER___3 = 65,
    KERN_UNKNOWN_NMI_PANIC___3 = 66,
    KERN_BOOTLOADER_TYPE___3 = 67,
    KERN_RANDOMIZE___3 = 68,
    KERN_SETUID_DUMPABLE___3 = 69,
    KERN_SPIN_RETRY___3 = 70,
    KERN_ACPI_VIDEO_FLAGS___3 = 71,
    KERN_IA64_UNALIGNED___3 = 72,
    KERN_COMPAT_LOG___3 = 73,
    KERN_MAX_LOCK_DEPTH___3 = 74,
    KERN_NMI_WATCHDOG___3 = 75,
    KERN_PANIC_ON_NMI___3 = 76
} ;
enum __anonenum_124___1 {
    VM_UNUSED1___3 = 1,
    VM_UNUSED2___3 = 2,
    VM_UNUSED3___3 = 3,
    VM_UNUSED4___3 = 4,
    VM_OVERCOMMIT_MEMORY___3 = 5,
    VM_UNUSED5___3 = 6,
    VM_UNUSED7___3 = 7,
    VM_UNUSED8___3 = 8,
    VM_UNUSED9___3 = 9,
    VM_PAGE_CLUSTER___3 = 10,
    VM_DIRTY_BACKGROUND___3 = 11,
    VM_DIRTY_RATIO___3 = 12,
    VM_DIRTY_WB_CS___3 = 13,
    VM_DIRTY_EXPIRE_CS___3 = 14,
    VM_NR_PDFLUSH_THREADS___3 = 15,
    VM_OVERCOMMIT_RATIO___3 = 16,
    VM_PAGEBUF___3 = 17,
    VM_HUGETLB_PAGES___3 = 18,
    VM_SWAPPINESS___3 = 19,
    VM_LOWMEM_RESERVE_RATIO___3 = 20,
    VM_MIN_FREE_KBYTES___3 = 21,
    VM_MAX_MAP_COUNT___3 = 22,
    VM_LAPTOP_MODE___3 = 23,
    VM_BLOCK_DUMP___3 = 24,
    VM_HUGETLB_GROUP___3 = 25,
    VM_VFS_CACHE_PRESSURE___3 = 26,
    VM_LEGACY_VA_LAYOUT___3 = 27,
    VM_SWAP_TOKEN_TIMEOUT___3 = 28,
    VM_DROP_PAGECACHE___3 = 29,
    VM_PERCPU_PAGELIST_FRACTION___3 = 30,
    VM_ZONE_RECLAIM_MODE___3 = 31,
    VM_MIN_UNMAPPED___3 = 32,
    VM_PANIC_ON_OOM___3 = 33,
    VM_VDSO_ENABLED___3 = 34,
    VM_MIN_SLAB___3 = 35
} ;
enum __anonenum_125___3 {
    NET_CORE___3 = 1,
    NET_ETHER___3 = 2,
    NET_802___3 = 3,
    NET_UNIX___3 = 4,
    NET_IPV4___3 = 5,
    NET_IPX___3 = 6,
    NET_ATALK___3 = 7,
    NET_NETROM___3 = 8,
    NET_AX25___3 = 9,
    NET_BRIDGE___3 = 10,
    NET_ROSE___3 = 11,
    NET_IPV6___3 = 12,
    NET_X25___3 = 13,
    NET_TR___3 = 14,
    NET_DECNET___3 = 15,
    NET_ECONET___3 = 16,
    NET_SCTP___3 = 17,
    NET_LLC___3 = 18,
    NET_NETFILTER___3 = 19,
    NET_DCCP___3 = 20,
    NET_IRDA___3 = 412
} ;
enum __anonenum_126___3 {
    RANDOM_POOLSIZE___3 = 1,
    RANDOM_ENTROPY_COUNT___3 = 2,
    RANDOM_READ_THRESH___3 = 3,
    RANDOM_WRITE_THRESH___3 = 4,
    RANDOM_BOOT_ID___3 = 5,
    RANDOM_UUID___3 = 6
} ;
enum __anonenum_127___3 {
    PTY_MAX___3 = 1,
    PTY_NR___3 = 2
} ;
enum __anonenum_128___3 {
    BUS_ISA_MEM_BASE___3 = 1,
    BUS_ISA_PORT_BASE___3 = 2,
    BUS_ISA_PORT_SHIFT___3 = 3
} ;
enum __anonenum_129___3 {
    NET_CORE_WMEM_MAX___3 = 1,
    NET_CORE_RMEM_MAX___3 = 2,
    NET_CORE_WMEM_DEFAULT___3 = 3,
    NET_CORE_RMEM_DEFAULT___3 = 4,
    NET_CORE_MAX_BACKLOG___3 = 6,
    NET_CORE_FASTROUTE___3 = 7,
    NET_CORE_MSG_COST___3 = 8,
    NET_CORE_MSG_BURST___3 = 9,
    NET_CORE_OPTMEM_MAX___3 = 10,
    NET_CORE_HOT_LIST_LENGTH___3 = 11,
    NET_CORE_DIVERT_VERSION___3 = 12,
    NET_CORE_NO_CONG_THRESH___3 = 13,
    NET_CORE_NO_CONG___3 = 14,
    NET_CORE_LO_CONG___3 = 15,
    NET_CORE_MOD_CONG___3 = 16,
    NET_CORE_DEV_WEIGHT___3 = 17,
    NET_CORE_SOMAXCONN___3 = 18,
    NET_CORE_BUDGET___3 = 19,
    NET_CORE_AEVENT_ETIME___3 = 20,
    NET_CORE_AEVENT_RSEQTH___3 = 21,
    NET_CORE_WARNINGS___3 = 22
} ;
enum __anonenum_130___3 {
    NET_UNIX_DESTROY_DELAY___3 = 1,
    NET_UNIX_DELETE_DELAY___3 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___3 = 3
} ;
enum __anonenum_131___3 {
    NET_NF_CONNTRACK_MAX___3 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___3 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___3 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___3 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___3 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___3 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___3 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___3 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___3 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___3 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___3 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___3 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___3 = 13,
    NET_NF_CONNTRACK_BUCKETS___3 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___3 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___3 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___3 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___3 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___3 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___3 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___3 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___3 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___3 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___3 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___3 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___3 = 26,
    NET_NF_CONNTRACK_COUNT___3 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___3 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___3 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___3 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___3 = 31,
    NET_NF_CONNTRACK_CHECKSUM___3 = 32
} ;
enum __anonenum_132___3 {
    NET_IPV4_FORWARD___3 = 8,
    NET_IPV4_DYNADDR___3 = 9,
    NET_IPV4_CONF___3 = 16,
    NET_IPV4_NEIGH___3 = 17,
    NET_IPV4_ROUTE___3 = 18,
    NET_IPV4_FIB_HASH___3 = 19,
    NET_IPV4_NETFILTER___3 = 20,
    NET_IPV4_TCP_TIMESTAMPS___3 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___3 = 34,
    NET_IPV4_TCP_SACK___3 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___3 = 36,
    NET_IPV4_DEFAULT_TTL___3 = 37,
    NET_IPV4_AUTOCONFIG___3 = 38,
    NET_IPV4_NO_PMTU_DISC___3 = 39,
    NET_IPV4_TCP_SYN_RETRIES___3 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___3 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___3 = 42,
    NET_IPV4_IPFRAG_TIME___3 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___3 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___3 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___3 = 46,
    NET_IPV4_TCP_RETRIES1___3 = 47,
    NET_IPV4_TCP_RETRIES2___3 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___3 = 49,
    NET_IPV4_IP_MASQ_DEBUG___3 = 50,
    NET_TCP_SYNCOOKIES___3 = 51,
    NET_TCP_STDURG___3 = 52,
    NET_TCP_RFC1337___3 = 53,
    NET_TCP_SYN_TAILDROP___3 = 54,
    NET_TCP_MAX_SYN_BACKLOG___3 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___3 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___3 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___3 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___3 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___3 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___3 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___3 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___3 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___3 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___3 = 65,
    NET_TCP_TW_RECYCLE___3 = 66,
    NET_IPV4_ALWAYS_DEFRAG___3 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___3 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___3 = 69,
    NET_IPV4_INET_PEER_MINTTL___3 = 70,
    NET_IPV4_INET_PEER_MAXTTL___3 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___3 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___3 = 73,
    NET_TCP_ORPHAN_RETRIES___3 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___3 = 75,
    NET_TCP_SYNACK_RETRIES___3 = 76,
    NET_TCP_MAX_ORPHANS___3 = 77,
    NET_TCP_MAX_TW_BUCKETS___3 = 78,
    NET_TCP_FACK___3 = 79,
    NET_TCP_REORDERING___3 = 80,
    NET_TCP_ECN___3 = 81,
    NET_TCP_DSACK___3 = 82,
    NET_TCP_MEM___3 = 83,
    NET_TCP_WMEM___3 = 84,
    NET_TCP_RMEM___3 = 85,
    NET_TCP_APP_WIN___3 = 86,
    NET_TCP_ADV_WIN_SCALE___3 = 87,
    NET_IPV4_NONLOCAL_BIND___3 = 88,
    NET_IPV4_ICMP_RATELIMIT___3 = 89,
    NET_IPV4_ICMP_RATEMASK___3 = 90,
    NET_TCP_TW_REUSE___3 = 91,
    NET_TCP_FRTO___3 = 92,
    NET_TCP_LOW_LATENCY___3 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___3 = 94,
    NET_IPV4_IGMP_MAX_MSF___3 = 96,
    NET_TCP_NO_METRICS_SAVE___3 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___3 = 105,
    NET_TCP_MODERATE_RCVBUF___3 = 106,
    NET_TCP_TSO_WIN_DIVISOR___3 = 107,
    NET_TCP_BIC_BETA___3 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___3 = 109,
    NET_TCP_CONG_CONTROL___3 = 110,
    NET_TCP_ABC___3 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___3 = 112,
    NET_TCP_MTU_PROBING___3 = 113,
    NET_TCP_BASE_MSS___3 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___3 = 115,
    NET_TCP_DMA_COPYBREAK___3 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___3 = 117,
    NET_CIPSOV4_CACHE_ENABLE___3 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___3 = 119,
    NET_CIPSOV4_RBM_OPTFMT___3 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___3 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___3 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___3 = 123,
    NET_TCP_MAX_SSTHRESH___3 = 124,
    NET_TCP_FRTO_RESPONSE___3 = 125
} ;
enum __anonenum_133___3 {
    NET_IPV4_ROUTE_FLUSH___3 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___3 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___3 = 3,
    NET_IPV4_ROUTE_GC_THRESH___3 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___3 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___3 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___3 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___3 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___3 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___3 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___3 = 11,
    NET_IPV4_ROUTE_ERROR_COST___3 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___3 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___3 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___3 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___3 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___3 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___3 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___3 = 19
} ;
enum __anonenum_134___3 {
    NET_PROTO_CONF_ALL___3 = -2,
    NET_PROTO_CONF_DEFAULT___3 = -3
} ;
enum __anonenum_135___3 {
    NET_IPV4_CONF_FORWARDING___3 = 1,
    NET_IPV4_CONF_MC_FORWARDING___3 = 2,
    NET_IPV4_CONF_PROXY_ARP___3 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___3 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___3 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___3 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___3 = 7,
    NET_IPV4_CONF_RP_FILTER___3 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___3 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___3 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___3 = 11,
    NET_IPV4_CONF_TAG___3 = 12,
    NET_IPV4_CONF_ARPFILTER___3 = 13,
    NET_IPV4_CONF_MEDIUM_ID___3 = 14,
    NET_IPV4_CONF_NOXFRM___3 = 15,
    NET_IPV4_CONF_NOPOLICY___3 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___3 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___3 = 18,
    NET_IPV4_CONF_ARP_IGNORE___3 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___3 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___3 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___3 = 22,
    __NET_IPV4_CONF_MAX___3 = 23
} ;
enum __anonenum_136___3 {
    NET_IPV4_NF_CONNTRACK_MAX___3 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___3 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___3 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___3 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___3 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___3 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___3 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___3 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___3 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___3 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___3 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___3 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___3 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___3 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___3 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___3 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___3 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___3 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___3 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___3 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___3 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___3 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___3 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___3 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___3 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___3 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___3 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___3 = 28
} ;
enum __anonenum_137___3 {
    NET_IPV6_CONF___3 = 16,
    NET_IPV6_NEIGH___3 = 17,
    NET_IPV6_ROUTE___3 = 18,
    NET_IPV6_ICMP___3 = 19,
    NET_IPV6_BINDV6ONLY___3 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___3 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___3 = 22,
    NET_IPV6_IP6FRAG_TIME___3 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___3 = 24,
    NET_IPV6_MLD_MAX_MSF___3 = 25
} ;
enum __anonenum_138___3 {
    NET_IPV6_ROUTE_FLUSH___3 = 1,
    NET_IPV6_ROUTE_GC_THRESH___3 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___3 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___3 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___3 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___3 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___3 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___3 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___3 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___3 = 10
} ;
enum __anonenum_139___3 {
    NET_IPV6_FORWARDING___3 = 1,
    NET_IPV6_HOP_LIMIT___3 = 2,
    NET_IPV6_MTU___3 = 3,
    NET_IPV6_ACCEPT_RA___3 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___3 = 5,
    NET_IPV6_AUTOCONF___3 = 6,
    NET_IPV6_DAD_TRANSMITS___3 = 7,
    NET_IPV6_RTR_SOLICITS___3 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___3 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___3 = 10,
    NET_IPV6_USE_TEMPADDR___3 = 11,
    NET_IPV6_TEMP_VALID_LFT___3 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___3 = 13,
    NET_IPV6_REGEN_MAX_RETRY___3 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___3 = 15,
    NET_IPV6_MAX_ADDRESSES___3 = 16,
    NET_IPV6_FORCE_MLD_VERSION___3 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___3 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___3 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___3 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___3 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___3 = 22,
    NET_IPV6_PROXY_NDP___3 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___3 = 25,
    __NET_IPV6_MAX___3 = 26
} ;
enum __anonenum_140___3 {
    NET_IPV6_ICMP_RATELIMIT___3 = 1
} ;
enum __anonenum_141___3 {
    NET_NEIGH_MCAST_SOLICIT___3 = 1,
    NET_NEIGH_UCAST_SOLICIT___3 = 2,
    NET_NEIGH_APP_SOLICIT___3 = 3,
    NET_NEIGH_RETRANS_TIME___3 = 4,
    NET_NEIGH_REACHABLE_TIME___3 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___3 = 6,
    NET_NEIGH_GC_STALE_TIME___3 = 7,
    NET_NEIGH_UNRES_QLEN___3 = 8,
    NET_NEIGH_PROXY_QLEN___3 = 9,
    NET_NEIGH_ANYCAST_DELAY___3 = 10,
    NET_NEIGH_PROXY_DELAY___3 = 11,
    NET_NEIGH_LOCKTIME___3 = 12,
    NET_NEIGH_GC_INTERVAL___3 = 13,
    NET_NEIGH_GC_THRESH1___3 = 14,
    NET_NEIGH_GC_THRESH2___3 = 15,
    NET_NEIGH_GC_THRESH3___3 = 16,
    NET_NEIGH_RETRANS_TIME_MS___3 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___3 = 18,
    __NET_NEIGH_MAX___3 = 19
} ;
enum __anonenum_142___3 {
    NET_DCCP_DEFAULT___3 = 1
} ;
enum __anonenum_143___3 {
    NET_IPX_PPROP_BROADCASTING___3 = 1,
    NET_IPX_FORWARDING___3 = 2
} ;
enum __anonenum_144___3 {
    NET_LLC2___3 = 1,
    NET_LLC_STATION___3 = 2
} ;
enum __anonenum_145___3 {
    NET_LLC2_TIMEOUT___3 = 1
} ;
enum __anonenum_146___3 {
    NET_LLC_STATION_ACK_TIMEOUT___3 = 1
} ;
enum __anonenum_147___3 {
    NET_LLC2_ACK_TIMEOUT___3 = 1,
    NET_LLC2_P_TIMEOUT___3 = 2,
    NET_LLC2_REJ_TIMEOUT___3 = 3,
    NET_LLC2_BUSY_TIMEOUT___3 = 4
} ;
enum __anonenum_148___3 {
    NET_ATALK_AARP_EXPIRY_TIME___3 = 1,
    NET_ATALK_AARP_TICK_TIME___3 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___3 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___3 = 4
} ;
enum __anonenum_149___3 {
    NET_NETROM_DEFAULT_PATH_QUALITY___3 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___3 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___3 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___3 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___3 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___3 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___3 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___3 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___3 = 9,
    NET_NETROM_ROUTING_CONTROL___3 = 10,
    NET_NETROM_LINK_FAILS_COUNT___3 = 11,
    NET_NETROM_RESET___3 = 12
} ;
enum __anonenum_150___3 {
    NET_AX25_IP_DEFAULT_MODE___3 = 1,
    NET_AX25_DEFAULT_MODE___3 = 2,
    NET_AX25_BACKOFF_TYPE___3 = 3,
    NET_AX25_CONNECT_MODE___3 = 4,
    NET_AX25_STANDARD_WINDOW___3 = 5,
    NET_AX25_EXTENDED_WINDOW___3 = 6,
    NET_AX25_T1_TIMEOUT___3 = 7,
    NET_AX25_T2_TIMEOUT___3 = 8,
    NET_AX25_T3_TIMEOUT___3 = 9,
    NET_AX25_IDLE_TIMEOUT___3 = 10,
    NET_AX25_N2___3 = 11,
    NET_AX25_PACLEN___3 = 12,
    NET_AX25_PROTOCOL___3 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___3 = 14
} ;
enum __anonenum_151___3 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___3 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___3 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___3 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___3 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___3 = 5,
    NET_ROSE_ROUTING_CONTROL___3 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___3 = 7,
    NET_ROSE_MAX_VCS___3 = 8,
    NET_ROSE_WINDOW_SIZE___3 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___3 = 10
} ;
enum __anonenum_152___3 {
    NET_X25_RESTART_REQUEST_TIMEOUT___3 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___3 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___3 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___3 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___3 = 5,
    NET_X25_FORWARD___3 = 6
} ;
enum __anonenum_153___3 {
    NET_TR_RIF_TIMEOUT___3 = 1
} ;
enum __anonenum_154___3 {
    NET_DECNET_NODE_TYPE___3 = 1,
    NET_DECNET_NODE_ADDRESS___3 = 2,
    NET_DECNET_NODE_NAME___3 = 3,
    NET_DECNET_DEFAULT_DEVICE___3 = 4,
    NET_DECNET_TIME_WAIT___3 = 5,
    NET_DECNET_DN_COUNT___3 = 6,
    NET_DECNET_DI_COUNT___3 = 7,
    NET_DECNET_DR_COUNT___3 = 8,
    NET_DECNET_DST_GC_INTERVAL___3 = 9,
    NET_DECNET_CONF___3 = 10,
    NET_DECNET_NO_FC_MAX_CWND___3 = 11,
    NET_DECNET_MEM___3 = 12,
    NET_DECNET_RMEM___3 = 13,
    NET_DECNET_WMEM___3 = 14,
    NET_DECNET_DEBUG_LEVEL___3 = 255
} ;
enum __anonenum_155___3 {
    NET_DECNET_CONF_LOOPBACK___3 = -2,
    NET_DECNET_CONF_DDCMP___3 = -3,
    NET_DECNET_CONF_PPP___3 = -4,
    NET_DECNET_CONF_X25___3 = -5,
    NET_DECNET_CONF_GRE___3 = -6,
    NET_DECNET_CONF_ETHER___3 = -7
} ;
enum __anonenum_156___3 {
    NET_DECNET_CONF_DEV_PRIORITY___3 = 1,
    NET_DECNET_CONF_DEV_T1___3 = 2,
    NET_DECNET_CONF_DEV_T2___3 = 3,
    NET_DECNET_CONF_DEV_T3___3 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___3 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___3 = 6,
    NET_DECNET_CONF_DEV_STATE___3 = 7
} ;
enum __anonenum_157___3 {
    NET_SCTP_RTO_INITIAL___3 = 1,
    NET_SCTP_RTO_MIN___3 = 2,
    NET_SCTP_RTO_MAX___3 = 3,
    NET_SCTP_RTO_ALPHA___3 = 4,
    NET_SCTP_RTO_BETA___3 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___3 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___3 = 7,
    NET_SCTP_PATH_MAX_RETRANS___3 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___3 = 9,
    NET_SCTP_HB_INTERVAL___3 = 10,
    NET_SCTP_PRESERVE_ENABLE___3 = 11,
    NET_SCTP_MAX_BURST___3 = 12,
    NET_SCTP_ADDIP_ENABLE___3 = 13,
    NET_SCTP_PRSCTP_ENABLE___3 = 14,
    NET_SCTP_SNDBUF_POLICY___3 = 15,
    NET_SCTP_SACK_TIMEOUT___3 = 16,
    NET_SCTP_RCVBUF_POLICY___3 = 17
} ;
enum __anonenum_158___3 {
    NET_BRIDGE_NF_CALL_ARPTABLES___3 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___3 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___3 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___3 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___3 = 5
} ;
enum __anonenum_159___3 {
    NET_IRDA_DISCOVERY___3 = 1,
    NET_IRDA_DEVNAME___3 = 2,
    NET_IRDA_DEBUG___3 = 3,
    NET_IRDA_FAST_POLL___3 = 4,
    NET_IRDA_DISCOVERY_SLOTS___3 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___3 = 6,
    NET_IRDA_SLOT_TIMEOUT___3 = 7,
    NET_IRDA_MAX_BAUD_RATE___3 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___3 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___3 = 10,
    NET_IRDA_MAX_TX_WINDOW___3 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___3 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___3 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___3 = 14
} ;
enum __anonenum_160___3 {
    FS_NRINODE___3 = 1,
    FS_STATINODE___3 = 2,
    FS_MAXINODE___3 = 3,
    FS_NRDQUOT___3 = 4,
    FS_MAXDQUOT___3 = 5,
    FS_NRFILE___3 = 6,
    FS_MAXFILE___3 = 7,
    FS_DENTRY___3 = 8,
    FS_NRSUPER___3 = 9,
    FS_MAXSUPER___3 = 10,
    FS_OVERFLOWUID___3 = 11,
    FS_OVERFLOWGID___3 = 12,
    FS_LEASES___3 = 13,
    FS_DIR_NOTIFY___3 = 14,
    FS_LEASE_TIME___3 = 15,
    FS_DQSTATS___3 = 16,
    FS_XFS___3 = 17,
    FS_AIO_NR___3 = 18,
    FS_AIO_MAX_NR___3 = 19,
    FS_INOTIFY___3 = 20,
    FS_OCFS2___3 = 988
} ;
enum __anonenum_161___3 {
    FS_DQ_LOOKUPS___3 = 1,
    FS_DQ_DROPS___3 = 2,
    FS_DQ_READS___3 = 3,
    FS_DQ_WRITES___3 = 4,
    FS_DQ_CACHE_HITS___3 = 5,
    FS_DQ_ALLOCATED___3 = 6,
    FS_DQ_FREE___3 = 7,
    FS_DQ_SYNCS___3 = 8,
    FS_DQ_WARNINGS___3 = 9
} ;
enum __anonenum_162___3 {
    DEV_CDROM___3 = 1,
    DEV_HWMON___3 = 2,
    DEV_PARPORT___3 = 3,
    DEV_RAID___3 = 4,
    DEV_MAC_HID___3 = 5,
    DEV_SCSI___3 = 6,
    DEV_IPMI___3 = 7
} ;
enum __anonenum_163___3 {
    DEV_CDROM_INFO___3 = 1,
    DEV_CDROM_AUTOCLOSE___3 = 2,
    DEV_CDROM_AUTOEJECT___3 = 3,
    DEV_CDROM_DEBUG___3 = 4,
    DEV_CDROM_LOCK___3 = 5,
    DEV_CDROM_CHECK_MEDIA___3 = 6
} ;
enum __anonenum_164___3 {
    DEV_PARPORT_DEFAULT___3 = -3
} ;
enum __anonenum_165___3 {
    DEV_RAID_SPEED_LIMIT_MIN___3 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___3 = 2
} ;
enum __anonenum_166___3 {
    DEV_PARPORT_DEFAULT_TIMESLICE___3 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___3 = 2
} ;
enum __anonenum_167___2 {
    DEV_PARPORT_SPINTIME___3 = 1,
    DEV_PARPORT_BASE_ADDR___3 = 2,
    DEV_PARPORT_IRQ___3 = 3,
    DEV_PARPORT_DMA___3 = 4,
    DEV_PARPORT_MODES___3 = 5,
    DEV_PARPORT_DEVICES___3 = 6,
    DEV_PARPORT_AUTOPROBE___3 = 16
} ;
enum __anonenum_168___2 {
    DEV_PARPORT_DEVICES_ACTIVE___3 = -3
} ;
enum __anonenum_169___3 {
    DEV_PARPORT_DEVICE_TIMESLICE___3 = 1
} ;
enum __anonenum_170___2 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___3 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___3 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___3 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___3 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___3 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___3 = 6
} ;
enum __anonenum_171___2 {
    DEV_SCSI_LOGGING_LEVEL___3 = 1
} ;
enum __anonenum_172___3 {
    DEV_IPMI_POWEROFF_POWERCYCLE___3 = 1
} ;
enum __anonenum_173___3 {
    ABI_DEFHANDLER_COFF___3 = 1,
    ABI_DEFHANDLER_ELF___3 = 2,
    ABI_DEFHANDLER_LCALL7___3 = 3,
    ABI_DEFHANDLER_LIBCSO___3 = 4,
    ABI_TRACE___3 = 5,
    ABI_FAKE_UTSNAME___3 = 6
} ;
enum __anonenum_176___2 {
    IOCB_CMD_PREAD___3 = 0,
    IOCB_CMD_PWRITE___3 = 1,
    IOCB_CMD_FSYNC___3 = 2,
    IOCB_CMD_FDSYNC___3 = 3,
    IOCB_CMD_NOOP___3 = 6,
    IOCB_CMD_PREADV___3 = 7,
    IOCB_CMD_PWRITEV___3 = 8
} ;
enum __anonenum_179___0 {
    IRQTF_RUNTHREAD___3 = 0,
    IRQTF_DIED___3 = 1,
    IRQTF_WARNED___3 = 2
} ;
enum __anonenum_180___0 {
    HI_SOFTIRQ___3 = 0,
    TIMER_SOFTIRQ___3 = 1,
    NET_TX_SOFTIRQ___3 = 2,
    NET_RX_SOFTIRQ___3 = 3,
    BLOCK_SOFTIRQ___3 = 4,
    TASKLET_SOFTIRQ___3 = 5,
    SCHED_SOFTIRQ___3 = 6,
    HRTIMER_SOFTIRQ___3 = 7,
    RCU_SOFTIRQ___3 = 8,
    NR_SOFTIRQS___3 = 9
} ;
enum __anonenum_181___2 {
    TASKLET_STATE_SCHED___3 = 0,
    TASKLET_STATE_RUN___3 = 1
} ;
enum __anonenum_183___1 {
    QIF_BLIMITS_B___3 = 0,
    QIF_SPACE_B___3 = 1,
    QIF_ILIMITS_B___3 = 2,
    QIF_INODES_B___3 = 3,
    QIF_BTIME_B___3 = 4,
    QIF_ITIME_B___3 = 5
} ;
enum __anonenum_184___1 {
    QUOTA_NL_C_UNSPEC___3 = 0,
    QUOTA_NL_C_WARNING___3 = 1,
    __QUOTA_NL_C_MAX___3 = 2
} ;
enum __anonenum_185___1 {
    QUOTA_NL_A_UNSPEC___3 = 0,
    QUOTA_NL_A_QTYPE___3 = 1,
    QUOTA_NL_A_EXCESS_ID___3 = 2,
    QUOTA_NL_A_WARNING___3 = 3,
    QUOTA_NL_A_DEV_MAJOR___3 = 4,
    QUOTA_NL_A_DEV_MINOR___3 = 5,
    QUOTA_NL_A_CAUSED_ID___3 = 6,
    __QUOTA_NL_A_MAX___3 = 7
} ;
enum __anonenum_186___2 {
    _DQUOT_USAGE_ENABLED___3 = 0,
    _DQUOT_LIMITS_ENABLED___3 = 1,
    _DQUOT_SUSPENDED___3 = 2,
    _DQUOT_STATE_FLAGS___3 = 3
} ;
enum __anonenum_193___2 {
    SB_UNFROZEN___3 = 0,
    SB_FREEZE_WRITE___3 = 1,
    SB_FREEZE_TRANS___3 = 2
} ;
enum __anonenum_194___2 {
    DIO_LOCKING___3 = 1,
    DIO_NO_LOCKING___3 = 2,
    DIO_OWN_LOCKING___3 = 3
} ;
enum __anonenum_4___4 {
    false___4 = 0,
    true___4 = 1
} ;
enum __anonenum_8 {
    DUMP_PREFIX_NONE___4 = 0,
    DUMP_PREFIX_ADDRESS___4 = 1,
    DUMP_PREFIX_OFFSET___4 = 2
} ;
enum __anonenum_20___3 {
    PG_LEVEL_NONE___4 = 0,
    PG_LEVEL_4K___4 = 1,
    PG_LEVEL_2M___4 = 2,
    PG_LEVEL_1G___4 = 3,
    PG_LEVEL_NUM___4 = 4
} ;
enum __anonenum_24 {
    GATE_INTERRUPT___4 = 14,
    GATE_TRAP___4 = 15,
    GATE_CALL___4 = 12,
    GATE_TASK___4 = 5
} ;
enum __anonenum_25___0 {
    DESC_TSS___4 = 9,
    DESC_LDT___4 = 2,
    DESCTYPE_S___4 = 16
} ;
enum __anonenum_26___0 {
    ADDR_NO_RANDOMIZE___4 = 262144,
    FDPIC_FUNCPTRS___4 = 524288,
    MMAP_PAGE_ZERO___4 = 1048576,
    ADDR_COMPAT_LAYOUT___4 = 2097152,
    READ_IMPLIES_EXEC___4 = 4194304,
    ADDR_LIMIT_32BIT___4 = 8388608,
    SHORT_INODE___4 = 16777216,
    WHOLE_SECONDS___4 = 33554432,
    STICKY_TIMEOUTS___4 = 67108864,
    ADDR_LIMIT_3GB___4 = 134217728
} ;
enum __anonenum_27___0 {
    PER_LINUX___4 = 0,
    PER_LINUX_32BIT___4 = 8388608,
    PER_LINUX_FDPIC___4 = 524288,
    PER_SVR4___4 = 68157441,
    PER_SVR3___4 = 83886082,
    PER_SCOSVR3___4 = 117440515,
    PER_OSR5___4 = 100663299,
    PER_WYSEV386___4 = 83886084,
    PER_ISCR4___4 = 67108869,
    PER_BSD___4 = 6,
    PER_SUNOS___4 = 67108870,
    PER_XENIX___4 = 83886087,
    PER_LINUX32___4 = 8,
    PER_LINUX32_3GB___4 = 134217736,
    PER_IRIX32___4 = 67108873,
    PER_IRIXN32___4 = 67108874,
    PER_IRIX64___4 = 67108875,
    PER_RISCOS___4 = 12,
    PER_SOLARIS___4 = 67108877,
    PER_UW7___4 = 68157454,
    PER_OSF4___4 = 15,
    PER_HPUX___4 = 16,
    PER_MASK___4 = 255
} ;
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[1 << 5] ;
   int count ;
   int layer ;
   struct rcu_head rcu_head ;
};
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[128UL / sizeof(long ) - 1UL] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
union __anonunion_d_39___0 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_113___0 {
    CTL_KERN___4 = 1,
    CTL_VM___4 = 2,
    CTL_NET___4 = 3,
    CTL_PROC___4 = 4,
    CTL_FS___4 = 5,
    CTL_DEBUG___4 = 6,
    CTL_DEV___4 = 7,
    CTL_BUS___4 = 8,
    CTL_ABI___4 = 9,
    CTL_CPU___4 = 10,
    CTL_ARLAN___4 = 254,
    CTL_S390DBF___4 = 5677,
    CTL_SUNRPC___4 = 7249,
    CTL_PM___4 = 9899,
    CTL_FRV___4 = 9898
} ;
enum __anonenum_114___0 {
    CTL_BUS_ISA___4 = 1
} ;
enum __anonenum_115___0 {
    INOTIFY_MAX_USER_INSTANCES___4 = 1,
    INOTIFY_MAX_USER_WATCHES___4 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___4 = 3
} ;
enum __anonenum_116___0 {
    KERN_OSTYPE___4 = 1,
    KERN_OSRELEASE___4 = 2,
    KERN_OSREV___4 = 3,
    KERN_VERSION___4 = 4,
    KERN_SECUREMASK___4 = 5,
    KERN_PROF___4 = 6,
    KERN_NODENAME___4 = 7,
    KERN_DOMAINNAME___4 = 8,
    KERN_PANIC___4 = 15,
    KERN_REALROOTDEV___4 = 16,
    KERN_SPARC_REBOOT___4 = 21,
    KERN_CTLALTDEL___4 = 22,
    KERN_PRINTK___4 = 23,
    KERN_NAMETRANS___4 = 24,
    KERN_PPC_HTABRECLAIM___4 = 25,
    KERN_PPC_ZEROPAGED___4 = 26,
    KERN_PPC_POWERSAVE_NAP___4 = 27,
    KERN_MODPROBE___4 = 28,
    KERN_SG_BIG_BUFF___4 = 29,
    KERN_ACCT___4 = 30,
    KERN_PPC_L2CR___4 = 31,
    KERN_RTSIGNR___4 = 32,
    KERN_RTSIGMAX___4 = 33,
    KERN_SHMMAX___4 = 34,
    KERN_MSGMAX___4 = 35,
    KERN_MSGMNB___4 = 36,
    KERN_MSGPOOL___4 = 37,
    KERN_SYSRQ___4 = 38,
    KERN_MAX_THREADS___4 = 39,
    KERN_RANDOM___4 = 40,
    KERN_SHMALL___4 = 41,
    KERN_MSGMNI___4 = 42,
    KERN_SEM___4 = 43,
    KERN_SPARC_STOP_A___4 = 44,
    KERN_SHMMNI___4 = 45,
    KERN_OVERFLOWUID___4 = 46,
    KERN_OVERFLOWGID___4 = 47,
    KERN_SHMPATH___4 = 48,
    KERN_HOTPLUG___4 = 49,
    KERN_IEEE_EMULATION_WARNINGS___4 = 50,
    KERN_S390_USER_DEBUG_LOGGING___4 = 51,
    KERN_CORE_USES_PID___4 = 52,
    KERN_TAINTED___4 = 53,
    KERN_CADPID___4 = 54,
    KERN_PIDMAX___4 = 55,
    KERN_CORE_PATTERN___4 = 56,
    KERN_PANIC_ON_OOPS___4 = 57,
    KERN_HPPA_PWRSW___4 = 58,
    KERN_HPPA_UNALIGNED___4 = 59,
    KERN_PRINTK_RATELIMIT___4 = 60,
    KERN_PRINTK_RATELIMIT_BURST___4 = 61,
    KERN_PTY___4 = 62,
    KERN_NGROUPS_MAX___4 = 63,
    KERN_SPARC_SCONS_PWROFF___4 = 64,
    KERN_HZ_TIMER___4 = 65,
    KERN_UNKNOWN_NMI_PANIC___4 = 66,
    KERN_BOOTLOADER_TYPE___4 = 67,
    KERN_RANDOMIZE___4 = 68,
    KERN_SETUID_DUMPABLE___4 = 69,
    KERN_SPIN_RETRY___4 = 70,
    KERN_ACPI_VIDEO_FLAGS___4 = 71,
    KERN_IA64_UNALIGNED___4 = 72,
    KERN_COMPAT_LOG___4 = 73,
    KERN_MAX_LOCK_DEPTH___4 = 74,
    KERN_NMI_WATCHDOG___4 = 75,
    KERN_PANIC_ON_NMI___4 = 76
} ;
enum __anonenum_117___0 {
    VM_UNUSED1___4 = 1,
    VM_UNUSED2___4 = 2,
    VM_UNUSED3___4 = 3,
    VM_UNUSED4___4 = 4,
    VM_OVERCOMMIT_MEMORY___4 = 5,
    VM_UNUSED5___4 = 6,
    VM_UNUSED7___4 = 7,
    VM_UNUSED8___4 = 8,
    VM_UNUSED9___4 = 9,
    VM_PAGE_CLUSTER___4 = 10,
    VM_DIRTY_BACKGROUND___4 = 11,
    VM_DIRTY_RATIO___4 = 12,
    VM_DIRTY_WB_CS___4 = 13,
    VM_DIRTY_EXPIRE_CS___4 = 14,
    VM_NR_PDFLUSH_THREADS___4 = 15,
    VM_OVERCOMMIT_RATIO___4 = 16,
    VM_PAGEBUF___4 = 17,
    VM_HUGETLB_PAGES___4 = 18,
    VM_SWAPPINESS___4 = 19,
    VM_LOWMEM_RESERVE_RATIO___4 = 20,
    VM_MIN_FREE_KBYTES___4 = 21,
    VM_MAX_MAP_COUNT___4 = 22,
    VM_LAPTOP_MODE___4 = 23,
    VM_BLOCK_DUMP___4 = 24,
    VM_HUGETLB_GROUP___4 = 25,
    VM_VFS_CACHE_PRESSURE___4 = 26,
    VM_LEGACY_VA_LAYOUT___4 = 27,
    VM_SWAP_TOKEN_TIMEOUT___4 = 28,
    VM_DROP_PAGECACHE___4 = 29,
    VM_PERCPU_PAGELIST_FRACTION___4 = 30,
    VM_ZONE_RECLAIM_MODE___4 = 31,
    VM_MIN_UNMAPPED___4 = 32,
    VM_PANIC_ON_OOM___4 = 33,
    VM_VDSO_ENABLED___4 = 34,
    VM_MIN_SLAB___4 = 35
} ;
enum __anonenum_118___0 {
    NET_CORE___4 = 1,
    NET_ETHER___4 = 2,
    NET_802___4 = 3,
    NET_UNIX___4 = 4,
    NET_IPV4___4 = 5,
    NET_IPX___4 = 6,
    NET_ATALK___4 = 7,
    NET_NETROM___4 = 8,
    NET_AX25___4 = 9,
    NET_BRIDGE___4 = 10,
    NET_ROSE___4 = 11,
    NET_IPV6___4 = 12,
    NET_X25___4 = 13,
    NET_TR___4 = 14,
    NET_DECNET___4 = 15,
    NET_ECONET___4 = 16,
    NET_SCTP___4 = 17,
    NET_LLC___4 = 18,
    NET_NETFILTER___4 = 19,
    NET_DCCP___4 = 20,
    NET_IRDA___4 = 412
} ;
enum __anonenum_119___0 {
    RANDOM_POOLSIZE___4 = 1,
    RANDOM_ENTROPY_COUNT___4 = 2,
    RANDOM_READ_THRESH___4 = 3,
    RANDOM_WRITE_THRESH___4 = 4,
    RANDOM_BOOT_ID___4 = 5,
    RANDOM_UUID___4 = 6
} ;
enum __anonenum_120___2 {
    PTY_MAX___4 = 1,
    PTY_NR___4 = 2
} ;
enum __anonenum_121___2 {
    BUS_ISA_MEM_BASE___4 = 1,
    BUS_ISA_PORT_BASE___4 = 2,
    BUS_ISA_PORT_SHIFT___4 = 3
} ;
enum __anonenum_122___2 {
    NET_CORE_WMEM_MAX___4 = 1,
    NET_CORE_RMEM_MAX___4 = 2,
    NET_CORE_WMEM_DEFAULT___4 = 3,
    NET_CORE_RMEM_DEFAULT___4 = 4,
    NET_CORE_MAX_BACKLOG___4 = 6,
    NET_CORE_FASTROUTE___4 = 7,
    NET_CORE_MSG_COST___4 = 8,
    NET_CORE_MSG_BURST___4 = 9,
    NET_CORE_OPTMEM_MAX___4 = 10,
    NET_CORE_HOT_LIST_LENGTH___4 = 11,
    NET_CORE_DIVERT_VERSION___4 = 12,
    NET_CORE_NO_CONG_THRESH___4 = 13,
    NET_CORE_NO_CONG___4 = 14,
    NET_CORE_LO_CONG___4 = 15,
    NET_CORE_MOD_CONG___4 = 16,
    NET_CORE_DEV_WEIGHT___4 = 17,
    NET_CORE_SOMAXCONN___4 = 18,
    NET_CORE_BUDGET___4 = 19,
    NET_CORE_AEVENT_ETIME___4 = 20,
    NET_CORE_AEVENT_RSEQTH___4 = 21,
    NET_CORE_WARNINGS___4 = 22
} ;
enum __anonenum_123___2 {
    NET_UNIX_DESTROY_DELAY___4 = 1,
    NET_UNIX_DELETE_DELAY___4 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___4 = 3
} ;
enum __anonenum_124___2 {
    NET_NF_CONNTRACK_MAX___4 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___4 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___4 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___4 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___4 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___4 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___4 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___4 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___4 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___4 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___4 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___4 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___4 = 13,
    NET_NF_CONNTRACK_BUCKETS___4 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___4 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___4 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___4 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___4 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___4 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___4 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___4 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___4 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___4 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___4 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___4 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___4 = 26,
    NET_NF_CONNTRACK_COUNT___4 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___4 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___4 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___4 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___4 = 31,
    NET_NF_CONNTRACK_CHECKSUM___4 = 32
} ;
enum __anonenum_125___4 {
    NET_IPV4_FORWARD___4 = 8,
    NET_IPV4_DYNADDR___4 = 9,
    NET_IPV4_CONF___4 = 16,
    NET_IPV4_NEIGH___4 = 17,
    NET_IPV4_ROUTE___4 = 18,
    NET_IPV4_FIB_HASH___4 = 19,
    NET_IPV4_NETFILTER___4 = 20,
    NET_IPV4_TCP_TIMESTAMPS___4 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___4 = 34,
    NET_IPV4_TCP_SACK___4 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___4 = 36,
    NET_IPV4_DEFAULT_TTL___4 = 37,
    NET_IPV4_AUTOCONFIG___4 = 38,
    NET_IPV4_NO_PMTU_DISC___4 = 39,
    NET_IPV4_TCP_SYN_RETRIES___4 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___4 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___4 = 42,
    NET_IPV4_IPFRAG_TIME___4 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___4 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___4 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___4 = 46,
    NET_IPV4_TCP_RETRIES1___4 = 47,
    NET_IPV4_TCP_RETRIES2___4 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___4 = 49,
    NET_IPV4_IP_MASQ_DEBUG___4 = 50,
    NET_TCP_SYNCOOKIES___4 = 51,
    NET_TCP_STDURG___4 = 52,
    NET_TCP_RFC1337___4 = 53,
    NET_TCP_SYN_TAILDROP___4 = 54,
    NET_TCP_MAX_SYN_BACKLOG___4 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___4 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___4 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___4 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___4 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___4 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___4 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___4 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___4 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___4 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___4 = 65,
    NET_TCP_TW_RECYCLE___4 = 66,
    NET_IPV4_ALWAYS_DEFRAG___4 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___4 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___4 = 69,
    NET_IPV4_INET_PEER_MINTTL___4 = 70,
    NET_IPV4_INET_PEER_MAXTTL___4 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___4 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___4 = 73,
    NET_TCP_ORPHAN_RETRIES___4 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___4 = 75,
    NET_TCP_SYNACK_RETRIES___4 = 76,
    NET_TCP_MAX_ORPHANS___4 = 77,
    NET_TCP_MAX_TW_BUCKETS___4 = 78,
    NET_TCP_FACK___4 = 79,
    NET_TCP_REORDERING___4 = 80,
    NET_TCP_ECN___4 = 81,
    NET_TCP_DSACK___4 = 82,
    NET_TCP_MEM___4 = 83,
    NET_TCP_WMEM___4 = 84,
    NET_TCP_RMEM___4 = 85,
    NET_TCP_APP_WIN___4 = 86,
    NET_TCP_ADV_WIN_SCALE___4 = 87,
    NET_IPV4_NONLOCAL_BIND___4 = 88,
    NET_IPV4_ICMP_RATELIMIT___4 = 89,
    NET_IPV4_ICMP_RATEMASK___4 = 90,
    NET_TCP_TW_REUSE___4 = 91,
    NET_TCP_FRTO___4 = 92,
    NET_TCP_LOW_LATENCY___4 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___4 = 94,
    NET_IPV4_IGMP_MAX_MSF___4 = 96,
    NET_TCP_NO_METRICS_SAVE___4 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___4 = 105,
    NET_TCP_MODERATE_RCVBUF___4 = 106,
    NET_TCP_TSO_WIN_DIVISOR___4 = 107,
    NET_TCP_BIC_BETA___4 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___4 = 109,
    NET_TCP_CONG_CONTROL___4 = 110,
    NET_TCP_ABC___4 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___4 = 112,
    NET_TCP_MTU_PROBING___4 = 113,
    NET_TCP_BASE_MSS___4 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___4 = 115,
    NET_TCP_DMA_COPYBREAK___4 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___4 = 117,
    NET_CIPSOV4_CACHE_ENABLE___4 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___4 = 119,
    NET_CIPSOV4_RBM_OPTFMT___4 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___4 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___4 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___4 = 123,
    NET_TCP_MAX_SSTHRESH___4 = 124,
    NET_TCP_FRTO_RESPONSE___4 = 125
} ;
enum __anonenum_126___4 {
    NET_IPV4_ROUTE_FLUSH___4 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___4 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___4 = 3,
    NET_IPV4_ROUTE_GC_THRESH___4 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___4 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___4 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___4 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___4 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___4 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___4 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___4 = 11,
    NET_IPV4_ROUTE_ERROR_COST___4 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___4 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___4 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___4 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___4 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___4 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___4 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___4 = 19
} ;
enum __anonenum_127___4 {
    NET_PROTO_CONF_ALL___4 = -2,
    NET_PROTO_CONF_DEFAULT___4 = -3
} ;
enum __anonenum_128___4 {
    NET_IPV4_CONF_FORWARDING___4 = 1,
    NET_IPV4_CONF_MC_FORWARDING___4 = 2,
    NET_IPV4_CONF_PROXY_ARP___4 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___4 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___4 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___4 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___4 = 7,
    NET_IPV4_CONF_RP_FILTER___4 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___4 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___4 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___4 = 11,
    NET_IPV4_CONF_TAG___4 = 12,
    NET_IPV4_CONF_ARPFILTER___4 = 13,
    NET_IPV4_CONF_MEDIUM_ID___4 = 14,
    NET_IPV4_CONF_NOXFRM___4 = 15,
    NET_IPV4_CONF_NOPOLICY___4 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___4 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___4 = 18,
    NET_IPV4_CONF_ARP_IGNORE___4 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___4 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___4 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___4 = 22,
    __NET_IPV4_CONF_MAX___4 = 23
} ;
enum __anonenum_129___4 {
    NET_IPV4_NF_CONNTRACK_MAX___4 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___4 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___4 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___4 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___4 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___4 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___4 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___4 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___4 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___4 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___4 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___4 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___4 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___4 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___4 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___4 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___4 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___4 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___4 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___4 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___4 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___4 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___4 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___4 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___4 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___4 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___4 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___4 = 28
} ;
enum __anonenum_130___4 {
    NET_IPV6_CONF___4 = 16,
    NET_IPV6_NEIGH___4 = 17,
    NET_IPV6_ROUTE___4 = 18,
    NET_IPV6_ICMP___4 = 19,
    NET_IPV6_BINDV6ONLY___4 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___4 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___4 = 22,
    NET_IPV6_IP6FRAG_TIME___4 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___4 = 24,
    NET_IPV6_MLD_MAX_MSF___4 = 25
} ;
enum __anonenum_131___4 {
    NET_IPV6_ROUTE_FLUSH___4 = 1,
    NET_IPV6_ROUTE_GC_THRESH___4 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___4 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___4 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___4 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___4 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___4 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___4 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___4 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___4 = 10
} ;
enum __anonenum_132___4 {
    NET_IPV6_FORWARDING___4 = 1,
    NET_IPV6_HOP_LIMIT___4 = 2,
    NET_IPV6_MTU___4 = 3,
    NET_IPV6_ACCEPT_RA___4 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___4 = 5,
    NET_IPV6_AUTOCONF___4 = 6,
    NET_IPV6_DAD_TRANSMITS___4 = 7,
    NET_IPV6_RTR_SOLICITS___4 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___4 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___4 = 10,
    NET_IPV6_USE_TEMPADDR___4 = 11,
    NET_IPV6_TEMP_VALID_LFT___4 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___4 = 13,
    NET_IPV6_REGEN_MAX_RETRY___4 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___4 = 15,
    NET_IPV6_MAX_ADDRESSES___4 = 16,
    NET_IPV6_FORCE_MLD_VERSION___4 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___4 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___4 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___4 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___4 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___4 = 22,
    NET_IPV6_PROXY_NDP___4 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___4 = 25,
    __NET_IPV6_MAX___4 = 26
} ;
enum __anonenum_133___4 {
    NET_IPV6_ICMP_RATELIMIT___4 = 1
} ;
enum __anonenum_134___4 {
    NET_NEIGH_MCAST_SOLICIT___4 = 1,
    NET_NEIGH_UCAST_SOLICIT___4 = 2,
    NET_NEIGH_APP_SOLICIT___4 = 3,
    NET_NEIGH_RETRANS_TIME___4 = 4,
    NET_NEIGH_REACHABLE_TIME___4 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___4 = 6,
    NET_NEIGH_GC_STALE_TIME___4 = 7,
    NET_NEIGH_UNRES_QLEN___4 = 8,
    NET_NEIGH_PROXY_QLEN___4 = 9,
    NET_NEIGH_ANYCAST_DELAY___4 = 10,
    NET_NEIGH_PROXY_DELAY___4 = 11,
    NET_NEIGH_LOCKTIME___4 = 12,
    NET_NEIGH_GC_INTERVAL___4 = 13,
    NET_NEIGH_GC_THRESH1___4 = 14,
    NET_NEIGH_GC_THRESH2___4 = 15,
    NET_NEIGH_GC_THRESH3___4 = 16,
    NET_NEIGH_RETRANS_TIME_MS___4 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___4 = 18,
    __NET_NEIGH_MAX___4 = 19
} ;
enum __anonenum_135___4 {
    NET_DCCP_DEFAULT___4 = 1
} ;
enum __anonenum_136___4 {
    NET_IPX_PPROP_BROADCASTING___4 = 1,
    NET_IPX_FORWARDING___4 = 2
} ;
enum __anonenum_137___4 {
    NET_LLC2___4 = 1,
    NET_LLC_STATION___4 = 2
} ;
enum __anonenum_138___4 {
    NET_LLC2_TIMEOUT___4 = 1
} ;
enum __anonenum_139___4 {
    NET_LLC_STATION_ACK_TIMEOUT___4 = 1
} ;
enum __anonenum_140___4 {
    NET_LLC2_ACK_TIMEOUT___4 = 1,
    NET_LLC2_P_TIMEOUT___4 = 2,
    NET_LLC2_REJ_TIMEOUT___4 = 3,
    NET_LLC2_BUSY_TIMEOUT___4 = 4
} ;
enum __anonenum_141___4 {
    NET_ATALK_AARP_EXPIRY_TIME___4 = 1,
    NET_ATALK_AARP_TICK_TIME___4 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___4 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___4 = 4
} ;
enum __anonenum_142___4 {
    NET_NETROM_DEFAULT_PATH_QUALITY___4 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___4 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___4 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___4 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___4 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___4 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___4 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___4 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___4 = 9,
    NET_NETROM_ROUTING_CONTROL___4 = 10,
    NET_NETROM_LINK_FAILS_COUNT___4 = 11,
    NET_NETROM_RESET___4 = 12
} ;
enum __anonenum_143___4 {
    NET_AX25_IP_DEFAULT_MODE___4 = 1,
    NET_AX25_DEFAULT_MODE___4 = 2,
    NET_AX25_BACKOFF_TYPE___4 = 3,
    NET_AX25_CONNECT_MODE___4 = 4,
    NET_AX25_STANDARD_WINDOW___4 = 5,
    NET_AX25_EXTENDED_WINDOW___4 = 6,
    NET_AX25_T1_TIMEOUT___4 = 7,
    NET_AX25_T2_TIMEOUT___4 = 8,
    NET_AX25_T3_TIMEOUT___4 = 9,
    NET_AX25_IDLE_TIMEOUT___4 = 10,
    NET_AX25_N2___4 = 11,
    NET_AX25_PACLEN___4 = 12,
    NET_AX25_PROTOCOL___4 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___4 = 14
} ;
enum __anonenum_144___4 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___4 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___4 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___4 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___4 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___4 = 5,
    NET_ROSE_ROUTING_CONTROL___4 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___4 = 7,
    NET_ROSE_MAX_VCS___4 = 8,
    NET_ROSE_WINDOW_SIZE___4 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___4 = 10
} ;
enum __anonenum_145___4 {
    NET_X25_RESTART_REQUEST_TIMEOUT___4 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___4 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___4 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___4 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___4 = 5,
    NET_X25_FORWARD___4 = 6
} ;
enum __anonenum_146___4 {
    NET_TR_RIF_TIMEOUT___4 = 1
} ;
enum __anonenum_147___4 {
    NET_DECNET_NODE_TYPE___4 = 1,
    NET_DECNET_NODE_ADDRESS___4 = 2,
    NET_DECNET_NODE_NAME___4 = 3,
    NET_DECNET_DEFAULT_DEVICE___4 = 4,
    NET_DECNET_TIME_WAIT___4 = 5,
    NET_DECNET_DN_COUNT___4 = 6,
    NET_DECNET_DI_COUNT___4 = 7,
    NET_DECNET_DR_COUNT___4 = 8,
    NET_DECNET_DST_GC_INTERVAL___4 = 9,
    NET_DECNET_CONF___4 = 10,
    NET_DECNET_NO_FC_MAX_CWND___4 = 11,
    NET_DECNET_MEM___4 = 12,
    NET_DECNET_RMEM___4 = 13,
    NET_DECNET_WMEM___4 = 14,
    NET_DECNET_DEBUG_LEVEL___4 = 255
} ;
enum __anonenum_148___4 {
    NET_DECNET_CONF_LOOPBACK___4 = -2,
    NET_DECNET_CONF_DDCMP___4 = -3,
    NET_DECNET_CONF_PPP___4 = -4,
    NET_DECNET_CONF_X25___4 = -5,
    NET_DECNET_CONF_GRE___4 = -6,
    NET_DECNET_CONF_ETHER___4 = -7
} ;
enum __anonenum_149___4 {
    NET_DECNET_CONF_DEV_PRIORITY___4 = 1,
    NET_DECNET_CONF_DEV_T1___4 = 2,
    NET_DECNET_CONF_DEV_T2___4 = 3,
    NET_DECNET_CONF_DEV_T3___4 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___4 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___4 = 6,
    NET_DECNET_CONF_DEV_STATE___4 = 7
} ;
enum __anonenum_150___4 {
    NET_SCTP_RTO_INITIAL___4 = 1,
    NET_SCTP_RTO_MIN___4 = 2,
    NET_SCTP_RTO_MAX___4 = 3,
    NET_SCTP_RTO_ALPHA___4 = 4,
    NET_SCTP_RTO_BETA___4 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___4 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___4 = 7,
    NET_SCTP_PATH_MAX_RETRANS___4 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___4 = 9,
    NET_SCTP_HB_INTERVAL___4 = 10,
    NET_SCTP_PRESERVE_ENABLE___4 = 11,
    NET_SCTP_MAX_BURST___4 = 12,
    NET_SCTP_ADDIP_ENABLE___4 = 13,
    NET_SCTP_PRSCTP_ENABLE___4 = 14,
    NET_SCTP_SNDBUF_POLICY___4 = 15,
    NET_SCTP_SACK_TIMEOUT___4 = 16,
    NET_SCTP_RCVBUF_POLICY___4 = 17
} ;
enum __anonenum_151___4 {
    NET_BRIDGE_NF_CALL_ARPTABLES___4 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___4 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___4 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___4 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___4 = 5
} ;
enum __anonenum_152___4 {
    NET_IRDA_DISCOVERY___4 = 1,
    NET_IRDA_DEVNAME___4 = 2,
    NET_IRDA_DEBUG___4 = 3,
    NET_IRDA_FAST_POLL___4 = 4,
    NET_IRDA_DISCOVERY_SLOTS___4 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___4 = 6,
    NET_IRDA_SLOT_TIMEOUT___4 = 7,
    NET_IRDA_MAX_BAUD_RATE___4 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___4 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___4 = 10,
    NET_IRDA_MAX_TX_WINDOW___4 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___4 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___4 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___4 = 14
} ;
enum __anonenum_153___4 {
    FS_NRINODE___4 = 1,
    FS_STATINODE___4 = 2,
    FS_MAXINODE___4 = 3,
    FS_NRDQUOT___4 = 4,
    FS_MAXDQUOT___4 = 5,
    FS_NRFILE___4 = 6,
    FS_MAXFILE___4 = 7,
    FS_DENTRY___4 = 8,
    FS_NRSUPER___4 = 9,
    FS_MAXSUPER___4 = 10,
    FS_OVERFLOWUID___4 = 11,
    FS_OVERFLOWGID___4 = 12,
    FS_LEASES___4 = 13,
    FS_DIR_NOTIFY___4 = 14,
    FS_LEASE_TIME___4 = 15,
    FS_DQSTATS___4 = 16,
    FS_XFS___4 = 17,
    FS_AIO_NR___4 = 18,
    FS_AIO_MAX_NR___4 = 19,
    FS_INOTIFY___4 = 20,
    FS_OCFS2___4 = 988
} ;
enum __anonenum_154___4 {
    FS_DQ_LOOKUPS___4 = 1,
    FS_DQ_DROPS___4 = 2,
    FS_DQ_READS___4 = 3,
    FS_DQ_WRITES___4 = 4,
    FS_DQ_CACHE_HITS___4 = 5,
    FS_DQ_ALLOCATED___4 = 6,
    FS_DQ_FREE___4 = 7,
    FS_DQ_SYNCS___4 = 8,
    FS_DQ_WARNINGS___4 = 9
} ;
enum __anonenum_155___4 {
    DEV_CDROM___4 = 1,
    DEV_HWMON___4 = 2,
    DEV_PARPORT___4 = 3,
    DEV_RAID___4 = 4,
    DEV_MAC_HID___4 = 5,
    DEV_SCSI___4 = 6,
    DEV_IPMI___4 = 7
} ;
enum __anonenum_156___4 {
    DEV_CDROM_INFO___4 = 1,
    DEV_CDROM_AUTOCLOSE___4 = 2,
    DEV_CDROM_AUTOEJECT___4 = 3,
    DEV_CDROM_DEBUG___4 = 4,
    DEV_CDROM_LOCK___4 = 5,
    DEV_CDROM_CHECK_MEDIA___4 = 6
} ;
enum __anonenum_157___4 {
    DEV_PARPORT_DEFAULT___4 = -3
} ;
enum __anonenum_158___4 {
    DEV_RAID_SPEED_LIMIT_MIN___4 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___4 = 2
} ;
enum __anonenum_159___4 {
    DEV_PARPORT_DEFAULT_TIMESLICE___4 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___4 = 2
} ;
enum __anonenum_160___4 {
    DEV_PARPORT_SPINTIME___4 = 1,
    DEV_PARPORT_BASE_ADDR___4 = 2,
    DEV_PARPORT_IRQ___4 = 3,
    DEV_PARPORT_DMA___4 = 4,
    DEV_PARPORT_MODES___4 = 5,
    DEV_PARPORT_DEVICES___4 = 6,
    DEV_PARPORT_AUTOPROBE___4 = 16
} ;
enum __anonenum_161___4 {
    DEV_PARPORT_DEVICES_ACTIVE___4 = -3
} ;
enum __anonenum_162___4 {
    DEV_PARPORT_DEVICE_TIMESLICE___4 = 1
} ;
enum __anonenum_163___4 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___4 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___4 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___4 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___4 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___4 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___4 = 6
} ;
enum __anonenum_164___4 {
    DEV_SCSI_LOGGING_LEVEL___4 = 1
} ;
enum __anonenum_165___4 {
    DEV_IPMI_POWEROFF_POWERCYCLE___4 = 1
} ;
enum __anonenum_166___4 {
    ABI_DEFHANDLER_COFF___4 = 1,
    ABI_DEFHANDLER_ELF___4 = 2,
    ABI_DEFHANDLER_LCALL7___4 = 3,
    ABI_DEFHANDLER_LIBCSO___4 = 4,
    ABI_TRACE___4 = 5,
    ABI_FAKE_UTSNAME___4 = 6
} ;
enum __anonenum_169___4 {
    IOCB_CMD_PREAD___4 = 0,
    IOCB_CMD_PWRITE___4 = 1,
    IOCB_CMD_FSYNC___4 = 2,
    IOCB_CMD_FDSYNC___4 = 3,
    IOCB_CMD_NOOP___4 = 6,
    IOCB_CMD_PREADV___4 = 7,
    IOCB_CMD_PWRITEV___4 = 8
} ;
enum __anonenum_172___4 {
    IRQTF_RUNTHREAD___4 = 0,
    IRQTF_DIED___4 = 1,
    IRQTF_WARNED___4 = 2
} ;
enum __anonenum_173___4 {
    HI_SOFTIRQ___4 = 0,
    TIMER_SOFTIRQ___4 = 1,
    NET_TX_SOFTIRQ___4 = 2,
    NET_RX_SOFTIRQ___4 = 3,
    BLOCK_SOFTIRQ___4 = 4,
    TASKLET_SOFTIRQ___4 = 5,
    SCHED_SOFTIRQ___4 = 6,
    HRTIMER_SOFTIRQ___4 = 7,
    RCU_SOFTIRQ___4 = 8,
    NR_SOFTIRQS___4 = 9
} ;
enum __anonenum_174___2 {
    TASKLET_STATE_SCHED___4 = 0,
    TASKLET_STATE_RUN___4 = 1
} ;
enum __anonenum_183___2 {
    QIF_BLIMITS_B___4 = 0,
    QIF_SPACE_B___4 = 1,
    QIF_ILIMITS_B___4 = 2,
    QIF_INODES_B___4 = 3,
    QIF_BTIME_B___4 = 4,
    QIF_ITIME_B___4 = 5
} ;
enum __anonenum_184___2 {
    QUOTA_NL_C_UNSPEC___4 = 0,
    QUOTA_NL_C_WARNING___4 = 1,
    __QUOTA_NL_C_MAX___4 = 2
} ;
enum __anonenum_185___2 {
    QUOTA_NL_A_UNSPEC___4 = 0,
    QUOTA_NL_A_QTYPE___4 = 1,
    QUOTA_NL_A_EXCESS_ID___4 = 2,
    QUOTA_NL_A_WARNING___4 = 3,
    QUOTA_NL_A_DEV_MAJOR___4 = 4,
    QUOTA_NL_A_DEV_MINOR___4 = 5,
    QUOTA_NL_A_CAUSED_ID___4 = 6,
    __QUOTA_NL_A_MAX___4 = 7
} ;
enum __anonenum_186___3 {
    _DQUOT_USAGE_ENABLED___4 = 0,
    _DQUOT_LIMITS_ENABLED___4 = 1,
    _DQUOT_SUSPENDED___4 = 2,
    _DQUOT_STATE_FLAGS___4 = 3
} ;
enum __anonenum_193___3 {
    SB_UNFROZEN___4 = 0,
    SB_FREEZE_WRITE___4 = 1,
    SB_FREEZE_TRANS___4 = 2
} ;
enum __anonenum_194___3 {
    DIO_LOCKING___4 = 1,
    DIO_NO_LOCKING___4 = 2,
    DIO_OWN_LOCKING___4 = 3
} ;
struct ep_device {
   struct usb_endpoint_descriptor *desc ;
   struct usb_device *udev ;
   struct device dev ;
   int minor ;
};
struct ep_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct usb_device * , struct usb_endpoint_descriptor * , char * ) ;
};
struct endpoint_class {
   struct kref kref ;
   struct class *class ;
};
enum __anonenum_4___5 {
    false___5 = 0,
    true___5 = 1
} ;
enum __anonenum_10___3 {
    DUMP_PREFIX_NONE___5 = 0,
    DUMP_PREFIX_ADDRESS___5 = 1,
    DUMP_PREFIX_OFFSET___5 = 2
} ;
enum __anonenum_15___3 {
    PG_LEVEL_NONE___5 = 0,
    PG_LEVEL_4K___5 = 1,
    PG_LEVEL_2M___5 = 2,
    PG_LEVEL_1G___5 = 3,
    PG_LEVEL_NUM___5 = 4
} ;
enum __anonenum_19___3 {
    GATE_INTERRUPT___5 = 14,
    GATE_TRAP___5 = 15,
    GATE_CALL___5 = 12,
    GATE_TASK___5 = 5
} ;
enum __anonenum_20___4 {
    DESC_TSS___5 = 9,
    DESC_LDT___5 = 2,
    DESCTYPE_S___5 = 16
} ;
enum __anonenum_21___4 {
    ADDR_NO_RANDOMIZE___5 = 262144,
    FDPIC_FUNCPTRS___5 = 524288,
    MMAP_PAGE_ZERO___5 = 1048576,
    ADDR_COMPAT_LAYOUT___5 = 2097152,
    READ_IMPLIES_EXEC___5 = 4194304,
    ADDR_LIMIT_32BIT___5 = 8388608,
    SHORT_INODE___5 = 16777216,
    WHOLE_SECONDS___5 = 33554432,
    STICKY_TIMEOUTS___5 = 67108864,
    ADDR_LIMIT_3GB___5 = 134217728
} ;
enum __anonenum_22___3 {
    PER_LINUX___5 = 0,
    PER_LINUX_32BIT___5 = 8388608,
    PER_LINUX_FDPIC___5 = 524288,
    PER_SVR4___5 = 68157441,
    PER_SVR3___5 = 83886082,
    PER_SCOSVR3___5 = 117440515,
    PER_OSR5___5 = 100663299,
    PER_WYSEV386___5 = 83886084,
    PER_ISCR4___5 = 67108869,
    PER_BSD___5 = 6,
    PER_SUNOS___5 = 67108870,
    PER_XENIX___5 = 83886087,
    PER_LINUX32___5 = 8,
    PER_LINUX32_3GB___5 = 134217736,
    PER_IRIX32___5 = 67108873,
    PER_IRIXN32___5 = 67108874,
    PER_IRIX64___5 = 67108875,
    PER_RISCOS___5 = 12,
    PER_SOLARIS___5 = 67108877,
    PER_UW7___5 = 68157454,
    PER_OSF4___5 = 15,
    PER_HPUX___5 = 16,
    PER_MASK___5 = 255
} ;
union __anonunion_d_37___1 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_119___1 {
    CTL_KERN___5 = 1,
    CTL_VM___5 = 2,
    CTL_NET___5 = 3,
    CTL_PROC___5 = 4,
    CTL_FS___5 = 5,
    CTL_DEBUG___5 = 6,
    CTL_DEV___5 = 7,
    CTL_BUS___5 = 8,
    CTL_ABI___5 = 9,
    CTL_CPU___5 = 10,
    CTL_ARLAN___5 = 254,
    CTL_S390DBF___5 = 5677,
    CTL_SUNRPC___5 = 7249,
    CTL_PM___5 = 9899,
    CTL_FRV___5 = 9898
} ;
enum __anonenum_120___3 {
    CTL_BUS_ISA___5 = 1
} ;
enum __anonenum_121___3 {
    INOTIFY_MAX_USER_INSTANCES___5 = 1,
    INOTIFY_MAX_USER_WATCHES___5 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___5 = 3
} ;
enum __anonenum_122___3 {
    KERN_OSTYPE___5 = 1,
    KERN_OSRELEASE___5 = 2,
    KERN_OSREV___5 = 3,
    KERN_VERSION___5 = 4,
    KERN_SECUREMASK___5 = 5,
    KERN_PROF___5 = 6,
    KERN_NODENAME___5 = 7,
    KERN_DOMAINNAME___5 = 8,
    KERN_PANIC___5 = 15,
    KERN_REALROOTDEV___5 = 16,
    KERN_SPARC_REBOOT___5 = 21,
    KERN_CTLALTDEL___5 = 22,
    KERN_PRINTK___5 = 23,
    KERN_NAMETRANS___5 = 24,
    KERN_PPC_HTABRECLAIM___5 = 25,
    KERN_PPC_ZEROPAGED___5 = 26,
    KERN_PPC_POWERSAVE_NAP___5 = 27,
    KERN_MODPROBE___5 = 28,
    KERN_SG_BIG_BUFF___5 = 29,
    KERN_ACCT___5 = 30,
    KERN_PPC_L2CR___5 = 31,
    KERN_RTSIGNR___5 = 32,
    KERN_RTSIGMAX___5 = 33,
    KERN_SHMMAX___5 = 34,
    KERN_MSGMAX___5 = 35,
    KERN_MSGMNB___5 = 36,
    KERN_MSGPOOL___5 = 37,
    KERN_SYSRQ___5 = 38,
    KERN_MAX_THREADS___5 = 39,
    KERN_RANDOM___5 = 40,
    KERN_SHMALL___5 = 41,
    KERN_MSGMNI___5 = 42,
    KERN_SEM___5 = 43,
    KERN_SPARC_STOP_A___5 = 44,
    KERN_SHMMNI___5 = 45,
    KERN_OVERFLOWUID___5 = 46,
    KERN_OVERFLOWGID___5 = 47,
    KERN_SHMPATH___5 = 48,
    KERN_HOTPLUG___5 = 49,
    KERN_IEEE_EMULATION_WARNINGS___5 = 50,
    KERN_S390_USER_DEBUG_LOGGING___5 = 51,
    KERN_CORE_USES_PID___5 = 52,
    KERN_TAINTED___5 = 53,
    KERN_CADPID___5 = 54,
    KERN_PIDMAX___5 = 55,
    KERN_CORE_PATTERN___5 = 56,
    KERN_PANIC_ON_OOPS___5 = 57,
    KERN_HPPA_PWRSW___5 = 58,
    KERN_HPPA_UNALIGNED___5 = 59,
    KERN_PRINTK_RATELIMIT___5 = 60,
    KERN_PRINTK_RATELIMIT_BURST___5 = 61,
    KERN_PTY___5 = 62,
    KERN_NGROUPS_MAX___5 = 63,
    KERN_SPARC_SCONS_PWROFF___5 = 64,
    KERN_HZ_TIMER___5 = 65,
    KERN_UNKNOWN_NMI_PANIC___5 = 66,
    KERN_BOOTLOADER_TYPE___5 = 67,
    KERN_RANDOMIZE___5 = 68,
    KERN_SETUID_DUMPABLE___5 = 69,
    KERN_SPIN_RETRY___5 = 70,
    KERN_ACPI_VIDEO_FLAGS___5 = 71,
    KERN_IA64_UNALIGNED___5 = 72,
    KERN_COMPAT_LOG___5 = 73,
    KERN_MAX_LOCK_DEPTH___5 = 74,
    KERN_NMI_WATCHDOG___5 = 75,
    KERN_PANIC_ON_NMI___5 = 76
} ;
enum __anonenum_123___3 {
    VM_UNUSED1___5 = 1,
    VM_UNUSED2___5 = 2,
    VM_UNUSED3___5 = 3,
    VM_UNUSED4___5 = 4,
    VM_OVERCOMMIT_MEMORY___5 = 5,
    VM_UNUSED5___5 = 6,
    VM_UNUSED7___5 = 7,
    VM_UNUSED8___5 = 8,
    VM_UNUSED9___5 = 9,
    VM_PAGE_CLUSTER___5 = 10,
    VM_DIRTY_BACKGROUND___5 = 11,
    VM_DIRTY_RATIO___5 = 12,
    VM_DIRTY_WB_CS___5 = 13,
    VM_DIRTY_EXPIRE_CS___5 = 14,
    VM_NR_PDFLUSH_THREADS___5 = 15,
    VM_OVERCOMMIT_RATIO___5 = 16,
    VM_PAGEBUF___5 = 17,
    VM_HUGETLB_PAGES___5 = 18,
    VM_SWAPPINESS___5 = 19,
    VM_LOWMEM_RESERVE_RATIO___5 = 20,
    VM_MIN_FREE_KBYTES___5 = 21,
    VM_MAX_MAP_COUNT___5 = 22,
    VM_LAPTOP_MODE___5 = 23,
    VM_BLOCK_DUMP___5 = 24,
    VM_HUGETLB_GROUP___5 = 25,
    VM_VFS_CACHE_PRESSURE___5 = 26,
    VM_LEGACY_VA_LAYOUT___5 = 27,
    VM_SWAP_TOKEN_TIMEOUT___5 = 28,
    VM_DROP_PAGECACHE___5 = 29,
    VM_PERCPU_PAGELIST_FRACTION___5 = 30,
    VM_ZONE_RECLAIM_MODE___5 = 31,
    VM_MIN_UNMAPPED___5 = 32,
    VM_PANIC_ON_OOM___5 = 33,
    VM_VDSO_ENABLED___5 = 34,
    VM_MIN_SLAB___5 = 35
} ;
enum __anonenum_124___3 {
    NET_CORE___5 = 1,
    NET_ETHER___5 = 2,
    NET_802___5 = 3,
    NET_UNIX___5 = 4,
    NET_IPV4___5 = 5,
    NET_IPX___5 = 6,
    NET_ATALK___5 = 7,
    NET_NETROM___5 = 8,
    NET_AX25___5 = 9,
    NET_BRIDGE___5 = 10,
    NET_ROSE___5 = 11,
    NET_IPV6___5 = 12,
    NET_X25___5 = 13,
    NET_TR___5 = 14,
    NET_DECNET___5 = 15,
    NET_ECONET___5 = 16,
    NET_SCTP___5 = 17,
    NET_LLC___5 = 18,
    NET_NETFILTER___5 = 19,
    NET_DCCP___5 = 20,
    NET_IRDA___5 = 412
} ;
enum __anonenum_125___5 {
    RANDOM_POOLSIZE___5 = 1,
    RANDOM_ENTROPY_COUNT___5 = 2,
    RANDOM_READ_THRESH___5 = 3,
    RANDOM_WRITE_THRESH___5 = 4,
    RANDOM_BOOT_ID___5 = 5,
    RANDOM_UUID___5 = 6
} ;
enum __anonenum_126___5 {
    PTY_MAX___5 = 1,
    PTY_NR___5 = 2
} ;
enum __anonenum_127___5 {
    BUS_ISA_MEM_BASE___5 = 1,
    BUS_ISA_PORT_BASE___5 = 2,
    BUS_ISA_PORT_SHIFT___5 = 3
} ;
enum __anonenum_128___5 {
    NET_CORE_WMEM_MAX___5 = 1,
    NET_CORE_RMEM_MAX___5 = 2,
    NET_CORE_WMEM_DEFAULT___5 = 3,
    NET_CORE_RMEM_DEFAULT___5 = 4,
    NET_CORE_MAX_BACKLOG___5 = 6,
    NET_CORE_FASTROUTE___5 = 7,
    NET_CORE_MSG_COST___5 = 8,
    NET_CORE_MSG_BURST___5 = 9,
    NET_CORE_OPTMEM_MAX___5 = 10,
    NET_CORE_HOT_LIST_LENGTH___5 = 11,
    NET_CORE_DIVERT_VERSION___5 = 12,
    NET_CORE_NO_CONG_THRESH___5 = 13,
    NET_CORE_NO_CONG___5 = 14,
    NET_CORE_LO_CONG___5 = 15,
    NET_CORE_MOD_CONG___5 = 16,
    NET_CORE_DEV_WEIGHT___5 = 17,
    NET_CORE_SOMAXCONN___5 = 18,
    NET_CORE_BUDGET___5 = 19,
    NET_CORE_AEVENT_ETIME___5 = 20,
    NET_CORE_AEVENT_RSEQTH___5 = 21,
    NET_CORE_WARNINGS___5 = 22
} ;
enum __anonenum_129___5 {
    NET_UNIX_DESTROY_DELAY___5 = 1,
    NET_UNIX_DELETE_DELAY___5 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___5 = 3
} ;
enum __anonenum_130___5 {
    NET_NF_CONNTRACK_MAX___5 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___5 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___5 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___5 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___5 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___5 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___5 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___5 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___5 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___5 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___5 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___5 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___5 = 13,
    NET_NF_CONNTRACK_BUCKETS___5 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___5 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___5 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___5 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___5 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___5 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___5 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___5 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___5 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___5 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___5 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___5 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___5 = 26,
    NET_NF_CONNTRACK_COUNT___5 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___5 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___5 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___5 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___5 = 31,
    NET_NF_CONNTRACK_CHECKSUM___5 = 32
} ;
enum __anonenum_131___5 {
    NET_IPV4_FORWARD___5 = 8,
    NET_IPV4_DYNADDR___5 = 9,
    NET_IPV4_CONF___5 = 16,
    NET_IPV4_NEIGH___5 = 17,
    NET_IPV4_ROUTE___5 = 18,
    NET_IPV4_FIB_HASH___5 = 19,
    NET_IPV4_NETFILTER___5 = 20,
    NET_IPV4_TCP_TIMESTAMPS___5 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___5 = 34,
    NET_IPV4_TCP_SACK___5 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___5 = 36,
    NET_IPV4_DEFAULT_TTL___5 = 37,
    NET_IPV4_AUTOCONFIG___5 = 38,
    NET_IPV4_NO_PMTU_DISC___5 = 39,
    NET_IPV4_TCP_SYN_RETRIES___5 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___5 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___5 = 42,
    NET_IPV4_IPFRAG_TIME___5 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___5 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___5 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___5 = 46,
    NET_IPV4_TCP_RETRIES1___5 = 47,
    NET_IPV4_TCP_RETRIES2___5 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___5 = 49,
    NET_IPV4_IP_MASQ_DEBUG___5 = 50,
    NET_TCP_SYNCOOKIES___5 = 51,
    NET_TCP_STDURG___5 = 52,
    NET_TCP_RFC1337___5 = 53,
    NET_TCP_SYN_TAILDROP___5 = 54,
    NET_TCP_MAX_SYN_BACKLOG___5 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___5 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___5 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___5 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___5 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___5 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___5 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___5 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___5 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___5 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___5 = 65,
    NET_TCP_TW_RECYCLE___5 = 66,
    NET_IPV4_ALWAYS_DEFRAG___5 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___5 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___5 = 69,
    NET_IPV4_INET_PEER_MINTTL___5 = 70,
    NET_IPV4_INET_PEER_MAXTTL___5 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___5 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___5 = 73,
    NET_TCP_ORPHAN_RETRIES___5 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___5 = 75,
    NET_TCP_SYNACK_RETRIES___5 = 76,
    NET_TCP_MAX_ORPHANS___5 = 77,
    NET_TCP_MAX_TW_BUCKETS___5 = 78,
    NET_TCP_FACK___5 = 79,
    NET_TCP_REORDERING___5 = 80,
    NET_TCP_ECN___5 = 81,
    NET_TCP_DSACK___5 = 82,
    NET_TCP_MEM___5 = 83,
    NET_TCP_WMEM___5 = 84,
    NET_TCP_RMEM___5 = 85,
    NET_TCP_APP_WIN___5 = 86,
    NET_TCP_ADV_WIN_SCALE___5 = 87,
    NET_IPV4_NONLOCAL_BIND___5 = 88,
    NET_IPV4_ICMP_RATELIMIT___5 = 89,
    NET_IPV4_ICMP_RATEMASK___5 = 90,
    NET_TCP_TW_REUSE___5 = 91,
    NET_TCP_FRTO___5 = 92,
    NET_TCP_LOW_LATENCY___5 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___5 = 94,
    NET_IPV4_IGMP_MAX_MSF___5 = 96,
    NET_TCP_NO_METRICS_SAVE___5 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___5 = 105,
    NET_TCP_MODERATE_RCVBUF___5 = 106,
    NET_TCP_TSO_WIN_DIVISOR___5 = 107,
    NET_TCP_BIC_BETA___5 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___5 = 109,
    NET_TCP_CONG_CONTROL___5 = 110,
    NET_TCP_ABC___5 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___5 = 112,
    NET_TCP_MTU_PROBING___5 = 113,
    NET_TCP_BASE_MSS___5 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___5 = 115,
    NET_TCP_DMA_COPYBREAK___5 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___5 = 117,
    NET_CIPSOV4_CACHE_ENABLE___5 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___5 = 119,
    NET_CIPSOV4_RBM_OPTFMT___5 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___5 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___5 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___5 = 123,
    NET_TCP_MAX_SSTHRESH___5 = 124,
    NET_TCP_FRTO_RESPONSE___5 = 125
} ;
enum __anonenum_132___5 {
    NET_IPV4_ROUTE_FLUSH___5 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___5 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___5 = 3,
    NET_IPV4_ROUTE_GC_THRESH___5 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___5 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___5 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___5 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___5 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___5 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___5 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___5 = 11,
    NET_IPV4_ROUTE_ERROR_COST___5 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___5 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___5 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___5 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___5 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___5 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___5 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___5 = 19
} ;
enum __anonenum_133___5 {
    NET_PROTO_CONF_ALL___5 = -2,
    NET_PROTO_CONF_DEFAULT___5 = -3
} ;
enum __anonenum_134___5 {
    NET_IPV4_CONF_FORWARDING___5 = 1,
    NET_IPV4_CONF_MC_FORWARDING___5 = 2,
    NET_IPV4_CONF_PROXY_ARP___5 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___5 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___5 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___5 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___5 = 7,
    NET_IPV4_CONF_RP_FILTER___5 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___5 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___5 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___5 = 11,
    NET_IPV4_CONF_TAG___5 = 12,
    NET_IPV4_CONF_ARPFILTER___5 = 13,
    NET_IPV4_CONF_MEDIUM_ID___5 = 14,
    NET_IPV4_CONF_NOXFRM___5 = 15,
    NET_IPV4_CONF_NOPOLICY___5 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___5 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___5 = 18,
    NET_IPV4_CONF_ARP_IGNORE___5 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___5 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___5 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___5 = 22,
    __NET_IPV4_CONF_MAX___5 = 23
} ;
enum __anonenum_135___5 {
    NET_IPV4_NF_CONNTRACK_MAX___5 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___5 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___5 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___5 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___5 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___5 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___5 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___5 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___5 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___5 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___5 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___5 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___5 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___5 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___5 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___5 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___5 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___5 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___5 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___5 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___5 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___5 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___5 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___5 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___5 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___5 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___5 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___5 = 28
} ;
enum __anonenum_136___5 {
    NET_IPV6_CONF___5 = 16,
    NET_IPV6_NEIGH___5 = 17,
    NET_IPV6_ROUTE___5 = 18,
    NET_IPV6_ICMP___5 = 19,
    NET_IPV6_BINDV6ONLY___5 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___5 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___5 = 22,
    NET_IPV6_IP6FRAG_TIME___5 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___5 = 24,
    NET_IPV6_MLD_MAX_MSF___5 = 25
} ;
enum __anonenum_137___5 {
    NET_IPV6_ROUTE_FLUSH___5 = 1,
    NET_IPV6_ROUTE_GC_THRESH___5 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___5 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___5 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___5 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___5 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___5 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___5 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___5 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___5 = 10
} ;
enum __anonenum_138___5 {
    NET_IPV6_FORWARDING___5 = 1,
    NET_IPV6_HOP_LIMIT___5 = 2,
    NET_IPV6_MTU___5 = 3,
    NET_IPV6_ACCEPT_RA___5 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___5 = 5,
    NET_IPV6_AUTOCONF___5 = 6,
    NET_IPV6_DAD_TRANSMITS___5 = 7,
    NET_IPV6_RTR_SOLICITS___5 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___5 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___5 = 10,
    NET_IPV6_USE_TEMPADDR___5 = 11,
    NET_IPV6_TEMP_VALID_LFT___5 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___5 = 13,
    NET_IPV6_REGEN_MAX_RETRY___5 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___5 = 15,
    NET_IPV6_MAX_ADDRESSES___5 = 16,
    NET_IPV6_FORCE_MLD_VERSION___5 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___5 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___5 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___5 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___5 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___5 = 22,
    NET_IPV6_PROXY_NDP___5 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___5 = 25,
    __NET_IPV6_MAX___5 = 26
} ;
enum __anonenum_139___5 {
    NET_IPV6_ICMP_RATELIMIT___5 = 1
} ;
enum __anonenum_140___5 {
    NET_NEIGH_MCAST_SOLICIT___5 = 1,
    NET_NEIGH_UCAST_SOLICIT___5 = 2,
    NET_NEIGH_APP_SOLICIT___5 = 3,
    NET_NEIGH_RETRANS_TIME___5 = 4,
    NET_NEIGH_REACHABLE_TIME___5 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___5 = 6,
    NET_NEIGH_GC_STALE_TIME___5 = 7,
    NET_NEIGH_UNRES_QLEN___5 = 8,
    NET_NEIGH_PROXY_QLEN___5 = 9,
    NET_NEIGH_ANYCAST_DELAY___5 = 10,
    NET_NEIGH_PROXY_DELAY___5 = 11,
    NET_NEIGH_LOCKTIME___5 = 12,
    NET_NEIGH_GC_INTERVAL___5 = 13,
    NET_NEIGH_GC_THRESH1___5 = 14,
    NET_NEIGH_GC_THRESH2___5 = 15,
    NET_NEIGH_GC_THRESH3___5 = 16,
    NET_NEIGH_RETRANS_TIME_MS___5 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___5 = 18,
    __NET_NEIGH_MAX___5 = 19
} ;
enum __anonenum_141___5 {
    NET_DCCP_DEFAULT___5 = 1
} ;
enum __anonenum_142___5 {
    NET_IPX_PPROP_BROADCASTING___5 = 1,
    NET_IPX_FORWARDING___5 = 2
} ;
enum __anonenum_143___5 {
    NET_LLC2___5 = 1,
    NET_LLC_STATION___5 = 2
} ;
enum __anonenum_144___5 {
    NET_LLC2_TIMEOUT___5 = 1
} ;
enum __anonenum_145___5 {
    NET_LLC_STATION_ACK_TIMEOUT___5 = 1
} ;
enum __anonenum_146___5 {
    NET_LLC2_ACK_TIMEOUT___5 = 1,
    NET_LLC2_P_TIMEOUT___5 = 2,
    NET_LLC2_REJ_TIMEOUT___5 = 3,
    NET_LLC2_BUSY_TIMEOUT___5 = 4
} ;
enum __anonenum_147___5 {
    NET_ATALK_AARP_EXPIRY_TIME___5 = 1,
    NET_ATALK_AARP_TICK_TIME___5 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___5 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___5 = 4
} ;
enum __anonenum_148___5 {
    NET_NETROM_DEFAULT_PATH_QUALITY___5 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___5 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___5 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___5 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___5 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___5 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___5 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___5 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___5 = 9,
    NET_NETROM_ROUTING_CONTROL___5 = 10,
    NET_NETROM_LINK_FAILS_COUNT___5 = 11,
    NET_NETROM_RESET___5 = 12
} ;
enum __anonenum_149___5 {
    NET_AX25_IP_DEFAULT_MODE___5 = 1,
    NET_AX25_DEFAULT_MODE___5 = 2,
    NET_AX25_BACKOFF_TYPE___5 = 3,
    NET_AX25_CONNECT_MODE___5 = 4,
    NET_AX25_STANDARD_WINDOW___5 = 5,
    NET_AX25_EXTENDED_WINDOW___5 = 6,
    NET_AX25_T1_TIMEOUT___5 = 7,
    NET_AX25_T2_TIMEOUT___5 = 8,
    NET_AX25_T3_TIMEOUT___5 = 9,
    NET_AX25_IDLE_TIMEOUT___5 = 10,
    NET_AX25_N2___5 = 11,
    NET_AX25_PACLEN___5 = 12,
    NET_AX25_PROTOCOL___5 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___5 = 14
} ;
enum __anonenum_150___5 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___5 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___5 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___5 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___5 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___5 = 5,
    NET_ROSE_ROUTING_CONTROL___5 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___5 = 7,
    NET_ROSE_MAX_VCS___5 = 8,
    NET_ROSE_WINDOW_SIZE___5 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___5 = 10
} ;
enum __anonenum_151___5 {
    NET_X25_RESTART_REQUEST_TIMEOUT___5 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___5 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___5 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___5 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___5 = 5,
    NET_X25_FORWARD___5 = 6
} ;
enum __anonenum_152___5 {
    NET_TR_RIF_TIMEOUT___5 = 1
} ;
enum __anonenum_153___5 {
    NET_DECNET_NODE_TYPE___5 = 1,
    NET_DECNET_NODE_ADDRESS___5 = 2,
    NET_DECNET_NODE_NAME___5 = 3,
    NET_DECNET_DEFAULT_DEVICE___5 = 4,
    NET_DECNET_TIME_WAIT___5 = 5,
    NET_DECNET_DN_COUNT___5 = 6,
    NET_DECNET_DI_COUNT___5 = 7,
    NET_DECNET_DR_COUNT___5 = 8,
    NET_DECNET_DST_GC_INTERVAL___5 = 9,
    NET_DECNET_CONF___5 = 10,
    NET_DECNET_NO_FC_MAX_CWND___5 = 11,
    NET_DECNET_MEM___5 = 12,
    NET_DECNET_RMEM___5 = 13,
    NET_DECNET_WMEM___5 = 14,
    NET_DECNET_DEBUG_LEVEL___5 = 255
} ;
enum __anonenum_154___5 {
    NET_DECNET_CONF_LOOPBACK___5 = -2,
    NET_DECNET_CONF_DDCMP___5 = -3,
    NET_DECNET_CONF_PPP___5 = -4,
    NET_DECNET_CONF_X25___5 = -5,
    NET_DECNET_CONF_GRE___5 = -6,
    NET_DECNET_CONF_ETHER___5 = -7
} ;
enum __anonenum_155___5 {
    NET_DECNET_CONF_DEV_PRIORITY___5 = 1,
    NET_DECNET_CONF_DEV_T1___5 = 2,
    NET_DECNET_CONF_DEV_T2___5 = 3,
    NET_DECNET_CONF_DEV_T3___5 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___5 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___5 = 6,
    NET_DECNET_CONF_DEV_STATE___5 = 7
} ;
enum __anonenum_156___5 {
    NET_SCTP_RTO_INITIAL___5 = 1,
    NET_SCTP_RTO_MIN___5 = 2,
    NET_SCTP_RTO_MAX___5 = 3,
    NET_SCTP_RTO_ALPHA___5 = 4,
    NET_SCTP_RTO_BETA___5 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___5 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___5 = 7,
    NET_SCTP_PATH_MAX_RETRANS___5 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___5 = 9,
    NET_SCTP_HB_INTERVAL___5 = 10,
    NET_SCTP_PRESERVE_ENABLE___5 = 11,
    NET_SCTP_MAX_BURST___5 = 12,
    NET_SCTP_ADDIP_ENABLE___5 = 13,
    NET_SCTP_PRSCTP_ENABLE___5 = 14,
    NET_SCTP_SNDBUF_POLICY___5 = 15,
    NET_SCTP_SACK_TIMEOUT___5 = 16,
    NET_SCTP_RCVBUF_POLICY___5 = 17
} ;
enum __anonenum_157___5 {
    NET_BRIDGE_NF_CALL_ARPTABLES___5 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___5 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___5 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___5 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___5 = 5
} ;
enum __anonenum_158___5 {
    NET_IRDA_DISCOVERY___5 = 1,
    NET_IRDA_DEVNAME___5 = 2,
    NET_IRDA_DEBUG___5 = 3,
    NET_IRDA_FAST_POLL___5 = 4,
    NET_IRDA_DISCOVERY_SLOTS___5 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___5 = 6,
    NET_IRDA_SLOT_TIMEOUT___5 = 7,
    NET_IRDA_MAX_BAUD_RATE___5 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___5 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___5 = 10,
    NET_IRDA_MAX_TX_WINDOW___5 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___5 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___5 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___5 = 14
} ;
enum __anonenum_159___5 {
    FS_NRINODE___5 = 1,
    FS_STATINODE___5 = 2,
    FS_MAXINODE___5 = 3,
    FS_NRDQUOT___5 = 4,
    FS_MAXDQUOT___5 = 5,
    FS_NRFILE___5 = 6,
    FS_MAXFILE___5 = 7,
    FS_DENTRY___5 = 8,
    FS_NRSUPER___5 = 9,
    FS_MAXSUPER___5 = 10,
    FS_OVERFLOWUID___5 = 11,
    FS_OVERFLOWGID___5 = 12,
    FS_LEASES___5 = 13,
    FS_DIR_NOTIFY___5 = 14,
    FS_LEASE_TIME___5 = 15,
    FS_DQSTATS___5 = 16,
    FS_XFS___5 = 17,
    FS_AIO_NR___5 = 18,
    FS_AIO_MAX_NR___5 = 19,
    FS_INOTIFY___5 = 20,
    FS_OCFS2___5 = 988
} ;
enum __anonenum_160___5 {
    FS_DQ_LOOKUPS___5 = 1,
    FS_DQ_DROPS___5 = 2,
    FS_DQ_READS___5 = 3,
    FS_DQ_WRITES___5 = 4,
    FS_DQ_CACHE_HITS___5 = 5,
    FS_DQ_ALLOCATED___5 = 6,
    FS_DQ_FREE___5 = 7,
    FS_DQ_SYNCS___5 = 8,
    FS_DQ_WARNINGS___5 = 9
} ;
enum __anonenum_161___5 {
    DEV_CDROM___5 = 1,
    DEV_HWMON___5 = 2,
    DEV_PARPORT___5 = 3,
    DEV_RAID___5 = 4,
    DEV_MAC_HID___5 = 5,
    DEV_SCSI___5 = 6,
    DEV_IPMI___5 = 7
} ;
enum __anonenum_162___5 {
    DEV_CDROM_INFO___5 = 1,
    DEV_CDROM_AUTOCLOSE___5 = 2,
    DEV_CDROM_AUTOEJECT___5 = 3,
    DEV_CDROM_DEBUG___5 = 4,
    DEV_CDROM_LOCK___5 = 5,
    DEV_CDROM_CHECK_MEDIA___5 = 6
} ;
enum __anonenum_163___5 {
    DEV_PARPORT_DEFAULT___5 = -3
} ;
enum __anonenum_164___5 {
    DEV_RAID_SPEED_LIMIT_MIN___5 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___5 = 2
} ;
enum __anonenum_165___5 {
    DEV_PARPORT_DEFAULT_TIMESLICE___5 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___5 = 2
} ;
enum __anonenum_166___5 {
    DEV_PARPORT_SPINTIME___5 = 1,
    DEV_PARPORT_BASE_ADDR___5 = 2,
    DEV_PARPORT_IRQ___5 = 3,
    DEV_PARPORT_DMA___5 = 4,
    DEV_PARPORT_MODES___5 = 5,
    DEV_PARPORT_DEVICES___5 = 6,
    DEV_PARPORT_AUTOPROBE___5 = 16
} ;
enum __anonenum_167___3 {
    DEV_PARPORT_DEVICES_ACTIVE___5 = -3
} ;
enum __anonenum_168___3 {
    DEV_PARPORT_DEVICE_TIMESLICE___5 = 1
} ;
enum __anonenum_169___5 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___5 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___5 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___5 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___5 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___5 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___5 = 6
} ;
enum __anonenum_170___3 {
    DEV_SCSI_LOGGING_LEVEL___5 = 1
} ;
enum __anonenum_171___3 {
    DEV_IPMI_POWEROFF_POWERCYCLE___5 = 1
} ;
enum __anonenum_172___5 {
    ABI_DEFHANDLER_COFF___5 = 1,
    ABI_DEFHANDLER_ELF___5 = 2,
    ABI_DEFHANDLER_LCALL7___5 = 3,
    ABI_DEFHANDLER_LIBCSO___5 = 4,
    ABI_TRACE___5 = 5,
    ABI_FAKE_UTSNAME___5 = 6
} ;
enum __anonenum_175___1 {
    IOCB_CMD_PREAD___5 = 0,
    IOCB_CMD_PWRITE___5 = 1,
    IOCB_CMD_FSYNC___5 = 2,
    IOCB_CMD_FDSYNC___5 = 3,
    IOCB_CMD_NOOP___5 = 6,
    IOCB_CMD_PREADV___5 = 7,
    IOCB_CMD_PWRITEV___5 = 8
} ;
enum __anonenum_179___1 {
    IRQTF_RUNTHREAD___5 = 0,
    IRQTF_DIED___5 = 1,
    IRQTF_WARNED___5 = 2
} ;
enum __anonenum_180___1 {
    HI_SOFTIRQ___5 = 0,
    TIMER_SOFTIRQ___5 = 1,
    NET_TX_SOFTIRQ___5 = 2,
    NET_RX_SOFTIRQ___5 = 3,
    BLOCK_SOFTIRQ___5 = 4,
    TASKLET_SOFTIRQ___5 = 5,
    SCHED_SOFTIRQ___5 = 6,
    HRTIMER_SOFTIRQ___5 = 7,
    RCU_SOFTIRQ___5 = 8,
    NR_SOFTIRQS___5 = 9
} ;
enum __anonenum_181___3 {
    TASKLET_STATE_SCHED___5 = 0,
    TASKLET_STATE_RUN___5 = 1
} ;
enum __anonenum_183___3 {
    QIF_BLIMITS_B___5 = 0,
    QIF_SPACE_B___5 = 1,
    QIF_ILIMITS_B___5 = 2,
    QIF_INODES_B___5 = 3,
    QIF_BTIME_B___5 = 4,
    QIF_ITIME_B___5 = 5
} ;
enum __anonenum_184___3 {
    QUOTA_NL_C_UNSPEC___5 = 0,
    QUOTA_NL_C_WARNING___5 = 1,
    __QUOTA_NL_C_MAX___5 = 2
} ;
enum __anonenum_185___3 {
    QUOTA_NL_A_UNSPEC___5 = 0,
    QUOTA_NL_A_QTYPE___5 = 1,
    QUOTA_NL_A_EXCESS_ID___5 = 2,
    QUOTA_NL_A_WARNING___5 = 3,
    QUOTA_NL_A_DEV_MAJOR___5 = 4,
    QUOTA_NL_A_DEV_MINOR___5 = 5,
    QUOTA_NL_A_CAUSED_ID___5 = 6,
    __QUOTA_NL_A_MAX___5 = 7
} ;
enum __anonenum_186___4 {
    _DQUOT_USAGE_ENABLED___5 = 0,
    _DQUOT_LIMITS_ENABLED___5 = 1,
    _DQUOT_SUSPENDED___5 = 2,
    _DQUOT_STATE_FLAGS___5 = 3
} ;
enum __anonenum_193___4 {
    SB_UNFROZEN___5 = 0,
    SB_FREEZE_WRITE___5 = 1,
    SB_FREEZE_TRANS___5 = 2
} ;
enum __anonenum_194___4 {
    DIO_LOCKING___5 = 1,
    DIO_NO_LOCKING___5 = 2,
    DIO_OWN_LOCKING___5 = 3
} ;
struct usb_class {
   struct kref kref ;
   struct class *class ;
};
enum __anonenum_4___6 {
    false___6 = 0,
    true___6 = 1
} ;
enum __anonenum_9___0 {
    DUMP_PREFIX_NONE___6 = 0,
    DUMP_PREFIX_ADDRESS___6 = 1,
    DUMP_PREFIX_OFFSET___6 = 2
} ;
enum __anonenum_21___5 {
    PG_LEVEL_NONE___6 = 0,
    PG_LEVEL_4K___6 = 1,
    PG_LEVEL_2M___6 = 2,
    PG_LEVEL_1G___6 = 3,
    PG_LEVEL_NUM___6 = 4
} ;
enum __anonenum_25___1 {
    GATE_INTERRUPT___6 = 14,
    GATE_TRAP___6 = 15,
    GATE_CALL___6 = 12,
    GATE_TASK___6 = 5
} ;
enum __anonenum_26___1 {
    DESC_TSS___6 = 9,
    DESC_LDT___6 = 2,
    DESCTYPE_S___6 = 16
} ;
enum __anonenum_27___1 {
    ADDR_NO_RANDOMIZE___6 = 262144,
    FDPIC_FUNCPTRS___6 = 524288,
    MMAP_PAGE_ZERO___6 = 1048576,
    ADDR_COMPAT_LAYOUT___6 = 2097152,
    READ_IMPLIES_EXEC___6 = 4194304,
    ADDR_LIMIT_32BIT___6 = 8388608,
    SHORT_INODE___6 = 16777216,
    WHOLE_SECONDS___6 = 33554432,
    STICKY_TIMEOUTS___6 = 67108864,
    ADDR_LIMIT_3GB___6 = 134217728
} ;
enum __anonenum_28___0 {
    PER_LINUX___6 = 0,
    PER_LINUX_32BIT___6 = 8388608,
    PER_LINUX_FDPIC___6 = 524288,
    PER_SVR4___6 = 68157441,
    PER_SVR3___6 = 83886082,
    PER_SCOSVR3___6 = 117440515,
    PER_OSR5___6 = 100663299,
    PER_WYSEV386___6 = 83886084,
    PER_ISCR4___6 = 67108869,
    PER_BSD___6 = 6,
    PER_SUNOS___6 = 67108870,
    PER_XENIX___6 = 83886087,
    PER_LINUX32___6 = 8,
    PER_LINUX32_3GB___6 = 134217736,
    PER_IRIX32___6 = 67108873,
    PER_IRIXN32___6 = 67108874,
    PER_IRIX64___6 = 67108875,
    PER_RISCOS___6 = 12,
    PER_SOLARIS___6 = 67108877,
    PER_UW7___6 = 68157454,
    PER_OSF4___6 = 15,
    PER_HPUX___6 = 16,
    PER_MASK___6 = 255
} ;
union __anonunion_d_39___1 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_113___1 {
    CTL_KERN___6 = 1,
    CTL_VM___6 = 2,
    CTL_NET___6 = 3,
    CTL_PROC___6 = 4,
    CTL_FS___6 = 5,
    CTL_DEBUG___6 = 6,
    CTL_DEV___6 = 7,
    CTL_BUS___6 = 8,
    CTL_ABI___6 = 9,
    CTL_CPU___6 = 10,
    CTL_ARLAN___6 = 254,
    CTL_S390DBF___6 = 5677,
    CTL_SUNRPC___6 = 7249,
    CTL_PM___6 = 9899,
    CTL_FRV___6 = 9898
} ;
enum __anonenum_114___1 {
    CTL_BUS_ISA___6 = 1
} ;
enum __anonenum_115___1 {
    INOTIFY_MAX_USER_INSTANCES___6 = 1,
    INOTIFY_MAX_USER_WATCHES___6 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___6 = 3
} ;
enum __anonenum_116___1 {
    KERN_OSTYPE___6 = 1,
    KERN_OSRELEASE___6 = 2,
    KERN_OSREV___6 = 3,
    KERN_VERSION___6 = 4,
    KERN_SECUREMASK___6 = 5,
    KERN_PROF___6 = 6,
    KERN_NODENAME___6 = 7,
    KERN_DOMAINNAME___6 = 8,
    KERN_PANIC___6 = 15,
    KERN_REALROOTDEV___6 = 16,
    KERN_SPARC_REBOOT___6 = 21,
    KERN_CTLALTDEL___6 = 22,
    KERN_PRINTK___6 = 23,
    KERN_NAMETRANS___6 = 24,
    KERN_PPC_HTABRECLAIM___6 = 25,
    KERN_PPC_ZEROPAGED___6 = 26,
    KERN_PPC_POWERSAVE_NAP___6 = 27,
    KERN_MODPROBE___6 = 28,
    KERN_SG_BIG_BUFF___6 = 29,
    KERN_ACCT___6 = 30,
    KERN_PPC_L2CR___6 = 31,
    KERN_RTSIGNR___6 = 32,
    KERN_RTSIGMAX___6 = 33,
    KERN_SHMMAX___6 = 34,
    KERN_MSGMAX___6 = 35,
    KERN_MSGMNB___6 = 36,
    KERN_MSGPOOL___6 = 37,
    KERN_SYSRQ___6 = 38,
    KERN_MAX_THREADS___6 = 39,
    KERN_RANDOM___6 = 40,
    KERN_SHMALL___6 = 41,
    KERN_MSGMNI___6 = 42,
    KERN_SEM___6 = 43,
    KERN_SPARC_STOP_A___6 = 44,
    KERN_SHMMNI___6 = 45,
    KERN_OVERFLOWUID___6 = 46,
    KERN_OVERFLOWGID___6 = 47,
    KERN_SHMPATH___6 = 48,
    KERN_HOTPLUG___6 = 49,
    KERN_IEEE_EMULATION_WARNINGS___6 = 50,
    KERN_S390_USER_DEBUG_LOGGING___6 = 51,
    KERN_CORE_USES_PID___6 = 52,
    KERN_TAINTED___6 = 53,
    KERN_CADPID___6 = 54,
    KERN_PIDMAX___6 = 55,
    KERN_CORE_PATTERN___6 = 56,
    KERN_PANIC_ON_OOPS___6 = 57,
    KERN_HPPA_PWRSW___6 = 58,
    KERN_HPPA_UNALIGNED___6 = 59,
    KERN_PRINTK_RATELIMIT___6 = 60,
    KERN_PRINTK_RATELIMIT_BURST___6 = 61,
    KERN_PTY___6 = 62,
    KERN_NGROUPS_MAX___6 = 63,
    KERN_SPARC_SCONS_PWROFF___6 = 64,
    KERN_HZ_TIMER___6 = 65,
    KERN_UNKNOWN_NMI_PANIC___6 = 66,
    KERN_BOOTLOADER_TYPE___6 = 67,
    KERN_RANDOMIZE___6 = 68,
    KERN_SETUID_DUMPABLE___6 = 69,
    KERN_SPIN_RETRY___6 = 70,
    KERN_ACPI_VIDEO_FLAGS___6 = 71,
    KERN_IA64_UNALIGNED___6 = 72,
    KERN_COMPAT_LOG___6 = 73,
    KERN_MAX_LOCK_DEPTH___6 = 74,
    KERN_NMI_WATCHDOG___6 = 75,
    KERN_PANIC_ON_NMI___6 = 76
} ;
enum __anonenum_117___1 {
    VM_UNUSED1___6 = 1,
    VM_UNUSED2___6 = 2,
    VM_UNUSED3___6 = 3,
    VM_UNUSED4___6 = 4,
    VM_OVERCOMMIT_MEMORY___6 = 5,
    VM_UNUSED5___6 = 6,
    VM_UNUSED7___6 = 7,
    VM_UNUSED8___6 = 8,
    VM_UNUSED9___6 = 9,
    VM_PAGE_CLUSTER___6 = 10,
    VM_DIRTY_BACKGROUND___6 = 11,
    VM_DIRTY_RATIO___6 = 12,
    VM_DIRTY_WB_CS___6 = 13,
    VM_DIRTY_EXPIRE_CS___6 = 14,
    VM_NR_PDFLUSH_THREADS___6 = 15,
    VM_OVERCOMMIT_RATIO___6 = 16,
    VM_PAGEBUF___6 = 17,
    VM_HUGETLB_PAGES___6 = 18,
    VM_SWAPPINESS___6 = 19,
    VM_LOWMEM_RESERVE_RATIO___6 = 20,
    VM_MIN_FREE_KBYTES___6 = 21,
    VM_MAX_MAP_COUNT___6 = 22,
    VM_LAPTOP_MODE___6 = 23,
    VM_BLOCK_DUMP___6 = 24,
    VM_HUGETLB_GROUP___6 = 25,
    VM_VFS_CACHE_PRESSURE___6 = 26,
    VM_LEGACY_VA_LAYOUT___6 = 27,
    VM_SWAP_TOKEN_TIMEOUT___6 = 28,
    VM_DROP_PAGECACHE___6 = 29,
    VM_PERCPU_PAGELIST_FRACTION___6 = 30,
    VM_ZONE_RECLAIM_MODE___6 = 31,
    VM_MIN_UNMAPPED___6 = 32,
    VM_PANIC_ON_OOM___6 = 33,
    VM_VDSO_ENABLED___6 = 34,
    VM_MIN_SLAB___6 = 35
} ;
enum __anonenum_118___1 {
    NET_CORE___6 = 1,
    NET_ETHER___6 = 2,
    NET_802___6 = 3,
    NET_UNIX___6 = 4,
    NET_IPV4___6 = 5,
    NET_IPX___6 = 6,
    NET_ATALK___6 = 7,
    NET_NETROM___6 = 8,
    NET_AX25___6 = 9,
    NET_BRIDGE___6 = 10,
    NET_ROSE___6 = 11,
    NET_IPV6___6 = 12,
    NET_X25___6 = 13,
    NET_TR___6 = 14,
    NET_DECNET___6 = 15,
    NET_ECONET___6 = 16,
    NET_SCTP___6 = 17,
    NET_LLC___6 = 18,
    NET_NETFILTER___6 = 19,
    NET_DCCP___6 = 20,
    NET_IRDA___6 = 412
} ;
enum __anonenum_119___2 {
    RANDOM_POOLSIZE___6 = 1,
    RANDOM_ENTROPY_COUNT___6 = 2,
    RANDOM_READ_THRESH___6 = 3,
    RANDOM_WRITE_THRESH___6 = 4,
    RANDOM_BOOT_ID___6 = 5,
    RANDOM_UUID___6 = 6
} ;
enum __anonenum_120___4 {
    PTY_MAX___6 = 1,
    PTY_NR___6 = 2
} ;
enum __anonenum_121___4 {
    BUS_ISA_MEM_BASE___6 = 1,
    BUS_ISA_PORT_BASE___6 = 2,
    BUS_ISA_PORT_SHIFT___6 = 3
} ;
enum __anonenum_122___4 {
    NET_CORE_WMEM_MAX___6 = 1,
    NET_CORE_RMEM_MAX___6 = 2,
    NET_CORE_WMEM_DEFAULT___6 = 3,
    NET_CORE_RMEM_DEFAULT___6 = 4,
    NET_CORE_MAX_BACKLOG___6 = 6,
    NET_CORE_FASTROUTE___6 = 7,
    NET_CORE_MSG_COST___6 = 8,
    NET_CORE_MSG_BURST___6 = 9,
    NET_CORE_OPTMEM_MAX___6 = 10,
    NET_CORE_HOT_LIST_LENGTH___6 = 11,
    NET_CORE_DIVERT_VERSION___6 = 12,
    NET_CORE_NO_CONG_THRESH___6 = 13,
    NET_CORE_NO_CONG___6 = 14,
    NET_CORE_LO_CONG___6 = 15,
    NET_CORE_MOD_CONG___6 = 16,
    NET_CORE_DEV_WEIGHT___6 = 17,
    NET_CORE_SOMAXCONN___6 = 18,
    NET_CORE_BUDGET___6 = 19,
    NET_CORE_AEVENT_ETIME___6 = 20,
    NET_CORE_AEVENT_RSEQTH___6 = 21,
    NET_CORE_WARNINGS___6 = 22
} ;
enum __anonenum_123___4 {
    NET_UNIX_DESTROY_DELAY___6 = 1,
    NET_UNIX_DELETE_DELAY___6 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___6 = 3
} ;
enum __anonenum_124___4 {
    NET_NF_CONNTRACK_MAX___6 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___6 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___6 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___6 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___6 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___6 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___6 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___6 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___6 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___6 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___6 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___6 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___6 = 13,
    NET_NF_CONNTRACK_BUCKETS___6 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___6 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___6 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___6 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___6 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___6 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___6 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___6 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___6 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___6 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___6 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___6 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___6 = 26,
    NET_NF_CONNTRACK_COUNT___6 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___6 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___6 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___6 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___6 = 31,
    NET_NF_CONNTRACK_CHECKSUM___6 = 32
} ;
enum __anonenum_125___6 {
    NET_IPV4_FORWARD___6 = 8,
    NET_IPV4_DYNADDR___6 = 9,
    NET_IPV4_CONF___6 = 16,
    NET_IPV4_NEIGH___6 = 17,
    NET_IPV4_ROUTE___6 = 18,
    NET_IPV4_FIB_HASH___6 = 19,
    NET_IPV4_NETFILTER___6 = 20,
    NET_IPV4_TCP_TIMESTAMPS___6 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___6 = 34,
    NET_IPV4_TCP_SACK___6 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___6 = 36,
    NET_IPV4_DEFAULT_TTL___6 = 37,
    NET_IPV4_AUTOCONFIG___6 = 38,
    NET_IPV4_NO_PMTU_DISC___6 = 39,
    NET_IPV4_TCP_SYN_RETRIES___6 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___6 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___6 = 42,
    NET_IPV4_IPFRAG_TIME___6 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___6 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___6 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___6 = 46,
    NET_IPV4_TCP_RETRIES1___6 = 47,
    NET_IPV4_TCP_RETRIES2___6 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___6 = 49,
    NET_IPV4_IP_MASQ_DEBUG___6 = 50,
    NET_TCP_SYNCOOKIES___6 = 51,
    NET_TCP_STDURG___6 = 52,
    NET_TCP_RFC1337___6 = 53,
    NET_TCP_SYN_TAILDROP___6 = 54,
    NET_TCP_MAX_SYN_BACKLOG___6 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___6 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___6 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___6 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___6 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___6 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___6 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___6 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___6 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___6 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___6 = 65,
    NET_TCP_TW_RECYCLE___6 = 66,
    NET_IPV4_ALWAYS_DEFRAG___6 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___6 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___6 = 69,
    NET_IPV4_INET_PEER_MINTTL___6 = 70,
    NET_IPV4_INET_PEER_MAXTTL___6 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___6 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___6 = 73,
    NET_TCP_ORPHAN_RETRIES___6 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___6 = 75,
    NET_TCP_SYNACK_RETRIES___6 = 76,
    NET_TCP_MAX_ORPHANS___6 = 77,
    NET_TCP_MAX_TW_BUCKETS___6 = 78,
    NET_TCP_FACK___6 = 79,
    NET_TCP_REORDERING___6 = 80,
    NET_TCP_ECN___6 = 81,
    NET_TCP_DSACK___6 = 82,
    NET_TCP_MEM___6 = 83,
    NET_TCP_WMEM___6 = 84,
    NET_TCP_RMEM___6 = 85,
    NET_TCP_APP_WIN___6 = 86,
    NET_TCP_ADV_WIN_SCALE___6 = 87,
    NET_IPV4_NONLOCAL_BIND___6 = 88,
    NET_IPV4_ICMP_RATELIMIT___6 = 89,
    NET_IPV4_ICMP_RATEMASK___6 = 90,
    NET_TCP_TW_REUSE___6 = 91,
    NET_TCP_FRTO___6 = 92,
    NET_TCP_LOW_LATENCY___6 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___6 = 94,
    NET_IPV4_IGMP_MAX_MSF___6 = 96,
    NET_TCP_NO_METRICS_SAVE___6 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___6 = 105,
    NET_TCP_MODERATE_RCVBUF___6 = 106,
    NET_TCP_TSO_WIN_DIVISOR___6 = 107,
    NET_TCP_BIC_BETA___6 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___6 = 109,
    NET_TCP_CONG_CONTROL___6 = 110,
    NET_TCP_ABC___6 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___6 = 112,
    NET_TCP_MTU_PROBING___6 = 113,
    NET_TCP_BASE_MSS___6 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___6 = 115,
    NET_TCP_DMA_COPYBREAK___6 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___6 = 117,
    NET_CIPSOV4_CACHE_ENABLE___6 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___6 = 119,
    NET_CIPSOV4_RBM_OPTFMT___6 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___6 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___6 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___6 = 123,
    NET_TCP_MAX_SSTHRESH___6 = 124,
    NET_TCP_FRTO_RESPONSE___6 = 125
} ;
enum __anonenum_126___6 {
    NET_IPV4_ROUTE_FLUSH___6 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___6 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___6 = 3,
    NET_IPV4_ROUTE_GC_THRESH___6 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___6 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___6 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___6 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___6 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___6 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___6 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___6 = 11,
    NET_IPV4_ROUTE_ERROR_COST___6 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___6 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___6 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___6 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___6 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___6 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___6 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___6 = 19
} ;
enum __anonenum_127___6 {
    NET_PROTO_CONF_ALL___6 = -2,
    NET_PROTO_CONF_DEFAULT___6 = -3
} ;
enum __anonenum_128___6 {
    NET_IPV4_CONF_FORWARDING___6 = 1,
    NET_IPV4_CONF_MC_FORWARDING___6 = 2,
    NET_IPV4_CONF_PROXY_ARP___6 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___6 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___6 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___6 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___6 = 7,
    NET_IPV4_CONF_RP_FILTER___6 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___6 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___6 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___6 = 11,
    NET_IPV4_CONF_TAG___6 = 12,
    NET_IPV4_CONF_ARPFILTER___6 = 13,
    NET_IPV4_CONF_MEDIUM_ID___6 = 14,
    NET_IPV4_CONF_NOXFRM___6 = 15,
    NET_IPV4_CONF_NOPOLICY___6 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___6 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___6 = 18,
    NET_IPV4_CONF_ARP_IGNORE___6 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___6 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___6 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___6 = 22,
    __NET_IPV4_CONF_MAX___6 = 23
} ;
enum __anonenum_129___6 {
    NET_IPV4_NF_CONNTRACK_MAX___6 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___6 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___6 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___6 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___6 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___6 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___6 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___6 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___6 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___6 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___6 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___6 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___6 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___6 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___6 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___6 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___6 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___6 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___6 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___6 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___6 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___6 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___6 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___6 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___6 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___6 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___6 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___6 = 28
} ;
enum __anonenum_130___6 {
    NET_IPV6_CONF___6 = 16,
    NET_IPV6_NEIGH___6 = 17,
    NET_IPV6_ROUTE___6 = 18,
    NET_IPV6_ICMP___6 = 19,
    NET_IPV6_BINDV6ONLY___6 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___6 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___6 = 22,
    NET_IPV6_IP6FRAG_TIME___6 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___6 = 24,
    NET_IPV6_MLD_MAX_MSF___6 = 25
} ;
enum __anonenum_131___6 {
    NET_IPV6_ROUTE_FLUSH___6 = 1,
    NET_IPV6_ROUTE_GC_THRESH___6 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___6 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___6 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___6 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___6 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___6 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___6 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___6 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___6 = 10
} ;
enum __anonenum_132___6 {
    NET_IPV6_FORWARDING___6 = 1,
    NET_IPV6_HOP_LIMIT___6 = 2,
    NET_IPV6_MTU___6 = 3,
    NET_IPV6_ACCEPT_RA___6 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___6 = 5,
    NET_IPV6_AUTOCONF___6 = 6,
    NET_IPV6_DAD_TRANSMITS___6 = 7,
    NET_IPV6_RTR_SOLICITS___6 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___6 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___6 = 10,
    NET_IPV6_USE_TEMPADDR___6 = 11,
    NET_IPV6_TEMP_VALID_LFT___6 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___6 = 13,
    NET_IPV6_REGEN_MAX_RETRY___6 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___6 = 15,
    NET_IPV6_MAX_ADDRESSES___6 = 16,
    NET_IPV6_FORCE_MLD_VERSION___6 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___6 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___6 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___6 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___6 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___6 = 22,
    NET_IPV6_PROXY_NDP___6 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___6 = 25,
    __NET_IPV6_MAX___6 = 26
} ;
enum __anonenum_133___6 {
    NET_IPV6_ICMP_RATELIMIT___6 = 1
} ;
enum __anonenum_134___6 {
    NET_NEIGH_MCAST_SOLICIT___6 = 1,
    NET_NEIGH_UCAST_SOLICIT___6 = 2,
    NET_NEIGH_APP_SOLICIT___6 = 3,
    NET_NEIGH_RETRANS_TIME___6 = 4,
    NET_NEIGH_REACHABLE_TIME___6 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___6 = 6,
    NET_NEIGH_GC_STALE_TIME___6 = 7,
    NET_NEIGH_UNRES_QLEN___6 = 8,
    NET_NEIGH_PROXY_QLEN___6 = 9,
    NET_NEIGH_ANYCAST_DELAY___6 = 10,
    NET_NEIGH_PROXY_DELAY___6 = 11,
    NET_NEIGH_LOCKTIME___6 = 12,
    NET_NEIGH_GC_INTERVAL___6 = 13,
    NET_NEIGH_GC_THRESH1___6 = 14,
    NET_NEIGH_GC_THRESH2___6 = 15,
    NET_NEIGH_GC_THRESH3___6 = 16,
    NET_NEIGH_RETRANS_TIME_MS___6 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___6 = 18,
    __NET_NEIGH_MAX___6 = 19
} ;
enum __anonenum_135___6 {
    NET_DCCP_DEFAULT___6 = 1
} ;
enum __anonenum_136___6 {
    NET_IPX_PPROP_BROADCASTING___6 = 1,
    NET_IPX_FORWARDING___6 = 2
} ;
enum __anonenum_137___6 {
    NET_LLC2___6 = 1,
    NET_LLC_STATION___6 = 2
} ;
enum __anonenum_138___6 {
    NET_LLC2_TIMEOUT___6 = 1
} ;
enum __anonenum_139___6 {
    NET_LLC_STATION_ACK_TIMEOUT___6 = 1
} ;
enum __anonenum_140___6 {
    NET_LLC2_ACK_TIMEOUT___6 = 1,
    NET_LLC2_P_TIMEOUT___6 = 2,
    NET_LLC2_REJ_TIMEOUT___6 = 3,
    NET_LLC2_BUSY_TIMEOUT___6 = 4
} ;
enum __anonenum_141___6 {
    NET_ATALK_AARP_EXPIRY_TIME___6 = 1,
    NET_ATALK_AARP_TICK_TIME___6 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___6 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___6 = 4
} ;
enum __anonenum_142___6 {
    NET_NETROM_DEFAULT_PATH_QUALITY___6 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___6 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___6 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___6 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___6 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___6 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___6 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___6 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___6 = 9,
    NET_NETROM_ROUTING_CONTROL___6 = 10,
    NET_NETROM_LINK_FAILS_COUNT___6 = 11,
    NET_NETROM_RESET___6 = 12
} ;
enum __anonenum_143___6 {
    NET_AX25_IP_DEFAULT_MODE___6 = 1,
    NET_AX25_DEFAULT_MODE___6 = 2,
    NET_AX25_BACKOFF_TYPE___6 = 3,
    NET_AX25_CONNECT_MODE___6 = 4,
    NET_AX25_STANDARD_WINDOW___6 = 5,
    NET_AX25_EXTENDED_WINDOW___6 = 6,
    NET_AX25_T1_TIMEOUT___6 = 7,
    NET_AX25_T2_TIMEOUT___6 = 8,
    NET_AX25_T3_TIMEOUT___6 = 9,
    NET_AX25_IDLE_TIMEOUT___6 = 10,
    NET_AX25_N2___6 = 11,
    NET_AX25_PACLEN___6 = 12,
    NET_AX25_PROTOCOL___6 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___6 = 14
} ;
enum __anonenum_144___6 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___6 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___6 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___6 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___6 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___6 = 5,
    NET_ROSE_ROUTING_CONTROL___6 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___6 = 7,
    NET_ROSE_MAX_VCS___6 = 8,
    NET_ROSE_WINDOW_SIZE___6 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___6 = 10
} ;
enum __anonenum_145___6 {
    NET_X25_RESTART_REQUEST_TIMEOUT___6 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___6 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___6 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___6 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___6 = 5,
    NET_X25_FORWARD___6 = 6
} ;
enum __anonenum_146___6 {
    NET_TR_RIF_TIMEOUT___6 = 1
} ;
enum __anonenum_147___6 {
    NET_DECNET_NODE_TYPE___6 = 1,
    NET_DECNET_NODE_ADDRESS___6 = 2,
    NET_DECNET_NODE_NAME___6 = 3,
    NET_DECNET_DEFAULT_DEVICE___6 = 4,
    NET_DECNET_TIME_WAIT___6 = 5,
    NET_DECNET_DN_COUNT___6 = 6,
    NET_DECNET_DI_COUNT___6 = 7,
    NET_DECNET_DR_COUNT___6 = 8,
    NET_DECNET_DST_GC_INTERVAL___6 = 9,
    NET_DECNET_CONF___6 = 10,
    NET_DECNET_NO_FC_MAX_CWND___6 = 11,
    NET_DECNET_MEM___6 = 12,
    NET_DECNET_RMEM___6 = 13,
    NET_DECNET_WMEM___6 = 14,
    NET_DECNET_DEBUG_LEVEL___6 = 255
} ;
enum __anonenum_148___6 {
    NET_DECNET_CONF_LOOPBACK___6 = -2,
    NET_DECNET_CONF_DDCMP___6 = -3,
    NET_DECNET_CONF_PPP___6 = -4,
    NET_DECNET_CONF_X25___6 = -5,
    NET_DECNET_CONF_GRE___6 = -6,
    NET_DECNET_CONF_ETHER___6 = -7
} ;
enum __anonenum_149___6 {
    NET_DECNET_CONF_DEV_PRIORITY___6 = 1,
    NET_DECNET_CONF_DEV_T1___6 = 2,
    NET_DECNET_CONF_DEV_T2___6 = 3,
    NET_DECNET_CONF_DEV_T3___6 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___6 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___6 = 6,
    NET_DECNET_CONF_DEV_STATE___6 = 7
} ;
enum __anonenum_150___6 {
    NET_SCTP_RTO_INITIAL___6 = 1,
    NET_SCTP_RTO_MIN___6 = 2,
    NET_SCTP_RTO_MAX___6 = 3,
    NET_SCTP_RTO_ALPHA___6 = 4,
    NET_SCTP_RTO_BETA___6 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___6 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___6 = 7,
    NET_SCTP_PATH_MAX_RETRANS___6 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___6 = 9,
    NET_SCTP_HB_INTERVAL___6 = 10,
    NET_SCTP_PRESERVE_ENABLE___6 = 11,
    NET_SCTP_MAX_BURST___6 = 12,
    NET_SCTP_ADDIP_ENABLE___6 = 13,
    NET_SCTP_PRSCTP_ENABLE___6 = 14,
    NET_SCTP_SNDBUF_POLICY___6 = 15,
    NET_SCTP_SACK_TIMEOUT___6 = 16,
    NET_SCTP_RCVBUF_POLICY___6 = 17
} ;
enum __anonenum_151___6 {
    NET_BRIDGE_NF_CALL_ARPTABLES___6 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___6 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___6 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___6 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___6 = 5
} ;
enum __anonenum_152___6 {
    NET_IRDA_DISCOVERY___6 = 1,
    NET_IRDA_DEVNAME___6 = 2,
    NET_IRDA_DEBUG___6 = 3,
    NET_IRDA_FAST_POLL___6 = 4,
    NET_IRDA_DISCOVERY_SLOTS___6 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___6 = 6,
    NET_IRDA_SLOT_TIMEOUT___6 = 7,
    NET_IRDA_MAX_BAUD_RATE___6 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___6 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___6 = 10,
    NET_IRDA_MAX_TX_WINDOW___6 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___6 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___6 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___6 = 14
} ;
enum __anonenum_153___6 {
    FS_NRINODE___6 = 1,
    FS_STATINODE___6 = 2,
    FS_MAXINODE___6 = 3,
    FS_NRDQUOT___6 = 4,
    FS_MAXDQUOT___6 = 5,
    FS_NRFILE___6 = 6,
    FS_MAXFILE___6 = 7,
    FS_DENTRY___6 = 8,
    FS_NRSUPER___6 = 9,
    FS_MAXSUPER___6 = 10,
    FS_OVERFLOWUID___6 = 11,
    FS_OVERFLOWGID___6 = 12,
    FS_LEASES___6 = 13,
    FS_DIR_NOTIFY___6 = 14,
    FS_LEASE_TIME___6 = 15,
    FS_DQSTATS___6 = 16,
    FS_XFS___6 = 17,
    FS_AIO_NR___6 = 18,
    FS_AIO_MAX_NR___6 = 19,
    FS_INOTIFY___6 = 20,
    FS_OCFS2___6 = 988
} ;
enum __anonenum_154___6 {
    FS_DQ_LOOKUPS___6 = 1,
    FS_DQ_DROPS___6 = 2,
    FS_DQ_READS___6 = 3,
    FS_DQ_WRITES___6 = 4,
    FS_DQ_CACHE_HITS___6 = 5,
    FS_DQ_ALLOCATED___6 = 6,
    FS_DQ_FREE___6 = 7,
    FS_DQ_SYNCS___6 = 8,
    FS_DQ_WARNINGS___6 = 9
} ;
enum __anonenum_155___6 {
    DEV_CDROM___6 = 1,
    DEV_HWMON___6 = 2,
    DEV_PARPORT___6 = 3,
    DEV_RAID___6 = 4,
    DEV_MAC_HID___6 = 5,
    DEV_SCSI___6 = 6,
    DEV_IPMI___6 = 7
} ;
enum __anonenum_156___6 {
    DEV_CDROM_INFO___6 = 1,
    DEV_CDROM_AUTOCLOSE___6 = 2,
    DEV_CDROM_AUTOEJECT___6 = 3,
    DEV_CDROM_DEBUG___6 = 4,
    DEV_CDROM_LOCK___6 = 5,
    DEV_CDROM_CHECK_MEDIA___6 = 6
} ;
enum __anonenum_157___6 {
    DEV_PARPORT_DEFAULT___6 = -3
} ;
enum __anonenum_158___6 {
    DEV_RAID_SPEED_LIMIT_MIN___6 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___6 = 2
} ;
enum __anonenum_159___6 {
    DEV_PARPORT_DEFAULT_TIMESLICE___6 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___6 = 2
} ;
enum __anonenum_160___6 {
    DEV_PARPORT_SPINTIME___6 = 1,
    DEV_PARPORT_BASE_ADDR___6 = 2,
    DEV_PARPORT_IRQ___6 = 3,
    DEV_PARPORT_DMA___6 = 4,
    DEV_PARPORT_MODES___6 = 5,
    DEV_PARPORT_DEVICES___6 = 6,
    DEV_PARPORT_AUTOPROBE___6 = 16
} ;
enum __anonenum_161___6 {
    DEV_PARPORT_DEVICES_ACTIVE___6 = -3
} ;
enum __anonenum_162___6 {
    DEV_PARPORT_DEVICE_TIMESLICE___6 = 1
} ;
enum __anonenum_163___6 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___6 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___6 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___6 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___6 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___6 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___6 = 6
} ;
enum __anonenum_164___6 {
    DEV_SCSI_LOGGING_LEVEL___6 = 1
} ;
enum __anonenum_165___6 {
    DEV_IPMI_POWEROFF_POWERCYCLE___6 = 1
} ;
enum __anonenum_166___6 {
    ABI_DEFHANDLER_COFF___6 = 1,
    ABI_DEFHANDLER_ELF___6 = 2,
    ABI_DEFHANDLER_LCALL7___6 = 3,
    ABI_DEFHANDLER_LIBCSO___6 = 4,
    ABI_TRACE___6 = 5,
    ABI_FAKE_UTSNAME___6 = 6
} ;
enum __anonenum_169___6 {
    IOCB_CMD_PREAD___6 = 0,
    IOCB_CMD_PWRITE___6 = 1,
    IOCB_CMD_FSYNC___6 = 2,
    IOCB_CMD_FDSYNC___6 = 3,
    IOCB_CMD_NOOP___6 = 6,
    IOCB_CMD_PREADV___6 = 7,
    IOCB_CMD_PWRITEV___6 = 8
} ;
enum __anonenum_172___6 {
    IRQTF_RUNTHREAD___6 = 0,
    IRQTF_DIED___6 = 1,
    IRQTF_WARNED___6 = 2
} ;
enum __anonenum_173___5 {
    HI_SOFTIRQ___6 = 0,
    TIMER_SOFTIRQ___6 = 1,
    NET_TX_SOFTIRQ___6 = 2,
    NET_RX_SOFTIRQ___6 = 3,
    BLOCK_SOFTIRQ___6 = 4,
    TASKLET_SOFTIRQ___6 = 5,
    SCHED_SOFTIRQ___6 = 6,
    HRTIMER_SOFTIRQ___6 = 7,
    RCU_SOFTIRQ___6 = 8,
    NR_SOFTIRQS___6 = 9
} ;
enum __anonenum_174___3 {
    TASKLET_STATE_SCHED___6 = 0,
    TASKLET_STATE_RUN___6 = 1
} ;
enum __anonenum_183___4 {
    QIF_BLIMITS_B___6 = 0,
    QIF_SPACE_B___6 = 1,
    QIF_ILIMITS_B___6 = 2,
    QIF_INODES_B___6 = 3,
    QIF_BTIME_B___6 = 4,
    QIF_ITIME_B___6 = 5
} ;
enum __anonenum_184___4 {
    QUOTA_NL_C_UNSPEC___6 = 0,
    QUOTA_NL_C_WARNING___6 = 1,
    __QUOTA_NL_C_MAX___6 = 2
} ;
enum __anonenum_185___4 {
    QUOTA_NL_A_UNSPEC___6 = 0,
    QUOTA_NL_A_QTYPE___6 = 1,
    QUOTA_NL_A_EXCESS_ID___6 = 2,
    QUOTA_NL_A_WARNING___6 = 3,
    QUOTA_NL_A_DEV_MAJOR___6 = 4,
    QUOTA_NL_A_DEV_MINOR___6 = 5,
    QUOTA_NL_A_CAUSED_ID___6 = 6,
    __QUOTA_NL_A_MAX___6 = 7
} ;
enum __anonenum_186___5 {
    _DQUOT_USAGE_ENABLED___6 = 0,
    _DQUOT_LIMITS_ENABLED___6 = 1,
    _DQUOT_SUSPENDED___6 = 2,
    _DQUOT_STATE_FLAGS___6 = 3
} ;
enum __anonenum_193___5 {
    SB_UNFROZEN___6 = 0,
    SB_FREEZE_WRITE___6 = 1,
    SB_FREEZE_TRANS___6 = 2
} ;
enum __anonenum_194___5 {
    DIO_LOCKING___6 = 1,
    DIO_NO_LOCKING___6 = 2,
    DIO_OWN_LOCKING___6 = 3
} ;
enum __anonenum_4___7 {
    false___7 = 0,
    true___7 = 1
} ;
enum __anonenum_10___4 {
    DUMP_PREFIX_NONE___7 = 0,
    DUMP_PREFIX_ADDRESS___7 = 1,
    DUMP_PREFIX_OFFSET___7 = 2
} ;
enum __anonenum_15___4 {
    PG_LEVEL_NONE___7 = 0,
    PG_LEVEL_4K___7 = 1,
    PG_LEVEL_2M___7 = 2,
    PG_LEVEL_1G___7 = 3,
    PG_LEVEL_NUM___7 = 4
} ;
enum __anonenum_19___4 {
    GATE_INTERRUPT___7 = 14,
    GATE_TRAP___7 = 15,
    GATE_CALL___7 = 12,
    GATE_TASK___7 = 5
} ;
enum __anonenum_20___5 {
    DESC_TSS___7 = 9,
    DESC_LDT___7 = 2,
    DESCTYPE_S___7 = 16
} ;
enum __anonenum_21___6 {
    ADDR_NO_RANDOMIZE___7 = 262144,
    FDPIC_FUNCPTRS___7 = 524288,
    MMAP_PAGE_ZERO___7 = 1048576,
    ADDR_COMPAT_LAYOUT___7 = 2097152,
    READ_IMPLIES_EXEC___7 = 4194304,
    ADDR_LIMIT_32BIT___7 = 8388608,
    SHORT_INODE___7 = 16777216,
    WHOLE_SECONDS___7 = 33554432,
    STICKY_TIMEOUTS___7 = 67108864,
    ADDR_LIMIT_3GB___7 = 134217728
} ;
enum __anonenum_22___4 {
    PER_LINUX___7 = 0,
    PER_LINUX_32BIT___7 = 8388608,
    PER_LINUX_FDPIC___7 = 524288,
    PER_SVR4___7 = 68157441,
    PER_SVR3___7 = 83886082,
    PER_SCOSVR3___7 = 117440515,
    PER_OSR5___7 = 100663299,
    PER_WYSEV386___7 = 83886084,
    PER_ISCR4___7 = 67108869,
    PER_BSD___7 = 6,
    PER_SUNOS___7 = 67108870,
    PER_XENIX___7 = 83886087,
    PER_LINUX32___7 = 8,
    PER_LINUX32_3GB___7 = 134217736,
    PER_IRIX32___7 = 67108873,
    PER_IRIXN32___7 = 67108874,
    PER_IRIX64___7 = 67108875,
    PER_RISCOS___7 = 12,
    PER_SOLARIS___7 = 67108877,
    PER_UW7___7 = 68157454,
    PER_OSF4___7 = 15,
    PER_HPUX___7 = 16,
    PER_MASK___7 = 255
} ;
union __anonunion_d_37___2 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
struct oldold_utsname {
   char sysname[9] ;
   char nodename[9] ;
   char release[9] ;
   char version[9] ;
   char machine[9] ;
};
struct old_utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
};
struct new_utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
enum __anonenum_119___3 {
    CTL_KERN___7 = 1,
    CTL_VM___7 = 2,
    CTL_NET___7 = 3,
    CTL_PROC___7 = 4,
    CTL_FS___7 = 5,
    CTL_DEBUG___7 = 6,
    CTL_DEV___7 = 7,
    CTL_BUS___7 = 8,
    CTL_ABI___7 = 9,
    CTL_CPU___7 = 10,
    CTL_ARLAN___7 = 254,
    CTL_S390DBF___7 = 5677,
    CTL_SUNRPC___7 = 7249,
    CTL_PM___7 = 9899,
    CTL_FRV___7 = 9898
} ;
enum __anonenum_120___5 {
    CTL_BUS_ISA___7 = 1
} ;
enum __anonenum_121___5 {
    INOTIFY_MAX_USER_INSTANCES___7 = 1,
    INOTIFY_MAX_USER_WATCHES___7 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___7 = 3
} ;
enum __anonenum_122___5 {
    KERN_OSTYPE___7 = 1,
    KERN_OSRELEASE___7 = 2,
    KERN_OSREV___7 = 3,
    KERN_VERSION___7 = 4,
    KERN_SECUREMASK___7 = 5,
    KERN_PROF___7 = 6,
    KERN_NODENAME___7 = 7,
    KERN_DOMAINNAME___7 = 8,
    KERN_PANIC___7 = 15,
    KERN_REALROOTDEV___7 = 16,
    KERN_SPARC_REBOOT___7 = 21,
    KERN_CTLALTDEL___7 = 22,
    KERN_PRINTK___7 = 23,
    KERN_NAMETRANS___7 = 24,
    KERN_PPC_HTABRECLAIM___7 = 25,
    KERN_PPC_ZEROPAGED___7 = 26,
    KERN_PPC_POWERSAVE_NAP___7 = 27,
    KERN_MODPROBE___7 = 28,
    KERN_SG_BIG_BUFF___7 = 29,
    KERN_ACCT___7 = 30,
    KERN_PPC_L2CR___7 = 31,
    KERN_RTSIGNR___7 = 32,
    KERN_RTSIGMAX___7 = 33,
    KERN_SHMMAX___7 = 34,
    KERN_MSGMAX___7 = 35,
    KERN_MSGMNB___7 = 36,
    KERN_MSGPOOL___7 = 37,
    KERN_SYSRQ___7 = 38,
    KERN_MAX_THREADS___7 = 39,
    KERN_RANDOM___7 = 40,
    KERN_SHMALL___7 = 41,
    KERN_MSGMNI___7 = 42,
    KERN_SEM___7 = 43,
    KERN_SPARC_STOP_A___7 = 44,
    KERN_SHMMNI___7 = 45,
    KERN_OVERFLOWUID___7 = 46,
    KERN_OVERFLOWGID___7 = 47,
    KERN_SHMPATH___7 = 48,
    KERN_HOTPLUG___7 = 49,
    KERN_IEEE_EMULATION_WARNINGS___7 = 50,
    KERN_S390_USER_DEBUG_LOGGING___7 = 51,
    KERN_CORE_USES_PID___7 = 52,
    KERN_TAINTED___7 = 53,
    KERN_CADPID___7 = 54,
    KERN_PIDMAX___7 = 55,
    KERN_CORE_PATTERN___7 = 56,
    KERN_PANIC_ON_OOPS___7 = 57,
    KERN_HPPA_PWRSW___7 = 58,
    KERN_HPPA_UNALIGNED___7 = 59,
    KERN_PRINTK_RATELIMIT___7 = 60,
    KERN_PRINTK_RATELIMIT_BURST___7 = 61,
    KERN_PTY___7 = 62,
    KERN_NGROUPS_MAX___7 = 63,
    KERN_SPARC_SCONS_PWROFF___7 = 64,
    KERN_HZ_TIMER___7 = 65,
    KERN_UNKNOWN_NMI_PANIC___7 = 66,
    KERN_BOOTLOADER_TYPE___7 = 67,
    KERN_RANDOMIZE___7 = 68,
    KERN_SETUID_DUMPABLE___7 = 69,
    KERN_SPIN_RETRY___7 = 70,
    KERN_ACPI_VIDEO_FLAGS___7 = 71,
    KERN_IA64_UNALIGNED___7 = 72,
    KERN_COMPAT_LOG___7 = 73,
    KERN_MAX_LOCK_DEPTH___7 = 74,
    KERN_NMI_WATCHDOG___7 = 75,
    KERN_PANIC_ON_NMI___7 = 76
} ;
enum __anonenum_123___5 {
    VM_UNUSED1___7 = 1,
    VM_UNUSED2___7 = 2,
    VM_UNUSED3___7 = 3,
    VM_UNUSED4___7 = 4,
    VM_OVERCOMMIT_MEMORY___7 = 5,
    VM_UNUSED5___7 = 6,
    VM_UNUSED7___7 = 7,
    VM_UNUSED8___7 = 8,
    VM_UNUSED9___7 = 9,
    VM_PAGE_CLUSTER___7 = 10,
    VM_DIRTY_BACKGROUND___7 = 11,
    VM_DIRTY_RATIO___7 = 12,
    VM_DIRTY_WB_CS___7 = 13,
    VM_DIRTY_EXPIRE_CS___7 = 14,
    VM_NR_PDFLUSH_THREADS___7 = 15,
    VM_OVERCOMMIT_RATIO___7 = 16,
    VM_PAGEBUF___7 = 17,
    VM_HUGETLB_PAGES___7 = 18,
    VM_SWAPPINESS___7 = 19,
    VM_LOWMEM_RESERVE_RATIO___7 = 20,
    VM_MIN_FREE_KBYTES___7 = 21,
    VM_MAX_MAP_COUNT___7 = 22,
    VM_LAPTOP_MODE___7 = 23,
    VM_BLOCK_DUMP___7 = 24,
    VM_HUGETLB_GROUP___7 = 25,
    VM_VFS_CACHE_PRESSURE___7 = 26,
    VM_LEGACY_VA_LAYOUT___7 = 27,
    VM_SWAP_TOKEN_TIMEOUT___7 = 28,
    VM_DROP_PAGECACHE___7 = 29,
    VM_PERCPU_PAGELIST_FRACTION___7 = 30,
    VM_ZONE_RECLAIM_MODE___7 = 31,
    VM_MIN_UNMAPPED___7 = 32,
    VM_PANIC_ON_OOM___7 = 33,
    VM_VDSO_ENABLED___7 = 34,
    VM_MIN_SLAB___7 = 35
} ;
enum __anonenum_124___5 {
    NET_CORE___7 = 1,
    NET_ETHER___7 = 2,
    NET_802___7 = 3,
    NET_UNIX___7 = 4,
    NET_IPV4___7 = 5,
    NET_IPX___7 = 6,
    NET_ATALK___7 = 7,
    NET_NETROM___7 = 8,
    NET_AX25___7 = 9,
    NET_BRIDGE___7 = 10,
    NET_ROSE___7 = 11,
    NET_IPV6___7 = 12,
    NET_X25___7 = 13,
    NET_TR___7 = 14,
    NET_DECNET___7 = 15,
    NET_ECONET___7 = 16,
    NET_SCTP___7 = 17,
    NET_LLC___7 = 18,
    NET_NETFILTER___7 = 19,
    NET_DCCP___7 = 20,
    NET_IRDA___7 = 412
} ;
enum __anonenum_125___7 {
    RANDOM_POOLSIZE___7 = 1,
    RANDOM_ENTROPY_COUNT___7 = 2,
    RANDOM_READ_THRESH___7 = 3,
    RANDOM_WRITE_THRESH___7 = 4,
    RANDOM_BOOT_ID___7 = 5,
    RANDOM_UUID___7 = 6
} ;
enum __anonenum_126___7 {
    PTY_MAX___7 = 1,
    PTY_NR___7 = 2
} ;
enum __anonenum_127___7 {
    BUS_ISA_MEM_BASE___7 = 1,
    BUS_ISA_PORT_BASE___7 = 2,
    BUS_ISA_PORT_SHIFT___7 = 3
} ;
enum __anonenum_128___7 {
    NET_CORE_WMEM_MAX___7 = 1,
    NET_CORE_RMEM_MAX___7 = 2,
    NET_CORE_WMEM_DEFAULT___7 = 3,
    NET_CORE_RMEM_DEFAULT___7 = 4,
    NET_CORE_MAX_BACKLOG___7 = 6,
    NET_CORE_FASTROUTE___7 = 7,
    NET_CORE_MSG_COST___7 = 8,
    NET_CORE_MSG_BURST___7 = 9,
    NET_CORE_OPTMEM_MAX___7 = 10,
    NET_CORE_HOT_LIST_LENGTH___7 = 11,
    NET_CORE_DIVERT_VERSION___7 = 12,
    NET_CORE_NO_CONG_THRESH___7 = 13,
    NET_CORE_NO_CONG___7 = 14,
    NET_CORE_LO_CONG___7 = 15,
    NET_CORE_MOD_CONG___7 = 16,
    NET_CORE_DEV_WEIGHT___7 = 17,
    NET_CORE_SOMAXCONN___7 = 18,
    NET_CORE_BUDGET___7 = 19,
    NET_CORE_AEVENT_ETIME___7 = 20,
    NET_CORE_AEVENT_RSEQTH___7 = 21,
    NET_CORE_WARNINGS___7 = 22
} ;
enum __anonenum_129___7 {
    NET_UNIX_DESTROY_DELAY___7 = 1,
    NET_UNIX_DELETE_DELAY___7 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___7 = 3
} ;
enum __anonenum_130___7 {
    NET_NF_CONNTRACK_MAX___7 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___7 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___7 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___7 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___7 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___7 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___7 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___7 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___7 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___7 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___7 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___7 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___7 = 13,
    NET_NF_CONNTRACK_BUCKETS___7 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___7 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___7 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___7 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___7 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___7 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___7 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___7 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___7 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___7 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___7 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___7 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___7 = 26,
    NET_NF_CONNTRACK_COUNT___7 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___7 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___7 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___7 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___7 = 31,
    NET_NF_CONNTRACK_CHECKSUM___7 = 32
} ;
enum __anonenum_131___7 {
    NET_IPV4_FORWARD___7 = 8,
    NET_IPV4_DYNADDR___7 = 9,
    NET_IPV4_CONF___7 = 16,
    NET_IPV4_NEIGH___7 = 17,
    NET_IPV4_ROUTE___7 = 18,
    NET_IPV4_FIB_HASH___7 = 19,
    NET_IPV4_NETFILTER___7 = 20,
    NET_IPV4_TCP_TIMESTAMPS___7 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___7 = 34,
    NET_IPV4_TCP_SACK___7 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___7 = 36,
    NET_IPV4_DEFAULT_TTL___7 = 37,
    NET_IPV4_AUTOCONFIG___7 = 38,
    NET_IPV4_NO_PMTU_DISC___7 = 39,
    NET_IPV4_TCP_SYN_RETRIES___7 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___7 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___7 = 42,
    NET_IPV4_IPFRAG_TIME___7 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___7 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___7 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___7 = 46,
    NET_IPV4_TCP_RETRIES1___7 = 47,
    NET_IPV4_TCP_RETRIES2___7 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___7 = 49,
    NET_IPV4_IP_MASQ_DEBUG___7 = 50,
    NET_TCP_SYNCOOKIES___7 = 51,
    NET_TCP_STDURG___7 = 52,
    NET_TCP_RFC1337___7 = 53,
    NET_TCP_SYN_TAILDROP___7 = 54,
    NET_TCP_MAX_SYN_BACKLOG___7 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___7 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___7 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___7 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___7 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___7 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___7 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___7 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___7 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___7 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___7 = 65,
    NET_TCP_TW_RECYCLE___7 = 66,
    NET_IPV4_ALWAYS_DEFRAG___7 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___7 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___7 = 69,
    NET_IPV4_INET_PEER_MINTTL___7 = 70,
    NET_IPV4_INET_PEER_MAXTTL___7 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___7 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___7 = 73,
    NET_TCP_ORPHAN_RETRIES___7 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___7 = 75,
    NET_TCP_SYNACK_RETRIES___7 = 76,
    NET_TCP_MAX_ORPHANS___7 = 77,
    NET_TCP_MAX_TW_BUCKETS___7 = 78,
    NET_TCP_FACK___7 = 79,
    NET_TCP_REORDERING___7 = 80,
    NET_TCP_ECN___7 = 81,
    NET_TCP_DSACK___7 = 82,
    NET_TCP_MEM___7 = 83,
    NET_TCP_WMEM___7 = 84,
    NET_TCP_RMEM___7 = 85,
    NET_TCP_APP_WIN___7 = 86,
    NET_TCP_ADV_WIN_SCALE___7 = 87,
    NET_IPV4_NONLOCAL_BIND___7 = 88,
    NET_IPV4_ICMP_RATELIMIT___7 = 89,
    NET_IPV4_ICMP_RATEMASK___7 = 90,
    NET_TCP_TW_REUSE___7 = 91,
    NET_TCP_FRTO___7 = 92,
    NET_TCP_LOW_LATENCY___7 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___7 = 94,
    NET_IPV4_IGMP_MAX_MSF___7 = 96,
    NET_TCP_NO_METRICS_SAVE___7 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___7 = 105,
    NET_TCP_MODERATE_RCVBUF___7 = 106,
    NET_TCP_TSO_WIN_DIVISOR___7 = 107,
    NET_TCP_BIC_BETA___7 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___7 = 109,
    NET_TCP_CONG_CONTROL___7 = 110,
    NET_TCP_ABC___7 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___7 = 112,
    NET_TCP_MTU_PROBING___7 = 113,
    NET_TCP_BASE_MSS___7 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___7 = 115,
    NET_TCP_DMA_COPYBREAK___7 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___7 = 117,
    NET_CIPSOV4_CACHE_ENABLE___7 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___7 = 119,
    NET_CIPSOV4_RBM_OPTFMT___7 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___7 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___7 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___7 = 123,
    NET_TCP_MAX_SSTHRESH___7 = 124,
    NET_TCP_FRTO_RESPONSE___7 = 125
} ;
enum __anonenum_132___7 {
    NET_IPV4_ROUTE_FLUSH___7 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___7 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___7 = 3,
    NET_IPV4_ROUTE_GC_THRESH___7 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___7 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___7 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___7 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___7 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___7 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___7 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___7 = 11,
    NET_IPV4_ROUTE_ERROR_COST___7 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___7 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___7 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___7 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___7 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___7 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___7 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___7 = 19
} ;
enum __anonenum_133___7 {
    NET_PROTO_CONF_ALL___7 = -2,
    NET_PROTO_CONF_DEFAULT___7 = -3
} ;
enum __anonenum_134___7 {
    NET_IPV4_CONF_FORWARDING___7 = 1,
    NET_IPV4_CONF_MC_FORWARDING___7 = 2,
    NET_IPV4_CONF_PROXY_ARP___7 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___7 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___7 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___7 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___7 = 7,
    NET_IPV4_CONF_RP_FILTER___7 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___7 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___7 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___7 = 11,
    NET_IPV4_CONF_TAG___7 = 12,
    NET_IPV4_CONF_ARPFILTER___7 = 13,
    NET_IPV4_CONF_MEDIUM_ID___7 = 14,
    NET_IPV4_CONF_NOXFRM___7 = 15,
    NET_IPV4_CONF_NOPOLICY___7 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___7 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___7 = 18,
    NET_IPV4_CONF_ARP_IGNORE___7 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___7 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___7 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___7 = 22,
    __NET_IPV4_CONF_MAX___7 = 23
} ;
enum __anonenum_135___7 {
    NET_IPV4_NF_CONNTRACK_MAX___7 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___7 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___7 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___7 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___7 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___7 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___7 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___7 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___7 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___7 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___7 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___7 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___7 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___7 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___7 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___7 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___7 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___7 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___7 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___7 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___7 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___7 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___7 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___7 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___7 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___7 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___7 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___7 = 28
} ;
enum __anonenum_136___7 {
    NET_IPV6_CONF___7 = 16,
    NET_IPV6_NEIGH___7 = 17,
    NET_IPV6_ROUTE___7 = 18,
    NET_IPV6_ICMP___7 = 19,
    NET_IPV6_BINDV6ONLY___7 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___7 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___7 = 22,
    NET_IPV6_IP6FRAG_TIME___7 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___7 = 24,
    NET_IPV6_MLD_MAX_MSF___7 = 25
} ;
enum __anonenum_137___7 {
    NET_IPV6_ROUTE_FLUSH___7 = 1,
    NET_IPV6_ROUTE_GC_THRESH___7 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___7 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___7 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___7 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___7 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___7 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___7 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___7 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___7 = 10
} ;
enum __anonenum_138___7 {
    NET_IPV6_FORWARDING___7 = 1,
    NET_IPV6_HOP_LIMIT___7 = 2,
    NET_IPV6_MTU___7 = 3,
    NET_IPV6_ACCEPT_RA___7 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___7 = 5,
    NET_IPV6_AUTOCONF___7 = 6,
    NET_IPV6_DAD_TRANSMITS___7 = 7,
    NET_IPV6_RTR_SOLICITS___7 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___7 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___7 = 10,
    NET_IPV6_USE_TEMPADDR___7 = 11,
    NET_IPV6_TEMP_VALID_LFT___7 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___7 = 13,
    NET_IPV6_REGEN_MAX_RETRY___7 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___7 = 15,
    NET_IPV6_MAX_ADDRESSES___7 = 16,
    NET_IPV6_FORCE_MLD_VERSION___7 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___7 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___7 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___7 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___7 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___7 = 22,
    NET_IPV6_PROXY_NDP___7 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___7 = 25,
    __NET_IPV6_MAX___7 = 26
} ;
enum __anonenum_139___7 {
    NET_IPV6_ICMP_RATELIMIT___7 = 1
} ;
enum __anonenum_140___7 {
    NET_NEIGH_MCAST_SOLICIT___7 = 1,
    NET_NEIGH_UCAST_SOLICIT___7 = 2,
    NET_NEIGH_APP_SOLICIT___7 = 3,
    NET_NEIGH_RETRANS_TIME___7 = 4,
    NET_NEIGH_REACHABLE_TIME___7 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___7 = 6,
    NET_NEIGH_GC_STALE_TIME___7 = 7,
    NET_NEIGH_UNRES_QLEN___7 = 8,
    NET_NEIGH_PROXY_QLEN___7 = 9,
    NET_NEIGH_ANYCAST_DELAY___7 = 10,
    NET_NEIGH_PROXY_DELAY___7 = 11,
    NET_NEIGH_LOCKTIME___7 = 12,
    NET_NEIGH_GC_INTERVAL___7 = 13,
    NET_NEIGH_GC_THRESH1___7 = 14,
    NET_NEIGH_GC_THRESH2___7 = 15,
    NET_NEIGH_GC_THRESH3___7 = 16,
    NET_NEIGH_RETRANS_TIME_MS___7 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___7 = 18,
    __NET_NEIGH_MAX___7 = 19
} ;
enum __anonenum_141___7 {
    NET_DCCP_DEFAULT___7 = 1
} ;
enum __anonenum_142___7 {
    NET_IPX_PPROP_BROADCASTING___7 = 1,
    NET_IPX_FORWARDING___7 = 2
} ;
enum __anonenum_143___7 {
    NET_LLC2___7 = 1,
    NET_LLC_STATION___7 = 2
} ;
enum __anonenum_144___7 {
    NET_LLC2_TIMEOUT___7 = 1
} ;
enum __anonenum_145___7 {
    NET_LLC_STATION_ACK_TIMEOUT___7 = 1
} ;
enum __anonenum_146___7 {
    NET_LLC2_ACK_TIMEOUT___7 = 1,
    NET_LLC2_P_TIMEOUT___7 = 2,
    NET_LLC2_REJ_TIMEOUT___7 = 3,
    NET_LLC2_BUSY_TIMEOUT___7 = 4
} ;
enum __anonenum_147___7 {
    NET_ATALK_AARP_EXPIRY_TIME___7 = 1,
    NET_ATALK_AARP_TICK_TIME___7 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___7 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___7 = 4
} ;
enum __anonenum_148___7 {
    NET_NETROM_DEFAULT_PATH_QUALITY___7 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___7 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___7 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___7 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___7 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___7 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___7 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___7 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___7 = 9,
    NET_NETROM_ROUTING_CONTROL___7 = 10,
    NET_NETROM_LINK_FAILS_COUNT___7 = 11,
    NET_NETROM_RESET___7 = 12
} ;
enum __anonenum_149___7 {
    NET_AX25_IP_DEFAULT_MODE___7 = 1,
    NET_AX25_DEFAULT_MODE___7 = 2,
    NET_AX25_BACKOFF_TYPE___7 = 3,
    NET_AX25_CONNECT_MODE___7 = 4,
    NET_AX25_STANDARD_WINDOW___7 = 5,
    NET_AX25_EXTENDED_WINDOW___7 = 6,
    NET_AX25_T1_TIMEOUT___7 = 7,
    NET_AX25_T2_TIMEOUT___7 = 8,
    NET_AX25_T3_TIMEOUT___7 = 9,
    NET_AX25_IDLE_TIMEOUT___7 = 10,
    NET_AX25_N2___7 = 11,
    NET_AX25_PACLEN___7 = 12,
    NET_AX25_PROTOCOL___7 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___7 = 14
} ;
enum __anonenum_150___7 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___7 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___7 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___7 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___7 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___7 = 5,
    NET_ROSE_ROUTING_CONTROL___7 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___7 = 7,
    NET_ROSE_MAX_VCS___7 = 8,
    NET_ROSE_WINDOW_SIZE___7 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___7 = 10
} ;
enum __anonenum_151___7 {
    NET_X25_RESTART_REQUEST_TIMEOUT___7 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___7 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___7 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___7 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___7 = 5,
    NET_X25_FORWARD___7 = 6
} ;
enum __anonenum_152___7 {
    NET_TR_RIF_TIMEOUT___7 = 1
} ;
enum __anonenum_153___7 {
    NET_DECNET_NODE_TYPE___7 = 1,
    NET_DECNET_NODE_ADDRESS___7 = 2,
    NET_DECNET_NODE_NAME___7 = 3,
    NET_DECNET_DEFAULT_DEVICE___7 = 4,
    NET_DECNET_TIME_WAIT___7 = 5,
    NET_DECNET_DN_COUNT___7 = 6,
    NET_DECNET_DI_COUNT___7 = 7,
    NET_DECNET_DR_COUNT___7 = 8,
    NET_DECNET_DST_GC_INTERVAL___7 = 9,
    NET_DECNET_CONF___7 = 10,
    NET_DECNET_NO_FC_MAX_CWND___7 = 11,
    NET_DECNET_MEM___7 = 12,
    NET_DECNET_RMEM___7 = 13,
    NET_DECNET_WMEM___7 = 14,
    NET_DECNET_DEBUG_LEVEL___7 = 255
} ;
enum __anonenum_154___7 {
    NET_DECNET_CONF_LOOPBACK___7 = -2,
    NET_DECNET_CONF_DDCMP___7 = -3,
    NET_DECNET_CONF_PPP___7 = -4,
    NET_DECNET_CONF_X25___7 = -5,
    NET_DECNET_CONF_GRE___7 = -6,
    NET_DECNET_CONF_ETHER___7 = -7
} ;
enum __anonenum_155___7 {
    NET_DECNET_CONF_DEV_PRIORITY___7 = 1,
    NET_DECNET_CONF_DEV_T1___7 = 2,
    NET_DECNET_CONF_DEV_T2___7 = 3,
    NET_DECNET_CONF_DEV_T3___7 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___7 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___7 = 6,
    NET_DECNET_CONF_DEV_STATE___7 = 7
} ;
enum __anonenum_156___7 {
    NET_SCTP_RTO_INITIAL___7 = 1,
    NET_SCTP_RTO_MIN___7 = 2,
    NET_SCTP_RTO_MAX___7 = 3,
    NET_SCTP_RTO_ALPHA___7 = 4,
    NET_SCTP_RTO_BETA___7 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___7 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___7 = 7,
    NET_SCTP_PATH_MAX_RETRANS___7 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___7 = 9,
    NET_SCTP_HB_INTERVAL___7 = 10,
    NET_SCTP_PRESERVE_ENABLE___7 = 11,
    NET_SCTP_MAX_BURST___7 = 12,
    NET_SCTP_ADDIP_ENABLE___7 = 13,
    NET_SCTP_PRSCTP_ENABLE___7 = 14,
    NET_SCTP_SNDBUF_POLICY___7 = 15,
    NET_SCTP_SACK_TIMEOUT___7 = 16,
    NET_SCTP_RCVBUF_POLICY___7 = 17
} ;
enum __anonenum_157___7 {
    NET_BRIDGE_NF_CALL_ARPTABLES___7 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___7 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___7 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___7 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___7 = 5
} ;
enum __anonenum_158___7 {
    NET_IRDA_DISCOVERY___7 = 1,
    NET_IRDA_DEVNAME___7 = 2,
    NET_IRDA_DEBUG___7 = 3,
    NET_IRDA_FAST_POLL___7 = 4,
    NET_IRDA_DISCOVERY_SLOTS___7 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___7 = 6,
    NET_IRDA_SLOT_TIMEOUT___7 = 7,
    NET_IRDA_MAX_BAUD_RATE___7 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___7 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___7 = 10,
    NET_IRDA_MAX_TX_WINDOW___7 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___7 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___7 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___7 = 14
} ;
enum __anonenum_159___7 {
    FS_NRINODE___7 = 1,
    FS_STATINODE___7 = 2,
    FS_MAXINODE___7 = 3,
    FS_NRDQUOT___7 = 4,
    FS_MAXDQUOT___7 = 5,
    FS_NRFILE___7 = 6,
    FS_MAXFILE___7 = 7,
    FS_DENTRY___7 = 8,
    FS_NRSUPER___7 = 9,
    FS_MAXSUPER___7 = 10,
    FS_OVERFLOWUID___7 = 11,
    FS_OVERFLOWGID___7 = 12,
    FS_LEASES___7 = 13,
    FS_DIR_NOTIFY___7 = 14,
    FS_LEASE_TIME___7 = 15,
    FS_DQSTATS___7 = 16,
    FS_XFS___7 = 17,
    FS_AIO_NR___7 = 18,
    FS_AIO_MAX_NR___7 = 19,
    FS_INOTIFY___7 = 20,
    FS_OCFS2___7 = 988
} ;
enum __anonenum_160___7 {
    FS_DQ_LOOKUPS___7 = 1,
    FS_DQ_DROPS___7 = 2,
    FS_DQ_READS___7 = 3,
    FS_DQ_WRITES___7 = 4,
    FS_DQ_CACHE_HITS___7 = 5,
    FS_DQ_ALLOCATED___7 = 6,
    FS_DQ_FREE___7 = 7,
    FS_DQ_SYNCS___7 = 8,
    FS_DQ_WARNINGS___7 = 9
} ;
enum __anonenum_161___7 {
    DEV_CDROM___7 = 1,
    DEV_HWMON___7 = 2,
    DEV_PARPORT___7 = 3,
    DEV_RAID___7 = 4,
    DEV_MAC_HID___7 = 5,
    DEV_SCSI___7 = 6,
    DEV_IPMI___7 = 7
} ;
enum __anonenum_162___7 {
    DEV_CDROM_INFO___7 = 1,
    DEV_CDROM_AUTOCLOSE___7 = 2,
    DEV_CDROM_AUTOEJECT___7 = 3,
    DEV_CDROM_DEBUG___7 = 4,
    DEV_CDROM_LOCK___7 = 5,
    DEV_CDROM_CHECK_MEDIA___7 = 6
} ;
enum __anonenum_163___7 {
    DEV_PARPORT_DEFAULT___7 = -3
} ;
enum __anonenum_164___7 {
    DEV_RAID_SPEED_LIMIT_MIN___7 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___7 = 2
} ;
enum __anonenum_165___7 {
    DEV_PARPORT_DEFAULT_TIMESLICE___7 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___7 = 2
} ;
enum __anonenum_166___7 {
    DEV_PARPORT_SPINTIME___7 = 1,
    DEV_PARPORT_BASE_ADDR___7 = 2,
    DEV_PARPORT_IRQ___7 = 3,
    DEV_PARPORT_DMA___7 = 4,
    DEV_PARPORT_MODES___7 = 5,
    DEV_PARPORT_DEVICES___7 = 6,
    DEV_PARPORT_AUTOPROBE___7 = 16
} ;
enum __anonenum_167___4 {
    DEV_PARPORT_DEVICES_ACTIVE___7 = -3
} ;
enum __anonenum_168___4 {
    DEV_PARPORT_DEVICE_TIMESLICE___7 = 1
} ;
enum __anonenum_169___7 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___7 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___7 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___7 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___7 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___7 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___7 = 6
} ;
enum __anonenum_170___4 {
    DEV_SCSI_LOGGING_LEVEL___7 = 1
} ;
enum __anonenum_171___4 {
    DEV_IPMI_POWEROFF_POWERCYCLE___7 = 1
} ;
enum __anonenum_172___7 {
    ABI_DEFHANDLER_COFF___7 = 1,
    ABI_DEFHANDLER_ELF___7 = 2,
    ABI_DEFHANDLER_LCALL7___7 = 3,
    ABI_DEFHANDLER_LIBCSO___7 = 4,
    ABI_TRACE___7 = 5,
    ABI_FAKE_UTSNAME___7 = 6
} ;
enum __anonenum_175___2 {
    IOCB_CMD_PREAD___7 = 0,
    IOCB_CMD_PWRITE___7 = 1,
    IOCB_CMD_FSYNC___7 = 2,
    IOCB_CMD_FDSYNC___7 = 3,
    IOCB_CMD_NOOP___7 = 6,
    IOCB_CMD_PREADV___7 = 7,
    IOCB_CMD_PWRITEV___7 = 8
} ;
struct mnt_namespace;
struct ipc_namespace;
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns ;
   struct net *net_ns ;
};
struct uts_namespace {
   struct kref kref ;
   struct new_utsname name ;
};
struct platform_device {
   char const   *name ;
   int id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id *id_entry ;
};
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t state ) ;
   int (*suspend_late)(struct platform_device * , pm_message_t state ) ;
   int (*resume_early)(struct platform_device * ) ;
   int (*resume)(struct platform_device * ) ;
   struct device_driver driver ;
   struct platform_device_id *id_table ;
};
struct early_platform_driver {
   char const   *class_str ;
   struct platform_driver *pdrv ;
   struct list_head list ;
   int requested_id ;
};
enum __anonenum_179___2 {
    IRQTF_RUNTHREAD___7 = 0,
    IRQTF_DIED___7 = 1,
    IRQTF_WARNED___7 = 2
} ;
enum __anonenum_180___2 {
    HI_SOFTIRQ___7 = 0,
    TIMER_SOFTIRQ___7 = 1,
    NET_TX_SOFTIRQ___7 = 2,
    NET_RX_SOFTIRQ___7 = 3,
    BLOCK_SOFTIRQ___7 = 4,
    TASKLET_SOFTIRQ___7 = 5,
    SCHED_SOFTIRQ___7 = 6,
    HRTIMER_SOFTIRQ___7 = 7,
    RCU_SOFTIRQ___7 = 8,
    NR_SOFTIRQS___7 = 9
} ;
enum __anonenum_181___4 {
    TASKLET_STATE_SCHED___7 = 0,
    TASKLET_STATE_RUN___7 = 1
} ;
enum __anonenum_183___5 {
    QIF_BLIMITS_B___7 = 0,
    QIF_SPACE_B___7 = 1,
    QIF_ILIMITS_B___7 = 2,
    QIF_INODES_B___7 = 3,
    QIF_BTIME_B___7 = 4,
    QIF_ITIME_B___7 = 5
} ;
enum __anonenum_184___5 {
    QUOTA_NL_C_UNSPEC___7 = 0,
    QUOTA_NL_C_WARNING___7 = 1,
    __QUOTA_NL_C_MAX___7 = 2
} ;
enum __anonenum_185___5 {
    QUOTA_NL_A_UNSPEC___7 = 0,
    QUOTA_NL_A_QTYPE___7 = 1,
    QUOTA_NL_A_EXCESS_ID___7 = 2,
    QUOTA_NL_A_WARNING___7 = 3,
    QUOTA_NL_A_DEV_MAJOR___7 = 4,
    QUOTA_NL_A_DEV_MINOR___7 = 5,
    QUOTA_NL_A_CAUSED_ID___7 = 6,
    __QUOTA_NL_A_MAX___7 = 7
} ;
enum __anonenum_186___6 {
    _DQUOT_USAGE_ENABLED___7 = 0,
    _DQUOT_LIMITS_ENABLED___7 = 1,
    _DQUOT_SUSPENDED___7 = 2,
    _DQUOT_STATE_FLAGS___7 = 3
} ;
enum __anonenum_193___6 {
    SB_UNFROZEN___7 = 0,
    SB_FREEZE_WRITE___7 = 1,
    SB_FREEZE_TRANS___7 = 2
} ;
enum __anonenum_194___6 {
    DIO_LOCKING___7 = 1,
    DIO_NO_LOCKING___7 = 2,
    DIO_OWN_LOCKING___7 = 3
} ;
struct usb_busmap {
   unsigned long busmap[64UL / (8UL * sizeof(unsigned long ))] ;
};
enum __anonenum_4___8 {
    false___8 = 0,
    true___8 = 1
} ;
enum __anonenum_8___0 {
    DUMP_PREFIX_NONE___8 = 0,
    DUMP_PREFIX_ADDRESS___8 = 1,
    DUMP_PREFIX_OFFSET___8 = 2
} ;
enum __anonenum_15___5 {
    PG_LEVEL_NONE___8 = 0,
    PG_LEVEL_4K___8 = 1,
    PG_LEVEL_2M___8 = 2,
    PG_LEVEL_1G___8 = 3,
    PG_LEVEL_NUM___8 = 4
} ;
enum __anonenum_19___5 {
    GATE_INTERRUPT___8 = 14,
    GATE_TRAP___8 = 15,
    GATE_CALL___8 = 12,
    GATE_TASK___8 = 5
} ;
enum __anonenum_20___6 {
    DESC_TSS___8 = 9,
    DESC_LDT___8 = 2,
    DESCTYPE_S___8 = 16
} ;
enum __anonenum_21___7 {
    ADDR_NO_RANDOMIZE___8 = 262144,
    FDPIC_FUNCPTRS___8 = 524288,
    MMAP_PAGE_ZERO___8 = 1048576,
    ADDR_COMPAT_LAYOUT___8 = 2097152,
    READ_IMPLIES_EXEC___8 = 4194304,
    ADDR_LIMIT_32BIT___8 = 8388608,
    SHORT_INODE___8 = 16777216,
    WHOLE_SECONDS___8 = 33554432,
    STICKY_TIMEOUTS___8 = 67108864,
    ADDR_LIMIT_3GB___8 = 134217728
} ;
enum __anonenum_22___5 {
    PER_LINUX___8 = 0,
    PER_LINUX_32BIT___8 = 8388608,
    PER_LINUX_FDPIC___8 = 524288,
    PER_SVR4___8 = 68157441,
    PER_SVR3___8 = 83886082,
    PER_SCOSVR3___8 = 117440515,
    PER_OSR5___8 = 100663299,
    PER_WYSEV386___8 = 83886084,
    PER_ISCR4___8 = 67108869,
    PER_BSD___8 = 6,
    PER_SUNOS___8 = 67108870,
    PER_XENIX___8 = 83886087,
    PER_LINUX32___8 = 8,
    PER_LINUX32_3GB___8 = 134217736,
    PER_IRIX32___8 = 67108873,
    PER_IRIXN32___8 = 67108874,
    PER_IRIX64___8 = 67108875,
    PER_RISCOS___8 = 12,
    PER_SOLARIS___8 = 67108877,
    PER_UW7___8 = 68157454,
    PER_OSF4___8 = 15,
    PER_HPUX___8 = 16,
    PER_MASK___8 = 255
} ;
union __anonunion_d_37___3 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
enum pci_mmap_state {
    pci_mmap_io = 0,
    pci_mmap_mem = 1
} ;
enum __anonenum_101 {
    PCI_STD_RESOURCES = 0,
    PCI_STD_RESOURCE_END = 5,
    PCI_ROM_RESOURCE = 6,
    PCI_BRIDGE_RESOURCES = 7,
    PCI_BRIDGE_RESOURCE_END = 10,
    PCI_NUM_RESOURCES = 11,
    DEVICE_COUNT_RESOURCE = 12
} ;
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned int pcie_reset_state_t;
enum pcie_reset_state {
    pcie_deassert_reset = 1,
    pcie_warm_reset = 2,
    pcie_hot_reset = 3
} ;
typedef unsigned short pci_dev_flags_t;
enum pci_dev_flags {
    PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
    PCI_DEV_FLAGS_NO_D3 = 2
} ;
enum pci_irq_reroute_variant {
    INTEL_IRQ_REROUTE_VARIANT = 1,
    MAX_IRQ_REROUTE_VARIANTS = 3
} ;
typedef unsigned short pci_bus_flags_t;
enum pci_bus_flags {
    PCI_BUS_FLAGS_NO_MSI = 1,
    PCI_BUS_FLAGS_NO_MMRBC = 2
} ;
struct pci_cap_saved_state {
   struct hlist_node next ;
   char cap_nr ;
   u32 data[0] ;
};
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_driver;
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   struct bin_attribute *res_attr_wc[12] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
};
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[16] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
struct pci_bus_region {
   resource_size_t start ;
   resource_size_t end ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
enum pci_ers_result {
    PCI_ERS_RESULT_NONE = 1,
    PCI_ERS_RESULT_CAN_RECOVER = 2,
    PCI_ERS_RESULT_NEED_RESET = 3,
    PCI_ERS_RESULT_DISCONNECT = 4,
    PCI_ERS_RESULT_RECOVERED = 5
} ;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
enum pci_lost_interrupt_reason {
    PCI_LOST_IRQ_NO_INFORMATION = 0,
    PCI_LOST_IRQ_DISABLE_MSI = 1,
    PCI_LOST_IRQ_DISABLE_MSIX = 2,
    PCI_LOST_IRQ_DISABLE_ACPI = 3
} ;
enum pci_dma_burst_strategy {
    PCI_DMA_BURST_INFINITY = 0,
    PCI_DMA_BURST_BOUNDARY = 1,
    PCI_DMA_BURST_MULTIPLE = 2
} ;
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
struct pci_sysdata {
   int domain ;
   int node ;
};
struct irq_routing_table;
struct pci_fixup {
   u16 vendor ;
   u16 device ;
   void (*hook)(struct pci_dev *dev ) ;
};
enum pci_fixup_pass {
    pci_fixup_early = 0,
    pci_fixup_header = 1,
    pci_fixup_final = 2,
    pci_fixup_enable = 3,
    pci_fixup_resume = 4,
    pci_fixup_suspend = 5,
    pci_fixup_resume_early = 6
} ;
enum __anonenum_121___6 {
    CTL_KERN___8 = 1,
    CTL_VM___8 = 2,
    CTL_NET___8 = 3,
    CTL_PROC___8 = 4,
    CTL_FS___8 = 5,
    CTL_DEBUG___8 = 6,
    CTL_DEV___8 = 7,
    CTL_BUS___8 = 8,
    CTL_ABI___8 = 9,
    CTL_CPU___8 = 10,
    CTL_ARLAN___8 = 254,
    CTL_S390DBF___8 = 5677,
    CTL_SUNRPC___8 = 7249,
    CTL_PM___8 = 9899,
    CTL_FRV___8 = 9898
} ;
enum __anonenum_122___6 {
    CTL_BUS_ISA___8 = 1
} ;
enum __anonenum_123___6 {
    INOTIFY_MAX_USER_INSTANCES___8 = 1,
    INOTIFY_MAX_USER_WATCHES___8 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___8 = 3
} ;
enum __anonenum_124___6 {
    KERN_OSTYPE___8 = 1,
    KERN_OSRELEASE___8 = 2,
    KERN_OSREV___8 = 3,
    KERN_VERSION___8 = 4,
    KERN_SECUREMASK___8 = 5,
    KERN_PROF___8 = 6,
    KERN_NODENAME___8 = 7,
    KERN_DOMAINNAME___8 = 8,
    KERN_PANIC___8 = 15,
    KERN_REALROOTDEV___8 = 16,
    KERN_SPARC_REBOOT___8 = 21,
    KERN_CTLALTDEL___8 = 22,
    KERN_PRINTK___8 = 23,
    KERN_NAMETRANS___8 = 24,
    KERN_PPC_HTABRECLAIM___8 = 25,
    KERN_PPC_ZEROPAGED___8 = 26,
    KERN_PPC_POWERSAVE_NAP___8 = 27,
    KERN_MODPROBE___8 = 28,
    KERN_SG_BIG_BUFF___8 = 29,
    KERN_ACCT___8 = 30,
    KERN_PPC_L2CR___8 = 31,
    KERN_RTSIGNR___8 = 32,
    KERN_RTSIGMAX___8 = 33,
    KERN_SHMMAX___8 = 34,
    KERN_MSGMAX___8 = 35,
    KERN_MSGMNB___8 = 36,
    KERN_MSGPOOL___8 = 37,
    KERN_SYSRQ___8 = 38,
    KERN_MAX_THREADS___8 = 39,
    KERN_RANDOM___8 = 40,
    KERN_SHMALL___8 = 41,
    KERN_MSGMNI___8 = 42,
    KERN_SEM___8 = 43,
    KERN_SPARC_STOP_A___8 = 44,
    KERN_SHMMNI___8 = 45,
    KERN_OVERFLOWUID___8 = 46,
    KERN_OVERFLOWGID___8 = 47,
    KERN_SHMPATH___8 = 48,
    KERN_HOTPLUG___8 = 49,
    KERN_IEEE_EMULATION_WARNINGS___8 = 50,
    KERN_S390_USER_DEBUG_LOGGING___8 = 51,
    KERN_CORE_USES_PID___8 = 52,
    KERN_TAINTED___8 = 53,
    KERN_CADPID___8 = 54,
    KERN_PIDMAX___8 = 55,
    KERN_CORE_PATTERN___8 = 56,
    KERN_PANIC_ON_OOPS___8 = 57,
    KERN_HPPA_PWRSW___8 = 58,
    KERN_HPPA_UNALIGNED___8 = 59,
    KERN_PRINTK_RATELIMIT___8 = 60,
    KERN_PRINTK_RATELIMIT_BURST___8 = 61,
    KERN_PTY___8 = 62,
    KERN_NGROUPS_MAX___8 = 63,
    KERN_SPARC_SCONS_PWROFF___8 = 64,
    KERN_HZ_TIMER___8 = 65,
    KERN_UNKNOWN_NMI_PANIC___8 = 66,
    KERN_BOOTLOADER_TYPE___8 = 67,
    KERN_RANDOMIZE___8 = 68,
    KERN_SETUID_DUMPABLE___8 = 69,
    KERN_SPIN_RETRY___8 = 70,
    KERN_ACPI_VIDEO_FLAGS___8 = 71,
    KERN_IA64_UNALIGNED___8 = 72,
    KERN_COMPAT_LOG___8 = 73,
    KERN_MAX_LOCK_DEPTH___8 = 74,
    KERN_NMI_WATCHDOG___8 = 75,
    KERN_PANIC_ON_NMI___8 = 76
} ;
enum __anonenum_125___8 {
    VM_UNUSED1___8 = 1,
    VM_UNUSED2___8 = 2,
    VM_UNUSED3___8 = 3,
    VM_UNUSED4___8 = 4,
    VM_OVERCOMMIT_MEMORY___8 = 5,
    VM_UNUSED5___8 = 6,
    VM_UNUSED7___8 = 7,
    VM_UNUSED8___8 = 8,
    VM_UNUSED9___8 = 9,
    VM_PAGE_CLUSTER___8 = 10,
    VM_DIRTY_BACKGROUND___8 = 11,
    VM_DIRTY_RATIO___8 = 12,
    VM_DIRTY_WB_CS___8 = 13,
    VM_DIRTY_EXPIRE_CS___8 = 14,
    VM_NR_PDFLUSH_THREADS___8 = 15,
    VM_OVERCOMMIT_RATIO___8 = 16,
    VM_PAGEBUF___8 = 17,
    VM_HUGETLB_PAGES___8 = 18,
    VM_SWAPPINESS___8 = 19,
    VM_LOWMEM_RESERVE_RATIO___8 = 20,
    VM_MIN_FREE_KBYTES___8 = 21,
    VM_MAX_MAP_COUNT___8 = 22,
    VM_LAPTOP_MODE___8 = 23,
    VM_BLOCK_DUMP___8 = 24,
    VM_HUGETLB_GROUP___8 = 25,
    VM_VFS_CACHE_PRESSURE___8 = 26,
    VM_LEGACY_VA_LAYOUT___8 = 27,
    VM_SWAP_TOKEN_TIMEOUT___8 = 28,
    VM_DROP_PAGECACHE___8 = 29,
    VM_PERCPU_PAGELIST_FRACTION___8 = 30,
    VM_ZONE_RECLAIM_MODE___8 = 31,
    VM_MIN_UNMAPPED___8 = 32,
    VM_PANIC_ON_OOM___8 = 33,
    VM_VDSO_ENABLED___8 = 34,
    VM_MIN_SLAB___8 = 35
} ;
enum __anonenum_126___8 {
    NET_CORE___8 = 1,
    NET_ETHER___8 = 2,
    NET_802___8 = 3,
    NET_UNIX___8 = 4,
    NET_IPV4___8 = 5,
    NET_IPX___8 = 6,
    NET_ATALK___8 = 7,
    NET_NETROM___8 = 8,
    NET_AX25___8 = 9,
    NET_BRIDGE___8 = 10,
    NET_ROSE___8 = 11,
    NET_IPV6___8 = 12,
    NET_X25___8 = 13,
    NET_TR___8 = 14,
    NET_DECNET___8 = 15,
    NET_ECONET___8 = 16,
    NET_SCTP___8 = 17,
    NET_LLC___8 = 18,
    NET_NETFILTER___8 = 19,
    NET_DCCP___8 = 20,
    NET_IRDA___8 = 412
} ;
enum __anonenum_127___8 {
    RANDOM_POOLSIZE___8 = 1,
    RANDOM_ENTROPY_COUNT___8 = 2,
    RANDOM_READ_THRESH___8 = 3,
    RANDOM_WRITE_THRESH___8 = 4,
    RANDOM_BOOT_ID___8 = 5,
    RANDOM_UUID___8 = 6
} ;
enum __anonenum_128___8 {
    PTY_MAX___8 = 1,
    PTY_NR___8 = 2
} ;
enum __anonenum_129___8 {
    BUS_ISA_MEM_BASE___8 = 1,
    BUS_ISA_PORT_BASE___8 = 2,
    BUS_ISA_PORT_SHIFT___8 = 3
} ;
enum __anonenum_130___8 {
    NET_CORE_WMEM_MAX___8 = 1,
    NET_CORE_RMEM_MAX___8 = 2,
    NET_CORE_WMEM_DEFAULT___8 = 3,
    NET_CORE_RMEM_DEFAULT___8 = 4,
    NET_CORE_MAX_BACKLOG___8 = 6,
    NET_CORE_FASTROUTE___8 = 7,
    NET_CORE_MSG_COST___8 = 8,
    NET_CORE_MSG_BURST___8 = 9,
    NET_CORE_OPTMEM_MAX___8 = 10,
    NET_CORE_HOT_LIST_LENGTH___8 = 11,
    NET_CORE_DIVERT_VERSION___8 = 12,
    NET_CORE_NO_CONG_THRESH___8 = 13,
    NET_CORE_NO_CONG___8 = 14,
    NET_CORE_LO_CONG___8 = 15,
    NET_CORE_MOD_CONG___8 = 16,
    NET_CORE_DEV_WEIGHT___8 = 17,
    NET_CORE_SOMAXCONN___8 = 18,
    NET_CORE_BUDGET___8 = 19,
    NET_CORE_AEVENT_ETIME___8 = 20,
    NET_CORE_AEVENT_RSEQTH___8 = 21,
    NET_CORE_WARNINGS___8 = 22
} ;
enum __anonenum_131___8 {
    NET_UNIX_DESTROY_DELAY___8 = 1,
    NET_UNIX_DELETE_DELAY___8 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___8 = 3
} ;
enum __anonenum_132___8 {
    NET_NF_CONNTRACK_MAX___8 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___8 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___8 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___8 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___8 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___8 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___8 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___8 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___8 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___8 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___8 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___8 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___8 = 13,
    NET_NF_CONNTRACK_BUCKETS___8 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___8 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___8 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___8 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___8 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___8 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___8 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___8 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___8 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___8 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___8 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___8 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___8 = 26,
    NET_NF_CONNTRACK_COUNT___8 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___8 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___8 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___8 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___8 = 31,
    NET_NF_CONNTRACK_CHECKSUM___8 = 32
} ;
enum __anonenum_133___8 {
    NET_IPV4_FORWARD___8 = 8,
    NET_IPV4_DYNADDR___8 = 9,
    NET_IPV4_CONF___8 = 16,
    NET_IPV4_NEIGH___8 = 17,
    NET_IPV4_ROUTE___8 = 18,
    NET_IPV4_FIB_HASH___8 = 19,
    NET_IPV4_NETFILTER___8 = 20,
    NET_IPV4_TCP_TIMESTAMPS___8 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___8 = 34,
    NET_IPV4_TCP_SACK___8 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___8 = 36,
    NET_IPV4_DEFAULT_TTL___8 = 37,
    NET_IPV4_AUTOCONFIG___8 = 38,
    NET_IPV4_NO_PMTU_DISC___8 = 39,
    NET_IPV4_TCP_SYN_RETRIES___8 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___8 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___8 = 42,
    NET_IPV4_IPFRAG_TIME___8 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___8 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___8 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___8 = 46,
    NET_IPV4_TCP_RETRIES1___8 = 47,
    NET_IPV4_TCP_RETRIES2___8 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___8 = 49,
    NET_IPV4_IP_MASQ_DEBUG___8 = 50,
    NET_TCP_SYNCOOKIES___8 = 51,
    NET_TCP_STDURG___8 = 52,
    NET_TCP_RFC1337___8 = 53,
    NET_TCP_SYN_TAILDROP___8 = 54,
    NET_TCP_MAX_SYN_BACKLOG___8 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___8 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___8 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___8 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___8 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___8 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___8 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___8 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___8 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___8 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___8 = 65,
    NET_TCP_TW_RECYCLE___8 = 66,
    NET_IPV4_ALWAYS_DEFRAG___8 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___8 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___8 = 69,
    NET_IPV4_INET_PEER_MINTTL___8 = 70,
    NET_IPV4_INET_PEER_MAXTTL___8 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___8 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___8 = 73,
    NET_TCP_ORPHAN_RETRIES___8 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___8 = 75,
    NET_TCP_SYNACK_RETRIES___8 = 76,
    NET_TCP_MAX_ORPHANS___8 = 77,
    NET_TCP_MAX_TW_BUCKETS___8 = 78,
    NET_TCP_FACK___8 = 79,
    NET_TCP_REORDERING___8 = 80,
    NET_TCP_ECN___8 = 81,
    NET_TCP_DSACK___8 = 82,
    NET_TCP_MEM___8 = 83,
    NET_TCP_WMEM___8 = 84,
    NET_TCP_RMEM___8 = 85,
    NET_TCP_APP_WIN___8 = 86,
    NET_TCP_ADV_WIN_SCALE___8 = 87,
    NET_IPV4_NONLOCAL_BIND___8 = 88,
    NET_IPV4_ICMP_RATELIMIT___8 = 89,
    NET_IPV4_ICMP_RATEMASK___8 = 90,
    NET_TCP_TW_REUSE___8 = 91,
    NET_TCP_FRTO___8 = 92,
    NET_TCP_LOW_LATENCY___8 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___8 = 94,
    NET_IPV4_IGMP_MAX_MSF___8 = 96,
    NET_TCP_NO_METRICS_SAVE___8 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___8 = 105,
    NET_TCP_MODERATE_RCVBUF___8 = 106,
    NET_TCP_TSO_WIN_DIVISOR___8 = 107,
    NET_TCP_BIC_BETA___8 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___8 = 109,
    NET_TCP_CONG_CONTROL___8 = 110,
    NET_TCP_ABC___8 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___8 = 112,
    NET_TCP_MTU_PROBING___8 = 113,
    NET_TCP_BASE_MSS___8 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___8 = 115,
    NET_TCP_DMA_COPYBREAK___8 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___8 = 117,
    NET_CIPSOV4_CACHE_ENABLE___8 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___8 = 119,
    NET_CIPSOV4_RBM_OPTFMT___8 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___8 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___8 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___8 = 123,
    NET_TCP_MAX_SSTHRESH___8 = 124,
    NET_TCP_FRTO_RESPONSE___8 = 125
} ;
enum __anonenum_134___8 {
    NET_IPV4_ROUTE_FLUSH___8 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___8 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___8 = 3,
    NET_IPV4_ROUTE_GC_THRESH___8 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___8 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___8 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___8 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___8 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___8 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___8 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___8 = 11,
    NET_IPV4_ROUTE_ERROR_COST___8 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___8 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___8 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___8 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___8 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___8 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___8 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___8 = 19
} ;
enum __anonenum_135___8 {
    NET_PROTO_CONF_ALL___8 = -2,
    NET_PROTO_CONF_DEFAULT___8 = -3
} ;
enum __anonenum_136___8 {
    NET_IPV4_CONF_FORWARDING___8 = 1,
    NET_IPV4_CONF_MC_FORWARDING___8 = 2,
    NET_IPV4_CONF_PROXY_ARP___8 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___8 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___8 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___8 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___8 = 7,
    NET_IPV4_CONF_RP_FILTER___8 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___8 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___8 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___8 = 11,
    NET_IPV4_CONF_TAG___8 = 12,
    NET_IPV4_CONF_ARPFILTER___8 = 13,
    NET_IPV4_CONF_MEDIUM_ID___8 = 14,
    NET_IPV4_CONF_NOXFRM___8 = 15,
    NET_IPV4_CONF_NOPOLICY___8 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___8 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___8 = 18,
    NET_IPV4_CONF_ARP_IGNORE___8 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___8 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___8 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___8 = 22,
    __NET_IPV4_CONF_MAX___8 = 23
} ;
enum __anonenum_137___8 {
    NET_IPV4_NF_CONNTRACK_MAX___8 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___8 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___8 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___8 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___8 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___8 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___8 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___8 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___8 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___8 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___8 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___8 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___8 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___8 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___8 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___8 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___8 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___8 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___8 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___8 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___8 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___8 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___8 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___8 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___8 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___8 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___8 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___8 = 28
} ;
enum __anonenum_138___8 {
    NET_IPV6_CONF___8 = 16,
    NET_IPV6_NEIGH___8 = 17,
    NET_IPV6_ROUTE___8 = 18,
    NET_IPV6_ICMP___8 = 19,
    NET_IPV6_BINDV6ONLY___8 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___8 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___8 = 22,
    NET_IPV6_IP6FRAG_TIME___8 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___8 = 24,
    NET_IPV6_MLD_MAX_MSF___8 = 25
} ;
enum __anonenum_139___8 {
    NET_IPV6_ROUTE_FLUSH___8 = 1,
    NET_IPV6_ROUTE_GC_THRESH___8 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___8 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___8 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___8 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___8 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___8 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___8 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___8 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___8 = 10
} ;
enum __anonenum_140___8 {
    NET_IPV6_FORWARDING___8 = 1,
    NET_IPV6_HOP_LIMIT___8 = 2,
    NET_IPV6_MTU___8 = 3,
    NET_IPV6_ACCEPT_RA___8 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___8 = 5,
    NET_IPV6_AUTOCONF___8 = 6,
    NET_IPV6_DAD_TRANSMITS___8 = 7,
    NET_IPV6_RTR_SOLICITS___8 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___8 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___8 = 10,
    NET_IPV6_USE_TEMPADDR___8 = 11,
    NET_IPV6_TEMP_VALID_LFT___8 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___8 = 13,
    NET_IPV6_REGEN_MAX_RETRY___8 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___8 = 15,
    NET_IPV6_MAX_ADDRESSES___8 = 16,
    NET_IPV6_FORCE_MLD_VERSION___8 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___8 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___8 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___8 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___8 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___8 = 22,
    NET_IPV6_PROXY_NDP___8 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___8 = 25,
    __NET_IPV6_MAX___8 = 26
} ;
enum __anonenum_141___8 {
    NET_IPV6_ICMP_RATELIMIT___8 = 1
} ;
enum __anonenum_142___8 {
    NET_NEIGH_MCAST_SOLICIT___8 = 1,
    NET_NEIGH_UCAST_SOLICIT___8 = 2,
    NET_NEIGH_APP_SOLICIT___8 = 3,
    NET_NEIGH_RETRANS_TIME___8 = 4,
    NET_NEIGH_REACHABLE_TIME___8 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___8 = 6,
    NET_NEIGH_GC_STALE_TIME___8 = 7,
    NET_NEIGH_UNRES_QLEN___8 = 8,
    NET_NEIGH_PROXY_QLEN___8 = 9,
    NET_NEIGH_ANYCAST_DELAY___8 = 10,
    NET_NEIGH_PROXY_DELAY___8 = 11,
    NET_NEIGH_LOCKTIME___8 = 12,
    NET_NEIGH_GC_INTERVAL___8 = 13,
    NET_NEIGH_GC_THRESH1___8 = 14,
    NET_NEIGH_GC_THRESH2___8 = 15,
    NET_NEIGH_GC_THRESH3___8 = 16,
    NET_NEIGH_RETRANS_TIME_MS___8 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___8 = 18,
    __NET_NEIGH_MAX___8 = 19
} ;
enum __anonenum_143___8 {
    NET_DCCP_DEFAULT___8 = 1
} ;
enum __anonenum_144___8 {
    NET_IPX_PPROP_BROADCASTING___8 = 1,
    NET_IPX_FORWARDING___8 = 2
} ;
enum __anonenum_145___8 {
    NET_LLC2___8 = 1,
    NET_LLC_STATION___8 = 2
} ;
enum __anonenum_146___8 {
    NET_LLC2_TIMEOUT___8 = 1
} ;
enum __anonenum_147___8 {
    NET_LLC_STATION_ACK_TIMEOUT___8 = 1
} ;
enum __anonenum_148___8 {
    NET_LLC2_ACK_TIMEOUT___8 = 1,
    NET_LLC2_P_TIMEOUT___8 = 2,
    NET_LLC2_REJ_TIMEOUT___8 = 3,
    NET_LLC2_BUSY_TIMEOUT___8 = 4
} ;
enum __anonenum_149___8 {
    NET_ATALK_AARP_EXPIRY_TIME___8 = 1,
    NET_ATALK_AARP_TICK_TIME___8 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___8 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___8 = 4
} ;
enum __anonenum_150___8 {
    NET_NETROM_DEFAULT_PATH_QUALITY___8 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___8 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___8 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___8 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___8 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___8 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___8 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___8 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___8 = 9,
    NET_NETROM_ROUTING_CONTROL___8 = 10,
    NET_NETROM_LINK_FAILS_COUNT___8 = 11,
    NET_NETROM_RESET___8 = 12
} ;
enum __anonenum_151___8 {
    NET_AX25_IP_DEFAULT_MODE___8 = 1,
    NET_AX25_DEFAULT_MODE___8 = 2,
    NET_AX25_BACKOFF_TYPE___8 = 3,
    NET_AX25_CONNECT_MODE___8 = 4,
    NET_AX25_STANDARD_WINDOW___8 = 5,
    NET_AX25_EXTENDED_WINDOW___8 = 6,
    NET_AX25_T1_TIMEOUT___8 = 7,
    NET_AX25_T2_TIMEOUT___8 = 8,
    NET_AX25_T3_TIMEOUT___8 = 9,
    NET_AX25_IDLE_TIMEOUT___8 = 10,
    NET_AX25_N2___8 = 11,
    NET_AX25_PACLEN___8 = 12,
    NET_AX25_PROTOCOL___8 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___8 = 14
} ;
enum __anonenum_152___8 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___8 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___8 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___8 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___8 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___8 = 5,
    NET_ROSE_ROUTING_CONTROL___8 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___8 = 7,
    NET_ROSE_MAX_VCS___8 = 8,
    NET_ROSE_WINDOW_SIZE___8 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___8 = 10
} ;
enum __anonenum_153___8 {
    NET_X25_RESTART_REQUEST_TIMEOUT___8 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___8 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___8 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___8 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___8 = 5,
    NET_X25_FORWARD___8 = 6
} ;
enum __anonenum_154___8 {
    NET_TR_RIF_TIMEOUT___8 = 1
} ;
enum __anonenum_155___8 {
    NET_DECNET_NODE_TYPE___8 = 1,
    NET_DECNET_NODE_ADDRESS___8 = 2,
    NET_DECNET_NODE_NAME___8 = 3,
    NET_DECNET_DEFAULT_DEVICE___8 = 4,
    NET_DECNET_TIME_WAIT___8 = 5,
    NET_DECNET_DN_COUNT___8 = 6,
    NET_DECNET_DI_COUNT___8 = 7,
    NET_DECNET_DR_COUNT___8 = 8,
    NET_DECNET_DST_GC_INTERVAL___8 = 9,
    NET_DECNET_CONF___8 = 10,
    NET_DECNET_NO_FC_MAX_CWND___8 = 11,
    NET_DECNET_MEM___8 = 12,
    NET_DECNET_RMEM___8 = 13,
    NET_DECNET_WMEM___8 = 14,
    NET_DECNET_DEBUG_LEVEL___8 = 255
} ;
enum __anonenum_156___8 {
    NET_DECNET_CONF_LOOPBACK___8 = -2,
    NET_DECNET_CONF_DDCMP___8 = -3,
    NET_DECNET_CONF_PPP___8 = -4,
    NET_DECNET_CONF_X25___8 = -5,
    NET_DECNET_CONF_GRE___8 = -6,
    NET_DECNET_CONF_ETHER___8 = -7
} ;
enum __anonenum_157___8 {
    NET_DECNET_CONF_DEV_PRIORITY___8 = 1,
    NET_DECNET_CONF_DEV_T1___8 = 2,
    NET_DECNET_CONF_DEV_T2___8 = 3,
    NET_DECNET_CONF_DEV_T3___8 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___8 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___8 = 6,
    NET_DECNET_CONF_DEV_STATE___8 = 7
} ;
enum __anonenum_158___8 {
    NET_SCTP_RTO_INITIAL___8 = 1,
    NET_SCTP_RTO_MIN___8 = 2,
    NET_SCTP_RTO_MAX___8 = 3,
    NET_SCTP_RTO_ALPHA___8 = 4,
    NET_SCTP_RTO_BETA___8 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___8 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___8 = 7,
    NET_SCTP_PATH_MAX_RETRANS___8 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___8 = 9,
    NET_SCTP_HB_INTERVAL___8 = 10,
    NET_SCTP_PRESERVE_ENABLE___8 = 11,
    NET_SCTP_MAX_BURST___8 = 12,
    NET_SCTP_ADDIP_ENABLE___8 = 13,
    NET_SCTP_PRSCTP_ENABLE___8 = 14,
    NET_SCTP_SNDBUF_POLICY___8 = 15,
    NET_SCTP_SACK_TIMEOUT___8 = 16,
    NET_SCTP_RCVBUF_POLICY___8 = 17
} ;
enum __anonenum_159___8 {
    NET_BRIDGE_NF_CALL_ARPTABLES___8 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___8 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___8 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___8 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___8 = 5
} ;
enum __anonenum_160___8 {
    NET_IRDA_DISCOVERY___8 = 1,
    NET_IRDA_DEVNAME___8 = 2,
    NET_IRDA_DEBUG___8 = 3,
    NET_IRDA_FAST_POLL___8 = 4,
    NET_IRDA_DISCOVERY_SLOTS___8 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___8 = 6,
    NET_IRDA_SLOT_TIMEOUT___8 = 7,
    NET_IRDA_MAX_BAUD_RATE___8 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___8 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___8 = 10,
    NET_IRDA_MAX_TX_WINDOW___8 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___8 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___8 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___8 = 14
} ;
enum __anonenum_161___8 {
    FS_NRINODE___8 = 1,
    FS_STATINODE___8 = 2,
    FS_MAXINODE___8 = 3,
    FS_NRDQUOT___8 = 4,
    FS_MAXDQUOT___8 = 5,
    FS_NRFILE___8 = 6,
    FS_MAXFILE___8 = 7,
    FS_DENTRY___8 = 8,
    FS_NRSUPER___8 = 9,
    FS_MAXSUPER___8 = 10,
    FS_OVERFLOWUID___8 = 11,
    FS_OVERFLOWGID___8 = 12,
    FS_LEASES___8 = 13,
    FS_DIR_NOTIFY___8 = 14,
    FS_LEASE_TIME___8 = 15,
    FS_DQSTATS___8 = 16,
    FS_XFS___8 = 17,
    FS_AIO_NR___8 = 18,
    FS_AIO_MAX_NR___8 = 19,
    FS_INOTIFY___8 = 20,
    FS_OCFS2___8 = 988
} ;
enum __anonenum_162___8 {
    FS_DQ_LOOKUPS___8 = 1,
    FS_DQ_DROPS___8 = 2,
    FS_DQ_READS___8 = 3,
    FS_DQ_WRITES___8 = 4,
    FS_DQ_CACHE_HITS___8 = 5,
    FS_DQ_ALLOCATED___8 = 6,
    FS_DQ_FREE___8 = 7,
    FS_DQ_SYNCS___8 = 8,
    FS_DQ_WARNINGS___8 = 9
} ;
enum __anonenum_163___8 {
    DEV_CDROM___8 = 1,
    DEV_HWMON___8 = 2,
    DEV_PARPORT___8 = 3,
    DEV_RAID___8 = 4,
    DEV_MAC_HID___8 = 5,
    DEV_SCSI___8 = 6,
    DEV_IPMI___8 = 7
} ;
enum __anonenum_164___8 {
    DEV_CDROM_INFO___8 = 1,
    DEV_CDROM_AUTOCLOSE___8 = 2,
    DEV_CDROM_AUTOEJECT___8 = 3,
    DEV_CDROM_DEBUG___8 = 4,
    DEV_CDROM_LOCK___8 = 5,
    DEV_CDROM_CHECK_MEDIA___8 = 6
} ;
enum __anonenum_165___8 {
    DEV_PARPORT_DEFAULT___8 = -3
} ;
enum __anonenum_166___8 {
    DEV_RAID_SPEED_LIMIT_MIN___8 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___8 = 2
} ;
enum __anonenum_167___5 {
    DEV_PARPORT_DEFAULT_TIMESLICE___8 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___8 = 2
} ;
enum __anonenum_168___5 {
    DEV_PARPORT_SPINTIME___8 = 1,
    DEV_PARPORT_BASE_ADDR___8 = 2,
    DEV_PARPORT_IRQ___8 = 3,
    DEV_PARPORT_DMA___8 = 4,
    DEV_PARPORT_MODES___8 = 5,
    DEV_PARPORT_DEVICES___8 = 6,
    DEV_PARPORT_AUTOPROBE___8 = 16
} ;
enum __anonenum_169___8 {
    DEV_PARPORT_DEVICES_ACTIVE___8 = -3
} ;
enum __anonenum_170___5 {
    DEV_PARPORT_DEVICE_TIMESLICE___8 = 1
} ;
enum __anonenum_171___5 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___8 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___8 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___8 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___8 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___8 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___8 = 6
} ;
enum __anonenum_172___8 {
    DEV_SCSI_LOGGING_LEVEL___8 = 1
} ;
enum __anonenum_173___6 {
    DEV_IPMI_POWEROFF_POWERCYCLE___8 = 1
} ;
enum __anonenum_174___4 {
    ABI_DEFHANDLER_COFF___8 = 1,
    ABI_DEFHANDLER_ELF___8 = 2,
    ABI_DEFHANDLER_LCALL7___8 = 3,
    ABI_DEFHANDLER_LIBCSO___8 = 4,
    ABI_TRACE___8 = 5,
    ABI_FAKE_UTSNAME___8 = 6
} ;
enum __anonenum_177___1 {
    IOCB_CMD_PREAD___8 = 0,
    IOCB_CMD_PWRITE___8 = 1,
    IOCB_CMD_FSYNC___8 = 2,
    IOCB_CMD_FDSYNC___8 = 3,
    IOCB_CMD_NOOP___8 = 6,
    IOCB_CMD_PREADV___8 = 7,
    IOCB_CMD_PWRITEV___8 = 8
} ;
enum __anonenum_180___3 {
    IRQTF_RUNTHREAD___8 = 0,
    IRQTF_DIED___8 = 1,
    IRQTF_WARNED___8 = 2
} ;
enum __anonenum_181___5 {
    HI_SOFTIRQ___8 = 0,
    TIMER_SOFTIRQ___8 = 1,
    NET_TX_SOFTIRQ___8 = 2,
    NET_RX_SOFTIRQ___8 = 3,
    BLOCK_SOFTIRQ___8 = 4,
    TASKLET_SOFTIRQ___8 = 5,
    SCHED_SOFTIRQ___8 = 6,
    HRTIMER_SOFTIRQ___8 = 7,
    RCU_SOFTIRQ___8 = 8,
    NR_SOFTIRQS___8 = 9
} ;
enum __anonenum_182 {
    TASKLET_STATE_SCHED___8 = 0,
    TASKLET_STATE_RUN___8 = 1
} ;
enum __anonenum_184___6 {
    QIF_BLIMITS_B___8 = 0,
    QIF_SPACE_B___8 = 1,
    QIF_ILIMITS_B___8 = 2,
    QIF_INODES_B___8 = 3,
    QIF_BTIME_B___8 = 4,
    QIF_ITIME_B___8 = 5
} ;
enum __anonenum_185___6 {
    QUOTA_NL_C_UNSPEC___8 = 0,
    QUOTA_NL_C_WARNING___8 = 1,
    __QUOTA_NL_C_MAX___8 = 2
} ;
enum __anonenum_186___7 {
    QUOTA_NL_A_UNSPEC___8 = 0,
    QUOTA_NL_A_QTYPE___8 = 1,
    QUOTA_NL_A_EXCESS_ID___8 = 2,
    QUOTA_NL_A_WARNING___8 = 3,
    QUOTA_NL_A_DEV_MAJOR___8 = 4,
    QUOTA_NL_A_DEV_MINOR___8 = 5,
    QUOTA_NL_A_CAUSED_ID___8 = 6,
    __QUOTA_NL_A_MAX___8 = 7
} ;
enum __anonenum_187___0 {
    _DQUOT_USAGE_ENABLED___8 = 0,
    _DQUOT_LIMITS_ENABLED___8 = 1,
    _DQUOT_SUSPENDED___8 = 2,
    _DQUOT_STATE_FLAGS___8 = 3
} ;
enum __anonenum_194___7 {
    SB_UNFROZEN___8 = 0,
    SB_FREEZE_WRITE___8 = 1,
    SB_FREEZE_TRANS___8 = 2
} ;
enum __anonenum_195___0 {
    DIO_LOCKING___8 = 1,
    DIO_NO_LOCKING___8 = 2,
    DIO_OWN_LOCKING___8 = 3
} ;
enum __anonenum_4___9 {
    false___9 = 0,
    true___9 = 1
} ;
enum __anonenum_8___1 {
    DUMP_PREFIX_NONE___9 = 0,
    DUMP_PREFIX_ADDRESS___9 = 1,
    DUMP_PREFIX_OFFSET___9 = 2
} ;
enum __anonenum_15___6 {
    PG_LEVEL_NONE___9 = 0,
    PG_LEVEL_4K___9 = 1,
    PG_LEVEL_2M___9 = 2,
    PG_LEVEL_1G___9 = 3,
    PG_LEVEL_NUM___9 = 4
} ;
enum __anonenum_19___6 {
    GATE_INTERRUPT___9 = 14,
    GATE_TRAP___9 = 15,
    GATE_CALL___9 = 12,
    GATE_TASK___9 = 5
} ;
enum __anonenum_20___7 {
    DESC_TSS___9 = 9,
    DESC_LDT___9 = 2,
    DESCTYPE_S___9 = 16
} ;
enum __anonenum_21___8 {
    ADDR_NO_RANDOMIZE___9 = 262144,
    FDPIC_FUNCPTRS___9 = 524288,
    MMAP_PAGE_ZERO___9 = 1048576,
    ADDR_COMPAT_LAYOUT___9 = 2097152,
    READ_IMPLIES_EXEC___9 = 4194304,
    ADDR_LIMIT_32BIT___9 = 8388608,
    SHORT_INODE___9 = 16777216,
    WHOLE_SECONDS___9 = 33554432,
    STICKY_TIMEOUTS___9 = 67108864,
    ADDR_LIMIT_3GB___9 = 134217728
} ;
enum __anonenum_22___6 {
    PER_LINUX___9 = 0,
    PER_LINUX_32BIT___9 = 8388608,
    PER_LINUX_FDPIC___9 = 524288,
    PER_SVR4___9 = 68157441,
    PER_SVR3___9 = 83886082,
    PER_SCOSVR3___9 = 117440515,
    PER_OSR5___9 = 100663299,
    PER_WYSEV386___9 = 83886084,
    PER_ISCR4___9 = 67108869,
    PER_BSD___9 = 6,
    PER_SUNOS___9 = 67108870,
    PER_XENIX___9 = 83886087,
    PER_LINUX32___9 = 8,
    PER_LINUX32_3GB___9 = 134217736,
    PER_IRIX32___9 = 67108873,
    PER_IRIXN32___9 = 67108874,
    PER_IRIX64___9 = 67108875,
    PER_RISCOS___9 = 12,
    PER_SOLARIS___9 = 67108877,
    PER_UW7___9 = 68157454,
    PER_OSF4___9 = 15,
    PER_HPUX___9 = 16,
    PER_MASK___9 = 255
} ;
union __anonunion_d_37___4 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_119___4 {
    CTL_KERN___9 = 1,
    CTL_VM___9 = 2,
    CTL_NET___9 = 3,
    CTL_PROC___9 = 4,
    CTL_FS___9 = 5,
    CTL_DEBUG___9 = 6,
    CTL_DEV___9 = 7,
    CTL_BUS___9 = 8,
    CTL_ABI___9 = 9,
    CTL_CPU___9 = 10,
    CTL_ARLAN___9 = 254,
    CTL_S390DBF___9 = 5677,
    CTL_SUNRPC___9 = 7249,
    CTL_PM___9 = 9899,
    CTL_FRV___9 = 9898
} ;
enum __anonenum_120___6 {
    CTL_BUS_ISA___9 = 1
} ;
enum __anonenum_121___7 {
    INOTIFY_MAX_USER_INSTANCES___9 = 1,
    INOTIFY_MAX_USER_WATCHES___9 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___9 = 3
} ;
enum __anonenum_122___7 {
    KERN_OSTYPE___9 = 1,
    KERN_OSRELEASE___9 = 2,
    KERN_OSREV___9 = 3,
    KERN_VERSION___9 = 4,
    KERN_SECUREMASK___9 = 5,
    KERN_PROF___9 = 6,
    KERN_NODENAME___9 = 7,
    KERN_DOMAINNAME___9 = 8,
    KERN_PANIC___9 = 15,
    KERN_REALROOTDEV___9 = 16,
    KERN_SPARC_REBOOT___9 = 21,
    KERN_CTLALTDEL___9 = 22,
    KERN_PRINTK___9 = 23,
    KERN_NAMETRANS___9 = 24,
    KERN_PPC_HTABRECLAIM___9 = 25,
    KERN_PPC_ZEROPAGED___9 = 26,
    KERN_PPC_POWERSAVE_NAP___9 = 27,
    KERN_MODPROBE___9 = 28,
    KERN_SG_BIG_BUFF___9 = 29,
    KERN_ACCT___9 = 30,
    KERN_PPC_L2CR___9 = 31,
    KERN_RTSIGNR___9 = 32,
    KERN_RTSIGMAX___9 = 33,
    KERN_SHMMAX___9 = 34,
    KERN_MSGMAX___9 = 35,
    KERN_MSGMNB___9 = 36,
    KERN_MSGPOOL___9 = 37,
    KERN_SYSRQ___9 = 38,
    KERN_MAX_THREADS___9 = 39,
    KERN_RANDOM___9 = 40,
    KERN_SHMALL___9 = 41,
    KERN_MSGMNI___9 = 42,
    KERN_SEM___9 = 43,
    KERN_SPARC_STOP_A___9 = 44,
    KERN_SHMMNI___9 = 45,
    KERN_OVERFLOWUID___9 = 46,
    KERN_OVERFLOWGID___9 = 47,
    KERN_SHMPATH___9 = 48,
    KERN_HOTPLUG___9 = 49,
    KERN_IEEE_EMULATION_WARNINGS___9 = 50,
    KERN_S390_USER_DEBUG_LOGGING___9 = 51,
    KERN_CORE_USES_PID___9 = 52,
    KERN_TAINTED___9 = 53,
    KERN_CADPID___9 = 54,
    KERN_PIDMAX___9 = 55,
    KERN_CORE_PATTERN___9 = 56,
    KERN_PANIC_ON_OOPS___9 = 57,
    KERN_HPPA_PWRSW___9 = 58,
    KERN_HPPA_UNALIGNED___9 = 59,
    KERN_PRINTK_RATELIMIT___9 = 60,
    KERN_PRINTK_RATELIMIT_BURST___9 = 61,
    KERN_PTY___9 = 62,
    KERN_NGROUPS_MAX___9 = 63,
    KERN_SPARC_SCONS_PWROFF___9 = 64,
    KERN_HZ_TIMER___9 = 65,
    KERN_UNKNOWN_NMI_PANIC___9 = 66,
    KERN_BOOTLOADER_TYPE___9 = 67,
    KERN_RANDOMIZE___9 = 68,
    KERN_SETUID_DUMPABLE___9 = 69,
    KERN_SPIN_RETRY___9 = 70,
    KERN_ACPI_VIDEO_FLAGS___9 = 71,
    KERN_IA64_UNALIGNED___9 = 72,
    KERN_COMPAT_LOG___9 = 73,
    KERN_MAX_LOCK_DEPTH___9 = 74,
    KERN_NMI_WATCHDOG___9 = 75,
    KERN_PANIC_ON_NMI___9 = 76
} ;
enum __anonenum_123___7 {
    VM_UNUSED1___9 = 1,
    VM_UNUSED2___9 = 2,
    VM_UNUSED3___9 = 3,
    VM_UNUSED4___9 = 4,
    VM_OVERCOMMIT_MEMORY___9 = 5,
    VM_UNUSED5___9 = 6,
    VM_UNUSED7___9 = 7,
    VM_UNUSED8___9 = 8,
    VM_UNUSED9___9 = 9,
    VM_PAGE_CLUSTER___9 = 10,
    VM_DIRTY_BACKGROUND___9 = 11,
    VM_DIRTY_RATIO___9 = 12,
    VM_DIRTY_WB_CS___9 = 13,
    VM_DIRTY_EXPIRE_CS___9 = 14,
    VM_NR_PDFLUSH_THREADS___9 = 15,
    VM_OVERCOMMIT_RATIO___9 = 16,
    VM_PAGEBUF___9 = 17,
    VM_HUGETLB_PAGES___9 = 18,
    VM_SWAPPINESS___9 = 19,
    VM_LOWMEM_RESERVE_RATIO___9 = 20,
    VM_MIN_FREE_KBYTES___9 = 21,
    VM_MAX_MAP_COUNT___9 = 22,
    VM_LAPTOP_MODE___9 = 23,
    VM_BLOCK_DUMP___9 = 24,
    VM_HUGETLB_GROUP___9 = 25,
    VM_VFS_CACHE_PRESSURE___9 = 26,
    VM_LEGACY_VA_LAYOUT___9 = 27,
    VM_SWAP_TOKEN_TIMEOUT___9 = 28,
    VM_DROP_PAGECACHE___9 = 29,
    VM_PERCPU_PAGELIST_FRACTION___9 = 30,
    VM_ZONE_RECLAIM_MODE___9 = 31,
    VM_MIN_UNMAPPED___9 = 32,
    VM_PANIC_ON_OOM___9 = 33,
    VM_VDSO_ENABLED___9 = 34,
    VM_MIN_SLAB___9 = 35
} ;
enum __anonenum_124___7 {
    NET_CORE___9 = 1,
    NET_ETHER___9 = 2,
    NET_802___9 = 3,
    NET_UNIX___9 = 4,
    NET_IPV4___9 = 5,
    NET_IPX___9 = 6,
    NET_ATALK___9 = 7,
    NET_NETROM___9 = 8,
    NET_AX25___9 = 9,
    NET_BRIDGE___9 = 10,
    NET_ROSE___9 = 11,
    NET_IPV6___9 = 12,
    NET_X25___9 = 13,
    NET_TR___9 = 14,
    NET_DECNET___9 = 15,
    NET_ECONET___9 = 16,
    NET_SCTP___9 = 17,
    NET_LLC___9 = 18,
    NET_NETFILTER___9 = 19,
    NET_DCCP___9 = 20,
    NET_IRDA___9 = 412
} ;
enum __anonenum_125___9 {
    RANDOM_POOLSIZE___9 = 1,
    RANDOM_ENTROPY_COUNT___9 = 2,
    RANDOM_READ_THRESH___9 = 3,
    RANDOM_WRITE_THRESH___9 = 4,
    RANDOM_BOOT_ID___9 = 5,
    RANDOM_UUID___9 = 6
} ;
enum __anonenum_126___9 {
    PTY_MAX___9 = 1,
    PTY_NR___9 = 2
} ;
enum __anonenum_127___9 {
    BUS_ISA_MEM_BASE___9 = 1,
    BUS_ISA_PORT_BASE___9 = 2,
    BUS_ISA_PORT_SHIFT___9 = 3
} ;
enum __anonenum_128___9 {
    NET_CORE_WMEM_MAX___9 = 1,
    NET_CORE_RMEM_MAX___9 = 2,
    NET_CORE_WMEM_DEFAULT___9 = 3,
    NET_CORE_RMEM_DEFAULT___9 = 4,
    NET_CORE_MAX_BACKLOG___9 = 6,
    NET_CORE_FASTROUTE___9 = 7,
    NET_CORE_MSG_COST___9 = 8,
    NET_CORE_MSG_BURST___9 = 9,
    NET_CORE_OPTMEM_MAX___9 = 10,
    NET_CORE_HOT_LIST_LENGTH___9 = 11,
    NET_CORE_DIVERT_VERSION___9 = 12,
    NET_CORE_NO_CONG_THRESH___9 = 13,
    NET_CORE_NO_CONG___9 = 14,
    NET_CORE_LO_CONG___9 = 15,
    NET_CORE_MOD_CONG___9 = 16,
    NET_CORE_DEV_WEIGHT___9 = 17,
    NET_CORE_SOMAXCONN___9 = 18,
    NET_CORE_BUDGET___9 = 19,
    NET_CORE_AEVENT_ETIME___9 = 20,
    NET_CORE_AEVENT_RSEQTH___9 = 21,
    NET_CORE_WARNINGS___9 = 22
} ;
enum __anonenum_129___9 {
    NET_UNIX_DESTROY_DELAY___9 = 1,
    NET_UNIX_DELETE_DELAY___9 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___9 = 3
} ;
enum __anonenum_130___9 {
    NET_NF_CONNTRACK_MAX___9 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___9 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___9 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___9 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___9 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___9 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___9 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___9 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___9 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___9 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___9 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___9 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___9 = 13,
    NET_NF_CONNTRACK_BUCKETS___9 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___9 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___9 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___9 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___9 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___9 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___9 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___9 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___9 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___9 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___9 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___9 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___9 = 26,
    NET_NF_CONNTRACK_COUNT___9 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___9 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___9 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___9 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___9 = 31,
    NET_NF_CONNTRACK_CHECKSUM___9 = 32
} ;
enum __anonenum_131___9 {
    NET_IPV4_FORWARD___9 = 8,
    NET_IPV4_DYNADDR___9 = 9,
    NET_IPV4_CONF___9 = 16,
    NET_IPV4_NEIGH___9 = 17,
    NET_IPV4_ROUTE___9 = 18,
    NET_IPV4_FIB_HASH___9 = 19,
    NET_IPV4_NETFILTER___9 = 20,
    NET_IPV4_TCP_TIMESTAMPS___9 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___9 = 34,
    NET_IPV4_TCP_SACK___9 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___9 = 36,
    NET_IPV4_DEFAULT_TTL___9 = 37,
    NET_IPV4_AUTOCONFIG___9 = 38,
    NET_IPV4_NO_PMTU_DISC___9 = 39,
    NET_IPV4_TCP_SYN_RETRIES___9 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___9 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___9 = 42,
    NET_IPV4_IPFRAG_TIME___9 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___9 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___9 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___9 = 46,
    NET_IPV4_TCP_RETRIES1___9 = 47,
    NET_IPV4_TCP_RETRIES2___9 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___9 = 49,
    NET_IPV4_IP_MASQ_DEBUG___9 = 50,
    NET_TCP_SYNCOOKIES___9 = 51,
    NET_TCP_STDURG___9 = 52,
    NET_TCP_RFC1337___9 = 53,
    NET_TCP_SYN_TAILDROP___9 = 54,
    NET_TCP_MAX_SYN_BACKLOG___9 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___9 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___9 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___9 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___9 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___9 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___9 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___9 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___9 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___9 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___9 = 65,
    NET_TCP_TW_RECYCLE___9 = 66,
    NET_IPV4_ALWAYS_DEFRAG___9 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___9 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___9 = 69,
    NET_IPV4_INET_PEER_MINTTL___9 = 70,
    NET_IPV4_INET_PEER_MAXTTL___9 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___9 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___9 = 73,
    NET_TCP_ORPHAN_RETRIES___9 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___9 = 75,
    NET_TCP_SYNACK_RETRIES___9 = 76,
    NET_TCP_MAX_ORPHANS___9 = 77,
    NET_TCP_MAX_TW_BUCKETS___9 = 78,
    NET_TCP_FACK___9 = 79,
    NET_TCP_REORDERING___9 = 80,
    NET_TCP_ECN___9 = 81,
    NET_TCP_DSACK___9 = 82,
    NET_TCP_MEM___9 = 83,
    NET_TCP_WMEM___9 = 84,
    NET_TCP_RMEM___9 = 85,
    NET_TCP_APP_WIN___9 = 86,
    NET_TCP_ADV_WIN_SCALE___9 = 87,
    NET_IPV4_NONLOCAL_BIND___9 = 88,
    NET_IPV4_ICMP_RATELIMIT___9 = 89,
    NET_IPV4_ICMP_RATEMASK___9 = 90,
    NET_TCP_TW_REUSE___9 = 91,
    NET_TCP_FRTO___9 = 92,
    NET_TCP_LOW_LATENCY___9 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___9 = 94,
    NET_IPV4_IGMP_MAX_MSF___9 = 96,
    NET_TCP_NO_METRICS_SAVE___9 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___9 = 105,
    NET_TCP_MODERATE_RCVBUF___9 = 106,
    NET_TCP_TSO_WIN_DIVISOR___9 = 107,
    NET_TCP_BIC_BETA___9 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___9 = 109,
    NET_TCP_CONG_CONTROL___9 = 110,
    NET_TCP_ABC___9 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___9 = 112,
    NET_TCP_MTU_PROBING___9 = 113,
    NET_TCP_BASE_MSS___9 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___9 = 115,
    NET_TCP_DMA_COPYBREAK___9 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___9 = 117,
    NET_CIPSOV4_CACHE_ENABLE___9 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___9 = 119,
    NET_CIPSOV4_RBM_OPTFMT___9 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___9 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___9 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___9 = 123,
    NET_TCP_MAX_SSTHRESH___9 = 124,
    NET_TCP_FRTO_RESPONSE___9 = 125
} ;
enum __anonenum_132___9 {
    NET_IPV4_ROUTE_FLUSH___9 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___9 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___9 = 3,
    NET_IPV4_ROUTE_GC_THRESH___9 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___9 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___9 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___9 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___9 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___9 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___9 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___9 = 11,
    NET_IPV4_ROUTE_ERROR_COST___9 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___9 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___9 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___9 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___9 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___9 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___9 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___9 = 19
} ;
enum __anonenum_133___9 {
    NET_PROTO_CONF_ALL___9 = -2,
    NET_PROTO_CONF_DEFAULT___9 = -3
} ;
enum __anonenum_134___9 {
    NET_IPV4_CONF_FORWARDING___9 = 1,
    NET_IPV4_CONF_MC_FORWARDING___9 = 2,
    NET_IPV4_CONF_PROXY_ARP___9 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___9 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___9 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___9 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___9 = 7,
    NET_IPV4_CONF_RP_FILTER___9 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___9 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___9 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___9 = 11,
    NET_IPV4_CONF_TAG___9 = 12,
    NET_IPV4_CONF_ARPFILTER___9 = 13,
    NET_IPV4_CONF_MEDIUM_ID___9 = 14,
    NET_IPV4_CONF_NOXFRM___9 = 15,
    NET_IPV4_CONF_NOPOLICY___9 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___9 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___9 = 18,
    NET_IPV4_CONF_ARP_IGNORE___9 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___9 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___9 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___9 = 22,
    __NET_IPV4_CONF_MAX___9 = 23
} ;
enum __anonenum_135___9 {
    NET_IPV4_NF_CONNTRACK_MAX___9 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___9 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___9 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___9 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___9 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___9 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___9 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___9 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___9 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___9 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___9 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___9 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___9 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___9 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___9 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___9 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___9 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___9 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___9 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___9 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___9 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___9 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___9 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___9 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___9 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___9 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___9 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___9 = 28
} ;
enum __anonenum_136___9 {
    NET_IPV6_CONF___9 = 16,
    NET_IPV6_NEIGH___9 = 17,
    NET_IPV6_ROUTE___9 = 18,
    NET_IPV6_ICMP___9 = 19,
    NET_IPV6_BINDV6ONLY___9 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___9 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___9 = 22,
    NET_IPV6_IP6FRAG_TIME___9 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___9 = 24,
    NET_IPV6_MLD_MAX_MSF___9 = 25
} ;
enum __anonenum_137___9 {
    NET_IPV6_ROUTE_FLUSH___9 = 1,
    NET_IPV6_ROUTE_GC_THRESH___9 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___9 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___9 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___9 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___9 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___9 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___9 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___9 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___9 = 10
} ;
enum __anonenum_138___9 {
    NET_IPV6_FORWARDING___9 = 1,
    NET_IPV6_HOP_LIMIT___9 = 2,
    NET_IPV6_MTU___9 = 3,
    NET_IPV6_ACCEPT_RA___9 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___9 = 5,
    NET_IPV6_AUTOCONF___9 = 6,
    NET_IPV6_DAD_TRANSMITS___9 = 7,
    NET_IPV6_RTR_SOLICITS___9 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___9 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___9 = 10,
    NET_IPV6_USE_TEMPADDR___9 = 11,
    NET_IPV6_TEMP_VALID_LFT___9 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___9 = 13,
    NET_IPV6_REGEN_MAX_RETRY___9 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___9 = 15,
    NET_IPV6_MAX_ADDRESSES___9 = 16,
    NET_IPV6_FORCE_MLD_VERSION___9 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___9 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___9 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___9 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___9 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___9 = 22,
    NET_IPV6_PROXY_NDP___9 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___9 = 25,
    __NET_IPV6_MAX___9 = 26
} ;
enum __anonenum_139___9 {
    NET_IPV6_ICMP_RATELIMIT___9 = 1
} ;
enum __anonenum_140___9 {
    NET_NEIGH_MCAST_SOLICIT___9 = 1,
    NET_NEIGH_UCAST_SOLICIT___9 = 2,
    NET_NEIGH_APP_SOLICIT___9 = 3,
    NET_NEIGH_RETRANS_TIME___9 = 4,
    NET_NEIGH_REACHABLE_TIME___9 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___9 = 6,
    NET_NEIGH_GC_STALE_TIME___9 = 7,
    NET_NEIGH_UNRES_QLEN___9 = 8,
    NET_NEIGH_PROXY_QLEN___9 = 9,
    NET_NEIGH_ANYCAST_DELAY___9 = 10,
    NET_NEIGH_PROXY_DELAY___9 = 11,
    NET_NEIGH_LOCKTIME___9 = 12,
    NET_NEIGH_GC_INTERVAL___9 = 13,
    NET_NEIGH_GC_THRESH1___9 = 14,
    NET_NEIGH_GC_THRESH2___9 = 15,
    NET_NEIGH_GC_THRESH3___9 = 16,
    NET_NEIGH_RETRANS_TIME_MS___9 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___9 = 18,
    __NET_NEIGH_MAX___9 = 19
} ;
enum __anonenum_141___9 {
    NET_DCCP_DEFAULT___9 = 1
} ;
enum __anonenum_142___9 {
    NET_IPX_PPROP_BROADCASTING___9 = 1,
    NET_IPX_FORWARDING___9 = 2
} ;
enum __anonenum_143___9 {
    NET_LLC2___9 = 1,
    NET_LLC_STATION___9 = 2
} ;
enum __anonenum_144___9 {
    NET_LLC2_TIMEOUT___9 = 1
} ;
enum __anonenum_145___9 {
    NET_LLC_STATION_ACK_TIMEOUT___9 = 1
} ;
enum __anonenum_146___9 {
    NET_LLC2_ACK_TIMEOUT___9 = 1,
    NET_LLC2_P_TIMEOUT___9 = 2,
    NET_LLC2_REJ_TIMEOUT___9 = 3,
    NET_LLC2_BUSY_TIMEOUT___9 = 4
} ;
enum __anonenum_147___9 {
    NET_ATALK_AARP_EXPIRY_TIME___9 = 1,
    NET_ATALK_AARP_TICK_TIME___9 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___9 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___9 = 4
} ;
enum __anonenum_148___9 {
    NET_NETROM_DEFAULT_PATH_QUALITY___9 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___9 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___9 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___9 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___9 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___9 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___9 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___9 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___9 = 9,
    NET_NETROM_ROUTING_CONTROL___9 = 10,
    NET_NETROM_LINK_FAILS_COUNT___9 = 11,
    NET_NETROM_RESET___9 = 12
} ;
enum __anonenum_149___9 {
    NET_AX25_IP_DEFAULT_MODE___9 = 1,
    NET_AX25_DEFAULT_MODE___9 = 2,
    NET_AX25_BACKOFF_TYPE___9 = 3,
    NET_AX25_CONNECT_MODE___9 = 4,
    NET_AX25_STANDARD_WINDOW___9 = 5,
    NET_AX25_EXTENDED_WINDOW___9 = 6,
    NET_AX25_T1_TIMEOUT___9 = 7,
    NET_AX25_T2_TIMEOUT___9 = 8,
    NET_AX25_T3_TIMEOUT___9 = 9,
    NET_AX25_IDLE_TIMEOUT___9 = 10,
    NET_AX25_N2___9 = 11,
    NET_AX25_PACLEN___9 = 12,
    NET_AX25_PROTOCOL___9 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___9 = 14
} ;
enum __anonenum_150___9 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___9 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___9 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___9 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___9 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___9 = 5,
    NET_ROSE_ROUTING_CONTROL___9 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___9 = 7,
    NET_ROSE_MAX_VCS___9 = 8,
    NET_ROSE_WINDOW_SIZE___9 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___9 = 10
} ;
enum __anonenum_151___9 {
    NET_X25_RESTART_REQUEST_TIMEOUT___9 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___9 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___9 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___9 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___9 = 5,
    NET_X25_FORWARD___9 = 6
} ;
enum __anonenum_152___9 {
    NET_TR_RIF_TIMEOUT___9 = 1
} ;
enum __anonenum_153___9 {
    NET_DECNET_NODE_TYPE___9 = 1,
    NET_DECNET_NODE_ADDRESS___9 = 2,
    NET_DECNET_NODE_NAME___9 = 3,
    NET_DECNET_DEFAULT_DEVICE___9 = 4,
    NET_DECNET_TIME_WAIT___9 = 5,
    NET_DECNET_DN_COUNT___9 = 6,
    NET_DECNET_DI_COUNT___9 = 7,
    NET_DECNET_DR_COUNT___9 = 8,
    NET_DECNET_DST_GC_INTERVAL___9 = 9,
    NET_DECNET_CONF___9 = 10,
    NET_DECNET_NO_FC_MAX_CWND___9 = 11,
    NET_DECNET_MEM___9 = 12,
    NET_DECNET_RMEM___9 = 13,
    NET_DECNET_WMEM___9 = 14,
    NET_DECNET_DEBUG_LEVEL___9 = 255
} ;
enum __anonenum_154___9 {
    NET_DECNET_CONF_LOOPBACK___9 = -2,
    NET_DECNET_CONF_DDCMP___9 = -3,
    NET_DECNET_CONF_PPP___9 = -4,
    NET_DECNET_CONF_X25___9 = -5,
    NET_DECNET_CONF_GRE___9 = -6,
    NET_DECNET_CONF_ETHER___9 = -7
} ;
enum __anonenum_155___9 {
    NET_DECNET_CONF_DEV_PRIORITY___9 = 1,
    NET_DECNET_CONF_DEV_T1___9 = 2,
    NET_DECNET_CONF_DEV_T2___9 = 3,
    NET_DECNET_CONF_DEV_T3___9 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___9 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___9 = 6,
    NET_DECNET_CONF_DEV_STATE___9 = 7
} ;
enum __anonenum_156___9 {
    NET_SCTP_RTO_INITIAL___9 = 1,
    NET_SCTP_RTO_MIN___9 = 2,
    NET_SCTP_RTO_MAX___9 = 3,
    NET_SCTP_RTO_ALPHA___9 = 4,
    NET_SCTP_RTO_BETA___9 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___9 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___9 = 7,
    NET_SCTP_PATH_MAX_RETRANS___9 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___9 = 9,
    NET_SCTP_HB_INTERVAL___9 = 10,
    NET_SCTP_PRESERVE_ENABLE___9 = 11,
    NET_SCTP_MAX_BURST___9 = 12,
    NET_SCTP_ADDIP_ENABLE___9 = 13,
    NET_SCTP_PRSCTP_ENABLE___9 = 14,
    NET_SCTP_SNDBUF_POLICY___9 = 15,
    NET_SCTP_SACK_TIMEOUT___9 = 16,
    NET_SCTP_RCVBUF_POLICY___9 = 17
} ;
enum __anonenum_157___9 {
    NET_BRIDGE_NF_CALL_ARPTABLES___9 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___9 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___9 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___9 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___9 = 5
} ;
enum __anonenum_158___9 {
    NET_IRDA_DISCOVERY___9 = 1,
    NET_IRDA_DEVNAME___9 = 2,
    NET_IRDA_DEBUG___9 = 3,
    NET_IRDA_FAST_POLL___9 = 4,
    NET_IRDA_DISCOVERY_SLOTS___9 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___9 = 6,
    NET_IRDA_SLOT_TIMEOUT___9 = 7,
    NET_IRDA_MAX_BAUD_RATE___9 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___9 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___9 = 10,
    NET_IRDA_MAX_TX_WINDOW___9 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___9 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___9 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___9 = 14
} ;
enum __anonenum_159___9 {
    FS_NRINODE___9 = 1,
    FS_STATINODE___9 = 2,
    FS_MAXINODE___9 = 3,
    FS_NRDQUOT___9 = 4,
    FS_MAXDQUOT___9 = 5,
    FS_NRFILE___9 = 6,
    FS_MAXFILE___9 = 7,
    FS_DENTRY___9 = 8,
    FS_NRSUPER___9 = 9,
    FS_MAXSUPER___9 = 10,
    FS_OVERFLOWUID___9 = 11,
    FS_OVERFLOWGID___9 = 12,
    FS_LEASES___9 = 13,
    FS_DIR_NOTIFY___9 = 14,
    FS_LEASE_TIME___9 = 15,
    FS_DQSTATS___9 = 16,
    FS_XFS___9 = 17,
    FS_AIO_NR___9 = 18,
    FS_AIO_MAX_NR___9 = 19,
    FS_INOTIFY___9 = 20,
    FS_OCFS2___9 = 988
} ;
enum __anonenum_160___9 {
    FS_DQ_LOOKUPS___9 = 1,
    FS_DQ_DROPS___9 = 2,
    FS_DQ_READS___9 = 3,
    FS_DQ_WRITES___9 = 4,
    FS_DQ_CACHE_HITS___9 = 5,
    FS_DQ_ALLOCATED___9 = 6,
    FS_DQ_FREE___9 = 7,
    FS_DQ_SYNCS___9 = 8,
    FS_DQ_WARNINGS___9 = 9
} ;
enum __anonenum_161___9 {
    DEV_CDROM___9 = 1,
    DEV_HWMON___9 = 2,
    DEV_PARPORT___9 = 3,
    DEV_RAID___9 = 4,
    DEV_MAC_HID___9 = 5,
    DEV_SCSI___9 = 6,
    DEV_IPMI___9 = 7
} ;
enum __anonenum_162___9 {
    DEV_CDROM_INFO___9 = 1,
    DEV_CDROM_AUTOCLOSE___9 = 2,
    DEV_CDROM_AUTOEJECT___9 = 3,
    DEV_CDROM_DEBUG___9 = 4,
    DEV_CDROM_LOCK___9 = 5,
    DEV_CDROM_CHECK_MEDIA___9 = 6
} ;
enum __anonenum_163___9 {
    DEV_PARPORT_DEFAULT___9 = -3
} ;
enum __anonenum_164___9 {
    DEV_RAID_SPEED_LIMIT_MIN___9 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___9 = 2
} ;
enum __anonenum_165___9 {
    DEV_PARPORT_DEFAULT_TIMESLICE___9 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___9 = 2
} ;
enum __anonenum_166___9 {
    DEV_PARPORT_SPINTIME___9 = 1,
    DEV_PARPORT_BASE_ADDR___9 = 2,
    DEV_PARPORT_IRQ___9 = 3,
    DEV_PARPORT_DMA___9 = 4,
    DEV_PARPORT_MODES___9 = 5,
    DEV_PARPORT_DEVICES___9 = 6,
    DEV_PARPORT_AUTOPROBE___9 = 16
} ;
enum __anonenum_167___6 {
    DEV_PARPORT_DEVICES_ACTIVE___9 = -3
} ;
enum __anonenum_168___6 {
    DEV_PARPORT_DEVICE_TIMESLICE___9 = 1
} ;
enum __anonenum_169___9 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___9 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___9 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___9 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___9 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___9 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___9 = 6
} ;
enum __anonenum_170___6 {
    DEV_SCSI_LOGGING_LEVEL___9 = 1
} ;
enum __anonenum_171___6 {
    DEV_IPMI_POWEROFF_POWERCYCLE___9 = 1
} ;
enum __anonenum_172___9 {
    ABI_DEFHANDLER_COFF___9 = 1,
    ABI_DEFHANDLER_ELF___9 = 2,
    ABI_DEFHANDLER_LCALL7___9 = 3,
    ABI_DEFHANDLER_LIBCSO___9 = 4,
    ABI_TRACE___9 = 5,
    ABI_FAKE_UTSNAME___9 = 6
} ;
enum __anonenum_175___3 {
    IOCB_CMD_PREAD___9 = 0,
    IOCB_CMD_PWRITE___9 = 1,
    IOCB_CMD_FSYNC___9 = 2,
    IOCB_CMD_FDSYNC___9 = 3,
    IOCB_CMD_NOOP___9 = 6,
    IOCB_CMD_PREADV___9 = 7,
    IOCB_CMD_PWRITEV___9 = 8
} ;
enum __anonenum_179___3 {
    IRQTF_RUNTHREAD___9 = 0,
    IRQTF_DIED___9 = 1,
    IRQTF_WARNED___9 = 2
} ;
enum __anonenum_180___4 {
    HI_SOFTIRQ___9 = 0,
    TIMER_SOFTIRQ___9 = 1,
    NET_TX_SOFTIRQ___9 = 2,
    NET_RX_SOFTIRQ___9 = 3,
    BLOCK_SOFTIRQ___9 = 4,
    TASKLET_SOFTIRQ___9 = 5,
    SCHED_SOFTIRQ___9 = 6,
    HRTIMER_SOFTIRQ___9 = 7,
    RCU_SOFTIRQ___9 = 8,
    NR_SOFTIRQS___9 = 9
} ;
enum __anonenum_181___6 {
    TASKLET_STATE_SCHED___9 = 0,
    TASKLET_STATE_RUN___9 = 1
} ;
enum __anonenum_183___6 {
    QIF_BLIMITS_B___9 = 0,
    QIF_SPACE_B___9 = 1,
    QIF_ILIMITS_B___9 = 2,
    QIF_INODES_B___9 = 3,
    QIF_BTIME_B___9 = 4,
    QIF_ITIME_B___9 = 5
} ;
enum __anonenum_184___7 {
    QUOTA_NL_C_UNSPEC___9 = 0,
    QUOTA_NL_C_WARNING___9 = 1,
    __QUOTA_NL_C_MAX___9 = 2
} ;
enum __anonenum_185___7 {
    QUOTA_NL_A_UNSPEC___9 = 0,
    QUOTA_NL_A_QTYPE___9 = 1,
    QUOTA_NL_A_EXCESS_ID___9 = 2,
    QUOTA_NL_A_WARNING___9 = 3,
    QUOTA_NL_A_DEV_MAJOR___9 = 4,
    QUOTA_NL_A_DEV_MINOR___9 = 5,
    QUOTA_NL_A_CAUSED_ID___9 = 6,
    __QUOTA_NL_A_MAX___9 = 7
} ;
enum __anonenum_186___8 {
    _DQUOT_USAGE_ENABLED___9 = 0,
    _DQUOT_LIMITS_ENABLED___9 = 1,
    _DQUOT_SUSPENDED___9 = 2,
    _DQUOT_STATE_FLAGS___9 = 3
} ;
enum __anonenum_193___7 {
    SB_UNFROZEN___9 = 0,
    SB_FREEZE_WRITE___9 = 1,
    SB_FREEZE_TRANS___9 = 2
} ;
enum __anonenum_194___8 {
    DIO_LOCKING___9 = 1,
    DIO_NO_LOCKING___9 = 2,
    DIO_OWN_LOCKING___9 = 3
} ;
union __anonunion_status_195 {
   struct usb_hub_status hub ;
   struct usb_port_status port ;
};
struct usb_hub {
   struct device *intfdev ;
   struct usb_device *hdev ;
   struct kref kref ;
   struct urb *urb ;
   char (*buffer)[8] ;
   dma_addr_t buffer_dma ;
   union __anonunion_status_195 *status ;
   struct mutex status_mutex ;
   int error ;
   int nerrors ;
   struct list_head event_list ;
   unsigned long event_bits[1] ;
   unsigned long change_bits[1] ;
   unsigned long busy_bits[1] ;
   struct usb_hub_descriptor *descriptor ;
   struct usb_tt tt ;
   unsigned int mA_per_port ;
   unsigned int limited_power : 1 ;
   unsigned int quiescing : 1 ;
   unsigned int disconnected : 1 ;
   unsigned int has_indicators : 1 ;
   u8 indicator[31] ;
   struct delayed_work leds ;
   struct delayed_work init_work ;
};
enum hub_activation_type {
    HUB_INIT = 0,
    HUB_INIT2 = 1,
    HUB_INIT3 = 2,
    HUB_POST_RESET = 3,
    HUB_RESUME = 4,
    HUB_RESET_RESUME = 5
} ;
enum hub_quiescing_type {
    HUB_DISCONNECT = 0,
    HUB_PRE_RESET = 1,
    HUB_SUSPEND = 2
} ;
enum __anonenum_4___10 {
    false___10 = 0,
    true___10 = 1
} ;
enum __anonenum_10___5 {
    DUMP_PREFIX_NONE___10 = 0,
    DUMP_PREFIX_ADDRESS___10 = 1,
    DUMP_PREFIX_OFFSET___10 = 2
} ;
enum __anonenum_15___7 {
    PG_LEVEL_NONE___10 = 0,
    PG_LEVEL_4K___10 = 1,
    PG_LEVEL_2M___10 = 2,
    PG_LEVEL_1G___10 = 3,
    PG_LEVEL_NUM___10 = 4
} ;
enum __anonenum_19___7 {
    GATE_INTERRUPT___10 = 14,
    GATE_TRAP___10 = 15,
    GATE_CALL___10 = 12,
    GATE_TASK___10 = 5
} ;
enum __anonenum_20___8 {
    DESC_TSS___10 = 9,
    DESC_LDT___10 = 2,
    DESCTYPE_S___10 = 16
} ;
enum __anonenum_21___9 {
    ADDR_NO_RANDOMIZE___10 = 262144,
    FDPIC_FUNCPTRS___10 = 524288,
    MMAP_PAGE_ZERO___10 = 1048576,
    ADDR_COMPAT_LAYOUT___10 = 2097152,
    READ_IMPLIES_EXEC___10 = 4194304,
    ADDR_LIMIT_32BIT___10 = 8388608,
    SHORT_INODE___10 = 16777216,
    WHOLE_SECONDS___10 = 33554432,
    STICKY_TIMEOUTS___10 = 67108864,
    ADDR_LIMIT_3GB___10 = 134217728
} ;
enum __anonenum_22___7 {
    PER_LINUX___10 = 0,
    PER_LINUX_32BIT___10 = 8388608,
    PER_LINUX_FDPIC___10 = 524288,
    PER_SVR4___10 = 68157441,
    PER_SVR3___10 = 83886082,
    PER_SCOSVR3___10 = 117440515,
    PER_OSR5___10 = 100663299,
    PER_WYSEV386___10 = 83886084,
    PER_ISCR4___10 = 67108869,
    PER_BSD___10 = 6,
    PER_SUNOS___10 = 67108870,
    PER_XENIX___10 = 83886087,
    PER_LINUX32___10 = 8,
    PER_LINUX32_3GB___10 = 134217736,
    PER_IRIX32___10 = 67108873,
    PER_IRIXN32___10 = 67108874,
    PER_IRIX64___10 = 67108875,
    PER_RISCOS___10 = 12,
    PER_SOLARIS___10 = 67108877,
    PER_UW7___10 = 68157454,
    PER_OSF4___10 = 15,
    PER_HPUX___10 = 16,
    PER_MASK___10 = 255
} ;
union __anonunion_d_37___5 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_102 {
    QIF_BLIMITS_B___10 = 0,
    QIF_SPACE_B___10 = 1,
    QIF_ILIMITS_B___10 = 2,
    QIF_INODES_B___10 = 3,
    QIF_BTIME_B___10 = 4,
    QIF_ITIME_B___10 = 5
} ;
enum __anonenum_103 {
    QUOTA_NL_C_UNSPEC___10 = 0,
    QUOTA_NL_C_WARNING___10 = 1,
    __QUOTA_NL_C_MAX___10 = 2
} ;
enum __anonenum_104 {
    QUOTA_NL_A_UNSPEC___10 = 0,
    QUOTA_NL_A_QTYPE___10 = 1,
    QUOTA_NL_A_EXCESS_ID___10 = 2,
    QUOTA_NL_A_WARNING___10 = 3,
    QUOTA_NL_A_DEV_MAJOR___10 = 4,
    QUOTA_NL_A_DEV_MINOR___10 = 5,
    QUOTA_NL_A_CAUSED_ID___10 = 6,
    __QUOTA_NL_A_MAX___10 = 7
} ;
enum __anonenum_105 {
    _DQUOT_USAGE_ENABLED___10 = 0,
    _DQUOT_LIMITS_ENABLED___10 = 1,
    _DQUOT_SUSPENDED___10 = 2,
    _DQUOT_STATE_FLAGS___10 = 3
} ;
enum __anonenum_112 {
    SB_UNFROZEN___10 = 0,
    SB_FREEZE_WRITE___10 = 1,
    SB_FREEZE_TRANS___10 = 2
} ;
enum __anonenum_113___2 {
    DIO_LOCKING___10 = 1,
    DIO_NO_LOCKING___10 = 2,
    DIO_OWN_LOCKING___10 = 3
} ;
struct vfsmount {
   struct list_head mnt_hash ;
   struct vfsmount *mnt_parent ;
   struct dentry *mnt_mountpoint ;
   struct dentry *mnt_root ;
   struct super_block *mnt_sb ;
   struct list_head mnt_mounts ;
   struct list_head mnt_child ;
   int mnt_flags ;
   char const   *mnt_devname ;
   struct list_head mnt_list ;
   struct list_head mnt_expire ;
   struct list_head mnt_share ;
   struct list_head mnt_slave_list ;
   struct list_head mnt_slave ;
   struct vfsmount *mnt_master ;
   struct mnt_namespace *mnt_ns ;
   int mnt_id ;
   int mnt_group_id ;
   atomic_t mnt_count ;
   int mnt_expiry_mark ;
   int mnt_pinned ;
   int mnt_ghosts ;
   atomic_t __mnt_writers ;
};
enum __anonenum_132___10 {
    CTL_KERN___10 = 1,
    CTL_VM___10 = 2,
    CTL_NET___10 = 3,
    CTL_PROC___10 = 4,
    CTL_FS___10 = 5,
    CTL_DEBUG___10 = 6,
    CTL_DEV___10 = 7,
    CTL_BUS___10 = 8,
    CTL_ABI___10 = 9,
    CTL_CPU___10 = 10,
    CTL_ARLAN___10 = 254,
    CTL_S390DBF___10 = 5677,
    CTL_SUNRPC___10 = 7249,
    CTL_PM___10 = 9899,
    CTL_FRV___10 = 9898
} ;
enum __anonenum_133___10 {
    CTL_BUS_ISA___10 = 1
} ;
enum __anonenum_134___10 {
    INOTIFY_MAX_USER_INSTANCES___10 = 1,
    INOTIFY_MAX_USER_WATCHES___10 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___10 = 3
} ;
enum __anonenum_135___10 {
    KERN_OSTYPE___10 = 1,
    KERN_OSRELEASE___10 = 2,
    KERN_OSREV___10 = 3,
    KERN_VERSION___10 = 4,
    KERN_SECUREMASK___10 = 5,
    KERN_PROF___10 = 6,
    KERN_NODENAME___10 = 7,
    KERN_DOMAINNAME___10 = 8,
    KERN_PANIC___10 = 15,
    KERN_REALROOTDEV___10 = 16,
    KERN_SPARC_REBOOT___10 = 21,
    KERN_CTLALTDEL___10 = 22,
    KERN_PRINTK___10 = 23,
    KERN_NAMETRANS___10 = 24,
    KERN_PPC_HTABRECLAIM___10 = 25,
    KERN_PPC_ZEROPAGED___10 = 26,
    KERN_PPC_POWERSAVE_NAP___10 = 27,
    KERN_MODPROBE___10 = 28,
    KERN_SG_BIG_BUFF___10 = 29,
    KERN_ACCT___10 = 30,
    KERN_PPC_L2CR___10 = 31,
    KERN_RTSIGNR___10 = 32,
    KERN_RTSIGMAX___10 = 33,
    KERN_SHMMAX___10 = 34,
    KERN_MSGMAX___10 = 35,
    KERN_MSGMNB___10 = 36,
    KERN_MSGPOOL___10 = 37,
    KERN_SYSRQ___10 = 38,
    KERN_MAX_THREADS___10 = 39,
    KERN_RANDOM___10 = 40,
    KERN_SHMALL___10 = 41,
    KERN_MSGMNI___10 = 42,
    KERN_SEM___10 = 43,
    KERN_SPARC_STOP_A___10 = 44,
    KERN_SHMMNI___10 = 45,
    KERN_OVERFLOWUID___10 = 46,
    KERN_OVERFLOWGID___10 = 47,
    KERN_SHMPATH___10 = 48,
    KERN_HOTPLUG___10 = 49,
    KERN_IEEE_EMULATION_WARNINGS___10 = 50,
    KERN_S390_USER_DEBUG_LOGGING___10 = 51,
    KERN_CORE_USES_PID___10 = 52,
    KERN_TAINTED___10 = 53,
    KERN_CADPID___10 = 54,
    KERN_PIDMAX___10 = 55,
    KERN_CORE_PATTERN___10 = 56,
    KERN_PANIC_ON_OOPS___10 = 57,
    KERN_HPPA_PWRSW___10 = 58,
    KERN_HPPA_UNALIGNED___10 = 59,
    KERN_PRINTK_RATELIMIT___10 = 60,
    KERN_PRINTK_RATELIMIT_BURST___10 = 61,
    KERN_PTY___10 = 62,
    KERN_NGROUPS_MAX___10 = 63,
    KERN_SPARC_SCONS_PWROFF___10 = 64,
    KERN_HZ_TIMER___10 = 65,
    KERN_UNKNOWN_NMI_PANIC___10 = 66,
    KERN_BOOTLOADER_TYPE___10 = 67,
    KERN_RANDOMIZE___10 = 68,
    KERN_SETUID_DUMPABLE___10 = 69,
    KERN_SPIN_RETRY___10 = 70,
    KERN_ACPI_VIDEO_FLAGS___10 = 71,
    KERN_IA64_UNALIGNED___10 = 72,
    KERN_COMPAT_LOG___10 = 73,
    KERN_MAX_LOCK_DEPTH___10 = 74,
    KERN_NMI_WATCHDOG___10 = 75,
    KERN_PANIC_ON_NMI___10 = 76
} ;
enum __anonenum_136___10 {
    VM_UNUSED1___10 = 1,
    VM_UNUSED2___10 = 2,
    VM_UNUSED3___10 = 3,
    VM_UNUSED4___10 = 4,
    VM_OVERCOMMIT_MEMORY___10 = 5,
    VM_UNUSED5___10 = 6,
    VM_UNUSED7___10 = 7,
    VM_UNUSED8___10 = 8,
    VM_UNUSED9___10 = 9,
    VM_PAGE_CLUSTER___10 = 10,
    VM_DIRTY_BACKGROUND___10 = 11,
    VM_DIRTY_RATIO___10 = 12,
    VM_DIRTY_WB_CS___10 = 13,
    VM_DIRTY_EXPIRE_CS___10 = 14,
    VM_NR_PDFLUSH_THREADS___10 = 15,
    VM_OVERCOMMIT_RATIO___10 = 16,
    VM_PAGEBUF___10 = 17,
    VM_HUGETLB_PAGES___10 = 18,
    VM_SWAPPINESS___10 = 19,
    VM_LOWMEM_RESERVE_RATIO___10 = 20,
    VM_MIN_FREE_KBYTES___10 = 21,
    VM_MAX_MAP_COUNT___10 = 22,
    VM_LAPTOP_MODE___10 = 23,
    VM_BLOCK_DUMP___10 = 24,
    VM_HUGETLB_GROUP___10 = 25,
    VM_VFS_CACHE_PRESSURE___10 = 26,
    VM_LEGACY_VA_LAYOUT___10 = 27,
    VM_SWAP_TOKEN_TIMEOUT___10 = 28,
    VM_DROP_PAGECACHE___10 = 29,
    VM_PERCPU_PAGELIST_FRACTION___10 = 30,
    VM_ZONE_RECLAIM_MODE___10 = 31,
    VM_MIN_UNMAPPED___10 = 32,
    VM_PANIC_ON_OOM___10 = 33,
    VM_VDSO_ENABLED___10 = 34,
    VM_MIN_SLAB___10 = 35
} ;
enum __anonenum_137___10 {
    NET_CORE___10 = 1,
    NET_ETHER___10 = 2,
    NET_802___10 = 3,
    NET_UNIX___10 = 4,
    NET_IPV4___10 = 5,
    NET_IPX___10 = 6,
    NET_ATALK___10 = 7,
    NET_NETROM___10 = 8,
    NET_AX25___10 = 9,
    NET_BRIDGE___10 = 10,
    NET_ROSE___10 = 11,
    NET_IPV6___10 = 12,
    NET_X25___10 = 13,
    NET_TR___10 = 14,
    NET_DECNET___10 = 15,
    NET_ECONET___10 = 16,
    NET_SCTP___10 = 17,
    NET_LLC___10 = 18,
    NET_NETFILTER___10 = 19,
    NET_DCCP___10 = 20,
    NET_IRDA___10 = 412
} ;
enum __anonenum_138___10 {
    RANDOM_POOLSIZE___10 = 1,
    RANDOM_ENTROPY_COUNT___10 = 2,
    RANDOM_READ_THRESH___10 = 3,
    RANDOM_WRITE_THRESH___10 = 4,
    RANDOM_BOOT_ID___10 = 5,
    RANDOM_UUID___10 = 6
} ;
enum __anonenum_139___10 {
    PTY_MAX___10 = 1,
    PTY_NR___10 = 2
} ;
enum __anonenum_140___10 {
    BUS_ISA_MEM_BASE___10 = 1,
    BUS_ISA_PORT_BASE___10 = 2,
    BUS_ISA_PORT_SHIFT___10 = 3
} ;
enum __anonenum_141___10 {
    NET_CORE_WMEM_MAX___10 = 1,
    NET_CORE_RMEM_MAX___10 = 2,
    NET_CORE_WMEM_DEFAULT___10 = 3,
    NET_CORE_RMEM_DEFAULT___10 = 4,
    NET_CORE_MAX_BACKLOG___10 = 6,
    NET_CORE_FASTROUTE___10 = 7,
    NET_CORE_MSG_COST___10 = 8,
    NET_CORE_MSG_BURST___10 = 9,
    NET_CORE_OPTMEM_MAX___10 = 10,
    NET_CORE_HOT_LIST_LENGTH___10 = 11,
    NET_CORE_DIVERT_VERSION___10 = 12,
    NET_CORE_NO_CONG_THRESH___10 = 13,
    NET_CORE_NO_CONG___10 = 14,
    NET_CORE_LO_CONG___10 = 15,
    NET_CORE_MOD_CONG___10 = 16,
    NET_CORE_DEV_WEIGHT___10 = 17,
    NET_CORE_SOMAXCONN___10 = 18,
    NET_CORE_BUDGET___10 = 19,
    NET_CORE_AEVENT_ETIME___10 = 20,
    NET_CORE_AEVENT_RSEQTH___10 = 21,
    NET_CORE_WARNINGS___10 = 22
} ;
enum __anonenum_142___10 {
    NET_UNIX_DESTROY_DELAY___10 = 1,
    NET_UNIX_DELETE_DELAY___10 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___10 = 3
} ;
enum __anonenum_143___10 {
    NET_NF_CONNTRACK_MAX___10 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___10 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___10 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___10 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___10 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___10 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___10 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___10 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___10 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___10 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___10 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___10 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___10 = 13,
    NET_NF_CONNTRACK_BUCKETS___10 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___10 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___10 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___10 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___10 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___10 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___10 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___10 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___10 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___10 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___10 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___10 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___10 = 26,
    NET_NF_CONNTRACK_COUNT___10 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___10 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___10 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___10 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___10 = 31,
    NET_NF_CONNTRACK_CHECKSUM___10 = 32
} ;
enum __anonenum_144___10 {
    NET_IPV4_FORWARD___10 = 8,
    NET_IPV4_DYNADDR___10 = 9,
    NET_IPV4_CONF___10 = 16,
    NET_IPV4_NEIGH___10 = 17,
    NET_IPV4_ROUTE___10 = 18,
    NET_IPV4_FIB_HASH___10 = 19,
    NET_IPV4_NETFILTER___10 = 20,
    NET_IPV4_TCP_TIMESTAMPS___10 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___10 = 34,
    NET_IPV4_TCP_SACK___10 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___10 = 36,
    NET_IPV4_DEFAULT_TTL___10 = 37,
    NET_IPV4_AUTOCONFIG___10 = 38,
    NET_IPV4_NO_PMTU_DISC___10 = 39,
    NET_IPV4_TCP_SYN_RETRIES___10 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___10 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___10 = 42,
    NET_IPV4_IPFRAG_TIME___10 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___10 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___10 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___10 = 46,
    NET_IPV4_TCP_RETRIES1___10 = 47,
    NET_IPV4_TCP_RETRIES2___10 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___10 = 49,
    NET_IPV4_IP_MASQ_DEBUG___10 = 50,
    NET_TCP_SYNCOOKIES___10 = 51,
    NET_TCP_STDURG___10 = 52,
    NET_TCP_RFC1337___10 = 53,
    NET_TCP_SYN_TAILDROP___10 = 54,
    NET_TCP_MAX_SYN_BACKLOG___10 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___10 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___10 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___10 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___10 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___10 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___10 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___10 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___10 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___10 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___10 = 65,
    NET_TCP_TW_RECYCLE___10 = 66,
    NET_IPV4_ALWAYS_DEFRAG___10 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___10 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___10 = 69,
    NET_IPV4_INET_PEER_MINTTL___10 = 70,
    NET_IPV4_INET_PEER_MAXTTL___10 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___10 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___10 = 73,
    NET_TCP_ORPHAN_RETRIES___10 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___10 = 75,
    NET_TCP_SYNACK_RETRIES___10 = 76,
    NET_TCP_MAX_ORPHANS___10 = 77,
    NET_TCP_MAX_TW_BUCKETS___10 = 78,
    NET_TCP_FACK___10 = 79,
    NET_TCP_REORDERING___10 = 80,
    NET_TCP_ECN___10 = 81,
    NET_TCP_DSACK___10 = 82,
    NET_TCP_MEM___10 = 83,
    NET_TCP_WMEM___10 = 84,
    NET_TCP_RMEM___10 = 85,
    NET_TCP_APP_WIN___10 = 86,
    NET_TCP_ADV_WIN_SCALE___10 = 87,
    NET_IPV4_NONLOCAL_BIND___10 = 88,
    NET_IPV4_ICMP_RATELIMIT___10 = 89,
    NET_IPV4_ICMP_RATEMASK___10 = 90,
    NET_TCP_TW_REUSE___10 = 91,
    NET_TCP_FRTO___10 = 92,
    NET_TCP_LOW_LATENCY___10 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___10 = 94,
    NET_IPV4_IGMP_MAX_MSF___10 = 96,
    NET_TCP_NO_METRICS_SAVE___10 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___10 = 105,
    NET_TCP_MODERATE_RCVBUF___10 = 106,
    NET_TCP_TSO_WIN_DIVISOR___10 = 107,
    NET_TCP_BIC_BETA___10 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___10 = 109,
    NET_TCP_CONG_CONTROL___10 = 110,
    NET_TCP_ABC___10 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___10 = 112,
    NET_TCP_MTU_PROBING___10 = 113,
    NET_TCP_BASE_MSS___10 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___10 = 115,
    NET_TCP_DMA_COPYBREAK___10 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___10 = 117,
    NET_CIPSOV4_CACHE_ENABLE___10 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___10 = 119,
    NET_CIPSOV4_RBM_OPTFMT___10 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___10 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___10 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___10 = 123,
    NET_TCP_MAX_SSTHRESH___10 = 124,
    NET_TCP_FRTO_RESPONSE___10 = 125
} ;
enum __anonenum_145___10 {
    NET_IPV4_ROUTE_FLUSH___10 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___10 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___10 = 3,
    NET_IPV4_ROUTE_GC_THRESH___10 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___10 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___10 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___10 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___10 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___10 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___10 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___10 = 11,
    NET_IPV4_ROUTE_ERROR_COST___10 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___10 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___10 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___10 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___10 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___10 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___10 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___10 = 19
} ;
enum __anonenum_146___10 {
    NET_PROTO_CONF_ALL___10 = -2,
    NET_PROTO_CONF_DEFAULT___10 = -3
} ;
enum __anonenum_147___10 {
    NET_IPV4_CONF_FORWARDING___10 = 1,
    NET_IPV4_CONF_MC_FORWARDING___10 = 2,
    NET_IPV4_CONF_PROXY_ARP___10 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___10 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___10 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___10 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___10 = 7,
    NET_IPV4_CONF_RP_FILTER___10 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___10 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___10 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___10 = 11,
    NET_IPV4_CONF_TAG___10 = 12,
    NET_IPV4_CONF_ARPFILTER___10 = 13,
    NET_IPV4_CONF_MEDIUM_ID___10 = 14,
    NET_IPV4_CONF_NOXFRM___10 = 15,
    NET_IPV4_CONF_NOPOLICY___10 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___10 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___10 = 18,
    NET_IPV4_CONF_ARP_IGNORE___10 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___10 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___10 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___10 = 22,
    __NET_IPV4_CONF_MAX___10 = 23
} ;
enum __anonenum_148___10 {
    NET_IPV4_NF_CONNTRACK_MAX___10 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___10 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___10 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___10 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___10 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___10 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___10 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___10 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___10 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___10 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___10 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___10 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___10 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___10 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___10 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___10 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___10 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___10 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___10 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___10 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___10 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___10 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___10 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___10 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___10 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___10 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___10 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___10 = 28
} ;
enum __anonenum_149___10 {
    NET_IPV6_CONF___10 = 16,
    NET_IPV6_NEIGH___10 = 17,
    NET_IPV6_ROUTE___10 = 18,
    NET_IPV6_ICMP___10 = 19,
    NET_IPV6_BINDV6ONLY___10 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___10 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___10 = 22,
    NET_IPV6_IP6FRAG_TIME___10 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___10 = 24,
    NET_IPV6_MLD_MAX_MSF___10 = 25
} ;
enum __anonenum_150___10 {
    NET_IPV6_ROUTE_FLUSH___10 = 1,
    NET_IPV6_ROUTE_GC_THRESH___10 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___10 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___10 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___10 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___10 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___10 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___10 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___10 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___10 = 10
} ;
enum __anonenum_151___10 {
    NET_IPV6_FORWARDING___10 = 1,
    NET_IPV6_HOP_LIMIT___10 = 2,
    NET_IPV6_MTU___10 = 3,
    NET_IPV6_ACCEPT_RA___10 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___10 = 5,
    NET_IPV6_AUTOCONF___10 = 6,
    NET_IPV6_DAD_TRANSMITS___10 = 7,
    NET_IPV6_RTR_SOLICITS___10 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___10 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___10 = 10,
    NET_IPV6_USE_TEMPADDR___10 = 11,
    NET_IPV6_TEMP_VALID_LFT___10 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___10 = 13,
    NET_IPV6_REGEN_MAX_RETRY___10 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___10 = 15,
    NET_IPV6_MAX_ADDRESSES___10 = 16,
    NET_IPV6_FORCE_MLD_VERSION___10 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___10 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___10 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___10 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___10 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___10 = 22,
    NET_IPV6_PROXY_NDP___10 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___10 = 25,
    __NET_IPV6_MAX___10 = 26
} ;
enum __anonenum_152___10 {
    NET_IPV6_ICMP_RATELIMIT___10 = 1
} ;
enum __anonenum_153___10 {
    NET_NEIGH_MCAST_SOLICIT___10 = 1,
    NET_NEIGH_UCAST_SOLICIT___10 = 2,
    NET_NEIGH_APP_SOLICIT___10 = 3,
    NET_NEIGH_RETRANS_TIME___10 = 4,
    NET_NEIGH_REACHABLE_TIME___10 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___10 = 6,
    NET_NEIGH_GC_STALE_TIME___10 = 7,
    NET_NEIGH_UNRES_QLEN___10 = 8,
    NET_NEIGH_PROXY_QLEN___10 = 9,
    NET_NEIGH_ANYCAST_DELAY___10 = 10,
    NET_NEIGH_PROXY_DELAY___10 = 11,
    NET_NEIGH_LOCKTIME___10 = 12,
    NET_NEIGH_GC_INTERVAL___10 = 13,
    NET_NEIGH_GC_THRESH1___10 = 14,
    NET_NEIGH_GC_THRESH2___10 = 15,
    NET_NEIGH_GC_THRESH3___10 = 16,
    NET_NEIGH_RETRANS_TIME_MS___10 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___10 = 18,
    __NET_NEIGH_MAX___10 = 19
} ;
enum __anonenum_154___10 {
    NET_DCCP_DEFAULT___10 = 1
} ;
enum __anonenum_155___10 {
    NET_IPX_PPROP_BROADCASTING___10 = 1,
    NET_IPX_FORWARDING___10 = 2
} ;
enum __anonenum_156___10 {
    NET_LLC2___10 = 1,
    NET_LLC_STATION___10 = 2
} ;
enum __anonenum_157___10 {
    NET_LLC2_TIMEOUT___10 = 1
} ;
enum __anonenum_158___10 {
    NET_LLC_STATION_ACK_TIMEOUT___10 = 1
} ;
enum __anonenum_159___10 {
    NET_LLC2_ACK_TIMEOUT___10 = 1,
    NET_LLC2_P_TIMEOUT___10 = 2,
    NET_LLC2_REJ_TIMEOUT___10 = 3,
    NET_LLC2_BUSY_TIMEOUT___10 = 4
} ;
enum __anonenum_160___10 {
    NET_ATALK_AARP_EXPIRY_TIME___10 = 1,
    NET_ATALK_AARP_TICK_TIME___10 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___10 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___10 = 4
} ;
enum __anonenum_161___10 {
    NET_NETROM_DEFAULT_PATH_QUALITY___10 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___10 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___10 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___10 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___10 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___10 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___10 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___10 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___10 = 9,
    NET_NETROM_ROUTING_CONTROL___10 = 10,
    NET_NETROM_LINK_FAILS_COUNT___10 = 11,
    NET_NETROM_RESET___10 = 12
} ;
enum __anonenum_162___10 {
    NET_AX25_IP_DEFAULT_MODE___10 = 1,
    NET_AX25_DEFAULT_MODE___10 = 2,
    NET_AX25_BACKOFF_TYPE___10 = 3,
    NET_AX25_CONNECT_MODE___10 = 4,
    NET_AX25_STANDARD_WINDOW___10 = 5,
    NET_AX25_EXTENDED_WINDOW___10 = 6,
    NET_AX25_T1_TIMEOUT___10 = 7,
    NET_AX25_T2_TIMEOUT___10 = 8,
    NET_AX25_T3_TIMEOUT___10 = 9,
    NET_AX25_IDLE_TIMEOUT___10 = 10,
    NET_AX25_N2___10 = 11,
    NET_AX25_PACLEN___10 = 12,
    NET_AX25_PROTOCOL___10 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___10 = 14
} ;
enum __anonenum_163___10 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___10 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___10 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___10 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___10 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___10 = 5,
    NET_ROSE_ROUTING_CONTROL___10 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___10 = 7,
    NET_ROSE_MAX_VCS___10 = 8,
    NET_ROSE_WINDOW_SIZE___10 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___10 = 10
} ;
enum __anonenum_164___10 {
    NET_X25_RESTART_REQUEST_TIMEOUT___10 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___10 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___10 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___10 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___10 = 5,
    NET_X25_FORWARD___10 = 6
} ;
enum __anonenum_165___10 {
    NET_TR_RIF_TIMEOUT___10 = 1
} ;
enum __anonenum_166___10 {
    NET_DECNET_NODE_TYPE___10 = 1,
    NET_DECNET_NODE_ADDRESS___10 = 2,
    NET_DECNET_NODE_NAME___10 = 3,
    NET_DECNET_DEFAULT_DEVICE___10 = 4,
    NET_DECNET_TIME_WAIT___10 = 5,
    NET_DECNET_DN_COUNT___10 = 6,
    NET_DECNET_DI_COUNT___10 = 7,
    NET_DECNET_DR_COUNT___10 = 8,
    NET_DECNET_DST_GC_INTERVAL___10 = 9,
    NET_DECNET_CONF___10 = 10,
    NET_DECNET_NO_FC_MAX_CWND___10 = 11,
    NET_DECNET_MEM___10 = 12,
    NET_DECNET_RMEM___10 = 13,
    NET_DECNET_WMEM___10 = 14,
    NET_DECNET_DEBUG_LEVEL___10 = 255
} ;
enum __anonenum_167___7 {
    NET_DECNET_CONF_LOOPBACK___10 = -2,
    NET_DECNET_CONF_DDCMP___10 = -3,
    NET_DECNET_CONF_PPP___10 = -4,
    NET_DECNET_CONF_X25___10 = -5,
    NET_DECNET_CONF_GRE___10 = -6,
    NET_DECNET_CONF_ETHER___10 = -7
} ;
enum __anonenum_168___7 {
    NET_DECNET_CONF_DEV_PRIORITY___10 = 1,
    NET_DECNET_CONF_DEV_T1___10 = 2,
    NET_DECNET_CONF_DEV_T2___10 = 3,
    NET_DECNET_CONF_DEV_T3___10 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___10 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___10 = 6,
    NET_DECNET_CONF_DEV_STATE___10 = 7
} ;
enum __anonenum_169___10 {
    NET_SCTP_RTO_INITIAL___10 = 1,
    NET_SCTP_RTO_MIN___10 = 2,
    NET_SCTP_RTO_MAX___10 = 3,
    NET_SCTP_RTO_ALPHA___10 = 4,
    NET_SCTP_RTO_BETA___10 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___10 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___10 = 7,
    NET_SCTP_PATH_MAX_RETRANS___10 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___10 = 9,
    NET_SCTP_HB_INTERVAL___10 = 10,
    NET_SCTP_PRESERVE_ENABLE___10 = 11,
    NET_SCTP_MAX_BURST___10 = 12,
    NET_SCTP_ADDIP_ENABLE___10 = 13,
    NET_SCTP_PRSCTP_ENABLE___10 = 14,
    NET_SCTP_SNDBUF_POLICY___10 = 15,
    NET_SCTP_SACK_TIMEOUT___10 = 16,
    NET_SCTP_RCVBUF_POLICY___10 = 17
} ;
enum __anonenum_170___7 {
    NET_BRIDGE_NF_CALL_ARPTABLES___10 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___10 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___10 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___10 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___10 = 5
} ;
enum __anonenum_171___7 {
    NET_IRDA_DISCOVERY___10 = 1,
    NET_IRDA_DEVNAME___10 = 2,
    NET_IRDA_DEBUG___10 = 3,
    NET_IRDA_FAST_POLL___10 = 4,
    NET_IRDA_DISCOVERY_SLOTS___10 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___10 = 6,
    NET_IRDA_SLOT_TIMEOUT___10 = 7,
    NET_IRDA_MAX_BAUD_RATE___10 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___10 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___10 = 10,
    NET_IRDA_MAX_TX_WINDOW___10 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___10 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___10 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___10 = 14
} ;
enum __anonenum_172___10 {
    FS_NRINODE___10 = 1,
    FS_STATINODE___10 = 2,
    FS_MAXINODE___10 = 3,
    FS_NRDQUOT___10 = 4,
    FS_MAXDQUOT___10 = 5,
    FS_NRFILE___10 = 6,
    FS_MAXFILE___10 = 7,
    FS_DENTRY___10 = 8,
    FS_NRSUPER___10 = 9,
    FS_MAXSUPER___10 = 10,
    FS_OVERFLOWUID___10 = 11,
    FS_OVERFLOWGID___10 = 12,
    FS_LEASES___10 = 13,
    FS_DIR_NOTIFY___10 = 14,
    FS_LEASE_TIME___10 = 15,
    FS_DQSTATS___10 = 16,
    FS_XFS___10 = 17,
    FS_AIO_NR___10 = 18,
    FS_AIO_MAX_NR___10 = 19,
    FS_INOTIFY___10 = 20,
    FS_OCFS2___10 = 988
} ;
enum __anonenum_173___7 {
    FS_DQ_LOOKUPS___10 = 1,
    FS_DQ_DROPS___10 = 2,
    FS_DQ_READS___10 = 3,
    FS_DQ_WRITES___10 = 4,
    FS_DQ_CACHE_HITS___10 = 5,
    FS_DQ_ALLOCATED___10 = 6,
    FS_DQ_FREE___10 = 7,
    FS_DQ_SYNCS___10 = 8,
    FS_DQ_WARNINGS___10 = 9
} ;
enum __anonenum_174___5 {
    DEV_CDROM___10 = 1,
    DEV_HWMON___10 = 2,
    DEV_PARPORT___10 = 3,
    DEV_RAID___10 = 4,
    DEV_MAC_HID___10 = 5,
    DEV_SCSI___10 = 6,
    DEV_IPMI___10 = 7
} ;
enum __anonenum_175___4 {
    DEV_CDROM_INFO___10 = 1,
    DEV_CDROM_AUTOCLOSE___10 = 2,
    DEV_CDROM_AUTOEJECT___10 = 3,
    DEV_CDROM_DEBUG___10 = 4,
    DEV_CDROM_LOCK___10 = 5,
    DEV_CDROM_CHECK_MEDIA___10 = 6
} ;
enum __anonenum_176___3 {
    DEV_PARPORT_DEFAULT___10 = -3
} ;
enum __anonenum_177___2 {
    DEV_RAID_SPEED_LIMIT_MIN___10 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___10 = 2
} ;
enum __anonenum_178___1 {
    DEV_PARPORT_DEFAULT_TIMESLICE___10 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___10 = 2
} ;
enum __anonenum_179___4 {
    DEV_PARPORT_SPINTIME___10 = 1,
    DEV_PARPORT_BASE_ADDR___10 = 2,
    DEV_PARPORT_IRQ___10 = 3,
    DEV_PARPORT_DMA___10 = 4,
    DEV_PARPORT_MODES___10 = 5,
    DEV_PARPORT_DEVICES___10 = 6,
    DEV_PARPORT_AUTOPROBE___10 = 16
} ;
enum __anonenum_180___5 {
    DEV_PARPORT_DEVICES_ACTIVE___10 = -3
} ;
enum __anonenum_181___7 {
    DEV_PARPORT_DEVICE_TIMESLICE___10 = 1
} ;
enum __anonenum_182___0 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___10 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___10 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___10 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___10 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___10 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___10 = 6
} ;
enum __anonenum_183___7 {
    DEV_SCSI_LOGGING_LEVEL___10 = 1
} ;
enum __anonenum_184___8 {
    DEV_IPMI_POWEROFF_POWERCYCLE___10 = 1
} ;
enum __anonenum_185___8 {
    ABI_DEFHANDLER_COFF___10 = 1,
    ABI_DEFHANDLER_ELF___10 = 2,
    ABI_DEFHANDLER_LCALL7___10 = 3,
    ABI_DEFHANDLER_LIBCSO___10 = 4,
    ABI_TRACE___10 = 5,
    ABI_FAKE_UTSNAME___10 = 6
} ;
enum __anonenum_188___0 {
    IOCB_CMD_PREAD___10 = 0,
    IOCB_CMD_PWRITE___10 = 1,
    IOCB_CMD_FSYNC___10 = 2,
    IOCB_CMD_FDSYNC___10 = 3,
    IOCB_CMD_NOOP___10 = 6,
    IOCB_CMD_PREADV___10 = 7,
    IOCB_CMD_PWRITEV___10 = 8
} ;
enum __anonenum_191 {
    IRQTF_RUNTHREAD___10 = 0,
    IRQTF_DIED___10 = 1,
    IRQTF_WARNED___10 = 2
} ;
enum __anonenum_192 {
    HI_SOFTIRQ___10 = 0,
    TIMER_SOFTIRQ___10 = 1,
    NET_TX_SOFTIRQ___10 = 2,
    NET_RX_SOFTIRQ___10 = 3,
    BLOCK_SOFTIRQ___10 = 4,
    TASKLET_SOFTIRQ___10 = 5,
    SCHED_SOFTIRQ___10 = 6,
    HRTIMER_SOFTIRQ___10 = 7,
    RCU_SOFTIRQ___10 = 8,
    NR_SOFTIRQS___10 = 9
} ;
enum __anonenum_193___8 {
    TASKLET_STATE_SCHED___10 = 0,
    TASKLET_STATE_RUN___10 = 1
} ;
struct tlb_state {
   struct mm_struct *active_mm ;
   int state ;
};
typedef int T_____0;
typedef struct mm_struct *T_____1;
enum mapping_flags {
    AS_EIO = 21,
    AS_ENOSPC = 22,
    AS_MM_ALL_LOCKS = 23,
    AS_UNEVICTABLE = 24
} ;
typedef int filler_t(void * , struct page * );
enum __anonenum_194___9 {
    PROC_ROOT_INO = 1
} ;
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
typedef int write_proc_t(struct file *file , char const   *buffer , unsigned long count ,
                         void *data );
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
struct kcore_list {
   struct kcore_list *next ;
   unsigned long addr ;
   size_t size ;
};
struct vmcore {
   struct list_head list ;
   unsigned long long paddr ;
   unsigned long long size ;
   loff_t offset ;
};
struct tty_driver;
union proc_op {
   int (*proc_get_link)(struct inode * , struct path * ) ;
   int (*proc_read)(struct task_struct *task , char *page ) ;
   int (*proc_show)(struct seq_file *m , struct pid_namespace *ns , struct pid *pid ,
                    struct task_struct *task ) ;
};
struct proc_inode {
   struct pid *pid ;
   int fd ;
   union proc_op op ;
   struct proc_dir_entry *pde ;
   struct ctl_table_header *sysctl ;
   struct ctl_table *sysctl_entry ;
   struct inode vfs_inode ;
};
struct proc_maps_private {
   struct pid *pid ;
   struct task_struct *task ;
   struct vm_area_struct *tail_vma ;
};
struct open_intent {
   int flags ;
   int create_mode ;
   struct file *file ;
};
enum __anonenum_196 {
    MAX_NESTED_LINKS = 8
} ;
union __anonunion_intent_197 {
   struct open_intent open ;
};
struct nameidata {
   struct path path ;
   struct qstr last ;
   unsigned int flags ;
   int last_type ;
   unsigned int depth ;
   char *saved_names[9] ;
   union __anonunion_intent_197 intent ;
};
enum __anonenum_198___0 {
    LAST_NORM = 0,
    LAST_ROOT = 1,
    LAST_DOT = 2,
    LAST_DOTDOT = 3,
    LAST_BIND = 4
} ;
struct match_token {
   int token ;
   char const   *pattern ;
};
typedef struct match_token match_table_t[];
enum __anonenum_199___0 {
    MAX_OPT_ARGS = 3
} ;
struct __anonstruct_substring_t_200 {
   char *from ;
   char *to ;
};
typedef struct __anonstruct_substring_t_200 substring_t;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file *m , loff_t *pos ) ;
   void (*stop)(struct seq_file *m , void *v ) ;
   void *(*next)(struct seq_file *m , void *v , loff_t *pos ) ;
   int (*show)(struct seq_file *m , void *v ) ;
};
enum __anonenum_201 {
    Opt_devuid = 0,
    Opt_devgid = 1,
    Opt_devmode = 2,
    Opt_busuid = 3,
    Opt_busgid = 4,
    Opt_busmode = 5,
    Opt_listuid = 6,
    Opt_listgid = 7,
    Opt_listmode = 8,
    Opt_err = 9
} ;
enum __anonenum_4___11 {
    false___11 = 0,
    true___11 = 1
} ;
enum __anonenum_11 {
    DUMP_PREFIX_NONE___11 = 0,
    DUMP_PREFIX_ADDRESS___11 = 1,
    DUMP_PREFIX_OFFSET___11 = 2
} ;
enum __anonenum_16 {
    PG_LEVEL_NONE___11 = 0,
    PG_LEVEL_4K___11 = 1,
    PG_LEVEL_2M___11 = 2,
    PG_LEVEL_1G___11 = 3,
    PG_LEVEL_NUM___11 = 4
} ;
enum __anonenum_20___9 {
    GATE_INTERRUPT___11 = 14,
    GATE_TRAP___11 = 15,
    GATE_CALL___11 = 12,
    GATE_TASK___11 = 5
} ;
enum __anonenum_21___10 {
    DESC_TSS___11 = 9,
    DESC_LDT___11 = 2,
    DESCTYPE_S___11 = 16
} ;
enum __anonenum_22___8 {
    ADDR_NO_RANDOMIZE___11 = 262144,
    FDPIC_FUNCPTRS___11 = 524288,
    MMAP_PAGE_ZERO___11 = 1048576,
    ADDR_COMPAT_LAYOUT___11 = 2097152,
    READ_IMPLIES_EXEC___11 = 4194304,
    ADDR_LIMIT_32BIT___11 = 8388608,
    SHORT_INODE___11 = 16777216,
    WHOLE_SECONDS___11 = 33554432,
    STICKY_TIMEOUTS___11 = 67108864,
    ADDR_LIMIT_3GB___11 = 134217728
} ;
enum __anonenum_23 {
    PER_LINUX___11 = 0,
    PER_LINUX_32BIT___11 = 8388608,
    PER_LINUX_FDPIC___11 = 524288,
    PER_SVR4___11 = 68157441,
    PER_SVR3___11 = 83886082,
    PER_SCOSVR3___11 = 117440515,
    PER_OSR5___11 = 100663299,
    PER_WYSEV386___11 = 83886084,
    PER_ISCR4___11 = 67108869,
    PER_BSD___11 = 6,
    PER_SUNOS___11 = 67108870,
    PER_XENIX___11 = 83886087,
    PER_LINUX32___11 = 8,
    PER_LINUX32_3GB___11 = 134217736,
    PER_IRIX32___11 = 67108873,
    PER_IRIXN32___11 = 67108874,
    PER_IRIX64___11 = 67108875,
    PER_RISCOS___11 = 12,
    PER_SOLARIS___11 = 67108877,
    PER_UW7___11 = 68157454,
    PER_OSF4___11 = 15,
    PER_HPUX___11 = 16,
    PER_MASK___11 = 255
} ;
union __anonunion_d_38___1 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_101___0 {
    PCI_STD_RESOURCES___0 = 0,
    PCI_STD_RESOURCE_END___0 = 5,
    PCI_ROM_RESOURCE___0 = 6,
    PCI_BRIDGE_RESOURCES___0 = 7,
    PCI_BRIDGE_RESOURCE_END___0 = 10,
    PCI_NUM_RESOURCES___0 = 11,
    DEVICE_COUNT_RESOURCE___0 = 12
} ;
enum __anonenum_121___8 {
    CTL_KERN___11 = 1,
    CTL_VM___11 = 2,
    CTL_NET___11 = 3,
    CTL_PROC___11 = 4,
    CTL_FS___11 = 5,
    CTL_DEBUG___11 = 6,
    CTL_DEV___11 = 7,
    CTL_BUS___11 = 8,
    CTL_ABI___11 = 9,
    CTL_CPU___11 = 10,
    CTL_ARLAN___11 = 254,
    CTL_S390DBF___11 = 5677,
    CTL_SUNRPC___11 = 7249,
    CTL_PM___11 = 9899,
    CTL_FRV___11 = 9898
} ;
enum __anonenum_122___8 {
    CTL_BUS_ISA___11 = 1
} ;
enum __anonenum_123___8 {
    INOTIFY_MAX_USER_INSTANCES___11 = 1,
    INOTIFY_MAX_USER_WATCHES___11 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___11 = 3
} ;
enum __anonenum_124___8 {
    KERN_OSTYPE___11 = 1,
    KERN_OSRELEASE___11 = 2,
    KERN_OSREV___11 = 3,
    KERN_VERSION___11 = 4,
    KERN_SECUREMASK___11 = 5,
    KERN_PROF___11 = 6,
    KERN_NODENAME___11 = 7,
    KERN_DOMAINNAME___11 = 8,
    KERN_PANIC___11 = 15,
    KERN_REALROOTDEV___11 = 16,
    KERN_SPARC_REBOOT___11 = 21,
    KERN_CTLALTDEL___11 = 22,
    KERN_PRINTK___11 = 23,
    KERN_NAMETRANS___11 = 24,
    KERN_PPC_HTABRECLAIM___11 = 25,
    KERN_PPC_ZEROPAGED___11 = 26,
    KERN_PPC_POWERSAVE_NAP___11 = 27,
    KERN_MODPROBE___11 = 28,
    KERN_SG_BIG_BUFF___11 = 29,
    KERN_ACCT___11 = 30,
    KERN_PPC_L2CR___11 = 31,
    KERN_RTSIGNR___11 = 32,
    KERN_RTSIGMAX___11 = 33,
    KERN_SHMMAX___11 = 34,
    KERN_MSGMAX___11 = 35,
    KERN_MSGMNB___11 = 36,
    KERN_MSGPOOL___11 = 37,
    KERN_SYSRQ___11 = 38,
    KERN_MAX_THREADS___11 = 39,
    KERN_RANDOM___11 = 40,
    KERN_SHMALL___11 = 41,
    KERN_MSGMNI___11 = 42,
    KERN_SEM___11 = 43,
    KERN_SPARC_STOP_A___11 = 44,
    KERN_SHMMNI___11 = 45,
    KERN_OVERFLOWUID___11 = 46,
    KERN_OVERFLOWGID___11 = 47,
    KERN_SHMPATH___11 = 48,
    KERN_HOTPLUG___11 = 49,
    KERN_IEEE_EMULATION_WARNINGS___11 = 50,
    KERN_S390_USER_DEBUG_LOGGING___11 = 51,
    KERN_CORE_USES_PID___11 = 52,
    KERN_TAINTED___11 = 53,
    KERN_CADPID___11 = 54,
    KERN_PIDMAX___11 = 55,
    KERN_CORE_PATTERN___11 = 56,
    KERN_PANIC_ON_OOPS___11 = 57,
    KERN_HPPA_PWRSW___11 = 58,
    KERN_HPPA_UNALIGNED___11 = 59,
    KERN_PRINTK_RATELIMIT___11 = 60,
    KERN_PRINTK_RATELIMIT_BURST___11 = 61,
    KERN_PTY___11 = 62,
    KERN_NGROUPS_MAX___11 = 63,
    KERN_SPARC_SCONS_PWROFF___11 = 64,
    KERN_HZ_TIMER___11 = 65,
    KERN_UNKNOWN_NMI_PANIC___11 = 66,
    KERN_BOOTLOADER_TYPE___11 = 67,
    KERN_RANDOMIZE___11 = 68,
    KERN_SETUID_DUMPABLE___11 = 69,
    KERN_SPIN_RETRY___11 = 70,
    KERN_ACPI_VIDEO_FLAGS___11 = 71,
    KERN_IA64_UNALIGNED___11 = 72,
    KERN_COMPAT_LOG___11 = 73,
    KERN_MAX_LOCK_DEPTH___11 = 74,
    KERN_NMI_WATCHDOG___11 = 75,
    KERN_PANIC_ON_NMI___11 = 76
} ;
enum __anonenum_125___10 {
    VM_UNUSED1___11 = 1,
    VM_UNUSED2___11 = 2,
    VM_UNUSED3___11 = 3,
    VM_UNUSED4___11 = 4,
    VM_OVERCOMMIT_MEMORY___11 = 5,
    VM_UNUSED5___11 = 6,
    VM_UNUSED7___11 = 7,
    VM_UNUSED8___11 = 8,
    VM_UNUSED9___11 = 9,
    VM_PAGE_CLUSTER___11 = 10,
    VM_DIRTY_BACKGROUND___11 = 11,
    VM_DIRTY_RATIO___11 = 12,
    VM_DIRTY_WB_CS___11 = 13,
    VM_DIRTY_EXPIRE_CS___11 = 14,
    VM_NR_PDFLUSH_THREADS___11 = 15,
    VM_OVERCOMMIT_RATIO___11 = 16,
    VM_PAGEBUF___11 = 17,
    VM_HUGETLB_PAGES___11 = 18,
    VM_SWAPPINESS___11 = 19,
    VM_LOWMEM_RESERVE_RATIO___11 = 20,
    VM_MIN_FREE_KBYTES___11 = 21,
    VM_MAX_MAP_COUNT___11 = 22,
    VM_LAPTOP_MODE___11 = 23,
    VM_BLOCK_DUMP___11 = 24,
    VM_HUGETLB_GROUP___11 = 25,
    VM_VFS_CACHE_PRESSURE___11 = 26,
    VM_LEGACY_VA_LAYOUT___11 = 27,
    VM_SWAP_TOKEN_TIMEOUT___11 = 28,
    VM_DROP_PAGECACHE___11 = 29,
    VM_PERCPU_PAGELIST_FRACTION___11 = 30,
    VM_ZONE_RECLAIM_MODE___11 = 31,
    VM_MIN_UNMAPPED___11 = 32,
    VM_PANIC_ON_OOM___11 = 33,
    VM_VDSO_ENABLED___11 = 34,
    VM_MIN_SLAB___11 = 35
} ;
enum __anonenum_126___10 {
    NET_CORE___11 = 1,
    NET_ETHER___11 = 2,
    NET_802___11 = 3,
    NET_UNIX___11 = 4,
    NET_IPV4___11 = 5,
    NET_IPX___11 = 6,
    NET_ATALK___11 = 7,
    NET_NETROM___11 = 8,
    NET_AX25___11 = 9,
    NET_BRIDGE___11 = 10,
    NET_ROSE___11 = 11,
    NET_IPV6___11 = 12,
    NET_X25___11 = 13,
    NET_TR___11 = 14,
    NET_DECNET___11 = 15,
    NET_ECONET___11 = 16,
    NET_SCTP___11 = 17,
    NET_LLC___11 = 18,
    NET_NETFILTER___11 = 19,
    NET_DCCP___11 = 20,
    NET_IRDA___11 = 412
} ;
enum __anonenum_127___10 {
    RANDOM_POOLSIZE___11 = 1,
    RANDOM_ENTROPY_COUNT___11 = 2,
    RANDOM_READ_THRESH___11 = 3,
    RANDOM_WRITE_THRESH___11 = 4,
    RANDOM_BOOT_ID___11 = 5,
    RANDOM_UUID___11 = 6
} ;
enum __anonenum_128___10 {
    PTY_MAX___11 = 1,
    PTY_NR___11 = 2
} ;
enum __anonenum_129___10 {
    BUS_ISA_MEM_BASE___11 = 1,
    BUS_ISA_PORT_BASE___11 = 2,
    BUS_ISA_PORT_SHIFT___11 = 3
} ;
enum __anonenum_130___10 {
    NET_CORE_WMEM_MAX___11 = 1,
    NET_CORE_RMEM_MAX___11 = 2,
    NET_CORE_WMEM_DEFAULT___11 = 3,
    NET_CORE_RMEM_DEFAULT___11 = 4,
    NET_CORE_MAX_BACKLOG___11 = 6,
    NET_CORE_FASTROUTE___11 = 7,
    NET_CORE_MSG_COST___11 = 8,
    NET_CORE_MSG_BURST___11 = 9,
    NET_CORE_OPTMEM_MAX___11 = 10,
    NET_CORE_HOT_LIST_LENGTH___11 = 11,
    NET_CORE_DIVERT_VERSION___11 = 12,
    NET_CORE_NO_CONG_THRESH___11 = 13,
    NET_CORE_NO_CONG___11 = 14,
    NET_CORE_LO_CONG___11 = 15,
    NET_CORE_MOD_CONG___11 = 16,
    NET_CORE_DEV_WEIGHT___11 = 17,
    NET_CORE_SOMAXCONN___11 = 18,
    NET_CORE_BUDGET___11 = 19,
    NET_CORE_AEVENT_ETIME___11 = 20,
    NET_CORE_AEVENT_RSEQTH___11 = 21,
    NET_CORE_WARNINGS___11 = 22
} ;
enum __anonenum_131___10 {
    NET_UNIX_DESTROY_DELAY___11 = 1,
    NET_UNIX_DELETE_DELAY___11 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___11 = 3
} ;
enum __anonenum_132___11 {
    NET_NF_CONNTRACK_MAX___11 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___11 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___11 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___11 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___11 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___11 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___11 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___11 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___11 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___11 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___11 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___11 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___11 = 13,
    NET_NF_CONNTRACK_BUCKETS___11 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___11 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___11 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___11 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___11 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___11 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___11 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___11 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___11 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___11 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___11 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___11 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___11 = 26,
    NET_NF_CONNTRACK_COUNT___11 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___11 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___11 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___11 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___11 = 31,
    NET_NF_CONNTRACK_CHECKSUM___11 = 32
} ;
enum __anonenum_133___11 {
    NET_IPV4_FORWARD___11 = 8,
    NET_IPV4_DYNADDR___11 = 9,
    NET_IPV4_CONF___11 = 16,
    NET_IPV4_NEIGH___11 = 17,
    NET_IPV4_ROUTE___11 = 18,
    NET_IPV4_FIB_HASH___11 = 19,
    NET_IPV4_NETFILTER___11 = 20,
    NET_IPV4_TCP_TIMESTAMPS___11 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___11 = 34,
    NET_IPV4_TCP_SACK___11 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___11 = 36,
    NET_IPV4_DEFAULT_TTL___11 = 37,
    NET_IPV4_AUTOCONFIG___11 = 38,
    NET_IPV4_NO_PMTU_DISC___11 = 39,
    NET_IPV4_TCP_SYN_RETRIES___11 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___11 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___11 = 42,
    NET_IPV4_IPFRAG_TIME___11 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___11 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___11 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___11 = 46,
    NET_IPV4_TCP_RETRIES1___11 = 47,
    NET_IPV4_TCP_RETRIES2___11 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___11 = 49,
    NET_IPV4_IP_MASQ_DEBUG___11 = 50,
    NET_TCP_SYNCOOKIES___11 = 51,
    NET_TCP_STDURG___11 = 52,
    NET_TCP_RFC1337___11 = 53,
    NET_TCP_SYN_TAILDROP___11 = 54,
    NET_TCP_MAX_SYN_BACKLOG___11 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___11 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___11 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___11 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___11 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___11 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___11 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___11 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___11 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___11 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___11 = 65,
    NET_TCP_TW_RECYCLE___11 = 66,
    NET_IPV4_ALWAYS_DEFRAG___11 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___11 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___11 = 69,
    NET_IPV4_INET_PEER_MINTTL___11 = 70,
    NET_IPV4_INET_PEER_MAXTTL___11 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___11 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___11 = 73,
    NET_TCP_ORPHAN_RETRIES___11 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___11 = 75,
    NET_TCP_SYNACK_RETRIES___11 = 76,
    NET_TCP_MAX_ORPHANS___11 = 77,
    NET_TCP_MAX_TW_BUCKETS___11 = 78,
    NET_TCP_FACK___11 = 79,
    NET_TCP_REORDERING___11 = 80,
    NET_TCP_ECN___11 = 81,
    NET_TCP_DSACK___11 = 82,
    NET_TCP_MEM___11 = 83,
    NET_TCP_WMEM___11 = 84,
    NET_TCP_RMEM___11 = 85,
    NET_TCP_APP_WIN___11 = 86,
    NET_TCP_ADV_WIN_SCALE___11 = 87,
    NET_IPV4_NONLOCAL_BIND___11 = 88,
    NET_IPV4_ICMP_RATELIMIT___11 = 89,
    NET_IPV4_ICMP_RATEMASK___11 = 90,
    NET_TCP_TW_REUSE___11 = 91,
    NET_TCP_FRTO___11 = 92,
    NET_TCP_LOW_LATENCY___11 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___11 = 94,
    NET_IPV4_IGMP_MAX_MSF___11 = 96,
    NET_TCP_NO_METRICS_SAVE___11 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___11 = 105,
    NET_TCP_MODERATE_RCVBUF___11 = 106,
    NET_TCP_TSO_WIN_DIVISOR___11 = 107,
    NET_TCP_BIC_BETA___11 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___11 = 109,
    NET_TCP_CONG_CONTROL___11 = 110,
    NET_TCP_ABC___11 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___11 = 112,
    NET_TCP_MTU_PROBING___11 = 113,
    NET_TCP_BASE_MSS___11 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___11 = 115,
    NET_TCP_DMA_COPYBREAK___11 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___11 = 117,
    NET_CIPSOV4_CACHE_ENABLE___11 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___11 = 119,
    NET_CIPSOV4_RBM_OPTFMT___11 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___11 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___11 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___11 = 123,
    NET_TCP_MAX_SSTHRESH___11 = 124,
    NET_TCP_FRTO_RESPONSE___11 = 125
} ;
enum __anonenum_134___11 {
    NET_IPV4_ROUTE_FLUSH___11 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___11 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___11 = 3,
    NET_IPV4_ROUTE_GC_THRESH___11 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___11 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___11 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___11 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___11 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___11 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___11 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___11 = 11,
    NET_IPV4_ROUTE_ERROR_COST___11 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___11 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___11 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___11 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___11 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___11 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___11 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___11 = 19
} ;
enum __anonenum_135___11 {
    NET_PROTO_CONF_ALL___11 = -2,
    NET_PROTO_CONF_DEFAULT___11 = -3
} ;
enum __anonenum_136___11 {
    NET_IPV4_CONF_FORWARDING___11 = 1,
    NET_IPV4_CONF_MC_FORWARDING___11 = 2,
    NET_IPV4_CONF_PROXY_ARP___11 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___11 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___11 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___11 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___11 = 7,
    NET_IPV4_CONF_RP_FILTER___11 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___11 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___11 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___11 = 11,
    NET_IPV4_CONF_TAG___11 = 12,
    NET_IPV4_CONF_ARPFILTER___11 = 13,
    NET_IPV4_CONF_MEDIUM_ID___11 = 14,
    NET_IPV4_CONF_NOXFRM___11 = 15,
    NET_IPV4_CONF_NOPOLICY___11 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___11 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___11 = 18,
    NET_IPV4_CONF_ARP_IGNORE___11 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___11 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___11 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___11 = 22,
    __NET_IPV4_CONF_MAX___11 = 23
} ;
enum __anonenum_137___11 {
    NET_IPV4_NF_CONNTRACK_MAX___11 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___11 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___11 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___11 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___11 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___11 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___11 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___11 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___11 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___11 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___11 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___11 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___11 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___11 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___11 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___11 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___11 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___11 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___11 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___11 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___11 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___11 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___11 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___11 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___11 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___11 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___11 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___11 = 28
} ;
enum __anonenum_138___11 {
    NET_IPV6_CONF___11 = 16,
    NET_IPV6_NEIGH___11 = 17,
    NET_IPV6_ROUTE___11 = 18,
    NET_IPV6_ICMP___11 = 19,
    NET_IPV6_BINDV6ONLY___11 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___11 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___11 = 22,
    NET_IPV6_IP6FRAG_TIME___11 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___11 = 24,
    NET_IPV6_MLD_MAX_MSF___11 = 25
} ;
enum __anonenum_139___11 {
    NET_IPV6_ROUTE_FLUSH___11 = 1,
    NET_IPV6_ROUTE_GC_THRESH___11 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___11 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___11 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___11 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___11 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___11 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___11 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___11 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___11 = 10
} ;
enum __anonenum_140___11 {
    NET_IPV6_FORWARDING___11 = 1,
    NET_IPV6_HOP_LIMIT___11 = 2,
    NET_IPV6_MTU___11 = 3,
    NET_IPV6_ACCEPT_RA___11 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___11 = 5,
    NET_IPV6_AUTOCONF___11 = 6,
    NET_IPV6_DAD_TRANSMITS___11 = 7,
    NET_IPV6_RTR_SOLICITS___11 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___11 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___11 = 10,
    NET_IPV6_USE_TEMPADDR___11 = 11,
    NET_IPV6_TEMP_VALID_LFT___11 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___11 = 13,
    NET_IPV6_REGEN_MAX_RETRY___11 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___11 = 15,
    NET_IPV6_MAX_ADDRESSES___11 = 16,
    NET_IPV6_FORCE_MLD_VERSION___11 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___11 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___11 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___11 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___11 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___11 = 22,
    NET_IPV6_PROXY_NDP___11 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___11 = 25,
    __NET_IPV6_MAX___11 = 26
} ;
enum __anonenum_141___11 {
    NET_IPV6_ICMP_RATELIMIT___11 = 1
} ;
enum __anonenum_142___11 {
    NET_NEIGH_MCAST_SOLICIT___11 = 1,
    NET_NEIGH_UCAST_SOLICIT___11 = 2,
    NET_NEIGH_APP_SOLICIT___11 = 3,
    NET_NEIGH_RETRANS_TIME___11 = 4,
    NET_NEIGH_REACHABLE_TIME___11 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___11 = 6,
    NET_NEIGH_GC_STALE_TIME___11 = 7,
    NET_NEIGH_UNRES_QLEN___11 = 8,
    NET_NEIGH_PROXY_QLEN___11 = 9,
    NET_NEIGH_ANYCAST_DELAY___11 = 10,
    NET_NEIGH_PROXY_DELAY___11 = 11,
    NET_NEIGH_LOCKTIME___11 = 12,
    NET_NEIGH_GC_INTERVAL___11 = 13,
    NET_NEIGH_GC_THRESH1___11 = 14,
    NET_NEIGH_GC_THRESH2___11 = 15,
    NET_NEIGH_GC_THRESH3___11 = 16,
    NET_NEIGH_RETRANS_TIME_MS___11 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___11 = 18,
    __NET_NEIGH_MAX___11 = 19
} ;
enum __anonenum_143___11 {
    NET_DCCP_DEFAULT___11 = 1
} ;
enum __anonenum_144___11 {
    NET_IPX_PPROP_BROADCASTING___11 = 1,
    NET_IPX_FORWARDING___11 = 2
} ;
enum __anonenum_145___11 {
    NET_LLC2___11 = 1,
    NET_LLC_STATION___11 = 2
} ;
enum __anonenum_146___11 {
    NET_LLC2_TIMEOUT___11 = 1
} ;
enum __anonenum_147___11 {
    NET_LLC_STATION_ACK_TIMEOUT___11 = 1
} ;
enum __anonenum_148___11 {
    NET_LLC2_ACK_TIMEOUT___11 = 1,
    NET_LLC2_P_TIMEOUT___11 = 2,
    NET_LLC2_REJ_TIMEOUT___11 = 3,
    NET_LLC2_BUSY_TIMEOUT___11 = 4
} ;
enum __anonenum_149___11 {
    NET_ATALK_AARP_EXPIRY_TIME___11 = 1,
    NET_ATALK_AARP_TICK_TIME___11 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___11 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___11 = 4
} ;
enum __anonenum_150___11 {
    NET_NETROM_DEFAULT_PATH_QUALITY___11 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___11 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___11 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___11 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___11 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___11 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___11 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___11 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___11 = 9,
    NET_NETROM_ROUTING_CONTROL___11 = 10,
    NET_NETROM_LINK_FAILS_COUNT___11 = 11,
    NET_NETROM_RESET___11 = 12
} ;
enum __anonenum_151___11 {
    NET_AX25_IP_DEFAULT_MODE___11 = 1,
    NET_AX25_DEFAULT_MODE___11 = 2,
    NET_AX25_BACKOFF_TYPE___11 = 3,
    NET_AX25_CONNECT_MODE___11 = 4,
    NET_AX25_STANDARD_WINDOW___11 = 5,
    NET_AX25_EXTENDED_WINDOW___11 = 6,
    NET_AX25_T1_TIMEOUT___11 = 7,
    NET_AX25_T2_TIMEOUT___11 = 8,
    NET_AX25_T3_TIMEOUT___11 = 9,
    NET_AX25_IDLE_TIMEOUT___11 = 10,
    NET_AX25_N2___11 = 11,
    NET_AX25_PACLEN___11 = 12,
    NET_AX25_PROTOCOL___11 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___11 = 14
} ;
enum __anonenum_152___11 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___11 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___11 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___11 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___11 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___11 = 5,
    NET_ROSE_ROUTING_CONTROL___11 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___11 = 7,
    NET_ROSE_MAX_VCS___11 = 8,
    NET_ROSE_WINDOW_SIZE___11 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___11 = 10
} ;
enum __anonenum_153___11 {
    NET_X25_RESTART_REQUEST_TIMEOUT___11 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___11 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___11 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___11 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___11 = 5,
    NET_X25_FORWARD___11 = 6
} ;
enum __anonenum_154___11 {
    NET_TR_RIF_TIMEOUT___11 = 1
} ;
enum __anonenum_155___11 {
    NET_DECNET_NODE_TYPE___11 = 1,
    NET_DECNET_NODE_ADDRESS___11 = 2,
    NET_DECNET_NODE_NAME___11 = 3,
    NET_DECNET_DEFAULT_DEVICE___11 = 4,
    NET_DECNET_TIME_WAIT___11 = 5,
    NET_DECNET_DN_COUNT___11 = 6,
    NET_DECNET_DI_COUNT___11 = 7,
    NET_DECNET_DR_COUNT___11 = 8,
    NET_DECNET_DST_GC_INTERVAL___11 = 9,
    NET_DECNET_CONF___11 = 10,
    NET_DECNET_NO_FC_MAX_CWND___11 = 11,
    NET_DECNET_MEM___11 = 12,
    NET_DECNET_RMEM___11 = 13,
    NET_DECNET_WMEM___11 = 14,
    NET_DECNET_DEBUG_LEVEL___11 = 255
} ;
enum __anonenum_156___11 {
    NET_DECNET_CONF_LOOPBACK___11 = -2,
    NET_DECNET_CONF_DDCMP___11 = -3,
    NET_DECNET_CONF_PPP___11 = -4,
    NET_DECNET_CONF_X25___11 = -5,
    NET_DECNET_CONF_GRE___11 = -6,
    NET_DECNET_CONF_ETHER___11 = -7
} ;
enum __anonenum_157___11 {
    NET_DECNET_CONF_DEV_PRIORITY___11 = 1,
    NET_DECNET_CONF_DEV_T1___11 = 2,
    NET_DECNET_CONF_DEV_T2___11 = 3,
    NET_DECNET_CONF_DEV_T3___11 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___11 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___11 = 6,
    NET_DECNET_CONF_DEV_STATE___11 = 7
} ;
enum __anonenum_158___11 {
    NET_SCTP_RTO_INITIAL___11 = 1,
    NET_SCTP_RTO_MIN___11 = 2,
    NET_SCTP_RTO_MAX___11 = 3,
    NET_SCTP_RTO_ALPHA___11 = 4,
    NET_SCTP_RTO_BETA___11 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___11 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___11 = 7,
    NET_SCTP_PATH_MAX_RETRANS___11 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___11 = 9,
    NET_SCTP_HB_INTERVAL___11 = 10,
    NET_SCTP_PRESERVE_ENABLE___11 = 11,
    NET_SCTP_MAX_BURST___11 = 12,
    NET_SCTP_ADDIP_ENABLE___11 = 13,
    NET_SCTP_PRSCTP_ENABLE___11 = 14,
    NET_SCTP_SNDBUF_POLICY___11 = 15,
    NET_SCTP_SACK_TIMEOUT___11 = 16,
    NET_SCTP_RCVBUF_POLICY___11 = 17
} ;
enum __anonenum_159___11 {
    NET_BRIDGE_NF_CALL_ARPTABLES___11 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___11 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___11 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___11 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___11 = 5
} ;
enum __anonenum_160___11 {
    NET_IRDA_DISCOVERY___11 = 1,
    NET_IRDA_DEVNAME___11 = 2,
    NET_IRDA_DEBUG___11 = 3,
    NET_IRDA_FAST_POLL___11 = 4,
    NET_IRDA_DISCOVERY_SLOTS___11 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___11 = 6,
    NET_IRDA_SLOT_TIMEOUT___11 = 7,
    NET_IRDA_MAX_BAUD_RATE___11 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___11 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___11 = 10,
    NET_IRDA_MAX_TX_WINDOW___11 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___11 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___11 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___11 = 14
} ;
enum __anonenum_161___11 {
    FS_NRINODE___11 = 1,
    FS_STATINODE___11 = 2,
    FS_MAXINODE___11 = 3,
    FS_NRDQUOT___11 = 4,
    FS_MAXDQUOT___11 = 5,
    FS_NRFILE___11 = 6,
    FS_MAXFILE___11 = 7,
    FS_DENTRY___11 = 8,
    FS_NRSUPER___11 = 9,
    FS_MAXSUPER___11 = 10,
    FS_OVERFLOWUID___11 = 11,
    FS_OVERFLOWGID___11 = 12,
    FS_LEASES___11 = 13,
    FS_DIR_NOTIFY___11 = 14,
    FS_LEASE_TIME___11 = 15,
    FS_DQSTATS___11 = 16,
    FS_XFS___11 = 17,
    FS_AIO_NR___11 = 18,
    FS_AIO_MAX_NR___11 = 19,
    FS_INOTIFY___11 = 20,
    FS_OCFS2___11 = 988
} ;
enum __anonenum_162___11 {
    FS_DQ_LOOKUPS___11 = 1,
    FS_DQ_DROPS___11 = 2,
    FS_DQ_READS___11 = 3,
    FS_DQ_WRITES___11 = 4,
    FS_DQ_CACHE_HITS___11 = 5,
    FS_DQ_ALLOCATED___11 = 6,
    FS_DQ_FREE___11 = 7,
    FS_DQ_SYNCS___11 = 8,
    FS_DQ_WARNINGS___11 = 9
} ;
enum __anonenum_163___11 {
    DEV_CDROM___11 = 1,
    DEV_HWMON___11 = 2,
    DEV_PARPORT___11 = 3,
    DEV_RAID___11 = 4,
    DEV_MAC_HID___11 = 5,
    DEV_SCSI___11 = 6,
    DEV_IPMI___11 = 7
} ;
enum __anonenum_164___11 {
    DEV_CDROM_INFO___11 = 1,
    DEV_CDROM_AUTOCLOSE___11 = 2,
    DEV_CDROM_AUTOEJECT___11 = 3,
    DEV_CDROM_DEBUG___11 = 4,
    DEV_CDROM_LOCK___11 = 5,
    DEV_CDROM_CHECK_MEDIA___11 = 6
} ;
enum __anonenum_165___11 {
    DEV_PARPORT_DEFAULT___11 = -3
} ;
enum __anonenum_166___11 {
    DEV_RAID_SPEED_LIMIT_MIN___11 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___11 = 2
} ;
enum __anonenum_167___8 {
    DEV_PARPORT_DEFAULT_TIMESLICE___11 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___11 = 2
} ;
enum __anonenum_168___8 {
    DEV_PARPORT_SPINTIME___11 = 1,
    DEV_PARPORT_BASE_ADDR___11 = 2,
    DEV_PARPORT_IRQ___11 = 3,
    DEV_PARPORT_DMA___11 = 4,
    DEV_PARPORT_MODES___11 = 5,
    DEV_PARPORT_DEVICES___11 = 6,
    DEV_PARPORT_AUTOPROBE___11 = 16
} ;
enum __anonenum_169___11 {
    DEV_PARPORT_DEVICES_ACTIVE___11 = -3
} ;
enum __anonenum_170___8 {
    DEV_PARPORT_DEVICE_TIMESLICE___11 = 1
} ;
enum __anonenum_171___8 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___11 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___11 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___11 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___11 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___11 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___11 = 6
} ;
enum __anonenum_172___11 {
    DEV_SCSI_LOGGING_LEVEL___11 = 1
} ;
enum __anonenum_173___8 {
    DEV_IPMI_POWEROFF_POWERCYCLE___11 = 1
} ;
enum __anonenum_174___6 {
    ABI_DEFHANDLER_COFF___11 = 1,
    ABI_DEFHANDLER_ELF___11 = 2,
    ABI_DEFHANDLER_LCALL7___11 = 3,
    ABI_DEFHANDLER_LIBCSO___11 = 4,
    ABI_TRACE___11 = 5,
    ABI_FAKE_UTSNAME___11 = 6
} ;
enum __anonenum_177___3 {
    IOCB_CMD_PREAD___11 = 0,
    IOCB_CMD_PWRITE___11 = 1,
    IOCB_CMD_FSYNC___11 = 2,
    IOCB_CMD_FDSYNC___11 = 3,
    IOCB_CMD_NOOP___11 = 6,
    IOCB_CMD_PREADV___11 = 7,
    IOCB_CMD_PWRITEV___11 = 8
} ;
enum __anonenum_180___6 {
    IRQTF_RUNTHREAD___11 = 0,
    IRQTF_DIED___11 = 1,
    IRQTF_WARNED___11 = 2
} ;
enum __anonenum_181___8 {
    HI_SOFTIRQ___11 = 0,
    TIMER_SOFTIRQ___11 = 1,
    NET_TX_SOFTIRQ___11 = 2,
    NET_RX_SOFTIRQ___11 = 3,
    BLOCK_SOFTIRQ___11 = 4,
    TASKLET_SOFTIRQ___11 = 5,
    SCHED_SOFTIRQ___11 = 6,
    HRTIMER_SOFTIRQ___11 = 7,
    RCU_SOFTIRQ___11 = 8,
    NR_SOFTIRQS___11 = 9
} ;
enum __anonenum_182___1 {
    TASKLET_STATE_SCHED___11 = 0,
    TASKLET_STATE_RUN___11 = 1
} ;
enum __anonenum_184___9 {
    QIF_BLIMITS_B___11 = 0,
    QIF_SPACE_B___11 = 1,
    QIF_ILIMITS_B___11 = 2,
    QIF_INODES_B___11 = 3,
    QIF_BTIME_B___11 = 4,
    QIF_ITIME_B___11 = 5
} ;
enum __anonenum_185___9 {
    QUOTA_NL_C_UNSPEC___11 = 0,
    QUOTA_NL_C_WARNING___11 = 1,
    __QUOTA_NL_C_MAX___11 = 2
} ;
enum __anonenum_186___9 {
    QUOTA_NL_A_UNSPEC___11 = 0,
    QUOTA_NL_A_QTYPE___11 = 1,
    QUOTA_NL_A_EXCESS_ID___11 = 2,
    QUOTA_NL_A_WARNING___11 = 3,
    QUOTA_NL_A_DEV_MAJOR___11 = 4,
    QUOTA_NL_A_DEV_MINOR___11 = 5,
    QUOTA_NL_A_CAUSED_ID___11 = 6,
    __QUOTA_NL_A_MAX___11 = 7
} ;
enum __anonenum_187___1 {
    _DQUOT_USAGE_ENABLED___11 = 0,
    _DQUOT_LIMITS_ENABLED___11 = 1,
    _DQUOT_SUSPENDED___11 = 2,
    _DQUOT_STATE_FLAGS___11 = 3
} ;
enum __anonenum_194___10 {
    SB_UNFROZEN___11 = 0,
    SB_FREEZE_WRITE___11 = 1,
    SB_FREEZE_TRANS___11 = 2
} ;
enum __anonenum_195___1 {
    DIO_LOCKING___11 = 1,
    DIO_NO_LOCKING___11 = 2,
    DIO_OWN_LOCKING___11 = 3
} ;
struct api_context {
   struct completion done ;
   int status ;
};
struct set_config_request {
   struct usb_device *udev ;
   int config ;
   struct work_struct work ;
   struct list_head node ;
};
enum __anonenum_4___12 {
    false___12 = 0,
    true___12 = 1
} ;
enum __anonenum_8___2 {
    DUMP_PREFIX_NONE___12 = 0,
    DUMP_PREFIX_ADDRESS___12 = 1,
    DUMP_PREFIX_OFFSET___12 = 2
} ;
enum __anonenum_15___8 {
    PG_LEVEL_NONE___12 = 0,
    PG_LEVEL_4K___12 = 1,
    PG_LEVEL_2M___12 = 2,
    PG_LEVEL_1G___12 = 3,
    PG_LEVEL_NUM___12 = 4
} ;
enum __anonenum_19___8 {
    GATE_INTERRUPT___12 = 14,
    GATE_TRAP___12 = 15,
    GATE_CALL___12 = 12,
    GATE_TASK___12 = 5
} ;
enum __anonenum_20___10 {
    DESC_TSS___12 = 9,
    DESC_LDT___12 = 2,
    DESCTYPE_S___12 = 16
} ;
enum __anonenum_21___11 {
    ADDR_NO_RANDOMIZE___12 = 262144,
    FDPIC_FUNCPTRS___12 = 524288,
    MMAP_PAGE_ZERO___12 = 1048576,
    ADDR_COMPAT_LAYOUT___12 = 2097152,
    READ_IMPLIES_EXEC___12 = 4194304,
    ADDR_LIMIT_32BIT___12 = 8388608,
    SHORT_INODE___12 = 16777216,
    WHOLE_SECONDS___12 = 33554432,
    STICKY_TIMEOUTS___12 = 67108864,
    ADDR_LIMIT_3GB___12 = 134217728
} ;
enum __anonenum_22___9 {
    PER_LINUX___12 = 0,
    PER_LINUX_32BIT___12 = 8388608,
    PER_LINUX_FDPIC___12 = 524288,
    PER_SVR4___12 = 68157441,
    PER_SVR3___12 = 83886082,
    PER_SCOSVR3___12 = 117440515,
    PER_OSR5___12 = 100663299,
    PER_WYSEV386___12 = 83886084,
    PER_ISCR4___12 = 67108869,
    PER_BSD___12 = 6,
    PER_SUNOS___12 = 67108870,
    PER_XENIX___12 = 83886087,
    PER_LINUX32___12 = 8,
    PER_LINUX32_3GB___12 = 134217736,
    PER_IRIX32___12 = 67108873,
    PER_IRIXN32___12 = 67108874,
    PER_IRIX64___12 = 67108875,
    PER_RISCOS___12 = 12,
    PER_SOLARIS___12 = 67108877,
    PER_UW7___12 = 68157454,
    PER_OSF4___12 = 15,
    PER_HPUX___12 = 16,
    PER_MASK___12 = 255
} ;
union __anonunion_d_39___2 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_113___3 {
    CTL_KERN___12 = 1,
    CTL_VM___12 = 2,
    CTL_NET___12 = 3,
    CTL_PROC___12 = 4,
    CTL_FS___12 = 5,
    CTL_DEBUG___12 = 6,
    CTL_DEV___12 = 7,
    CTL_BUS___12 = 8,
    CTL_ABI___12 = 9,
    CTL_CPU___12 = 10,
    CTL_ARLAN___12 = 254,
    CTL_S390DBF___12 = 5677,
    CTL_SUNRPC___12 = 7249,
    CTL_PM___12 = 9899,
    CTL_FRV___12 = 9898
} ;
enum __anonenum_114___2 {
    CTL_BUS_ISA___12 = 1
} ;
enum __anonenum_115___2 {
    INOTIFY_MAX_USER_INSTANCES___12 = 1,
    INOTIFY_MAX_USER_WATCHES___12 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___12 = 3
} ;
enum __anonenum_116___2 {
    KERN_OSTYPE___12 = 1,
    KERN_OSRELEASE___12 = 2,
    KERN_OSREV___12 = 3,
    KERN_VERSION___12 = 4,
    KERN_SECUREMASK___12 = 5,
    KERN_PROF___12 = 6,
    KERN_NODENAME___12 = 7,
    KERN_DOMAINNAME___12 = 8,
    KERN_PANIC___12 = 15,
    KERN_REALROOTDEV___12 = 16,
    KERN_SPARC_REBOOT___12 = 21,
    KERN_CTLALTDEL___12 = 22,
    KERN_PRINTK___12 = 23,
    KERN_NAMETRANS___12 = 24,
    KERN_PPC_HTABRECLAIM___12 = 25,
    KERN_PPC_ZEROPAGED___12 = 26,
    KERN_PPC_POWERSAVE_NAP___12 = 27,
    KERN_MODPROBE___12 = 28,
    KERN_SG_BIG_BUFF___12 = 29,
    KERN_ACCT___12 = 30,
    KERN_PPC_L2CR___12 = 31,
    KERN_RTSIGNR___12 = 32,
    KERN_RTSIGMAX___12 = 33,
    KERN_SHMMAX___12 = 34,
    KERN_MSGMAX___12 = 35,
    KERN_MSGMNB___12 = 36,
    KERN_MSGPOOL___12 = 37,
    KERN_SYSRQ___12 = 38,
    KERN_MAX_THREADS___12 = 39,
    KERN_RANDOM___12 = 40,
    KERN_SHMALL___12 = 41,
    KERN_MSGMNI___12 = 42,
    KERN_SEM___12 = 43,
    KERN_SPARC_STOP_A___12 = 44,
    KERN_SHMMNI___12 = 45,
    KERN_OVERFLOWUID___12 = 46,
    KERN_OVERFLOWGID___12 = 47,
    KERN_SHMPATH___12 = 48,
    KERN_HOTPLUG___12 = 49,
    KERN_IEEE_EMULATION_WARNINGS___12 = 50,
    KERN_S390_USER_DEBUG_LOGGING___12 = 51,
    KERN_CORE_USES_PID___12 = 52,
    KERN_TAINTED___12 = 53,
    KERN_CADPID___12 = 54,
    KERN_PIDMAX___12 = 55,
    KERN_CORE_PATTERN___12 = 56,
    KERN_PANIC_ON_OOPS___12 = 57,
    KERN_HPPA_PWRSW___12 = 58,
    KERN_HPPA_UNALIGNED___12 = 59,
    KERN_PRINTK_RATELIMIT___12 = 60,
    KERN_PRINTK_RATELIMIT_BURST___12 = 61,
    KERN_PTY___12 = 62,
    KERN_NGROUPS_MAX___12 = 63,
    KERN_SPARC_SCONS_PWROFF___12 = 64,
    KERN_HZ_TIMER___12 = 65,
    KERN_UNKNOWN_NMI_PANIC___12 = 66,
    KERN_BOOTLOADER_TYPE___12 = 67,
    KERN_RANDOMIZE___12 = 68,
    KERN_SETUID_DUMPABLE___12 = 69,
    KERN_SPIN_RETRY___12 = 70,
    KERN_ACPI_VIDEO_FLAGS___12 = 71,
    KERN_IA64_UNALIGNED___12 = 72,
    KERN_COMPAT_LOG___12 = 73,
    KERN_MAX_LOCK_DEPTH___12 = 74,
    KERN_NMI_WATCHDOG___12 = 75,
    KERN_PANIC_ON_NMI___12 = 76
} ;
enum __anonenum_117___2 {
    VM_UNUSED1___12 = 1,
    VM_UNUSED2___12 = 2,
    VM_UNUSED3___12 = 3,
    VM_UNUSED4___12 = 4,
    VM_OVERCOMMIT_MEMORY___12 = 5,
    VM_UNUSED5___12 = 6,
    VM_UNUSED7___12 = 7,
    VM_UNUSED8___12 = 8,
    VM_UNUSED9___12 = 9,
    VM_PAGE_CLUSTER___12 = 10,
    VM_DIRTY_BACKGROUND___12 = 11,
    VM_DIRTY_RATIO___12 = 12,
    VM_DIRTY_WB_CS___12 = 13,
    VM_DIRTY_EXPIRE_CS___12 = 14,
    VM_NR_PDFLUSH_THREADS___12 = 15,
    VM_OVERCOMMIT_RATIO___12 = 16,
    VM_PAGEBUF___12 = 17,
    VM_HUGETLB_PAGES___12 = 18,
    VM_SWAPPINESS___12 = 19,
    VM_LOWMEM_RESERVE_RATIO___12 = 20,
    VM_MIN_FREE_KBYTES___12 = 21,
    VM_MAX_MAP_COUNT___12 = 22,
    VM_LAPTOP_MODE___12 = 23,
    VM_BLOCK_DUMP___12 = 24,
    VM_HUGETLB_GROUP___12 = 25,
    VM_VFS_CACHE_PRESSURE___12 = 26,
    VM_LEGACY_VA_LAYOUT___12 = 27,
    VM_SWAP_TOKEN_TIMEOUT___12 = 28,
    VM_DROP_PAGECACHE___12 = 29,
    VM_PERCPU_PAGELIST_FRACTION___12 = 30,
    VM_ZONE_RECLAIM_MODE___12 = 31,
    VM_MIN_UNMAPPED___12 = 32,
    VM_PANIC_ON_OOM___12 = 33,
    VM_VDSO_ENABLED___12 = 34,
    VM_MIN_SLAB___12 = 35
} ;
enum __anonenum_118___2 {
    NET_CORE___12 = 1,
    NET_ETHER___12 = 2,
    NET_802___12 = 3,
    NET_UNIX___12 = 4,
    NET_IPV4___12 = 5,
    NET_IPX___12 = 6,
    NET_ATALK___12 = 7,
    NET_NETROM___12 = 8,
    NET_AX25___12 = 9,
    NET_BRIDGE___12 = 10,
    NET_ROSE___12 = 11,
    NET_IPV6___12 = 12,
    NET_X25___12 = 13,
    NET_TR___12 = 14,
    NET_DECNET___12 = 15,
    NET_ECONET___12 = 16,
    NET_SCTP___12 = 17,
    NET_LLC___12 = 18,
    NET_NETFILTER___12 = 19,
    NET_DCCP___12 = 20,
    NET_IRDA___12 = 412
} ;
enum __anonenum_119___5 {
    RANDOM_POOLSIZE___12 = 1,
    RANDOM_ENTROPY_COUNT___12 = 2,
    RANDOM_READ_THRESH___12 = 3,
    RANDOM_WRITE_THRESH___12 = 4,
    RANDOM_BOOT_ID___12 = 5,
    RANDOM_UUID___12 = 6
} ;
enum __anonenum_120___7 {
    PTY_MAX___12 = 1,
    PTY_NR___12 = 2
} ;
enum __anonenum_121___9 {
    BUS_ISA_MEM_BASE___12 = 1,
    BUS_ISA_PORT_BASE___12 = 2,
    BUS_ISA_PORT_SHIFT___12 = 3
} ;
enum __anonenum_122___9 {
    NET_CORE_WMEM_MAX___12 = 1,
    NET_CORE_RMEM_MAX___12 = 2,
    NET_CORE_WMEM_DEFAULT___12 = 3,
    NET_CORE_RMEM_DEFAULT___12 = 4,
    NET_CORE_MAX_BACKLOG___12 = 6,
    NET_CORE_FASTROUTE___12 = 7,
    NET_CORE_MSG_COST___12 = 8,
    NET_CORE_MSG_BURST___12 = 9,
    NET_CORE_OPTMEM_MAX___12 = 10,
    NET_CORE_HOT_LIST_LENGTH___12 = 11,
    NET_CORE_DIVERT_VERSION___12 = 12,
    NET_CORE_NO_CONG_THRESH___12 = 13,
    NET_CORE_NO_CONG___12 = 14,
    NET_CORE_LO_CONG___12 = 15,
    NET_CORE_MOD_CONG___12 = 16,
    NET_CORE_DEV_WEIGHT___12 = 17,
    NET_CORE_SOMAXCONN___12 = 18,
    NET_CORE_BUDGET___12 = 19,
    NET_CORE_AEVENT_ETIME___12 = 20,
    NET_CORE_AEVENT_RSEQTH___12 = 21,
    NET_CORE_WARNINGS___12 = 22
} ;
enum __anonenum_123___9 {
    NET_UNIX_DESTROY_DELAY___12 = 1,
    NET_UNIX_DELETE_DELAY___12 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___12 = 3
} ;
enum __anonenum_124___9 {
    NET_NF_CONNTRACK_MAX___12 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___12 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___12 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___12 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___12 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___12 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___12 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___12 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___12 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___12 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___12 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___12 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___12 = 13,
    NET_NF_CONNTRACK_BUCKETS___12 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___12 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___12 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___12 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___12 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___12 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___12 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___12 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___12 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___12 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___12 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___12 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___12 = 26,
    NET_NF_CONNTRACK_COUNT___12 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___12 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___12 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___12 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___12 = 31,
    NET_NF_CONNTRACK_CHECKSUM___12 = 32
} ;
enum __anonenum_125___11 {
    NET_IPV4_FORWARD___12 = 8,
    NET_IPV4_DYNADDR___12 = 9,
    NET_IPV4_CONF___12 = 16,
    NET_IPV4_NEIGH___12 = 17,
    NET_IPV4_ROUTE___12 = 18,
    NET_IPV4_FIB_HASH___12 = 19,
    NET_IPV4_NETFILTER___12 = 20,
    NET_IPV4_TCP_TIMESTAMPS___12 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___12 = 34,
    NET_IPV4_TCP_SACK___12 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___12 = 36,
    NET_IPV4_DEFAULT_TTL___12 = 37,
    NET_IPV4_AUTOCONFIG___12 = 38,
    NET_IPV4_NO_PMTU_DISC___12 = 39,
    NET_IPV4_TCP_SYN_RETRIES___12 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___12 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___12 = 42,
    NET_IPV4_IPFRAG_TIME___12 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___12 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___12 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___12 = 46,
    NET_IPV4_TCP_RETRIES1___12 = 47,
    NET_IPV4_TCP_RETRIES2___12 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___12 = 49,
    NET_IPV4_IP_MASQ_DEBUG___12 = 50,
    NET_TCP_SYNCOOKIES___12 = 51,
    NET_TCP_STDURG___12 = 52,
    NET_TCP_RFC1337___12 = 53,
    NET_TCP_SYN_TAILDROP___12 = 54,
    NET_TCP_MAX_SYN_BACKLOG___12 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___12 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___12 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___12 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___12 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___12 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___12 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___12 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___12 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___12 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___12 = 65,
    NET_TCP_TW_RECYCLE___12 = 66,
    NET_IPV4_ALWAYS_DEFRAG___12 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___12 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___12 = 69,
    NET_IPV4_INET_PEER_MINTTL___12 = 70,
    NET_IPV4_INET_PEER_MAXTTL___12 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___12 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___12 = 73,
    NET_TCP_ORPHAN_RETRIES___12 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___12 = 75,
    NET_TCP_SYNACK_RETRIES___12 = 76,
    NET_TCP_MAX_ORPHANS___12 = 77,
    NET_TCP_MAX_TW_BUCKETS___12 = 78,
    NET_TCP_FACK___12 = 79,
    NET_TCP_REORDERING___12 = 80,
    NET_TCP_ECN___12 = 81,
    NET_TCP_DSACK___12 = 82,
    NET_TCP_MEM___12 = 83,
    NET_TCP_WMEM___12 = 84,
    NET_TCP_RMEM___12 = 85,
    NET_TCP_APP_WIN___12 = 86,
    NET_TCP_ADV_WIN_SCALE___12 = 87,
    NET_IPV4_NONLOCAL_BIND___12 = 88,
    NET_IPV4_ICMP_RATELIMIT___12 = 89,
    NET_IPV4_ICMP_RATEMASK___12 = 90,
    NET_TCP_TW_REUSE___12 = 91,
    NET_TCP_FRTO___12 = 92,
    NET_TCP_LOW_LATENCY___12 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___12 = 94,
    NET_IPV4_IGMP_MAX_MSF___12 = 96,
    NET_TCP_NO_METRICS_SAVE___12 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___12 = 105,
    NET_TCP_MODERATE_RCVBUF___12 = 106,
    NET_TCP_TSO_WIN_DIVISOR___12 = 107,
    NET_TCP_BIC_BETA___12 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___12 = 109,
    NET_TCP_CONG_CONTROL___12 = 110,
    NET_TCP_ABC___12 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___12 = 112,
    NET_TCP_MTU_PROBING___12 = 113,
    NET_TCP_BASE_MSS___12 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___12 = 115,
    NET_TCP_DMA_COPYBREAK___12 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___12 = 117,
    NET_CIPSOV4_CACHE_ENABLE___12 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___12 = 119,
    NET_CIPSOV4_RBM_OPTFMT___12 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___12 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___12 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___12 = 123,
    NET_TCP_MAX_SSTHRESH___12 = 124,
    NET_TCP_FRTO_RESPONSE___12 = 125
} ;
enum __anonenum_126___11 {
    NET_IPV4_ROUTE_FLUSH___12 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___12 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___12 = 3,
    NET_IPV4_ROUTE_GC_THRESH___12 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___12 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___12 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___12 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___12 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___12 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___12 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___12 = 11,
    NET_IPV4_ROUTE_ERROR_COST___12 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___12 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___12 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___12 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___12 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___12 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___12 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___12 = 19
} ;
enum __anonenum_127___11 {
    NET_PROTO_CONF_ALL___12 = -2,
    NET_PROTO_CONF_DEFAULT___12 = -3
} ;
enum __anonenum_128___11 {
    NET_IPV4_CONF_FORWARDING___12 = 1,
    NET_IPV4_CONF_MC_FORWARDING___12 = 2,
    NET_IPV4_CONF_PROXY_ARP___12 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___12 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___12 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___12 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___12 = 7,
    NET_IPV4_CONF_RP_FILTER___12 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___12 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___12 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___12 = 11,
    NET_IPV4_CONF_TAG___12 = 12,
    NET_IPV4_CONF_ARPFILTER___12 = 13,
    NET_IPV4_CONF_MEDIUM_ID___12 = 14,
    NET_IPV4_CONF_NOXFRM___12 = 15,
    NET_IPV4_CONF_NOPOLICY___12 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___12 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___12 = 18,
    NET_IPV4_CONF_ARP_IGNORE___12 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___12 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___12 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___12 = 22,
    __NET_IPV4_CONF_MAX___12 = 23
} ;
enum __anonenum_129___11 {
    NET_IPV4_NF_CONNTRACK_MAX___12 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___12 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___12 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___12 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___12 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___12 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___12 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___12 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___12 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___12 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___12 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___12 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___12 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___12 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___12 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___12 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___12 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___12 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___12 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___12 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___12 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___12 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___12 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___12 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___12 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___12 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___12 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___12 = 28
} ;
enum __anonenum_130___11 {
    NET_IPV6_CONF___12 = 16,
    NET_IPV6_NEIGH___12 = 17,
    NET_IPV6_ROUTE___12 = 18,
    NET_IPV6_ICMP___12 = 19,
    NET_IPV6_BINDV6ONLY___12 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___12 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___12 = 22,
    NET_IPV6_IP6FRAG_TIME___12 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___12 = 24,
    NET_IPV6_MLD_MAX_MSF___12 = 25
} ;
enum __anonenum_131___11 {
    NET_IPV6_ROUTE_FLUSH___12 = 1,
    NET_IPV6_ROUTE_GC_THRESH___12 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___12 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___12 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___12 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___12 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___12 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___12 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___12 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___12 = 10
} ;
enum __anonenum_132___12 {
    NET_IPV6_FORWARDING___12 = 1,
    NET_IPV6_HOP_LIMIT___12 = 2,
    NET_IPV6_MTU___12 = 3,
    NET_IPV6_ACCEPT_RA___12 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___12 = 5,
    NET_IPV6_AUTOCONF___12 = 6,
    NET_IPV6_DAD_TRANSMITS___12 = 7,
    NET_IPV6_RTR_SOLICITS___12 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___12 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___12 = 10,
    NET_IPV6_USE_TEMPADDR___12 = 11,
    NET_IPV6_TEMP_VALID_LFT___12 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___12 = 13,
    NET_IPV6_REGEN_MAX_RETRY___12 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___12 = 15,
    NET_IPV6_MAX_ADDRESSES___12 = 16,
    NET_IPV6_FORCE_MLD_VERSION___12 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___12 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___12 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___12 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___12 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___12 = 22,
    NET_IPV6_PROXY_NDP___12 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___12 = 25,
    __NET_IPV6_MAX___12 = 26
} ;
enum __anonenum_133___12 {
    NET_IPV6_ICMP_RATELIMIT___12 = 1
} ;
enum __anonenum_134___12 {
    NET_NEIGH_MCAST_SOLICIT___12 = 1,
    NET_NEIGH_UCAST_SOLICIT___12 = 2,
    NET_NEIGH_APP_SOLICIT___12 = 3,
    NET_NEIGH_RETRANS_TIME___12 = 4,
    NET_NEIGH_REACHABLE_TIME___12 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___12 = 6,
    NET_NEIGH_GC_STALE_TIME___12 = 7,
    NET_NEIGH_UNRES_QLEN___12 = 8,
    NET_NEIGH_PROXY_QLEN___12 = 9,
    NET_NEIGH_ANYCAST_DELAY___12 = 10,
    NET_NEIGH_PROXY_DELAY___12 = 11,
    NET_NEIGH_LOCKTIME___12 = 12,
    NET_NEIGH_GC_INTERVAL___12 = 13,
    NET_NEIGH_GC_THRESH1___12 = 14,
    NET_NEIGH_GC_THRESH2___12 = 15,
    NET_NEIGH_GC_THRESH3___12 = 16,
    NET_NEIGH_RETRANS_TIME_MS___12 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___12 = 18,
    __NET_NEIGH_MAX___12 = 19
} ;
enum __anonenum_135___12 {
    NET_DCCP_DEFAULT___12 = 1
} ;
enum __anonenum_136___12 {
    NET_IPX_PPROP_BROADCASTING___12 = 1,
    NET_IPX_FORWARDING___12 = 2
} ;
enum __anonenum_137___12 {
    NET_LLC2___12 = 1,
    NET_LLC_STATION___12 = 2
} ;
enum __anonenum_138___12 {
    NET_LLC2_TIMEOUT___12 = 1
} ;
enum __anonenum_139___12 {
    NET_LLC_STATION_ACK_TIMEOUT___12 = 1
} ;
enum __anonenum_140___12 {
    NET_LLC2_ACK_TIMEOUT___12 = 1,
    NET_LLC2_P_TIMEOUT___12 = 2,
    NET_LLC2_REJ_TIMEOUT___12 = 3,
    NET_LLC2_BUSY_TIMEOUT___12 = 4
} ;
enum __anonenum_141___12 {
    NET_ATALK_AARP_EXPIRY_TIME___12 = 1,
    NET_ATALK_AARP_TICK_TIME___12 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___12 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___12 = 4
} ;
enum __anonenum_142___12 {
    NET_NETROM_DEFAULT_PATH_QUALITY___12 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___12 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___12 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___12 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___12 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___12 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___12 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___12 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___12 = 9,
    NET_NETROM_ROUTING_CONTROL___12 = 10,
    NET_NETROM_LINK_FAILS_COUNT___12 = 11,
    NET_NETROM_RESET___12 = 12
} ;
enum __anonenum_143___12 {
    NET_AX25_IP_DEFAULT_MODE___12 = 1,
    NET_AX25_DEFAULT_MODE___12 = 2,
    NET_AX25_BACKOFF_TYPE___12 = 3,
    NET_AX25_CONNECT_MODE___12 = 4,
    NET_AX25_STANDARD_WINDOW___12 = 5,
    NET_AX25_EXTENDED_WINDOW___12 = 6,
    NET_AX25_T1_TIMEOUT___12 = 7,
    NET_AX25_T2_TIMEOUT___12 = 8,
    NET_AX25_T3_TIMEOUT___12 = 9,
    NET_AX25_IDLE_TIMEOUT___12 = 10,
    NET_AX25_N2___12 = 11,
    NET_AX25_PACLEN___12 = 12,
    NET_AX25_PROTOCOL___12 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___12 = 14
} ;
enum __anonenum_144___12 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___12 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___12 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___12 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___12 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___12 = 5,
    NET_ROSE_ROUTING_CONTROL___12 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___12 = 7,
    NET_ROSE_MAX_VCS___12 = 8,
    NET_ROSE_WINDOW_SIZE___12 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___12 = 10
} ;
enum __anonenum_145___12 {
    NET_X25_RESTART_REQUEST_TIMEOUT___12 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___12 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___12 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___12 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___12 = 5,
    NET_X25_FORWARD___12 = 6
} ;
enum __anonenum_146___12 {
    NET_TR_RIF_TIMEOUT___12 = 1
} ;
enum __anonenum_147___12 {
    NET_DECNET_NODE_TYPE___12 = 1,
    NET_DECNET_NODE_ADDRESS___12 = 2,
    NET_DECNET_NODE_NAME___12 = 3,
    NET_DECNET_DEFAULT_DEVICE___12 = 4,
    NET_DECNET_TIME_WAIT___12 = 5,
    NET_DECNET_DN_COUNT___12 = 6,
    NET_DECNET_DI_COUNT___12 = 7,
    NET_DECNET_DR_COUNT___12 = 8,
    NET_DECNET_DST_GC_INTERVAL___12 = 9,
    NET_DECNET_CONF___12 = 10,
    NET_DECNET_NO_FC_MAX_CWND___12 = 11,
    NET_DECNET_MEM___12 = 12,
    NET_DECNET_RMEM___12 = 13,
    NET_DECNET_WMEM___12 = 14,
    NET_DECNET_DEBUG_LEVEL___12 = 255
} ;
enum __anonenum_148___12 {
    NET_DECNET_CONF_LOOPBACK___12 = -2,
    NET_DECNET_CONF_DDCMP___12 = -3,
    NET_DECNET_CONF_PPP___12 = -4,
    NET_DECNET_CONF_X25___12 = -5,
    NET_DECNET_CONF_GRE___12 = -6,
    NET_DECNET_CONF_ETHER___12 = -7
} ;
enum __anonenum_149___12 {
    NET_DECNET_CONF_DEV_PRIORITY___12 = 1,
    NET_DECNET_CONF_DEV_T1___12 = 2,
    NET_DECNET_CONF_DEV_T2___12 = 3,
    NET_DECNET_CONF_DEV_T3___12 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___12 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___12 = 6,
    NET_DECNET_CONF_DEV_STATE___12 = 7
} ;
enum __anonenum_150___12 {
    NET_SCTP_RTO_INITIAL___12 = 1,
    NET_SCTP_RTO_MIN___12 = 2,
    NET_SCTP_RTO_MAX___12 = 3,
    NET_SCTP_RTO_ALPHA___12 = 4,
    NET_SCTP_RTO_BETA___12 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___12 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___12 = 7,
    NET_SCTP_PATH_MAX_RETRANS___12 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___12 = 9,
    NET_SCTP_HB_INTERVAL___12 = 10,
    NET_SCTP_PRESERVE_ENABLE___12 = 11,
    NET_SCTP_MAX_BURST___12 = 12,
    NET_SCTP_ADDIP_ENABLE___12 = 13,
    NET_SCTP_PRSCTP_ENABLE___12 = 14,
    NET_SCTP_SNDBUF_POLICY___12 = 15,
    NET_SCTP_SACK_TIMEOUT___12 = 16,
    NET_SCTP_RCVBUF_POLICY___12 = 17
} ;
enum __anonenum_151___12 {
    NET_BRIDGE_NF_CALL_ARPTABLES___12 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___12 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___12 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___12 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___12 = 5
} ;
enum __anonenum_152___12 {
    NET_IRDA_DISCOVERY___12 = 1,
    NET_IRDA_DEVNAME___12 = 2,
    NET_IRDA_DEBUG___12 = 3,
    NET_IRDA_FAST_POLL___12 = 4,
    NET_IRDA_DISCOVERY_SLOTS___12 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___12 = 6,
    NET_IRDA_SLOT_TIMEOUT___12 = 7,
    NET_IRDA_MAX_BAUD_RATE___12 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___12 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___12 = 10,
    NET_IRDA_MAX_TX_WINDOW___12 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___12 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___12 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___12 = 14
} ;
enum __anonenum_153___12 {
    FS_NRINODE___12 = 1,
    FS_STATINODE___12 = 2,
    FS_MAXINODE___12 = 3,
    FS_NRDQUOT___12 = 4,
    FS_MAXDQUOT___12 = 5,
    FS_NRFILE___12 = 6,
    FS_MAXFILE___12 = 7,
    FS_DENTRY___12 = 8,
    FS_NRSUPER___12 = 9,
    FS_MAXSUPER___12 = 10,
    FS_OVERFLOWUID___12 = 11,
    FS_OVERFLOWGID___12 = 12,
    FS_LEASES___12 = 13,
    FS_DIR_NOTIFY___12 = 14,
    FS_LEASE_TIME___12 = 15,
    FS_DQSTATS___12 = 16,
    FS_XFS___12 = 17,
    FS_AIO_NR___12 = 18,
    FS_AIO_MAX_NR___12 = 19,
    FS_INOTIFY___12 = 20,
    FS_OCFS2___12 = 988
} ;
enum __anonenum_154___12 {
    FS_DQ_LOOKUPS___12 = 1,
    FS_DQ_DROPS___12 = 2,
    FS_DQ_READS___12 = 3,
    FS_DQ_WRITES___12 = 4,
    FS_DQ_CACHE_HITS___12 = 5,
    FS_DQ_ALLOCATED___12 = 6,
    FS_DQ_FREE___12 = 7,
    FS_DQ_SYNCS___12 = 8,
    FS_DQ_WARNINGS___12 = 9
} ;
enum __anonenum_155___12 {
    DEV_CDROM___12 = 1,
    DEV_HWMON___12 = 2,
    DEV_PARPORT___12 = 3,
    DEV_RAID___12 = 4,
    DEV_MAC_HID___12 = 5,
    DEV_SCSI___12 = 6,
    DEV_IPMI___12 = 7
} ;
enum __anonenum_156___12 {
    DEV_CDROM_INFO___12 = 1,
    DEV_CDROM_AUTOCLOSE___12 = 2,
    DEV_CDROM_AUTOEJECT___12 = 3,
    DEV_CDROM_DEBUG___12 = 4,
    DEV_CDROM_LOCK___12 = 5,
    DEV_CDROM_CHECK_MEDIA___12 = 6
} ;
enum __anonenum_157___12 {
    DEV_PARPORT_DEFAULT___12 = -3
} ;
enum __anonenum_158___12 {
    DEV_RAID_SPEED_LIMIT_MIN___12 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___12 = 2
} ;
enum __anonenum_159___12 {
    DEV_PARPORT_DEFAULT_TIMESLICE___12 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___12 = 2
} ;
enum __anonenum_160___12 {
    DEV_PARPORT_SPINTIME___12 = 1,
    DEV_PARPORT_BASE_ADDR___12 = 2,
    DEV_PARPORT_IRQ___12 = 3,
    DEV_PARPORT_DMA___12 = 4,
    DEV_PARPORT_MODES___12 = 5,
    DEV_PARPORT_DEVICES___12 = 6,
    DEV_PARPORT_AUTOPROBE___12 = 16
} ;
enum __anonenum_161___12 {
    DEV_PARPORT_DEVICES_ACTIVE___12 = -3
} ;
enum __anonenum_162___12 {
    DEV_PARPORT_DEVICE_TIMESLICE___12 = 1
} ;
enum __anonenum_163___12 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___12 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___12 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___12 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___12 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___12 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___12 = 6
} ;
enum __anonenum_164___12 {
    DEV_SCSI_LOGGING_LEVEL___12 = 1
} ;
enum __anonenum_165___12 {
    DEV_IPMI_POWEROFF_POWERCYCLE___12 = 1
} ;
enum __anonenum_166___12 {
    ABI_DEFHANDLER_COFF___12 = 1,
    ABI_DEFHANDLER_ELF___12 = 2,
    ABI_DEFHANDLER_LCALL7___12 = 3,
    ABI_DEFHANDLER_LIBCSO___12 = 4,
    ABI_TRACE___12 = 5,
    ABI_FAKE_UTSNAME___12 = 6
} ;
enum __anonenum_169___12 {
    IOCB_CMD_PREAD___12 = 0,
    IOCB_CMD_PWRITE___12 = 1,
    IOCB_CMD_FSYNC___12 = 2,
    IOCB_CMD_FDSYNC___12 = 3,
    IOCB_CMD_NOOP___12 = 6,
    IOCB_CMD_PREADV___12 = 7,
    IOCB_CMD_PWRITEV___12 = 8
} ;
enum __anonenum_172___12 {
    IRQTF_RUNTHREAD___12 = 0,
    IRQTF_DIED___12 = 1,
    IRQTF_WARNED___12 = 2
} ;
enum __anonenum_173___9 {
    HI_SOFTIRQ___12 = 0,
    TIMER_SOFTIRQ___12 = 1,
    NET_TX_SOFTIRQ___12 = 2,
    NET_RX_SOFTIRQ___12 = 3,
    BLOCK_SOFTIRQ___12 = 4,
    TASKLET_SOFTIRQ___12 = 5,
    SCHED_SOFTIRQ___12 = 6,
    HRTIMER_SOFTIRQ___12 = 7,
    RCU_SOFTIRQ___12 = 8,
    NR_SOFTIRQS___12 = 9
} ;
enum __anonenum_174___7 {
    TASKLET_STATE_SCHED___12 = 0,
    TASKLET_STATE_RUN___12 = 1
} ;
enum __anonenum_183___8 {
    QIF_BLIMITS_B___12 = 0,
    QIF_SPACE_B___12 = 1,
    QIF_ILIMITS_B___12 = 2,
    QIF_INODES_B___12 = 3,
    QIF_BTIME_B___12 = 4,
    QIF_ITIME_B___12 = 5
} ;
enum __anonenum_184___10 {
    QUOTA_NL_C_UNSPEC___12 = 0,
    QUOTA_NL_C_WARNING___12 = 1,
    __QUOTA_NL_C_MAX___12 = 2
} ;
enum __anonenum_185___10 {
    QUOTA_NL_A_UNSPEC___12 = 0,
    QUOTA_NL_A_QTYPE___12 = 1,
    QUOTA_NL_A_EXCESS_ID___12 = 2,
    QUOTA_NL_A_WARNING___12 = 3,
    QUOTA_NL_A_DEV_MAJOR___12 = 4,
    QUOTA_NL_A_DEV_MINOR___12 = 5,
    QUOTA_NL_A_CAUSED_ID___12 = 6,
    __QUOTA_NL_A_MAX___12 = 7
} ;
enum __anonenum_186___10 {
    _DQUOT_USAGE_ENABLED___12 = 0,
    _DQUOT_LIMITS_ENABLED___12 = 1,
    _DQUOT_SUSPENDED___12 = 2,
    _DQUOT_STATE_FLAGS___12 = 3
} ;
enum __anonenum_193___9 {
    SB_UNFROZEN___12 = 0,
    SB_FREEZE_WRITE___12 = 1,
    SB_FREEZE_TRANS___12 = 2
} ;
enum __anonenum_194___11 {
    DIO_LOCKING___12 = 1,
    DIO_NO_LOCKING___12 = 2,
    DIO_OWN_LOCKING___12 = 3
} ;
enum __anonenum_4___13 {
    false___13 = 0,
    true___13 = 1
} ;
enum __anonenum_9___1 {
    DUMP_PREFIX_NONE___13 = 0,
    DUMP_PREFIX_ADDRESS___13 = 1,
    DUMP_PREFIX_OFFSET___13 = 2
} ;
enum __anonenum_21___12 {
    PG_LEVEL_NONE___13 = 0,
    PG_LEVEL_4K___13 = 1,
    PG_LEVEL_2M___13 = 2,
    PG_LEVEL_1G___13 = 3,
    PG_LEVEL_NUM___13 = 4
} ;
enum __anonenum_25___2 {
    GATE_INTERRUPT___13 = 14,
    GATE_TRAP___13 = 15,
    GATE_CALL___13 = 12,
    GATE_TASK___13 = 5
} ;
enum __anonenum_26___2 {
    DESC_TSS___13 = 9,
    DESC_LDT___13 = 2,
    DESCTYPE_S___13 = 16
} ;
enum __anonenum_27___2 {
    ADDR_NO_RANDOMIZE___13 = 262144,
    FDPIC_FUNCPTRS___13 = 524288,
    MMAP_PAGE_ZERO___13 = 1048576,
    ADDR_COMPAT_LAYOUT___13 = 2097152,
    READ_IMPLIES_EXEC___13 = 4194304,
    ADDR_LIMIT_32BIT___13 = 8388608,
    SHORT_INODE___13 = 16777216,
    WHOLE_SECONDS___13 = 33554432,
    STICKY_TIMEOUTS___13 = 67108864,
    ADDR_LIMIT_3GB___13 = 134217728
} ;
enum __anonenum_28___1 {
    PER_LINUX___13 = 0,
    PER_LINUX_32BIT___13 = 8388608,
    PER_LINUX_FDPIC___13 = 524288,
    PER_SVR4___13 = 68157441,
    PER_SVR3___13 = 83886082,
    PER_SCOSVR3___13 = 117440515,
    PER_OSR5___13 = 100663299,
    PER_WYSEV386___13 = 83886084,
    PER_ISCR4___13 = 67108869,
    PER_BSD___13 = 6,
    PER_SUNOS___13 = 67108870,
    PER_XENIX___13 = 83886087,
    PER_LINUX32___13 = 8,
    PER_LINUX32_3GB___13 = 134217736,
    PER_IRIX32___13 = 67108873,
    PER_IRIXN32___13 = 67108874,
    PER_IRIX64___13 = 67108875,
    PER_RISCOS___13 = 12,
    PER_SOLARIS___13 = 67108877,
    PER_UW7___13 = 68157454,
    PER_OSF4___13 = 15,
    PER_HPUX___13 = 16,
    PER_MASK___13 = 255
} ;
union __anonunion_d_39___3 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_113___4 {
    CTL_KERN___13 = 1,
    CTL_VM___13 = 2,
    CTL_NET___13 = 3,
    CTL_PROC___13 = 4,
    CTL_FS___13 = 5,
    CTL_DEBUG___13 = 6,
    CTL_DEV___13 = 7,
    CTL_BUS___13 = 8,
    CTL_ABI___13 = 9,
    CTL_CPU___13 = 10,
    CTL_ARLAN___13 = 254,
    CTL_S390DBF___13 = 5677,
    CTL_SUNRPC___13 = 7249,
    CTL_PM___13 = 9899,
    CTL_FRV___13 = 9898
} ;
enum __anonenum_114___3 {
    CTL_BUS_ISA___13 = 1
} ;
enum __anonenum_115___3 {
    INOTIFY_MAX_USER_INSTANCES___13 = 1,
    INOTIFY_MAX_USER_WATCHES___13 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___13 = 3
} ;
enum __anonenum_116___3 {
    KERN_OSTYPE___13 = 1,
    KERN_OSRELEASE___13 = 2,
    KERN_OSREV___13 = 3,
    KERN_VERSION___13 = 4,
    KERN_SECUREMASK___13 = 5,
    KERN_PROF___13 = 6,
    KERN_NODENAME___13 = 7,
    KERN_DOMAINNAME___13 = 8,
    KERN_PANIC___13 = 15,
    KERN_REALROOTDEV___13 = 16,
    KERN_SPARC_REBOOT___13 = 21,
    KERN_CTLALTDEL___13 = 22,
    KERN_PRINTK___13 = 23,
    KERN_NAMETRANS___13 = 24,
    KERN_PPC_HTABRECLAIM___13 = 25,
    KERN_PPC_ZEROPAGED___13 = 26,
    KERN_PPC_POWERSAVE_NAP___13 = 27,
    KERN_MODPROBE___13 = 28,
    KERN_SG_BIG_BUFF___13 = 29,
    KERN_ACCT___13 = 30,
    KERN_PPC_L2CR___13 = 31,
    KERN_RTSIGNR___13 = 32,
    KERN_RTSIGMAX___13 = 33,
    KERN_SHMMAX___13 = 34,
    KERN_MSGMAX___13 = 35,
    KERN_MSGMNB___13 = 36,
    KERN_MSGPOOL___13 = 37,
    KERN_SYSRQ___13 = 38,
    KERN_MAX_THREADS___13 = 39,
    KERN_RANDOM___13 = 40,
    KERN_SHMALL___13 = 41,
    KERN_MSGMNI___13 = 42,
    KERN_SEM___13 = 43,
    KERN_SPARC_STOP_A___13 = 44,
    KERN_SHMMNI___13 = 45,
    KERN_OVERFLOWUID___13 = 46,
    KERN_OVERFLOWGID___13 = 47,
    KERN_SHMPATH___13 = 48,
    KERN_HOTPLUG___13 = 49,
    KERN_IEEE_EMULATION_WARNINGS___13 = 50,
    KERN_S390_USER_DEBUG_LOGGING___13 = 51,
    KERN_CORE_USES_PID___13 = 52,
    KERN_TAINTED___13 = 53,
    KERN_CADPID___13 = 54,
    KERN_PIDMAX___13 = 55,
    KERN_CORE_PATTERN___13 = 56,
    KERN_PANIC_ON_OOPS___13 = 57,
    KERN_HPPA_PWRSW___13 = 58,
    KERN_HPPA_UNALIGNED___13 = 59,
    KERN_PRINTK_RATELIMIT___13 = 60,
    KERN_PRINTK_RATELIMIT_BURST___13 = 61,
    KERN_PTY___13 = 62,
    KERN_NGROUPS_MAX___13 = 63,
    KERN_SPARC_SCONS_PWROFF___13 = 64,
    KERN_HZ_TIMER___13 = 65,
    KERN_UNKNOWN_NMI_PANIC___13 = 66,
    KERN_BOOTLOADER_TYPE___13 = 67,
    KERN_RANDOMIZE___13 = 68,
    KERN_SETUID_DUMPABLE___13 = 69,
    KERN_SPIN_RETRY___13 = 70,
    KERN_ACPI_VIDEO_FLAGS___13 = 71,
    KERN_IA64_UNALIGNED___13 = 72,
    KERN_COMPAT_LOG___13 = 73,
    KERN_MAX_LOCK_DEPTH___13 = 74,
    KERN_NMI_WATCHDOG___13 = 75,
    KERN_PANIC_ON_NMI___13 = 76
} ;
enum __anonenum_117___3 {
    VM_UNUSED1___13 = 1,
    VM_UNUSED2___13 = 2,
    VM_UNUSED3___13 = 3,
    VM_UNUSED4___13 = 4,
    VM_OVERCOMMIT_MEMORY___13 = 5,
    VM_UNUSED5___13 = 6,
    VM_UNUSED7___13 = 7,
    VM_UNUSED8___13 = 8,
    VM_UNUSED9___13 = 9,
    VM_PAGE_CLUSTER___13 = 10,
    VM_DIRTY_BACKGROUND___13 = 11,
    VM_DIRTY_RATIO___13 = 12,
    VM_DIRTY_WB_CS___13 = 13,
    VM_DIRTY_EXPIRE_CS___13 = 14,
    VM_NR_PDFLUSH_THREADS___13 = 15,
    VM_OVERCOMMIT_RATIO___13 = 16,
    VM_PAGEBUF___13 = 17,
    VM_HUGETLB_PAGES___13 = 18,
    VM_SWAPPINESS___13 = 19,
    VM_LOWMEM_RESERVE_RATIO___13 = 20,
    VM_MIN_FREE_KBYTES___13 = 21,
    VM_MAX_MAP_COUNT___13 = 22,
    VM_LAPTOP_MODE___13 = 23,
    VM_BLOCK_DUMP___13 = 24,
    VM_HUGETLB_GROUP___13 = 25,
    VM_VFS_CACHE_PRESSURE___13 = 26,
    VM_LEGACY_VA_LAYOUT___13 = 27,
    VM_SWAP_TOKEN_TIMEOUT___13 = 28,
    VM_DROP_PAGECACHE___13 = 29,
    VM_PERCPU_PAGELIST_FRACTION___13 = 30,
    VM_ZONE_RECLAIM_MODE___13 = 31,
    VM_MIN_UNMAPPED___13 = 32,
    VM_PANIC_ON_OOM___13 = 33,
    VM_VDSO_ENABLED___13 = 34,
    VM_MIN_SLAB___13 = 35
} ;
enum __anonenum_118___3 {
    NET_CORE___13 = 1,
    NET_ETHER___13 = 2,
    NET_802___13 = 3,
    NET_UNIX___13 = 4,
    NET_IPV4___13 = 5,
    NET_IPX___13 = 6,
    NET_ATALK___13 = 7,
    NET_NETROM___13 = 8,
    NET_AX25___13 = 9,
    NET_BRIDGE___13 = 10,
    NET_ROSE___13 = 11,
    NET_IPV6___13 = 12,
    NET_X25___13 = 13,
    NET_TR___13 = 14,
    NET_DECNET___13 = 15,
    NET_ECONET___13 = 16,
    NET_SCTP___13 = 17,
    NET_LLC___13 = 18,
    NET_NETFILTER___13 = 19,
    NET_DCCP___13 = 20,
    NET_IRDA___13 = 412
} ;
enum __anonenum_119___6 {
    RANDOM_POOLSIZE___13 = 1,
    RANDOM_ENTROPY_COUNT___13 = 2,
    RANDOM_READ_THRESH___13 = 3,
    RANDOM_WRITE_THRESH___13 = 4,
    RANDOM_BOOT_ID___13 = 5,
    RANDOM_UUID___13 = 6
} ;
enum __anonenum_120___8 {
    PTY_MAX___13 = 1,
    PTY_NR___13 = 2
} ;
enum __anonenum_121___10 {
    BUS_ISA_MEM_BASE___13 = 1,
    BUS_ISA_PORT_BASE___13 = 2,
    BUS_ISA_PORT_SHIFT___13 = 3
} ;
enum __anonenum_122___10 {
    NET_CORE_WMEM_MAX___13 = 1,
    NET_CORE_RMEM_MAX___13 = 2,
    NET_CORE_WMEM_DEFAULT___13 = 3,
    NET_CORE_RMEM_DEFAULT___13 = 4,
    NET_CORE_MAX_BACKLOG___13 = 6,
    NET_CORE_FASTROUTE___13 = 7,
    NET_CORE_MSG_COST___13 = 8,
    NET_CORE_MSG_BURST___13 = 9,
    NET_CORE_OPTMEM_MAX___13 = 10,
    NET_CORE_HOT_LIST_LENGTH___13 = 11,
    NET_CORE_DIVERT_VERSION___13 = 12,
    NET_CORE_NO_CONG_THRESH___13 = 13,
    NET_CORE_NO_CONG___13 = 14,
    NET_CORE_LO_CONG___13 = 15,
    NET_CORE_MOD_CONG___13 = 16,
    NET_CORE_DEV_WEIGHT___13 = 17,
    NET_CORE_SOMAXCONN___13 = 18,
    NET_CORE_BUDGET___13 = 19,
    NET_CORE_AEVENT_ETIME___13 = 20,
    NET_CORE_AEVENT_RSEQTH___13 = 21,
    NET_CORE_WARNINGS___13 = 22
} ;
enum __anonenum_123___10 {
    NET_UNIX_DESTROY_DELAY___13 = 1,
    NET_UNIX_DELETE_DELAY___13 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___13 = 3
} ;
enum __anonenum_124___10 {
    NET_NF_CONNTRACK_MAX___13 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___13 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___13 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___13 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___13 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___13 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___13 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___13 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___13 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___13 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___13 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___13 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___13 = 13,
    NET_NF_CONNTRACK_BUCKETS___13 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___13 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___13 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___13 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___13 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___13 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___13 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___13 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___13 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___13 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___13 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___13 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___13 = 26,
    NET_NF_CONNTRACK_COUNT___13 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___13 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___13 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___13 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___13 = 31,
    NET_NF_CONNTRACK_CHECKSUM___13 = 32
} ;
enum __anonenum_125___12 {
    NET_IPV4_FORWARD___13 = 8,
    NET_IPV4_DYNADDR___13 = 9,
    NET_IPV4_CONF___13 = 16,
    NET_IPV4_NEIGH___13 = 17,
    NET_IPV4_ROUTE___13 = 18,
    NET_IPV4_FIB_HASH___13 = 19,
    NET_IPV4_NETFILTER___13 = 20,
    NET_IPV4_TCP_TIMESTAMPS___13 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___13 = 34,
    NET_IPV4_TCP_SACK___13 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___13 = 36,
    NET_IPV4_DEFAULT_TTL___13 = 37,
    NET_IPV4_AUTOCONFIG___13 = 38,
    NET_IPV4_NO_PMTU_DISC___13 = 39,
    NET_IPV4_TCP_SYN_RETRIES___13 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___13 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___13 = 42,
    NET_IPV4_IPFRAG_TIME___13 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___13 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___13 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___13 = 46,
    NET_IPV4_TCP_RETRIES1___13 = 47,
    NET_IPV4_TCP_RETRIES2___13 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___13 = 49,
    NET_IPV4_IP_MASQ_DEBUG___13 = 50,
    NET_TCP_SYNCOOKIES___13 = 51,
    NET_TCP_STDURG___13 = 52,
    NET_TCP_RFC1337___13 = 53,
    NET_TCP_SYN_TAILDROP___13 = 54,
    NET_TCP_MAX_SYN_BACKLOG___13 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___13 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___13 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___13 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___13 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___13 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___13 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___13 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___13 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___13 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___13 = 65,
    NET_TCP_TW_RECYCLE___13 = 66,
    NET_IPV4_ALWAYS_DEFRAG___13 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___13 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___13 = 69,
    NET_IPV4_INET_PEER_MINTTL___13 = 70,
    NET_IPV4_INET_PEER_MAXTTL___13 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___13 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___13 = 73,
    NET_TCP_ORPHAN_RETRIES___13 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___13 = 75,
    NET_TCP_SYNACK_RETRIES___13 = 76,
    NET_TCP_MAX_ORPHANS___13 = 77,
    NET_TCP_MAX_TW_BUCKETS___13 = 78,
    NET_TCP_FACK___13 = 79,
    NET_TCP_REORDERING___13 = 80,
    NET_TCP_ECN___13 = 81,
    NET_TCP_DSACK___13 = 82,
    NET_TCP_MEM___13 = 83,
    NET_TCP_WMEM___13 = 84,
    NET_TCP_RMEM___13 = 85,
    NET_TCP_APP_WIN___13 = 86,
    NET_TCP_ADV_WIN_SCALE___13 = 87,
    NET_IPV4_NONLOCAL_BIND___13 = 88,
    NET_IPV4_ICMP_RATELIMIT___13 = 89,
    NET_IPV4_ICMP_RATEMASK___13 = 90,
    NET_TCP_TW_REUSE___13 = 91,
    NET_TCP_FRTO___13 = 92,
    NET_TCP_LOW_LATENCY___13 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___13 = 94,
    NET_IPV4_IGMP_MAX_MSF___13 = 96,
    NET_TCP_NO_METRICS_SAVE___13 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___13 = 105,
    NET_TCP_MODERATE_RCVBUF___13 = 106,
    NET_TCP_TSO_WIN_DIVISOR___13 = 107,
    NET_TCP_BIC_BETA___13 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___13 = 109,
    NET_TCP_CONG_CONTROL___13 = 110,
    NET_TCP_ABC___13 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___13 = 112,
    NET_TCP_MTU_PROBING___13 = 113,
    NET_TCP_BASE_MSS___13 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___13 = 115,
    NET_TCP_DMA_COPYBREAK___13 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___13 = 117,
    NET_CIPSOV4_CACHE_ENABLE___13 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___13 = 119,
    NET_CIPSOV4_RBM_OPTFMT___13 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___13 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___13 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___13 = 123,
    NET_TCP_MAX_SSTHRESH___13 = 124,
    NET_TCP_FRTO_RESPONSE___13 = 125
} ;
enum __anonenum_126___12 {
    NET_IPV4_ROUTE_FLUSH___13 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___13 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___13 = 3,
    NET_IPV4_ROUTE_GC_THRESH___13 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___13 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___13 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___13 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___13 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___13 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___13 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___13 = 11,
    NET_IPV4_ROUTE_ERROR_COST___13 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___13 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___13 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___13 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___13 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___13 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___13 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___13 = 19
} ;
enum __anonenum_127___12 {
    NET_PROTO_CONF_ALL___13 = -2,
    NET_PROTO_CONF_DEFAULT___13 = -3
} ;
enum __anonenum_128___12 {
    NET_IPV4_CONF_FORWARDING___13 = 1,
    NET_IPV4_CONF_MC_FORWARDING___13 = 2,
    NET_IPV4_CONF_PROXY_ARP___13 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___13 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___13 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___13 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___13 = 7,
    NET_IPV4_CONF_RP_FILTER___13 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___13 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___13 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___13 = 11,
    NET_IPV4_CONF_TAG___13 = 12,
    NET_IPV4_CONF_ARPFILTER___13 = 13,
    NET_IPV4_CONF_MEDIUM_ID___13 = 14,
    NET_IPV4_CONF_NOXFRM___13 = 15,
    NET_IPV4_CONF_NOPOLICY___13 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___13 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___13 = 18,
    NET_IPV4_CONF_ARP_IGNORE___13 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___13 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___13 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___13 = 22,
    __NET_IPV4_CONF_MAX___13 = 23
} ;
enum __anonenum_129___12 {
    NET_IPV4_NF_CONNTRACK_MAX___13 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___13 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___13 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___13 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___13 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___13 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___13 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___13 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___13 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___13 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___13 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___13 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___13 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___13 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___13 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___13 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___13 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___13 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___13 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___13 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___13 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___13 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___13 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___13 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___13 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___13 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___13 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___13 = 28
} ;
enum __anonenum_130___12 {
    NET_IPV6_CONF___13 = 16,
    NET_IPV6_NEIGH___13 = 17,
    NET_IPV6_ROUTE___13 = 18,
    NET_IPV6_ICMP___13 = 19,
    NET_IPV6_BINDV6ONLY___13 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___13 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___13 = 22,
    NET_IPV6_IP6FRAG_TIME___13 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___13 = 24,
    NET_IPV6_MLD_MAX_MSF___13 = 25
} ;
enum __anonenum_131___12 {
    NET_IPV6_ROUTE_FLUSH___13 = 1,
    NET_IPV6_ROUTE_GC_THRESH___13 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___13 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___13 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___13 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___13 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___13 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___13 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___13 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___13 = 10
} ;
enum __anonenum_132___13 {
    NET_IPV6_FORWARDING___13 = 1,
    NET_IPV6_HOP_LIMIT___13 = 2,
    NET_IPV6_MTU___13 = 3,
    NET_IPV6_ACCEPT_RA___13 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___13 = 5,
    NET_IPV6_AUTOCONF___13 = 6,
    NET_IPV6_DAD_TRANSMITS___13 = 7,
    NET_IPV6_RTR_SOLICITS___13 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___13 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___13 = 10,
    NET_IPV6_USE_TEMPADDR___13 = 11,
    NET_IPV6_TEMP_VALID_LFT___13 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___13 = 13,
    NET_IPV6_REGEN_MAX_RETRY___13 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___13 = 15,
    NET_IPV6_MAX_ADDRESSES___13 = 16,
    NET_IPV6_FORCE_MLD_VERSION___13 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___13 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___13 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___13 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___13 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___13 = 22,
    NET_IPV6_PROXY_NDP___13 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___13 = 25,
    __NET_IPV6_MAX___13 = 26
} ;
enum __anonenum_133___13 {
    NET_IPV6_ICMP_RATELIMIT___13 = 1
} ;
enum __anonenum_134___13 {
    NET_NEIGH_MCAST_SOLICIT___13 = 1,
    NET_NEIGH_UCAST_SOLICIT___13 = 2,
    NET_NEIGH_APP_SOLICIT___13 = 3,
    NET_NEIGH_RETRANS_TIME___13 = 4,
    NET_NEIGH_REACHABLE_TIME___13 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___13 = 6,
    NET_NEIGH_GC_STALE_TIME___13 = 7,
    NET_NEIGH_UNRES_QLEN___13 = 8,
    NET_NEIGH_PROXY_QLEN___13 = 9,
    NET_NEIGH_ANYCAST_DELAY___13 = 10,
    NET_NEIGH_PROXY_DELAY___13 = 11,
    NET_NEIGH_LOCKTIME___13 = 12,
    NET_NEIGH_GC_INTERVAL___13 = 13,
    NET_NEIGH_GC_THRESH1___13 = 14,
    NET_NEIGH_GC_THRESH2___13 = 15,
    NET_NEIGH_GC_THRESH3___13 = 16,
    NET_NEIGH_RETRANS_TIME_MS___13 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___13 = 18,
    __NET_NEIGH_MAX___13 = 19
} ;
enum __anonenum_135___13 {
    NET_DCCP_DEFAULT___13 = 1
} ;
enum __anonenum_136___13 {
    NET_IPX_PPROP_BROADCASTING___13 = 1,
    NET_IPX_FORWARDING___13 = 2
} ;
enum __anonenum_137___13 {
    NET_LLC2___13 = 1,
    NET_LLC_STATION___13 = 2
} ;
enum __anonenum_138___13 {
    NET_LLC2_TIMEOUT___13 = 1
} ;
enum __anonenum_139___13 {
    NET_LLC_STATION_ACK_TIMEOUT___13 = 1
} ;
enum __anonenum_140___13 {
    NET_LLC2_ACK_TIMEOUT___13 = 1,
    NET_LLC2_P_TIMEOUT___13 = 2,
    NET_LLC2_REJ_TIMEOUT___13 = 3,
    NET_LLC2_BUSY_TIMEOUT___13 = 4
} ;
enum __anonenum_141___13 {
    NET_ATALK_AARP_EXPIRY_TIME___13 = 1,
    NET_ATALK_AARP_TICK_TIME___13 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___13 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___13 = 4
} ;
enum __anonenum_142___13 {
    NET_NETROM_DEFAULT_PATH_QUALITY___13 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___13 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___13 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___13 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___13 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___13 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___13 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___13 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___13 = 9,
    NET_NETROM_ROUTING_CONTROL___13 = 10,
    NET_NETROM_LINK_FAILS_COUNT___13 = 11,
    NET_NETROM_RESET___13 = 12
} ;
enum __anonenum_143___13 {
    NET_AX25_IP_DEFAULT_MODE___13 = 1,
    NET_AX25_DEFAULT_MODE___13 = 2,
    NET_AX25_BACKOFF_TYPE___13 = 3,
    NET_AX25_CONNECT_MODE___13 = 4,
    NET_AX25_STANDARD_WINDOW___13 = 5,
    NET_AX25_EXTENDED_WINDOW___13 = 6,
    NET_AX25_T1_TIMEOUT___13 = 7,
    NET_AX25_T2_TIMEOUT___13 = 8,
    NET_AX25_T3_TIMEOUT___13 = 9,
    NET_AX25_IDLE_TIMEOUT___13 = 10,
    NET_AX25_N2___13 = 11,
    NET_AX25_PACLEN___13 = 12,
    NET_AX25_PROTOCOL___13 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___13 = 14
} ;
enum __anonenum_144___13 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___13 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___13 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___13 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___13 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___13 = 5,
    NET_ROSE_ROUTING_CONTROL___13 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___13 = 7,
    NET_ROSE_MAX_VCS___13 = 8,
    NET_ROSE_WINDOW_SIZE___13 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___13 = 10
} ;
enum __anonenum_145___13 {
    NET_X25_RESTART_REQUEST_TIMEOUT___13 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___13 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___13 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___13 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___13 = 5,
    NET_X25_FORWARD___13 = 6
} ;
enum __anonenum_146___13 {
    NET_TR_RIF_TIMEOUT___13 = 1
} ;
enum __anonenum_147___13 {
    NET_DECNET_NODE_TYPE___13 = 1,
    NET_DECNET_NODE_ADDRESS___13 = 2,
    NET_DECNET_NODE_NAME___13 = 3,
    NET_DECNET_DEFAULT_DEVICE___13 = 4,
    NET_DECNET_TIME_WAIT___13 = 5,
    NET_DECNET_DN_COUNT___13 = 6,
    NET_DECNET_DI_COUNT___13 = 7,
    NET_DECNET_DR_COUNT___13 = 8,
    NET_DECNET_DST_GC_INTERVAL___13 = 9,
    NET_DECNET_CONF___13 = 10,
    NET_DECNET_NO_FC_MAX_CWND___13 = 11,
    NET_DECNET_MEM___13 = 12,
    NET_DECNET_RMEM___13 = 13,
    NET_DECNET_WMEM___13 = 14,
    NET_DECNET_DEBUG_LEVEL___13 = 255
} ;
enum __anonenum_148___13 {
    NET_DECNET_CONF_LOOPBACK___13 = -2,
    NET_DECNET_CONF_DDCMP___13 = -3,
    NET_DECNET_CONF_PPP___13 = -4,
    NET_DECNET_CONF_X25___13 = -5,
    NET_DECNET_CONF_GRE___13 = -6,
    NET_DECNET_CONF_ETHER___13 = -7
} ;
enum __anonenum_149___13 {
    NET_DECNET_CONF_DEV_PRIORITY___13 = 1,
    NET_DECNET_CONF_DEV_T1___13 = 2,
    NET_DECNET_CONF_DEV_T2___13 = 3,
    NET_DECNET_CONF_DEV_T3___13 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___13 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___13 = 6,
    NET_DECNET_CONF_DEV_STATE___13 = 7
} ;
enum __anonenum_150___13 {
    NET_SCTP_RTO_INITIAL___13 = 1,
    NET_SCTP_RTO_MIN___13 = 2,
    NET_SCTP_RTO_MAX___13 = 3,
    NET_SCTP_RTO_ALPHA___13 = 4,
    NET_SCTP_RTO_BETA___13 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___13 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___13 = 7,
    NET_SCTP_PATH_MAX_RETRANS___13 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___13 = 9,
    NET_SCTP_HB_INTERVAL___13 = 10,
    NET_SCTP_PRESERVE_ENABLE___13 = 11,
    NET_SCTP_MAX_BURST___13 = 12,
    NET_SCTP_ADDIP_ENABLE___13 = 13,
    NET_SCTP_PRSCTP_ENABLE___13 = 14,
    NET_SCTP_SNDBUF_POLICY___13 = 15,
    NET_SCTP_SACK_TIMEOUT___13 = 16,
    NET_SCTP_RCVBUF_POLICY___13 = 17
} ;
enum __anonenum_151___13 {
    NET_BRIDGE_NF_CALL_ARPTABLES___13 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___13 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___13 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___13 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___13 = 5
} ;
enum __anonenum_152___13 {
    NET_IRDA_DISCOVERY___13 = 1,
    NET_IRDA_DEVNAME___13 = 2,
    NET_IRDA_DEBUG___13 = 3,
    NET_IRDA_FAST_POLL___13 = 4,
    NET_IRDA_DISCOVERY_SLOTS___13 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___13 = 6,
    NET_IRDA_SLOT_TIMEOUT___13 = 7,
    NET_IRDA_MAX_BAUD_RATE___13 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___13 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___13 = 10,
    NET_IRDA_MAX_TX_WINDOW___13 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___13 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___13 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___13 = 14
} ;
enum __anonenum_153___13 {
    FS_NRINODE___13 = 1,
    FS_STATINODE___13 = 2,
    FS_MAXINODE___13 = 3,
    FS_NRDQUOT___13 = 4,
    FS_MAXDQUOT___13 = 5,
    FS_NRFILE___13 = 6,
    FS_MAXFILE___13 = 7,
    FS_DENTRY___13 = 8,
    FS_NRSUPER___13 = 9,
    FS_MAXSUPER___13 = 10,
    FS_OVERFLOWUID___13 = 11,
    FS_OVERFLOWGID___13 = 12,
    FS_LEASES___13 = 13,
    FS_DIR_NOTIFY___13 = 14,
    FS_LEASE_TIME___13 = 15,
    FS_DQSTATS___13 = 16,
    FS_XFS___13 = 17,
    FS_AIO_NR___13 = 18,
    FS_AIO_MAX_NR___13 = 19,
    FS_INOTIFY___13 = 20,
    FS_OCFS2___13 = 988
} ;
enum __anonenum_154___13 {
    FS_DQ_LOOKUPS___13 = 1,
    FS_DQ_DROPS___13 = 2,
    FS_DQ_READS___13 = 3,
    FS_DQ_WRITES___13 = 4,
    FS_DQ_CACHE_HITS___13 = 5,
    FS_DQ_ALLOCATED___13 = 6,
    FS_DQ_FREE___13 = 7,
    FS_DQ_SYNCS___13 = 8,
    FS_DQ_WARNINGS___13 = 9
} ;
enum __anonenum_155___13 {
    DEV_CDROM___13 = 1,
    DEV_HWMON___13 = 2,
    DEV_PARPORT___13 = 3,
    DEV_RAID___13 = 4,
    DEV_MAC_HID___13 = 5,
    DEV_SCSI___13 = 6,
    DEV_IPMI___13 = 7
} ;
enum __anonenum_156___13 {
    DEV_CDROM_INFO___13 = 1,
    DEV_CDROM_AUTOCLOSE___13 = 2,
    DEV_CDROM_AUTOEJECT___13 = 3,
    DEV_CDROM_DEBUG___13 = 4,
    DEV_CDROM_LOCK___13 = 5,
    DEV_CDROM_CHECK_MEDIA___13 = 6
} ;
enum __anonenum_157___13 {
    DEV_PARPORT_DEFAULT___13 = -3
} ;
enum __anonenum_158___13 {
    DEV_RAID_SPEED_LIMIT_MIN___13 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___13 = 2
} ;
enum __anonenum_159___13 {
    DEV_PARPORT_DEFAULT_TIMESLICE___13 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___13 = 2
} ;
enum __anonenum_160___13 {
    DEV_PARPORT_SPINTIME___13 = 1,
    DEV_PARPORT_BASE_ADDR___13 = 2,
    DEV_PARPORT_IRQ___13 = 3,
    DEV_PARPORT_DMA___13 = 4,
    DEV_PARPORT_MODES___13 = 5,
    DEV_PARPORT_DEVICES___13 = 6,
    DEV_PARPORT_AUTOPROBE___13 = 16
} ;
enum __anonenum_161___13 {
    DEV_PARPORT_DEVICES_ACTIVE___13 = -3
} ;
enum __anonenum_162___13 {
    DEV_PARPORT_DEVICE_TIMESLICE___13 = 1
} ;
enum __anonenum_163___13 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___13 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___13 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___13 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___13 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___13 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___13 = 6
} ;
enum __anonenum_164___13 {
    DEV_SCSI_LOGGING_LEVEL___13 = 1
} ;
enum __anonenum_165___13 {
    DEV_IPMI_POWEROFF_POWERCYCLE___13 = 1
} ;
enum __anonenum_166___13 {
    ABI_DEFHANDLER_COFF___13 = 1,
    ABI_DEFHANDLER_ELF___13 = 2,
    ABI_DEFHANDLER_LCALL7___13 = 3,
    ABI_DEFHANDLER_LIBCSO___13 = 4,
    ABI_TRACE___13 = 5,
    ABI_FAKE_UTSNAME___13 = 6
} ;
enum __anonenum_169___13 {
    IOCB_CMD_PREAD___13 = 0,
    IOCB_CMD_PWRITE___13 = 1,
    IOCB_CMD_FSYNC___13 = 2,
    IOCB_CMD_FDSYNC___13 = 3,
    IOCB_CMD_NOOP___13 = 6,
    IOCB_CMD_PREADV___13 = 7,
    IOCB_CMD_PWRITEV___13 = 8
} ;
enum __anonenum_172___13 {
    IRQTF_RUNTHREAD___13 = 0,
    IRQTF_DIED___13 = 1,
    IRQTF_WARNED___13 = 2
} ;
enum __anonenum_173___10 {
    HI_SOFTIRQ___13 = 0,
    TIMER_SOFTIRQ___13 = 1,
    NET_TX_SOFTIRQ___13 = 2,
    NET_RX_SOFTIRQ___13 = 3,
    BLOCK_SOFTIRQ___13 = 4,
    TASKLET_SOFTIRQ___13 = 5,
    SCHED_SOFTIRQ___13 = 6,
    HRTIMER_SOFTIRQ___13 = 7,
    RCU_SOFTIRQ___13 = 8,
    NR_SOFTIRQS___13 = 9
} ;
enum __anonenum_174___8 {
    TASKLET_STATE_SCHED___13 = 0,
    TASKLET_STATE_RUN___13 = 1
} ;
enum __anonenum_183___9 {
    QIF_BLIMITS_B___13 = 0,
    QIF_SPACE_B___13 = 1,
    QIF_ILIMITS_B___13 = 2,
    QIF_INODES_B___13 = 3,
    QIF_BTIME_B___13 = 4,
    QIF_ITIME_B___13 = 5
} ;
enum __anonenum_184___11 {
    QUOTA_NL_C_UNSPEC___13 = 0,
    QUOTA_NL_C_WARNING___13 = 1,
    __QUOTA_NL_C_MAX___13 = 2
} ;
enum __anonenum_185___11 {
    QUOTA_NL_A_UNSPEC___13 = 0,
    QUOTA_NL_A_QTYPE___13 = 1,
    QUOTA_NL_A_EXCESS_ID___13 = 2,
    QUOTA_NL_A_WARNING___13 = 3,
    QUOTA_NL_A_DEV_MAJOR___13 = 4,
    QUOTA_NL_A_DEV_MINOR___13 = 5,
    QUOTA_NL_A_CAUSED_ID___13 = 6,
    __QUOTA_NL_A_MAX___13 = 7
} ;
enum __anonenum_186___11 {
    _DQUOT_USAGE_ENABLED___13 = 0,
    _DQUOT_LIMITS_ENABLED___13 = 1,
    _DQUOT_SUSPENDED___13 = 2,
    _DQUOT_STATE_FLAGS___13 = 3
} ;
enum __anonenum_193___10 {
    SB_UNFROZEN___13 = 0,
    SB_FREEZE_WRITE___13 = 1,
    SB_FREEZE_TRANS___13 = 2
} ;
enum __anonenum_194___12 {
    DIO_LOCKING___13 = 1,
    DIO_NO_LOCKING___13 = 2,
    DIO_OWN_LOCKING___13 = 3
} ;
enum __anonenum_4___14 {
    false___14 = 0,
    true___14 = 1
} ;
enum __anonenum_8___3 {
    DUMP_PREFIX_NONE___14 = 0,
    DUMP_PREFIX_ADDRESS___14 = 1,
    DUMP_PREFIX_OFFSET___14 = 2
} ;
enum __anonenum_21___13 {
    PG_LEVEL_NONE___14 = 0,
    PG_LEVEL_4K___14 = 1,
    PG_LEVEL_2M___14 = 2,
    PG_LEVEL_1G___14 = 3,
    PG_LEVEL_NUM___14 = 4
} ;
enum __anonenum_25___3 {
    GATE_INTERRUPT___14 = 14,
    GATE_TRAP___14 = 15,
    GATE_CALL___14 = 12,
    GATE_TASK___14 = 5
} ;
enum __anonenum_26___3 {
    DESC_TSS___14 = 9,
    DESC_LDT___14 = 2,
    DESCTYPE_S___14 = 16
} ;
enum __anonenum_27___3 {
    ADDR_NO_RANDOMIZE___14 = 262144,
    FDPIC_FUNCPTRS___14 = 524288,
    MMAP_PAGE_ZERO___14 = 1048576,
    ADDR_COMPAT_LAYOUT___14 = 2097152,
    READ_IMPLIES_EXEC___14 = 4194304,
    ADDR_LIMIT_32BIT___14 = 8388608,
    SHORT_INODE___14 = 16777216,
    WHOLE_SECONDS___14 = 33554432,
    STICKY_TIMEOUTS___14 = 67108864,
    ADDR_LIMIT_3GB___14 = 134217728
} ;
enum __anonenum_28___2 {
    PER_LINUX___14 = 0,
    PER_LINUX_32BIT___14 = 8388608,
    PER_LINUX_FDPIC___14 = 524288,
    PER_SVR4___14 = 68157441,
    PER_SVR3___14 = 83886082,
    PER_SCOSVR3___14 = 117440515,
    PER_OSR5___14 = 100663299,
    PER_WYSEV386___14 = 83886084,
    PER_ISCR4___14 = 67108869,
    PER_BSD___14 = 6,
    PER_SUNOS___14 = 67108870,
    PER_XENIX___14 = 83886087,
    PER_LINUX32___14 = 8,
    PER_LINUX32_3GB___14 = 134217736,
    PER_IRIX32___14 = 67108873,
    PER_IRIXN32___14 = 67108874,
    PER_IRIX64___14 = 67108875,
    PER_RISCOS___14 = 12,
    PER_SOLARIS___14 = 67108877,
    PER_UW7___14 = 68157454,
    PER_OSF4___14 = 15,
    PER_HPUX___14 = 16,
    PER_MASK___14 = 255
} ;
union __anonunion_d_39___4 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_113___5 {
    CTL_KERN___14 = 1,
    CTL_VM___14 = 2,
    CTL_NET___14 = 3,
    CTL_PROC___14 = 4,
    CTL_FS___14 = 5,
    CTL_DEBUG___14 = 6,
    CTL_DEV___14 = 7,
    CTL_BUS___14 = 8,
    CTL_ABI___14 = 9,
    CTL_CPU___14 = 10,
    CTL_ARLAN___14 = 254,
    CTL_S390DBF___14 = 5677,
    CTL_SUNRPC___14 = 7249,
    CTL_PM___14 = 9899,
    CTL_FRV___14 = 9898
} ;
enum __anonenum_114___4 {
    CTL_BUS_ISA___14 = 1
} ;
enum __anonenum_115___4 {
    INOTIFY_MAX_USER_INSTANCES___14 = 1,
    INOTIFY_MAX_USER_WATCHES___14 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___14 = 3
} ;
enum __anonenum_116___4 {
    KERN_OSTYPE___14 = 1,
    KERN_OSRELEASE___14 = 2,
    KERN_OSREV___14 = 3,
    KERN_VERSION___14 = 4,
    KERN_SECUREMASK___14 = 5,
    KERN_PROF___14 = 6,
    KERN_NODENAME___14 = 7,
    KERN_DOMAINNAME___14 = 8,
    KERN_PANIC___14 = 15,
    KERN_REALROOTDEV___14 = 16,
    KERN_SPARC_REBOOT___14 = 21,
    KERN_CTLALTDEL___14 = 22,
    KERN_PRINTK___14 = 23,
    KERN_NAMETRANS___14 = 24,
    KERN_PPC_HTABRECLAIM___14 = 25,
    KERN_PPC_ZEROPAGED___14 = 26,
    KERN_PPC_POWERSAVE_NAP___14 = 27,
    KERN_MODPROBE___14 = 28,
    KERN_SG_BIG_BUFF___14 = 29,
    KERN_ACCT___14 = 30,
    KERN_PPC_L2CR___14 = 31,
    KERN_RTSIGNR___14 = 32,
    KERN_RTSIGMAX___14 = 33,
    KERN_SHMMAX___14 = 34,
    KERN_MSGMAX___14 = 35,
    KERN_MSGMNB___14 = 36,
    KERN_MSGPOOL___14 = 37,
    KERN_SYSRQ___14 = 38,
    KERN_MAX_THREADS___14 = 39,
    KERN_RANDOM___14 = 40,
    KERN_SHMALL___14 = 41,
    KERN_MSGMNI___14 = 42,
    KERN_SEM___14 = 43,
    KERN_SPARC_STOP_A___14 = 44,
    KERN_SHMMNI___14 = 45,
    KERN_OVERFLOWUID___14 = 46,
    KERN_OVERFLOWGID___14 = 47,
    KERN_SHMPATH___14 = 48,
    KERN_HOTPLUG___14 = 49,
    KERN_IEEE_EMULATION_WARNINGS___14 = 50,
    KERN_S390_USER_DEBUG_LOGGING___14 = 51,
    KERN_CORE_USES_PID___14 = 52,
    KERN_TAINTED___14 = 53,
    KERN_CADPID___14 = 54,
    KERN_PIDMAX___14 = 55,
    KERN_CORE_PATTERN___14 = 56,
    KERN_PANIC_ON_OOPS___14 = 57,
    KERN_HPPA_PWRSW___14 = 58,
    KERN_HPPA_UNALIGNED___14 = 59,
    KERN_PRINTK_RATELIMIT___14 = 60,
    KERN_PRINTK_RATELIMIT_BURST___14 = 61,
    KERN_PTY___14 = 62,
    KERN_NGROUPS_MAX___14 = 63,
    KERN_SPARC_SCONS_PWROFF___14 = 64,
    KERN_HZ_TIMER___14 = 65,
    KERN_UNKNOWN_NMI_PANIC___14 = 66,
    KERN_BOOTLOADER_TYPE___14 = 67,
    KERN_RANDOMIZE___14 = 68,
    KERN_SETUID_DUMPABLE___14 = 69,
    KERN_SPIN_RETRY___14 = 70,
    KERN_ACPI_VIDEO_FLAGS___14 = 71,
    KERN_IA64_UNALIGNED___14 = 72,
    KERN_COMPAT_LOG___14 = 73,
    KERN_MAX_LOCK_DEPTH___14 = 74,
    KERN_NMI_WATCHDOG___14 = 75,
    KERN_PANIC_ON_NMI___14 = 76
} ;
enum __anonenum_117___4 {
    VM_UNUSED1___14 = 1,
    VM_UNUSED2___14 = 2,
    VM_UNUSED3___14 = 3,
    VM_UNUSED4___14 = 4,
    VM_OVERCOMMIT_MEMORY___14 = 5,
    VM_UNUSED5___14 = 6,
    VM_UNUSED7___14 = 7,
    VM_UNUSED8___14 = 8,
    VM_UNUSED9___14 = 9,
    VM_PAGE_CLUSTER___14 = 10,
    VM_DIRTY_BACKGROUND___14 = 11,
    VM_DIRTY_RATIO___14 = 12,
    VM_DIRTY_WB_CS___14 = 13,
    VM_DIRTY_EXPIRE_CS___14 = 14,
    VM_NR_PDFLUSH_THREADS___14 = 15,
    VM_OVERCOMMIT_RATIO___14 = 16,
    VM_PAGEBUF___14 = 17,
    VM_HUGETLB_PAGES___14 = 18,
    VM_SWAPPINESS___14 = 19,
    VM_LOWMEM_RESERVE_RATIO___14 = 20,
    VM_MIN_FREE_KBYTES___14 = 21,
    VM_MAX_MAP_COUNT___14 = 22,
    VM_LAPTOP_MODE___14 = 23,
    VM_BLOCK_DUMP___14 = 24,
    VM_HUGETLB_GROUP___14 = 25,
    VM_VFS_CACHE_PRESSURE___14 = 26,
    VM_LEGACY_VA_LAYOUT___14 = 27,
    VM_SWAP_TOKEN_TIMEOUT___14 = 28,
    VM_DROP_PAGECACHE___14 = 29,
    VM_PERCPU_PAGELIST_FRACTION___14 = 30,
    VM_ZONE_RECLAIM_MODE___14 = 31,
    VM_MIN_UNMAPPED___14 = 32,
    VM_PANIC_ON_OOM___14 = 33,
    VM_VDSO_ENABLED___14 = 34,
    VM_MIN_SLAB___14 = 35
} ;
enum __anonenum_118___4 {
    NET_CORE___14 = 1,
    NET_ETHER___14 = 2,
    NET_802___14 = 3,
    NET_UNIX___14 = 4,
    NET_IPV4___14 = 5,
    NET_IPX___14 = 6,
    NET_ATALK___14 = 7,
    NET_NETROM___14 = 8,
    NET_AX25___14 = 9,
    NET_BRIDGE___14 = 10,
    NET_ROSE___14 = 11,
    NET_IPV6___14 = 12,
    NET_X25___14 = 13,
    NET_TR___14 = 14,
    NET_DECNET___14 = 15,
    NET_ECONET___14 = 16,
    NET_SCTP___14 = 17,
    NET_LLC___14 = 18,
    NET_NETFILTER___14 = 19,
    NET_DCCP___14 = 20,
    NET_IRDA___14 = 412
} ;
enum __anonenum_119___7 {
    RANDOM_POOLSIZE___14 = 1,
    RANDOM_ENTROPY_COUNT___14 = 2,
    RANDOM_READ_THRESH___14 = 3,
    RANDOM_WRITE_THRESH___14 = 4,
    RANDOM_BOOT_ID___14 = 5,
    RANDOM_UUID___14 = 6
} ;
enum __anonenum_120___9 {
    PTY_MAX___14 = 1,
    PTY_NR___14 = 2
} ;
enum __anonenum_121___11 {
    BUS_ISA_MEM_BASE___14 = 1,
    BUS_ISA_PORT_BASE___14 = 2,
    BUS_ISA_PORT_SHIFT___14 = 3
} ;
enum __anonenum_122___11 {
    NET_CORE_WMEM_MAX___14 = 1,
    NET_CORE_RMEM_MAX___14 = 2,
    NET_CORE_WMEM_DEFAULT___14 = 3,
    NET_CORE_RMEM_DEFAULT___14 = 4,
    NET_CORE_MAX_BACKLOG___14 = 6,
    NET_CORE_FASTROUTE___14 = 7,
    NET_CORE_MSG_COST___14 = 8,
    NET_CORE_MSG_BURST___14 = 9,
    NET_CORE_OPTMEM_MAX___14 = 10,
    NET_CORE_HOT_LIST_LENGTH___14 = 11,
    NET_CORE_DIVERT_VERSION___14 = 12,
    NET_CORE_NO_CONG_THRESH___14 = 13,
    NET_CORE_NO_CONG___14 = 14,
    NET_CORE_LO_CONG___14 = 15,
    NET_CORE_MOD_CONG___14 = 16,
    NET_CORE_DEV_WEIGHT___14 = 17,
    NET_CORE_SOMAXCONN___14 = 18,
    NET_CORE_BUDGET___14 = 19,
    NET_CORE_AEVENT_ETIME___14 = 20,
    NET_CORE_AEVENT_RSEQTH___14 = 21,
    NET_CORE_WARNINGS___14 = 22
} ;
enum __anonenum_123___11 {
    NET_UNIX_DESTROY_DELAY___14 = 1,
    NET_UNIX_DELETE_DELAY___14 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___14 = 3
} ;
enum __anonenum_124___11 {
    NET_NF_CONNTRACK_MAX___14 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___14 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___14 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___14 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___14 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___14 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___14 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___14 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___14 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___14 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___14 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___14 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___14 = 13,
    NET_NF_CONNTRACK_BUCKETS___14 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___14 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___14 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___14 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___14 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___14 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___14 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___14 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___14 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___14 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___14 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___14 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___14 = 26,
    NET_NF_CONNTRACK_COUNT___14 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___14 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___14 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___14 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___14 = 31,
    NET_NF_CONNTRACK_CHECKSUM___14 = 32
} ;
enum __anonenum_125___13 {
    NET_IPV4_FORWARD___14 = 8,
    NET_IPV4_DYNADDR___14 = 9,
    NET_IPV4_CONF___14 = 16,
    NET_IPV4_NEIGH___14 = 17,
    NET_IPV4_ROUTE___14 = 18,
    NET_IPV4_FIB_HASH___14 = 19,
    NET_IPV4_NETFILTER___14 = 20,
    NET_IPV4_TCP_TIMESTAMPS___14 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___14 = 34,
    NET_IPV4_TCP_SACK___14 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___14 = 36,
    NET_IPV4_DEFAULT_TTL___14 = 37,
    NET_IPV4_AUTOCONFIG___14 = 38,
    NET_IPV4_NO_PMTU_DISC___14 = 39,
    NET_IPV4_TCP_SYN_RETRIES___14 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___14 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___14 = 42,
    NET_IPV4_IPFRAG_TIME___14 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___14 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___14 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___14 = 46,
    NET_IPV4_TCP_RETRIES1___14 = 47,
    NET_IPV4_TCP_RETRIES2___14 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___14 = 49,
    NET_IPV4_IP_MASQ_DEBUG___14 = 50,
    NET_TCP_SYNCOOKIES___14 = 51,
    NET_TCP_STDURG___14 = 52,
    NET_TCP_RFC1337___14 = 53,
    NET_TCP_SYN_TAILDROP___14 = 54,
    NET_TCP_MAX_SYN_BACKLOG___14 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___14 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___14 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___14 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___14 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___14 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___14 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___14 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___14 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___14 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___14 = 65,
    NET_TCP_TW_RECYCLE___14 = 66,
    NET_IPV4_ALWAYS_DEFRAG___14 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___14 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___14 = 69,
    NET_IPV4_INET_PEER_MINTTL___14 = 70,
    NET_IPV4_INET_PEER_MAXTTL___14 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___14 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___14 = 73,
    NET_TCP_ORPHAN_RETRIES___14 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___14 = 75,
    NET_TCP_SYNACK_RETRIES___14 = 76,
    NET_TCP_MAX_ORPHANS___14 = 77,
    NET_TCP_MAX_TW_BUCKETS___14 = 78,
    NET_TCP_FACK___14 = 79,
    NET_TCP_REORDERING___14 = 80,
    NET_TCP_ECN___14 = 81,
    NET_TCP_DSACK___14 = 82,
    NET_TCP_MEM___14 = 83,
    NET_TCP_WMEM___14 = 84,
    NET_TCP_RMEM___14 = 85,
    NET_TCP_APP_WIN___14 = 86,
    NET_TCP_ADV_WIN_SCALE___14 = 87,
    NET_IPV4_NONLOCAL_BIND___14 = 88,
    NET_IPV4_ICMP_RATELIMIT___14 = 89,
    NET_IPV4_ICMP_RATEMASK___14 = 90,
    NET_TCP_TW_REUSE___14 = 91,
    NET_TCP_FRTO___14 = 92,
    NET_TCP_LOW_LATENCY___14 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___14 = 94,
    NET_IPV4_IGMP_MAX_MSF___14 = 96,
    NET_TCP_NO_METRICS_SAVE___14 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___14 = 105,
    NET_TCP_MODERATE_RCVBUF___14 = 106,
    NET_TCP_TSO_WIN_DIVISOR___14 = 107,
    NET_TCP_BIC_BETA___14 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___14 = 109,
    NET_TCP_CONG_CONTROL___14 = 110,
    NET_TCP_ABC___14 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___14 = 112,
    NET_TCP_MTU_PROBING___14 = 113,
    NET_TCP_BASE_MSS___14 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___14 = 115,
    NET_TCP_DMA_COPYBREAK___14 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___14 = 117,
    NET_CIPSOV4_CACHE_ENABLE___14 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___14 = 119,
    NET_CIPSOV4_RBM_OPTFMT___14 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___14 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___14 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___14 = 123,
    NET_TCP_MAX_SSTHRESH___14 = 124,
    NET_TCP_FRTO_RESPONSE___14 = 125
} ;
enum __anonenum_126___13 {
    NET_IPV4_ROUTE_FLUSH___14 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___14 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___14 = 3,
    NET_IPV4_ROUTE_GC_THRESH___14 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___14 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___14 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___14 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___14 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___14 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___14 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___14 = 11,
    NET_IPV4_ROUTE_ERROR_COST___14 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___14 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___14 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___14 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___14 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___14 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___14 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___14 = 19
} ;
enum __anonenum_127___13 {
    NET_PROTO_CONF_ALL___14 = -2,
    NET_PROTO_CONF_DEFAULT___14 = -3
} ;
enum __anonenum_128___13 {
    NET_IPV4_CONF_FORWARDING___14 = 1,
    NET_IPV4_CONF_MC_FORWARDING___14 = 2,
    NET_IPV4_CONF_PROXY_ARP___14 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___14 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___14 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___14 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___14 = 7,
    NET_IPV4_CONF_RP_FILTER___14 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___14 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___14 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___14 = 11,
    NET_IPV4_CONF_TAG___14 = 12,
    NET_IPV4_CONF_ARPFILTER___14 = 13,
    NET_IPV4_CONF_MEDIUM_ID___14 = 14,
    NET_IPV4_CONF_NOXFRM___14 = 15,
    NET_IPV4_CONF_NOPOLICY___14 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___14 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___14 = 18,
    NET_IPV4_CONF_ARP_IGNORE___14 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___14 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___14 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___14 = 22,
    __NET_IPV4_CONF_MAX___14 = 23
} ;
enum __anonenum_129___13 {
    NET_IPV4_NF_CONNTRACK_MAX___14 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___14 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___14 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___14 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___14 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___14 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___14 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___14 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___14 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___14 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___14 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___14 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___14 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___14 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___14 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___14 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___14 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___14 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___14 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___14 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___14 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___14 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___14 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___14 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___14 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___14 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___14 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___14 = 28
} ;
enum __anonenum_130___13 {
    NET_IPV6_CONF___14 = 16,
    NET_IPV6_NEIGH___14 = 17,
    NET_IPV6_ROUTE___14 = 18,
    NET_IPV6_ICMP___14 = 19,
    NET_IPV6_BINDV6ONLY___14 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___14 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___14 = 22,
    NET_IPV6_IP6FRAG_TIME___14 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___14 = 24,
    NET_IPV6_MLD_MAX_MSF___14 = 25
} ;
enum __anonenum_131___13 {
    NET_IPV6_ROUTE_FLUSH___14 = 1,
    NET_IPV6_ROUTE_GC_THRESH___14 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___14 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___14 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___14 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___14 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___14 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___14 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___14 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___14 = 10
} ;
enum __anonenum_132___14 {
    NET_IPV6_FORWARDING___14 = 1,
    NET_IPV6_HOP_LIMIT___14 = 2,
    NET_IPV6_MTU___14 = 3,
    NET_IPV6_ACCEPT_RA___14 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___14 = 5,
    NET_IPV6_AUTOCONF___14 = 6,
    NET_IPV6_DAD_TRANSMITS___14 = 7,
    NET_IPV6_RTR_SOLICITS___14 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___14 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___14 = 10,
    NET_IPV6_USE_TEMPADDR___14 = 11,
    NET_IPV6_TEMP_VALID_LFT___14 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___14 = 13,
    NET_IPV6_REGEN_MAX_RETRY___14 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___14 = 15,
    NET_IPV6_MAX_ADDRESSES___14 = 16,
    NET_IPV6_FORCE_MLD_VERSION___14 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___14 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___14 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___14 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___14 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___14 = 22,
    NET_IPV6_PROXY_NDP___14 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___14 = 25,
    __NET_IPV6_MAX___14 = 26
} ;
enum __anonenum_133___14 {
    NET_IPV6_ICMP_RATELIMIT___14 = 1
} ;
enum __anonenum_134___14 {
    NET_NEIGH_MCAST_SOLICIT___14 = 1,
    NET_NEIGH_UCAST_SOLICIT___14 = 2,
    NET_NEIGH_APP_SOLICIT___14 = 3,
    NET_NEIGH_RETRANS_TIME___14 = 4,
    NET_NEIGH_REACHABLE_TIME___14 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___14 = 6,
    NET_NEIGH_GC_STALE_TIME___14 = 7,
    NET_NEIGH_UNRES_QLEN___14 = 8,
    NET_NEIGH_PROXY_QLEN___14 = 9,
    NET_NEIGH_ANYCAST_DELAY___14 = 10,
    NET_NEIGH_PROXY_DELAY___14 = 11,
    NET_NEIGH_LOCKTIME___14 = 12,
    NET_NEIGH_GC_INTERVAL___14 = 13,
    NET_NEIGH_GC_THRESH1___14 = 14,
    NET_NEIGH_GC_THRESH2___14 = 15,
    NET_NEIGH_GC_THRESH3___14 = 16,
    NET_NEIGH_RETRANS_TIME_MS___14 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___14 = 18,
    __NET_NEIGH_MAX___14 = 19
} ;
enum __anonenum_135___14 {
    NET_DCCP_DEFAULT___14 = 1
} ;
enum __anonenum_136___14 {
    NET_IPX_PPROP_BROADCASTING___14 = 1,
    NET_IPX_FORWARDING___14 = 2
} ;
enum __anonenum_137___14 {
    NET_LLC2___14 = 1,
    NET_LLC_STATION___14 = 2
} ;
enum __anonenum_138___14 {
    NET_LLC2_TIMEOUT___14 = 1
} ;
enum __anonenum_139___14 {
    NET_LLC_STATION_ACK_TIMEOUT___14 = 1
} ;
enum __anonenum_140___14 {
    NET_LLC2_ACK_TIMEOUT___14 = 1,
    NET_LLC2_P_TIMEOUT___14 = 2,
    NET_LLC2_REJ_TIMEOUT___14 = 3,
    NET_LLC2_BUSY_TIMEOUT___14 = 4
} ;
enum __anonenum_141___14 {
    NET_ATALK_AARP_EXPIRY_TIME___14 = 1,
    NET_ATALK_AARP_TICK_TIME___14 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___14 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___14 = 4
} ;
enum __anonenum_142___14 {
    NET_NETROM_DEFAULT_PATH_QUALITY___14 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___14 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___14 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___14 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___14 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___14 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___14 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___14 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___14 = 9,
    NET_NETROM_ROUTING_CONTROL___14 = 10,
    NET_NETROM_LINK_FAILS_COUNT___14 = 11,
    NET_NETROM_RESET___14 = 12
} ;
enum __anonenum_143___14 {
    NET_AX25_IP_DEFAULT_MODE___14 = 1,
    NET_AX25_DEFAULT_MODE___14 = 2,
    NET_AX25_BACKOFF_TYPE___14 = 3,
    NET_AX25_CONNECT_MODE___14 = 4,
    NET_AX25_STANDARD_WINDOW___14 = 5,
    NET_AX25_EXTENDED_WINDOW___14 = 6,
    NET_AX25_T1_TIMEOUT___14 = 7,
    NET_AX25_T2_TIMEOUT___14 = 8,
    NET_AX25_T3_TIMEOUT___14 = 9,
    NET_AX25_IDLE_TIMEOUT___14 = 10,
    NET_AX25_N2___14 = 11,
    NET_AX25_PACLEN___14 = 12,
    NET_AX25_PROTOCOL___14 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___14 = 14
} ;
enum __anonenum_144___14 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___14 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___14 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___14 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___14 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___14 = 5,
    NET_ROSE_ROUTING_CONTROL___14 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___14 = 7,
    NET_ROSE_MAX_VCS___14 = 8,
    NET_ROSE_WINDOW_SIZE___14 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___14 = 10
} ;
enum __anonenum_145___14 {
    NET_X25_RESTART_REQUEST_TIMEOUT___14 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___14 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___14 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___14 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___14 = 5,
    NET_X25_FORWARD___14 = 6
} ;
enum __anonenum_146___14 {
    NET_TR_RIF_TIMEOUT___14 = 1
} ;
enum __anonenum_147___14 {
    NET_DECNET_NODE_TYPE___14 = 1,
    NET_DECNET_NODE_ADDRESS___14 = 2,
    NET_DECNET_NODE_NAME___14 = 3,
    NET_DECNET_DEFAULT_DEVICE___14 = 4,
    NET_DECNET_TIME_WAIT___14 = 5,
    NET_DECNET_DN_COUNT___14 = 6,
    NET_DECNET_DI_COUNT___14 = 7,
    NET_DECNET_DR_COUNT___14 = 8,
    NET_DECNET_DST_GC_INTERVAL___14 = 9,
    NET_DECNET_CONF___14 = 10,
    NET_DECNET_NO_FC_MAX_CWND___14 = 11,
    NET_DECNET_MEM___14 = 12,
    NET_DECNET_RMEM___14 = 13,
    NET_DECNET_WMEM___14 = 14,
    NET_DECNET_DEBUG_LEVEL___14 = 255
} ;
enum __anonenum_148___14 {
    NET_DECNET_CONF_LOOPBACK___14 = -2,
    NET_DECNET_CONF_DDCMP___14 = -3,
    NET_DECNET_CONF_PPP___14 = -4,
    NET_DECNET_CONF_X25___14 = -5,
    NET_DECNET_CONF_GRE___14 = -6,
    NET_DECNET_CONF_ETHER___14 = -7
} ;
enum __anonenum_149___14 {
    NET_DECNET_CONF_DEV_PRIORITY___14 = 1,
    NET_DECNET_CONF_DEV_T1___14 = 2,
    NET_DECNET_CONF_DEV_T2___14 = 3,
    NET_DECNET_CONF_DEV_T3___14 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___14 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___14 = 6,
    NET_DECNET_CONF_DEV_STATE___14 = 7
} ;
enum __anonenum_150___14 {
    NET_SCTP_RTO_INITIAL___14 = 1,
    NET_SCTP_RTO_MIN___14 = 2,
    NET_SCTP_RTO_MAX___14 = 3,
    NET_SCTP_RTO_ALPHA___14 = 4,
    NET_SCTP_RTO_BETA___14 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___14 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___14 = 7,
    NET_SCTP_PATH_MAX_RETRANS___14 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___14 = 9,
    NET_SCTP_HB_INTERVAL___14 = 10,
    NET_SCTP_PRESERVE_ENABLE___14 = 11,
    NET_SCTP_MAX_BURST___14 = 12,
    NET_SCTP_ADDIP_ENABLE___14 = 13,
    NET_SCTP_PRSCTP_ENABLE___14 = 14,
    NET_SCTP_SNDBUF_POLICY___14 = 15,
    NET_SCTP_SACK_TIMEOUT___14 = 16,
    NET_SCTP_RCVBUF_POLICY___14 = 17
} ;
enum __anonenum_151___14 {
    NET_BRIDGE_NF_CALL_ARPTABLES___14 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___14 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___14 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___14 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___14 = 5
} ;
enum __anonenum_152___14 {
    NET_IRDA_DISCOVERY___14 = 1,
    NET_IRDA_DEVNAME___14 = 2,
    NET_IRDA_DEBUG___14 = 3,
    NET_IRDA_FAST_POLL___14 = 4,
    NET_IRDA_DISCOVERY_SLOTS___14 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___14 = 6,
    NET_IRDA_SLOT_TIMEOUT___14 = 7,
    NET_IRDA_MAX_BAUD_RATE___14 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___14 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___14 = 10,
    NET_IRDA_MAX_TX_WINDOW___14 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___14 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___14 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___14 = 14
} ;
enum __anonenum_153___14 {
    FS_NRINODE___14 = 1,
    FS_STATINODE___14 = 2,
    FS_MAXINODE___14 = 3,
    FS_NRDQUOT___14 = 4,
    FS_MAXDQUOT___14 = 5,
    FS_NRFILE___14 = 6,
    FS_MAXFILE___14 = 7,
    FS_DENTRY___14 = 8,
    FS_NRSUPER___14 = 9,
    FS_MAXSUPER___14 = 10,
    FS_OVERFLOWUID___14 = 11,
    FS_OVERFLOWGID___14 = 12,
    FS_LEASES___14 = 13,
    FS_DIR_NOTIFY___14 = 14,
    FS_LEASE_TIME___14 = 15,
    FS_DQSTATS___14 = 16,
    FS_XFS___14 = 17,
    FS_AIO_NR___14 = 18,
    FS_AIO_MAX_NR___14 = 19,
    FS_INOTIFY___14 = 20,
    FS_OCFS2___14 = 988
} ;
enum __anonenum_154___14 {
    FS_DQ_LOOKUPS___14 = 1,
    FS_DQ_DROPS___14 = 2,
    FS_DQ_READS___14 = 3,
    FS_DQ_WRITES___14 = 4,
    FS_DQ_CACHE_HITS___14 = 5,
    FS_DQ_ALLOCATED___14 = 6,
    FS_DQ_FREE___14 = 7,
    FS_DQ_SYNCS___14 = 8,
    FS_DQ_WARNINGS___14 = 9
} ;
enum __anonenum_155___14 {
    DEV_CDROM___14 = 1,
    DEV_HWMON___14 = 2,
    DEV_PARPORT___14 = 3,
    DEV_RAID___14 = 4,
    DEV_MAC_HID___14 = 5,
    DEV_SCSI___14 = 6,
    DEV_IPMI___14 = 7
} ;
enum __anonenum_156___14 {
    DEV_CDROM_INFO___14 = 1,
    DEV_CDROM_AUTOCLOSE___14 = 2,
    DEV_CDROM_AUTOEJECT___14 = 3,
    DEV_CDROM_DEBUG___14 = 4,
    DEV_CDROM_LOCK___14 = 5,
    DEV_CDROM_CHECK_MEDIA___14 = 6
} ;
enum __anonenum_157___14 {
    DEV_PARPORT_DEFAULT___14 = -3
} ;
enum __anonenum_158___14 {
    DEV_RAID_SPEED_LIMIT_MIN___14 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___14 = 2
} ;
enum __anonenum_159___14 {
    DEV_PARPORT_DEFAULT_TIMESLICE___14 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___14 = 2
} ;
enum __anonenum_160___14 {
    DEV_PARPORT_SPINTIME___14 = 1,
    DEV_PARPORT_BASE_ADDR___14 = 2,
    DEV_PARPORT_IRQ___14 = 3,
    DEV_PARPORT_DMA___14 = 4,
    DEV_PARPORT_MODES___14 = 5,
    DEV_PARPORT_DEVICES___14 = 6,
    DEV_PARPORT_AUTOPROBE___14 = 16
} ;
enum __anonenum_161___14 {
    DEV_PARPORT_DEVICES_ACTIVE___14 = -3
} ;
enum __anonenum_162___14 {
    DEV_PARPORT_DEVICE_TIMESLICE___14 = 1
} ;
enum __anonenum_163___14 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___14 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___14 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___14 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___14 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___14 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___14 = 6
} ;
enum __anonenum_164___14 {
    DEV_SCSI_LOGGING_LEVEL___14 = 1
} ;
enum __anonenum_165___14 {
    DEV_IPMI_POWEROFF_POWERCYCLE___14 = 1
} ;
enum __anonenum_166___14 {
    ABI_DEFHANDLER_COFF___14 = 1,
    ABI_DEFHANDLER_ELF___14 = 2,
    ABI_DEFHANDLER_LCALL7___14 = 3,
    ABI_DEFHANDLER_LIBCSO___14 = 4,
    ABI_TRACE___14 = 5,
    ABI_FAKE_UTSNAME___14 = 6
} ;
enum __anonenum_169___14 {
    IOCB_CMD_PREAD___14 = 0,
    IOCB_CMD_PWRITE___14 = 1,
    IOCB_CMD_FSYNC___14 = 2,
    IOCB_CMD_FDSYNC___14 = 3,
    IOCB_CMD_NOOP___14 = 6,
    IOCB_CMD_PREADV___14 = 7,
    IOCB_CMD_PWRITEV___14 = 8
} ;
enum __anonenum_172___14 {
    IRQTF_RUNTHREAD___14 = 0,
    IRQTF_DIED___14 = 1,
    IRQTF_WARNED___14 = 2
} ;
enum __anonenum_173___11 {
    HI_SOFTIRQ___14 = 0,
    TIMER_SOFTIRQ___14 = 1,
    NET_TX_SOFTIRQ___14 = 2,
    NET_RX_SOFTIRQ___14 = 3,
    BLOCK_SOFTIRQ___14 = 4,
    TASKLET_SOFTIRQ___14 = 5,
    SCHED_SOFTIRQ___14 = 6,
    HRTIMER_SOFTIRQ___14 = 7,
    RCU_SOFTIRQ___14 = 8,
    NR_SOFTIRQS___14 = 9
} ;
enum __anonenum_174___9 {
    TASKLET_STATE_SCHED___14 = 0,
    TASKLET_STATE_RUN___14 = 1
} ;
enum __anonenum_183___10 {
    QIF_BLIMITS_B___14 = 0,
    QIF_SPACE_B___14 = 1,
    QIF_ILIMITS_B___14 = 2,
    QIF_INODES_B___14 = 3,
    QIF_BTIME_B___14 = 4,
    QIF_ITIME_B___14 = 5
} ;
enum __anonenum_184___12 {
    QUOTA_NL_C_UNSPEC___14 = 0,
    QUOTA_NL_C_WARNING___14 = 1,
    __QUOTA_NL_C_MAX___14 = 2
} ;
enum __anonenum_185___12 {
    QUOTA_NL_A_UNSPEC___14 = 0,
    QUOTA_NL_A_QTYPE___14 = 1,
    QUOTA_NL_A_EXCESS_ID___14 = 2,
    QUOTA_NL_A_WARNING___14 = 3,
    QUOTA_NL_A_DEV_MAJOR___14 = 4,
    QUOTA_NL_A_DEV_MINOR___14 = 5,
    QUOTA_NL_A_CAUSED_ID___14 = 6,
    __QUOTA_NL_A_MAX___14 = 7
} ;
enum __anonenum_186___12 {
    _DQUOT_USAGE_ENABLED___14 = 0,
    _DQUOT_LIMITS_ENABLED___14 = 1,
    _DQUOT_SUSPENDED___14 = 2,
    _DQUOT_STATE_FLAGS___14 = 3
} ;
enum __anonenum_193___11 {
    SB_UNFROZEN___14 = 0,
    SB_FREEZE_WRITE___14 = 1,
    SB_FREEZE_TRANS___14 = 2
} ;
enum __anonenum_194___13 {
    DIO_LOCKING___14 = 1,
    DIO_NO_LOCKING___14 = 2,
    DIO_OWN_LOCKING___14 = 3
} ;
enum __anonenum_4___15 {
    false___15 = 0,
    true___15 = 1
} ;
enum __anonenum_10___6 {
    DUMP_PREFIX_NONE___15 = 0,
    DUMP_PREFIX_ADDRESS___15 = 1,
    DUMP_PREFIX_OFFSET___15 = 2
} ;
enum __anonenum_15___9 {
    PG_LEVEL_NONE___15 = 0,
    PG_LEVEL_4K___15 = 1,
    PG_LEVEL_2M___15 = 2,
    PG_LEVEL_1G___15 = 3,
    PG_LEVEL_NUM___15 = 4
} ;
enum __anonenum_19___9 {
    GATE_INTERRUPT___15 = 14,
    GATE_TRAP___15 = 15,
    GATE_CALL___15 = 12,
    GATE_TASK___15 = 5
} ;
enum __anonenum_20___11 {
    DESC_TSS___15 = 9,
    DESC_LDT___15 = 2,
    DESCTYPE_S___15 = 16
} ;
enum __anonenum_21___14 {
    ADDR_NO_RANDOMIZE___15 = 262144,
    FDPIC_FUNCPTRS___15 = 524288,
    MMAP_PAGE_ZERO___15 = 1048576,
    ADDR_COMPAT_LAYOUT___15 = 2097152,
    READ_IMPLIES_EXEC___15 = 4194304,
    ADDR_LIMIT_32BIT___15 = 8388608,
    SHORT_INODE___15 = 16777216,
    WHOLE_SECONDS___15 = 33554432,
    STICKY_TIMEOUTS___15 = 67108864,
    ADDR_LIMIT_3GB___15 = 134217728
} ;
enum __anonenum_22___10 {
    PER_LINUX___15 = 0,
    PER_LINUX_32BIT___15 = 8388608,
    PER_LINUX_FDPIC___15 = 524288,
    PER_SVR4___15 = 68157441,
    PER_SVR3___15 = 83886082,
    PER_SCOSVR3___15 = 117440515,
    PER_OSR5___15 = 100663299,
    PER_WYSEV386___15 = 83886084,
    PER_ISCR4___15 = 67108869,
    PER_BSD___15 = 6,
    PER_SUNOS___15 = 67108870,
    PER_XENIX___15 = 83886087,
    PER_LINUX32___15 = 8,
    PER_LINUX32_3GB___15 = 134217736,
    PER_IRIX32___15 = 67108873,
    PER_IRIXN32___15 = 67108874,
    PER_IRIX64___15 = 67108875,
    PER_RISCOS___15 = 12,
    PER_SOLARIS___15 = 67108877,
    PER_UW7___15 = 68157454,
    PER_OSF4___15 = 15,
    PER_HPUX___15 = 16,
    PER_MASK___15 = 255
} ;
union __anonunion_d_37___6 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_120___10 {
    CTL_KERN___15 = 1,
    CTL_VM___15 = 2,
    CTL_NET___15 = 3,
    CTL_PROC___15 = 4,
    CTL_FS___15 = 5,
    CTL_DEBUG___15 = 6,
    CTL_DEV___15 = 7,
    CTL_BUS___15 = 8,
    CTL_ABI___15 = 9,
    CTL_CPU___15 = 10,
    CTL_ARLAN___15 = 254,
    CTL_S390DBF___15 = 5677,
    CTL_SUNRPC___15 = 7249,
    CTL_PM___15 = 9899,
    CTL_FRV___15 = 9898
} ;
enum __anonenum_121___12 {
    CTL_BUS_ISA___15 = 1
} ;
enum __anonenum_122___12 {
    INOTIFY_MAX_USER_INSTANCES___15 = 1,
    INOTIFY_MAX_USER_WATCHES___15 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___15 = 3
} ;
enum __anonenum_123___12 {
    KERN_OSTYPE___15 = 1,
    KERN_OSRELEASE___15 = 2,
    KERN_OSREV___15 = 3,
    KERN_VERSION___15 = 4,
    KERN_SECUREMASK___15 = 5,
    KERN_PROF___15 = 6,
    KERN_NODENAME___15 = 7,
    KERN_DOMAINNAME___15 = 8,
    KERN_PANIC___15 = 15,
    KERN_REALROOTDEV___15 = 16,
    KERN_SPARC_REBOOT___15 = 21,
    KERN_CTLALTDEL___15 = 22,
    KERN_PRINTK___15 = 23,
    KERN_NAMETRANS___15 = 24,
    KERN_PPC_HTABRECLAIM___15 = 25,
    KERN_PPC_ZEROPAGED___15 = 26,
    KERN_PPC_POWERSAVE_NAP___15 = 27,
    KERN_MODPROBE___15 = 28,
    KERN_SG_BIG_BUFF___15 = 29,
    KERN_ACCT___15 = 30,
    KERN_PPC_L2CR___15 = 31,
    KERN_RTSIGNR___15 = 32,
    KERN_RTSIGMAX___15 = 33,
    KERN_SHMMAX___15 = 34,
    KERN_MSGMAX___15 = 35,
    KERN_MSGMNB___15 = 36,
    KERN_MSGPOOL___15 = 37,
    KERN_SYSRQ___15 = 38,
    KERN_MAX_THREADS___15 = 39,
    KERN_RANDOM___15 = 40,
    KERN_SHMALL___15 = 41,
    KERN_MSGMNI___15 = 42,
    KERN_SEM___15 = 43,
    KERN_SPARC_STOP_A___15 = 44,
    KERN_SHMMNI___15 = 45,
    KERN_OVERFLOWUID___15 = 46,
    KERN_OVERFLOWGID___15 = 47,
    KERN_SHMPATH___15 = 48,
    KERN_HOTPLUG___15 = 49,
    KERN_IEEE_EMULATION_WARNINGS___15 = 50,
    KERN_S390_USER_DEBUG_LOGGING___15 = 51,
    KERN_CORE_USES_PID___15 = 52,
    KERN_TAINTED___15 = 53,
    KERN_CADPID___15 = 54,
    KERN_PIDMAX___15 = 55,
    KERN_CORE_PATTERN___15 = 56,
    KERN_PANIC_ON_OOPS___15 = 57,
    KERN_HPPA_PWRSW___15 = 58,
    KERN_HPPA_UNALIGNED___15 = 59,
    KERN_PRINTK_RATELIMIT___15 = 60,
    KERN_PRINTK_RATELIMIT_BURST___15 = 61,
    KERN_PTY___15 = 62,
    KERN_NGROUPS_MAX___15 = 63,
    KERN_SPARC_SCONS_PWROFF___15 = 64,
    KERN_HZ_TIMER___15 = 65,
    KERN_UNKNOWN_NMI_PANIC___15 = 66,
    KERN_BOOTLOADER_TYPE___15 = 67,
    KERN_RANDOMIZE___15 = 68,
    KERN_SETUID_DUMPABLE___15 = 69,
    KERN_SPIN_RETRY___15 = 70,
    KERN_ACPI_VIDEO_FLAGS___15 = 71,
    KERN_IA64_UNALIGNED___15 = 72,
    KERN_COMPAT_LOG___15 = 73,
    KERN_MAX_LOCK_DEPTH___15 = 74,
    KERN_NMI_WATCHDOG___15 = 75,
    KERN_PANIC_ON_NMI___15 = 76
} ;
enum __anonenum_124___12 {
    VM_UNUSED1___15 = 1,
    VM_UNUSED2___15 = 2,
    VM_UNUSED3___15 = 3,
    VM_UNUSED4___15 = 4,
    VM_OVERCOMMIT_MEMORY___15 = 5,
    VM_UNUSED5___15 = 6,
    VM_UNUSED7___15 = 7,
    VM_UNUSED8___15 = 8,
    VM_UNUSED9___15 = 9,
    VM_PAGE_CLUSTER___15 = 10,
    VM_DIRTY_BACKGROUND___15 = 11,
    VM_DIRTY_RATIO___15 = 12,
    VM_DIRTY_WB_CS___15 = 13,
    VM_DIRTY_EXPIRE_CS___15 = 14,
    VM_NR_PDFLUSH_THREADS___15 = 15,
    VM_OVERCOMMIT_RATIO___15 = 16,
    VM_PAGEBUF___15 = 17,
    VM_HUGETLB_PAGES___15 = 18,
    VM_SWAPPINESS___15 = 19,
    VM_LOWMEM_RESERVE_RATIO___15 = 20,
    VM_MIN_FREE_KBYTES___15 = 21,
    VM_MAX_MAP_COUNT___15 = 22,
    VM_LAPTOP_MODE___15 = 23,
    VM_BLOCK_DUMP___15 = 24,
    VM_HUGETLB_GROUP___15 = 25,
    VM_VFS_CACHE_PRESSURE___15 = 26,
    VM_LEGACY_VA_LAYOUT___15 = 27,
    VM_SWAP_TOKEN_TIMEOUT___15 = 28,
    VM_DROP_PAGECACHE___15 = 29,
    VM_PERCPU_PAGELIST_FRACTION___15 = 30,
    VM_ZONE_RECLAIM_MODE___15 = 31,
    VM_MIN_UNMAPPED___15 = 32,
    VM_PANIC_ON_OOM___15 = 33,
    VM_VDSO_ENABLED___15 = 34,
    VM_MIN_SLAB___15 = 35
} ;
enum __anonenum_125___14 {
    NET_CORE___15 = 1,
    NET_ETHER___15 = 2,
    NET_802___15 = 3,
    NET_UNIX___15 = 4,
    NET_IPV4___15 = 5,
    NET_IPX___15 = 6,
    NET_ATALK___15 = 7,
    NET_NETROM___15 = 8,
    NET_AX25___15 = 9,
    NET_BRIDGE___15 = 10,
    NET_ROSE___15 = 11,
    NET_IPV6___15 = 12,
    NET_X25___15 = 13,
    NET_TR___15 = 14,
    NET_DECNET___15 = 15,
    NET_ECONET___15 = 16,
    NET_SCTP___15 = 17,
    NET_LLC___15 = 18,
    NET_NETFILTER___15 = 19,
    NET_DCCP___15 = 20,
    NET_IRDA___15 = 412
} ;
enum __anonenum_126___14 {
    RANDOM_POOLSIZE___15 = 1,
    RANDOM_ENTROPY_COUNT___15 = 2,
    RANDOM_READ_THRESH___15 = 3,
    RANDOM_WRITE_THRESH___15 = 4,
    RANDOM_BOOT_ID___15 = 5,
    RANDOM_UUID___15 = 6
} ;
enum __anonenum_127___14 {
    PTY_MAX___15 = 1,
    PTY_NR___15 = 2
} ;
enum __anonenum_128___14 {
    BUS_ISA_MEM_BASE___15 = 1,
    BUS_ISA_PORT_BASE___15 = 2,
    BUS_ISA_PORT_SHIFT___15 = 3
} ;
enum __anonenum_129___14 {
    NET_CORE_WMEM_MAX___15 = 1,
    NET_CORE_RMEM_MAX___15 = 2,
    NET_CORE_WMEM_DEFAULT___15 = 3,
    NET_CORE_RMEM_DEFAULT___15 = 4,
    NET_CORE_MAX_BACKLOG___15 = 6,
    NET_CORE_FASTROUTE___15 = 7,
    NET_CORE_MSG_COST___15 = 8,
    NET_CORE_MSG_BURST___15 = 9,
    NET_CORE_OPTMEM_MAX___15 = 10,
    NET_CORE_HOT_LIST_LENGTH___15 = 11,
    NET_CORE_DIVERT_VERSION___15 = 12,
    NET_CORE_NO_CONG_THRESH___15 = 13,
    NET_CORE_NO_CONG___15 = 14,
    NET_CORE_LO_CONG___15 = 15,
    NET_CORE_MOD_CONG___15 = 16,
    NET_CORE_DEV_WEIGHT___15 = 17,
    NET_CORE_SOMAXCONN___15 = 18,
    NET_CORE_BUDGET___15 = 19,
    NET_CORE_AEVENT_ETIME___15 = 20,
    NET_CORE_AEVENT_RSEQTH___15 = 21,
    NET_CORE_WARNINGS___15 = 22
} ;
enum __anonenum_130___14 {
    NET_UNIX_DESTROY_DELAY___15 = 1,
    NET_UNIX_DELETE_DELAY___15 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___15 = 3
} ;
enum __anonenum_131___14 {
    NET_NF_CONNTRACK_MAX___15 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___15 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___15 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___15 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___15 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___15 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___15 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___15 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___15 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___15 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___15 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___15 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___15 = 13,
    NET_NF_CONNTRACK_BUCKETS___15 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___15 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___15 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___15 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___15 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___15 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___15 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___15 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___15 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___15 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___15 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___15 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___15 = 26,
    NET_NF_CONNTRACK_COUNT___15 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___15 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___15 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___15 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___15 = 31,
    NET_NF_CONNTRACK_CHECKSUM___15 = 32
} ;
enum __anonenum_132___15 {
    NET_IPV4_FORWARD___15 = 8,
    NET_IPV4_DYNADDR___15 = 9,
    NET_IPV4_CONF___15 = 16,
    NET_IPV4_NEIGH___15 = 17,
    NET_IPV4_ROUTE___15 = 18,
    NET_IPV4_FIB_HASH___15 = 19,
    NET_IPV4_NETFILTER___15 = 20,
    NET_IPV4_TCP_TIMESTAMPS___15 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___15 = 34,
    NET_IPV4_TCP_SACK___15 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___15 = 36,
    NET_IPV4_DEFAULT_TTL___15 = 37,
    NET_IPV4_AUTOCONFIG___15 = 38,
    NET_IPV4_NO_PMTU_DISC___15 = 39,
    NET_IPV4_TCP_SYN_RETRIES___15 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___15 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___15 = 42,
    NET_IPV4_IPFRAG_TIME___15 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___15 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___15 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___15 = 46,
    NET_IPV4_TCP_RETRIES1___15 = 47,
    NET_IPV4_TCP_RETRIES2___15 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___15 = 49,
    NET_IPV4_IP_MASQ_DEBUG___15 = 50,
    NET_TCP_SYNCOOKIES___15 = 51,
    NET_TCP_STDURG___15 = 52,
    NET_TCP_RFC1337___15 = 53,
    NET_TCP_SYN_TAILDROP___15 = 54,
    NET_TCP_MAX_SYN_BACKLOG___15 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___15 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___15 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___15 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___15 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___15 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___15 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___15 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___15 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___15 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___15 = 65,
    NET_TCP_TW_RECYCLE___15 = 66,
    NET_IPV4_ALWAYS_DEFRAG___15 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___15 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___15 = 69,
    NET_IPV4_INET_PEER_MINTTL___15 = 70,
    NET_IPV4_INET_PEER_MAXTTL___15 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___15 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___15 = 73,
    NET_TCP_ORPHAN_RETRIES___15 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___15 = 75,
    NET_TCP_SYNACK_RETRIES___15 = 76,
    NET_TCP_MAX_ORPHANS___15 = 77,
    NET_TCP_MAX_TW_BUCKETS___15 = 78,
    NET_TCP_FACK___15 = 79,
    NET_TCP_REORDERING___15 = 80,
    NET_TCP_ECN___15 = 81,
    NET_TCP_DSACK___15 = 82,
    NET_TCP_MEM___15 = 83,
    NET_TCP_WMEM___15 = 84,
    NET_TCP_RMEM___15 = 85,
    NET_TCP_APP_WIN___15 = 86,
    NET_TCP_ADV_WIN_SCALE___15 = 87,
    NET_IPV4_NONLOCAL_BIND___15 = 88,
    NET_IPV4_ICMP_RATELIMIT___15 = 89,
    NET_IPV4_ICMP_RATEMASK___15 = 90,
    NET_TCP_TW_REUSE___15 = 91,
    NET_TCP_FRTO___15 = 92,
    NET_TCP_LOW_LATENCY___15 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___15 = 94,
    NET_IPV4_IGMP_MAX_MSF___15 = 96,
    NET_TCP_NO_METRICS_SAVE___15 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___15 = 105,
    NET_TCP_MODERATE_RCVBUF___15 = 106,
    NET_TCP_TSO_WIN_DIVISOR___15 = 107,
    NET_TCP_BIC_BETA___15 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___15 = 109,
    NET_TCP_CONG_CONTROL___15 = 110,
    NET_TCP_ABC___15 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___15 = 112,
    NET_TCP_MTU_PROBING___15 = 113,
    NET_TCP_BASE_MSS___15 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___15 = 115,
    NET_TCP_DMA_COPYBREAK___15 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___15 = 117,
    NET_CIPSOV4_CACHE_ENABLE___15 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___15 = 119,
    NET_CIPSOV4_RBM_OPTFMT___15 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___15 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___15 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___15 = 123,
    NET_TCP_MAX_SSTHRESH___15 = 124,
    NET_TCP_FRTO_RESPONSE___15 = 125
} ;
enum __anonenum_133___15 {
    NET_IPV4_ROUTE_FLUSH___15 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___15 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___15 = 3,
    NET_IPV4_ROUTE_GC_THRESH___15 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___15 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___15 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___15 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___15 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___15 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___15 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___15 = 11,
    NET_IPV4_ROUTE_ERROR_COST___15 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___15 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___15 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___15 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___15 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___15 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___15 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___15 = 19
} ;
enum __anonenum_134___15 {
    NET_PROTO_CONF_ALL___15 = -2,
    NET_PROTO_CONF_DEFAULT___15 = -3
} ;
enum __anonenum_135___15 {
    NET_IPV4_CONF_FORWARDING___15 = 1,
    NET_IPV4_CONF_MC_FORWARDING___15 = 2,
    NET_IPV4_CONF_PROXY_ARP___15 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___15 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___15 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___15 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___15 = 7,
    NET_IPV4_CONF_RP_FILTER___15 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___15 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___15 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___15 = 11,
    NET_IPV4_CONF_TAG___15 = 12,
    NET_IPV4_CONF_ARPFILTER___15 = 13,
    NET_IPV4_CONF_MEDIUM_ID___15 = 14,
    NET_IPV4_CONF_NOXFRM___15 = 15,
    NET_IPV4_CONF_NOPOLICY___15 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___15 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___15 = 18,
    NET_IPV4_CONF_ARP_IGNORE___15 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___15 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___15 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___15 = 22,
    __NET_IPV4_CONF_MAX___15 = 23
} ;
enum __anonenum_136___15 {
    NET_IPV4_NF_CONNTRACK_MAX___15 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___15 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___15 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___15 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___15 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___15 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___15 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___15 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___15 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___15 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___15 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___15 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___15 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___15 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___15 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___15 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___15 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___15 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___15 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___15 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___15 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___15 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___15 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___15 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___15 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___15 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___15 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___15 = 28
} ;
enum __anonenum_137___15 {
    NET_IPV6_CONF___15 = 16,
    NET_IPV6_NEIGH___15 = 17,
    NET_IPV6_ROUTE___15 = 18,
    NET_IPV6_ICMP___15 = 19,
    NET_IPV6_BINDV6ONLY___15 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___15 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___15 = 22,
    NET_IPV6_IP6FRAG_TIME___15 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___15 = 24,
    NET_IPV6_MLD_MAX_MSF___15 = 25
} ;
enum __anonenum_138___15 {
    NET_IPV6_ROUTE_FLUSH___15 = 1,
    NET_IPV6_ROUTE_GC_THRESH___15 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___15 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___15 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___15 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___15 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___15 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___15 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___15 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___15 = 10
} ;
enum __anonenum_139___15 {
    NET_IPV6_FORWARDING___15 = 1,
    NET_IPV6_HOP_LIMIT___15 = 2,
    NET_IPV6_MTU___15 = 3,
    NET_IPV6_ACCEPT_RA___15 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___15 = 5,
    NET_IPV6_AUTOCONF___15 = 6,
    NET_IPV6_DAD_TRANSMITS___15 = 7,
    NET_IPV6_RTR_SOLICITS___15 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___15 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___15 = 10,
    NET_IPV6_USE_TEMPADDR___15 = 11,
    NET_IPV6_TEMP_VALID_LFT___15 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___15 = 13,
    NET_IPV6_REGEN_MAX_RETRY___15 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___15 = 15,
    NET_IPV6_MAX_ADDRESSES___15 = 16,
    NET_IPV6_FORCE_MLD_VERSION___15 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___15 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___15 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___15 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___15 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___15 = 22,
    NET_IPV6_PROXY_NDP___15 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___15 = 25,
    __NET_IPV6_MAX___15 = 26
} ;
enum __anonenum_140___15 {
    NET_IPV6_ICMP_RATELIMIT___15 = 1
} ;
enum __anonenum_141___15 {
    NET_NEIGH_MCAST_SOLICIT___15 = 1,
    NET_NEIGH_UCAST_SOLICIT___15 = 2,
    NET_NEIGH_APP_SOLICIT___15 = 3,
    NET_NEIGH_RETRANS_TIME___15 = 4,
    NET_NEIGH_REACHABLE_TIME___15 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___15 = 6,
    NET_NEIGH_GC_STALE_TIME___15 = 7,
    NET_NEIGH_UNRES_QLEN___15 = 8,
    NET_NEIGH_PROXY_QLEN___15 = 9,
    NET_NEIGH_ANYCAST_DELAY___15 = 10,
    NET_NEIGH_PROXY_DELAY___15 = 11,
    NET_NEIGH_LOCKTIME___15 = 12,
    NET_NEIGH_GC_INTERVAL___15 = 13,
    NET_NEIGH_GC_THRESH1___15 = 14,
    NET_NEIGH_GC_THRESH2___15 = 15,
    NET_NEIGH_GC_THRESH3___15 = 16,
    NET_NEIGH_RETRANS_TIME_MS___15 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___15 = 18,
    __NET_NEIGH_MAX___15 = 19
} ;
enum __anonenum_142___15 {
    NET_DCCP_DEFAULT___15 = 1
} ;
enum __anonenum_143___15 {
    NET_IPX_PPROP_BROADCASTING___15 = 1,
    NET_IPX_FORWARDING___15 = 2
} ;
enum __anonenum_144___15 {
    NET_LLC2___15 = 1,
    NET_LLC_STATION___15 = 2
} ;
enum __anonenum_145___15 {
    NET_LLC2_TIMEOUT___15 = 1
} ;
enum __anonenum_146___15 {
    NET_LLC_STATION_ACK_TIMEOUT___15 = 1
} ;
enum __anonenum_147___15 {
    NET_LLC2_ACK_TIMEOUT___15 = 1,
    NET_LLC2_P_TIMEOUT___15 = 2,
    NET_LLC2_REJ_TIMEOUT___15 = 3,
    NET_LLC2_BUSY_TIMEOUT___15 = 4
} ;
enum __anonenum_148___15 {
    NET_ATALK_AARP_EXPIRY_TIME___15 = 1,
    NET_ATALK_AARP_TICK_TIME___15 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___15 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___15 = 4
} ;
enum __anonenum_149___15 {
    NET_NETROM_DEFAULT_PATH_QUALITY___15 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___15 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___15 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___15 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___15 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___15 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___15 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___15 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___15 = 9,
    NET_NETROM_ROUTING_CONTROL___15 = 10,
    NET_NETROM_LINK_FAILS_COUNT___15 = 11,
    NET_NETROM_RESET___15 = 12
} ;
enum __anonenum_150___15 {
    NET_AX25_IP_DEFAULT_MODE___15 = 1,
    NET_AX25_DEFAULT_MODE___15 = 2,
    NET_AX25_BACKOFF_TYPE___15 = 3,
    NET_AX25_CONNECT_MODE___15 = 4,
    NET_AX25_STANDARD_WINDOW___15 = 5,
    NET_AX25_EXTENDED_WINDOW___15 = 6,
    NET_AX25_T1_TIMEOUT___15 = 7,
    NET_AX25_T2_TIMEOUT___15 = 8,
    NET_AX25_T3_TIMEOUT___15 = 9,
    NET_AX25_IDLE_TIMEOUT___15 = 10,
    NET_AX25_N2___15 = 11,
    NET_AX25_PACLEN___15 = 12,
    NET_AX25_PROTOCOL___15 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___15 = 14
} ;
enum __anonenum_151___15 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___15 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___15 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___15 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___15 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___15 = 5,
    NET_ROSE_ROUTING_CONTROL___15 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___15 = 7,
    NET_ROSE_MAX_VCS___15 = 8,
    NET_ROSE_WINDOW_SIZE___15 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___15 = 10
} ;
enum __anonenum_152___15 {
    NET_X25_RESTART_REQUEST_TIMEOUT___15 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___15 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___15 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___15 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___15 = 5,
    NET_X25_FORWARD___15 = 6
} ;
enum __anonenum_153___15 {
    NET_TR_RIF_TIMEOUT___15 = 1
} ;
enum __anonenum_154___15 {
    NET_DECNET_NODE_TYPE___15 = 1,
    NET_DECNET_NODE_ADDRESS___15 = 2,
    NET_DECNET_NODE_NAME___15 = 3,
    NET_DECNET_DEFAULT_DEVICE___15 = 4,
    NET_DECNET_TIME_WAIT___15 = 5,
    NET_DECNET_DN_COUNT___15 = 6,
    NET_DECNET_DI_COUNT___15 = 7,
    NET_DECNET_DR_COUNT___15 = 8,
    NET_DECNET_DST_GC_INTERVAL___15 = 9,
    NET_DECNET_CONF___15 = 10,
    NET_DECNET_NO_FC_MAX_CWND___15 = 11,
    NET_DECNET_MEM___15 = 12,
    NET_DECNET_RMEM___15 = 13,
    NET_DECNET_WMEM___15 = 14,
    NET_DECNET_DEBUG_LEVEL___15 = 255
} ;
enum __anonenum_155___15 {
    NET_DECNET_CONF_LOOPBACK___15 = -2,
    NET_DECNET_CONF_DDCMP___15 = -3,
    NET_DECNET_CONF_PPP___15 = -4,
    NET_DECNET_CONF_X25___15 = -5,
    NET_DECNET_CONF_GRE___15 = -6,
    NET_DECNET_CONF_ETHER___15 = -7
} ;
enum __anonenum_156___15 {
    NET_DECNET_CONF_DEV_PRIORITY___15 = 1,
    NET_DECNET_CONF_DEV_T1___15 = 2,
    NET_DECNET_CONF_DEV_T2___15 = 3,
    NET_DECNET_CONF_DEV_T3___15 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___15 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___15 = 6,
    NET_DECNET_CONF_DEV_STATE___15 = 7
} ;
enum __anonenum_157___15 {
    NET_SCTP_RTO_INITIAL___15 = 1,
    NET_SCTP_RTO_MIN___15 = 2,
    NET_SCTP_RTO_MAX___15 = 3,
    NET_SCTP_RTO_ALPHA___15 = 4,
    NET_SCTP_RTO_BETA___15 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___15 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___15 = 7,
    NET_SCTP_PATH_MAX_RETRANS___15 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___15 = 9,
    NET_SCTP_HB_INTERVAL___15 = 10,
    NET_SCTP_PRESERVE_ENABLE___15 = 11,
    NET_SCTP_MAX_BURST___15 = 12,
    NET_SCTP_ADDIP_ENABLE___15 = 13,
    NET_SCTP_PRSCTP_ENABLE___15 = 14,
    NET_SCTP_SNDBUF_POLICY___15 = 15,
    NET_SCTP_SACK_TIMEOUT___15 = 16,
    NET_SCTP_RCVBUF_POLICY___15 = 17
} ;
enum __anonenum_158___15 {
    NET_BRIDGE_NF_CALL_ARPTABLES___15 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___15 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___15 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___15 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___15 = 5
} ;
enum __anonenum_159___15 {
    NET_IRDA_DISCOVERY___15 = 1,
    NET_IRDA_DEVNAME___15 = 2,
    NET_IRDA_DEBUG___15 = 3,
    NET_IRDA_FAST_POLL___15 = 4,
    NET_IRDA_DISCOVERY_SLOTS___15 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___15 = 6,
    NET_IRDA_SLOT_TIMEOUT___15 = 7,
    NET_IRDA_MAX_BAUD_RATE___15 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___15 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___15 = 10,
    NET_IRDA_MAX_TX_WINDOW___15 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___15 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___15 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___15 = 14
} ;
enum __anonenum_160___15 {
    FS_NRINODE___15 = 1,
    FS_STATINODE___15 = 2,
    FS_MAXINODE___15 = 3,
    FS_NRDQUOT___15 = 4,
    FS_MAXDQUOT___15 = 5,
    FS_NRFILE___15 = 6,
    FS_MAXFILE___15 = 7,
    FS_DENTRY___15 = 8,
    FS_NRSUPER___15 = 9,
    FS_MAXSUPER___15 = 10,
    FS_OVERFLOWUID___15 = 11,
    FS_OVERFLOWGID___15 = 12,
    FS_LEASES___15 = 13,
    FS_DIR_NOTIFY___15 = 14,
    FS_LEASE_TIME___15 = 15,
    FS_DQSTATS___15 = 16,
    FS_XFS___15 = 17,
    FS_AIO_NR___15 = 18,
    FS_AIO_MAX_NR___15 = 19,
    FS_INOTIFY___15 = 20,
    FS_OCFS2___15 = 988
} ;
enum __anonenum_161___15 {
    FS_DQ_LOOKUPS___15 = 1,
    FS_DQ_DROPS___15 = 2,
    FS_DQ_READS___15 = 3,
    FS_DQ_WRITES___15 = 4,
    FS_DQ_CACHE_HITS___15 = 5,
    FS_DQ_ALLOCATED___15 = 6,
    FS_DQ_FREE___15 = 7,
    FS_DQ_SYNCS___15 = 8,
    FS_DQ_WARNINGS___15 = 9
} ;
enum __anonenum_162___15 {
    DEV_CDROM___15 = 1,
    DEV_HWMON___15 = 2,
    DEV_PARPORT___15 = 3,
    DEV_RAID___15 = 4,
    DEV_MAC_HID___15 = 5,
    DEV_SCSI___15 = 6,
    DEV_IPMI___15 = 7
} ;
enum __anonenum_163___15 {
    DEV_CDROM_INFO___15 = 1,
    DEV_CDROM_AUTOCLOSE___15 = 2,
    DEV_CDROM_AUTOEJECT___15 = 3,
    DEV_CDROM_DEBUG___15 = 4,
    DEV_CDROM_LOCK___15 = 5,
    DEV_CDROM_CHECK_MEDIA___15 = 6
} ;
enum __anonenum_164___15 {
    DEV_PARPORT_DEFAULT___15 = -3
} ;
enum __anonenum_165___15 {
    DEV_RAID_SPEED_LIMIT_MIN___15 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___15 = 2
} ;
enum __anonenum_166___15 {
    DEV_PARPORT_DEFAULT_TIMESLICE___15 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___15 = 2
} ;
enum __anonenum_167___9 {
    DEV_PARPORT_SPINTIME___15 = 1,
    DEV_PARPORT_BASE_ADDR___15 = 2,
    DEV_PARPORT_IRQ___15 = 3,
    DEV_PARPORT_DMA___15 = 4,
    DEV_PARPORT_MODES___15 = 5,
    DEV_PARPORT_DEVICES___15 = 6,
    DEV_PARPORT_AUTOPROBE___15 = 16
} ;
enum __anonenum_168___9 {
    DEV_PARPORT_DEVICES_ACTIVE___15 = -3
} ;
enum __anonenum_169___15 {
    DEV_PARPORT_DEVICE_TIMESLICE___15 = 1
} ;
enum __anonenum_170___9 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___15 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___15 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___15 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___15 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___15 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___15 = 6
} ;
enum __anonenum_171___9 {
    DEV_SCSI_LOGGING_LEVEL___15 = 1
} ;
enum __anonenum_172___15 {
    DEV_IPMI_POWEROFF_POWERCYCLE___15 = 1
} ;
enum __anonenum_173___12 {
    ABI_DEFHANDLER_COFF___15 = 1,
    ABI_DEFHANDLER_ELF___15 = 2,
    ABI_DEFHANDLER_LCALL7___15 = 3,
    ABI_DEFHANDLER_LIBCSO___15 = 4,
    ABI_TRACE___15 = 5,
    ABI_FAKE_UTSNAME___15 = 6
} ;
enum __anonenum_176___4 {
    IOCB_CMD_PREAD___15 = 0,
    IOCB_CMD_PWRITE___15 = 1,
    IOCB_CMD_FSYNC___15 = 2,
    IOCB_CMD_FDSYNC___15 = 3,
    IOCB_CMD_NOOP___15 = 6,
    IOCB_CMD_PREADV___15 = 7,
    IOCB_CMD_PWRITEV___15 = 8
} ;
enum __anonenum_179___5 {
    IRQTF_RUNTHREAD___15 = 0,
    IRQTF_DIED___15 = 1,
    IRQTF_WARNED___15 = 2
} ;
enum __anonenum_180___7 {
    HI_SOFTIRQ___15 = 0,
    TIMER_SOFTIRQ___15 = 1,
    NET_TX_SOFTIRQ___15 = 2,
    NET_RX_SOFTIRQ___15 = 3,
    BLOCK_SOFTIRQ___15 = 4,
    TASKLET_SOFTIRQ___15 = 5,
    SCHED_SOFTIRQ___15 = 6,
    HRTIMER_SOFTIRQ___15 = 7,
    RCU_SOFTIRQ___15 = 8,
    NR_SOFTIRQS___15 = 9
} ;
enum __anonenum_181___9 {
    TASKLET_STATE_SCHED___15 = 0,
    TASKLET_STATE_RUN___15 = 1
} ;
enum __anonenum_183___11 {
    QIF_BLIMITS_B___15 = 0,
    QIF_SPACE_B___15 = 1,
    QIF_ILIMITS_B___15 = 2,
    QIF_INODES_B___15 = 3,
    QIF_BTIME_B___15 = 4,
    QIF_ITIME_B___15 = 5
} ;
enum __anonenum_184___13 {
    QUOTA_NL_C_UNSPEC___15 = 0,
    QUOTA_NL_C_WARNING___15 = 1,
    __QUOTA_NL_C_MAX___15 = 2
} ;
enum __anonenum_185___13 {
    QUOTA_NL_A_UNSPEC___15 = 0,
    QUOTA_NL_A_QTYPE___15 = 1,
    QUOTA_NL_A_EXCESS_ID___15 = 2,
    QUOTA_NL_A_WARNING___15 = 3,
    QUOTA_NL_A_DEV_MAJOR___15 = 4,
    QUOTA_NL_A_DEV_MINOR___15 = 5,
    QUOTA_NL_A_CAUSED_ID___15 = 6,
    __QUOTA_NL_A_MAX___15 = 7
} ;
enum __anonenum_186___13 {
    _DQUOT_USAGE_ENABLED___15 = 0,
    _DQUOT_LIMITS_ENABLED___15 = 1,
    _DQUOT_SUSPENDED___15 = 2,
    _DQUOT_STATE_FLAGS___15 = 3
} ;
enum __anonenum_193___12 {
    SB_UNFROZEN___15 = 0,
    SB_FREEZE_WRITE___15 = 1,
    SB_FREEZE_TRANS___15 = 2
} ;
enum __anonenum_194___14 {
    DIO_LOCKING___15 = 1,
    DIO_NO_LOCKING___15 = 2,
    DIO_OWN_LOCKING___15 = 3
} ;
enum __anonenum_4___16 {
    false___16 = 0,
    true___16 = 1
} ;
enum __anonenum_10___7 {
    DUMP_PREFIX_NONE___16 = 0,
    DUMP_PREFIX_ADDRESS___16 = 1,
    DUMP_PREFIX_OFFSET___16 = 2
} ;
enum __anonenum_15___10 {
    PG_LEVEL_NONE___16 = 0,
    PG_LEVEL_4K___16 = 1,
    PG_LEVEL_2M___16 = 2,
    PG_LEVEL_1G___16 = 3,
    PG_LEVEL_NUM___16 = 4
} ;
enum __anonenum_19___10 {
    GATE_INTERRUPT___16 = 14,
    GATE_TRAP___16 = 15,
    GATE_CALL___16 = 12,
    GATE_TASK___16 = 5
} ;
enum __anonenum_20___12 {
    DESC_TSS___16 = 9,
    DESC_LDT___16 = 2,
    DESCTYPE_S___16 = 16
} ;
enum __anonenum_21___15 {
    ADDR_NO_RANDOMIZE___16 = 262144,
    FDPIC_FUNCPTRS___16 = 524288,
    MMAP_PAGE_ZERO___16 = 1048576,
    ADDR_COMPAT_LAYOUT___16 = 2097152,
    READ_IMPLIES_EXEC___16 = 4194304,
    ADDR_LIMIT_32BIT___16 = 8388608,
    SHORT_INODE___16 = 16777216,
    WHOLE_SECONDS___16 = 33554432,
    STICKY_TIMEOUTS___16 = 67108864,
    ADDR_LIMIT_3GB___16 = 134217728
} ;
enum __anonenum_22___11 {
    PER_LINUX___16 = 0,
    PER_LINUX_32BIT___16 = 8388608,
    PER_LINUX_FDPIC___16 = 524288,
    PER_SVR4___16 = 68157441,
    PER_SVR3___16 = 83886082,
    PER_SCOSVR3___16 = 117440515,
    PER_OSR5___16 = 100663299,
    PER_WYSEV386___16 = 83886084,
    PER_ISCR4___16 = 67108869,
    PER_BSD___16 = 6,
    PER_SUNOS___16 = 67108870,
    PER_XENIX___16 = 83886087,
    PER_LINUX32___16 = 8,
    PER_LINUX32_3GB___16 = 134217736,
    PER_IRIX32___16 = 67108873,
    PER_IRIXN32___16 = 67108874,
    PER_IRIX64___16 = 67108875,
    PER_RISCOS___16 = 12,
    PER_SOLARIS___16 = 67108877,
    PER_UW7___16 = 68157454,
    PER_OSF4___16 = 15,
    PER_HPUX___16 = 16,
    PER_MASK___16 = 255
} ;
union __anonunion_d_37___7 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_119___8 {
    CTL_KERN___16 = 1,
    CTL_VM___16 = 2,
    CTL_NET___16 = 3,
    CTL_PROC___16 = 4,
    CTL_FS___16 = 5,
    CTL_DEBUG___16 = 6,
    CTL_DEV___16 = 7,
    CTL_BUS___16 = 8,
    CTL_ABI___16 = 9,
    CTL_CPU___16 = 10,
    CTL_ARLAN___16 = 254,
    CTL_S390DBF___16 = 5677,
    CTL_SUNRPC___16 = 7249,
    CTL_PM___16 = 9899,
    CTL_FRV___16 = 9898
} ;
enum __anonenum_120___11 {
    CTL_BUS_ISA___16 = 1
} ;
enum __anonenum_121___13 {
    INOTIFY_MAX_USER_INSTANCES___16 = 1,
    INOTIFY_MAX_USER_WATCHES___16 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___16 = 3
} ;
enum __anonenum_122___13 {
    KERN_OSTYPE___16 = 1,
    KERN_OSRELEASE___16 = 2,
    KERN_OSREV___16 = 3,
    KERN_VERSION___16 = 4,
    KERN_SECUREMASK___16 = 5,
    KERN_PROF___16 = 6,
    KERN_NODENAME___16 = 7,
    KERN_DOMAINNAME___16 = 8,
    KERN_PANIC___16 = 15,
    KERN_REALROOTDEV___16 = 16,
    KERN_SPARC_REBOOT___16 = 21,
    KERN_CTLALTDEL___16 = 22,
    KERN_PRINTK___16 = 23,
    KERN_NAMETRANS___16 = 24,
    KERN_PPC_HTABRECLAIM___16 = 25,
    KERN_PPC_ZEROPAGED___16 = 26,
    KERN_PPC_POWERSAVE_NAP___16 = 27,
    KERN_MODPROBE___16 = 28,
    KERN_SG_BIG_BUFF___16 = 29,
    KERN_ACCT___16 = 30,
    KERN_PPC_L2CR___16 = 31,
    KERN_RTSIGNR___16 = 32,
    KERN_RTSIGMAX___16 = 33,
    KERN_SHMMAX___16 = 34,
    KERN_MSGMAX___16 = 35,
    KERN_MSGMNB___16 = 36,
    KERN_MSGPOOL___16 = 37,
    KERN_SYSRQ___16 = 38,
    KERN_MAX_THREADS___16 = 39,
    KERN_RANDOM___16 = 40,
    KERN_SHMALL___16 = 41,
    KERN_MSGMNI___16 = 42,
    KERN_SEM___16 = 43,
    KERN_SPARC_STOP_A___16 = 44,
    KERN_SHMMNI___16 = 45,
    KERN_OVERFLOWUID___16 = 46,
    KERN_OVERFLOWGID___16 = 47,
    KERN_SHMPATH___16 = 48,
    KERN_HOTPLUG___16 = 49,
    KERN_IEEE_EMULATION_WARNINGS___16 = 50,
    KERN_S390_USER_DEBUG_LOGGING___16 = 51,
    KERN_CORE_USES_PID___16 = 52,
    KERN_TAINTED___16 = 53,
    KERN_CADPID___16 = 54,
    KERN_PIDMAX___16 = 55,
    KERN_CORE_PATTERN___16 = 56,
    KERN_PANIC_ON_OOPS___16 = 57,
    KERN_HPPA_PWRSW___16 = 58,
    KERN_HPPA_UNALIGNED___16 = 59,
    KERN_PRINTK_RATELIMIT___16 = 60,
    KERN_PRINTK_RATELIMIT_BURST___16 = 61,
    KERN_PTY___16 = 62,
    KERN_NGROUPS_MAX___16 = 63,
    KERN_SPARC_SCONS_PWROFF___16 = 64,
    KERN_HZ_TIMER___16 = 65,
    KERN_UNKNOWN_NMI_PANIC___16 = 66,
    KERN_BOOTLOADER_TYPE___16 = 67,
    KERN_RANDOMIZE___16 = 68,
    KERN_SETUID_DUMPABLE___16 = 69,
    KERN_SPIN_RETRY___16 = 70,
    KERN_ACPI_VIDEO_FLAGS___16 = 71,
    KERN_IA64_UNALIGNED___16 = 72,
    KERN_COMPAT_LOG___16 = 73,
    KERN_MAX_LOCK_DEPTH___16 = 74,
    KERN_NMI_WATCHDOG___16 = 75,
    KERN_PANIC_ON_NMI___16 = 76
} ;
enum __anonenum_123___13 {
    VM_UNUSED1___16 = 1,
    VM_UNUSED2___16 = 2,
    VM_UNUSED3___16 = 3,
    VM_UNUSED4___16 = 4,
    VM_OVERCOMMIT_MEMORY___16 = 5,
    VM_UNUSED5___16 = 6,
    VM_UNUSED7___16 = 7,
    VM_UNUSED8___16 = 8,
    VM_UNUSED9___16 = 9,
    VM_PAGE_CLUSTER___16 = 10,
    VM_DIRTY_BACKGROUND___16 = 11,
    VM_DIRTY_RATIO___16 = 12,
    VM_DIRTY_WB_CS___16 = 13,
    VM_DIRTY_EXPIRE_CS___16 = 14,
    VM_NR_PDFLUSH_THREADS___16 = 15,
    VM_OVERCOMMIT_RATIO___16 = 16,
    VM_PAGEBUF___16 = 17,
    VM_HUGETLB_PAGES___16 = 18,
    VM_SWAPPINESS___16 = 19,
    VM_LOWMEM_RESERVE_RATIO___16 = 20,
    VM_MIN_FREE_KBYTES___16 = 21,
    VM_MAX_MAP_COUNT___16 = 22,
    VM_LAPTOP_MODE___16 = 23,
    VM_BLOCK_DUMP___16 = 24,
    VM_HUGETLB_GROUP___16 = 25,
    VM_VFS_CACHE_PRESSURE___16 = 26,
    VM_LEGACY_VA_LAYOUT___16 = 27,
    VM_SWAP_TOKEN_TIMEOUT___16 = 28,
    VM_DROP_PAGECACHE___16 = 29,
    VM_PERCPU_PAGELIST_FRACTION___16 = 30,
    VM_ZONE_RECLAIM_MODE___16 = 31,
    VM_MIN_UNMAPPED___16 = 32,
    VM_PANIC_ON_OOM___16 = 33,
    VM_VDSO_ENABLED___16 = 34,
    VM_MIN_SLAB___16 = 35
} ;
enum __anonenum_124___13 {
    NET_CORE___16 = 1,
    NET_ETHER___16 = 2,
    NET_802___16 = 3,
    NET_UNIX___16 = 4,
    NET_IPV4___16 = 5,
    NET_IPX___16 = 6,
    NET_ATALK___16 = 7,
    NET_NETROM___16 = 8,
    NET_AX25___16 = 9,
    NET_BRIDGE___16 = 10,
    NET_ROSE___16 = 11,
    NET_IPV6___16 = 12,
    NET_X25___16 = 13,
    NET_TR___16 = 14,
    NET_DECNET___16 = 15,
    NET_ECONET___16 = 16,
    NET_SCTP___16 = 17,
    NET_LLC___16 = 18,
    NET_NETFILTER___16 = 19,
    NET_DCCP___16 = 20,
    NET_IRDA___16 = 412
} ;
enum __anonenum_125___15 {
    RANDOM_POOLSIZE___16 = 1,
    RANDOM_ENTROPY_COUNT___16 = 2,
    RANDOM_READ_THRESH___16 = 3,
    RANDOM_WRITE_THRESH___16 = 4,
    RANDOM_BOOT_ID___16 = 5,
    RANDOM_UUID___16 = 6
} ;
enum __anonenum_126___15 {
    PTY_MAX___16 = 1,
    PTY_NR___16 = 2
} ;
enum __anonenum_127___15 {
    BUS_ISA_MEM_BASE___16 = 1,
    BUS_ISA_PORT_BASE___16 = 2,
    BUS_ISA_PORT_SHIFT___16 = 3
} ;
enum __anonenum_128___15 {
    NET_CORE_WMEM_MAX___16 = 1,
    NET_CORE_RMEM_MAX___16 = 2,
    NET_CORE_WMEM_DEFAULT___16 = 3,
    NET_CORE_RMEM_DEFAULT___16 = 4,
    NET_CORE_MAX_BACKLOG___16 = 6,
    NET_CORE_FASTROUTE___16 = 7,
    NET_CORE_MSG_COST___16 = 8,
    NET_CORE_MSG_BURST___16 = 9,
    NET_CORE_OPTMEM_MAX___16 = 10,
    NET_CORE_HOT_LIST_LENGTH___16 = 11,
    NET_CORE_DIVERT_VERSION___16 = 12,
    NET_CORE_NO_CONG_THRESH___16 = 13,
    NET_CORE_NO_CONG___16 = 14,
    NET_CORE_LO_CONG___16 = 15,
    NET_CORE_MOD_CONG___16 = 16,
    NET_CORE_DEV_WEIGHT___16 = 17,
    NET_CORE_SOMAXCONN___16 = 18,
    NET_CORE_BUDGET___16 = 19,
    NET_CORE_AEVENT_ETIME___16 = 20,
    NET_CORE_AEVENT_RSEQTH___16 = 21,
    NET_CORE_WARNINGS___16 = 22
} ;
enum __anonenum_129___15 {
    NET_UNIX_DESTROY_DELAY___16 = 1,
    NET_UNIX_DELETE_DELAY___16 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___16 = 3
} ;
enum __anonenum_130___15 {
    NET_NF_CONNTRACK_MAX___16 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___16 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___16 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___16 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___16 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___16 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___16 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___16 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___16 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___16 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___16 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___16 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___16 = 13,
    NET_NF_CONNTRACK_BUCKETS___16 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___16 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___16 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___16 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___16 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___16 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___16 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___16 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___16 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___16 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___16 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___16 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___16 = 26,
    NET_NF_CONNTRACK_COUNT___16 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___16 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___16 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___16 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___16 = 31,
    NET_NF_CONNTRACK_CHECKSUM___16 = 32
} ;
enum __anonenum_131___15 {
    NET_IPV4_FORWARD___16 = 8,
    NET_IPV4_DYNADDR___16 = 9,
    NET_IPV4_CONF___16 = 16,
    NET_IPV4_NEIGH___16 = 17,
    NET_IPV4_ROUTE___16 = 18,
    NET_IPV4_FIB_HASH___16 = 19,
    NET_IPV4_NETFILTER___16 = 20,
    NET_IPV4_TCP_TIMESTAMPS___16 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___16 = 34,
    NET_IPV4_TCP_SACK___16 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___16 = 36,
    NET_IPV4_DEFAULT_TTL___16 = 37,
    NET_IPV4_AUTOCONFIG___16 = 38,
    NET_IPV4_NO_PMTU_DISC___16 = 39,
    NET_IPV4_TCP_SYN_RETRIES___16 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___16 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___16 = 42,
    NET_IPV4_IPFRAG_TIME___16 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___16 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___16 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___16 = 46,
    NET_IPV4_TCP_RETRIES1___16 = 47,
    NET_IPV4_TCP_RETRIES2___16 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___16 = 49,
    NET_IPV4_IP_MASQ_DEBUG___16 = 50,
    NET_TCP_SYNCOOKIES___16 = 51,
    NET_TCP_STDURG___16 = 52,
    NET_TCP_RFC1337___16 = 53,
    NET_TCP_SYN_TAILDROP___16 = 54,
    NET_TCP_MAX_SYN_BACKLOG___16 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___16 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___16 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___16 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___16 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___16 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___16 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___16 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___16 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___16 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___16 = 65,
    NET_TCP_TW_RECYCLE___16 = 66,
    NET_IPV4_ALWAYS_DEFRAG___16 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___16 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___16 = 69,
    NET_IPV4_INET_PEER_MINTTL___16 = 70,
    NET_IPV4_INET_PEER_MAXTTL___16 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___16 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___16 = 73,
    NET_TCP_ORPHAN_RETRIES___16 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___16 = 75,
    NET_TCP_SYNACK_RETRIES___16 = 76,
    NET_TCP_MAX_ORPHANS___16 = 77,
    NET_TCP_MAX_TW_BUCKETS___16 = 78,
    NET_TCP_FACK___16 = 79,
    NET_TCP_REORDERING___16 = 80,
    NET_TCP_ECN___16 = 81,
    NET_TCP_DSACK___16 = 82,
    NET_TCP_MEM___16 = 83,
    NET_TCP_WMEM___16 = 84,
    NET_TCP_RMEM___16 = 85,
    NET_TCP_APP_WIN___16 = 86,
    NET_TCP_ADV_WIN_SCALE___16 = 87,
    NET_IPV4_NONLOCAL_BIND___16 = 88,
    NET_IPV4_ICMP_RATELIMIT___16 = 89,
    NET_IPV4_ICMP_RATEMASK___16 = 90,
    NET_TCP_TW_REUSE___16 = 91,
    NET_TCP_FRTO___16 = 92,
    NET_TCP_LOW_LATENCY___16 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___16 = 94,
    NET_IPV4_IGMP_MAX_MSF___16 = 96,
    NET_TCP_NO_METRICS_SAVE___16 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___16 = 105,
    NET_TCP_MODERATE_RCVBUF___16 = 106,
    NET_TCP_TSO_WIN_DIVISOR___16 = 107,
    NET_TCP_BIC_BETA___16 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___16 = 109,
    NET_TCP_CONG_CONTROL___16 = 110,
    NET_TCP_ABC___16 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___16 = 112,
    NET_TCP_MTU_PROBING___16 = 113,
    NET_TCP_BASE_MSS___16 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___16 = 115,
    NET_TCP_DMA_COPYBREAK___16 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___16 = 117,
    NET_CIPSOV4_CACHE_ENABLE___16 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___16 = 119,
    NET_CIPSOV4_RBM_OPTFMT___16 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___16 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___16 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___16 = 123,
    NET_TCP_MAX_SSTHRESH___16 = 124,
    NET_TCP_FRTO_RESPONSE___16 = 125
} ;
enum __anonenum_132___16 {
    NET_IPV4_ROUTE_FLUSH___16 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___16 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___16 = 3,
    NET_IPV4_ROUTE_GC_THRESH___16 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___16 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___16 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___16 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___16 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___16 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___16 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___16 = 11,
    NET_IPV4_ROUTE_ERROR_COST___16 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___16 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___16 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___16 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___16 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___16 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___16 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___16 = 19
} ;
enum __anonenum_133___16 {
    NET_PROTO_CONF_ALL___16 = -2,
    NET_PROTO_CONF_DEFAULT___16 = -3
} ;
enum __anonenum_134___16 {
    NET_IPV4_CONF_FORWARDING___16 = 1,
    NET_IPV4_CONF_MC_FORWARDING___16 = 2,
    NET_IPV4_CONF_PROXY_ARP___16 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___16 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___16 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___16 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___16 = 7,
    NET_IPV4_CONF_RP_FILTER___16 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___16 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___16 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___16 = 11,
    NET_IPV4_CONF_TAG___16 = 12,
    NET_IPV4_CONF_ARPFILTER___16 = 13,
    NET_IPV4_CONF_MEDIUM_ID___16 = 14,
    NET_IPV4_CONF_NOXFRM___16 = 15,
    NET_IPV4_CONF_NOPOLICY___16 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___16 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___16 = 18,
    NET_IPV4_CONF_ARP_IGNORE___16 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___16 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___16 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___16 = 22,
    __NET_IPV4_CONF_MAX___16 = 23
} ;
enum __anonenum_135___16 {
    NET_IPV4_NF_CONNTRACK_MAX___16 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___16 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___16 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___16 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___16 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___16 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___16 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___16 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___16 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___16 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___16 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___16 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___16 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___16 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___16 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___16 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___16 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___16 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___16 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___16 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___16 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___16 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___16 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___16 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___16 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___16 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___16 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___16 = 28
} ;
enum __anonenum_136___16 {
    NET_IPV6_CONF___16 = 16,
    NET_IPV6_NEIGH___16 = 17,
    NET_IPV6_ROUTE___16 = 18,
    NET_IPV6_ICMP___16 = 19,
    NET_IPV6_BINDV6ONLY___16 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___16 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___16 = 22,
    NET_IPV6_IP6FRAG_TIME___16 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___16 = 24,
    NET_IPV6_MLD_MAX_MSF___16 = 25
} ;
enum __anonenum_137___16 {
    NET_IPV6_ROUTE_FLUSH___16 = 1,
    NET_IPV6_ROUTE_GC_THRESH___16 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___16 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___16 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___16 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___16 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___16 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___16 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___16 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___16 = 10
} ;
enum __anonenum_138___16 {
    NET_IPV6_FORWARDING___16 = 1,
    NET_IPV6_HOP_LIMIT___16 = 2,
    NET_IPV6_MTU___16 = 3,
    NET_IPV6_ACCEPT_RA___16 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___16 = 5,
    NET_IPV6_AUTOCONF___16 = 6,
    NET_IPV6_DAD_TRANSMITS___16 = 7,
    NET_IPV6_RTR_SOLICITS___16 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___16 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___16 = 10,
    NET_IPV6_USE_TEMPADDR___16 = 11,
    NET_IPV6_TEMP_VALID_LFT___16 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___16 = 13,
    NET_IPV6_REGEN_MAX_RETRY___16 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___16 = 15,
    NET_IPV6_MAX_ADDRESSES___16 = 16,
    NET_IPV6_FORCE_MLD_VERSION___16 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___16 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___16 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___16 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___16 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___16 = 22,
    NET_IPV6_PROXY_NDP___16 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___16 = 25,
    __NET_IPV6_MAX___16 = 26
} ;
enum __anonenum_139___16 {
    NET_IPV6_ICMP_RATELIMIT___16 = 1
} ;
enum __anonenum_140___16 {
    NET_NEIGH_MCAST_SOLICIT___16 = 1,
    NET_NEIGH_UCAST_SOLICIT___16 = 2,
    NET_NEIGH_APP_SOLICIT___16 = 3,
    NET_NEIGH_RETRANS_TIME___16 = 4,
    NET_NEIGH_REACHABLE_TIME___16 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___16 = 6,
    NET_NEIGH_GC_STALE_TIME___16 = 7,
    NET_NEIGH_UNRES_QLEN___16 = 8,
    NET_NEIGH_PROXY_QLEN___16 = 9,
    NET_NEIGH_ANYCAST_DELAY___16 = 10,
    NET_NEIGH_PROXY_DELAY___16 = 11,
    NET_NEIGH_LOCKTIME___16 = 12,
    NET_NEIGH_GC_INTERVAL___16 = 13,
    NET_NEIGH_GC_THRESH1___16 = 14,
    NET_NEIGH_GC_THRESH2___16 = 15,
    NET_NEIGH_GC_THRESH3___16 = 16,
    NET_NEIGH_RETRANS_TIME_MS___16 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___16 = 18,
    __NET_NEIGH_MAX___16 = 19
} ;
enum __anonenum_141___16 {
    NET_DCCP_DEFAULT___16 = 1
} ;
enum __anonenum_142___16 {
    NET_IPX_PPROP_BROADCASTING___16 = 1,
    NET_IPX_FORWARDING___16 = 2
} ;
enum __anonenum_143___16 {
    NET_LLC2___16 = 1,
    NET_LLC_STATION___16 = 2
} ;
enum __anonenum_144___16 {
    NET_LLC2_TIMEOUT___16 = 1
} ;
enum __anonenum_145___16 {
    NET_LLC_STATION_ACK_TIMEOUT___16 = 1
} ;
enum __anonenum_146___16 {
    NET_LLC2_ACK_TIMEOUT___16 = 1,
    NET_LLC2_P_TIMEOUT___16 = 2,
    NET_LLC2_REJ_TIMEOUT___16 = 3,
    NET_LLC2_BUSY_TIMEOUT___16 = 4
} ;
enum __anonenum_147___16 {
    NET_ATALK_AARP_EXPIRY_TIME___16 = 1,
    NET_ATALK_AARP_TICK_TIME___16 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___16 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___16 = 4
} ;
enum __anonenum_148___16 {
    NET_NETROM_DEFAULT_PATH_QUALITY___16 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___16 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___16 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___16 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___16 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___16 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___16 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___16 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___16 = 9,
    NET_NETROM_ROUTING_CONTROL___16 = 10,
    NET_NETROM_LINK_FAILS_COUNT___16 = 11,
    NET_NETROM_RESET___16 = 12
} ;
enum __anonenum_149___16 {
    NET_AX25_IP_DEFAULT_MODE___16 = 1,
    NET_AX25_DEFAULT_MODE___16 = 2,
    NET_AX25_BACKOFF_TYPE___16 = 3,
    NET_AX25_CONNECT_MODE___16 = 4,
    NET_AX25_STANDARD_WINDOW___16 = 5,
    NET_AX25_EXTENDED_WINDOW___16 = 6,
    NET_AX25_T1_TIMEOUT___16 = 7,
    NET_AX25_T2_TIMEOUT___16 = 8,
    NET_AX25_T3_TIMEOUT___16 = 9,
    NET_AX25_IDLE_TIMEOUT___16 = 10,
    NET_AX25_N2___16 = 11,
    NET_AX25_PACLEN___16 = 12,
    NET_AX25_PROTOCOL___16 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___16 = 14
} ;
enum __anonenum_150___16 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___16 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___16 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___16 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___16 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___16 = 5,
    NET_ROSE_ROUTING_CONTROL___16 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___16 = 7,
    NET_ROSE_MAX_VCS___16 = 8,
    NET_ROSE_WINDOW_SIZE___16 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___16 = 10
} ;
enum __anonenum_151___16 {
    NET_X25_RESTART_REQUEST_TIMEOUT___16 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___16 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___16 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___16 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___16 = 5,
    NET_X25_FORWARD___16 = 6
} ;
enum __anonenum_152___16 {
    NET_TR_RIF_TIMEOUT___16 = 1
} ;
enum __anonenum_153___16 {
    NET_DECNET_NODE_TYPE___16 = 1,
    NET_DECNET_NODE_ADDRESS___16 = 2,
    NET_DECNET_NODE_NAME___16 = 3,
    NET_DECNET_DEFAULT_DEVICE___16 = 4,
    NET_DECNET_TIME_WAIT___16 = 5,
    NET_DECNET_DN_COUNT___16 = 6,
    NET_DECNET_DI_COUNT___16 = 7,
    NET_DECNET_DR_COUNT___16 = 8,
    NET_DECNET_DST_GC_INTERVAL___16 = 9,
    NET_DECNET_CONF___16 = 10,
    NET_DECNET_NO_FC_MAX_CWND___16 = 11,
    NET_DECNET_MEM___16 = 12,
    NET_DECNET_RMEM___16 = 13,
    NET_DECNET_WMEM___16 = 14,
    NET_DECNET_DEBUG_LEVEL___16 = 255
} ;
enum __anonenum_154___16 {
    NET_DECNET_CONF_LOOPBACK___16 = -2,
    NET_DECNET_CONF_DDCMP___16 = -3,
    NET_DECNET_CONF_PPP___16 = -4,
    NET_DECNET_CONF_X25___16 = -5,
    NET_DECNET_CONF_GRE___16 = -6,
    NET_DECNET_CONF_ETHER___16 = -7
} ;
enum __anonenum_155___16 {
    NET_DECNET_CONF_DEV_PRIORITY___16 = 1,
    NET_DECNET_CONF_DEV_T1___16 = 2,
    NET_DECNET_CONF_DEV_T2___16 = 3,
    NET_DECNET_CONF_DEV_T3___16 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___16 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___16 = 6,
    NET_DECNET_CONF_DEV_STATE___16 = 7
} ;
enum __anonenum_156___16 {
    NET_SCTP_RTO_INITIAL___16 = 1,
    NET_SCTP_RTO_MIN___16 = 2,
    NET_SCTP_RTO_MAX___16 = 3,
    NET_SCTP_RTO_ALPHA___16 = 4,
    NET_SCTP_RTO_BETA___16 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___16 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___16 = 7,
    NET_SCTP_PATH_MAX_RETRANS___16 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___16 = 9,
    NET_SCTP_HB_INTERVAL___16 = 10,
    NET_SCTP_PRESERVE_ENABLE___16 = 11,
    NET_SCTP_MAX_BURST___16 = 12,
    NET_SCTP_ADDIP_ENABLE___16 = 13,
    NET_SCTP_PRSCTP_ENABLE___16 = 14,
    NET_SCTP_SNDBUF_POLICY___16 = 15,
    NET_SCTP_SACK_TIMEOUT___16 = 16,
    NET_SCTP_RCVBUF_POLICY___16 = 17
} ;
enum __anonenum_157___16 {
    NET_BRIDGE_NF_CALL_ARPTABLES___16 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___16 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___16 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___16 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___16 = 5
} ;
enum __anonenum_158___16 {
    NET_IRDA_DISCOVERY___16 = 1,
    NET_IRDA_DEVNAME___16 = 2,
    NET_IRDA_DEBUG___16 = 3,
    NET_IRDA_FAST_POLL___16 = 4,
    NET_IRDA_DISCOVERY_SLOTS___16 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___16 = 6,
    NET_IRDA_SLOT_TIMEOUT___16 = 7,
    NET_IRDA_MAX_BAUD_RATE___16 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___16 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___16 = 10,
    NET_IRDA_MAX_TX_WINDOW___16 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___16 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___16 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___16 = 14
} ;
enum __anonenum_159___16 {
    FS_NRINODE___16 = 1,
    FS_STATINODE___16 = 2,
    FS_MAXINODE___16 = 3,
    FS_NRDQUOT___16 = 4,
    FS_MAXDQUOT___16 = 5,
    FS_NRFILE___16 = 6,
    FS_MAXFILE___16 = 7,
    FS_DENTRY___16 = 8,
    FS_NRSUPER___16 = 9,
    FS_MAXSUPER___16 = 10,
    FS_OVERFLOWUID___16 = 11,
    FS_OVERFLOWGID___16 = 12,
    FS_LEASES___16 = 13,
    FS_DIR_NOTIFY___16 = 14,
    FS_LEASE_TIME___16 = 15,
    FS_DQSTATS___16 = 16,
    FS_XFS___16 = 17,
    FS_AIO_NR___16 = 18,
    FS_AIO_MAX_NR___16 = 19,
    FS_INOTIFY___16 = 20,
    FS_OCFS2___16 = 988
} ;
enum __anonenum_160___16 {
    FS_DQ_LOOKUPS___16 = 1,
    FS_DQ_DROPS___16 = 2,
    FS_DQ_READS___16 = 3,
    FS_DQ_WRITES___16 = 4,
    FS_DQ_CACHE_HITS___16 = 5,
    FS_DQ_ALLOCATED___16 = 6,
    FS_DQ_FREE___16 = 7,
    FS_DQ_SYNCS___16 = 8,
    FS_DQ_WARNINGS___16 = 9
} ;
enum __anonenum_161___16 {
    DEV_CDROM___16 = 1,
    DEV_HWMON___16 = 2,
    DEV_PARPORT___16 = 3,
    DEV_RAID___16 = 4,
    DEV_MAC_HID___16 = 5,
    DEV_SCSI___16 = 6,
    DEV_IPMI___16 = 7
} ;
enum __anonenum_162___16 {
    DEV_CDROM_INFO___16 = 1,
    DEV_CDROM_AUTOCLOSE___16 = 2,
    DEV_CDROM_AUTOEJECT___16 = 3,
    DEV_CDROM_DEBUG___16 = 4,
    DEV_CDROM_LOCK___16 = 5,
    DEV_CDROM_CHECK_MEDIA___16 = 6
} ;
enum __anonenum_163___16 {
    DEV_PARPORT_DEFAULT___16 = -3
} ;
enum __anonenum_164___16 {
    DEV_RAID_SPEED_LIMIT_MIN___16 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___16 = 2
} ;
enum __anonenum_165___16 {
    DEV_PARPORT_DEFAULT_TIMESLICE___16 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___16 = 2
} ;
enum __anonenum_166___16 {
    DEV_PARPORT_SPINTIME___16 = 1,
    DEV_PARPORT_BASE_ADDR___16 = 2,
    DEV_PARPORT_IRQ___16 = 3,
    DEV_PARPORT_DMA___16 = 4,
    DEV_PARPORT_MODES___16 = 5,
    DEV_PARPORT_DEVICES___16 = 6,
    DEV_PARPORT_AUTOPROBE___16 = 16
} ;
enum __anonenum_167___10 {
    DEV_PARPORT_DEVICES_ACTIVE___16 = -3
} ;
enum __anonenum_168___10 {
    DEV_PARPORT_DEVICE_TIMESLICE___16 = 1
} ;
enum __anonenum_169___16 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___16 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___16 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___16 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___16 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___16 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___16 = 6
} ;
enum __anonenum_170___10 {
    DEV_SCSI_LOGGING_LEVEL___16 = 1
} ;
enum __anonenum_171___10 {
    DEV_IPMI_POWEROFF_POWERCYCLE___16 = 1
} ;
enum __anonenum_172___16 {
    ABI_DEFHANDLER_COFF___16 = 1,
    ABI_DEFHANDLER_ELF___16 = 2,
    ABI_DEFHANDLER_LCALL7___16 = 3,
    ABI_DEFHANDLER_LIBCSO___16 = 4,
    ABI_TRACE___16 = 5,
    ABI_FAKE_UTSNAME___16 = 6
} ;
enum __anonenum_175___5 {
    IOCB_CMD_PREAD___16 = 0,
    IOCB_CMD_PWRITE___16 = 1,
    IOCB_CMD_FSYNC___16 = 2,
    IOCB_CMD_FDSYNC___16 = 3,
    IOCB_CMD_NOOP___16 = 6,
    IOCB_CMD_PREADV___16 = 7,
    IOCB_CMD_PWRITEV___16 = 8
} ;
enum __anonenum_178___2 {
    IRQTF_RUNTHREAD___16 = 0,
    IRQTF_DIED___16 = 1,
    IRQTF_WARNED___16 = 2
} ;
enum __anonenum_179___6 {
    HI_SOFTIRQ___16 = 0,
    TIMER_SOFTIRQ___16 = 1,
    NET_TX_SOFTIRQ___16 = 2,
    NET_RX_SOFTIRQ___16 = 3,
    BLOCK_SOFTIRQ___16 = 4,
    TASKLET_SOFTIRQ___16 = 5,
    SCHED_SOFTIRQ___16 = 6,
    HRTIMER_SOFTIRQ___16 = 7,
    RCU_SOFTIRQ___16 = 8,
    NR_SOFTIRQS___16 = 9
} ;
enum __anonenum_180___8 {
    TASKLET_STATE_SCHED___16 = 0,
    TASKLET_STATE_RUN___16 = 1
} ;
enum __anonenum_183___12 {
    QIF_BLIMITS_B___16 = 0,
    QIF_SPACE_B___16 = 1,
    QIF_ILIMITS_B___16 = 2,
    QIF_INODES_B___16 = 3,
    QIF_BTIME_B___16 = 4,
    QIF_ITIME_B___16 = 5
} ;
enum __anonenum_184___14 {
    QUOTA_NL_C_UNSPEC___16 = 0,
    QUOTA_NL_C_WARNING___16 = 1,
    __QUOTA_NL_C_MAX___16 = 2
} ;
enum __anonenum_185___14 {
    QUOTA_NL_A_UNSPEC___16 = 0,
    QUOTA_NL_A_QTYPE___16 = 1,
    QUOTA_NL_A_EXCESS_ID___16 = 2,
    QUOTA_NL_A_WARNING___16 = 3,
    QUOTA_NL_A_DEV_MAJOR___16 = 4,
    QUOTA_NL_A_DEV_MINOR___16 = 5,
    QUOTA_NL_A_CAUSED_ID___16 = 6,
    __QUOTA_NL_A_MAX___16 = 7
} ;
enum __anonenum_186___14 {
    _DQUOT_USAGE_ENABLED___16 = 0,
    _DQUOT_LIMITS_ENABLED___16 = 1,
    _DQUOT_SUSPENDED___16 = 2,
    _DQUOT_STATE_FLAGS___16 = 3
} ;
enum __anonenum_193___13 {
    SB_UNFROZEN___16 = 0,
    SB_FREEZE_WRITE___16 = 1,
    SB_FREEZE_TRANS___16 = 2
} ;
enum __anonenum_194___15 {
    DIO_LOCKING___16 = 1,
    DIO_NO_LOCKING___16 = 2,
    DIO_OWN_LOCKING___16 = 3
} ;
struct find_interface_arg {
   int minor ;
   struct usb_interface *interface ;
};
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
extern char const   early_idt_handlers[32][10] ;
extern initcall_t __con_initcall_start[] ;
extern initcall_t __con_initcall_end[] ;
extern initcall_t __security_initcall_start[] ;
extern initcall_t __security_initcall_end[] ;
extern int do_one_initcall(int (*fn)(void) ) ;
extern char boot_command_line[]  __attribute__((__section__(".init.data"))) ;
extern char *saved_command_line ;
extern unsigned int reset_devices ;
extern void setup_arch(char ** ) ;
extern void prepare_namespace(void) ;
extern void (*late_time_init)(void) ;
extern void parse_early_param(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void parse_early_options(char *cmdline )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern unsigned long profile_pc(struct pt_regs *regs ) ;
extern unsigned long convert_ip_to_linear(struct task_struct *child , struct pt_regs *regs ) ;
extern void send_sigtrap(struct task_struct *tsk , struct pt_regs *regs , int error_code ,
                         int si_code ) ;
extern void signal_fault(struct pt_regs *regs , void *frame , char *where ) ;
extern long syscall_trace_enter(struct pt_regs * ) ;
extern void syscall_trace_leave(struct pt_regs * ) ;
__inline static unsigned long regs_return_value(struct pt_regs *regs ) 
{ 

  {
  return (regs->ax);
}
}
__inline static int user_mode(struct pt_regs *regs ) 
{ 

  {
  return ((regs->cs & 3UL) == 3UL);
}
}
__inline static int user_mode_vm(struct pt_regs *regs ) 
{ 

  {
  return (((regs->cs & 3UL) | (regs->flags & 131072UL)) >= 3UL);
}
}
__inline static int v8086_mode(struct pt_regs *regs ) 
{ 

  {
  return ((int )(regs->flags & 131072UL));
}
}
__inline static unsigned long kernel_stack_pointer(struct pt_regs *regs ) 
{ 

  {
  return ((unsigned long )(& regs->sp));
}
}
__inline static unsigned long instruction_pointer(struct pt_regs *regs ) 
{ 

  {
  return (regs->ip);
}
}
__inline static unsigned long frame_pointer(struct pt_regs *regs ) 
{ 

  {
  return (regs->bp);
}
}
__inline static unsigned long user_stack_pointer(struct pt_regs *regs ) 
{ 

  {
  return (regs->sp);
}
}
extern void user_enable_single_step(struct task_struct * ) ;
extern void user_disable_single_step(struct task_struct * ) ;
extern void user_enable_block_step(struct task_struct * ) ;
extern int do_get_thread_area(struct task_struct *p , int idx , struct user_desc *info ) ;
extern int do_set_thread_area(struct task_struct *p , int idx , struct user_desc *info ,
                              int can_allocate ) ;
extern void x86_ptrace_untrace(struct task_struct * ) ;
extern void x86_ptrace_fork(struct task_struct *child , unsigned long clone_flags ) ;
extern void handle_vm86_fault(struct kernel_vm86_regs * , long  ) ;
extern int handle_vm86_trap(struct kernel_vm86_regs * , long  , int  ) ;
extern struct pt_regs *save_v86_state(struct kernel_vm86_regs * ) ;
extern void release_vm86_irqs(struct task_struct * ) ;
extern void __bad_percpu_size(void) ;
extern unsigned long __per_cpu_offset[8] ;
extern void setup_per_cpu_areas(void) ;
extern unsigned long per_cpu__this_cpu_off  __attribute__((__section__(".data.percpu"))) ;
extern struct task_struct *per_cpu__current_task  __attribute__((__section__(".data.percpu"))) ;
__inline static struct task_struct *get_current(void) 
{ struct task_struct *ret__ ;

  {
  if ((int )sizeof(per_cpu__current_task) == 1) {
    goto switch_0_1;
  } else {
    if ((int )sizeof(per_cpu__current_task) == 2) {
      goto switch_0_2;
    } else {
      if ((int )sizeof(per_cpu__current_task) == 4) {
        goto switch_0_4;
      } else {
        if ((int )sizeof(per_cpu__current_task) == 8) {
          goto switch_0_8;
        } else {
          {
          goto switch_0_default;
          if (0) {
            switch_0_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_0_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  return (ret__);
}
}
extern void alternative_instructions(void) ;
extern void apply_alternatives(struct alt_instr *start , struct alt_instr *end ) ;
extern void alternatives_smp_module_add(struct module *mod , char *name , void *locks ,
                                        void *locks_end , void *text , void *text_end ) ;
extern void alternatives_smp_module_del(struct module *mod ) ;
extern void alternatives_smp_switch(int smp ) ;
extern unsigned char const   * const  *find_nop_table(void) ;
__inline static void apply_paravirt(struct paravirt_patch_site *start , struct paravirt_patch_site *end ) 
{ 

  {
  return;
}
}
extern void add_nops(void *insns , unsigned int len ) ;
extern void *text_poke(void *addr , void const   *opcode , size_t len ) ;
extern void *text_poke_early(void *addr , void const   *opcode , size_t len ) ;
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return;
}
}
__inline static void __set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return;
}
}
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static void clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  clear_bit((int )nr, addr);
  }
  return;
}
}
__inline static void __clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static void __clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  __clear_bit((int )nr, addr);
  }
  return;
}
}
__inline static void __change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static void change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int test_and_set_bit_lock(int nr , unsigned long volatile   *addr ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(nr, addr);
  }
  return (tmp);
}
}
__inline static int __test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  ("bts %2,%1\n\t"
            "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return (oldbit);
}
}
__inline static int test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int __test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   ("btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return (oldbit);
}
}
__inline static int __test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   ("btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 

  {
  return (((1UL << nr % 32U) & *((unsigned long *)addr + nr / 32U)) != 0UL);
}
}
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  }
  return (oldbit);
}
}
__inline static unsigned long __ffs(unsigned long word ) 
{ 

  {
  {
  __asm__  ("bsf %1,%0": "=r" (word): "rm" (word));
  }
  return (word);
}
}
__inline static unsigned long ffz(unsigned long word ) 
{ 

  {
  {
  __asm__  ("bsf %1,%0": "=r" (word): "r" (~ word));
  }
  return (word);
}
}
__inline static unsigned long __fls(unsigned long word ) 
{ 

  {
  {
  __asm__  ("bsr %1,%0": "=r" (word): "rm" (word));
  }
  return (word);
}
}
__inline static int ffs(int x ) 
{ int r ;

  {
  {
  __asm__  ("bsfl %1,%0\n\t"
            "cmovzl %2,%0": "=r" (r): "rm" (x), "r" (-1));
  }
  return (r + 1);
}
}
__inline static int fls(int x ) 
{ int r ;

  {
  {
  __asm__  ("bsrl %1,%0\n\t"
            "cmovzl %2,%0": "=&r" (r): "rm" (x), "rm" (-1));
  }
  return (r + 1);
}
}
__inline static int sched_find_first_bit(unsigned long const   *b ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  if (*(b + 0)) {
    {
    tmp = __ffs((unsigned long )*(b + 0));
    }
    return ((int )tmp);
  }
  if (*(b + 1)) {
    {
    tmp___0 = __ffs((unsigned long )*(b + 1));
    }
    return ((int )(tmp___0 + 32UL));
  }
  if (*(b + 2)) {
    {
    tmp___1 = __ffs((unsigned long )*(b + 2));
    }
    return ((int )(tmp___1 + 64UL));
  }
  {
  tmp___2 = __ffs((unsigned long )*(b + 3));
  }
  return ((int )(tmp___2 + 96UL));
}
}
extern unsigned int hweight32(unsigned int w ) ;
extern unsigned int hweight16(unsigned int w ) ;
extern unsigned int hweight8(unsigned int w ) ;
extern unsigned long hweight64(__u64 w ) ;
__inline static int fls64(__u64 x ) 
{ __u32 h ;
  int tmp ;
  int tmp___0 ;

  {
  {
  h = (__u32 )(x >> 32);
  }
  if (h) {
    {
    tmp = fls((int )h);
    }
    return (tmp + 32);
  }
  {
  tmp___0 = fls((int )x);
  }
  return (tmp___0);
}
}
__inline static __u32 __arch_swab32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __arch_swab32(__u32 val ) 
{ 

  {
  {
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
  }
  return (val);
}
}
__inline static __u64 __arch_swab64(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __arch_swab64(__u64 val ) 
{ 

  {
  {
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
  }
  return (val);
}
}
__inline static __u16 __fswab16(__u16 val )  __attribute__((__const__)) ;
__inline static __u16 __fswab16(__u16 val ) 
{ 

  {
  return ((unsigned short )((((int )val & 255) << 8) | (((int )val & 65280) >> 8)));
}
}
__inline static __u32 __fswab32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __fswab32(__u32 val ) 
{ __u32 tmp ;

  {
  {
  tmp = __arch_swab32(val);
  }
  return (tmp);
}
}
__inline static __u64 __fswab64(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __fswab64(__u64 val ) 
{ __u64 tmp ;

  {
  {
  tmp = __arch_swab64(val);
  }
  return (tmp);
}
}
__inline static __u32 __fswahw32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __fswahw32(__u32 val ) 
{ 

  {
  return (((val & 65535U) << 16) | ((val & 4294901760U) >> 16));
}
}
__inline static __u32 __fswahb32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __fswahb32(__u32 val ) 
{ 

  {
  return (((val & 16711935U) << 8) | ((val & 4278255360U) >> 8));
}
}
__inline static __u16 __swab16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __fswab16((unsigned short )*p);
  }
  return ((unsigned short )((int )tmp));
}
}
__inline static __u32 __swab32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __fswab32((unsigned int )*p);
  }
  return (tmp);
}
}
__inline static __u64 __swab64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __fswab64((unsigned long long )*p);
  }
  return (tmp);
}
}
__inline static __u32 __swahw32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __fswahw32((unsigned int )*p);
  }
  return (tmp);
}
}
__inline static __u32 __swahb32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __fswahb32((unsigned int )*p);
  }
  return (tmp);
}
}
__inline static void __swab16s(__u16 *p ) 
{ 

  {
  {
  *p = __swab16p((__u16 const   *)p);
  }
  return;
}
}
__inline static void __swab32s(__u32 *p ) 
{ 

  {
  {
  *p = __swab32p((__u32 const   *)p);
  }
  return;
}
}
__inline static void __swab64s(__u64 *p ) 
{ 

  {
  {
  *p = __swab64p((__u64 const   *)p);
  }
  return;
}
}
__inline static void __swahw32s(__u32 *p ) 
{ 

  {
  {
  *p = __swahw32p((__u32 const   *)p);
  }
  return;
}
}
__inline static void __swahb32s(__u32 *p ) 
{ 

  {
  {
  *p = __swahb32p((__u32 const   *)p);
  }
  return;
}
}
__inline static __le64 __cpu_to_le64p(__u64 const   *p ) 
{ 

  {
  return ((unsigned long long )*p);
}
}
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 

  {
  return ((unsigned long long )*p);
}
}
__inline static __le32 __cpu_to_le32p(__u32 const   *p ) 
{ 

  {
  return ((unsigned int )*p);
}
}
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 

  {
  return ((unsigned int )*p);
}
}
__inline static __le16 __cpu_to_le16p(__u16 const   *p ) 
{ 

  {
  return ((unsigned short )*p);
}
}
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 

  {
  return ((unsigned short )*p);
}
}
__inline static __be64 __cpu_to_be64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __swab64p(p);
  }
  return (tmp);
}
}
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __swab64p((__u64 const   *)((__u64 *)p));
  }
  return (tmp);
}
}
__inline static __be32 __cpu_to_be32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __swab32p(p);
  }
  return (tmp);
}
}
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __swab32p((__u32 const   *)((__u32 *)p));
  }
  return (tmp);
}
}
__inline static __be16 __cpu_to_be16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __swab16p(p);
  }
  return (tmp);
}
}
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __swab16p((__u16 const   *)((__u16 *)p));
  }
  return (tmp);
}
}
__inline static void le16_add_cpu(__le16 *var , u16 val ) 
{ 

  {
  {
  *var = (unsigned short )((int )*var + (int )val);
  }
  return;
}
}
__inline static void le32_add_cpu(__le32 *var , u32 val ) 
{ 

  {
  {
  *var += val;
  }
  return;
}
}
__inline static void le64_add_cpu(__le64 *var , u64 val ) 
{ 

  {
  {
  *var += val;
  }
  return;
}
}
__inline static void be16_add_cpu(__be16 *var , u16 val ) 
{ __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;

  {
  {
  tmp___2 = __fswab16(*var);
  tmp___3 = __fswab16((unsigned short )((int )tmp___2 + (int )val));
  *var = (unsigned short )((int )tmp___3);
  }
  return;
}
}
__inline static void be32_add_cpu(__be32 *var , u32 val ) 
{ __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
  {
  tmp___4 = __fswab32(*var);
  tmp___5 = __fswab32(tmp___4 + val);
  *var = tmp___5;
  }
  return;
}
}
__inline static void be64_add_cpu(__be64 *var , u64 val ) 
{ __u64 tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;
  __u64 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;
  __u64 tmp___7 ;
  __u64 tmp___8 ;
  __u64 tmp___9 ;

  {
  {
  tmp___8 = __fswab64(*var);
  tmp___9 = __fswab64(tmp___8 + val);
  *var = tmp___9;
  }
  return;
}
}
__inline static int get_bitmask_order(unsigned int count ) 
{ int order ;

  {
  {
  order = fls((int )count);
  }
  return (order);
}
}
__inline static int get_count_order(unsigned int count ) 
{ int order ;
  int tmp ;

  {
  {
  tmp = fls((int )count);
  order = tmp - 1;
  }
  if (count & (count - 1U)) {
    {
    order ++;
    }
  }
  return (order);
}
}
__inline static unsigned long hweight_long(unsigned long w ) 
{ unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  if (sizeof(w) == 4UL) {
    {
    tmp = hweight32((unsigned int )w);
    tmp___1 = (unsigned long )tmp;
    }
  } else {
    {
    tmp___0 = hweight64((unsigned long long )w);
    tmp___1 = tmp___0;
    }
  }
  return (tmp___1);
}
}
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word << shift) | (word >> (32U - shift)));
}
}
__inline static __u32 ror32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word >> shift) | (word << (32U - shift)));
}
}
__inline static __u16 rol16(__u16 word , unsigned int shift ) 
{ 

  {
  return ((unsigned short )(((int )word << shift) | ((int )word >> (16U - shift))));
}
}
__inline static __u16 ror16(__u16 word , unsigned int shift ) 
{ 

  {
  return ((unsigned short )(((int )word >> shift) | ((int )word << (16U - shift))));
}
}
__inline static __u8 rol8(__u8 word , unsigned int shift ) 
{ 

  {
  return ((unsigned char )(((int )word << shift) | ((int )word >> (8U - shift))));
}
}
__inline static __u8 ror8(__u8 word , unsigned int shift ) 
{ 

  {
  return ((unsigned char )(((int )word >> shift) | ((int )word << (8U - shift))));
}
}
__inline static unsigned int fls_long(unsigned long l ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (sizeof(l) == 4UL) {
    {
    tmp = fls((int )l);
    }
    return ((unsigned int )tmp);
  }
  {
  tmp___0 = fls64((unsigned long long )l);
  }
  return ((unsigned int )tmp___0);
}
}
__inline static unsigned long __ffs64(u64 word ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if ((unsigned long )((unsigned int )word) == 0UL) {
    {
    tmp = __ffs((unsigned long )((unsigned int )(word >> 32)));
    }
    return (tmp + 32UL);
  }
  {
  tmp___0 = __ffs((unsigned long )word);
  }
  return (tmp___0);
}
}
extern unsigned long find_first_bit(unsigned long const   *addr , unsigned long size ) ;
extern unsigned long find_first_zero_bit(unsigned long const   *addr , unsigned long size ) ;
extern unsigned long find_last_bit(unsigned long const   *addr , unsigned long size ) ;
extern unsigned long find_next_bit(unsigned long const   *addr , unsigned long size ,
                                   unsigned long offset ) ;
extern unsigned long find_next_zero_bit(unsigned long const   *addr , unsigned long size ,
                                        unsigned long offset ) ;
extern char const   * const  x86_cap_flags[288] ;
extern char const   * const  x86_power_flags[32] ;
__inline static void __set_64bit(unsigned long long *ptr , unsigned int low , unsigned int high ) 
{ 

  {
  {
  __asm__  volatile   ("\n1:\t"
                       "movl (%0), %%eax\n\t"
                       "movl 4(%0), %%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b (%0)\n\t"
                       "jnz 1b": : "D" (ptr), "b" (low), "c" (high): "ax", "dx", "memory");
  }
  return;
}
}
__inline static void __set_64bit_constant(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
  __set_64bit(ptr, (unsigned int )value, (unsigned int )(value >> 32));
  }
  return;
}
}
__inline static void __set_64bit_var(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
  __set_64bit(ptr, *((unsigned int *)(& value) + 0), *((unsigned int *)(& value) + 1));
  }
  return;
}
}
__inline static unsigned long __xchg(unsigned long x , void volatile   *ptr , int size ) 
{ 

  {
  if (size == 1) {
    goto switch_1_1;
  } else {
    if (size == 2) {
      goto switch_1_2;
    } else {
      if (size == 4) {
        goto switch_1_4;
      } else {
        if (0) {
          switch_1_1: /* CIL Label */ 
          {
          __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
          switch_1_2: /* CIL Label */ 
          {
          __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
          switch_1_4: /* CIL Label */ 
          {
          __asm__  volatile   ("xchgl %0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
        } else {
          switch_1_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (x);
}
}
__inline static unsigned long __cmpxchg(void volatile   *ptr , unsigned long old ,
                                        unsigned long new , int size ) 
{ unsigned long prev ;

  {
  if (size == 1) {
    goto switch_2_1;
  } else {
    if (size == 2) {
      goto switch_2_2;
    } else {
      if (size == 4) {
        goto switch_2_4;
      } else {
        if (0) {
          switch_2_1: /* CIL Label */ 
          {
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_2_2: /* CIL Label */ 
          {
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_2_4: /* CIL Label */ 
          {
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
        } else {
          switch_2_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (old);
}
}
__inline static unsigned long __sync_cmpxchg(void volatile   *ptr , unsigned long old ,
                                             unsigned long new , int size ) 
{ unsigned long prev ;

  {
  if (size == 1) {
    goto switch_3_1;
  } else {
    if (size == 2) {
      goto switch_3_2;
    } else {
      if (size == 4) {
        goto switch_3_4;
      } else {
        if (0) {
          switch_3_1: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_3_2: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_3_4: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
        } else {
          switch_3_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (old);
}
}
__inline static unsigned long __cmpxchg_local(void volatile   *ptr , unsigned long old ,
                                              unsigned long new , int size ) 
{ unsigned long prev ;

  {
  if (size == 1) {
    goto switch_4_1;
  } else {
    if (size == 2) {
      goto switch_4_2;
    } else {
      if (size == 4) {
        goto switch_4_4;
      } else {
        if (0) {
          switch_4_1: /* CIL Label */ 
          {
          __asm__  volatile   ("cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_4_2: /* CIL Label */ 
          {
          __asm__  volatile   ("cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_4_4: /* CIL Label */ 
          {
          __asm__  volatile   ("cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
        } else {
          switch_4_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (old);
}
}
__inline static unsigned long long __cmpxchg64(void volatile   *ptr , unsigned long long old ,
                                               unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
  return (prev);
}
}
__inline static unsigned long long __cmpxchg64_local(void volatile   *ptr , unsigned long long old ,
                                                     unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
  __asm__  volatile   ("cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
  return (prev);
}
}
extern unsigned long long cmpxchg_486_u64(void volatile   * , u64  , u64  ) ;
extern  __attribute__((__noreturn__)) int ____ilog2_NaN(void)  __attribute__((__const__)) ;
__inline static int __ilog2_u32(u32 n )  __attribute__((__const__)) ;
__inline static int __ilog2_u32(u32 n ) 
{ int tmp ;

  {
  {
  tmp = fls((int )n);
  }
  return (tmp - 1);
}
}
__inline static int __ilog2_u64(u64 n )  __attribute__((__const__)) ;
__inline static int __ilog2_u64(u64 n ) 
{ int tmp ;

  {
  {
  tmp = fls64(n);
  }
  return (tmp - 1);
}
}
__inline static bool is_power_of_2(unsigned long n )  __attribute__((__const__)) ;
__inline static bool is_power_of_2(unsigned long n ) 
{ int tmp ;

  {
  if (n != 0UL) {
    if ((n & (n - 1UL)) == 0UL) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return ((_Bool )tmp);
}
}
__inline static unsigned long __roundup_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
  tmp = fls_long(n - 1UL);
  }
  return (1UL << tmp);
}
}
__inline static unsigned long __rounddown_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
__inline static unsigned long __rounddown_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
  tmp = fls_long(n);
  }
  return (1UL << (tmp - 1U));
}
}
extern int __ratelimit(struct ratelimit_state *rs ) ;
extern long long dynamic_debug_enabled ;
extern long long dynamic_debug_enabled2 ;
extern int ddebug_add_module(struct _ddebug *tab , unsigned int n , char const   *modname ) ;
__inline static int ddebug_remove_module(char *mod ) 
{ 

  {
  return (0);
}
}
extern void ( /* format attribute */  warn_slowpath_fmt)(char const   *file , int line ,
                                                         char const   *fmt  , ...) ;
extern void warn_slowpath_null(char const   *file , int line ) ;
extern char const   linux_banner[] ;
extern char const   linux_proc_banner[] ;
extern int console_printk[] ;
extern int _cond_resched(void) ;
__inline static void might_fault(void) 
{ 

  {
  {
  while (1) {
    while_5_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_5_break;
  }
  while_5_break: /* CIL Label */ ;
  }
  return;
}
}
extern struct atomic_notifier_head panic_notifier_list ;
extern long (*panic_blink)(long time ) ;
extern  __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *fmt 
                                                                            , ...) ;
extern void oops_enter(void) ;
extern void oops_exit(void) ;
extern int oops_may_print(void) ;
extern  __attribute__((__noreturn__)) void do_exit(long error_code ) ;
extern  __attribute__((__noreturn__)) void complete_and_exit(struct completion * ,
                                                             long  ) ;
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
extern unsigned long long simple_strtoull(char const   * , char ** , unsigned int  ) ;
extern long long simple_strtoll(char const   * , char ** , unsigned int  ) ;
extern int strict_strtoul(char const   * , unsigned int  , unsigned long * ) ;
extern int strict_strtol(char const   * , unsigned int  , long * ) ;
extern int strict_strtoull(char const   * , unsigned int  , unsigned long long * ) ;
extern int strict_strtoll(char const   * , unsigned int  , long long * ) ;
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
extern int ( /* format attribute */  vsprintf)(char *buf , char const   * , va_list  ) ;
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
extern int ( /* format attribute */  vsnprintf)(char *buf , size_t size , char const   *fmt ,
                                                va_list args ) ;
extern int ( /* format attribute */  scnprintf)(char *buf , size_t size , char const   *fmt 
                                                , ...) ;
extern int ( /* format attribute */  vscnprintf)(char *buf , size_t size , char const   *fmt ,
                                                 va_list args ) ;
extern char *( /* format attribute */  kasprintf)(gfp_t gfp , char const   *fmt  , ...) ;
extern char *kvasprintf(gfp_t gfp , char const   *fmt , va_list args ) ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern int ( /* format attribute */  vsscanf)(char const   * , char const   * , va_list  ) ;
extern int get_option(char **str , int *pint ) ;
extern char *get_options(char const   *str , int nints , int *ints ) ;
extern unsigned long long memparse(char const   *ptr , char **retptr ) ;
extern int core_kernel_text(unsigned long addr ) ;
extern int __kernel_text_address(unsigned long addr ) ;
extern int kernel_text_address(unsigned long addr ) ;
extern int func_ptr_is_kernel_text(void *ptr ) ;
extern struct pid *session_of_pgrp(struct pid *pgrp ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) vprintk)(char const   *fmt ,
                                                                             va_list args ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...) ;
extern struct ratelimit_state printk_ratelimit_state ;
extern int printk_ratelimit(void) ;
extern bool printk_timed_ratelimit(unsigned long *caller_jiffies , unsigned int interval_msec ) ;
extern void log_buf_kexec_setup(void) ;
extern int printk_needs_cpu(int cpu ) ;
extern void printk_tick(void) ;
extern void ( /* format attribute */ __attribute__((__regparm__(0))) early_printk)(char const   *fmt 
                                                                                   , ...) ;
extern unsigned long int_sqrt(unsigned long  ) ;
__inline static void console_silent(void) 
{ 

  {
  {
  console_printk[0] = 0;
  }
  return;
}
}
__inline static void console_verbose(void) 
{ 

  {
  if (console_printk[0]) {
    {
    console_printk[0] = 15;
    }
  }
  return;
}
}
extern void bust_spinlocks(int yes ) ;
extern void wake_up_klogd(void) ;
extern int oops_in_progress ;
extern int panic_timeout ;
extern int panic_on_oops ;
extern int panic_on_unrecovered_nmi ;
extern char const   *print_tainted(void) ;
extern void add_taint(unsigned int flag ) ;
extern int test_taint(unsigned int flag ) ;
extern unsigned long get_taint(void) ;
extern int root_mountflags ;
extern enum system_states system_state ;
extern void dump_stack(void) ;
extern void hex_dump_to_buffer(void const   *buf , size_t len , int rowsize , int groupsize ,
                               char *linebuf , size_t linebuflen , bool ascii ) ;
extern void print_hex_dump(char const   *level , char const   *prefix_str , int prefix_type ,
                           int rowsize , int groupsize , void const   *buf , size_t len ,
                           bool ascii ) ;
extern void print_hex_dump_bytes(char const   *prefix_str , int prefix_type , void const   *buf ,
                                 size_t len ) ;
extern char const   hex_asc[] ;
__inline static char *pack_hex_byte(char *buf , u8 byte ) 
{ char *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = buf;
  buf ++;
  *tmp = (char )hex_asc[((int )byte & 240) >> 4];
  tmp___0 = buf;
  buf ++;
  *tmp___0 = (char )hex_asc[(int )byte & 15];
  }
  return (buf);
}
}
extern void tracing_on(void) ;
extern void tracing_off(void) ;
extern void tracing_off_permanent(void) ;
extern int tracing_is_on(void) ;
extern void tracing_start(void) ;
extern void tracing_stop(void) ;
extern void ftrace_off_permanent(void) ;
extern void ftrace_special(unsigned long arg1 , unsigned long arg2 , unsigned long arg3 ) ;
__inline static void ( /* format attribute */  ____trace_printk_check_format)(char const   *fmt 
                                                                              , ...) 
{ 

  {
  return;
}
}
extern int ( /* format attribute */  __trace_bprintk)(unsigned long ip , char const   *fmt 
                                                      , ...) ;
extern int ( /* format attribute */  __trace_printk)(unsigned long ip , char const   *fmt 
                                                     , ...) ;
extern int __ftrace_vbprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
extern int __ftrace_vprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
extern void ftrace_dump(void) ;
extern int do_sysinfo(struct sysinfo *info ) ;
__inline static unsigned long native_save_fl(void) 
{ unsigned long flags ;

  {
  {
  __asm__  volatile   ("# __raw_save_flags\n\t"
                       "pushf ; pop %0": "=g" (flags): : "memory");
  }
  return (flags);
}
}
__inline static void native_restore_fl(unsigned long flags ) 
{ 

  {
  {
  __asm__  volatile   ("push %0 ; popf": : "g" (flags): "memory", "cc");
  }
  return;
}
}
__inline static void native_irq_disable(void) 
{ 

  {
  {
  __asm__  volatile   ("cli": : : "memory");
  }
  return;
}
}
__inline static void native_irq_enable(void) 
{ 

  {
  {
  __asm__  volatile   ("sti": : : "memory");
  }
  return;
}
}
__inline static void native_safe_halt(void) 
{ 

  {
  {
  __asm__  volatile   ("sti; hlt": : : "memory");
  }
  return;
}
}
__inline static void native_halt(void) 
{ 

  {
  {
  __asm__  volatile   ("hlt": : : "memory");
  }
  return;
}
}
__inline static unsigned long __raw_local_save_flags(void) 
{ unsigned long tmp ;

  {
  {
  tmp = native_save_fl();
  }
  return (tmp);
}
}
__inline static void raw_local_irq_restore(unsigned long flags ) 
{ 

  {
  {
  native_restore_fl(flags);
  }
  return;
}
}
__inline static void raw_local_irq_disable(void) 
{ 

  {
  {
  native_irq_disable();
  }
  return;
}
}
__inline static void raw_local_irq_enable(void) 
{ 

  {
  {
  native_irq_enable();
  }
  return;
}
}
__inline static void raw_safe_halt(void) 
{ 

  {
  {
  native_safe_halt();
  }
  return;
}
}
__inline static void halt(void) 
{ 

  {
  {
  native_halt();
  }
  return;
}
}
__inline static unsigned long __raw_local_irq_save(void) 
{ unsigned long flags ;
  unsigned long tmp ;

  {
  {
  tmp = __raw_local_save_flags();
  flags = tmp;
  raw_local_irq_disable();
  }
  return (flags);
}
}
__inline static int raw_irqs_disabled_flags(unsigned long flags ) 
{ 

  {
  return (! (flags & 512UL));
}
}
__inline static int raw_irqs_disabled(void) 
{ unsigned long flags ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp = __raw_local_save_flags();
  flags = tmp;
  tmp___0 = raw_irqs_disabled_flags(flags);
  }
  return (tmp___0);
}
}
extern struct task_struct *__switch_to(struct task_struct *prev , struct task_struct *next ) ;
extern void __switch_to_xtra(struct task_struct *prev_p , struct task_struct *next_p ,
                             struct tss_struct *tss ) ;
extern void native_load_gs_index(unsigned int  ) ;
__inline static unsigned long get_limit(unsigned long segment ) 
{ unsigned long __limit ;

  {
  {
  __asm__  ("lsll %1,%0": "=r" (__limit): "r" (segment));
  }
  return (__limit + 1UL);
}
}
__inline static void native_clts(void) 
{ 

  {
  {
  __asm__  volatile   ("clts":);
  }
  return;
}
}
static unsigned long __force_order  ;
__inline static unsigned long native_read_cr0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static void native_write_cr0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static unsigned long native_read_cr2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static void native_write_cr2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static unsigned long native_read_cr3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static void native_write_cr3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static unsigned long native_read_cr4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static void native_wbinvd(void) 
{ 

  {
  {
  __asm__  volatile   ("wbinvd": : : "memory");
  }
  return;
}
}
__inline static void clflush(void volatile   *__p ) 
{ 

  {
  {
  __asm__  volatile   ("clflush %0": "+m" (*((char volatile   *)__p)));
  }
  return;
}
}
extern void disable_hlt(void) ;
extern void enable_hlt(void) ;
extern void cpu_idle_wait(void) ;
extern unsigned long arch_align_stack(unsigned long sp ) ;
extern void free_init_pages(char *what , unsigned long begin , unsigned long end ) ;
extern void default_idle(void) ;
extern void stop_this_cpu(void *dummy ) ;
__inline static void rdtsc_barrier(void) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (113): "memory");
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (114): "memory");
  }
  return;
}
}
extern unsigned int __VMALLOC_RESERVE ;
extern int sysctl_legacy_va_layout ;
extern void find_low_pfn_range(void) ;
extern unsigned long init_memory_mapping(unsigned long start , unsigned long end ) ;
extern void initmem_init(unsigned long  , unsigned long  ) ;
extern void free_initmem(void) ;
extern void setup_bootmem_allocator(void) ;
extern int page_is_ram(unsigned long pagenr ) ;
extern int devmem_is_allowed(unsigned long pagenr ) ;
extern unsigned long max_low_pfn_mapped ;
extern unsigned long max_pfn_mapped ;
extern char *strndup_user(char const   * , long  ) ;
extern void *memdup_user(void const   * , size_t  ) ;
extern char *strcpy(char *dest , char const   *src ) ;
extern char *strncpy(char *dest , char const   *src , size_t count ) ;
extern char *strcat(char *dest , char const   *src ) ;
extern char *strncat(char *dest , char const   *src , size_t count ) ;
extern int strcmp(char const   *cs , char const   *ct ) ;
extern int strncmp(char const   *cs , char const   *ct , size_t count ) ;
extern char *strchr(char const   *s , int c ) ;
extern size_t strlen(char const   *s ) ;
__inline static void *__memcpy(void *to , void const   *from , size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  {
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  }
  return (to);
}
}
__inline static void *__constant_memcpy(void *to , void const   *from , size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;

  {
  if (! n) {
    return (to);
  }
  if ((int )n == 1) {
    goto switch_6_1;
  } else {
    if ((int )n == 2) {
      goto switch_6_2;
    } else {
      if ((int )n == 4) {
        goto switch_6_4;
      } else {
        if ((int )n == 3) {
          goto switch_6_3;
        } else {
          if ((int )n == 5) {
            goto switch_6_5;
          } else {
            if ((int )n == 6) {
              goto switch_6_6;
            } else {
              if ((int )n == 8) {
                goto switch_6_8;
              } else {
                if (0) {
                  switch_6_1: /* CIL Label */ 
                  {
                  *((char *)to) = *((char *)from);
                  }
                  return (to);
                  switch_6_2: /* CIL Label */ 
                  {
                  *((short *)to) = *((short *)from);
                  }
                  return (to);
                  switch_6_4: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  }
                  return (to);
                  switch_6_3: /* CIL Label */ 
                  {
                  *((short *)to) = *((short *)from);
                  *((char *)to + 2) = *((char *)from + 2);
                  }
                  return (to);
                  switch_6_5: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  *((char *)to + 4) = *((char *)from + 4);
                  }
                  return (to);
                  switch_6_6: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  *((short *)to + 2) = *((short *)from + 2);
                  }
                  return (to);
                  switch_6_8: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  *((int *)to + 1) = *((int *)from + 1);
                  }
                  return (to);
                } else {
                  switch_6_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
  {
  esi = (long )from;
  edi = (long )to;
  }
  if (n >= 20U) {
    {
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n / 4U),
                         "1" (edi), "2" (esi): "memory");
    }
  } else {
    if (n >= 16U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
    if (n >= 12U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
    if (n >= 8U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
    if (n >= 4U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
  }
  if ((int )(n % 4U) == 0) {
    goto switch_7_0;
  } else {
    if ((int )(n % 4U) == 1) {
      goto switch_7_1;
    } else {
      if ((int )(n % 4U) == 2) {
        goto switch_7_2;
      } else {
        {
        goto switch_7_default;
        if (0) {
          switch_7_0: /* CIL Label */ 
          return (to);
          switch_7_1: /* CIL Label */ 
          {
          __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
          return (to);
          switch_7_2: /* CIL Label */ 
          {
          __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
          return (to);
          switch_7_default: /* CIL Label */ 
          {
          __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi),
                               "1" (esi): "memory");
          }
          return (to);
        } else {
          switch_7_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
extern void *memmove(void *dest , void const   *src , size_t n ) ;
extern void *memchr(void const   *cs , int c , size_t count ) ;
__inline static void *__memset_generic(void *s , char c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
  __asm__  volatile   ("rep\n\t"
                       "stosb": "=&c" (d0), "=&D" (d1): "a" (c), "1" (s), "0" (count): "memory");
  }
  return (s);
}
}
__inline static void *__constant_c_memset(void *s , unsigned long c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
  __asm__  volatile   ("rep ; stosl\n\t"
                       "testb $2,%b3\n\t"
                       "je 1f\n\t"
                       "stosw\n"
                       "1:\ttestb $1,%b3\n\t"
                       "je 2f\n\t"
                       "stosb\n"
                       "2:": "=&c" (d0), "=&D" (d1): "a" (c), "q" (count), "0" (count / 4U),
                       "1" ((long )s): "memory");
  }
  return (s);
}
}
extern size_t strnlen(char const   *s , size_t count ) ;
extern char *strstr(char const   *cs , char const   *ct ) ;
__inline static void *__constant_c_and_count_memset(void *s , unsigned long pattern ,
                                                    size_t count ) 
{ int d0 ;
  int d1 ;
  unsigned long eax ;

  {
  if ((int )count == 0) {
    goto switch_8_0;
  } else {
    if ((int )count == 1) {
      goto switch_8_1;
    } else {
      if ((int )count == 2) {
        goto switch_8_2;
      } else {
        if ((int )count == 3) {
          goto switch_8_3;
        } else {
          if ((int )count == 4) {
            goto switch_8_4;
          } else {
            if (0) {
              switch_8_0: /* CIL Label */ 
              return (s);
              switch_8_1: /* CIL Label */ 
              {
              *((unsigned char *)s) = (unsigned char )(pattern & 255UL);
              }
              return (s);
              switch_8_2: /* CIL Label */ 
              {
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              }
              return (s);
              switch_8_3: /* CIL Label */ 
              {
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              *((unsigned char *)s + 2) = (unsigned char )(pattern & 255UL);
              }
              return (s);
              switch_8_4: /* CIL Label */ 
              {
              *((unsigned long *)s) = pattern;
              }
              return (s);
            } else {
              switch_8_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
  eax = pattern;
  }
  if ((int )(count % 4U) == 0) {
    goto switch_9_0;
  } else {
    if ((int )(count % 4U) == 1) {
      goto switch_9_1;
    } else {
      if ((int )(count % 4U) == 2) {
        goto switch_9_2;
      } else {
        {
        goto switch_9_default;
        if (0) {
          switch_9_0: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_9_1: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_9_2: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_9_default: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
          return (s);
        } else {
          switch_9_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
extern void *memscan(void *addr , int c , size_t size ) ;
extern size_t strlcpy(char * , char const   * , size_t  ) ;
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
extern int strnicmp(char const   * , char const   * , __kernel_size_t  ) ;
extern int strcasecmp(char const   *s1 , char const   *s2 ) ;
extern int strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
extern char *strnchr(char const   * , size_t  , int  ) ;
extern char *strrchr(char const   * , int  ) ;
extern char *strstrip(char * ) ;
extern char *strpbrk(char const   * , char const   * ) ;
extern char *strsep(char ** , char const   * ) ;
extern __kernel_size_t strspn(char const   * , char const   * ) ;
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
extern char *kstrdup(char const   *s , gfp_t gfp ) ;
extern char *kstrndup(char const   *s , size_t len , gfp_t gfp ) ;
extern void *kmemdup(void const   *src , size_t len , gfp_t gfp ) ;
extern char **argv_split(gfp_t gfp , char const   *str , int *argcp ) ;
extern void argv_free(char **argv ) ;
extern bool sysfs_streq(char const   *s1 , char const   *s2 ) ;
extern int vbin_printf(u32 *bin_buf , size_t size , char const   *fmt , va_list args ) ;
extern int bstr_printf(char *buf , size_t size , char const   *fmt , u32 const   *bin_buf ) ;
extern int ( /* format attribute */  bprintf)(u32 *bin_buf , size_t size , char const   *fmt 
                                              , ...) ;
extern ssize_t memory_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
__inline static bool strstarts(char const   *str , char const   *prefix ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen(prefix);
  tmp___0 = strncmp(str, prefix, tmp);
  }
  return ((_Bool )(tmp___0 == 0));
}
}
__inline static void clear_page(void *page ) 
{ 

  {
  {
  __constant_c_and_count_memset(page, 0UL, (unsigned int )(1UL << 12));
  }
  return;
}
}
__inline static void copy_page(void *to , void *from ) 
{ 

  {
  {
  __constant_memcpy(to, (void const   *)from, (unsigned int )(1UL << 12));
  }
  return;
}
}
__inline static void clear_user_page(void *page , unsigned long vaddr , struct page *pg ) 
{ 

  {
  {
  clear_page(page);
  }
  return;
}
}
__inline static void copy_user_page(void *to , void *from , unsigned long vaddr ,
                                    struct page *topage ) 
{ 

  {
  {
  copy_page(to, from);
  }
  return;
}
}
extern bool __virt_addr_valid(unsigned long kaddr ) ;
__inline static int get_order(unsigned long size )  __attribute__((__const__)) ;
__inline static int get_order(unsigned long size ) 
{ int order ;

  {
  {
  size = (size - 1UL) >> 11;
  order = -1;
  }
  {
  while (1) {
    while_10_continue: /* CIL Label */ ;
    {
    size >>= 1;
    order ++;
    }
    if (! size) {
      goto while_10_break;
    }
  }
  while_10_break: /* CIL Label */ ;
  }
  return (order);
}
}
extern bool __vmalloc_start_set ;
__inline static pgd_t native_make_pgd(pgdval_t val ) 
{ pgd_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.pgd = val;
  }
  return (__constr_expr_0);
}
}
__inline static pgdval_t native_pgd_val(pgd_t pgd ) 
{ 

  {
  return (pgd.pgd);
}
}
__inline static pgdval_t pgd_flags(pgd_t pgd ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pgd);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
__inline static int pgd_none(pgd_t pgd ) 
{ 

  {
  return (0);
}
}
__inline static int pgd_present(pgd_t pgd ) 
{ 

  {
  return (1);
}
}
__inline static void pgd_clear(pgd_t *pgd ) 
{ 

  {
  return;
}
}
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address ) 
{ 

  {
  return ((pud_t *)pgd);
}
}
__inline static pudval_t native_pud_val(pud_t pud ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pud.pgd);
  }
  return (tmp);
}
}
__inline static int pud_none(pud_t pud ) 
{ 

  {
  return (0);
}
}
__inline static int pud_present(pud_t pud ) 
{ 

  {
  return (1);
}
}
__inline static void pud_clear(pud_t *pud ) 
{ 

  {
  return;
}
}
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address ) 
{ 

  {
  return ((pmd_t *)pud);
}
}
__inline static void pmd_free(struct mm_struct *mm , pmd_t *pmd ) 
{ 

  {
  return;
}
}
__inline static pmdval_t native_pmd_val(pmd_t pmd ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pmd.pud.pgd);
  }
  return (tmp);
}
}
__inline static pudval_t pud_flags(pud_t pud ) 
{ pudval_t tmp ;

  {
  {
  tmp = native_pud_val(pud);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
__inline static pmdval_t pmd_flags(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = native_pmd_val(pmd);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
__inline static pte_t native_make_pte(pteval_t val ) 
{ pte_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.pte = val;
  }
  return (__constr_expr_0);
}
}
__inline static pteval_t native_pte_val(pte_t pte ) 
{ 

  {
  return (pte.pte);
}
}
__inline static pteval_t pte_flags(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = native_pte_val(pte);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
extern pteval_t __supported_pte_mask ;
extern int nx_enabled ;
extern void set_nx(void) ;
extern pgprot_t pgprot_writecombine(pgprot_t prot ) ;
extern pgprot_t phys_mem_access_prot(struct file *file , unsigned long pfn , unsigned long size ,
                                     pgprot_t vma_prot ) ;
extern int phys_mem_access_prot_allowed(struct file *file , unsigned long pfn , unsigned long size ,
                                        pgprot_t *vma_prot ) ;
extern void set_pte_vaddr(unsigned long vaddr , pte_t pte ) ;
extern void native_pagetable_setup_start(pgd_t *base ) ;
extern void native_pagetable_setup_done(pgd_t *base ) ;
extern void arch_report_meminfo(struct seq_file *m ) ;
extern void update_page_count(int level , unsigned long pages ) ;
extern pte_t *lookup_address(unsigned long address , unsigned int *level ) ;
__inline static unsigned long long native_read_tscp(unsigned int *aux ) 
{ unsigned long low ;
  unsigned long high ;

  {
  {
  __asm__  volatile   (".byte 0x0f,0x01,0xf9": "=a" (low), "=d" (high), "=c" (*aux));
  }
  return ((unsigned long long )low | ((unsigned long long )high << 32));
}
}
__inline static unsigned long long native_read_msr(unsigned int msr ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("rdmsr": "=A" (val): "c" (msr));
  }
  return (val);
}
}
__inline static unsigned long long native_read_msr_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("2: rdmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=r" (*err), "=A" (val): "c" (msr), [fault] "i" (-14));
  }
  return (val);
}
}
__inline static unsigned long long native_read_msr_amd_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("2: rdmsr ; xor %0,%0\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %3,%0 ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": "=r" (*err), "=A" (val): "c" (msr), "D" (2623152186U),
                       "i" (-14));
  }
  return (val);
}
}
__inline static void native_write_msr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
  __asm__  volatile   ("wrmsr": : "c" (msr), "a" (low), "d" (high): "memory");
  }
  return;
}
}
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int err ;

  {
  {
  __asm__  volatile   ("2: wrmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=a" (err): "c" (msr), "0" (low), "d" (high),
                       [fault] "i" (-14): "memory");
  }
  return (err);
}
}
extern unsigned long long native_read_tsc(void) ;
__inline static unsigned long long __native_read_tsc(void) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("rdtsc": "=A" (val));
  }
  return (val);
}
}
__inline static unsigned long long native_read_pmc(int counter ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("rdpmc": "=A" (val): "c" (counter));
  }
  return (val);
}
}
__inline static void wrmsr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
  native_write_msr(msr, low, high);
  }
  return;
}
}
__inline static int wrmsr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int tmp ;

  {
  {
  tmp = native_write_msr_safe(msr, low, high);
  }
  return (tmp);
}
}
__inline static int rdmsrl_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
  *p = native_read_msr_safe(msr, & err);
  }
  return (err);
}
}
__inline static int rdmsrl_amd_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
  *p = native_read_msr_amd_safe(msr, & err);
  }
  return (err);
}
}
extern int rdmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
extern int wrmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
extern int rdmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
extern int wrmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
__inline static void *ERR_PTR(long error ) 
{ 

  {
  return ((void *)error);
}
}
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
  return ((long )ptr);
}
}
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 0xfffff001UL))), 0L);
  }
  return (tmp);
}
}
__inline static void *ERR_CAST(void const   *ptr ) 
{ 

  {
  return ((void *)ptr);
}
}
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored )  __attribute__((__section__(".cpuinit.text"))) ;
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored ) 
{ 

  {
  return;
}
}
__inline static void ds_switch_to(struct task_struct *prev , struct task_struct *next ) 
{ 

  {
  return;
}
}
__inline static void ds_exit_thread(struct task_struct *tsk ) 
{ 

  {
  return;
}
}
extern int register_exec_domain(struct exec_domain * ) ;
extern int unregister_exec_domain(struct exec_domain * ) ;
extern int __set_personality(unsigned long  ) ;
extern int __bitmap_empty(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_full(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_equal(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                          int bits ) ;
extern void __bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                int bits ) ;
extern void __bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                 int shift , int bits ) ;
extern void __bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                int shift , int bits ) ;
extern void __bitmap_and(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_or(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
extern void __bitmap_xor(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_andnot(unsigned long *dst , unsigned long const   *bitmap1 ,
                            unsigned long const   *bitmap2 , int bits ) ;
extern int __bitmap_intersects(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                               int bits ) ;
extern int __bitmap_subset(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
extern int __bitmap_weight(unsigned long const   *bitmap , int bits ) ;
extern int bitmap_scnprintf(char *buf , unsigned int len , unsigned long const   *src ,
                            int nbits ) ;
extern int __bitmap_parse(char const   *buf , unsigned int buflen , int is_user ,
                          unsigned long *dst , int nbits ) ;
extern int bitmap_parse_user(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                             int nbits ) ;
extern int bitmap_scnlistprintf(char *buf , unsigned int len , unsigned long const   *src ,
                                int nbits ) ;
extern int bitmap_parselist(char const   *buf , unsigned long *maskp , int nmaskbits ) ;
extern void bitmap_remap(unsigned long *dst , unsigned long const   *src , unsigned long const   *old ,
                         unsigned long const   *new , int bits ) ;
extern int bitmap_bitremap(int oldbit , unsigned long const   *old , unsigned long const   *new ,
                           int bits ) ;
extern void bitmap_onto(unsigned long *dst , unsigned long const   *orig , unsigned long const   *relmap ,
                        int bits ) ;
extern void bitmap_fold(unsigned long *dst , unsigned long const   *orig , int sz ,
                        int bits ) ;
extern int bitmap_find_free_region(unsigned long *bitmap , int bits , int order ) ;
extern void bitmap_release_region(unsigned long *bitmap , int pos , int order ) ;
extern int bitmap_allocate_region(unsigned long *bitmap , int pos , int order ) ;
extern void bitmap_copy_le(void *dst , unsigned long const   *src , int nbits ) ;
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ int len ;

  {
  {
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
  __constant_c_memset((void *)dst, 0UL, (unsigned int )len);
  }
  return;
}
}
__inline static void bitmap_fill(unsigned long *dst , int nbits ) 
{ size_t nlongs ;
  int len ;

  {
  {
  nlongs = (size_t )((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long )));
  len = (int )((unsigned long )(nlongs - 1U) * sizeof(unsigned long ));
  __constant_c_memset((void *)dst, 4294967295UL, (unsigned int )len);
  }
  if (nbits % 32) {
    {
    *(dst + (nlongs - 1U)) = (1UL << nbits % 32) - 1UL;
    }
  } else {
    {
    *(dst + (nlongs - 1U)) = ~ 0UL;
    }
  }
  return;
}
}
__inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
                                 int nbits ) 
{ int len ;

  {
  {
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
  __memcpy((void *)dst, (void const   *)src, (unsigned int )len);
  }
  return;
}
}
__inline static void bitmap_and(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_and(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_or(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_or(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_xor(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_xor(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_andnot(unsigned long *dst , unsigned long const   *src1 ,
                                   unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_andnot(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                       int nbits ) 
{ unsigned long tmp ;

  {
  {
  __bitmap_complement(dst, src, nbits);
  }
  return;
}
}
__inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
                                 int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_equal(src1, src2, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_intersects(unsigned long const   *src1 , unsigned long const   *src2 ,
                                      int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = __bitmap_intersects(src1, src2, nbits);
  }
  return (tmp___0);
}
}
__inline static int bitmap_subset(unsigned long const   *src1 , unsigned long const   *src2 ,
                                  int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_subset(src1, src2, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_empty(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_empty(src, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_full(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_full(src, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_weight(src, nbits);
  }
  return (tmp___1);
}
}
__inline static void bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                        int n , int nbits ) 
{ 

  {
  {
  __bitmap_shift_right(dst, src, n, nbits);
  }
  return;
}
}
__inline static void bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                       int n , int nbits ) 
{ unsigned long tmp ;

  {
  {
  __bitmap_shift_left(dst, src, n, nbits);
  }
  return;
}
}
__inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
                                 int nmaskbits ) 
{ int tmp ;

  {
  {
  tmp = __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
  }
  return (tmp);
}
}
extern cpumask_t _unused_cpumask_arg_ ;
__inline static void __cpu_set(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
  set_bit((unsigned int )cpu, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __cpu_clear(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
  clear_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __cpus_setall(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_fill(dstp->bits, nbits);
  }
  return;
}
}
__inline static void __cpus_clear(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_zero(dstp->bits, nbits);
  }
  return;
}
}
__inline static int __cpu_test_and_set(int cpu , cpumask_t *addr ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(cpu, (unsigned long volatile   *)(addr->bits));
  }
  return (tmp);
}
}
__inline static void __cpus_and(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __cpus_or(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ 

  {
  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
  return;
}
}
__inline static void __cpus_xor(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __cpus_andnot(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                   int nbits ) 
{ 

  {
  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  }
  return;
}
}
__inline static void __cpus_complement(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int nbits ) 
{ 

  {
  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
  return;
}
}
__inline static int __cpus_equal(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                 int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_intersects(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                      int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_subset(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_empty(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_full(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_weight(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static void __cpus_shift_right(cpumask_t *dstp , cpumask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static void __cpus_shift_left(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static int __check_is_bitmap(unsigned long const   *bitmap ) 
{ 

  {
  return (1);
}
}
extern unsigned long const   cpu_bit_bitmap[33][((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
__inline static struct cpumask  const  *get_cpu_mask(unsigned int cpu ) 
{ unsigned long const   *p ;
  int tmp ;

  {
  {
  p = cpu_bit_bitmap[1U + cpu % 32U];
  p -= cpu / 32U;
  }
  return ((struct cpumask  const  *)((struct cpumask *)p));
}
}
__inline static int __cpu_remap(int oldbit , cpumask_t const   *oldp , cpumask_t const   *newp ,
                                int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
  return (tmp);
}
}
__inline static void __cpus_remap(cpumask_t *dstp , cpumask_t const   *srcp , cpumask_t const   *oldp ,
                                  cpumask_t const   *newp , int nbits ) 
{ 

  {
  {
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
  return;
}
}
__inline static void __cpus_onto(cpumask_t *dstp , cpumask_t const   *origp , cpumask_t const   *relmapp ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
  return;
}
}
__inline static void __cpus_fold(cpumask_t *dstp , cpumask_t const   *origp , int sz ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
  return;
}
}
extern int nr_cpu_ids ;
extern int __first_cpu(cpumask_t const   *srcp ) ;
extern int __next_cpu(int n , cpumask_t const   *srcp ) ;
extern int __any_online_cpu(cpumask_t const   *mask ) ;
extern struct cpumask  const  * const  cpu_possible_mask ;
extern struct cpumask  const  * const  cpu_online_mask ;
extern struct cpumask  const  * const  cpu_present_mask ;
extern struct cpumask  const  * const  cpu_active_mask ;
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 

  {
  return (cpu);
}
}
__inline static unsigned int cpumask_first(struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  {
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 8UL);
  }
  return ((unsigned int )tmp);
}
}
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  if (n != -1) {
    {
    cpumask_check((unsigned int )n);
    }
  }
  {
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
  return ((unsigned int )tmp);
}
}
__inline static unsigned int cpumask_next_zero(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  if (n != -1) {
    {
    cpumask_check((unsigned int )n);
    }
  }
  {
  tmp = find_next_zero_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
  return ((unsigned int )tmp);
}
}
extern int cpumask_next_and(int n , struct cpumask  const  * , struct cpumask  const  * ) ;
extern int cpumask_any_but(struct cpumask  const  *mask , unsigned int cpu ) ;
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_check(cpu);
  set_bit(tmp, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void cpumask_clear_cpu(int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_check((unsigned int )cpu);
  clear_bit((int )tmp, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static int cpumask_test_and_set_cpu(int cpu , struct cpumask *cpumask ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
  tmp = cpumask_check((unsigned int )cpu);
  tmp___0 = test_and_set_bit((int )tmp, (unsigned long volatile   *)(cpumask->bits));
  }
  return (tmp___0);
}
}
__inline static void cpumask_setall(struct cpumask *dstp ) 
{ 

  {
  {
  bitmap_fill(dstp->bits, 8);
  }
  return;
}
}
__inline static void cpumask_clear(struct cpumask *dstp ) 
{ 

  {
  {
  bitmap_zero(dstp->bits, 8);
  }
  return;
}
}
__inline static void cpumask_and(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             8);
  }
  return;
}
}
__inline static void cpumask_or(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            8);
  }
  return;
}
}
__inline static void cpumask_xor(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             8);
  }
  return;
}
}
__inline static void cpumask_andnot(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                    struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                8);
  }
  return;
}
}
__inline static void cpumask_complement(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
  return;
}
}
__inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     8);
  }
  return ((_Bool )tmp);
}
}
__inline static bool cpumask_intersects(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          8);
  }
  return ((_Bool )tmp);
}
}
__inline static int cpumask_subset(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      8);
  }
  return (tmp);
}
}
__inline static bool cpumask_empty(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), 8);
  }
  return ((_Bool )tmp);
}
}
__inline static bool cpumask_full(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), 8);
  }
  return ((_Bool )tmp);
}
}
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), 8);
  }
  return ((unsigned int )tmp);
}
}
__inline static void cpumask_shift_right(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                         int n ) 
{ 

  {
  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
  return;
}
}
__inline static void cpumask_shift_left(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                        int n ) 
{ 

  {
  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
  return;
}
}
__inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
  bitmap_copy(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
  return;
}
}
__inline static int cpumask_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         8);
  }
  return (tmp);
}
}
__inline static int cpumask_parse_user(char const   *buf , int len , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, 8);
  }
  return (tmp);
}
}
__inline static int cpulist_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             8);
  }
  return (tmp);
}
}
__inline static int cpulist_parse(char const   *buf , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parselist(buf, dstp->bits, 8);
  }
  return (tmp);
}
}
__inline static size_t cpumask_size(void) 
{ 

  {
  return ((unsigned int )((((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long )));
}
}
__inline static bool alloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
  return ((_Bool)1);
}
}
__inline static bool alloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
  return ((_Bool)1);
}
}
__inline static bool zalloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
  {
  cpumask_clear(*mask);
  }
  return ((_Bool)1);
}
}
__inline static bool zalloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
  {
  cpumask_clear(*mask);
  }
  return ((_Bool)1);
}
}
__inline static void alloc_bootmem_cpumask_var(cpumask_var_t *mask ) 
{ 

  {
  return;
}
}
__inline static void free_cpumask_var(struct cpumask *mask ) 
{ 

  {
  return;
}
}
extern unsigned long const   cpu_all_bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
extern void set_cpu_possible(unsigned int cpu , bool possible ) ;
extern void set_cpu_present(unsigned int cpu , bool present ) ;
extern void set_cpu_online(unsigned int cpu , bool online ) ;
extern void set_cpu_active(unsigned int cpu , bool active ) ;
extern void init_cpu_present(struct cpumask  const  *src ) ;
extern void init_cpu_possible(struct cpumask  const  *src ) ;
extern void init_cpu_online(struct cpumask  const  *src ) ;
__inline static void *current_text_addr(void) 
{ void *pc ;

  {
  {
  __asm__  volatile   ("mov $1f, %0; 1:": "=r" (pc));
  }
  return (pc);
}
}
extern struct cpuinfo_x86 boot_cpu_data ;
extern struct cpuinfo_x86 new_cpu_data ;
extern struct tss_struct doublefault_tss ;
extern __u32 cleared_cpu_caps[9] ;
extern struct cpuinfo_x86 per_cpu__cpu_info  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
extern struct seq_operations  const  cpuinfo_op ;
__inline static int hlt_works(int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_info));
  }
  return ((int )((struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[cpu]))->hlt_works_ok);
}
}
extern void cpu_detect(struct cpuinfo_x86 *c ) ;
extern struct pt_regs *idle_regs(struct pt_regs * ) ;
extern void early_cpu_init(void) ;
extern void identify_boot_cpu(void) ;
extern void identify_secondary_cpu(struct cpuinfo_x86 * ) ;
extern void print_cpu_info(struct cpuinfo_x86 * ) ;
extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c ) ;
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c ) ;
extern unsigned short num_cache_leaves ;
extern void detect_extended_topology(struct cpuinfo_x86 *c ) ;
extern void detect_ht(struct cpuinfo_x86 *c ) ;
__inline static void native_cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                                  unsigned int *edx ) 
{ 

  {
  {
  __asm__  ("cpuid": "=a" (*eax), "=b" (*ebx), "=c" (*ecx), "=d" (*edx): "0" (*eax),
            "2" (*ecx));
  }
  return;
}
}
__inline static void load_cr3(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
extern struct tss_struct per_cpu__init_tss  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
extern unsigned int xstate_size ;
extern void free_thread_xstate(struct task_struct * ) ;
extern struct kmem_cache *task_xstate_cachep ;
__inline static unsigned long native_get_debugreg(int regno ) 
{ unsigned long val ;

  {
  {
  val = 0UL;
  }
  if (regno == 0) {
    goto switch_11_0;
  } else {
    if (regno == 1) {
      goto switch_11_1;
    } else {
      if (regno == 2) {
        goto switch_11_2;
      } else {
        if (regno == 3) {
          goto switch_11_3;
        } else {
          if (regno == 6) {
            goto switch_11_6;
          } else {
            if (regno == 7) {
              goto switch_11_7;
            } else {
              {
              goto switch_11_default;
              if (0) {
                switch_11_0: /* CIL Label */ 
                {
                __asm__  ("mov %%db0, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_1: /* CIL Label */ 
                {
                __asm__  ("mov %%db1, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_2: /* CIL Label */ 
                {
                __asm__  ("mov %%db2, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_3: /* CIL Label */ 
                {
                __asm__  ("mov %%db3, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_6: /* CIL Label */ 
                {
                __asm__  ("mov %%db6, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_7: /* CIL Label */ 
                {
                __asm__  ("mov %%db7, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_default: /* CIL Label */ 
                {

                }
                {
                while (1) {
                  while_12_continue: /* CIL Label */ ;
                  {
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (497), "i" (sizeof(struct bug_entry )));
                  }
                  {
                  while (1) {
                    while_13_continue: /* CIL Label */ ;
                  }
                  while_13_break: /* CIL Label */ ;
                  }
                  goto while_12_break;
                }
                while_12_break: /* CIL Label */ ;
                }
              } else {
                switch_11_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
  return (val);
}
}
__inline static void native_set_debugreg(int regno , unsigned long value ) 
{ 

  {
  if (regno == 0) {
    goto switch_14_0;
  } else {
    if (regno == 1) {
      goto switch_14_1;
    } else {
      if (regno == 2) {
        goto switch_14_2;
      } else {
        if (regno == 3) {
          goto switch_14_3;
        } else {
          if (regno == 6) {
            goto switch_14_6;
          } else {
            if (regno == 7) {
              goto switch_14_7;
            } else {
              {
              goto switch_14_default;
              if (0) {
                switch_14_0: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db0": : "r" (value));
                }
                goto switch_14_break;
                switch_14_1: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db1": : "r" (value));
                }
                goto switch_14_break;
                switch_14_2: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db2": : "r" (value));
                }
                goto switch_14_break;
                switch_14_3: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db3": : "r" (value));
                }
                goto switch_14_break;
                switch_14_6: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db6": : "r" (value));
                }
                goto switch_14_break;
                switch_14_7: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db7": : "r" (value));
                }
                goto switch_14_break;
                switch_14_default: /* CIL Label */ 
                {

                }
                {
                while (1) {
                  while_15_continue: /* CIL Label */ ;
                  {
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (524), "i" (sizeof(struct bug_entry )));
                  }
                  {
                  while (1) {
                    while_16_continue: /* CIL Label */ ;
                  }
                  while_16_break: /* CIL Label */ ;
                  }
                  goto while_15_break;
                }
                while_15_break: /* CIL Label */ ;
                }
              } else {
                switch_14_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
__inline static void native_set_iopl_mask(unsigned int mask ) 
{ unsigned int reg ;

  {
  {
  __asm__  volatile   ("pushfl;"
                       "popl %0;"
                       "andl %1, %0;"
                       "orl %2, %0;"
                       "pushl %0;"
                       "popfl": "=&r" (reg): "i" (~ 12288), "r" (mask));
  }
  return;
}
}
__inline static void native_load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ long tmp ;

  {
  {
  tss->x86_tss.sp0 = thread->sp0;
  tmp = __builtin_expect((long )(! (! ((unsigned long )tss->x86_tss.ss1 != thread->sysenter_cs))),
                         0L);
  }
  if (tmp) {
    {
    tss->x86_tss.ss1 = (unsigned short )thread->sysenter_cs;
    wrmsr(372U, (unsigned int )thread->sysenter_cs, 0U);
    }
  }
  return;
}
}
__inline static void native_swapgs(void) 
{ 

  {
  return;
}
}
__inline static void load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ 

  {
  {
  native_load_sp0(tss, thread);
  }
  return;
}
}
extern unsigned long mmu_cr4_features ;
__inline static void set_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4((unsigned long )cr4);
  }
  return;
}
}
extern int kernel_thread(int (*fn)(void * ) , void *arg , unsigned long flags ) ;
extern void release_thread(struct task_struct * ) ;
extern void prepare_to_copy(struct task_struct *tsk ) ;
extern unsigned long get_wchan(struct task_struct *p ) ;
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
  *eax = op;
  *ecx = 0U;
  native_cpuid(eax, ebx, ecx, edx);
  }
  return;
}
}
__inline static void cpuid_count(unsigned int op , int count , unsigned int *eax ,
                                 unsigned int *ebx , unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
  *eax = op;
  *ecx = (unsigned int )count;
  native_cpuid(eax, ebx, ecx, edx);
  }
  return;
}
}
__inline static unsigned int cpuid_eax(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (eax);
}
}
__inline static unsigned int cpuid_ebx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (ebx);
}
}
__inline static unsigned int cpuid_ecx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (ecx);
}
}
__inline static unsigned int cpuid_edx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (edx);
}
}
__inline static void rep_nop(void) 
{ 

  {
  {
  __asm__  volatile   ("rep; nop": : : "memory");
  }
  return;
}
}
__inline static void cpu_relax(void) 
{ 

  {
  {
  rep_nop();
  }
  return;
}
}
__inline static void sync_core(void) 
{ int tmp ;

  {
  {
  __asm__  volatile   ("cpuid": "=a" (tmp): "0" (1): "ebx", "ecx", "edx", "memory");
  }
  return;
}
}
__inline static void __monitor(void const   *eax , unsigned long ecx , unsigned long edx ) 
{ 

  {
  {
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc8;": : "a" (eax), "c" (ecx), "d" (edx));
  }
  return;
}
}
__inline static void __mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
  return;
}
}
__inline static void __sti_mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
  while (1) {
    while_17_continue: /* CIL Label */ ;
    goto while_17_break;
  }
  while_17_break: /* CIL Label */ ;
  }
  {
  __asm__  volatile   ("sti; .byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
  return;
}
}
extern void mwait_idle_with_hints(unsigned long eax , unsigned long ecx ) ;
extern void select_idle_routine(struct cpuinfo_x86  const  *c ) ;
extern void init_c1e_mask(void) ;
extern unsigned long boot_option_idle_override ;
extern unsigned long idle_halt ;
extern unsigned long idle_nomwait ;
__inline static void wbinvd_halt(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
  if (19 >> 5 == 0) {
    if ((1UL << 19) & (unsigned long )(1 | (1 << 15))) {
      {
      tmp___1 = 1;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    if (19 >> 5 == 1) {
      goto _L___4;
    } else {
      _L___4: /* CIL Label */ 
      if (19 >> 5 == 2) {
        goto _L___3;
      } else {
        _L___3: /* CIL Label */ 
        if (19 >> 5 == 3) {
          goto _L___2;
        } else {
          _L___2: /* CIL Label */ 
          if (19 >> 5 == 4) {
            goto _L___1;
          } else {
            _L___1: /* CIL Label */ 
            if (19 >> 5 == 5) {
              goto _L___0;
            } else {
              _L___0: /* CIL Label */ 
              if (19 >> 5 == 6) {
                goto _L;
              } else {
                _L: /* CIL Label */ 
                if (19 >> 5 == 7) {
                  {
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                  tmp___1 = tmp;
                  }
                } else {
                  {
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                  tmp___1 = tmp;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (tmp___1) {
    {
    __asm__  volatile   ("cli; wbinvd; 1: hlt; jmp 1b": : : "memory");
    }
  } else {
    {
    while (1) {
      while_18_continue: /* CIL Label */ ;
      {
      halt();
      }
    }
    while_18_break: /* CIL Label */ ;
    }
  }
  return;
}
}
extern void enable_sep_cpu(void) ;
extern int sysenter_setup(void) ;
extern struct desc_ptr early_gdt_descr ;
extern void cpu_set_gdt(int  ) ;
extern void switch_to_new_gdt(int  ) ;
extern void load_percpu_segment(int  ) ;
extern void cpu_init(void) ;
__inline static unsigned long get_debugctlmsr(void) 
{ unsigned long debugctlmsr ;
  unsigned long long tmp ;

  {
  {
  debugctlmsr = 0UL;
  tmp = native_read_msr(473U);
  debugctlmsr = (unsigned long )tmp;
  }
  return (debugctlmsr);
}
}
__inline static void update_debugctlmsr(unsigned long debugctlmsr ) 
{ 

  {
  {
  native_write_msr(473U, (unsigned int )((unsigned long long )debugctlmsr), (unsigned int )((unsigned long long )debugctlmsr >> 32));
  }
  return;
}
}
extern unsigned int machine_id ;
extern unsigned int machine_submodel_id ;
extern unsigned int BIOS_revision ;
extern int bootloader_type ;
extern char ignore_fpu_irq ;
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
  return;
}
}
__inline static void prefetchw(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchw (%1)"
                       "\n664:\n"
                       ".previous": : "i" (63), "r" (x));
  }
  return;
}
}
__inline static void spin_lock_prefetch(void const   *x ) 
{ 

  {
  {
  prefetchw(x);
  }
  return;
}
}
extern unsigned long thread_saved_pc(struct task_struct *tsk ) ;
extern void start_thread(struct pt_regs *regs , unsigned long new_ip , unsigned long new_sp ) ;
extern int get_tsc_mode(unsigned long adr ) ;
extern int set_tsc_mode(unsigned int val ) ;
__inline static void prefetch_range(void *addr , size_t len ) 
{ char *cp ;
  char *end ;

  {
  {
  end = (char *)(addr + len);
  cp = (char *)addr;
  }
  {
  while (1) {
    while_19_continue: /* CIL Label */ ;
    if (! ((unsigned long )cp < (unsigned long )end)) {
      goto while_19_break;
    }
    {
    prefetch((void const   *)cp);
    cp += 4 * (1 << 5);
    }
  }
  while_19_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  {
  list->next = list;
  list->prev = list;
  }
  return;
}
}
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  }
  return;
}
}
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head, head->next);
  }
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = prev;
  prev->next = next;
  }
  return;
}
}
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static void list_replace(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
  new->next = old->next;
  (new->next)->prev = new;
  new->prev = old->prev;
  (new->prev)->next = new;
  }
  return;
}
}
__inline static void list_replace_init(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
  list_replace(old, new);
  INIT_LIST_HEAD(old);
  }
  return;
}
}
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  INIT_LIST_HEAD(entry);
  }
  return;
}
}
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
  __list_del(list->prev, list->next);
  list_add(list, head);
  }
  return;
}
}
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
  __list_del(list->prev, list->next);
  list_add_tail(list, head);
  }
  return;
}
}
__inline static int list_is_last(struct list_head  const  *list , struct list_head  const  *head ) 
{ 

  {
  return ((unsigned long )list->next == (unsigned long )head);
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((unsigned long )head->next == (unsigned long )head);
}
}
__inline static int list_empty_careful(struct list_head  const  *head ) 
{ struct list_head *next ;
  int tmp ;

  {
  {
  next = (struct list_head *)head->next;
  }
  if ((unsigned long )next == (unsigned long )head) {
    if ((unsigned long )next == (unsigned long )head->prev) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int list_is_singular(struct list_head  const  *head ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = list_empty(head);
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    if ((unsigned long )head->next == (unsigned long )head->prev) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static void __list_cut_position(struct list_head *list , struct list_head *head ,
                                         struct list_head *entry ) 
{ struct list_head *new_first ;

  {
  {
  new_first = entry->next;
  list->next = head->next;
  (list->next)->prev = list;
  list->prev = entry;
  entry->next = list;
  head->next = new_first;
  new_first->prev = head;
  }
  return;
}
}
__inline static void list_cut_position(struct list_head *list , struct list_head *head ,
                                       struct list_head *entry ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = list_empty((struct list_head  const  *)head);
  }
  if (tmp) {
    return;
  }
  {
  tmp___0 = list_is_singular((struct list_head  const  *)head);
  }
  if (tmp___0) {
    if ((unsigned long )head->next != (unsigned long )entry) {
      if ((unsigned long )head != (unsigned long )entry) {
        return;
      }
    }
  }
  if ((unsigned long )entry == (unsigned long )head) {
    {
    INIT_LIST_HEAD(list);
    }
  } else {
    {
    __list_cut_position(list, head, entry);
    }
  }
  return;
}
}
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;

  {
  {
  first = (struct list_head *)list->next;
  last = (struct list_head *)list->prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
  }
  return;
}
}
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty(list);
  }
  if (! tmp) {
    {
    __list_splice(list, head, head->next);
    }
  }
  return;
}
}
__inline static void list_splice_tail(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)list);
  }
  if (! tmp) {
    {
    __list_splice((struct list_head  const  *)list, head->prev, head);
    }
  }
  return;
}
}
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)list);
  }
  if (! tmp) {
    {
    __list_splice((struct list_head  const  *)list, head, head->next);
    INIT_LIST_HEAD(list);
    }
  }
  return;
}
}
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)list);
  }
  if (! tmp) {
    {
    __list_splice((struct list_head  const  *)list, head->prev, head);
    INIT_LIST_HEAD(list);
    }
  }
  return;
}
}
__inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
{ 

  {
  {
  h->next = (struct hlist_node *)((void *)0);
  h->pprev = (struct hlist_node **)((void *)0);
  }
  return;
}
}
__inline static int hlist_unhashed(struct hlist_node  const  *h ) 
{ 

  {
  return (! h->pprev);
}
}
__inline static int hlist_empty(struct hlist_head  const  *h ) 
{ 

  {
  return (! h->first);
}
}
__inline static void __hlist_del(struct hlist_node *n ) 
{ struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
  {
  next = n->next;
  pprev = n->pprev;
  *pprev = next;
  }
  if (next) {
    {
    next->pprev = pprev;
    }
  }
  return;
}
}
__inline static void hlist_del(struct hlist_node *n ) 
{ 

  {
  {
  __hlist_del(n);
  n->next = (struct hlist_node *)((void *)1048832);
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_del_init(struct hlist_node *n ) 
{ int tmp ;

  {
  {
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
  if (! tmp) {
    {
    __hlist_del(n);
    INIT_HLIST_NODE(n);
    }
  }
  return;
}
}
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
  first = h->first;
  n->next = first;
  }
  if (first) {
    {
    first->pprev = & n->next;
    }
  }
  {
  h->first = n;
  n->pprev = & h->first;
  }
  return;
}
}
__inline static void hlist_add_before(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
  n->pprev = next->pprev;
  n->next = next;
  next->pprev = & n->next;
  *(n->pprev) = n;
  }
  return;
}
}
__inline static void hlist_add_after(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
  next->next = n->next;
  n->next = next;
  next->pprev = & n->next;
  }
  if (next->next) {
    {
    (next->next)->pprev = & next->next;
    }
  }
  return;
}
}
__inline static void hlist_move_list(struct hlist_head *old , struct hlist_head *new ) 
{ 

  {
  {
  new->first = old->first;
  }
  if (new->first) {
    {
    (new->first)->pprev = & new->first;
    }
  }
  {
  old->first = (struct hlist_node *)((void *)0);
  }
  return;
}
}
extern long do_no_restart_syscall(struct restart_block *parm ) ;
__inline static void atomic_add(int i , atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (v->counter): "ir" (i));
  }
  return;
}
}
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %1,%0": "+m" (v->counter): "ir" (i));
  }
  return;
}
}
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %2,%0; sete %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static void atomic_inc(atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (v->counter));
  }
  return;
}
}
__inline static void atomic_dec(atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0": "+m" (v->counter));
  }
  return;
}
}
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int atomic_inc_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int atomic_add_negative(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %2,%0; sets %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ int __i ;

  {
  {
  __i = i;
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddl %0, %1": "+r" (i), "+m" (v->counter): : "memory");
  }
  return (i + __i);
}
}
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ int tmp ;

  {
  {
  tmp = atomic_add_return(- i, v);
  }
  return (tmp);
}
}
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ int c ;
  int old ;
  long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
  c = (int )v->counter;
  }
  {
  while (1) {
    while_20_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (c == u))), 0L);
    }
    if (tmp) {
      goto while_20_break;
    }
    {
    tmp___0 = __cmpxchg((void volatile   *)(& v->counter), (unsigned long )c, (unsigned long )(c + a),
                        (int )sizeof(v->counter));
    old = (int )((int volatile   )tmp___0);
    tmp___1 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
    if (tmp___1) {
      goto while_20_break;
    }
    {
    c = old;
    }
  }
  while_20_break: /* CIL Label */ ;
  }
  return (c != u);
}
}
__inline static long atomic_long_read(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  }
  return ((long )v->counter);
}
}
__inline static void atomic_long_set(atomic_long_t *l , long i ) 
{ atomic_t *v ;

  {
  {
  v = l;
  v->counter = (int volatile   )i;
  }
  return;
}
}
__inline static void atomic_long_inc(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_inc(v);
  }
  return;
}
}
__inline static void atomic_long_dec(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_dec(v);
  }
  return;
}
}
__inline static void atomic_long_add(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_add((int )i, v);
  }
  return;
}
}
__inline static void atomic_long_sub(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_sub((int )i, v);
  }
  return;
}
}
__inline static int atomic_long_sub_and_test(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_sub_and_test((int )i, v);
  }
  return (tmp);
}
}
__inline static int atomic_long_dec_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_dec_and_test(v);
  }
  return (tmp);
}
}
__inline static int atomic_long_inc_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_inc_and_test(v);
  }
  return (tmp);
}
}
__inline static int atomic_long_add_negative(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_negative((int )i, v);
  }
  return (tmp);
}
}
__inline static long atomic_long_add_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_return((int )i, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_sub_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_sub_return((int )i, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_inc_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_return(1, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_dec_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_sub_return(1, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_add_unless(atomic_long_t *l , long a , long u ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_unless(v, (int )a, (int )u);
  }
  return ((long )tmp);
}
}
register unsigned long current_stack_pointer  __asm__("esp")   ;
__inline static struct thread_info *current_thread_info(void) 
{ 

  {
  return ((struct thread_info *)(current_stack_pointer & ~ (((1UL << 12) << 1) - 1UL)));
}
}
__inline static void set_restore_sigmask(void) 
{ struct thread_info *ti ;
  struct thread_info *tmp ;

  {
  {
  tmp = current_thread_info();
  ti = tmp;
  ti->status |= 8U;
  set_bit(2U, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return;
}
}
extern void arch_task_cache_init(void) ;
extern void free_thread_info(struct thread_info *ti ) ;
extern int arch_dup_task_struct(struct task_struct *dst , struct task_struct *src ) ;
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
  set_bit((unsigned int )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return;
}
}
__inline static void clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
  clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return;
}
}
__inline static int test_and_set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return (tmp);
}
}
__inline static int test_and_clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return (tmp);
}
}
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
  }
  return (tmp___0);
}
}
extern void local_bh_disable(void) ;
extern void _local_bh_enable(void) ;
extern void local_bh_enable(void) ;
extern void local_bh_enable_ip(unsigned long ip ) ;
extern void early_init_irq_lock_class(void) ;
extern int generic__raw_read_trylock(raw_rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
__inline static void __ticket_spin_lock(raw_spinlock_t *lock ) 
{ short inc ;

  {
  {
  inc = (short)256;
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddw %w0, %1\n"
                       "1:\t"
                       "cmpb %h0, %b0\n\t"
                       "je 2f\n\t"
                       "rep ; nop\n\t"
                       "movb %1, %b0\n\t"
                       "jmp 1b\n"
                       "2:": "+Q" (inc), "+m" (lock->slock): : "memory", "cc");
  }
  return;
}
}
__inline static int __ticket_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;
  int new ;

  {
  {
  __asm__  volatile   ("movzwl %2, %0\n\t"
                       "cmpb %h0,%b0\n\t"
                       "leal 0x100(%"
                       "k"
                       "0), %1\n\t"
                       "jne 1f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchgw %w1,%2\n\t"
                       "1:"
                       "sete %b1\n\t"
                       "movzbl %b1,%0\n\t": "=&a" (tmp), "=&q" (new), "+m" (lock->slock): : "memory",
                       "cc");
  }
  return (tmp);
}
}
__inline static void __ticket_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
  __asm__  volatile   ("incb %0": "+m" (lock->slock): : "memory", "cc");
  }
  return;
}
}
__inline static int __ticket_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
  return (! (! (((tmp >> 8) ^ tmp) & ((1 << 8) - 1))));
}
}
__inline static int __ticket_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
  return ((((tmp >> 8) - tmp) & ((1 << 8) - 1)) > 1);
}
}
__inline static int __raw_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = __ticket_spin_is_locked(lock);
  }
  return (tmp);
}
}
__inline static int __raw_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = __ticket_spin_is_contended(lock);
  }
  return (tmp);
}
}
__inline static void __raw_spin_lock(raw_spinlock_t *lock ) 
{ 

  {
  {
  __ticket_spin_lock(lock);
  }
  return;
}
}
__inline static int __raw_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = __ticket_spin_trylock(lock);
  }
  return (tmp);
}
}
__inline static void __raw_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
  __ticket_spin_unlock(lock);
  }
  return;
}
}
__inline static void __raw_spin_lock_flags(raw_spinlock_t *lock , unsigned long flags ) 
{ 

  {
  {
  __raw_spin_lock(lock);
  }
  return;
}
}
__inline static void __raw_spin_unlock_wait(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
    tmp = __raw_spin_is_locked(lock);
    }
    if (! tmp) {
      goto while_21_break;
    }
    {
    cpu_relax();
    }
  }
  while_21_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int __raw_read_can_lock(raw_rwlock_t *lock ) 
{ 

  {
  return ((int )lock->lock > 0);
}
}
__inline static int __raw_write_can_lock(raw_rwlock_t *lock ) 
{ 

  {
  return (lock->lock == 16777216U);
}
}
__inline static void __raw_read_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl $1,(%0)\n\t"
                       "jns 1f\n"
                       "call __read_lock_failed\n\t"
                       "1:\n": : "a" (rw): "memory");
  }
  return;
}
}
__inline static void __raw_write_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl %1,(%0)\n\t"
                       "jz 1f\n"
                       "call __write_lock_failed\n\t"
                       "1:\n": : "a" (rw), "i" (16777216): "memory");
  }
  return;
}
}
__inline static int __raw_read_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
  count = (atomic_t *)lock;
  tmp = atomic_sub_return(1, count);
  }
  if (tmp >= 0) {
    return (1);
  }
  {
  atomic_inc(count);
  }
  return (0);
}
}
__inline static int __raw_write_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
  count = (atomic_t *)lock;
  tmp = atomic_sub_and_test(16777216, count);
  }
  if (tmp) {
    return (1);
  }
  {
  atomic_add(16777216, count);
  }
  return (0);
}
}
__inline static void __raw_read_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (rw->lock): : "memory");
  }
  return;
}
}
__inline static void __raw_write_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1, %0": "+m" (rw->lock): "i" (16777216): "memory");
  }
  return;
}
}
extern int in_lock_functions(unsigned long addr ) ;
extern void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_nest_lock(spinlock_t *lock , struct lockdep_map *map )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _spin_lock_irqsave(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _spin_lock_irqsave_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _read_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _write_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _spin_trylock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _read_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _write_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _spin_trylock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern int _atomic_dec_and_lock(atomic_t *atomic , spinlock_t *lock ) ;
__inline static void write_seqlock(seqlock_t *sl ) 
{ 

  {
  {
  _spin_lock(& sl->lock);
  (sl->sequence) ++;
  __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
__inline static void write_sequnlock(seqlock_t *sl ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  (sl->sequence) ++;
  }
  {
  while (1) {
    while_22_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& sl->lock.raw_lock);
    }
    goto while_22_break;
  }
  while_22_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int write_tryseqlock(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  {
  tmp = _spin_trylock(& sl->lock);
  ret = tmp;
  }
  if (ret) {
    {
    (sl->sequence) ++;
    __asm__  volatile   ("": : : "memory");
    }
  }
  return (ret);
}
}
__inline static unsigned int read_seqbegin(seqlock_t const   *sl ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
  ret = (unsigned int )sl->sequence;
  __asm__  volatile   ("": : : "memory");
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
  if (tmp) {
    {
    cpu_relax();
    }
    goto repeat;
  }
  return (ret);
}
}
__inline static int read_seqretry(seqlock_t const   *sl , unsigned int start ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  }
  return (sl->sequence != (unsigned int const   )start);
}
}
__inline static unsigned int read_seqcount_begin(seqcount_t const   *s ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
  ret = (unsigned int )s->sequence;
  __asm__  volatile   ("": : : "memory");
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
  if (tmp) {
    {
    cpu_relax();
    }
    goto repeat;
  }
  return (ret);
}
}
__inline static int read_seqcount_retry(seqcount_t const   *s , unsigned int start ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  }
  return (s->sequence != (unsigned int const   )start);
}
}
__inline static void write_seqcount_begin(seqcount_t *s ) 
{ 

  {
  {
  (s->sequence) ++;
  __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
__inline static void write_seqcount_end(seqcount_t *s ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  (s->sequence) ++;
  }
  return;
}
}
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
extern s64 div_s64_rem(s64 dividend , s32 divisor , s32 *remainder ) ;
extern u64 div64_u64(u64 dividend , u64 divisor ) ;
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static s64 div_s64(s64 dividend , s32 divisor ) 
{ s32 remainder ;
  s64 tmp ;

  {
  {
  tmp = div_s64_rem(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
extern u32 iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) ;
__inline static u32 __iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) 
{ u32 ret ;

  {
  {
  ret = (u32 )0;
  }
  {
  while (1) {
    while_23_continue: /* CIL Label */ ;
    if (! (dividend >= (u64 )divisor)) {
      goto while_23_break;
    }
    {
    __asm__  ("": "+rm" (dividend));
    dividend -= (u64 )divisor;
    ret ++;
    }
  }
  while_23_break: /* CIL Label */ ;
  }
  {
  *remainder = dividend;
  }
  return (ret);
}
}
extern struct timezone sys_tz ;
__inline static int timespec_equal(struct timespec  const  *a , struct timespec  const  *b ) 
{ int tmp ;

  {
  if (a->tv_sec == b->tv_sec) {
    if (a->tv_nsec == b->tv_nsec) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 

  {
  if (lhs->tv_sec < rhs->tv_sec) {
    return (-1);
  }
  if (lhs->tv_sec > rhs->tv_sec) {
    return (1);
  }
  return ((int )(lhs->tv_nsec - rhs->tv_nsec));
}
}
__inline static int timeval_compare(struct timeval  const  *lhs , struct timeval  const  *rhs ) 
{ 

  {
  if (lhs->tv_sec < rhs->tv_sec) {
    return (-1);
  }
  if (lhs->tv_sec > rhs->tv_sec) {
    return (1);
  }
  return ((int )(lhs->tv_usec - rhs->tv_usec));
}
}
extern unsigned long mktime(unsigned int year , unsigned int mon , unsigned int day ,
                            unsigned int hour , unsigned int min , unsigned int sec ) ;
extern void set_normalized_timespec(struct timespec *ts , time_t sec , long nsec ) ;
extern struct timespec timespec_add_safe(struct timespec lhs , struct timespec rhs ) ;
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ struct timespec ts_delta ;

  {
  {
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, lhs.tv_nsec - rhs.tv_nsec);
  }
  return (ts_delta);
}
}
extern struct timespec xtime ;
extern struct timespec wall_to_monotonic ;
extern seqlock_t xtime_lock ;
extern unsigned long read_persistent_clock(void) ;
extern int update_persistent_clock(struct timespec now ) ;
extern int no_sync_cmos_clock  __attribute__((__section__(".data.read_mostly"))) ;
extern void timekeeping_init(void) ;
extern int timekeeping_suspended ;
extern unsigned long get_seconds(void) ;
extern struct timespec current_kernel_time(void) ;
extern void do_gettimeofday(struct timeval *tv ) ;
extern int do_settimeofday(struct timespec *tv ) ;
extern int do_sys_settimeofday(struct timespec *tv , struct timezone *tz ) ;
extern long do_utimes(int dfd , char *filename , struct timespec *times , int flags ) ;
extern int do_setitimer(int which , struct itimerval *value , struct itimerval *ovalue ) ;
extern unsigned int alarm_setitimer(unsigned int seconds ) ;
extern int do_getitimer(int which , struct itimerval *value ) ;
extern void getnstimeofday(struct timespec *tv ) ;
extern void getrawmonotonic(struct timespec *ts ) ;
extern void getboottime(struct timespec *ts ) ;
extern void monotonic_to_bootbased(struct timespec *ts ) ;
extern struct timespec timespec_trunc(struct timespec t , unsigned int gran ) ;
extern int timekeeping_valid_for_hres(void) ;
extern void update_wall_time(void) ;
extern void update_xtime_cache(u64 nsec ) ;
extern void do_sys_times(struct tms * ) ;
__inline static s64 timespec_to_ns(struct timespec  const  *ts ) 
{ 

  {
  return ((long long )ts->tv_sec * 1000000000LL + (long long )ts->tv_nsec);
}
}
__inline static s64 timeval_to_ns(struct timeval  const  *tv ) 
{ 

  {
  return ((long long )tv->tv_sec * 1000000000LL + (long long )(tv->tv_usec * 1000L));
}
}
extern struct timespec ns_to_timespec(s64 nsec ) ;
extern struct timeval ns_to_timeval(s64 nsec ) ;
__inline static void timespec_add_ns(struct timespec *a , u64 ns ) 
{ u32 tmp ;

  {
  {
  tmp = __iter_div_u64_rem((u64 )a->tv_nsec + ns, 1000000000U, & ns);
  a->tv_sec += (__kernel_time_t )tmp;
  a->tv_nsec = (long )ns;
  }
  return;
}
}
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key ) ;
extern void init_waitqueue_head(wait_queue_head_t *q ) ;
__inline static void init_waitqueue_entry(wait_queue_t *q , struct task_struct *p ) 
{ 

  {
  {
  q->flags = 0U;
  q->private = (void *)p;
  q->func = & default_wake_function;
  }
  return;
}
}
__inline static void init_waitqueue_func_entry(wait_queue_t *q , int (*func)(wait_queue_t *wait ,
                                                                             unsigned int mode ,
                                                                             int sync ,
                                                                             void *key ) ) 
{ 

  {
  {
  q->flags = 0U;
  q->private = (void *)0;
  q->func = func;
  }
  return;
}
}
__inline static int waitqueue_active(wait_queue_head_t *q ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  return (tmp___0);
}
}
extern void add_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
extern void add_wait_queue_exclusive(wait_queue_head_t *q , wait_queue_t *wait ) ;
extern void remove_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
__inline static void __add_wait_queue(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
  list_add(& new->task_list, & head->task_list);
  }
  return;
}
}
__inline static void __add_wait_queue_tail(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
  list_add_tail(& new->task_list, & head->task_list);
  }
  return;
}
}
__inline static void __remove_wait_queue(wait_queue_head_t *head , wait_queue_t *old ) 
{ 

  {
  {
  list_del(& old->task_list);
  }
  return;
}
}
extern void __wake_up_common(wait_queue_head_t *q , unsigned int mode , int nr_exclusive ,
                             int sync , void *key ) ;
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
extern void __wake_up_locked_key(wait_queue_head_t *q , unsigned int mode , void *key ) ;
extern void __wake_up_sync_key(wait_queue_head_t *q , unsigned int mode , int nr ,
                               void *key ) ;
extern void __wake_up_locked(wait_queue_head_t *q , unsigned int mode ) ;
extern void __wake_up_sync(wait_queue_head_t *q , unsigned int mode , int nr ) ;
extern void __wake_up_bit(wait_queue_head_t * , void * , int  ) ;
extern int __wait_on_bit(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                         unsigned int  ) ;
extern int __wait_on_bit_lock(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                              unsigned int  ) ;
extern void wake_up_bit(void * , int  ) ;
extern int out_of_line_wait_on_bit(void * , int  , int (*)(void * ) , unsigned int  ) ;
extern int out_of_line_wait_on_bit_lock(void * , int  , int (*)(void * ) , unsigned int  ) ;
extern wait_queue_head_t *bit_waitqueue(void * , int  ) ;
__inline static void add_wait_queue_exclusive_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
  wait->flags |= 1U;
  __add_wait_queue_tail(q, wait);
  }
  return;
}
}
__inline static void remove_wait_queue_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
  __remove_wait_queue(q, wait);
  }
  return;
}
}
extern void sleep_on(wait_queue_head_t *q ) ;
extern long sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
extern void interruptible_sleep_on(wait_queue_head_t *q ) ;
extern long interruptible_sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
extern void prepare_to_wait_exclusive(wait_queue_head_t *q , wait_queue_t *wait ,
                                      int state ) ;
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
extern void abort_exclusive_wait(wait_queue_head_t *q , wait_queue_t *wait , unsigned int mode ,
                                 void *key ) ;
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
extern int wake_bit_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
__inline static int wait_on_bit(void *word , int bit , int (*action)(void * ) , unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)word);
  }
  if (! tmp___0) {
    return (0);
  }
  {
  tmp___1 = out_of_line_wait_on_bit(word, bit, action, mode);
  }
  return (tmp___1);
}
}
__inline static int wait_on_bit_lock(void *word , int bit , int (*action)(void * ) ,
                                     unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = test_and_set_bit(bit, (unsigned long volatile   *)word);
  }
  if (! tmp) {
    return (0);
  }
  {
  tmp___0 = out_of_line_wait_on_bit_lock(word, bit, action, mode);
  }
  return (tmp___0);
}
}
extern nodemask_t _unused_nodemask_arg_ ;
__inline static void __node_set(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
  set_bit((unsigned int )node, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __node_clear(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
  clear_bit(node, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __nodes_setall(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_fill(dstp->bits, nbits);
  }
  return;
}
}
__inline static void __nodes_clear(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_zero(dstp->bits, nbits);
  }
  return;
}
}
__inline static int __node_test_and_set(int node , nodemask_t *addr ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(node, (unsigned long volatile   *)(addr->bits));
  }
  return (tmp);
}
}
__inline static void __nodes_and(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __nodes_or(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
  return;
}
}
__inline static void __nodes_xor(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __nodes_andnot(nodemask_t *dstp , nodemask_t const   *src1p ,
                                    nodemask_t const   *src2p , int nbits ) 
{ 

  {
  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  }
  return;
}
}
__inline static void __nodes_complement(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int nbits ) 
{ 

  {
  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
  return;
}
}
__inline static int __nodes_equal(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_intersects(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                       int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_subset(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                   int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_empty(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_full(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_weight(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static void __nodes_shift_right(nodemask_t *dstp , nodemask_t const   *srcp ,
                                         int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static void __nodes_shift_left(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static int __first_node(nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  __min1 = 1;
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 1UL);
  __min2 = (int )tmp;
  }
  if (__min1 < __min2) {
    {
    tmp___0 = __min1;
    }
  } else {
    {
    tmp___0 = __min2;
    }
  }
  return (tmp___0);
}
}
__inline static int __next_node(int n , nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  __min1 = 1;
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 1UL, (unsigned long )(n + 1));
  __min2 = (int )tmp;
  }
  if (__min1 < __min2) {
    {
    tmp___0 = __min1;
    }
  } else {
    {
    tmp___0 = __min2;
    }
  }
  return (tmp___0);
}
}
__inline static int __first_unset_node(nodemask_t const   *maskp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  __min1 = 1;
  tmp = find_first_zero_bit((unsigned long const   *)(maskp->bits), 1UL);
  __min2 = (int )tmp;
  }
  if (__min1 < __min2) {
    {
    tmp___0 = __min1;
    }
  } else {
    {
    tmp___0 = __min2;
    }
  }
  return (tmp___0);
}
}
__inline static int __nodemask_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         nbits);
  }
  return (tmp);
}
}
__inline static int __nodemask_parse_user(char const   *buf , int len , nodemask_t *dstp ,
                                          int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, nbits);
  }
  return (tmp);
}
}
__inline static int __nodelist_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             nbits);
  }
  return (tmp);
}
}
__inline static int __nodelist_parse(char const   *buf , nodemask_t *dstp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parselist(buf, dstp->bits, nbits);
  }
  return (tmp);
}
}
__inline static int __node_remap(int oldbit , nodemask_t const   *oldp , nodemask_t const   *newp ,
                                 int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
  return (tmp);
}
}
__inline static void __nodes_remap(nodemask_t *dstp , nodemask_t const   *srcp , nodemask_t const   *oldp ,
                                   nodemask_t const   *newp , int nbits ) 
{ 

  {
  {
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
  return;
}
}
__inline static void __nodes_onto(nodemask_t *dstp , nodemask_t const   *origp , nodemask_t const   *relmapp ,
                                  int nbits ) 
{ 

  {
  {
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
  return;
}
}
__inline static void __nodes_fold(nodemask_t *dstp , nodemask_t const   *origp , int sz ,
                                  int nbits ) 
{ 

  {
  {
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
  return;
}
}
extern nodemask_t node_states[5] ;
__inline static int node_state(int node , enum node_states state ) 
{ 

  {
  return (node == 0);
}
}
__inline static void node_set_state(int node , enum node_states state ) 
{ 

  {
  return;
}
}
__inline static int num_node_state(enum node_states state ) 
{ 

  {
  return (1);
}
}
extern unsigned long get_pageblock_flags_group(struct page *page , int start_bitidx ,
                                               int end_bitidx ) ;
extern void set_pageblock_flags_group(struct page *page , unsigned long flags , int start_bitidx ,
                                      int end_bitidx ) ;
extern int page_group_by_mobility_disabled ;
__inline static int get_pageblock_migratetype(struct page *page ) 
{ long tmp ;
  unsigned long tmp___0 ;

  {
  {
  tmp = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
  if (tmp) {
    return (0);
  }
  {
  tmp___0 = get_pageblock_flags_group(page, 0, 2);
  }
  return ((int )tmp___0);
}
}
__inline static int is_file_lru(enum lru_list l ) 
{ int tmp ;

  {
  if ((unsigned int )l == 2U) {
    {
    tmp = 1;
    }
  } else {
    if ((unsigned int )l == 3U) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
__inline static int is_active_lru(enum lru_list l ) 
{ int tmp ;

  {
  if ((unsigned int )l == 1U) {
    {
    tmp = 1;
    }
  } else {
    if ((unsigned int )l == 3U) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
__inline static int is_unevictable_lru(enum lru_list l ) 
{ 

  {
  return ((unsigned int )l == 4U);
}
}
__inline static void zone_set_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
  set_bit((unsigned int )flag, (unsigned long volatile   *)(& zone->flags));
  }
  return;
}
}
__inline static int zone_test_and_set_flag(struct zone *zone , zone_flags_t flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
__inline static void zone_clear_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
  clear_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
  return;
}
}
__inline static int zone_is_all_unreclaimable(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
__inline static int zone_is_reclaim_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
__inline static int zone_is_oom_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
extern struct page *mem_map ;
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
__inline static int mutex_is_locked(struct mutex *lock ) 
{ 

  {
  return (lock->count.counter != (int volatile   )1);
}
}
extern void mutex_lock(struct mutex *lock ) ;
extern int mutex_lock_interruptible(struct mutex *lock ) ;
extern int mutex_lock_killable(struct mutex *lock ) ;
extern int mutex_trylock(struct mutex *lock ) ;
extern void mutex_unlock(struct mutex *lock ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_read_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_write_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_wake)(struct rw_semaphore * ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_downgrade_wake)(struct rw_semaphore *sem ) ;
extern void __init_rwsem(struct rw_semaphore *sem , char const   *name , struct lock_class_key *key ) ;
__inline static void __down_read(struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   ("# beginning down_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  incl      (%%eax)\n\t"
                       "  jns        1f\n"
                       "  call call_rwsem_down_read_failed\n"
                       "1:\n\t"
                       "# ending down_read\n\t": "+m" (sem->count): "a" (sem): "memory",
                       "cc");
  }
  return;
}
}
__inline static int __down_read_trylock(struct rw_semaphore *sem ) 
{ __s32 result ;
  __s32 tmp ;
  int tmp___0 ;

  {
  {
  __asm__  volatile   ("# beginning __down_read_trylock\n\t"
                       "  movl      %0,%1\n\t"
                       "1:\n\t"
                       "  movl\t     %1,%2\n\t"
                       "  addl      %3,%2\n\t"
                       "  jle\t     2f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  cmpxchgl  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "# ending __down_read_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "i" (1): "memory", "cc");
  }
  if (result >= 0) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
__inline static void __down_write_nested(struct rw_semaphore *sem , int subclass ) 
{ int tmp ;

  {
  {
  tmp = -65535;
  __asm__  volatile   ("# beginning down_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  testl     %%edx,%%edx\n\t"
                       "  jz        1f\n"
                       "  call call_rwsem_down_write_failed\n"
                       "1:\n"
                       "# ending down_write": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
  return;
}
}
__inline static void __down_write(struct rw_semaphore *sem ) 
{ 

  {
  {
  __down_write_nested(sem, 0);
  }
  return;
}
}
__inline static int __down_write_trylock(struct rw_semaphore *sem ) 
{ long ret ;
  unsigned long tmp ;

  {
  {
  tmp = __cmpxchg((void volatile   *)(& sem->count), 0UL, 0xffff0001UL, (int )sizeof(sem->count));
  ret = (long )tmp;
  }
  if (ret == 0L) {
    return (1);
  }
  return (0);
}
}
__inline static void __up_read(struct rw_semaphore *sem ) 
{ __s32 tmp ;

  {
  {
  tmp = -1;
  __asm__  volatile   ("# beginning __up_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  jns        1f\n\t"
                       "  call call_rwsem_wake\n"
                       "1:\n"
                       "# ending __up_read\n": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
  return;
}
}
__inline static void __up_write(struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   ("# beginning __up_write\n\t"
                       "  movl      %2,%%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xaddl     %%edx,(%%eax)\n\t"
                       "  jz       1f\n"
                       "  call call_rwsem_wake\n"
                       "1:\n\t"
                       "# ending __up_write\n": "+m" (sem->count): "a" (sem), "i" (65535): "memory",
                       "cc", "edx");
  }
  return;
}
}
__inline static void __downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   ("# beginning __downgrade_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  addl      %2,(%%eax)\n\t"
                       "  jns       1f\n\t"
                       "  call call_rwsem_downgrade_wake\n"
                       "1:\n\t"
                       "# ending __downgrade_write\n": "+m" (sem->count): "a" (sem),
                       "i" (65536): "memory", "cc");
  }
  return;
}
}
__inline static void rwsem_atomic_add(int delta , struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (sem->count): "ir" (delta));
  }
  return;
}
}
__inline static int rwsem_atomic_update(int delta , struct rw_semaphore *sem ) 
{ int tmp ;

  {
  {
  tmp = delta;
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xadd %0,%1": "+r" (tmp), "+m" (sem->count): : "memory");
  }
  return (tmp + delta);
}
}
__inline static int rwsem_is_locked(struct rw_semaphore *sem ) 
{ 

  {
  return (sem->count != 0L);
}
}
extern void down_read(struct rw_semaphore *sem ) ;
extern int down_read_trylock(struct rw_semaphore *sem ) ;
extern void down_write(struct rw_semaphore *sem ) ;
extern int down_write_trylock(struct rw_semaphore *sem ) ;
extern void up_read(struct rw_semaphore *sem ) ;
extern void up_write(struct rw_semaphore *sem ) ;
extern void downgrade_write(struct rw_semaphore *sem ) ;
extern int init_srcu_struct(struct srcu_struct *sp ) ;
extern void cleanup_srcu_struct(struct srcu_struct *sp ) ;
extern int srcu_read_lock(struct srcu_struct *sp ) ;
extern void srcu_read_unlock(struct srcu_struct *sp , int idx ) ;
extern void synchronize_srcu(struct srcu_struct *sp ) ;
extern long srcu_batches_completed(struct srcu_struct *sp ) ;
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh ) ;
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh , struct notifier_block *nb ) ;
extern int raw_notifier_chain_register(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
extern int blocking_notifier_chain_cond_register(struct blocking_notifier_head *nh ,
                                                 struct notifier_block *nb ) ;
extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh ,
                                              struct notifier_block *nb ) ;
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                      void *v ) ;
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                        void *v , int nr_to_call , int *nr_calls ) ;
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                        void *v ) ;
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                          void *v , int nr_to_call , int *nr_calls ) ;
extern int raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                   void *v ) ;
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                     void *v , int nr_to_call , int *nr_calls ) ;
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                    void *v ) ;
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                      void *v , int nr_to_call , int *nr_calls ) ;
__inline static int notifier_from_errno(int err ) 
{ 

  {
  return (32768 | (1 - err));
}
}
__inline static int notifier_to_errno(int ret ) 
{ int tmp ;

  {
  {
  ret &= -32769;
  }
  if (ret > 1) {
    {
    tmp = 1 - ret;
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern struct blocking_notifier_head reboot_notifier_list ;
__inline static void pgdat_resize_lock(struct pglist_data *p , unsigned long *f ) 
{ 

  {
  return;
}
}
__inline static void pgdat_resize_init(struct pglist_data *pgdat ) 
{ 

  {
  return;
}
}
__inline static unsigned int zone_span_seqbegin(struct zone *zone ) 
{ 

  {
  return (0U);
}
}
__inline static int zone_span_seqretry(struct zone *zone , unsigned int iv ) 
{ 

  {
  return (0);
}
}
__inline static void zone_span_writelock(struct zone *zone ) 
{ 

  {
  return;
}
}
__inline static int mhp_notimplemented(char const   *func ) 
{ 

  {
  {
  printk("<4>%s() called, with CONFIG_MEMORY_HOTPLUG disabled\n", func);
  dump_stack();
  }
  return (-38);
}
}
extern int walk_memory_resource(unsigned long start_pfn , unsigned long nr_pages ,
                                void *arg , int (*func)(unsigned long  , unsigned long  ,
                                                        void * ) ) ;
__inline static int is_mem_section_removable(unsigned long pfn , unsigned long nr_pages ) 
{ 

  {
  return (0);
}
}
extern int add_memory(int nid , u64 start , u64 size ) ;
extern int arch_add_memory(int nid , u64 start , u64 size ) ;
extern int remove_memory(u64 start , u64 size ) ;
extern int sparse_add_one_section(struct zone *zone , unsigned long start_pfn , int nr_pages ) ;
extern void sparse_remove_one_section(struct zone *zone , struct mem_section *ms ) ;
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map , unsigned long pnum ) ;
extern void get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ) ;
extern void build_all_zonelists(void) ;
extern void wakeup_kswapd(struct zone *zone , int order ) ;
extern int zone_watermark_ok(struct zone *z , int order , unsigned long mark , int classzone_idx ,
                             int alloc_flags ) ;
extern int init_currently_empty_zone(struct zone *zone , unsigned long start_pfn ,
                                     unsigned long size , enum memmap_context context ) ;
__inline static void memory_present(int nid , unsigned long start , unsigned long end ) 
{ 

  {
  return;
}
}
__inline static int populated_zone(struct zone *zone ) 
{ 

  {
  return (! (! zone->present_pages));
}
}
extern int movable_zone ;
__inline static int zone_movable_is_highmem(void) 
{ 

  {
  return (movable_zone == 2);
}
}
__inline static int is_highmem_idx(enum zone_type idx ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )idx == 2U) {
    {
    tmp___0 = 1;
    }
  } else {
    if ((unsigned int )idx == 3U) {
      {
      tmp = zone_movable_is_highmem();
      }
      if (tmp) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static int is_normal_idx(enum zone_type idx ) 
{ 

  {
  return ((unsigned int )idx == 1U);
}
}
__inline static int is_highmem(struct zone *zone ) 
{ int zone_off ;
  int tmp ;
  int tmp___0 ;

  {
  {
  zone_off = (char *)zone - (char *)((zone->zone_pgdat)->node_zones);
  }
  if ((unsigned long )zone_off == 2UL * sizeof(*zone)) {
    {
    tmp___0 = 1;
    }
  } else {
    if ((unsigned long )zone_off == 3UL * sizeof(*zone)) {
      {
      tmp = zone_movable_is_highmem();
      }
      if (tmp) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static int is_normal(struct zone *zone ) 
{ 

  {
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 1));
}
}
__inline static int is_dma32(struct zone *zone ) 
{ 

  {
  return (0);
}
}
__inline static int is_dma(struct zone *zone ) 
{ 

  {
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 0));
}
}
extern int min_free_kbytes_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                          void * , size_t * , loff_t * ) ;
extern int sysctl_lowmem_reserve_ratio[3] ;
extern int lowmem_reserve_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                               void * , size_t * , loff_t * ) ;
extern int percpu_pagelist_fraction_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                   void * , size_t * , loff_t * ) ;
extern int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                    void * , size_t * , loff_t * ) ;
extern int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                void * , size_t * , loff_t * ) ;
extern int numa_zonelist_order_handler(struct ctl_table * , int  , struct file * ,
                                       void * , size_t * , loff_t * ) ;
extern char numa_zonelist_order[] ;
extern struct pglist_data contig_page_data ;
extern struct pglist_data *first_online_pgdat(void) ;
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat ) ;
extern struct zone *next_zone(struct zone *zone ) ;
__inline static struct zone *zonelist_zone(struct zoneref *zoneref ) 
{ 

  {
  return (zoneref->zone);
}
}
__inline static int zonelist_zone_idx(struct zoneref *zoneref ) 
{ 

  {
  return (zoneref->zone_idx);
}
}
__inline static int zonelist_node_idx(struct zoneref *zoneref ) 
{ 

  {
  return (0);
}
}
extern struct zoneref *next_zones_zonelist(struct zoneref *z , enum zone_type highest_zoneidx ,
                                           nodemask_t *nodes , struct zone **zone ) ;
__inline static struct zoneref *first_zones_zonelist(struct zonelist *zonelist , enum zone_type highest_zoneidx ,
                                                     nodemask_t *nodes , struct zone **zone ) 
{ struct zoneref *tmp ;

  {
  {
  tmp = next_zones_zonelist(zonelist->_zonerefs, highest_zoneidx, nodes, zone);
  }
  return (tmp);
}
}
extern unsigned long node_memmap_size_bytes(int  , unsigned long  , unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static int memmap_valid_within(unsigned long pfn , struct page *page , struct zone *zone ) 
{ 

  {
  return (1);
}
}
extern void cpu_idle(void) ;
extern unsigned int total_cpus ;
extern int smp_call_function_single(int cpuid , void (*func)(void *info ) , void *info ,
                                    int wait ) ;
extern int apic_version[256] ;
extern int pic_mode ;
extern unsigned int def_to_bigsmp ;
extern u8 apicid_2_node[] ;
extern void early_find_smp_config(void) ;
extern void early_get_smp_config(void) ;
extern unsigned long mp_bus_not_pci[((260UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
extern unsigned int boot_cpu_physical_apicid ;
extern unsigned int max_physical_apicid ;
extern int smp_found_config ;
extern int mpc_default_type ;
extern unsigned long mp_lapic_addr ;
extern void get_smp_config(void) ;
extern void find_smp_config(void) ;
extern void early_reserve_e820_mpc_new(void) ;
extern void generic_processor_info(int apicid , int version )  __attribute__((__section__(".cpuinit.text"))) ;
extern void mp_register_ioapic(int id , u32 address , u32 gsi_base ) ;
extern void mp_override_legacy_irq(u8 bus_irq , u8 polarity , u8 trigger , u32 gsi ) ;
extern void mp_config_acpi_legacy_irqs(void) ;
extern int mp_register_gsi(u32 gsi , int edge_level , int active_high_low ) ;
extern int acpi_probe_gsi(void) ;
extern int mp_config_acpi_gsi(unsigned char number , unsigned int devfn , u8 pin ,
                              u32 gsi , int triggering , int polarity ) ;
extern int mp_find_ioapic(int gsi ) ;
extern int mp_find_ioapic_pin(int ioapic , int gsi ) ;
__inline static void physid_set_mask_of_physid(int physid , physid_mask_t *map ) 
{ 

  {
  {
  bitmap_zero(map->mask, 256);
  set_bit((unsigned int )physid, (unsigned long volatile   *)(map->mask));
  }
  return;
}
}
extern physid_mask_t phys_cpu_present_map ;
extern int generic_mps_oem_check(struct mpc_table * , char * , char * ) ;
extern int default_acpi_madt_oem_check(char * , char * ) ;
extern unsigned long loops_per_jiffy ;
extern void __bad_udelay(void) ;
extern void __bad_ndelay(void) ;
extern void __udelay(unsigned long usecs ) ;
extern void __ndelay(unsigned long nsecs ) ;
extern void __const_udelay(unsigned long xloops ) ;
extern void __delay(unsigned long loops ) ;
extern void use_tsc_delay(void) ;
extern unsigned long lpj_fine ;
extern void calibrate_delay(void) ;
extern void msleep(unsigned int msecs ) ;
extern unsigned long msleep_interruptible(unsigned int msecs ) ;
__inline static void ssleep(unsigned int seconds ) 
{ 

  {
  {
  msleep(seconds * 1000U);
  }
  return;
}
}
extern void (*pm_idle)(void) ;
extern void (*pm_power_off)(void) ;
extern void (*pm_power_off_prepare)(void) ;
extern void device_pm_lock(void) ;
extern int sysdev_resume(void) ;
extern void device_power_up(pm_message_t state ) ;
extern void device_resume(pm_message_t state ) ;
extern void device_pm_unlock(void) ;
extern int sysdev_suspend(pm_message_t state ) ;
extern int device_power_down(pm_message_t state ) ;
extern int device_suspend(pm_message_t state ) ;
extern int device_prepare_suspend(pm_message_t state ) ;
extern void __suspend_report_result(char const   *function , void *fn , int ret ) ;
extern unsigned int pm_flags ;
extern int pxm_to_nid(int pxm ) ;
extern void numa_remove_cpu(int cpu ) ;
extern void set_highmem_pages_init(void) ;
extern void leave_mm(int cpu ) ;
extern int __acpi_acquire_global_lock(unsigned int *lock ) ;
extern int __acpi_release_global_lock(unsigned int *lock ) ;
extern int acpi_lapic ;
extern int acpi_ioapic ;
extern int acpi_noirq ;
extern int acpi_strict ;
extern int acpi_disabled ;
extern int acpi_ht ;
extern int acpi_pci_disabled ;
extern int acpi_skip_timer_override ;
extern int acpi_use_timer_override ;
extern u8 acpi_sci_flags ;
extern int acpi_sci_override_gsi ;
extern void acpi_pic_sci_set_trigger(unsigned int  , u16  ) ;
__inline static void disable_acpi(void) 
{ 

  {
  {
  acpi_disabled = 1;
  acpi_ht = 0;
  acpi_pci_disabled = 1;
  acpi_noirq = 1;
  }
  return;
}
}
extern int acpi_gsi_to_irq(u32 gsi , unsigned int *irq ) ;
__inline static void acpi_noirq_set(void) 
{ 

  {
  {
  acpi_noirq = 1;
  }
  return;
}
}
__inline static void acpi_disable_pci(void) 
{ 

  {
  {
  acpi_pci_disabled = 1;
  acpi_noirq_set();
  }
  return;
}
}
extern int acpi_save_state_mem(void) ;
extern void acpi_restore_state_mem(void) ;
extern unsigned long acpi_wakeup_address ;
extern void acpi_reserve_bootmem(void) ;
__inline static unsigned int acpi_processor_cstate_check(unsigned int max_cstate ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )boot_cpu_data.x86 == 15) {
    if ((int )boot_cpu_data.x86_vendor == 2) {
      if ((int )boot_cpu_data.x86_model <= 5) {
        if ((int )boot_cpu_data.x86_mask < 10) {
          return (1U);
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    _L___7: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    if (117 >> 5 == 0) {
      if ((1UL << 21) & (unsigned long )(1 | (1 << 15))) {
        {
        tmp___1 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      if (117 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
        if (117 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
          if (117 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
            if (117 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
              if (117 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
                if (117 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
                  if (117 >> 5 == 7) {
                    {
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___1 = tmp;
                    }
                  } else {
                    {
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___1 = tmp;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (tmp___1) {
      return (1U);
    } else {
      return (max_cstate);
    }
  }
}
}
__inline static void acpi_fake_nodes(struct bootnode  const  *fake_nodes , int num_nodes ) 
{ 

  {
  return;
}
}
extern unsigned long __FIXADDR_TOP ;
extern void reserve_top_address(unsigned long reserve ) ;
extern int fixmaps_set ;
extern pte_t *kmap_pte ;
extern pgprot_t kmap_prot ;
extern pte_t *pkmap_page_table ;
extern void __native_set_fixmap(enum fixed_addresses idx , pte_t pte ) ;
extern void native_set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) ;
__inline static void __set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) 
{ 

  {
  {
  native_set_fixmap(idx, phys, flags);
  }
  return;
}
}
extern void __this_fixmap_does_not_exist(void) ;
__inline static unsigned long fix_to_virt(unsigned int idx ) 
{ 

  {
  if (idx >= 513U) {
    {
    __this_fixmap_does_not_exist();
    }
  }
  return (__FIXADDR_TOP - (unsigned long )(idx << 12));
}
}
__inline static unsigned long virt_to_fix(unsigned long vaddr ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
  while (1) {
    while_24_continue: /* CIL Label */ ;
    if (vaddr >= __FIXADDR_TOP) {
      {
      tmp = 1;
      }
    } else {
      if (vaddr < __FIXADDR_TOP - (unsigned long )(176 << 12)) {
        {
        tmp = 1;
        }
      } else {
        {
        tmp = 0;
        }
      }
    }
    {
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
    if (tmp___0) {
      {
      while (1) {
        while_25_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"),
                             "i" (205), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_26_continue: /* CIL Label */ ;
        }
        while_26_break: /* CIL Label */ ;
        }
        goto while_25_break;
      }
      while_25_break: /* CIL Label */ ;
      }
    }
    goto while_24_break;
  }
  while_24_break: /* CIL Label */ ;
  }
  return ((__FIXADDR_TOP - (vaddr & ~ ((1UL << 12) - 1UL))) >> 12);
}
}
extern void generic_apic_probe(void) ;
extern unsigned int apic_verbosity ;
extern int local_apic_timer_c2_ok ;
extern int disable_apic ;
extern void __inquire_remote_apic(int apicid ) ;
__inline static void default_inquire_remote_apic(int apicid ) 
{ 

  {
  if (apic_verbosity >= 2U) {
    {
    __inquire_remote_apic(apicid);
    }
  }
  return;
}
}
__inline static int is_vsmp_box(void) 
{ 

  {
  return (0);
}
}
extern void xapic_wait_icr_idle(void) ;
extern u32 safe_xapic_wait_icr_idle(void) ;
extern void xapic_icr_write(u32  , u32  ) ;
extern int setup_profiling_timer(unsigned int  ) ;
__inline static void native_apic_mem_write(u32 reg , u32 v ) 
{ u32 volatile   *addr ;
  unsigned long tmp ;

  {
  {
  tmp = fix_to_virt(4U);
  addr = (u32 volatile   *)(tmp + (unsigned long )reg);
  __asm__  volatile   ("661:\n\t"
                       "movl %0, %1"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c[feat]\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "xchgl %0, %1"
                       "\n664:\n"
                       ".previous": "=r" (v), "=m" (*addr): [feat] "i" (115), "0" (v),
                       "m" (*addr));
  }
  return;
}
}
__inline static u32 native_apic_mem_read(u32 reg ) 
{ unsigned long tmp ;

  {
  {
  tmp = fix_to_virt(4U);
  }
  return ((unsigned int )*((u32 volatile   *)(tmp + (unsigned long )reg)));
}
}
extern void native_apic_wait_icr_idle(void) ;
extern u32 native_safe_apic_wait_icr_idle(void) ;
extern void native_apic_icr_write(u32 low , u32 id ) ;
extern u64 native_apic_icr_read(void) ;
extern int get_physical_broadcast(void) ;
extern int lapic_get_maxlvt(void) ;
extern void clear_local_APIC(void) ;
extern void connect_bsp_APIC(void) ;
extern void disconnect_bsp_APIC(int virt_wire_setup ) ;
extern void disable_local_APIC(void) ;
extern void lapic_shutdown(void) ;
extern int verify_local_APIC(void) ;
extern void cache_APIC_registers(void) ;
extern void sync_Arb_IDs(void) ;
extern void init_bsp_APIC(void) ;
extern void setup_local_APIC(void) ;
extern void end_local_APIC_setup(void) ;
extern void init_apic_mappings(void) ;
extern void setup_boot_APIC_clock(void) ;
extern void setup_secondary_APIC_clock(void) ;
extern int APIC_init_uniprocessor(void) ;
extern void enable_NMI_through_LVT0(void) ;
extern u8 setup_APIC_eilvt_mce(u8 vector , u8 msg_type , u8 mask ) ;
extern u8 setup_APIC_eilvt_ibs(u8 vector , u8 msg_type , u8 mask ) ;
extern struct apic *apic ;
extern atomic_t init_deasserted ;
extern int wakeup_secondary_cpu_via_nmi(int apicid , unsigned long start_eip ) ;
__inline static u32 apic_read(u32 reg ) 
{ u32 tmp ;

  {
  {
  tmp = (*(apic->read))(reg);
  }
  return (tmp);
}
}
__inline static void apic_write(u32 reg , u32 val ) 
{ 

  {
  {
  (*(apic->write))(reg, val);
  }
  return;
}
}
__inline static u64 apic_icr_read(void) 
{ u64 tmp ;

  {
  {
  tmp = (*(apic->icr_read))();
  }
  return (tmp);
}
}
__inline static void apic_icr_write(u32 low , u32 high ) 
{ 

  {
  {
  (*(apic->icr_write))(low, high);
  }
  return;
}
}
__inline static void apic_wait_icr_idle(void) 
{ 

  {
  {
  (*(apic->wait_icr_idle))();
  }
  return;
}
}
__inline static u32 safe_apic_wait_icr_idle(void) 
{ u32 tmp ;

  {
  {
  tmp = (*(apic->safe_wait_icr_idle))();
  }
  return (tmp);
}
}
__inline static void ack_APIC_irq(void) 
{ 

  {
  {
  apic_write(176U, 0U);
  }
  return;
}
}
__inline static unsigned int default_get_apic_id(unsigned long x ) 
{ unsigned int ver ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = apic_read(48U);
  ver = tmp & 255U;
  }
  if (ver >= 20U) {
    return ((unsigned int )((x >> 24) & 255UL));
  } else {
    if (122 >> 5 == 0) {
      if ((1UL << 26) & (unsigned long )(1 | (1 << 15))) {
        {
        tmp___2 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      if (122 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
        if (122 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
          if (122 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
            if (122 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
              if (122 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
                if (122 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
                  if (122 >> 5 == 7) {
                    {
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___2 = tmp___0;
                    }
                  } else {
                    {
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___2 = tmp___0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (tmp___2) {
      return ((unsigned int )((x >> 24) & 255UL));
    } else {
      return ((unsigned int )((x >> 24) & 15UL));
    }
  }
}
}
__inline static void default_wait_for_init_deassert(atomic_t *deassert ) 
{ 

  {
  {
  while (1) {
    while_27_continue: /* CIL Label */ ;
    if (! (! deassert->counter)) {
      goto while_27_break;
    }
    {
    cpu_relax();
    }
  }
  while_27_break: /* CIL Label */ ;
  }
  return;
}
}
extern void generic_bigsmp_probe(void) ;
__inline static struct cpumask  const  *default_target_cpus(void) 
{ 

  {
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
extern u16 per_cpu__x86_bios_cpu_apicid  __attribute__((__section__(".data.percpu"))) ;
extern u16 *x86_bios_cpu_apicid_early_ptr ;
extern u16 x86_bios_cpu_apicid_early_map[] ;
__inline static unsigned int read_apic_id(void) 
{ unsigned int reg ;
  unsigned int tmp ;

  {
  {
  reg = apic_read(32U);
  tmp = (*(apic->get_apic_id))((unsigned long )reg);
  }
  return (tmp);
}
}
extern void default_setup_apic_routing(void) ;
extern void default_init_apic_ldr(void) ;
__inline static int default_apic_id_registered(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp___2 = read_apic_id();
  tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
  return (tmp___3);
}
}
__inline static int default_phys_pkg_id(int cpuid_apic , int index_msb ) 
{ 

  {
  return (cpuid_apic >> index_msb);
}
}
extern int default_apicid_to_node(int logical_apicid ) ;
__inline static unsigned int default_cpu_mask_to_apicid(struct cpumask  const  *cpumask ) 
{ 

  {
  return ((unsigned int )(cpumask->bits[0] & 255UL));
}
}
__inline static unsigned int default_cpu_mask_to_apicid_and(struct cpumask  const  *cpumask ,
                                                            struct cpumask  const  *andmask ) 
{ unsigned long mask1 ;
  unsigned long mask2 ;
  unsigned long mask3 ;

  {
  {
  mask1 = cpumask->bits[0];
  mask2 = andmask->bits[0];
  mask3 = cpu_online_mask->bits[0];
  }
  return ((unsigned int )((mask1 & mask2) & mask3));
}
}
__inline static unsigned long default_check_apicid_used(physid_mask_t bitmap , int apicid ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(apicid, (unsigned long const volatile   *)(bitmap.mask));
  }
  return ((unsigned long )tmp___0);
}
}
__inline static unsigned long default_check_apicid_present(int bit ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
  return ((unsigned long )tmp___0);
}
}
__inline static physid_mask_t default_ioapic_phys_id_map(physid_mask_t phys_map ) 
{ 

  {
  return (phys_map);
}
}
__inline static int default_cpu_to_logical_apicid(int cpu ) 
{ 

  {
  return (1 << cpu);
}
}
__inline static int __default_cpu_present_to_apicid(int mps_cpu ) 
{ unsigned long __ptr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  if (mps_cpu < nr_cpu_ids) {
    {
    tmp___2 = cpumask_check((unsigned int )mps_cpu);
    tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(cpu_present_mask->bits));
    }
    if (tmp___3) {
      {
      __asm__  ("": "=r" (__ptr): "0" (& per_cpu__x86_bios_cpu_apicid));
      }
      return ((int )*((u16 *)(__ptr + __per_cpu_offset[mps_cpu])));
    } else {
      return (255);
    }
  } else {
    return (255);
  }
}
}
__inline static int __default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(boot_cpu_physical_apicid___0, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
  return (tmp___0);
}
}
__inline static int default_cpu_present_to_apicid(int mps_cpu ) 
{ int tmp ;

  {
  {
  tmp = __default_cpu_present_to_apicid(mps_cpu);
  }
  return (tmp);
}
}
__inline static int default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;

  {
  {
  tmp = __default_check_phys_apicid_present(boot_cpu_physical_apicid___0);
  }
  return (tmp);
}
}
__inline static physid_mask_t default_apicid_to_cpu_present(int phys_apicid ) 
{ physid_mask_t __physid_mask ;

  {
  {
  __physid_mask.mask[0] = 0UL;
  __physid_mask.mask[1] = 0UL;
  __physid_mask.mask[2] = 0UL;
  __physid_mask.mask[3] = 0UL;
  set_bit((unsigned int )phys_apicid, (unsigned long volatile   *)(__physid_mask.mask));
  }
  return (__physid_mask);
}
}
extern u8 cpu_2_logical_apicid[8] ;
__inline static int invalid_vm86_irq(int irq ) 
{ int tmp ;

  {
  if (irq < 3) {
    {
    tmp = 1;
    }
  } else {
    if (irq > 15) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
extern int nr_ioapics ;
extern int nr_ioapic_registers[64] ;
extern struct mpc_ioapic mp_ioapics[64] ;
extern int mp_irq_entries ;
extern struct mpc_intsrc mp_irqs[256] ;
extern int sis_apic_bug ;
extern int skip_ioapic_setup ;
extern int noioapicquirk ;
extern int noioapicreroute ;
extern int timer_through_8259 ;
extern int io_apic_get_unique_id(int ioapic , int apic_id ) ;
extern int io_apic_get_version(int ioapic ) ;
extern int io_apic_get_redir_entries(int ioapic ) ;
extern int io_apic_set_pci_routing(int ioapic , int pin , int irq , int edge_level ,
                                   int active_high_low ) ;
extern int (*ioapic_renumber_irq)(int ioapic , int irq ) ;
extern void ioapic_init_mappings(void) ;
extern void probe_nr_irqs_gsi(void) ;
extern int setup_ioapic_entry(int apic , int irq , struct IO_APIC_route_entry *entry ,
                              unsigned int destination , int trigger , int polarity ,
                              int vector , int pin ) ;
extern void ioapic_write_entry(int apic , int pin , struct IO_APIC_route_entry e ) ;
extern cpumask_var_t cpu_callin_mask ;
extern cpumask_var_t cpu_callout_mask ;
extern cpumask_var_t cpu_initialized_mask ;
extern cpumask_var_t cpu_sibling_setup_mask ;
extern void setup_cpu_local_masks(void) ;
extern int smp_num_siblings ;
extern unsigned int num_processors ;
extern cpumask_var_t per_cpu__cpu_sibling_map  __attribute__((__section__(".data.percpu"))) ;
extern cpumask_var_t per_cpu__cpu_core_map  __attribute__((__section__(".data.percpu"))) ;
extern u16 per_cpu__cpu_llc_id  __attribute__((__section__(".data.percpu"))) ;
extern int per_cpu__cpu_number  __attribute__((__section__(".data.percpu"))) ;
__inline static struct cpumask *cpu_sibling_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_sibling_map));
  }
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
__inline static struct cpumask *cpu_core_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_core_map));
  }
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
extern u16 per_cpu__x86_cpu_to_apicid  __attribute__((__section__(".data.percpu"))) ;
extern u16 *x86_cpu_to_apicid_early_ptr ;
extern u16 x86_cpu_to_apicid_early_map[] ;
extern struct __anonstruct_stack_start_92 stack_start ;
extern void set_cpu_sibling_map(int cpu ) ;
extern struct smp_ops smp_ops ;
__inline static void smp_send_stop(void) 
{ 

  {
  {
  (*(smp_ops.smp_send_stop))();
  }
  return;
}
}
__inline static void smp_prepare_boot_cpu(void) 
{ 

  {
  {
  (*(smp_ops.smp_prepare_boot_cpu))();
  }
  return;
}
}
__inline static void smp_prepare_cpus(unsigned int max_cpus ) 
{ 

  {
  {
  (*(smp_ops.smp_prepare_cpus))(max_cpus);
  }
  return;
}
}
__inline static void smp_cpus_done(unsigned int max_cpus ) 
{ 

  {
  {
  (*(smp_ops.smp_cpus_done))(max_cpus);
  }
  return;
}
}
__inline static int __cpu_up(unsigned int cpunum ) 
{ int tmp ;

  {
  {
  tmp = (*(smp_ops.cpu_up))(cpunum);
  }
  return (tmp);
}
}
__inline static int __cpu_disable(void) 
{ int tmp ;

  {
  {
  tmp = (*(smp_ops.cpu_disable))();
  }
  return (tmp);
}
}
__inline static void __cpu_die(unsigned int cpu ) 
{ 

  {
  {
  (*(smp_ops.cpu_die))(cpu);
  }
  return;
}
}
__inline static void play_dead(void) 
{ 

  {
  {
  (*(smp_ops.play_dead))();
  }
  return;
}
}
__inline static void smp_send_reschedule(int cpu ) 
{ 

  {
  {
  (*(smp_ops.smp_send_reschedule))(cpu);
  }
  return;
}
}
__inline static void arch_send_call_function_single_ipi(int cpu ) 
{ 

  {
  {
  (*(smp_ops.send_call_func_single_ipi))(cpu);
  }
  return;
}
}
__inline static void arch_send_call_function_ipi_mask(struct cpumask  const  *mask ) 
{ 

  {
  {
  (*(smp_ops.send_call_func_ipi))(mask);
  }
  return;
}
}
extern void cpu_disable_common(void) ;
extern void native_smp_prepare_boot_cpu(void) ;
extern void native_smp_prepare_cpus(unsigned int max_cpus ) ;
extern void native_smp_cpus_done(unsigned int max_cpus ) ;
extern int native_cpu_up(unsigned int cpunum ) ;
extern int native_cpu_disable(void) ;
extern void native_cpu_die(unsigned int cpu ) ;
extern void native_play_dead(void) ;
extern void play_dead_common(void) ;
extern void native_send_call_func_ipi(struct cpumask  const  *mask ) ;
extern void native_send_call_func_single_ipi(int cpu ) ;
extern void smp_store_cpu_info(int id ) ;
__inline static int num_booting_cpus(void) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_weight((struct cpumask  const  *)(cpu_callout_mask));
  }
  return ((int )tmp);
}
}
extern unsigned int disabled_cpus  __attribute__((__section__(".cpuinit.data"))) ;
extern int safe_smp_processor_id(void) ;
__inline static int logical_smp_processor_id(void) 
{ unsigned long tmp ;

  {
  {
  tmp = fix_to_virt(4U);
  }
  return ((int )((*((u32 *)(tmp + 208UL)) >> 24) & 255U));
}
}
extern int hard_smp_processor_id(void) ;
extern int smp_call_function(void (*func)(void *info ) , void *info , int wait ) ;
extern void smp_call_function_many(struct cpumask  const  *mask , void (*func)(void *info ) ,
                                   void *info , bool wait ) ;
__inline static int smp_call_function_mask(cpumask_t mask , void (*func)(void *info ) ,
                                           void *info , int wait ) 
{ 

  {
  {
  smp_call_function_many((struct cpumask  const  *)(& mask), func, info, (_Bool )wait);
  }
  return (0);
}
}
extern void __smp_call_function_single(int cpuid , struct call_single_data *data ,
                                       int wait ) ;
extern void generic_smp_call_function_single_interrupt(void) ;
extern void generic_smp_call_function_interrupt(void) ;
extern void ipi_call_lock(void) ;
extern void ipi_call_unlock(void) ;
extern void ipi_call_lock_irq(void) ;
extern void ipi_call_unlock_irq(void) ;
extern int on_each_cpu(void (*func)(void *info ) , void *info , int wait ) ;
extern unsigned int setup_max_cpus ;
extern void arch_disable_smp_support(void) ;
extern void smp_setup_processor_id(void) ;
__inline static int cpu_to_node(int cpu ) 
{ 

  {
  return (0);
}
}
__inline static struct cpumask  const  *cpumask_of_node(int node ) 
{ 

  {
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
extern struct cpumask  const  *cpu_coregroup_mask(int cpu ) ;
__inline static void arch_fix_phys_package_id(int num , u32 slot ) 
{ 

  {
  return;
}
}
extern void x86_pci_root_bus_res_quirks(struct pci_bus *b ) ;
__inline static void set_mp_bus_to_node(int busnum , int node ) 
{ 

  {
  return;
}
}
extern int arch_update_cpu_topology(void) ;
__inline static int allocflags_to_migratetype(gfp_t gfp_flags ) 
{ int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
  __ret_warn_on = ! (! ((gfp_flags & 1572864U) == 1572864U));
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
  if (tmp) {
    {
    warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h",
                       105);
    }
  }
  {
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  tmp___0 = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
  if (tmp___0) {
    return (0);
  }
  return ((((gfp_flags & 1048576U) != 0U) << 1) | ((gfp_flags & 524288U) != 0U));
}
}
__inline static enum zone_type gfp_zone(gfp_t flags ) 
{ 

  {
  if (flags & 1U) {
    return ((enum zone_type )0);
  }
  if ((flags & 1048578U) == 1048578U) {
    return ((enum zone_type )3);
  }
  if (flags & 2U) {
    return ((enum zone_type )2);
  }
  return ((enum zone_type )1);
}
}
__inline static int gfp_zonelist(gfp_t flags ) 
{ long tmp ;

  {
  return (0);
}
}
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ int tmp ;

  {
  {
  tmp = gfp_zonelist(flags);
  }
  return (contig_page_data.node_zonelists + tmp);
}
}
__inline static void arch_free_page(struct page *page , int order ) 
{ 

  {
  return;
}
}
extern struct page *__alloc_pages_internal(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ,
                                           nodemask_t *nodemask ) ;
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ struct page *tmp ;

  {
  {
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, (nodemask_t *)((void *)0));
  }
  return (tmp);
}
}
__inline static struct page *__alloc_pages_nodemask(gfp_t gfp_mask , unsigned int order ,
                                                    struct zonelist *zonelist , nodemask_t *nodemask ) 
{ struct page *tmp ;

  {
  {
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, nodemask);
  }
  return (tmp);
}
}
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ long tmp ;
  int ret__ ;
  struct zonelist *tmp___0 ;
  struct page *tmp___1 ;

  {
  {
  tmp = __builtin_expect((long )(! (! (order >= 11U))), 0L);
  }
  if (tmp) {
    return ((struct page *)((void *)0));
  }
  if (nid < 0) {
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_28_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_28_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_28_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_28_8;
          } else {
            {
            goto switch_28_default;
            if (0) {
              switch_28_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_28_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    nid = 0;
    }
  }
  {
  tmp___0 = node_zonelist(nid, gfp_mask);
  tmp___1 = __alloc_pages(gfp_mask, order, tmp___0);
  }
  return (tmp___1);
}
}
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
extern unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
extern void *alloc_pages_exact(size_t size , gfp_t gfp_mask ) ;
extern void free_pages_exact(void *virt , size_t size ) ;
extern void __free_pages(struct page *page , unsigned int order ) ;
extern void free_pages(unsigned long addr , unsigned int order ) ;
extern void free_hot_page(struct page *page ) ;
extern void free_cold_page(struct page *page ) ;
extern void page_alloc_init(void) ;
extern void drain_zone_pages(struct zone *zone , struct per_cpu_pages *pcp ) ;
extern void drain_all_pages(void) ;
extern void drain_local_pages(void *dummy ) ;
extern int ( /* format attribute */  __request_module)(bool wait , char const   *name 
                                                       , ...) ;
extern struct subprocess_info *call_usermodehelper_setup(char *path , char **argv ,
                                                         char **envp , gfp_t gfp_mask ) ;
extern void call_usermodehelper_setkeys(struct subprocess_info *info , struct key *session_keyring ) ;
extern int call_usermodehelper_stdinpipe(struct subprocess_info *sub_info , struct file **filp ) ;
extern void call_usermodehelper_setcleanup(struct subprocess_info *info , void (*cleanup)(char **argv ,
                                                                                          char **envp ) ) ;
extern int call_usermodehelper_exec(struct subprocess_info *info , enum umh_wait wait ) ;
extern void call_usermodehelper_freeinfo(struct subprocess_info *info ) ;
__inline static int call_usermodehelper(char *path , char **argv , char **envp , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  if ((int )wait == -1) {
    {
    tmp = 32U;
    }
  } else {
    {
    tmp = 208U;
    }
  }
  {
  gfp_mask = tmp;
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
  return (tmp___0);
}
}
__inline static int call_usermodehelper_keys(char *path , char **argv , char **envp ,
                                             struct key *session_keyring , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  if ((int )wait == -1) {
    {
    tmp = 32U;
    }
  } else {
    {
    tmp = 208U;
    }
  }
  {
  gfp_mask = tmp;
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  call_usermodehelper_setkeys(info, session_keyring);
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
  return (tmp___0);
}
}
extern void usermodehelper_init(void) ;
extern int call_usermodehelper_pipe(char *path , char **argv , char **envp , struct file **filp ) ;
extern int usermodehelper_disable(void) ;
extern void usermodehelper_enable(void) ;
extern char const   VDSO32_PRELINK[] ;
extern void __kernel_sigreturn ;
extern void __kernel_rt_sigreturn ;
extern char const   vdso32_int80_start ;
extern char const   vdso32_int80_end ;
extern char const   vdso32_syscall_start ;
extern char const   vdso32_syscall_end ;
extern char const   vdso32_sysenter_start ;
extern char const   vdso32_sysenter_end ;
extern unsigned int vdso_enabled ;
__inline static void fill_ldt(struct desc_struct *desc , struct user_desc  const  *info ) 
{ 

  {
  {
  desc->__annonCompField8.__annonCompField7.limit0 = (unsigned short )(info->limit & 65535U);
  desc->__annonCompField8.__annonCompField7.base0 = (unsigned short )(info->base_addr & 65535U);
  desc->__annonCompField8.__annonCompField7.base1 = (unsigned int )((info->base_addr & 16711680U) >> 16);
  desc->__annonCompField8.__annonCompField7.type = (unsigned int )((info->read_exec_only ^ 1U) << 1);
  desc->__annonCompField8.__annonCompField7.type |= (unsigned int )(info->contents << 2);
  desc->__annonCompField8.__annonCompField7.s = 1U;
  desc->__annonCompField8.__annonCompField7.dpl = 3U;
  desc->__annonCompField8.__annonCompField7.p = (unsigned int )(info->seg_not_present ^ 1U);
  desc->__annonCompField8.__annonCompField7.limit = (unsigned int )((info->limit & 983040U) >> 16);
  desc->__annonCompField8.__annonCompField7.avl = (unsigned int )info->useable;
  desc->__annonCompField8.__annonCompField7.d = (unsigned int )info->seg_32bit;
  desc->__annonCompField8.__annonCompField7.g = (unsigned int )info->limit_in_pages;
  desc->__annonCompField8.__annonCompField7.base2 = (unsigned int )((info->base_addr & 4278190080U) >> 24);
  desc->__annonCompField8.__annonCompField7.l = 0U;
  }
  return;
}
}
extern struct desc_ptr idt_descr ;
extern gate_desc idt_table[] ;
extern struct gdt_page per_cpu__gdt_page  __attribute__((__section__(".data.percpu.page_aligned"))) ;
__inline static struct desc_struct *get_cpu_gdt_table(unsigned int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__gdt_page));
  }
  return (((struct gdt_page *)(__ptr + __per_cpu_offset[cpu]))->gdt);
}
}
__inline static void pack_gate(gate_desc *gate , unsigned char type , unsigned long base ,
                               unsigned int dpl , unsigned int flags , unsigned short seg ) 
{ 

  {
  {
  gate->__annonCompField8.__annonCompField6.a = (unsigned int )((unsigned long )((int )seg << 16) | (base & 65535UL));
  gate->__annonCompField8.__annonCompField6.b = (unsigned int )((base & 4294901760UL) | (unsigned long )((((unsigned int )(128 | (int )type) | (dpl << 5)) & 255U) << 8));
  }
  return;
}
}
__inline static int desc_empty(void const   *ptr ) 
{ u32 const   *desc ;

  {
  {
  desc = (u32 const   *)ptr;
  }
  return (! (*(desc + 0) | *(desc + 1)));
}
}
__inline static void paravirt_alloc_ldt(struct desc_struct *ldt , unsigned int entries ) 
{ 

  {
  return;
}
}
__inline static void native_write_idt_entry(gate_desc *idt , int entry , gate_desc const   *gate ) 
{ 

  {
  {
  __constant_memcpy((void *)(idt + entry), (void const   *)gate, (unsigned int )sizeof(*gate));
  }
  return;
}
}
__inline static void native_write_ldt_entry(struct desc_struct *ldt , int entry ,
                                            void const   *desc ) 
{ 

  {
  {
  __constant_memcpy((void *)(ldt + entry), desc, 8U);
  }
  return;
}
}
__inline static void native_write_gdt_entry(struct desc_struct *gdt , int entry ,
                                            void const   *desc , int type ) 
{ unsigned int size ;

  {
  if (type == 9) {
    goto switch_29_9;
  } else {
    if (type == 2) {
      goto switch_29_2;
    } else {
      {
      goto switch_29_default;
      if (0) {
        switch_29_9: /* CIL Label */ 
        {
        size = (unsigned int )sizeof(tss_desc );
        }
        goto switch_29_break;
        switch_29_2: /* CIL Label */ 
        {
        size = (unsigned int )sizeof(ldt_desc );
        }
        goto switch_29_break;
        switch_29_default: /* CIL Label */ 
        {
        size = (unsigned int )sizeof(struct desc_struct );
        }
        goto switch_29_break;
      } else {
        switch_29_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
  __memcpy((void *)(gdt + entry), desc, size);
  }
  return;
}
}
__inline static void pack_descriptor(struct desc_struct *desc , unsigned long base ,
                                     unsigned long limit , unsigned char type , unsigned char flags ) 
{ 

  {
  {
  desc->__annonCompField8.__annonCompField6.a = (unsigned int )(((base & 65535UL) << 16) | (limit & 65535UL));
  desc->__annonCompField8.__annonCompField6.b = (unsigned int )(((((base & 4278190080UL) | ((base & 16711680UL) >> 16)) | (limit & 983040UL)) | (unsigned long )(((int )type & 255) << 8)) | (unsigned long )(((int )flags & 15) << 20));
  desc->__annonCompField8.__annonCompField7.p = 1U;
  }
  return;
}
}
__inline static void set_tssldt_descriptor(void *d , unsigned long addr , unsigned int type ,
                                           unsigned int size ) 
{ 

  {
  {
  pack_descriptor((struct desc_struct *)d, addr, (unsigned long )size, (unsigned char )(128U | type),
                  (unsigned char)0);
  }
  return;
}
}
__inline static void __set_tss_desc(unsigned int cpu , unsigned int entry , void *addr ) 
{ struct desc_struct *d ;
  struct desc_struct *tmp ;
  tss_desc tss ;

  {
  {
  tmp = get_cpu_gdt_table(cpu);
  d = tmp;
  set_tssldt_descriptor((void *)(& tss), (unsigned long )addr, 9U, (unsigned int )(((unsigned long )((unsigned int )(& ((struct tss_struct *)0)->io_bitmap) + 8192U) + sizeof(unsigned long )) - 1UL));
  native_write_gdt_entry(d, (int )entry, (void const   *)(& tss), 9);
  }
  return;
}
}
__inline static void native_set_ldt(void const   *addr , unsigned int entries ) 
{ unsigned int cpu ;
  int ret__ ;
  ldt_desc ldt ;
  struct desc_struct *tmp ;
  long tmp___0 ;

  {
  {
  tmp___0 = __builtin_expect((long )(! (! (entries == 0U))), 1L);
  }
  if (tmp___0) {
    {
    __asm__  volatile   ("lldt %w0": : "q" (0));
    }
  } else {
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_30_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_30_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_30_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_30_8;
          } else {
            {
            goto switch_30_default;
            if (0) {
              switch_30_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_30_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    cpu = (unsigned int )ret__;
    set_tssldt_descriptor((void *)(& ldt), (unsigned long )addr, 2U, entries * 8U - 1U);
    tmp = get_cpu_gdt_table(cpu);
    native_write_gdt_entry(tmp, 17, (void const   *)(& ldt), 2);
    __asm__  volatile   ("lldt %w0": : "q" (136));
    }
  }
  return;
}
}
__inline static void native_load_tr_desc(void) 
{ 

  {
  {
  __asm__  volatile   ("ltr %w0": : "q" (128));
  }
  return;
}
}
__inline static void native_load_gdt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("lgdt %0": : "m" (*dtr));
  }
  return;
}
}
__inline static void native_load_idt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("lidt %0": : "m" (*dtr));
  }
  return;
}
}
__inline static void native_store_gdt(struct desc_ptr *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("sgdt %0": "=m" (*dtr));
  }
  return;
}
}
__inline static void native_store_idt(struct desc_ptr *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("sidt %0": "=m" (*dtr));
  }
  return;
}
}
__inline static unsigned long native_store_tr(void) 
{ unsigned long tr ;

  {
  {
  __asm__  volatile   ("str %0": "=r" (tr));
  }
  return (tr);
}
}
__inline static void native_load_tls(struct thread_struct *t , unsigned int cpu ) 
{ unsigned int i ;
  struct desc_struct *gdt ;
  struct desc_struct *tmp ;

  {
  {
  tmp = get_cpu_gdt_table(cpu);
  gdt = tmp;
  i = 0U;
  }
  {
  while (1) {
    while_31_continue: /* CIL Label */ ;
    if (! (i < 3U)) {
      goto while_31_break;
    }
    {
    *(gdt + (6U + i)) = t->tls_array[i];
    i ++;
    }
  }
  while_31_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void clear_LDT(void) 
{ 

  {
  {
  native_set_ldt((void const   *)((void *)0), 0U);
  }
  return;
}
}
__inline static void load_LDT_nolock(mm_context_t *pc ) 
{ 

  {
  {
  native_set_ldt((void const   *)pc->ldt, (unsigned int )pc->size);
  }
  return;
}
}
__inline static void load_LDT(mm_context_t *pc ) 
{ 

  {
  {
  while (1) {
    while_32_continue: /* CIL Label */ ;
    goto while_32_break;
  }
  while_32_break: /* CIL Label */ ;
  }
  {
  load_LDT_nolock(pc);
  }
  {
  while (1) {
    while_33_continue: /* CIL Label */ ;
    goto while_33_break;
  }
  while_33_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static unsigned long get_desc_base(struct desc_struct  const  *desc ) 
{ 

  {
  return ((unsigned long )(((unsigned int const   )desc->__annonCompField8.__annonCompField7.base0 | (desc->__annonCompField8.__annonCompField7.base1 << 16)) | (desc->__annonCompField8.__annonCompField7.base2 << 24)));
}
}
__inline static unsigned long get_desc_limit(struct desc_struct  const  *desc ) 
{ 

  {
  return ((unsigned long )((unsigned int const   )desc->__annonCompField8.__annonCompField7.limit0 | (desc->__annonCompField8.__annonCompField7.limit << 16)));
}
}
__inline static void _set_gate(int gate , unsigned int type , void *addr , unsigned int dpl ,
                               unsigned int ist , unsigned int seg ) 
{ gate_desc s ;

  {
  {
  pack_gate(& s, (unsigned char )type, (unsigned long )addr, dpl, ist, (unsigned short )seg);
  native_write_idt_entry(idt_table, gate, (gate_desc const   *)(& s));
  }
  return;
}
}
__inline static void set_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_34_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_35_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (320), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_36_continue: /* CIL Label */ ;
        }
        while_36_break: /* CIL Label */ ;
        }
        goto while_35_break;
      }
      while_35_break: /* CIL Label */ ;
      }
    }
    goto while_34_break;
  }
  while_34_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 14U, addr, 0U, 0U, 96U);
  }
  return;
}
}
extern int first_system_vector ;
extern unsigned long used_vectors[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
__inline static void alloc_system_vector(int vector ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(vector, (unsigned long const volatile   *)(used_vectors));
  }
  if (tmp___0) {
    {
    while (1) {
      while_37_continue: /* CIL Label */ ;
      {
      __asm__  volatile   ("1:\tud2\n"
                           ".pushsection __bug_table,\"a\"\n"
                           "2:\t.long 1b, %c0\n"
                           "\t.word %c1, 0\n"
                           "\t.org 2b+%c2\n"
                           ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                           "i" (335), "i" (sizeof(struct bug_entry )));
      }
      {
      while (1) {
        while_38_continue: /* CIL Label */ ;
      }
      while_38_break: /* CIL Label */ ;
      }
      goto while_37_break;
    }
    while_37_break: /* CIL Label */ ;
    }
  } else {
    {
    set_bit((unsigned int )vector, (unsigned long volatile   *)(used_vectors));
    }
    if (first_system_vector > vector) {
      {
      first_system_vector = vector;
      }
    }
  }
  return;
}
}
__inline static void alloc_intr_gate(unsigned int n , void *addr ) 
{ 

  {
  {
  alloc_system_vector((int )n);
  set_intr_gate(n, addr);
  }
  return;
}
}
__inline static void set_system_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_39_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_40_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (349), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_41_continue: /* CIL Label */ ;
        }
        while_41_break: /* CIL Label */ ;
        }
        goto while_40_break;
      }
      while_40_break: /* CIL Label */ ;
      }
    }
    goto while_39_break;
  }
  while_39_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 14U, addr, 3U, 0U, 96U);
  }
  return;
}
}
__inline static void set_system_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_42_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_43_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (355), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_44_continue: /* CIL Label */ ;
        }
        while_44_break: /* CIL Label */ ;
        }
        goto while_43_break;
      }
      while_43_break: /* CIL Label */ ;
      }
    }
    goto while_42_break;
  }
  while_42_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 15U, addr, 3U, 0U, 96U);
  }
  return;
}
}
__inline static void set_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_45_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_46_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (361), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_47_continue: /* CIL Label */ ;
        }
        while_47_break: /* CIL Label */ ;
        }
        goto while_46_break;
      }
      while_46_break: /* CIL Label */ ;
      }
    }
    goto while_45_break;
  }
  while_45_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 15U, addr, 0U, 0U, 96U);
  }
  return;
}
}
__inline static void set_task_gate(unsigned int n , unsigned int gdt_entry ) 
{ long tmp ;

  {
  {
  while (1) {
    while_48_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_49_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (367), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_50_continue: /* CIL Label */ ;
        }
        while_50_break: /* CIL Label */ ;
        }
        goto while_49_break;
      }
      while_49_break: /* CIL Label */ ;
      }
    }
    goto while_48_break;
  }
  while_48_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 5U, (void *)0, 0U, 0U, gdt_entry << 3);
  }
  return;
}
}
__inline static void set_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
  while (1) {
    while_51_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_52_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (373), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_53_continue: /* CIL Label */ ;
        }
        while_53_break: /* CIL Label */ ;
        }
        goto while_52_break;
      }
      while_52_break: /* CIL Label */ ;
      }
    }
    goto while_51_break;
  }
  while_51_break: /* CIL Label */ ;
  }
  {
  _set_gate(n, 14U, addr, 0U, ist, 96U);
  }
  return;
}
}
__inline static void set_system_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
  while (1) {
    while_54_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_55_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (379), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_56_continue: /* CIL Label */ ;
        }
        while_56_break: /* CIL Label */ ;
        }
        goto while_55_break;
      }
      while_55_break: /* CIL Label */ ;
      }
    }
    goto while_54_break;
  }
  while_54_break: /* CIL Label */ ;
  }
  {
  _set_gate(n, 14U, addr, 3U, ist, 96U);
  }
  return;
}
}
extern int arch_setup_additional_pages(struct linux_binprm *bprm , int uses_interp ) ;
extern int syscall32_setup_pages(struct linux_binprm * , int exstack ) ;
extern unsigned long arch_randomize_brk(struct mm_struct *mm ) ;
extern Elf64_Dyn _DYNAMIC[] ;
__inline static int elf_coredump_extra_notes_write(struct file *file , loff_t *foffset ) 
{ 

  {
  return (0);
}
}
extern int sysfs_schedule_callback(struct kobject *kobj , void (*func)(void * ) ,
                                   void *data , struct module *owner ) ;
extern int sysfs_create_dir(struct kobject *kobj ) ;
extern void sysfs_remove_dir(struct kobject *kobj ) ;
extern int sysfs_rename_dir(struct kobject *kobj , char const   *new_name ) ;
extern int sysfs_move_dir(struct kobject *kobj , struct kobject *new_parent_kobj ) ;
extern int sysfs_create_file(struct kobject *kobj , struct attribute  const  *attr ) ;
extern int sysfs_chmod_file(struct kobject *kobj , struct attribute *attr , mode_t mode ) ;
extern void sysfs_remove_file(struct kobject *kobj , struct attribute  const  *attr ) ;
extern int sysfs_create_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern void sysfs_remove_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char const   *name ) ;
extern int sysfs_create_link_nowarn(struct kobject *kobj , struct kobject *target ,
                                    char const   *name ) ;
extern void sysfs_remove_link(struct kobject *kobj , char const   *name ) ;
extern int sysfs_create_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern int sysfs_update_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern void sysfs_remove_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern int sysfs_add_file_to_group(struct kobject *kobj , struct attribute  const  *attr ,
                                   char const   *group ) ;
extern void sysfs_remove_file_from_group(struct kobject *kobj , struct attribute  const  *attr ,
                                         char const   *group ) ;
extern void sysfs_notify(struct kobject *kobj , char const   *dir , char const   *attr ) ;
extern void sysfs_notify_dirent(struct sysfs_dirent *sd ) ;
extern struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd , unsigned char const   *name ) ;
extern struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd ) ;
extern void sysfs_put(struct sysfs_dirent *sd ) ;
extern void sysfs_printk_last_file(void) ;
extern int sysfs_init(void) ;
extern void kref_set(struct kref *kref , int num ) ;
extern void kref_init(struct kref *kref ) ;
extern void kref_get(struct kref *kref ) ;
extern int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) ;
extern char uevent_helper[] ;
extern u64 uevent_seqnum ;
extern int ( /* format attribute */  kobject_set_name)(struct kobject *kobj , char const   *name 
                                                       , ...) ;
extern int kobject_set_name_vargs(struct kobject *kobj , char const   *fmt , va_list vargs ) ;
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 

  {
  return ((char const   *)kobj->name);
}
}
extern void kobject_init(struct kobject *kobj , struct kobj_type *ktype ) ;
extern int kobject_add(struct kobject *kobj , struct kobject *parent , char const   *fmt 
                       , ...) ;
extern int kobject_init_and_add(struct kobject *kobj , struct kobj_type *ktype , struct kobject *parent ,
                                char const   *fmt  , ...) ;
extern void kobject_del(struct kobject *kobj ) ;
extern struct kobject *kobject_create(void) ;
extern struct kobject *kobject_create_and_add(char const   *name , struct kobject *parent ) ;
extern int kobject_rename(struct kobject * , char const   *new_name ) ;
extern int kobject_move(struct kobject * , struct kobject * ) ;
extern struct kobject *kobject_get(struct kobject *kobj ) ;
extern void kobject_put(struct kobject *kobj ) ;
extern char *kobject_get_path(struct kobject *kobj , gfp_t flag ) ;
extern struct sysfs_ops kobj_sysfs_ops ;
extern void kset_init(struct kset *kset ) ;
extern int kset_register(struct kset *kset ) ;
extern void kset_unregister(struct kset *kset ) ;
extern struct kset *kset_create_and_add(char const   *name , struct kset_uevent_ops *u ,
                                        struct kobject *parent_kobj ) ;
__inline static struct kset *to_kset(struct kobject *kobj ) 
{ struct kobject  const  *__mptr ;
  struct kset *tmp ;

  {
  if (kobj) {
    {
    __mptr = (struct kobject  const  *)kobj;
    tmp = (struct kset *)((char *)__mptr - (unsigned int )(& ((struct kset *)0)->kobj));
    }
  } else {
    {
    tmp = (struct kset *)((void *)0);
    }
  }
  return (tmp);
}
}
__inline static struct kset *kset_get(struct kset *k ) 
{ struct kobject *tmp ;
  struct kset *tmp___0 ;
  struct kset *tmp___1 ;

  {
  if (k) {
    {
    tmp = kobject_get(& k->kobj);
    tmp___0 = to_kset(tmp);
    tmp___1 = tmp___0;
    }
  } else {
    {
    tmp___1 = (struct kset *)((void *)0);
    }
  }
  return (tmp___1);
}
}
__inline static void kset_put(struct kset *k ) 
{ 

  {
  {
  kobject_put(& k->kobj);
  }
  return;
}
}
__inline static struct kobj_type *get_ktype(struct kobject *kobj ) 
{ 

  {
  return (kobj->ktype);
}
}
extern struct kobject *kset_find_obj(struct kset * , char const   * ) ;
extern struct kobject *kernel_kobj ;
extern struct kobject *mm_kobj ;
extern struct kobject *hypervisor_kobj ;
extern struct kobject *power_kobj ;
extern struct kobject *firmware_kobj ;
extern int kobject_uevent(struct kobject *kobj , enum kobject_action action ) ;
extern int kobject_uevent_env(struct kobject *kobj , enum kobject_action action ,
                              char **envp ) ;
extern int ( /* format attribute */  add_uevent_var)(struct kobj_uevent_env *env ,
                                                     char const   *format  , ...) ;
extern int kobject_action_type(char const   *buf , size_t count , enum kobject_action *type ) ;
extern int parse_args(char const   *name , char *args , struct kernel_param *params ,
                      unsigned int num , int (*unknown)(char *param , char *val ) ) ;
extern void destroy_params(struct kernel_param  const  *params , unsigned int num ) ;
extern int param_set_byte(char const   *val , struct kernel_param *kp ) ;
extern int param_get_byte(char *buffer , struct kernel_param *kp ) ;
extern int param_set_short(char const   *val , struct kernel_param *kp ) ;
extern int param_get_short(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ushort(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ushort(char *buffer , struct kernel_param *kp ) ;
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
extern int param_set_long(char const   *val , struct kernel_param *kp ) ;
extern int param_get_long(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ulong(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ulong(char *buffer , struct kernel_param *kp ) ;
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
extern int param_set_invbool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_invbool(char *buffer , struct kernel_param *kp ) ;
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
extern int param_set_copystring(char const   *val , struct kernel_param *kp ) ;
extern int param_get_string(char *buffer , struct kernel_param *kp ) ;
extern int module_param_sysfs_setup(struct module *mod , struct kernel_param *kparam ,
                                    unsigned int num_params ) ;
extern void module_param_sysfs_remove(struct module *mod ) ;
extern void marker_update_probe_range(struct marker *begin , struct marker *end ) ;
extern marker_probe_func __mark_empty_function ;
extern void marker_probe_cb(struct marker  const  *mdata , void *call_private  , ...) ;
extern int marker_probe_register(char const   *name , char const   *format , marker_probe_func *probe ,
                                 void *probe_private ) ;
extern int marker_probe_unregister(char const   *name , marker_probe_func *probe ,
                                   void *probe_private ) ;
extern int marker_probe_unregister_private_data(marker_probe_func *probe , void *probe_private ) ;
extern void *marker_get_private_data(char const   *name , marker_probe_func *probe ,
                                     int num ) ;
__inline static void init_completion(struct completion *x ) 
{ 

  {
  {
  x->done = 0U;
  init_waitqueue_head(& x->wait);
  }
  return;
}
}
extern void wait_for_completion(struct completion * ) ;
extern int wait_for_completion_interruptible(struct completion *x ) ;
extern int wait_for_completion_killable(struct completion *x ) ;
extern unsigned long wait_for_completion_timeout(struct completion *x , unsigned long timeout ) ;
extern unsigned long wait_for_completion_interruptible_timeout(struct completion *x ,
                                                               unsigned long timeout ) ;
extern bool try_wait_for_completion(struct completion *x ) ;
extern bool completion_done(struct completion *x ) ;
extern void complete(struct completion * ) ;
extern void complete_all(struct completion * ) ;
extern int rcu_scheduler_active ;
extern void rcu_qsctr_inc(int cpu ) ;
extern void rcu_bh_qsctr_inc(int cpu ) ;
extern int rcu_pending(int cpu ) ;
extern int rcu_needs_cpu(int cpu ) ;
__inline static void __rcu_read_lock(void) 
{ 

  {
  {
  while (1) {
    while_57_continue: /* CIL Label */ ;
    goto while_57_break;
  }
  while_57_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_58_continue: /* CIL Label */ ;
    goto while_58_break;
  }
  while_58_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void __rcu_read_lock_bh(void) 
{ 

  {
  {
  local_bh_disable();
  }
  {
  while (1) {
    while_59_continue: /* CIL Label */ ;
    goto while_59_break;
  }
  while_59_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void __rcu_read_unlock_bh(void) 
{ 

  {
  {
  while (1) {
    while_60_continue: /* CIL Label */ ;
    goto while_60_break;
  }
  while_60_break: /* CIL Label */ ;
  }
  {
  local_bh_enable();
  }
  return;
}
}
extern void __rcu_init(void) ;
extern void rcu_check_callbacks(int cpu , int user ) ;
extern void rcu_restart_cpu(int cpu ) ;
extern long rcu_batches_completed(void) ;
extern long rcu_batches_completed_bh(void) ;
extern void rcu_enter_nohz(void) ;
extern void rcu_exit_nohz(void) ;
__inline static int rcu_blocking_is_gp(void) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_weight((struct cpumask  const  *)cpu_online_mask);
  }
  return (tmp == 1U);
}
}
extern void wakeme_after_rcu(struct rcu_head *head ) ;
extern void call_rcu(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
extern void call_rcu_bh(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
extern void synchronize_rcu(void) ;
extern void rcu_barrier(void) ;
extern void rcu_barrier_bh(void) ;
extern void rcu_barrier_sched(void) ;
extern void rcu_init(void) ;
extern void rcu_scheduler_starting(void) ;
extern void tracepoint_update_probe_range(struct tracepoint *begin , struct tracepoint *end ) ;
extern int tracepoint_probe_register(char const   *name , void *probe ) ;
extern int tracepoint_probe_unregister(char const   *name , void *probe ) ;
extern int tracepoint_probe_register_noupdate(char const   *name , void *probe ) ;
extern int tracepoint_probe_unregister_noupdate(char const   *name , void *probe ) ;
extern void tracepoint_probe_update_all(void) ;
extern void tracepoint_iter_start(struct tracepoint_iter *iter ) ;
extern void tracepoint_iter_next(struct tracepoint_iter *iter ) ;
extern void tracepoint_iter_stop(struct tracepoint_iter *iter ) ;
extern void tracepoint_iter_reset(struct tracepoint_iter *iter ) ;
extern int tracepoint_get_iter_range(struct tracepoint **tracepoint , struct tracepoint *begin ,
                                     struct tracepoint *end ) ;
__inline static void tracepoint_synchronize_unregister(void) 
{ 

  {
  {
  synchronize_rcu();
  }
  return;
}
}
extern void kmem_cache_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern int slab_is_available(void) ;
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
extern void kmem_cache_destroy(struct kmem_cache * ) ;
extern int kmem_cache_shrink(struct kmem_cache * ) ;
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
extern unsigned int kmem_cache_size(struct kmem_cache * ) ;
extern char const   *kmem_cache_name(struct kmem_cache * ) ;
extern int kmem_ptr_validate(struct kmem_cache *cachep , void const   *ptr ) ;
extern void *__krealloc(void const   * , size_t  , gfp_t  ) ;
extern void *krealloc(void const   * , size_t  , gfp_t  ) ;
extern void kfree(void const   * ) ;
extern void kzfree(void const   * ) ;
extern size_t ksize(void const   * ) ;
extern unsigned int cpu_khz ;
extern unsigned int tsc_khz ;
extern void disable_TSC(void) ;
__inline static cycles_t get_cycles(void) 
{ unsigned long long ret ;

  {
  {
  ret = 0ULL;
  ret = __native_read_tsc();
  }
  return (ret);
}
}
__inline static cycles_t vget_cycles(void) 
{ unsigned long long tmp ;

  {
  {
  tmp = __native_read_tsc();
  }
  return (tmp);
}
}
extern void tsc_init(void) ;
extern void mark_tsc_unstable(char *reason ) ;
extern int unsynchronized_tsc(void) ;
extern int check_tsc_unstable(void) ;
extern void check_tsc_sync_source(int cpu ) ;
extern void check_tsc_sync_target(void) ;
extern int notsc_setup(char * ) ;
extern unsigned long tick_usec ;
extern unsigned long tick_nsec ;
extern int tickadj ;
extern int time_status ;
extern long time_maxerror ;
extern long time_esterror ;
extern long time_adjust ;
extern void ntp_init(void) ;
extern void ntp_clear(void) ;
__inline static int ntp_synced(void) 
{ 

  {
  return (! (time_status & 64));
}
}
extern u64 tick_length ;
extern void second_overflow(void) ;
extern void update_ntp_one_tick(void) ;
extern int do_adjtimex(struct timex * ) ;
extern int read_current_timer(unsigned long *timer_val ) ;
extern u64 jiffies_64  __attribute__((__section__(".data"))) ;
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
extern u64 get_jiffies_64(void) ;
extern unsigned long preset_lpj ;
extern unsigned int jiffies_to_msecs(unsigned long j ) ;
extern unsigned int jiffies_to_usecs(unsigned long j ) ;
extern unsigned long msecs_to_jiffies(unsigned int m ) ;
extern unsigned long usecs_to_jiffies(unsigned int u ) ;
extern unsigned long timespec_to_jiffies(struct timespec  const  *value ) ;
extern void jiffies_to_timespec(unsigned long jiffies , struct timespec *value ) ;
extern unsigned long timeval_to_jiffies(struct timeval  const  *value ) ;
extern void jiffies_to_timeval(unsigned long jiffies , struct timeval *value ) ;
extern clock_t jiffies_to_clock_t(long x ) ;
extern unsigned long clock_t_to_jiffies(unsigned long x ) ;
extern u64 jiffies_64_to_clock_t(u64 x ) ;
extern u64 nsec_to_clock_t(u64 x ) ;
__inline static ktime_t ktime_set(long secs , unsigned long nsecs ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (long long )secs * 1000000000LL + (long long )nsecs;
  }
  return (__constr_expr_0);
}
}
__inline static ktime_t timespec_to_ktime(struct timespec ts ) 
{ ktime_t tmp ;

  {
  {
  tmp = ktime_set(ts.tv_sec, (unsigned long )ts.tv_nsec);
  }
  return (tmp);
}
}
__inline static ktime_t timeval_to_ktime(struct timeval tv ) 
{ ktime_t tmp ;

  {
  {
  tmp = ktime_set(tv.tv_sec, (unsigned long )(tv.tv_usec * 1000L));
  }
  return (tmp);
}
}
__inline static int ktime_equal(ktime_t cmp1 , ktime_t cmp2 ) 
{ 

  {
  return (cmp1.tv64 == cmp2.tv64);
}
}
__inline static s64 ktime_to_us(ktime_t kt ) 
{ struct timeval tv ;
  struct timeval tmp ;

  {
  {
  tmp = ns_to_timeval(kt.tv64);
  tv = tmp;
  }
  return ((long long )tv.tv_sec * 1000000LL + (long long )tv.tv_usec);
}
}
__inline static s64 ktime_us_delta(ktime_t later , ktime_t earlier ) 
{ ktime_t __constr_expr_0 ;
  s64 tmp ;

  {
  {
  __constr_expr_0.tv64 = later.tv64 - earlier.tv64;
  tmp = ktime_to_us(__constr_expr_0);
  }
  return (tmp);
}
}
__inline static ktime_t ktime_add_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 + usec * 1000ULL);
  }
  return (__constr_expr_0);
}
}
__inline static ktime_t ktime_sub_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 - usec * 1000ULL);
  }
  return (__constr_expr_0);
}
}
extern ktime_t ktime_add_safe(ktime_t lhs , ktime_t rhs ) ;
extern void ktime_get_ts(struct timespec *ts ) ;
__inline static ktime_t ns_to_ktime(u64 ns ) ;
static union ktime  const  ktime_zero  =    {(s64 )0};
__inline static ktime_t ns_to_ktime(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void debug_object_init(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
  return;
}
}
__inline static void debug_check_no_obj_freed(void const   *address , unsigned long size ) 
{ 

  {
  return;
}
}
extern struct tvec_base boot_tvec_bases ;
extern void init_timer_key(struct timer_list *timer , char const   *name , struct lock_class_key *key ) ;
extern void init_timer_deferrable_key(struct timer_list *timer , char const   *name ,
                                      struct lock_class_key *key ) ;
__inline static void destroy_timer_on_stack(struct timer_list *timer ) 
{ 

  {
  return;
}
}
__inline static void init_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                             struct lock_class_key *key ) 
{ 

  {
  {
  init_timer_key(timer, name, key);
  }
  return;
}
}
__inline static void setup_timer_key(struct timer_list *timer , char const   *name ,
                                     struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                     unsigned long data ) 
{ 

  {
  {
  timer->function = function;
  timer->data = data;
  init_timer_key(timer, name, key);
  }
  return;
}
}
__inline static void setup_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                              struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                              unsigned long data ) 
{ 

  {
  {
  timer->function = function;
  timer->data = data;
  init_timer_on_stack_key(timer, name, key);
  }
  return;
}
}
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 

  {
  return ((unsigned long )timer->entry.next != (unsigned long )((void *)0));
}
}
extern void add_timer_on(struct timer_list *timer , int cpu ) ;
extern int del_timer(struct timer_list *timer ) ;
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
extern int mod_timer_pending(struct timer_list *timer , unsigned long expires ) ;
extern unsigned long next_timer_interrupt(void) ;
extern unsigned long get_next_timer_interrupt(unsigned long now ) ;
extern void init_timer_stats(void) ;
extern void timer_stats_update_stats(void *timer , pid_t pid , void *startf , void *timerf ,
                                     char *comm , unsigned int timer_flag ) ;
extern void __timer_stats_timer_set_start_info(struct timer_list *timer , void *addr ) ;
__inline static void timer_stats_timer_set_start_info(struct timer_list *timer ) 
{ void *tmp ;

  {
  {
  tmp = __builtin_return_address(0U);
  __timer_stats_timer_set_start_info(timer, tmp);
  }
  return;
}
}
__inline static void timer_stats_timer_clear_start_info(struct timer_list *timer ) 
{ 

  {
  {
  timer->start_site = (void *)0;
  }
  return;
}
}
extern void add_timer(struct timer_list *timer ) ;
extern int try_to_del_timer_sync(struct timer_list *timer ) ;
extern int del_timer_sync(struct timer_list *timer ) ;
extern void init_timers(void) ;
extern void run_local_timers(void) ;
extern enum hrtimer_restart it_real_fn(struct hrtimer * ) ;
extern unsigned long __round_jiffies(unsigned long j , int cpu ) ;
extern unsigned long __round_jiffies_relative(unsigned long j , int cpu ) ;
extern unsigned long round_jiffies(unsigned long j ) ;
extern unsigned long round_jiffies_relative(unsigned long j ) ;
extern unsigned long __round_jiffies_up(unsigned long j , int cpu ) ;
extern unsigned long __round_jiffies_up_relative(unsigned long j , int cpu ) ;
extern unsigned long round_jiffies_up(unsigned long j ) ;
extern unsigned long round_jiffies_up_relative(unsigned long j ) ;
__inline static struct delayed_work *to_delayed_work(struct work_struct *work ) 
{ struct work_struct  const  *__mptr ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  }
  return ((struct delayed_work *)((char *)__mptr - (unsigned int )(& ((struct delayed_work *)0)->work)));
}
}
extern struct workqueue_struct *__create_workqueue_key(char const   *name , int singlethread ,
                                                       int freezeable , int rt , struct lock_class_key *key ,
                                                       char const   *lock_name ) ;
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
extern int queue_work(struct workqueue_struct *wq , struct work_struct *work ) ;
extern int queue_work_on(int cpu , struct workqueue_struct *wq , struct work_struct *work ) ;
extern int queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *work ,
                              unsigned long delay ) ;
extern int queue_delayed_work_on(int cpu , struct workqueue_struct *wq , struct delayed_work *work ,
                                 unsigned long delay ) ;
extern void flush_workqueue(struct workqueue_struct *wq ) ;
extern void flush_scheduled_work(void) ;
extern int schedule_work(struct work_struct *work ) ;
extern int schedule_work_on(int cpu , struct work_struct *work ) ;
extern int schedule_delayed_work(struct delayed_work *work , unsigned long delay ) ;
extern int schedule_delayed_work_on(int cpu , struct delayed_work *work , unsigned long delay ) ;
extern int schedule_on_each_cpu(void (*func)(struct work_struct *work ) ) ;
extern int current_is_keventd(void) ;
extern int keventd_up(void) ;
extern void init_workqueues(void) ;
extern int execute_in_process_context(void (*fn)(struct work_struct *work ) , struct execute_work * ) ;
extern int flush_work(struct work_struct *work ) ;
extern int cancel_work_sync(struct work_struct *work ) ;
__inline static int cancel_delayed_work(struct delayed_work *work ) 
{ int ret ;

  {
  {
  ret = del_timer_sync(& work->timer);
  }
  if (ret) {
    {
    clear_bit(0, (unsigned long volatile   *)((unsigned long *)(& work->work.data)));
    }
  }
  return (ret);
}
}
extern int cancel_delayed_work_sync(struct delayed_work *work ) ;
__inline static void cancel_rearming_delayed_workqueue(struct workqueue_struct *wq ,
                                                       struct delayed_work *work ) 
{ 

  {
  {
  cancel_delayed_work_sync(work);
  }
  return;
}
}
__inline static void cancel_rearming_delayed_work(struct delayed_work *work ) 
{ 

  {
  {
  cancel_delayed_work_sync(work);
  }
  return;
}
}
extern long work_on_cpu(unsigned int cpu , long (*fn)(void * ) , void *arg ) ;
extern struct tracepoint __tracepoint_kmalloc ;
__inline static void trace_kmalloc(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                                   size_t bytes_alloc , gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_61_continue: /* CIL Label */ ;
      {
      while (1) {
        while_62_continue: /* CIL Label */ ;
        goto while_62_break;
      }
      while_62_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc.funcs));
      }
      {
      while (1) {
        while_63_continue: /* CIL Label */ ;
        goto while_63_break;
      }
      while_63_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_64_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
          it_func ++;
          }
          if (! *it_func) {
            goto while_64_break;
          }
        }
        while_64_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_65_continue: /* CIL Label */ ;
        goto while_65_break;
      }
      while_65_break: /* CIL Label */ ;
      }
      goto while_61_break;
    }
    while_61_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr , size_t bytes_req ,
                                                         size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmalloc", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                           void const   *ptr , size_t bytes_req ,
                                                           size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmalloc", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmem_cache_alloc ;
__inline static void trace_kmem_cache_alloc(unsigned long call_site , void const   *ptr ,
                                            size_t bytes_req , size_t bytes_alloc ,
                                            gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_66_continue: /* CIL Label */ ;
      {
      while (1) {
        while_67_continue: /* CIL Label */ ;
        goto while_67_break;
      }
      while_67_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc.funcs));
      }
      {
      while (1) {
        while_68_continue: /* CIL Label */ ;
        goto while_68_break;
      }
      while_68_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_69_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
          it_func ++;
          }
          if (! *it_func) {
            goto while_69_break;
          }
        }
        while_69_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_70_continue: /* CIL Label */ ;
        goto while_70_break;
      }
      while_70_break: /* CIL Label */ ;
      }
      goto while_66_break;
    }
    while_66_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                  void const   *ptr ,
                                                                  size_t bytes_req ,
                                                                  size_t bytes_alloc ,
                                                                  gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmem_cache_alloc", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                    void const   *ptr ,
                                                                    size_t bytes_req ,
                                                                    size_t bytes_alloc ,
                                                                    gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmem_cache_alloc", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmalloc_node ;
__inline static void trace_kmalloc_node(unsigned long call_site , void const   *ptr ,
                                        size_t bytes_req , size_t bytes_alloc , gfp_t gfp_flags ,
                                        int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc_node.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_71_continue: /* CIL Label */ ;
      {
      while (1) {
        while_72_continue: /* CIL Label */ ;
        goto while_72_break;
      }
      while_72_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc_node.funcs));
      }
      {
      while (1) {
        while_73_continue: /* CIL Label */ ;
        goto while_73_break;
      }
      while_73_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_74_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
          it_func ++;
          }
          if (! *it_func) {
            goto while_74_break;
          }
        }
        while_74_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_75_continue: /* CIL Label */ ;
        goto while_75_break;
      }
      while_75_break: /* CIL Label */ ;
      }
      goto while_71_break;
    }
    while_71_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                              void const   *ptr ,
                                                              size_t bytes_req , size_t bytes_alloc ,
                                                              gfp_t gfp_flags , int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmalloc_node", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                                void const   *ptr ,
                                                                size_t bytes_req ,
                                                                size_t bytes_alloc ,
                                                                gfp_t gfp_flags ,
                                                                int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmalloc_node", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmem_cache_alloc_node ;
__inline static void trace_kmem_cache_alloc_node(unsigned long call_site , void const   *ptr ,
                                                 size_t bytes_req , size_t bytes_alloc ,
                                                 gfp_t gfp_flags , int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc_node.state)),
                         0L);
  }
  if (tmp) {
    {
    while (1) {
      while_76_continue: /* CIL Label */ ;
      {
      while (1) {
        while_77_continue: /* CIL Label */ ;
        goto while_77_break;
      }
      while_77_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc_node.funcs));
      }
      {
      while (1) {
        while_78_continue: /* CIL Label */ ;
        goto while_78_break;
      }
      while_78_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_79_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
          it_func ++;
          }
          if (! *it_func) {
            goto while_79_break;
          }
        }
        while_79_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_80_continue: /* CIL Label */ ;
        goto while_80_break;
      }
      while_80_break: /* CIL Label */ ;
      }
      goto while_76_break;
    }
    while_76_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                       void const   *ptr ,
                                                                       size_t bytes_req ,
                                                                       size_t bytes_alloc ,
                                                                       gfp_t gfp_flags ,
                                                                       int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmem_cache_alloc_node", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                         void const   *ptr ,
                                                                         size_t bytes_req ,
                                                                         size_t bytes_alloc ,
                                                                         gfp_t gfp_flags ,
                                                                         int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmem_cache_alloc_node", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kfree ;
__inline static void trace_kfree(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kfree.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_81_continue: /* CIL Label */ ;
      {
      while (1) {
        while_82_continue: /* CIL Label */ ;
        goto while_82_break;
      }
      while_82_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kfree.funcs));
      }
      {
      while (1) {
        while_83_continue: /* CIL Label */ ;
        goto while_83_break;
      }
      while_83_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_84_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
          it_func ++;
          }
          if (! *it_func) {
            goto while_84_break;
          }
        }
        while_84_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_85_continue: /* CIL Label */ ;
        goto while_85_break;
      }
      while_85_break: /* CIL Label */ ;
      }
      goto while_81_break;
    }
    while_81_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kfree(void (*probe)(unsigned long call_site , void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kfree", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kfree(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kfree", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmem_cache_free ;
__inline static void trace_kmem_cache_free(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_free.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_86_continue: /* CIL Label */ ;
      {
      while (1) {
        while_87_continue: /* CIL Label */ ;
        goto while_87_break;
      }
      while_87_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_free.funcs));
      }
      {
      while (1) {
        while_88_continue: /* CIL Label */ ;
        goto while_88_break;
      }
      while_88_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_89_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
          it_func ++;
          }
          if (! *it_func) {
            goto while_89_break;
          }
        }
        while_89_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_90_continue: /* CIL Label */ ;
        goto while_90_break;
      }
      while_90_break: /* CIL Label */ ;
      }
      goto while_86_break;
    }
    while_86_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                 void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmem_cache_free", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                   void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmem_cache_free", (void *)probe);
  }
  return (tmp);
}
}
extern struct kmem_cache kmalloc_caches[14] ;
__inline static int kmalloc_index(size_t size ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;

  {
  if (! size) {
    return (0);
  }
  if (size <= 8U) {
    if (8ULL & (1ULL << 63)) {
      {
      tmp___63 = 63;
      }
    } else {
      if (8ULL & (1ULL << 62)) {
        {
        tmp___62 = 62;
        }
      } else {
        if (8ULL & (1ULL << 61)) {
          {
          tmp___61 = 61;
          }
        } else {
          if (8ULL & (1ULL << 60)) {
            {
            tmp___60 = 60;
            }
          } else {
            if (8ULL & (1ULL << 59)) {
              {
              tmp___59 = 59;
              }
            } else {
              if (8ULL & (1ULL << 58)) {
                {
                tmp___58 = 58;
                }
              } else {
                if (8ULL & (1ULL << 57)) {
                  {
                  tmp___57 = 57;
                  }
                } else {
                  if (8ULL & (1ULL << 56)) {
                    {
                    tmp___56 = 56;
                    }
                  } else {
                    if (8ULL & (1ULL << 55)) {
                      {
                      tmp___55 = 55;
                      }
                    } else {
                      if (8ULL & (1ULL << 54)) {
                        {
                        tmp___54 = 54;
                        }
                      } else {
                        if (8ULL & (1ULL << 53)) {
                          {
                          tmp___53 = 53;
                          }
                        } else {
                          if (8ULL & (1ULL << 52)) {
                            {
                            tmp___52 = 52;
                            }
                          } else {
                            if (8ULL & (1ULL << 51)) {
                              {
                              tmp___51 = 51;
                              }
                            } else {
                              if (8ULL & (1ULL << 50)) {
                                {
                                tmp___50 = 50;
                                }
                              } else {
                                if (8ULL & (1ULL << 49)) {
                                  {
                                  tmp___49 = 49;
                                  }
                                } else {
                                  if (8ULL & (1ULL << 48)) {
                                    {
                                    tmp___48 = 48;
                                    }
                                  } else {
                                    if (8ULL & (1ULL << 47)) {
                                      {
                                      tmp___47 = 47;
                                      }
                                    } else {
                                      if (8ULL & (1ULL << 46)) {
                                        {
                                        tmp___46 = 46;
                                        }
                                      } else {
                                        if (8ULL & (1ULL << 45)) {
                                          {
                                          tmp___45 = 45;
                                          }
                                        } else {
                                          if (8ULL & (1ULL << 44)) {
                                            {
                                            tmp___44 = 44;
                                            }
                                          } else {
                                            if (8ULL & (1ULL << 43)) {
                                              {
                                              tmp___43 = 43;
                                              }
                                            } else {
                                              if (8ULL & (1ULL << 42)) {
                                                {
                                                tmp___42 = 42;
                                                }
                                              } else {
                                                if (8ULL & (1ULL << 41)) {
                                                  {
                                                  tmp___41 = 41;
                                                  }
                                                } else {
                                                  if (8ULL & (1ULL << 40)) {
                                                    {
                                                    tmp___40 = 40;
                                                    }
                                                  } else {
                                                    if (8ULL & (1ULL << 39)) {
                                                      {
                                                      tmp___39 = 39;
                                                      }
                                                    } else {
                                                      if (8ULL & (1ULL << 38)) {
                                                        {
                                                        tmp___38 = 38;
                                                        }
                                                      } else {
                                                        if (8ULL & (1ULL << 37)) {
                                                          {
                                                          tmp___37 = 37;
                                                          }
                                                        } else {
                                                          if (8ULL & (1ULL << 36)) {
                                                            {
                                                            tmp___36 = 36;
                                                            }
                                                          } else {
                                                            if (8ULL & (1ULL << 35)) {
                                                              {
                                                              tmp___35 = 35;
                                                              }
                                                            } else {
                                                              if (8ULL & (1ULL << 34)) {
                                                                {
                                                                tmp___34 = 34;
                                                                }
                                                              } else {
                                                                if (8ULL & (1ULL << 33)) {
                                                                  {
                                                                  tmp___33 = 33;
                                                                  }
                                                                } else {
                                                                  if (8ULL & (1ULL << 32)) {
                                                                    {
                                                                    tmp___32 = 32;
                                                                    }
                                                                  } else {
                                                                    if (8ULL & (1ULL << 31)) {
                                                                      {
                                                                      tmp___31 = 31;
                                                                      }
                                                                    } else {
                                                                      if (8ULL & (1ULL << 30)) {
                                                                        {
                                                                        tmp___30 = 30;
                                                                        }
                                                                      } else {
                                                                        if (8ULL & (1ULL << 29)) {
                                                                          {
                                                                          tmp___29 = 29;
                                                                          }
                                                                        } else {
                                                                          if (8ULL & (1ULL << 28)) {
                                                                            {
                                                                            tmp___28 = 28;
                                                                            }
                                                                          } else {
                                                                            if (8ULL & (1ULL << 27)) {
                                                                              {
                                                                              tmp___27 = 27;
                                                                              }
                                                                            } else {
                                                                              if (8ULL & (1ULL << 26)) {
                                                                                {
                                                                                tmp___26 = 26;
                                                                                }
                                                                              } else {
                                                                                if (8ULL & (1ULL << 25)) {
                                                                                  {
                                                                                  tmp___25 = 25;
                                                                                  }
                                                                                } else {
                                                                                  if (8ULL & (1ULL << 24)) {
                                                                                    {
                                                                                    tmp___24 = 24;
                                                                                    }
                                                                                  } else {
                                                                                    if (8ULL & (1ULL << 23)) {
                                                                                      {
                                                                                      tmp___23 = 23;
                                                                                      }
                                                                                    } else {
                                                                                      if (8ULL & (1ULL << 22)) {
                                                                                        {
                                                                                        tmp___22 = 22;
                                                                                        }
                                                                                      } else {
                                                                                        if (8ULL & (1ULL << 21)) {
                                                                                          {
                                                                                          tmp___21 = 21;
                                                                                          }
                                                                                        } else {
                                                                                          if (8ULL & (1ULL << 20)) {
                                                                                            {
                                                                                            tmp___20 = 20;
                                                                                            }
                                                                                          } else {
                                                                                            if (8ULL & (1ULL << 19)) {
                                                                                              {
                                                                                              tmp___19 = 19;
                                                                                              }
                                                                                            } else {
                                                                                              if (8ULL & (1ULL << 18)) {
                                                                                                {
                                                                                                tmp___18 = 18;
                                                                                                }
                                                                                              } else {
                                                                                                if (8ULL & (1ULL << 17)) {
                                                                                                  {
                                                                                                  tmp___17 = 17;
                                                                                                  }
                                                                                                } else {
                                                                                                  if (8ULL & (1ULL << 16)) {
                                                                                                    {
                                                                                                    tmp___16 = 16;
                                                                                                    }
                                                                                                  } else {
                                                                                                    if (8ULL & (1ULL << 15)) {
                                                                                                      {
                                                                                                      tmp___15 = 15;
                                                                                                      }
                                                                                                    } else {
                                                                                                      if (8ULL & (1ULL << 14)) {
                                                                                                        {
                                                                                                        tmp___14 = 14;
                                                                                                        }
                                                                                                      } else {
                                                                                                        if (8ULL & (1ULL << 13)) {
                                                                                                          {
                                                                                                          tmp___13 = 13;
                                                                                                          }
                                                                                                        } else {
                                                                                                          if (8ULL & (1ULL << 12)) {
                                                                                                            {
                                                                                                            tmp___12 = 12;
                                                                                                            }
                                                                                                          } else {
                                                                                                            if (8ULL & (1ULL << 11)) {
                                                                                                              {
                                                                                                              tmp___11 = 11;
                                                                                                              }
                                                                                                            } else {
                                                                                                              if (8ULL & (1ULL << 10)) {
                                                                                                                {
                                                                                                                tmp___10 = 10;
                                                                                                                }
                                                                                                              } else {
                                                                                                                if (8ULL & (1ULL << 9)) {
                                                                                                                  {
                                                                                                                  tmp___9 = 9;
                                                                                                                  }
                                                                                                                } else {
                                                                                                                  if (8ULL & (1ULL << 8)) {
                                                                                                                    {
                                                                                                                    tmp___8 = 8;
                                                                                                                    }
                                                                                                                  } else {
                                                                                                                    if (8ULL & (1ULL << 7)) {
                                                                                                                      {
                                                                                                                      tmp___7 = 7;
                                                                                                                      }
                                                                                                                    } else {
                                                                                                                      if (8ULL & (1ULL << 6)) {
                                                                                                                        {
                                                                                                                        tmp___6 = 6;
                                                                                                                        }
                                                                                                                      } else {
                                                                                                                        if (8ULL & (1ULL << 5)) {
                                                                                                                          {
                                                                                                                          tmp___5 = 5;
                                                                                                                          }
                                                                                                                        } else {
                                                                                                                          if (8ULL & (1ULL << 4)) {
                                                                                                                            {
                                                                                                                            tmp___4 = 4;
                                                                                                                            }
                                                                                                                          } else {
                                                                                                                            if (8ULL & (1ULL << 3)) {
                                                                                                                              {
                                                                                                                              tmp___3 = 3;
                                                                                                                              }
                                                                                                                            } else {
                                                                                                                              if (8ULL & (1ULL << 2)) {
                                                                                                                                {
                                                                                                                                tmp___2 = 2;
                                                                                                                                }
                                                                                                                              } else {
                                                                                                                                if (8ULL & (1ULL << 1)) {
                                                                                                                                  {
                                                                                                                                  tmp___1 = 1;
                                                                                                                                  }
                                                                                                                                } else {
                                                                                                                                  {
                                                                                                                                  tmp___0 = ____ilog2_NaN();
                                                                                                                                  tmp___1 = tmp___0;
                                                                                                                                  }
                                                                                                                                }
                                                                                                                                {
                                                                                                                                tmp___2 = tmp___1;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              {
                                                                                                                              tmp___3 = tmp___2;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            {
                                                                                                                            tmp___4 = tmp___3;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          {
                                                                                                                          tmp___5 = tmp___4;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        {
                                                                                                                        tmp___6 = tmp___5;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      {
                                                                                                                      tmp___7 = tmp___6;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    {
                                                                                                                    tmp___8 = tmp___7;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  {
                                                                                                                  tmp___9 = tmp___8;
                                                                                                                  }
                                                                                                                }
                                                                                                                {
                                                                                                                tmp___10 = tmp___9;
                                                                                                                }
                                                                                                              }
                                                                                                              {
                                                                                                              tmp___11 = tmp___10;
                                                                                                              }
                                                                                                            }
                                                                                                            {
                                                                                                            tmp___12 = tmp___11;
                                                                                                            }
                                                                                                          }
                                                                                                          {
                                                                                                          tmp___13 = tmp___12;
                                                                                                          }
                                                                                                        }
                                                                                                        {
                                                                                                        tmp___14 = tmp___13;
                                                                                                        }
                                                                                                      }
                                                                                                      {
                                                                                                      tmp___15 = tmp___14;
                                                                                                      }
                                                                                                    }
                                                                                                    {
                                                                                                    tmp___16 = tmp___15;
                                                                                                    }
                                                                                                  }
                                                                                                  {
                                                                                                  tmp___17 = tmp___16;
                                                                                                  }
                                                                                                }
                                                                                                {
                                                                                                tmp___18 = tmp___17;
                                                                                                }
                                                                                              }
                                                                                              {
                                                                                              tmp___19 = tmp___18;
                                                                                              }
                                                                                            }
                                                                                            {
                                                                                            tmp___20 = tmp___19;
                                                                                            }
                                                                                          }
                                                                                          {
                                                                                          tmp___21 = tmp___20;
                                                                                          }
                                                                                        }
                                                                                        {
                                                                                        tmp___22 = tmp___21;
                                                                                        }
                                                                                      }
                                                                                      {
                                                                                      tmp___23 = tmp___22;
                                                                                      }
                                                                                    }
                                                                                    {
                                                                                    tmp___24 = tmp___23;
                                                                                    }
                                                                                  }
                                                                                  {
                                                                                  tmp___25 = tmp___24;
                                                                                  }
                                                                                }
                                                                                {
                                                                                tmp___26 = tmp___25;
                                                                                }
                                                                              }
                                                                              {
                                                                              tmp___27 = tmp___26;
                                                                              }
                                                                            }
                                                                            {
                                                                            tmp___28 = tmp___27;
                                                                            }
                                                                          }
                                                                          {
                                                                          tmp___29 = tmp___28;
                                                                          }
                                                                        }
                                                                        {
                                                                        tmp___30 = tmp___29;
                                                                        }
                                                                      }
                                                                      {
                                                                      tmp___31 = tmp___30;
                                                                      }
                                                                    }
                                                                    {
                                                                    tmp___32 = tmp___31;
                                                                    }
                                                                  }
                                                                  {
                                                                  tmp___33 = tmp___32;
                                                                  }
                                                                }
                                                                {
                                                                tmp___34 = tmp___33;
                                                                }
                                                              }
                                                              {
                                                              tmp___35 = tmp___34;
                                                              }
                                                            }
                                                            {
                                                            tmp___36 = tmp___35;
                                                            }
                                                          }
                                                          {
                                                          tmp___37 = tmp___36;
                                                          }
                                                        }
                                                        {
                                                        tmp___38 = tmp___37;
                                                        }
                                                      }
                                                      {
                                                      tmp___39 = tmp___38;
                                                      }
                                                    }
                                                    {
                                                    tmp___40 = tmp___39;
                                                    }
                                                  }
                                                  {
                                                  tmp___41 = tmp___40;
                                                  }
                                                }
                                                {
                                                tmp___42 = tmp___41;
                                                }
                                              }
                                              {
                                              tmp___43 = tmp___42;
                                              }
                                            }
                                            {
                                            tmp___44 = tmp___43;
                                            }
                                          }
                                          {
                                          tmp___45 = tmp___44;
                                          }
                                        }
                                        {
                                        tmp___46 = tmp___45;
                                        }
                                      }
                                      {
                                      tmp___47 = tmp___46;
                                      }
                                    }
                                    {
                                    tmp___48 = tmp___47;
                                    }
                                  }
                                  {
                                  tmp___49 = tmp___48;
                                  }
                                }
                                {
                                tmp___50 = tmp___49;
                                }
                              }
                              {
                              tmp___51 = tmp___50;
                              }
                            }
                            {
                            tmp___52 = tmp___51;
                            }
                          }
                          {
                          tmp___53 = tmp___52;
                          }
                        }
                        {
                        tmp___54 = tmp___53;
                        }
                      }
                      {
                      tmp___55 = tmp___54;
                      }
                    }
                    {
                    tmp___56 = tmp___55;
                    }
                  }
                  {
                  tmp___57 = tmp___56;
                  }
                }
                {
                tmp___58 = tmp___57;
                }
              }
              {
              tmp___59 = tmp___58;
              }
            }
            {
            tmp___60 = tmp___59;
            }
          }
          {
          tmp___61 = tmp___60;
          }
        }
        {
        tmp___62 = tmp___61;
        }
      }
      {
      tmp___63 = tmp___62;
      }
    }
    return (tmp___63);
  }
  if (size > 64U) {
    if (size <= 96U) {
      return (1);
    }
  }
  if (size > 128U) {
    if (size <= 192U) {
      return (2);
    }
  }
  if (size <= 8U) {
    return (3);
  }
  if (size <= 16U) {
    return (4);
  }
  if (size <= 32U) {
    return (5);
  }
  if (size <= 64U) {
    return (6);
  }
  if (size <= 128U) {
    return (7);
  }
  if (size <= 256U) {
    return (8);
  }
  if (size <= 512U) {
    return (9);
  }
  if (size <= 1024U) {
    return (10);
  }
  if (size <= 2048U) {
    return (11);
  }
  if (size <= 4096U) {
    return (12);
  }
  if (size <= 8192U) {
    return (13);
  }
  if (size <= 16384U) {
    return (14);
  }
  if (size <= 32768U) {
    return (15);
  }
  if (size <= 65536U) {
    return (16);
  }
  if (size <= 131072U) {
    return (17);
  }
  if (size <= 262144U) {
    return (18);
  }
  if (size <= 524288U) {
    return (19);
  }
  if (size <= 1048576U) {
    return (20);
  }
  if (size <= 2097152U) {
    return (21);
  }
  return (-1);
}
}
__inline static struct kmem_cache *kmalloc_slab(size_t size ) 
{ int index ;
  int tmp ;

  {
  {
  tmp = kmalloc_index(size);
  index = tmp;
  }
  if (index == 0) {
    return ((struct kmem_cache *)((void *)0));
  }
  return (& kmalloc_caches[index]);
}
}
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *kmem_cache_alloc_notrace(struct kmem_cache *s , gfp_t gfpflags ) 
{ void *tmp ;

  {
  {
  tmp = kmem_cache_alloc(s, gfpflags);
  }
  return (tmp);
}
}
__inline static void *kmalloc_large(size_t size , gfp_t flags ) 
{ unsigned int order ;
  int tmp ;
  void *ret ;
  unsigned long tmp___0 ;

  {
  {
  tmp = get_order((unsigned long )size);
  order = (unsigned int )tmp;
  tmp___0 = __get_free_pages(flags | 16384U, order);
  ret = (void *)tmp___0;
  }
  __here: 
  {
  trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )((1UL << 12) << order),
                flags);
  }
  return (ret);
}
}
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *ret ;
  void *tmp ;
  struct kmem_cache *s ;
  struct kmem_cache *tmp___0 ;
  void *tmp___1 ;

  {
  if (0) {
    if ((unsigned long )size > 2UL * (1UL << 12)) {
      {
      tmp = kmalloc_large(size, flags);
      }
      return (tmp);
    }
    if (! (flags & 1U)) {
      {
      tmp___0 = kmalloc_slab(size);
      s = tmp___0;
      }
      if (! s) {
        return ((void *)16);
      }
      {
      ret = kmem_cache_alloc_notrace(s, flags);
      }
      __here: 
      {
      trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )s->size,
                    flags);
      }
      return (ret);
    }
  }
  {
  tmp___1 = __kmalloc(size, flags);
  }
  return (tmp___1);
}
}
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  if (size != 0U) {
    if ((unsigned long )n > 0xffffffffUL / (unsigned long )size) {
      return ((void *)0);
    }
  }
  {
  tmp = __kmalloc(n * size, flags | 32768U);
  }
  return (tmp);
}
}
__inline static void *kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags);
  }
  return (tmp);
}
}
__inline static void *__kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
  tmp = __kmalloc(size, flags);
  }
  return (tmp);
}
}
__inline static void *kmem_cache_alloc_node(struct kmem_cache *cachep , gfp_t flags ,
                                            int node ) 
{ void *tmp ;

  {
  {
  tmp = kmem_cache_alloc(cachep, flags);
  }
  return (tmp);
}
}
extern void *__kmalloc_track_caller(size_t  , gfp_t  , unsigned long  ) ;
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmem_cache_alloc(k, flags | 32768U);
  }
  return (tmp);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc_node(size, flags | 32768U, node);
  }
  return (tmp);
}
}
extern void *pcpu_base_addr ;
extern size_t pcpu_setup_first_chunk(struct page *(*get_page_fn)(unsigned int cpu ,
                                                                 int pageno ) , size_t static_size ,
                                     size_t reserved_size , ssize_t dyn_size , ssize_t unit_size ,
                                     void *base_addr , void (*populate_pte_fn)(unsigned long addr ) )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern ssize_t pcpu_embed_first_chunk(size_t static_size , size_t reserved_size ,
                                      ssize_t dyn_size , ssize_t unit_size )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern void *__alloc_reserved_percpu(size_t size , size_t align ) ;
extern void *__alloc_percpu(size_t size , size_t align ) ;
extern void free_percpu(void *__pdata ) ;
__inline static void local_inc(local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
  return;
}
}
__inline static void local_dec(local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
  return;
}
}
__inline static void local_add(long i , local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
  return;
}
}
__inline static void local_sub(long i , local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
  return;
}
}
__inline static int local_sub_and_test(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%2,%0; sete %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static int local_dec_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int local_inc_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int local_add_negative(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%2,%0; sets %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static long local_add_return(long i , local_t *l ) 
{ long __i ;

  {
  {
  __i = i;
  __asm__  volatile   (" "
                       "xaddl"
                       " "
                       "%0, %1;": "+r" (i), "+m" (l->a.counter): : "memory");
  }
  return (i + __i);
}
}
__inline static long local_sub_return(long i , local_t *l ) 
{ long tmp ;

  {
  {
  tmp = local_add_return(- i, l);
  }
  return (tmp);
}
}
extern int init_module(void) ;
extern void cleanup_module(void) ;
extern struct exception_table_entry  const  *search_extable(struct exception_table_entry  const  *first ,
                                                            struct exception_table_entry  const  *last ,
                                                            unsigned long value ) ;
extern void sort_extable(struct exception_table_entry *start , struct exception_table_entry *finish ) ;
extern void sort_main_extable(void) ;
extern struct exception_table_entry  const  *search_exception_tables(unsigned long add ) ;
extern void *__symbol_get(char const   *symbol ) ;
extern void *__symbol_get_gpl(char const   *symbol ) ;
extern struct mutex module_mutex ;
__inline static int module_is_live(struct module *mod ) 
{ 

  {
  return ((unsigned int )mod->state != 2U);
}
}
extern struct module *__module_text_address(unsigned long addr ) ;
extern struct module *__module_address(unsigned long addr ) ;
extern bool is_module_address(unsigned long addr ) ;
extern bool is_module_text_address(unsigned long addr ) ;
__inline static int within_module_core(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
  if ((unsigned long )mod->module_core <= addr) {
    if (addr < (unsigned long )mod->module_core + (unsigned long )mod->core_size) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int within_module_init(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
  if ((unsigned long )mod->module_init <= addr) {
    if (addr < (unsigned long )mod->module_init + (unsigned long )mod->init_size) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern struct module *find_module(char const   *name ) ;
extern struct kernel_symbol  const  *find_symbol(char const   *name , struct module **owner ,
                                                 unsigned long const   **crc , bool gplok ,
                                                 bool warn ) ;
extern bool each_symbol(bool (*fn)(struct symsearch  const  *arr , struct module *owner ,
                                   unsigned int symnum , void *data ) , void *data ) ;
extern int module_get_kallsym(unsigned int symnum , unsigned long *value , char *type ,
                              char *name , char *module_name , int *exported ) ;
extern unsigned long module_kallsyms_lookup_name(char const   *name ) ;
extern int module_kallsyms_on_each_symbol(int (*fn)(void * , char const   * , struct module * ,
                                                    unsigned long  ) , void *data ) ;
extern  __attribute__((__noreturn__)) void __module_put_and_exit(struct module *mod ,
                                                                 long code ) ;
extern unsigned int module_refcount(struct module *mod ) ;
extern void __symbol_put(char const   *symbol ) ;
extern void symbol_put_addr(void *addr ) ;
__inline static local_t *__module_ref_addr(struct module *mod , int cpu ) 
{ 

  {
  return ((local_t *)(mod->refptr + __per_cpu_offset[cpu]));
}
}
__inline static void __module_get(struct module *module ) 
{ int ret__ ;
  local_t *tmp ;

  {
  if (module) {
    {
    while (1) {
      while_91_continue: /* CIL Label */ ;
      goto while_91_break;
    }
    while_91_break: /* CIL Label */ ;
    }
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_92_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_92_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_92_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_92_8;
          } else {
            {
            goto switch_92_default;
            if (0) {
              switch_92_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_92_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    tmp = __module_ref_addr(module, ret__);
    local_inc(tmp);
    }
    {
    while (1) {
      while_93_continue: /* CIL Label */ ;
      goto while_93_break;
    }
    while_93_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int try_module_get(struct module *module ) 
{ int ret ;
  unsigned int cpu ;
  int ret__ ;
  local_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  ret = 1;
  }
  if (module) {
    {
    while (1) {
      while_94_continue: /* CIL Label */ ;
      goto while_94_break;
    }
    while_94_break: /* CIL Label */ ;
    }
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_95_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_95_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_95_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_95_8;
          } else {
            {
            goto switch_95_default;
            if (0) {
              switch_95_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_95_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    cpu = (unsigned int )ret__;
    tmp___0 = module_is_live(module);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 1L);
    }
    if (tmp___2) {
      {
      tmp = __module_ref_addr(module, (int )cpu);
      local_inc(tmp);
      }
    } else {
      {
      ret = 0;
      }
    }
    {
    while (1) {
      while_96_continue: /* CIL Label */ ;
      goto while_96_break;
    }
    while_96_break: /* CIL Label */ ;
    }
  }
  return (ret);
}
}
extern void module_put(struct module *module ) ;
extern int use_module(struct module *a , struct module *b ) ;
extern char const   *module_address_lookup(unsigned long addr , unsigned long *symbolsize ,
                                           unsigned long *offset , char **modname ,
                                           char *namebuf ) ;
extern int lookup_module_symbol_name(unsigned long addr , char *symname ) ;
extern int lookup_module_symbol_attrs(unsigned long addr , unsigned long *size , unsigned long *offset ,
                                      char *modname , char *name ) ;
extern struct exception_table_entry  const  *search_module_extables(unsigned long addr ) ;
extern int register_module_notifier(struct notifier_block *nb ) ;
extern int unregister_module_notifier(struct notifier_block *nb ) ;
extern void print_modules(void) ;
extern void module_update_markers(void) ;
extern void module_update_tracepoints(void) ;
extern int module_get_iter_tracepoints(struct tracepoint_iter *iter ) ;
extern struct kset *module_kset ;
extern struct kobj_type module_ktype ;
extern int module_sysfs_initialized ;
extern int mod_sysfs_init(struct module *mod ) ;
extern int mod_sysfs_setup(struct module *mod , struct kernel_param *kparam , unsigned int num_params ) ;
extern int module_add_modinfo_attrs(struct module *mod ) ;
extern void module_remove_modinfo_attrs(struct module *mod ) ;
extern struct resource ioport_resource ;
extern struct resource iomem_resource ;
extern int request_resource(struct resource *root , struct resource *new ) ;
extern int release_resource(struct resource *new ) ;
extern void reserve_region_with_split(struct resource *root , resource_size_t start ,
                                      resource_size_t end , char const   *name ) ;
extern int insert_resource(struct resource *parent , struct resource *new ) ;
extern void insert_resource_expand_to_fit(struct resource *root , struct resource *new ) ;
extern int allocate_resource(struct resource *root , struct resource *new , resource_size_t size ,
                             resource_size_t min , resource_size_t max , resource_size_t align ,
                             void (*alignf)(void * , struct resource * , resource_size_t  ,
                                            resource_size_t  ) , void *alignf_data ) ;
extern int adjust_resource(struct resource *res , resource_size_t start , resource_size_t size ) ;
extern resource_size_t resource_alignment(struct resource *res ) ;
__inline static resource_size_t resource_size(struct resource *res ) 
{ 

  {
  return ((res->end - res->start) + 1U);
}
}
__inline static unsigned long resource_type(struct resource *res ) 
{ 

  {
  return (res->flags & 3840UL);
}
}
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
extern int __check_region(struct resource * , resource_size_t  , resource_size_t  ) ;
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
__inline static int check_region(resource_size_t s , resource_size_t n ) 
{ int tmp ;

  {
  {
  tmp = __check_region(& ioport_resource, s, n);
  }
  return (tmp);
}
}
extern struct resource *__devm_request_region(struct device *dev , struct resource *parent ,
                                              resource_size_t start , resource_size_t n ,
                                              char const   *name ) ;
extern void __devm_release_region(struct device *dev , struct resource *parent , resource_size_t start ,
                                  resource_size_t n ) ;
extern int iomem_map_sanity_check(resource_size_t addr , unsigned long size ) ;
extern int iomem_is_exclusive(u64 addr ) ;
extern void klist_init(struct klist *k , void (*get)(struct klist_node * ) , void (*put)(struct klist_node * ) ) ;
extern void klist_add_tail(struct klist_node *n , struct klist *k ) ;
extern void klist_add_head(struct klist_node *n , struct klist *k ) ;
extern void klist_add_after(struct klist_node *n , struct klist_node *pos ) ;
extern void klist_add_before(struct klist_node *n , struct klist_node *pos ) ;
extern void klist_del(struct klist_node *n ) ;
extern void klist_remove(struct klist_node *n ) ;
extern int klist_node_attached(struct klist_node *n ) ;
extern void klist_iter_init(struct klist *k , struct klist_iter *i ) ;
extern void klist_iter_init_node(struct klist *k , struct klist_iter *i , struct klist_node *n ) ;
extern void klist_iter_exit(struct klist_iter *i ) ;
extern struct klist_node *klist_next(struct klist_iter *i ) ;
static struct lock_class_key __key  ;
__inline static void sema_init(struct semaphore *sem , int val ) 
{ struct semaphore __constr_expr_0 ;

  {
  {
  __constr_expr_0.lock.raw_lock.slock = 0U;
  __constr_expr_0.count = (unsigned int )val;
  __constr_expr_0.wait_list.next = & sem->wait_list;
  __constr_expr_0.wait_list.prev = & sem->wait_list;
  *sem = __constr_expr_0;
  }
  {
  while (1) {
    while_97_continue: /* CIL Label */ ;
    goto while_97_break;
  }
  while_97_break: /* CIL Label */ ;
  }
  return;
}
}
extern void down(struct semaphore *sem ) ;
extern int down_interruptible(struct semaphore *sem ) ;
extern int down_killable(struct semaphore *sem ) ;
extern int down_trylock(struct semaphore *sem ) ;
extern int down_timeout(struct semaphore *sem , long jiffies ) ;
extern void up(struct semaphore *sem ) ;
extern int bus_create_file(struct bus_type * , struct bus_attribute * ) ;
extern void bus_remove_file(struct bus_type * , struct bus_attribute * ) ;
extern int bus_register(struct bus_type *bus ) ;
extern void bus_unregister(struct bus_type *bus ) ;
extern int bus_rescan_devices(struct bus_type *bus ) ;
extern int bus_for_each_dev(struct bus_type *bus , struct device *start , void *data ,
                            int (*fn)(struct device *dev , void *data ) ) ;
extern struct device *bus_find_device(struct bus_type *bus , struct device *start ,
                                      void *data , int (*match)(struct device *dev ,
                                                                void *data ) ) ;
extern struct device *bus_find_device_by_name(struct bus_type *bus , struct device *start ,
                                              char const   *name ) ;
extern int bus_for_each_drv(struct bus_type *bus , struct device_driver *start , void *data ,
                            int (*fn)(struct device_driver * , void * ) ) ;
extern void bus_sort_breadthfirst(struct bus_type *bus , int (*compare)(struct device  const  *a ,
                                                                        struct device  const  *b ) ) ;
extern int bus_register_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
extern int bus_unregister_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
extern struct kset *bus_get_kset(struct bus_type *bus ) ;
extern struct klist *bus_get_device_klist(struct bus_type *bus ) ;
extern int driver_register(struct device_driver *drv ) ;
extern void driver_unregister(struct device_driver *drv ) ;
extern struct device_driver *get_driver(struct device_driver *drv ) ;
extern void put_driver(struct device_driver *drv ) ;
extern struct device_driver *driver_find(char const   *name , struct bus_type *bus ) ;
extern int driver_probe_done(void) ;
extern void wait_for_device_probe(void) ;
extern int driver_create_file(struct device_driver *driver , struct driver_attribute *attr ) ;
extern void driver_remove_file(struct device_driver *driver , struct driver_attribute *attr ) ;
extern int driver_add_kobj(struct device_driver *drv , struct kobject *kobj , char const   *fmt 
                           , ...) ;
extern int driver_for_each_device(struct device_driver *drv , struct device *start ,
                                  void *data , int (*fn)(struct device *dev , void * ) ) ;
extern struct device *driver_find_device(struct device_driver *drv , struct device *start ,
                                         void *data , int (*match)(struct device *dev ,
                                                                   void *data ) ) ;
extern struct kobject *sysfs_dev_block_kobj ;
extern struct kobject *sysfs_dev_char_kobj ;
extern int __class_register(struct class *class , struct lock_class_key *key ) ;
extern void class_unregister(struct class *class ) ;
extern void class_dev_iter_init(struct class_dev_iter *iter , struct class *class ,
                                struct device *start , struct device_type  const  *type ) ;
extern struct device *class_dev_iter_next(struct class_dev_iter *iter ) ;
extern void class_dev_iter_exit(struct class_dev_iter *iter ) ;
extern int class_for_each_device(struct class *class , struct device *start , void *data ,
                                 int (*fn)(struct device *dev , void *data ) ) ;
extern struct device *class_find_device(struct class *class , struct device *start ,
                                        void *data , int (*match)(struct device * ,
                                                                  void * ) ) ;
extern int class_create_file(struct class *class , struct class_attribute  const  *attr ) ;
extern void class_remove_file(struct class *class , struct class_attribute  const  *attr ) ;
extern int class_interface_register(struct class_interface * ) ;
extern void class_interface_unregister(struct class_interface * ) ;
extern struct class *__class_create(struct module *owner , char const   *name , struct lock_class_key *key ) ;
extern void class_destroy(struct class *cls ) ;
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
extern int device_create_bin_file(struct device *dev , struct bin_attribute *attr ) ;
extern void device_remove_bin_file(struct device *dev , struct bin_attribute *attr ) ;
extern int device_schedule_callback_owner(struct device *dev , void (*func)(struct device *dev ) ,
                                          struct module *owner ) ;
extern void *__devres_alloc(void (*release)(struct device *dev , void *res ) , size_t size ,
                            gfp_t gfp , char const   *name ) ;
extern void devres_free(void *res ) ;
extern void devres_add(struct device *dev , void *res ) ;
extern void *devres_find(struct device *dev , void (*release)(struct device *dev ,
                                                              void *res ) , int (*match)(struct device *dev ,
                                                                                         void *res ,
                                                                                         void *match_data ) ,
                         void *match_data ) ;
extern void *devres_get(struct device *dev , void *new_res , int (*match)(struct device *dev ,
                                                                          void *res ,
                                                                          void *match_data ) ,
                        void *match_data ) ;
extern void *devres_remove(struct device *dev , void (*release)(struct device *dev ,
                                                                void *res ) , int (*match)(struct device *dev ,
                                                                                           void *res ,
                                                                                           void *match_data ) ,
                           void *match_data ) ;
extern int devres_destroy(struct device *dev , void (*release)(struct device *dev ,
                                                               void *res ) , int (*match)(struct device *dev ,
                                                                                          void *res ,
                                                                                          void *match_data ) ,
                          void *match_data ) ;
extern void *devres_open_group(struct device *dev , void *id , gfp_t gfp ) ;
extern void devres_close_group(struct device *dev , void *id ) ;
extern void devres_remove_group(struct device *dev , void *id ) ;
extern int devres_release_group(struct device *dev , void *id ) ;
extern void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) ;
extern void devm_kfree(struct device *dev , void *p ) ;
__inline static void device_init_wakeup(struct device *dev , int val ) 
{ unsigned int tmp ;

  {
  {
  tmp = (unsigned int )(! (! val));
  dev->power.should_wakeup = tmp;
  dev->power.can_wakeup = tmp;
  }
  return;
}
}
__inline static void device_set_wakeup_capable(struct device *dev , int val ) 
{ 

  {
  {
  dev->power.can_wakeup = (unsigned int )(! (! val));
  }
  return;
}
}
__inline static int device_can_wakeup(struct device *dev ) 
{ 

  {
  return ((int )dev->power.can_wakeup);
}
}
__inline static void device_set_wakeup_enable(struct device *dev , int val ) 
{ 

  {
  {
  dev->power.should_wakeup = (unsigned int )(! (! val));
  }
  return;
}
}
__inline static int device_may_wakeup(struct device *dev ) 
{ int tmp ;

  {
  if (dev->power.can_wakeup) {
    if (dev->power.should_wakeup) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static char const   *dev_name(struct device  const  *dev ) 
{ char const   *tmp ;

  {
  {
  tmp = kobject_name(& dev->kobj);
  }
  return (tmp);
}
}
extern int ( /* format attribute */  dev_set_name)(struct device *dev , char const   *name 
                                                   , ...) ;
__inline static int dev_to_node(struct device *dev ) 
{ 

  {
  return (-1);
}
}
__inline static void set_dev_node(struct device *dev , int node ) 
{ 

  {
  return;
}
}
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 

  {
  return ((void *)dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 

  {
  {
  dev->driver_data = data;
  }
  return;
}
}
__inline static unsigned int dev_get_uevent_suppress(struct device  const  *dev ) 
{ 

  {
  return ((unsigned int )dev->kobj.uevent_suppress);
}
}
__inline static void dev_set_uevent_suppress(struct device *dev , int val ) 
{ 

  {
  {
  dev->kobj.uevent_suppress = (unsigned int )val;
  }
  return;
}
}
__inline static int device_is_registered(struct device *dev ) 
{ 

  {
  return ((int )dev->kobj.state_in_sysfs);
}
}
extern void driver_init(void) ;
extern int device_register(struct device *dev ) ;
extern void device_unregister(struct device *dev ) ;
extern void device_initialize(struct device *dev ) ;
extern int device_add(struct device *dev ) ;
extern void device_del(struct device *dev ) ;
extern int device_for_each_child(struct device *dev , void *data , int (*fn)(struct device *dev ,
                                                                             void *data ) ) ;
extern struct device *device_find_child(struct device *dev , void *data , int (*match)(struct device *dev ,
                                                                                       void *data ) ) ;
extern int device_rename(struct device *dev , char *new_name ) ;
extern int device_move(struct device *dev , struct device *new_parent , enum dpm_order dpm_order ) ;
extern struct device *__root_device_register(char const   *name , struct module *owner ) ;
__inline static struct device *root_device_register(char const   *name ) 
{ struct device *tmp ;

  {
  {
  tmp = __root_device_register(name, (struct module *)0);
  }
  return (tmp);
}
}
extern void root_device_unregister(struct device *root ) ;
extern int device_bind_driver(struct device *dev ) ;
extern void device_release_driver(struct device *dev ) ;
extern int device_attach(struct device *dev ) ;
extern int driver_attach(struct device_driver *drv ) ;
extern int device_reprobe(struct device *dev ) ;
extern struct device *device_create_vargs(struct class *cls , struct device *parent ,
                                          dev_t devt , void *drvdata , char const   *fmt ,
                                          va_list vargs ) ;
extern struct device *( /* format attribute */  device_create)(struct class *cls ,
                                                               struct device *parent ,
                                                               dev_t devt , void *drvdata ,
                                                               char const   *fmt 
                                                               , ...) ;
extern void device_destroy(struct class *cls , dev_t devt ) ;
extern int (*platform_notify)(struct device *dev ) ;
extern int (*platform_notify_remove)(struct device *dev ) ;
extern struct device *get_device(struct device *dev ) ;
extern void put_device(struct device *dev ) ;
extern void device_shutdown(void) ;
extern void sysdev_shutdown(void) ;
extern char const   *dev_driver_string(struct device  const  *dev ) ;
__inline static void rb_set_parent(struct rb_node *rb , struct rb_node *p ) 
{ 

  {
  {
  rb->rb_parent_color = (rb->rb_parent_color & 3UL) | (unsigned long )p;
  }
  return;
}
}
__inline static void rb_set_color(struct rb_node *rb , int color ) 
{ 

  {
  {
  rb->rb_parent_color = (rb->rb_parent_color & 0xfffffffeUL) | (unsigned long )color;
  }
  return;
}
}
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
extern struct rb_node *rb_next(struct rb_node  const  * ) ;
extern struct rb_node *rb_prev(struct rb_node  const  * ) ;
extern struct rb_node *rb_first(struct rb_root  const  * ) ;
extern struct rb_node *rb_last(struct rb_root  const  * ) ;
extern void rb_replace_node(struct rb_node *victim , struct rb_node *new , struct rb_root *root ) ;
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link ) 
{ struct rb_node *tmp ;

  {
  {
  node->rb_parent_color = (unsigned long )parent;
  tmp = (struct rb_node *)((void *)0);
  node->rb_right = tmp;
  node->rb_left = tmp;
  *rb_link = node;
  }
  return;
}
}
__inline static void prio_tree_iter_init(struct prio_tree_iter *iter , struct prio_tree_root *root ,
                                         unsigned long r_index , unsigned long h_index ) 
{ 

  {
  {
  iter->root = root;
  iter->r_index = r_index;
  iter->h_index = h_index;
  iter->cur = (struct prio_tree_node *)((void *)0);
  }
  return;
}
}
__inline static int prio_tree_empty(struct prio_tree_root  const  *root ) 
{ 

  {
  return ((unsigned long )root->prio_tree_node == (unsigned long )((void *)0));
}
}
__inline static int prio_tree_root(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((unsigned long )node->parent == (unsigned long )node);
}
}
__inline static int prio_tree_left_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((unsigned long )node->left == (unsigned long )node);
}
}
__inline static int prio_tree_right_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((unsigned long )node->right == (unsigned long )node);
}
}
extern struct prio_tree_node *prio_tree_replace(struct prio_tree_root *root , struct prio_tree_node *old ,
                                                struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_insert(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern void prio_tree_remove(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter ) ;
extern int debug_locks ;
extern int debug_locks_silent ;
__inline static int __debug_locks_off(void) 
{ unsigned long tmp ;

  {
  {
  tmp = __xchg(0UL, (void volatile   *)(& debug_locks), (int )sizeof(debug_locks));
  }
  return ((int )tmp);
}
}
extern int debug_locks_off(void) ;
extern unsigned long max_mapnr ;
extern unsigned long num_physpages ;
extern void *high_memory ;
extern int page_cluster ;
extern unsigned long mmap_min_addr ;
extern unsigned long empty_zero_page[(1UL << 12) / sizeof(unsigned long )] ;
extern spinlock_t pgd_lock ;
extern struct list_head pgd_list ;
__inline static void paravirt_pagetable_setup_start(pgd_t *base )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static void paravirt_pagetable_setup_start(pgd_t *base ) 
{ 

  {
  {
  native_pagetable_setup_start(base);
  }
  return;
}
}
__inline static void paravirt_pagetable_setup_done(pgd_t *base )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static void paravirt_pagetable_setup_done(pgd_t *base ) 
{ 

  {
  {
  native_pagetable_setup_done(base);
  }
  return;
}
}
__inline static int pte_dirty(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 6)));
}
}
__inline static int pte_young(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 5)));
}
}
__inline static int pte_write(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 1)));
}
}
__inline static int pte_huge(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 7)));
}
}
__inline static int pte_global(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 8)));
}
}
__inline static int pte_exec(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return (1);
}
}
__inline static int pte_special(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 9)));
}
}
__inline static unsigned long pte_pfn(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = native_pte_val(pte);
  }
  return ((tmp & (unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))) >> 12);
}
}
__inline static int pmd_large(pmd_t pte ) 
{ pmdval_t tmp ;

  {
  {
  tmp = pmd_flags(pte);
  }
  return ((tmp & ((1UL << 7) | 1UL)) == ((1UL << 7) | 1UL));
}
}
__inline static pte_t pte_set_flags(pte_t pte , pteval_t set ) 
{ pteval_t v ;
  pteval_t tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = native_pte_val(pte);
  v = tmp;
  tmp___0 = native_make_pte(v | set);
  }
  return (tmp___0);
}
}
__inline static pte_t pte_clear_flags(pte_t pte , pteval_t clear ) 
{ pteval_t v ;
  pteval_t tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = native_pte_val(pte);
  v = tmp;
  tmp___0 = native_make_pte(v & ~ clear);
  }
  return (tmp___0);
}
}
__inline static pte_t pte_mkclean(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 6);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkold(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 5);
  }
  return (tmp);
}
}
__inline static pte_t pte_wrprotect(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 1);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkexec(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 0UL);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkdirty(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 6);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkyoung(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 5);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkwrite(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 1);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkhuge(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 7);
  }
  return (tmp);
}
}
__inline static pte_t pte_clrhuge(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 7);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkglobal(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 8);
  }
  return (tmp);
}
}
__inline static pte_t pte_clrglobal(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 8);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkspecial(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 9);
  }
  return (tmp);
}
}
__inline static pgprotval_t massage_pgprot(pgprot_t pgprot ) 
{ pgprotval_t protval ;

  {
  {
  protval = pgprot.pgprot;
  }
  if (protval & 1UL) {
    {
    protval &= __supported_pte_mask;
    }
  }
  return (protval);
}
}
__inline static pte_t pfn_pte(unsigned long page_nr , pgprot_t pgprot ) 
{ pgprotval_t tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = massage_pgprot(pgprot);
  tmp___0 = native_make_pte((unsigned long )((unsigned int )page_nr << 12) | tmp);
  }
  return (tmp___0);
}
}
__inline static pmd_t pfn_pmd(unsigned long page_nr , pgprot_t pgprot ) 
{ pmd_t __constr_expr_0 ;
  pgprotval_t tmp ;
  pgd_t tmp___0 ;

  {
  {
  tmp = massage_pgprot(pgprot);
  tmp___0 = native_make_pgd((unsigned long )((unsigned int )page_nr << 12) | tmp);
  __constr_expr_0.pud.pgd = tmp___0;
  }
  return (__constr_expr_0);
}
}
__inline static pte_t pte_modify(pte_t pte , pgprot_t newprot ) 
{ pteval_t val ;
  pteval_t tmp ;
  pgprotval_t tmp___0 ;
  pte_t tmp___1 ;

  {
  {
  tmp = native_pte_val(pte);
  val = tmp;
  val &= (((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6);
  tmp___0 = massage_pgprot(newprot);
  val |= tmp___0 & ~ ((((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
  tmp___1 = native_make_pte(val);
  }
  return (tmp___1);
}
}
__inline static pgprot_t pgprot_modify(pgprot_t oldprot , pgprot_t newprot ) 
{ pgprotval_t preservebits ;
  pgprotval_t addbits ;
  pgprot_t __constr_expr_0 ;

  {
  {
  preservebits = oldprot.pgprot & ((((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
  addbits = newprot.pgprot;
  __constr_expr_0.pgprot = preservebits | addbits;
  }
  return (__constr_expr_0);
}
}
__inline static int is_new_memtype_allowed(unsigned long flags , unsigned long new_flags ) 
{ 

  {
  if (flags == 1UL << 4) {
    if (new_flags == 0UL) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (flags == 1UL << 3) {
      if (new_flags == 0UL) {
        return (0);
      }
    }
  }
  return (1);
}
}
extern pmd_t *populate_extra_pmd(unsigned long vaddr ) ;
extern pte_t *populate_extra_pte(unsigned long vaddr ) ;
extern pgd_t swapper_pg_dir[1024] ;
extern void paging_init(void) ;
extern void set_pmd_pfn(unsigned long  , unsigned long  , pgprot_t  ) ;
__inline static void native_set_pte(pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  *ptep = pte;
  }
  return;
}
}
__inline static void native_set_pmd(pmd_t *pmdp , pmd_t pmd ) 
{ 

  {
  {
  *pmdp = pmd;
  }
  return;
}
}
__inline static void native_set_pte_atomic(pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  native_set_pte(ptep, pte);
  }
  return;
}
}
__inline static void native_pmd_clear(pmd_t *pmdp ) 
{ pmd_t __constr_expr_0 ;
  pgd_t tmp ;

  {
  {
  tmp = native_make_pgd(0UL);
  __constr_expr_0.pud.pgd = tmp;
  native_set_pmd(pmdp, __constr_expr_0);
  }
  return;
}
}
__inline static void native_pte_clear(struct mm_struct *mm , unsigned long addr ,
                                      pte_t *xp ) 
{ 

  {
  {
  *xp = native_make_pte(0UL);
  }
  return;
}
}
__inline static pte_t native_ptep_get_and_clear(pte_t *xp ) 
{ unsigned long tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = __xchg(0UL, (void volatile   *)(& xp->pte_low), (int )sizeof(xp->pte_low));
  tmp___0 = native_make_pte(tmp);
  }
  return (tmp___0);
}
}
__inline static int pte_none(pte_t pte ) 
{ 

  {
  return (! pte.pte);
}
}
__inline static int pte_same(pte_t a , pte_t b ) 
{ 

  {
  return (a.pte == b.pte);
}
}
__inline static int pte_present(pte_t a ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(a);
  }
  return ((int )(tmp & (1UL | (1UL << 8))));
}
}
__inline static int pmd_present(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = pmd_flags(pmd);
  }
  return ((int )(tmp & 1UL));
}
}
__inline static int pmd_none(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = native_pmd_val(pmd);
  }
  return (tmp == 0UL);
}
}
__inline static unsigned long pmd_page_vaddr(pmd_t pmd ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pmd.pud.pgd);
  }
  return ((unsigned long )((void *)((tmp & (unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))) + 3221225472UL)));
}
}
__inline static unsigned int pmd_index(unsigned long address ) 
{ 

  {
  return (0U);
}
}
__inline static unsigned int pte_index(unsigned long address ) 
{ 

  {
  return ((unsigned int )((address >> 12) & 1023UL));
}
}
__inline static pte_t *pte_offset_kernel(pmd_t *pmd , unsigned long address ) 
{ unsigned long tmp ;
  unsigned int tmp___0 ;

  {
  {
  tmp = pmd_page_vaddr(*pmd);
  tmp___0 = pte_index(address);
  }
  return ((pte_t *)tmp + tmp___0);
}
}
__inline static int pmd_bad(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = pmd_flags(pmd);
  }
  return ((tmp & ~ (1UL << 2)) != (((1UL | (1UL << 1)) | (1UL << 5)) | (1UL << 6)));
}
}
__inline static unsigned long pages_to_mb(unsigned long npg ) 
{ 

  {
  return (npg >> 8);
}
}
__inline static pte_t native_local_ptep_get_and_clear(pte_t *ptep ) 
{ pte_t res ;

  {
  {
  res = *ptep;
  native_pte_clear((struct mm_struct *)((void *)0), 0UL, ptep);
  }
  return (res);
}
}
__inline static void native_set_pte_at(struct mm_struct *mm , unsigned long addr ,
                                       pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  native_set_pte(ptep, pte);
  }
  return;
}
}
extern int ptep_set_access_flags(struct vm_area_struct *vma , unsigned long address ,
                                 pte_t *ptep , pte_t entry , int dirty ) ;
extern int ptep_test_and_clear_young(struct vm_area_struct *vma , unsigned long addr ,
                                     pte_t *ptep ) ;
extern int ptep_clear_flush_young(struct vm_area_struct *vma , unsigned long address ,
                                  pte_t *ptep ) ;
__inline static pte_t ptep_get_and_clear(struct mm_struct *mm , unsigned long addr ,
                                         pte_t *ptep ) 
{ pte_t pte ;
  pte_t tmp ;

  {
  {
  tmp = native_ptep_get_and_clear(ptep);
  pte = tmp;
  }
  {
  while (1) {
    while_98_continue: /* CIL Label */ ;
    goto while_98_break;
  }
  while_98_break: /* CIL Label */ ;
  }
  return (pte);
}
}
__inline static pte_t ptep_get_and_clear_full(struct mm_struct *mm , unsigned long addr ,
                                              pte_t *ptep , int full ) 
{ pte_t pte ;

  {
  if (full) {
    {
    pte = native_local_ptep_get_and_clear(ptep);
    }
  } else {
    {
    pte = ptep_get_and_clear(mm, addr, ptep);
    }
  }
  return (pte);
}
}
__inline static void ptep_set_wrprotect(struct mm_struct *mm , unsigned long addr ,
                                        pte_t *ptep ) 
{ 

  {
  {
  clear_bit(1, (unsigned long volatile   *)(& ptep->pte));
  }
  {
  while (1) {
    while_99_continue: /* CIL Label */ ;
    goto while_99_break;
  }
  while_99_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void clone_pgd_range(pgd_t *dst , pgd_t *src , int count ) 
{ 

  {
  {
  __memcpy((void *)dst, (void const   *)src, (unsigned int )((unsigned long )count * sizeof(pgd_t )));
  }
  return;
}
}
extern void pgd_clear_bad(pgd_t * ) ;
extern void pud_clear_bad(pud_t * ) ;
extern void pmd_clear_bad(pmd_t * ) ;
__inline static int pgd_none_or_clear_bad(pgd_t *pgd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = pgd_none(*pgd);
  }
  if (tmp) {
    return (1);
  }
  {
  tmp___0 = pgd_none(*pgd);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    pgd_clear_bad(pgd);
    }
    return (1);
  }
  return (0);
}
}
__inline static int pud_none_or_clear_bad(pud_t *pud ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = pud_none(*pud);
  }
  if (tmp) {
    return (1);
  }
  {
  tmp___0 = pud_none(*pud);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    pud_clear_bad(pud);
    }
    return (1);
  }
  return (0);
}
}
__inline static int pmd_none_or_clear_bad(pmd_t *pmd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = pmd_none(*pmd);
  }
  if (tmp) {
    return (1);
  }
  {
  tmp___0 = pmd_bad(*pmd);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    pmd_clear_bad(pmd);
    }
    return (1);
  }
  return (0);
}
}
__inline static pte_t __ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep ) 
{ pte_t tmp ;

  {
  {
  tmp = ptep_get_and_clear(mm, addr, ptep);
  }
  return (tmp);
}
}
__inline static void __ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  native_set_pte_at(mm, addr, ptep, pte);
  }
  return;
}
}
__inline static pte_t ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep ) 
{ pte_t tmp ;

  {
  {
  tmp = __ptep_modify_prot_start(mm, addr, ptep);
  }
  return (tmp);
}
}
__inline static void ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  __ptep_modify_prot_commit(mm, addr, ptep, pte);
  }
  return;
}
}
extern int track_pfn_vma_new(struct vm_area_struct *vma , pgprot_t *prot , unsigned long pfn ,
                             unsigned long size ) ;
extern int track_pfn_vma_copy(struct vm_area_struct *vma ) ;
extern void untrack_pfn_vma(struct vm_area_struct *vma , unsigned long pfn , unsigned long size ) ;
extern struct kmem_cache *vm_area_cachep ;
extern pgprot_t protection_map[16] ;
__inline static int is_linear_pfn_mapping(struct vm_area_struct *vma ) 
{ 

  {
  return ((int )(vma->vm_flags & 1073741824UL));
}
}
__inline static int is_pfn_mapping(struct vm_area_struct *vma ) 
{ 

  {
  return ((int )(vma->vm_flags & 1024UL));
}
}
__inline static int PageLocked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestSetPageLocked(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageError(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageError(struct page *page ) 
{ 

  {
  {
  set_bit(1U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageError(struct page *page ) 
{ 

  {
  {
  clear_bit(1, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageReferenced(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageReferenced(struct page *page ) 
{ 

  {
  {
  set_bit(2U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageReferenced(struct page *page ) 
{ 

  {
  {
  clear_bit(2, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageReferenced(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(2, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageDirty(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(4U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageDirty(struct page *page ) 
{ 

  {
  {
  set_bit(4U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageDirty(struct page *page ) 
{ 

  {
  {
  clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPageDirty(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPageDirty(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __ClearPageDirty(struct page *page ) 
{ 

  {
  {
  __clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageLRU(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(5U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageLRU(struct page *page ) 
{ 

  {
  {
  set_bit(5U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageLRU(struct page *page ) 
{ 

  {
  {
  clear_bit(5, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageLRU(struct page *page ) 
{ 

  {
  {
  __clear_bit(5, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageActive(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(6U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageActive(struct page *page ) 
{ 

  {
  {
  set_bit(6U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageActive(struct page *page ) 
{ 

  {
  {
  clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageActive(struct page *page ) 
{ 

  {
  {
  __clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageActive(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageSlab(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(7U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageSlab(struct page *page ) 
{ 

  {
  {
  __set_bit(7, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSlab(struct page *page ) 
{ 

  {
  {
  __clear_bit(7, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageChecked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(8U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageChecked(struct page *page ) 
{ 

  {
  {
  set_bit(8U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageChecked(struct page *page ) 
{ 

  {
  {
  clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPagePinned(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(8, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPagePinned(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageReserved(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(10U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageReserved(struct page *page ) 
{ 

  {
  {
  set_bit(10U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageReserved(struct page *page ) 
{ 

  {
  {
  clear_bit(10, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageReserved(struct page *page ) 
{ 

  {
  {
  __clear_bit(10, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageSwapBacked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(20U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageSwapBacked(struct page *page ) 
{ 

  {
  {
  set_bit(20U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageSwapBacked(struct page *page ) 
{ 

  {
  {
  clear_bit(20, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSwapBacked(struct page *page ) 
{ 

  {
  {
  __clear_bit(20, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __SetPageSlobPage(struct page *page ) 
{ 

  {
  {
  __set_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageSlobFree(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(11U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageSlobFree(struct page *page ) 
{ 

  {
  {
  __set_bit(11, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSlobFree(struct page *page ) 
{ 

  {
  {
  __clear_bit(11, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __SetPageSlubDebug(struct page *page ) 
{ 

  {
  {
  __set_bit(1, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSlubDebug(struct page *page ) 
{ 

  {
  {
  __clear_bit(1, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void SetPagePrivate(struct page *page ) 
{ 

  {
  {
  set_bit(11U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPagePrivate(struct page *page ) 
{ 

  {
  {
  clear_bit(11, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PagePrivate2(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(12U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPagePrivate2(struct page *page ) 
{ 

  {
  {
  set_bit(12U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPagePrivate2(struct page *page ) 
{ 

  {
  {
  clear_bit(12, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPagePrivate2(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(12, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPagePrivate2(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(12, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageWriteback(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(13U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestSetPageWriteback(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(13, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPageWriteback(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(13, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageBuddy(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(19U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageBuddy(struct page *page ) 
{ 

  {
  {
  __set_bit(19, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageBuddy(struct page *page ) 
{ 

  {
  {
  __clear_bit(19, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageMappedToDisk(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(17U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageMappedToDisk(struct page *page ) 
{ 

  {
  {
  set_bit(17U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageMappedToDisk(struct page *page ) 
{ 

  {
  {
  clear_bit(17, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageReclaim(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(18U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageReclaim(struct page *page ) 
{ 

  {
  {
  set_bit(18U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageReclaim(struct page *page ) 
{ 

  {
  {
  clear_bit(18, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageReclaim(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(18, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageSwapCache(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(16U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageSwapCache(struct page *page ) 
{ 

  {
  {
  set_bit(16U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageSwapCache(struct page *page ) 
{ 

  {
  {
  clear_bit(16, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageUnevictable(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(21U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageUnevictable(struct page *page ) 
{ 

  {
  {
  set_bit(21U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageUnevictable(struct page *page ) 
{ 

  {
  {
  clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageUnevictable(struct page *page ) 
{ 

  {
  {
  __clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageUnevictable(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageMlocked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(22U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageMlocked(struct page *page ) 
{ 

  {
  {
  set_bit(22U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageMlocked(struct page *page ) 
{ 

  {
  {
  clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageMlocked(struct page *page ) 
{ 

  {
  {
  __clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPageMlocked(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPageMlocked(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageUncached(struct page *page ) 
{ 

  {
  return (0);
}
}
__inline static int PageUptodate(struct page *page ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(3U, (unsigned long const volatile   *)(& page->flags));
  ret = tmp;
  }
  if (ret) {
    {
    __asm__  volatile   ("": : : "memory");
    }
  }
  return (ret);
}
}
__inline static void __SetPageUptodate(struct page *page ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  __set_bit(3, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void SetPageUptodate(struct page *page ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  set_bit(3U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageUptodate(struct page *page ) 
{ 

  {
  {
  clear_bit(3, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
extern void cancel_dirty_page(struct page *page , unsigned int account_size ) ;
extern int test_clear_page_writeback(struct page *page ) ;
extern int test_set_page_writeback(struct page *page ) ;
__inline static void set_page_writeback(struct page *page ) 
{ 

  {
  {
  test_set_page_writeback(page);
  }
  return;
}
}
__inline static int PageHead(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(14U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageHead(struct page *page ) 
{ 

  {
  {
  __set_bit(14, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageHead(struct page *page ) 
{ 

  {
  {
  __clear_bit(14, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageTail(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(15U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageTail(struct page *page ) 
{ 

  {
  {
  __set_bit(15, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageTail(struct page *page ) 
{ 

  {
  {
  __clear_bit(15, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageCompound(struct page *page ) 
{ 

  {
  return ((int )(page->flags & (unsigned long )((1L << 14) | (1L << 15))));
}
}
__inline static int put_page_testzero(struct page *page ) 
{ int tmp ;

  {
  {
  while (1) {
    while_100_continue: /* CIL Label */ ;
    goto while_100_break;
  }
  while_100_break: /* CIL Label */ ;
  }
  {
  tmp = atomic_dec_and_test(& page->_count);
  }
  return (tmp);
}
}
__inline static int get_page_unless_zero(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = atomic_add_unless(& page->_count, 1, 0);
  }
  return (tmp);
}
}
extern struct page *vmalloc_to_page(void const   *addr ) ;
extern unsigned long vmalloc_to_pfn(void const   *addr ) ;
__inline static int is_vmalloc_addr(void const   *x ) 
{ unsigned long addr ;
  int tmp ;

  {
  {
  addr = (unsigned long )x;
  }
  if (addr >= (unsigned long )high_memory + 8388608UL) {
    if (addr < (((__FIXADDR_TOP - (unsigned long )(513 << 12)) - (1UL << 12) * 1025UL) & ~ ((1UL << 22) - 1UL)) - 2UL * (1UL << 12)) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static struct page *compound_head(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = PageTail(page);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return (page->__annonCompField19.first_page);
  }
  return (page);
}
}
__inline static int page_count(struct page *page ) 
{ struct page *tmp ;

  {
  {
  tmp = compound_head(page);
  }
  return ((int )tmp->_count.counter);
}
}
__inline static void get_page(struct page *page ) 
{ 

  {
  {
  page = compound_head(page);
  }
  {
  while (1) {
    while_101_continue: /* CIL Label */ ;
    goto while_101_break;
  }
  while_101_break: /* CIL Label */ ;
  }
  {
  atomic_inc(& page->_count);
  }
  return;
}
}
__inline static struct page *virt_to_head_page(void const   *x ) 
{ struct page *page ;
  struct page *tmp ;

  {
  {
  page = mem_map + (((unsigned long )x - 3221225472UL) >> 12);
  tmp = compound_head(page);
  }
  return (tmp);
}
}
__inline static void init_page_count(struct page *page ) 
{ 

  {
  {
  page->_count.counter = (int volatile   )1;
  }
  return;
}
}
extern void put_page(struct page *page ) ;
extern void put_pages_list(struct list_head *pages ) ;
extern void split_page(struct page *page , unsigned int order ) ;
__inline static void set_compound_page_dtor(struct page *page , compound_page_dtor *dtor ) 
{ 

  {
  {
  (page + 1)->lru.next = (struct list_head *)((void *)dtor);
  }
  return;
}
}
__inline static compound_page_dtor *get_compound_page_dtor(struct page *page ) 
{ 

  {
  return ((compound_page_dtor *)(page + 1)->lru.next);
}
}
__inline static int compound_order(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = PageHead(page);
  }
  if (! tmp) {
    return (0);
  }
  return ((int )((unsigned long )(page + 1)->lru.prev));
}
}
__inline static void set_compound_order(struct page *page , unsigned long order ) 
{ 

  {
  {
  (page + 1)->lru.prev = (struct list_head *)((void *)order);
  }
  return;
}
}
__inline static enum zone_type page_zonenum(struct page *page ) 
{ 

  {
  return ((enum zone_type )((page->flags >> (sizeof(unsigned long ) * 8UL - 2UL)) & ((1UL << 2) - 1UL)));
}
}
__inline static int page_zone_id(struct page *page ) 
{ unsigned long tmp ;

  {
  if (sizeof(unsigned long ) * 8UL < sizeof(unsigned long ) * 8UL - 2UL) {
    {
    tmp = sizeof(unsigned long ) * 8UL;
    }
  } else {
    {
    tmp = sizeof(unsigned long ) * 8UL - 2UL;
    }
  }
  return ((int )((page->flags >> tmp) & ((1UL << 2) - 1UL)));
}
}
__inline static struct zone *page_zone(struct page *page ) 
{ enum zone_type tmp ;

  {
  {
  tmp = page_zonenum(page);
  }
  return (& contig_page_data.node_zones[tmp]);
}
}
__inline static void set_page_zone(struct page *page , enum zone_type zone ) 
{ 

  {
  {
  page->flags &= ~ (((1UL << 2) - 1UL) << (sizeof(unsigned long ) * 8UL - 2UL));
  page->flags |= ((unsigned long )zone & ((1UL << 2) - 1UL)) << (sizeof(unsigned long ) * 8UL - 2UL);
  }
  return;
}
}
__inline static void set_page_node(struct page *page , unsigned long node ) 
{ 

  {
  {
  page->flags &= 0xffffffffUL;
  page->flags = page->flags;
  }
  return;
}
}
__inline static void set_page_links(struct page *page , enum zone_type zone , unsigned long node ,
                                    unsigned long pfn ) 
{ 

  {
  {
  set_page_zone(page, zone);
  set_page_node(page, node);
  set_page_node(page, pfn);
  }
  return;
}
}
__inline static unsigned long round_hint_to_min(unsigned long hint ) 
{ 

  {
  {
  hint &= ~ ((1UL << 12) - 1UL);
  }
  if ((unsigned long )((void *)hint) != (unsigned long )((void *)0)) {
    if (hint < mmap_min_addr) {
      return ((mmap_min_addr + ((1UL << 12) - 1UL)) & ~ ((1UL << 12) - 1UL));
    }
  }
  return (hint);
}
}
extern int sysctl_stat_interval ;
extern struct vm_event_state per_cpu__vm_event_states  __attribute__((__section__(".data.percpu"))) ;
__inline static void __count_vm_event(enum vm_event_item item ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_102_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_102_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_102_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_102_8;
        } else {
          {
          goto switch_102_default;
          if (0) {
            switch_102_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_102_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  (((struct vm_event_state *)(__ptr + ret__))->event[item]) ++;
  }
  return;
}
}
extern int simple_identifier_vm_event_states(void) ;
__inline static void count_vm_event(enum vm_event_item item ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  while (1) {
    while_103_continue: /* CIL Label */ ;
    goto while_103_break;
  }
  while_103_break: /* CIL Label */ ;
  }
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_104_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_104_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_104_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_104_8;
        } else {
          {
          goto switch_104_default;
          if (0) {
            switch_104_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_104_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  (((struct vm_event_state *)(__ptr + ret__))->event[item]) ++;
  }
  {
  while (1) {
    while_105_continue: /* CIL Label */ ;
    goto while_105_break;
  }
  while_105_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void __count_vm_events(enum vm_event_item item , long delta ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_106_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_106_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_106_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_106_8;
        } else {
          {
          goto switch_106_default;
          if (0) {
            switch_106_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_106_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ((struct vm_event_state *)(__ptr + ret__))->event[item] += (unsigned long )delta;
  }
  return;
}
}
__inline static void count_vm_events(enum vm_event_item item , long delta ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  while (1) {
    while_107_continue: /* CIL Label */ ;
    goto while_107_break;
  }
  while_107_break: /* CIL Label */ ;
  }
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_108_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_108_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_108_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_108_8;
        } else {
          {
          goto switch_108_default;
          if (0) {
            switch_108_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_108_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ((struct vm_event_state *)(__ptr + ret__))->event[item] += (unsigned long )delta;
  }
  {
  while (1) {
    while_109_continue: /* CIL Label */ ;
    goto while_109_break;
  }
  while_109_break: /* CIL Label */ ;
  }
  return;
}
}
extern void all_vm_events(unsigned long * ) ;
extern void vm_events_fold_cpu(int cpu ) ;
extern atomic_long_t vm_stat[19] ;
__inline static void zone_page_state_add(long x , struct zone *zone , enum zone_stat_item item ) 
{ 

  {
  {
  atomic_long_add(x, & zone->vm_stat[item]);
  atomic_long_add(x, & vm_stat[item]);
  }
  return;
}
}
__inline static unsigned long global_page_state(enum zone_stat_item item ) 
{ long x ;
  long tmp ;

  {
  {
  tmp = atomic_long_read(& vm_stat[item]);
  x = tmp;
  }
  if (x < 0L) {
    {
    x = 0L;
    }
  }
  return ((unsigned long )x);
}
}
__inline static unsigned long zone_page_state(struct zone *zone , enum zone_stat_item item ) 
{ long x ;
  long tmp ;

  {
  {
  tmp = atomic_long_read(& zone->vm_stat[item]);
  x = tmp;
  }
  if (x < 0L) {
    {
    x = 0L;
    }
  }
  return ((unsigned long )x);
}
}
extern unsigned long global_lru_pages(void) ;
__inline static unsigned long zone_lru_pages(struct zone *zone ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
  tmp = zone_page_state(zone, (enum zone_stat_item )2);
  tmp___0 = zone_page_state(zone, (enum zone_stat_item )4);
  tmp___1 = zone_page_state(zone, (enum zone_stat_item )1);
  tmp___2 = zone_page_state(zone, (enum zone_stat_item )3);
  }
  return (((tmp + tmp___0) + tmp___1) + tmp___2);
}
}
__inline static void zap_zone_vm_stats(struct zone *zone ) 
{ 

  {
  {
  __constant_c_and_count_memset((void *)(zone->vm_stat), 0UL, (unsigned int )sizeof(zone->vm_stat));
  }
  return;
}
}
extern void inc_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void __mod_zone_page_state(struct zone * , enum zone_stat_item item , int  ) ;
extern void __inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void __dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void mod_zone_page_state(struct zone * , enum zone_stat_item  , int  ) ;
extern void inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void __inc_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void dec_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void __dec_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void refresh_cpu_vm_stats(int  ) ;
__inline static void *lowmem_page_address(struct page *page ) 
{ 

  {
  return ((void *)(((unsigned long )(page - mem_map) << 12) + 3221225472UL));
}
}
extern void *page_address(struct page *page ) ;
extern void set_page_address(struct page *page , void *virtual ) ;
extern void page_address_init(void) ;
extern struct address_space swapper_space ;
__inline static struct address_space *page_mapping(struct page *page ) 
{ struct address_space *mapping ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  mapping = page->__annonCompField19.__annonCompField18.mapping;
  }
  {
  while (1) {
    while_110_continue: /* CIL Label */ ;
    goto while_110_break;
  }
  while_110_break: /* CIL Label */ ;
  }
  {
  tmp___0 = PageSwapCache(page);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    mapping = & swapper_space;
    }
  } else {
    {
    tmp = __builtin_expect((long )(! (! ((unsigned long )mapping & 1UL))), 0L);
    }
    if (tmp) {
      {
      mapping = (struct address_space *)((void *)0);
      }
    }
  }
  return (mapping);
}
}
__inline static int PageAnon(struct page *page ) 
{ 

  {
  return (((unsigned long )page->__annonCompField19.__annonCompField18.mapping & 1UL) != 0UL);
}
}
__inline static unsigned long page_index(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = PageSwapCache(page);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return (page->__annonCompField19.__annonCompField18.private);
  }
  return (page->__annonCompField20.index);
}
}
__inline static void reset_page_mapcount(struct page *page ) 
{ 

  {
  {
  page->__annonCompField17._mapcount.counter = (int volatile   )-1;
  }
  return;
}
}
__inline static int page_mapcount(struct page *page ) 
{ 

  {
  return ((int )(page->__annonCompField17._mapcount.counter + (int volatile   )1));
}
}
__inline static int page_mapped(struct page *page ) 
{ 

  {
  return (page->__annonCompField17._mapcount.counter >= (int volatile   )0);
}
}
extern void pagefault_out_of_memory(void) ;
extern void show_free_areas(void) ;
extern int shmem_lock(struct file *file , int lock , struct user_struct *user ) ;
extern struct file *shmem_file_setup(char *name , loff_t size , unsigned long flags ) ;
extern int shmem_zero_setup(struct vm_area_struct * ) ;
extern int can_do_mlock(void) ;
extern int user_shm_lock(size_t  , struct user_struct * ) ;
extern void user_shm_unlock(size_t  , struct user_struct * ) ;
extern struct page *vm_normal_page(struct vm_area_struct *vma , unsigned long addr ,
                                   pte_t pte ) ;
extern int zap_vma_ptes(struct vm_area_struct *vma , unsigned long address , unsigned long size ) ;
extern unsigned long zap_page_range(struct vm_area_struct *vma , unsigned long address ,
                                    unsigned long size , struct zap_details * ) ;
extern unsigned long unmap_vmas(struct mmu_gather **tlb , struct vm_area_struct *start_vma ,
                                unsigned long start_addr , unsigned long end_addr ,
                                unsigned long *nr_accounted , struct zap_details * ) ;
extern int walk_page_range(unsigned long addr , unsigned long end , struct mm_walk *walk ) ;
extern void free_pgd_range(struct mmu_gather *tlb , unsigned long addr , unsigned long end ,
                           unsigned long floor , unsigned long ceiling ) ;
extern int copy_page_range(struct mm_struct *dst , struct mm_struct *src , struct vm_area_struct *vma ) ;
extern void unmap_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                loff_t holelen , int even_cows ) ;
extern int follow_phys(struct vm_area_struct *vma , unsigned long address , unsigned int flags ,
                       unsigned long *prot , resource_size_t *phys ) ;
extern int generic_access_phys(struct vm_area_struct *vma , unsigned long addr , void *buf ,
                               int len , int write ) ;
__inline static void unmap_shared_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                                loff_t holelen ) 
{ 

  {
  {
  unmap_mapping_range(mapping, holebegin, holelen, 0);
  }
  return;
}
}
extern int vmtruncate(struct inode *inode , loff_t offset ) ;
extern int vmtruncate_range(struct inode *inode , loff_t offset , loff_t end ) ;
extern int handle_mm_fault(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long address ,
                           int write_access ) ;
extern int make_pages_present(unsigned long addr , unsigned long end ) ;
extern int access_process_vm(struct task_struct *tsk , unsigned long addr , void *buf ,
                             int len , int write ) ;
extern int get_user_pages(struct task_struct *tsk , struct mm_struct *mm , unsigned long start ,
                          int len , int write , int force , struct page **pages ,
                          struct vm_area_struct **vmas ) ;
extern int try_to_release_page(struct page *page , gfp_t gfp_mask ) ;
extern void do_invalidatepage(struct page *page , unsigned long offset ) ;
extern int __set_page_dirty_nobuffers(struct page *page ) ;
extern int __set_page_dirty_no_writeback(struct page *page ) ;
extern int redirty_page_for_writepage(struct writeback_control *wbc , struct page *page ) ;
extern void account_page_dirtied(struct page *page , struct address_space *mapping ) ;
extern int set_page_dirty(struct page *page ) ;
extern int set_page_dirty_lock(struct page *page ) ;
extern int clear_page_dirty_for_io(struct page *page ) ;
extern unsigned long move_page_tables(struct vm_area_struct *vma , unsigned long old_addr ,
                                      struct vm_area_struct *new_vma , unsigned long new_addr ,
                                      unsigned long len ) ;
extern unsigned long do_mremap(unsigned long addr , unsigned long old_len , unsigned long new_len ,
                               unsigned long flags , unsigned long new_addr ) ;
extern int mprotect_fixup(struct vm_area_struct *vma , struct vm_area_struct **pprev ,
                          unsigned long start , unsigned long end , unsigned long newflags ) ;
extern int get_user_pages_fast(unsigned long start , int nr_pages , int write , struct page **pages ) ;
extern void register_shrinker(struct shrinker * ) ;
extern void unregister_shrinker(struct shrinker * ) ;
extern int vma_wants_writenotify(struct vm_area_struct *vma ) ;
extern pte_t *get_locked_pte(struct mm_struct *mm , unsigned long addr , spinlock_t **ptl ) ;
__inline static int __pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) 
{ 

  {
  return (0);
}
}
__inline static int __pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) 
{ 

  {
  return (0);
}
}
extern int __pte_alloc(struct mm_struct *mm , pmd_t *pmd , unsigned long address ) ;
extern int __pte_alloc_kernel(pmd_t *pmd , unsigned long address ) ;
__inline static pud_t *pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  pud_t *tmp___3 ;
  pud_t *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
  {
  tmp___5 = pgd_none(*pgd);
  }
  if (tmp___5) {
    {
    tmp___6 = 1;
    }
  } else {
    {
    tmp___6 = 0;
    }
  }
  {
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
  if (tmp___7) {
    {
    tmp___8 = __pud_alloc(mm, pgd, address);
    }
    if (tmp___8) {
      {
      tmp___4 = (pud_t *)((void *)0);
      }
    } else {
      {
      tmp___3 = pud_offset(pgd, address);
      tmp___4 = tmp___3;
      }
    }
  } else {
    {
    tmp___3 = pud_offset(pgd, address);
    tmp___4 = tmp___3;
    }
  }
  return (tmp___4);
}
}
__inline static pmd_t *pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  pmd_t *tmp___3 ;
  pmd_t *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
  {
  tmp___5 = pud_none(*pud);
  }
  if (tmp___5) {
    {
    tmp___6 = 1;
    }
  } else {
    {
    tmp___6 = 0;
    }
  }
  {
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
  if (tmp___7) {
    {
    tmp___8 = __pmd_alloc(mm, pud, address);
    }
    if (tmp___8) {
      {
      tmp___4 = (pmd_t *)((void *)0);
      }
    } else {
      {
      tmp___3 = pmd_offset(pud, address);
      tmp___4 = tmp___3;
      }
    }
  } else {
    {
    tmp___3 = pmd_offset(pud, address);
    tmp___4 = tmp___3;
    }
  }
  return (tmp___4);
}
}
__inline static void pgtable_page_ctor(struct page *page ) 
{ spinlock_t __constr_expr_0 ;

  {
  {
  while (1) {
    while_111_continue: /* CIL Label */ ;
    {
    while (1) {
      while_112_continue: /* CIL Label */ ;
      {
      __constr_expr_0.raw_lock.slock = 0U;
      page->__annonCompField19.ptl = __constr_expr_0;
      }
      goto while_112_break;
    }
    while_112_break: /* CIL Label */ ;
    }
    goto while_111_break;
  }
  while_111_break: /* CIL Label */ ;
  }
  {
  inc_zone_page_state(page, (enum zone_stat_item )14);
  }
  return;
}
}
__inline static void pgtable_page_dtor(struct page *page ) 
{ 

  {
  {
  page->__annonCompField19.__annonCompField18.mapping = (struct address_space *)((void *)0);
  dec_zone_page_state(page, (enum zone_stat_item )14);
  }
  return;
}
}
extern void free_area_init(unsigned long *zones_size ) ;
extern void free_area_init_node(int nid , unsigned long *zones_size , unsigned long zone_start_pfn ,
                                unsigned long *zholes_size ) ;
extern void free_area_init_nodes(unsigned long *max_zone_pfn ) ;
extern void add_active_range(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
extern void remove_active_range(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
extern void push_node_boundaries(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
extern void remove_all_active_ranges(void) ;
extern unsigned long absent_pages_in_range(unsigned long start_pfn , unsigned long end_pfn ) ;
extern void get_pfn_range_for_nid(unsigned int nid , unsigned long *start_pfn , unsigned long *end_pfn ) ;
extern unsigned long find_min_pfn_with_active_regions(void) ;
extern void free_bootmem_with_active_regions(int nid , unsigned long max_low_pfn ) ;
extern void work_with_active_regions(int nid , int (*work_fn)(unsigned long  , unsigned long  ,
                                                              void * ) , void *data ) ;
extern void sparse_memory_present_with_active_regions(int nid ) ;
extern int early_pfn_to_nid(unsigned long pfn )  __attribute__((__section__(".meminit.text"))) ;
extern void set_dma_reserve(unsigned long new_dma_reserve ) ;
extern void memmap_init_zone(unsigned long  , int  , unsigned long  , unsigned long  ,
                             enum memmap_context  ) ;
extern void setup_per_zone_pages_min(void) ;
extern void mem_init(void) ;
extern void mmap_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void show_mem(void) ;
extern void si_meminfo(struct sysinfo *val ) ;
extern void si_meminfo_node(struct sysinfo *val , int nid ) ;
extern int after_bootmem ;
extern atomic_long_t mmap_pages_allocated ;
extern void vma_prio_tree_add(struct vm_area_struct * , struct vm_area_struct *old ) ;
extern void vma_prio_tree_insert(struct vm_area_struct * , struct prio_tree_root * ) ;
extern void vma_prio_tree_remove(struct vm_area_struct * , struct prio_tree_root * ) ;
extern struct vm_area_struct *vma_prio_tree_next(struct vm_area_struct *vma , struct prio_tree_iter *iter ) ;
__inline static void vma_nonlinear_insert(struct vm_area_struct *vma , struct list_head *list ) 
{ 

  {
  {
  vma->shared.vm_set.parent = (void *)0;
  list_add_tail(& vma->shared.vm_set.list, list);
  }
  return;
}
}
extern int __vm_enough_memory(struct mm_struct *mm , long pages , int cap_sys_admin ) ;
extern void vma_adjust(struct vm_area_struct *vma , unsigned long start , unsigned long end ,
                       unsigned long pgoff , struct vm_area_struct *insert ) ;
extern struct vm_area_struct *vma_merge(struct mm_struct * , struct vm_area_struct *prev ,
                                        unsigned long addr , unsigned long end , unsigned long vm_flags ,
                                        struct anon_vma * , struct file * , unsigned long  ,
                                        struct mempolicy * ) ;
extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct * ) ;
extern int split_vma(struct mm_struct * , struct vm_area_struct * , unsigned long addr ,
                     int new_below ) ;
extern int insert_vm_struct(struct mm_struct * , struct vm_area_struct * ) ;
extern void __vma_link_rb(struct mm_struct * , struct vm_area_struct * , struct rb_node ** ,
                          struct rb_node * ) ;
extern void unlink_file_vma(struct vm_area_struct * ) ;
extern struct vm_area_struct *copy_vma(struct vm_area_struct ** , unsigned long addr ,
                                       unsigned long len , unsigned long pgoff ) ;
extern void exit_mmap(struct mm_struct * ) ;
extern int mm_take_all_locks(struct mm_struct *mm ) ;
extern void mm_drop_all_locks(struct mm_struct *mm ) ;
extern void added_exe_file_vma(struct mm_struct *mm ) ;
extern void removed_exe_file_vma(struct mm_struct *mm ) ;
extern int may_expand_vm(struct mm_struct *mm , unsigned long npages ) ;
extern int install_special_mapping(struct mm_struct *mm , unsigned long addr , unsigned long len ,
                                   unsigned long flags , struct page **pages ) ;
extern unsigned long get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                       unsigned long  , unsigned long  ) ;
extern unsigned long do_mmap_pgoff(struct file *file , unsigned long addr , unsigned long len ,
                                   unsigned long prot , unsigned long flag , unsigned long pgoff ) ;
extern unsigned long mmap_region(struct file *file , unsigned long addr , unsigned long len ,
                                 unsigned long flags , unsigned int vm_flags , unsigned long pgoff ) ;
__inline static unsigned long do_mmap(struct file *file , unsigned long addr , unsigned long len ,
                                      unsigned long prot , unsigned long flag , unsigned long offset ) 
{ unsigned long ret ;

  {
  {
  ret = 0xffffffeaUL;
  }
  if (offset + ((len + ((1UL << 12) - 1UL)) & ~ ((1UL << 12) - 1UL)) < offset) {
    goto out;
  }
  if (! (offset & ~ (~ ((1UL << 12) - 1UL)))) {
    {
    ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 12);
    }
  }
  out: 
  return (ret);
}
}
extern int do_munmap(struct mm_struct * , unsigned long  , size_t  ) ;
extern unsigned long do_brk(unsigned long  , unsigned long  ) ;
extern unsigned long page_unuse(struct page * ) ;
extern void truncate_inode_pages(struct address_space * , loff_t  ) ;
extern void truncate_inode_pages_range(struct address_space * , loff_t lstart , loff_t lend ) ;
extern int filemap_fault(struct vm_area_struct * , struct vm_fault * ) ;
extern int write_one_page(struct page *page , int wait ) ;
extern void task_dirty_inc(struct task_struct *tsk ) ;
extern int do_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                   unsigned long offset , unsigned long nr_to_read ) ;
extern int force_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                      unsigned long offset , unsigned long nr_to_read ) ;
extern void page_cache_sync_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                      struct file *filp , unsigned long offset , unsigned long size ) ;
extern void page_cache_async_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                       struct file *filp , struct page *pg , unsigned long offset ,
                                       unsigned long size ) ;
extern unsigned long max_sane_readahead(unsigned long nr ) ;
extern int expand_stack(struct vm_area_struct *vma , unsigned long address ) ;
extern int expand_stack_downwards(struct vm_area_struct *vma , unsigned long address ) ;
extern struct vm_area_struct *find_vma(struct mm_struct *mm , unsigned long addr ) ;
extern struct vm_area_struct *find_vma_prev(struct mm_struct *mm , unsigned long addr ,
                                            struct vm_area_struct **pprev ) ;
__inline static struct vm_area_struct *find_vma_intersection(struct mm_struct *mm ,
                                                             unsigned long start_addr ,
                                                             unsigned long end_addr ) 
{ struct vm_area_struct *vma ;
  struct vm_area_struct *tmp ;

  {
  {
  tmp = find_vma(mm, start_addr);
  vma = tmp;
  }
  if (vma) {
    if (end_addr <= vma->vm_start) {
      {
      vma = (struct vm_area_struct *)((void *)0);
      }
    }
  }
  return (vma);
}
}
__inline static unsigned long vma_pages(struct vm_area_struct *vma ) 
{ 

  {
  return ((vma->vm_end - vma->vm_start) >> 12);
}
}
extern pgprot_t vm_get_page_prot(unsigned long vm_flags ) ;
extern struct vm_area_struct *find_extend_vma(struct mm_struct * , unsigned long addr ) ;
extern int remap_pfn_range(struct vm_area_struct * , unsigned long addr , unsigned long pfn ,
                           unsigned long size , pgprot_t  ) ;
extern int vm_insert_page(struct vm_area_struct * , unsigned long addr , struct page * ) ;
extern int vm_insert_pfn(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
extern int vm_insert_mixed(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
extern struct page *follow_page(struct vm_area_struct * , unsigned long address ,
                                unsigned int foll_flags ) ;
extern int apply_to_page_range(struct mm_struct *mm , unsigned long address , unsigned long size ,
                               int (*fn)(pte_t *pte , pgtable_t token , unsigned long addr ,
                                         void *data ) , void *data ) ;
extern void vm_stat_account(struct mm_struct * , unsigned long  , struct file * ,
                            long  ) ;
__inline static void kernel_map_pages(struct page *page , int numpages , int enable ) 
{ 

  {
  return;
}
}
__inline static bool kernel_page_present(struct page *page ) 
{ 

  {
  return ((_Bool)1);
}
}
extern struct vm_area_struct *get_gate_vma(struct task_struct *tsk ) ;
extern int in_gate_area_no_task(unsigned long addr ) ;
extern int in_gate_area(struct task_struct *task , unsigned long addr ) ;
extern int drop_caches_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                      void * , size_t * , loff_t * ) ;
extern unsigned long shrink_slab(unsigned long scanned , gfp_t gfp_mask , unsigned long lru_pages ) ;
extern int randomize_va_space ;
extern char const   *arch_vma_name(struct vm_area_struct *vma ) ;
extern void print_vma_addr(char *prefix , unsigned long rip ) ;
extern struct page *sparse_mem_map_populate(unsigned long pnum , int nid ) ;
extern pgd_t *vmemmap_pgd_populate(unsigned long addr , int node ) ;
extern pud_t *vmemmap_pud_populate(pgd_t *pgd , unsigned long addr , int node ) ;
extern pmd_t *vmemmap_pmd_populate(pud_t *pud , unsigned long addr , int node ) ;
extern pte_t *vmemmap_pte_populate(pmd_t *pmd , unsigned long addr , int node ) ;
extern void *vmemmap_alloc_block(unsigned long size , int node ) ;
extern void vmemmap_verify(pte_t * , int  , unsigned long  , unsigned long  ) ;
extern int vmemmap_populate_basepages(struct page *start_page , unsigned long pages ,
                                      int node ) ;
extern int vmemmap_populate(struct page *start_page , unsigned long pages , int node ) ;
extern void vmemmap_populate_print_last(void) ;
extern void *alloc_locked_buffer(size_t size ) ;
extern void free_locked_buffer(void *buffer , size_t size ) ;
extern void release_locked_buffer(void *buffer , size_t size ) ;
__inline static unsigned char readb(void const volatile   *addr ) 
{ unsigned char ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
  }
  return (ret);
}
}
__inline static unsigned short readw(void const volatile   *addr ) 
{ unsigned short ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
  }
  return (ret);
}
}
__inline static unsigned int readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
  }
  return (ret);
}
}
__inline static unsigned char __readb(void const volatile   *addr ) 
{ unsigned char ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)));
  }
  return (ret);
}
}
__inline static unsigned short __readw(void const volatile   *addr ) 
{ unsigned short ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)));
  }
  return (ret);
}
}
__inline static unsigned int __readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
  }
  return (ret);
}
}
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
  }
  return;
}
}
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
  }
  return;
}
}
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
  }
  return;
}
}
__inline static void __writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)));
  }
  return;
}
}
__inline static void __writew(unsigned short val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)));
  }
  return;
}
}
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
  }
  return;
}
}
__inline static __u64 readq(void const volatile   *addr ) 
{ u32 const volatile   *p ;
  u32 low ;
  u32 high ;

  {
  {
  p = (u32 const volatile   *)addr;
  low = readl((void const volatile   *)p);
  high = readl((void const volatile   *)(p + 1));
  }
  return ((unsigned long long )low + ((unsigned long long )high << 32));
}
}
__inline static void writeq(__u64 val , void volatile   *addr ) 
{ 

  {
  {
  writel((unsigned int )val, addr);
  writel((unsigned int )(val >> 32), addr + 4);
  }
  return;
}
}
__inline static phys_addr_t virt_to_phys(void volatile   *address ) 
{ 

  {
  return ((unsigned int )((unsigned long )address - 3221225472UL));
}
}
__inline static void *phys_to_virt(phys_addr_t address ) 
{ 

  {
  return ((void *)((unsigned long )address + 3221225472UL));
}
}
__inline static unsigned int isa_virt_to_bus(void volatile   *address ) 
{ phys_addr_t tmp ;

  {
  {
  tmp = virt_to_phys(address);
  }
  return (tmp);
}
}
extern void *ioremap_nocache(resource_size_t offset , unsigned long size ) ;
extern void *ioremap_cache(resource_size_t offset , unsigned long size ) ;
extern void *ioremap_prot(resource_size_t offset , unsigned long size , unsigned long prot_val ) ;
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ void *tmp ;

  {
  {
  tmp = ioremap_nocache(offset, size);
  }
  return (tmp);
}
}
extern void iounmap(void volatile   *addr ) ;
extern unsigned int ioread8(void * ) ;
extern unsigned int ioread16(void * ) ;
extern unsigned int ioread16be(void * ) ;
extern unsigned int ioread32(void * ) ;
extern unsigned int ioread32be(void * ) ;
extern void iowrite8(u8  , void * ) ;
extern void iowrite16(u16  , void * ) ;
extern void iowrite16be(u16  , void * ) ;
extern void iowrite32(u32  , void * ) ;
extern void iowrite32be(u32  , void * ) ;
extern void ioread8_rep(void *port , void *buf , unsigned long count ) ;
extern void ioread16_rep(void *port , void *buf , unsigned long count ) ;
extern void ioread32_rep(void *port , void *buf , unsigned long count ) ;
extern void iowrite8_rep(void *port , void const   *buf , unsigned long count ) ;
extern void iowrite16_rep(void *port , void const   *buf , unsigned long count ) ;
extern void iowrite32_rep(void *port , void const   *buf , unsigned long count ) ;
extern void *ioport_map(unsigned long port , unsigned int nr ) ;
extern void ioport_unmap(void * ) ;
extern void *pci_iomap(struct pci_dev *dev , int bar , unsigned long max ) ;
extern void pci_iounmap(struct pci_dev *dev , void * ) ;
extern void vm_unmap_ram(void const   *mem , unsigned int count ) ;
extern void *vm_map_ram(struct page **pages , unsigned int count , int node , pgprot_t prot ) ;
extern void vm_unmap_aliases(void) ;
extern void vmalloc_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void *vmalloc(unsigned long size ) ;
extern void *vmalloc_user(unsigned long size ) ;
extern void *vmalloc_node(unsigned long size , int node ) ;
extern void *vmalloc_exec(unsigned long size ) ;
extern void *vmalloc_32(unsigned long size ) ;
extern void *vmalloc_32_user(unsigned long size ) ;
extern void *__vmalloc(unsigned long size , gfp_t gfp_mask , pgprot_t prot ) ;
extern void *__vmalloc_area(struct vm_struct *area , gfp_t gfp_mask , pgprot_t prot ) ;
extern void vfree(void const   *addr ) ;
extern void *vmap(struct page **pages , unsigned int count , unsigned long flags ,
                  pgprot_t prot ) ;
extern void vunmap(void const   *addr ) ;
extern int remap_vmalloc_range(struct vm_area_struct *vma , void *addr , unsigned long pgoff ) ;
extern void vmalloc_sync_all(void) ;
__inline static size_t get_vm_area_size(struct vm_struct  const  *area ) 
{ 

  {
  return ((unsigned int )(area->size - (unsigned long const   )(1UL << 12)));
}
}
extern struct vm_struct *get_vm_area(unsigned long size , unsigned long flags ) ;
extern struct vm_struct *get_vm_area_caller(unsigned long size , unsigned long flags ,
                                            void *caller ) ;
extern struct vm_struct *__get_vm_area(unsigned long size , unsigned long flags ,
                                       unsigned long start , unsigned long end ) ;
extern struct vm_struct *__get_vm_area_caller(unsigned long size , unsigned long flags ,
                                              unsigned long start , unsigned long end ,
                                              void *caller ) ;
extern struct vm_struct *get_vm_area_node(unsigned long size , unsigned long flags ,
                                          int node , gfp_t gfp_mask ) ;
extern struct vm_struct *remove_vm_area(void const   *addr ) ;
extern int map_vm_area(struct vm_struct *area , pgprot_t prot , struct page ***pages ) ;
extern int map_kernel_range_noflush(unsigned long start , unsigned long size , pgprot_t prot ,
                                    struct page **pages ) ;
extern void unmap_kernel_range_noflush(unsigned long addr , unsigned long size ) ;
extern void unmap_kernel_range(unsigned long addr , unsigned long size ) ;
extern struct vm_struct *alloc_vm_area(size_t size ) ;
extern void free_vm_area(struct vm_struct *area ) ;
extern long vread(char *buf , char *addr , unsigned long count ) ;
extern long vwrite(char *buf , char *addr , unsigned long count ) ;
extern rwlock_t vmlist_lock ;
extern struct vm_struct *vmlist ;
extern void vm_area_register_early(struct vm_struct *vm , size_t align )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static void memset_io(void volatile   *addr , unsigned char val , int count ) 
{ 

  {
  {
  __memset_generic((void *)addr, (char )val, (unsigned int )count);
  }
  return;
}
}
__inline static void memcpy_fromio(void *dst , void const volatile   *src , int count ) 
{ 

  {
  {
  __memcpy(dst, (void const   *)src, (unsigned int )count);
  }
  return;
}
}
__inline static void memcpy_toio(void volatile   *dst , void const   *src , int count ) 
{ 

  {
  {
  __memcpy((void *)dst, src, (unsigned int )count);
  }
  return;
}
}
extern void native_io_delay(void) ;
extern int io_delay_type ;
extern void io_delay_init(void) ;
__inline static void slow_down_io(void) 
{ 

  {
  {
  native_io_delay();
  }
  return;
}
}
__inline static void outb_local(unsigned char value , int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned char inb_local(int port ) 
{ unsigned char value ;

  {
  {
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void outb_local_p(unsigned char value , int port ) 
{ 

  {
  {
  outb_local(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned char inb_local_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  {
  tmp = inb_local(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outb(unsigned char value , int port ) 
{ 

  {
  {
  outb_local(value, port);
  }
  return;
}
}
__inline static unsigned char inb(int port ) 
{ unsigned char tmp ;

  {
  {
  tmp = inb_local(port);
  }
  return (tmp);
}
}
__inline static void outb_p(unsigned char value , int port ) 
{ 

  {
  {
  outb(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned char inb_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  {
  tmp = inb(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outsb(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "b": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void insb(int port , void *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "b": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void outw_local(unsigned short value , int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned short inw_local(int port ) 
{ unsigned short value ;

  {
  {
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void outw_local_p(unsigned short value , int port ) 
{ 

  {
  {
  outw_local(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned short inw_local_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  {
  tmp = inw_local(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outw(unsigned short value , int port ) 
{ 

  {
  {
  outw_local(value, port);
  }
  return;
}
}
__inline static unsigned short inw(int port ) 
{ unsigned short tmp ;

  {
  {
  tmp = inw_local(port);
  }
  return (tmp);
}
}
__inline static void outw_p(unsigned short value , int port ) 
{ 

  {
  {
  outw(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned short inw_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  {
  tmp = inw(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outsw(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "w": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void insw(int port , void *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "w": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void outl_local(unsigned int value , int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned int inl_local(int port ) 
{ unsigned int value ;

  {
  {
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void outl_local_p(unsigned int value , int port ) 
{ 

  {
  {
  outl_local(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned int inl_local_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  {
  tmp = inl_local(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outl(unsigned int value , int port ) 
{ 

  {
  {
  outl_local(value, port);
  }
  return;
}
}
__inline static unsigned int inl(int port ) 
{ unsigned int tmp ;

  {
  {
  tmp = inl_local(port);
  }
  return (tmp);
}
}
__inline static void outl_p(unsigned int value , int port ) 
{ 

  {
  {
  outl(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned int inl_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  {
  tmp = inl(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outsl(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "l": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void insl(int port , void *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "l": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
extern void *xlate_dev_mem_ptr(unsigned long phys ) ;
extern void unxlate_dev_mem_ptr(unsigned long phys , void *addr ) ;
extern int ioremap_change_attr(unsigned long vaddr , unsigned long size , unsigned long prot_val ) ;
extern void *ioremap_wc(resource_size_t offset , unsigned long size ) ;
extern void early_ioremap_init(void) ;
extern void early_ioremap_reset(void) ;
extern void *early_ioremap(resource_size_t phys_addr , unsigned long size ) ;
extern void *early_memremap(resource_size_t phys_addr , unsigned long size ) ;
extern void early_iounmap(void *addr , unsigned long size ) ;
__inline static int is_warning_bug(struct bug_entry  const  *bug ) 
{ 

  {
  return ((int )((int const   )bug->flags & 1));
}
}
extern struct bug_entry  const  *find_bug(unsigned long bugaddr ) ;
extern enum bug_trap_type report_bug(unsigned long bug_addr , struct pt_regs *regs ) ;
extern int module_bug_finalize(Elf32_Ehdr const   * , Elf32_Shdr const   * , struct module * ) ;
extern void module_bug_cleanup(struct module * ) ;
extern int is_valid_bugaddr(unsigned long addr ) ;
__inline static void init_dma_attrs(struct dma_attrs *attrs ) 
{ 

  {
  {
  bitmap_zero(attrs->flags, (int )(((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))));
  }
  return;
}
}
__inline static void dma_set_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 

  {
  return;
}
}
__inline static int dma_get_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 

  {
  return (0);
}
}
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ unsigned long page_link ;
  long tmp ;

  {
  {
  page_link = sg->page_link & 3UL;
  }
  {
  while (1) {
    while_113_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! ((unsigned long )page & 3UL))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_114_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"),
                             "i" (63), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_115_continue: /* CIL Label */ ;
        }
        while_115_break: /* CIL Label */ ;
        }
        goto while_114_break;
      }
      while_114_break: /* CIL Label */ ;
      }
    }
    goto while_113_break;
  }
  while_113_break: /* CIL Label */ ;
  }
  {
  sg->page_link = page_link | (unsigned long )page;
  }
  return;
}
}
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 

  {
  {
  sg_assign_page(sg, page);
  sg->offset = offset;
  sg->length = len;
  }
  return;
}
}
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 

  {
  return ((struct page *)(sg->page_link & 0xfffffffcUL));
}
}
__inline static void sg_set_buf(struct scatterlist *sg , void const   *buf , unsigned int buflen ) 
{ 

  {
  {
  sg_set_page(sg, mem_map + (((unsigned long )buf - 3221225472UL) >> 12), buflen,
              (unsigned int )((unsigned long )buf & ~ (~ ((1UL << 12) - 1UL))));
  }
  return;
}
}
__inline static void sg_chain(struct scatterlist *prv , unsigned int prv_nents , struct scatterlist *sgl ) 
{ 

  {
  {
  (prv + (prv_nents - 1U))->offset = 0U;
  (prv + (prv_nents - 1U))->length = 0U;
  (prv + (prv_nents - 1U))->page_link = ((unsigned long )sgl | 1UL) & 0xfffffffdUL;
  }
  return;
}
}
__inline static void sg_mark_end(struct scatterlist *sg ) 
{ 

  {
  {
  sg->page_link |= 2UL;
  sg->page_link &= 0xfffffffeUL;
  }
  return;
}
}
__inline static dma_addr_t sg_phys(struct scatterlist *sg ) 
{ struct page *tmp ;

  {
  {
  tmp = sg_page(sg);
  }
  return (((unsigned int )((unsigned long )(tmp - mem_map)) << 12) + sg->offset);
}
}
__inline static void *sg_virt(struct scatterlist *sg ) 
{ struct page *tmp ;
  void *tmp___0 ;

  {
  {
  tmp = sg_page(sg);
  tmp___0 = page_address(tmp);
  }
  return (tmp___0 + sg->offset);
}
}
extern struct scatterlist *sg_next(struct scatterlist * ) ;
extern struct scatterlist *sg_last(struct scatterlist *s , unsigned int  ) ;
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
extern void sg_init_one(struct scatterlist * , void const   * , unsigned int  ) ;
extern void __sg_free_table(struct sg_table * , unsigned int  , sg_free_fn * ) ;
extern void sg_free_table(struct sg_table * ) ;
extern int __sg_alloc_table(struct sg_table * , unsigned int  , unsigned int  , gfp_t  ,
                            sg_alloc_fn * ) ;
extern int sg_alloc_table(struct sg_table * , unsigned int  , gfp_t  ) ;
extern size_t sg_copy_from_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                  size_t buflen ) ;
extern size_t sg_copy_to_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                size_t buflen ) ;
extern void sg_miter_start(struct sg_mapping_iter *miter , struct scatterlist *sgl ,
                           unsigned int nents , unsigned int flags ) ;
extern bool sg_miter_next(struct sg_mapping_iter *miter ) ;
extern void sg_miter_stop(struct sg_mapping_iter *miter ) ;
__inline static int valid_dma_direction(int dma_direction ) 
{ int tmp ;

  {
  if (dma_direction == 0) {
    {
    tmp = 1;
    }
  } else {
    if (dma_direction == 1) {
      {
      tmp = 1;
      }
    } else {
      if (dma_direction == 2) {
        {
        tmp = 1;
        }
      } else {
        {
        tmp = 0;
        }
      }
    }
  }
  return (tmp);
}
}
__inline static int is_device_dma_capable(struct device *dev ) 
{ int tmp ;

  {
  if ((unsigned long )dev->dma_mask != (unsigned long )((void *)0)) {
    if (*(dev->dma_mask) != 0ULL) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int is_buffer_dma_capable(u64 mask , dma_addr_t addr , size_t size ) 
{ 

  {
  return ((u64 )(addr + size) <= mask);
}
}
__inline static void dma_debug_add_bus(struct bus_type *bus ) 
{ 

  {
  return;
}
}
__inline static void dma_debug_init(u32 num_entries ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , int direction , dma_addr_t dma_addr ,
                                        bool map_single ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                          int direction , bool map_single ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_map_sg(struct device *dev , struct scatterlist *sg ,
                                      int nents , int mapped_ents , int direction ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_unmap_sg(struct device *dev , struct scatterlist *sglist ,
                                        int nelems , int dir ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t dma_addr ,
                                              void *virt ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_free_coherent(struct device *dev , size_t size , void *virt ,
                                             dma_addr_t addr ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_sync_single_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                   size_t size , int direction ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                         unsigned long offset , size_t size ,
                                                         int direction ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_dump_mappings(struct device *dev ) 
{ 

  {
  return;
}
}
extern void swiotlb_init(void) ;
extern void *swiotlb_alloc_boot(size_t bytes , unsigned long nslabs ) ;
extern void *swiotlb_alloc(unsigned int order , unsigned long nslabs ) ;
extern dma_addr_t swiotlb_phys_to_bus(struct device *hwdev , phys_addr_t address ) ;
extern phys_addr_t swiotlb_bus_to_phys(dma_addr_t address ) ;
extern int swiotlb_arch_range_needs_mapping(phys_addr_t paddr , size_t size ) ;
extern void *swiotlb_alloc_coherent(struct device *hwdev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t flags ) ;
extern void swiotlb_free_coherent(struct device *hwdev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
extern dma_addr_t swiotlb_map_page(struct device *dev , struct page *page , unsigned long offset ,
                                   size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern void swiotlb_unmap_page(struct device *hwdev , dma_addr_t dev_addr , size_t size ,
                               enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern int swiotlb_map_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                          int direction ) ;
extern void swiotlb_unmap_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                             int direction ) ;
extern int swiotlb_map_sg_attrs(struct device *hwdev , struct scatterlist *sgl , int nelems ,
                                enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern void swiotlb_unmap_sg_attrs(struct device *hwdev , struct scatterlist *sgl ,
                                   int nelems , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern void swiotlb_sync_single_for_cpu(struct device *hwdev , dma_addr_t dev_addr ,
                                        size_t size , enum dma_data_direction dir ) ;
extern void swiotlb_sync_sg_for_cpu(struct device *hwdev , struct scatterlist *sg ,
                                    int nelems , enum dma_data_direction dir ) ;
extern void swiotlb_sync_single_for_device(struct device *hwdev , dma_addr_t dev_addr ,
                                           size_t size , enum dma_data_direction dir ) ;
extern void swiotlb_sync_sg_for_device(struct device *hwdev , struct scatterlist *sg ,
                                       int nelems , enum dma_data_direction dir ) ;
extern void swiotlb_sync_single_range_for_cpu(struct device *hwdev , dma_addr_t dev_addr ,
                                              unsigned long offset , size_t size ,
                                              enum dma_data_direction dir ) ;
extern void swiotlb_sync_single_range_for_device(struct device *hwdev , dma_addr_t dev_addr ,
                                                 unsigned long offset , size_t size ,
                                                 enum dma_data_direction dir ) ;
extern int swiotlb_dma_mapping_error(struct device *hwdev , dma_addr_t dma_addr ) ;
extern int swiotlb_dma_supported(struct device *hwdev , u64 mask ) ;
extern int swiotlb_force ;
__inline static void dma_mark_clean(void *addr , size_t size ) 
{ 

  {
  return;
}
}
extern int dma_alloc_from_coherent(struct device *dev , ssize_t size , dma_addr_t *dma_handle ,
                                   void **ret ) ;
extern int dma_release_from_coherent(struct device *dev , int order , void *vaddr ) ;
extern int dma_declare_coherent_memory(struct device *dev , dma_addr_t bus_addr ,
                                       dma_addr_t device_addr , size_t size , int flags ) ;
extern void dma_release_declared_memory(struct device *dev ) ;
extern void *dma_mark_declared_memory_occupied(struct device *dev , dma_addr_t device_addr ,
                                               size_t size ) ;
extern dma_addr_t bad_dma_address ;
extern int iommu_merge ;
extern struct device x86_dma_fallback_dev ;
extern int panic_on_overflow ;
extern struct dma_map_ops *dma_ops ;
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 

  {
  return (dma_ops);
}
}
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  if (ops->mapping_error) {
    {
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
    }
    return (tmp___0);
  }
  return (dma_addr == bad_dma_address);
}
}
extern int dma_supported(struct device *hwdev , u64 mask ) ;
extern int dma_set_mask(struct device *dev , u64 mask ) ;
extern void *dma_generic_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_addr ,
                                        gfp_t flag ) ;
__inline static dma_addr_t dma_map_single(struct device *hwdev , void *ptr , size_t size ,
                                          enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_116_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_117_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (62), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_118_continue: /* CIL Label */ ;
        }
        while_118_break: /* CIL Label */ ;
        }
        goto while_117_break;
      }
      while_117_break: /* CIL Label */ ;
      }
    }
    goto while_116_break;
  }
  while_116_break: /* CIL Label */ ;
  }
  {
  addr = (*(ops->map_page))(hwdev, mem_map + (((unsigned long )ptr - 3221225472UL) >> 12),
                            (unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL)), size,
                            dir, (struct dma_attrs *)((void *)0));
  debug_dma_map_page(hwdev, mem_map + (((unsigned long )ptr - 3221225472UL) >> 12),
                     (unsigned int )((unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL))),
                     size, (int )dir, addr, (_Bool)1);
  }
  return (addr);
}
}
__inline static void dma_unmap_single(struct device *dev , dma_addr_t addr , size_t size ,
                                      enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_119_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_120_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (78), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_121_continue: /* CIL Label */ ;
        }
        while_121_break: /* CIL Label */ ;
        }
        goto while_120_break;
      }
      while_120_break: /* CIL Label */ ;
      }
    }
    goto while_119_break;
  }
  while_119_break: /* CIL Label */ ;
  }
  if (ops->unmap_page) {
    {
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)((void *)0));
    }
  }
  {
  debug_dma_unmap_page(dev, addr, size, (int )dir, (_Bool)1);
  }
  return;
}
}
__inline static int dma_map_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                               enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int ents ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_122_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_123_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (91), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_124_continue: /* CIL Label */ ;
        }
        while_124_break: /* CIL Label */ ;
        }
        goto while_123_break;
      }
      while_123_break: /* CIL Label */ ;
      }
    }
    goto while_122_break;
  }
  while_122_break: /* CIL Label */ ;
  }
  {
  ents = (*(ops->map_sg))(hwdev, sg, nents, dir, (struct dma_attrs *)((void *)0));
  debug_dma_map_sg(hwdev, sg, nents, ents, (int )dir);
  }
  return (ents);
}
}
__inline static void dma_unmap_sg(struct device *hwdev , struct scatterlist *sg ,
                                  int nents , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_125_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_126_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (104), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_127_continue: /* CIL Label */ ;
        }
        while_127_break: /* CIL Label */ ;
        }
        goto while_126_break;
      }
      while_126_break: /* CIL Label */ ;
      }
    }
    goto while_125_break;
  }
  while_125_break: /* CIL Label */ ;
  }
  {
  debug_dma_unmap_sg(hwdev, sg, nents, (int )dir);
  }
  if (ops->unmap_sg) {
    {
    (*(ops->unmap_sg))(hwdev, sg, nents, dir, (struct dma_attrs *)((void *)0));
    }
  }
  return;
}
}
__inline static void dma_sync_single_for_cpu(struct device *hwdev , dma_addr_t dma_handle ,
                                             size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_128_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_129_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (116), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_130_continue: /* CIL Label */ ;
        }
        while_130_break: /* CIL Label */ ;
        }
        goto while_129_break;
      }
      while_129_break: /* CIL Label */ ;
      }
    }
    goto while_128_break;
  }
  while_128_break: /* CIL Label */ ;
  }
  if (ops->sync_single_for_cpu) {
    {
    (*(ops->sync_single_for_cpu))(hwdev, dma_handle, size, dir);
    }
  }
  {
  debug_dma_sync_single_for_cpu(hwdev, dma_handle, size, (int )dir);
  }
  {
  while (1) {
    while_131_continue: /* CIL Label */ ;
    goto while_131_break;
  }
  while_131_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_single_for_device(struct device *hwdev , dma_addr_t dma_handle ,
                                                size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_132_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_133_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (129), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_134_continue: /* CIL Label */ ;
        }
        while_134_break: /* CIL Label */ ;
        }
        goto while_133_break;
      }
      while_133_break: /* CIL Label */ ;
      }
    }
    goto while_132_break;
  }
  while_132_break: /* CIL Label */ ;
  }
  if (ops->sync_single_for_device) {
    {
    (*(ops->sync_single_for_device))(hwdev, dma_handle, size, dir);
    }
  }
  {
  debug_dma_sync_single_for_cpu(hwdev, dma_handle, size, (int )dir);
  }
  {
  while (1) {
    while_135_continue: /* CIL Label */ ;
    goto while_135_break;
  }
  while_135_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_single_range_for_cpu(struct device *hwdev , dma_addr_t dma_handle ,
                                                   unsigned long offset , size_t size ,
                                                   enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_136_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_137_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (143), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_138_continue: /* CIL Label */ ;
        }
        while_138_break: /* CIL Label */ ;
        }
        goto while_137_break;
      }
      while_137_break: /* CIL Label */ ;
      }
    }
    goto while_136_break;
  }
  while_136_break: /* CIL Label */ ;
  }
  if (ops->sync_single_range_for_cpu) {
    {
    (*(ops->sync_single_range_for_cpu))(hwdev, dma_handle, offset, size, dir);
    }
  }
  {
  debug_dma_sync_single_range_for_cpu(hwdev, dma_handle, offset, size, (int )dir);
  }
  {
  while (1) {
    while_139_continue: /* CIL Label */ ;
    goto while_139_break;
  }
  while_139_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_single_range_for_device(struct device *hwdev , dma_addr_t dma_handle ,
                                                      unsigned long offset , size_t size ,
                                                      enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_140_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_141_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (159), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_142_continue: /* CIL Label */ ;
        }
        while_142_break: /* CIL Label */ ;
        }
        goto while_141_break;
      }
      while_141_break: /* CIL Label */ ;
      }
    }
    goto while_140_break;
  }
  while_140_break: /* CIL Label */ ;
  }
  if (ops->sync_single_range_for_device) {
    {
    (*(ops->sync_single_range_for_device))(hwdev, dma_handle, offset, size, dir);
    }
  }
  {
  debug_dma_sync_single_range_for_cpu(hwdev, dma_handle, offset, size, (int )dir);
  }
  {
  while (1) {
    while_143_continue: /* CIL Label */ ;
    goto while_143_break;
  }
  while_143_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_sg_for_cpu(struct device *hwdev , struct scatterlist *sg ,
                                         int nelems , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_144_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_145_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (174), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_146_continue: /* CIL Label */ ;
        }
        while_146_break: /* CIL Label */ ;
        }
        goto while_145_break;
      }
      while_145_break: /* CIL Label */ ;
      }
    }
    goto while_144_break;
  }
  while_144_break: /* CIL Label */ ;
  }
  if (ops->sync_sg_for_cpu) {
    {
    (*(ops->sync_sg_for_cpu))(hwdev, sg, nelems, dir);
    }
  }
  {
  debug_dma_unmap_sg(hwdev, sg, nelems, (int )dir);
  }
  {
  while (1) {
    while_147_continue: /* CIL Label */ ;
    goto while_147_break;
  }
  while_147_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_sg_for_device(struct device *hwdev , struct scatterlist *sg ,
                                            int nelems , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_148_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_149_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (187), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_150_continue: /* CIL Label */ ;
        }
        while_150_break: /* CIL Label */ ;
        }
        goto while_149_break;
      }
      while_149_break: /* CIL Label */ ;
      }
    }
    goto while_148_break;
  }
  while_148_break: /* CIL Label */ ;
  }
  if (ops->sync_sg_for_device) {
    {
    (*(ops->sync_sg_for_device))(hwdev, sg, nelems, dir);
    }
  }
  {
  debug_dma_unmap_sg(hwdev, sg, nelems, (int )dir);
  }
  {
  while (1) {
    while_151_continue: /* CIL Label */ ;
    goto while_151_break;
  }
  while_151_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_152_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_153_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (202), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_154_continue: /* CIL Label */ ;
        }
        while_154_break: /* CIL Label */ ;
        }
        goto while_153_break;
      }
      while_153_break: /* CIL Label */ ;
      }
    }
    goto while_152_break;
  }
  while_152_break: /* CIL Label */ ;
  }
  {
  addr = (*(ops->map_page))(dev, page, (unsigned long )offset, size, dir, (struct dma_attrs *)((void *)0));
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, (_Bool)0);
  }
  return (addr);
}
}
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_155_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_156_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (214), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_157_continue: /* CIL Label */ ;
        }
        while_157_break: /* CIL Label */ ;
        }
        goto while_156_break;
      }
      while_156_break: /* CIL Label */ ;
      }
    }
    goto while_155_break;
  }
  while_155_break: /* CIL Label */ ;
  }
  if (ops->unmap_page) {
    {
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)((void *)0));
    }
  }
  {
  debug_dma_unmap_page(dev, addr, size, (int )dir, (_Bool)0);
  }
  return;
}
}
__inline static void dma_cache_sync(struct device *dev , void *vaddr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 

  {
  {
  while (1) {
    while_158_continue: /* CIL Label */ ;
    goto while_158_break;
  }
  while_158_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int dma_get_cache_alignment(void) 
{ 

  {
  return ((int )boot_cpu_data.x86_clflush_size);
}
}
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;

  {
  {
  dma_mask = 0UL;
  dma_mask = (unsigned long )dev->coherent_dma_mask;
  }
  if (! dma_mask) {
    if (gfp & 1U) {
      {
      dma_mask = (unsigned long )((1ULL << 24) - 1ULL);
      }
    } else {
      {
      dma_mask = (unsigned long )((1ULL << 32) - 1ULL);
      }
    }
  }
  return (dma_mask);
}
}
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;
  unsigned long tmp ;

  {
  {
  tmp = dma_alloc_coherent_mask(dev, gfp);
  dma_mask = tmp;
  }
  if ((unsigned long long )dma_mask <= (1ULL << 24) - 1ULL) {
    {
    gfp |= 1U;
    }
  }
  return (gfp);
}
}
__inline static void *dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                         gfp_t gfp ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  int tmp___1 ;
  gfp_t tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  gfp &= 4294967288U;
  tmp___0 = dma_alloc_from_coherent(dev, (int )size, dma_handle, & memory);
  }
  if (tmp___0) {
    return (memory);
  }
  if (! dev) {
    {
    dev = & x86_dma_fallback_dev;
    gfp |= 1U;
    }
  }
  {
  tmp___1 = is_device_dma_capable(dev);
  }
  if (! tmp___1) {
    return ((void *)0);
  }
  if (! ops->alloc_coherent) {
    return ((void *)0);
  }
  {
  tmp___2 = dma_alloc_coherent_gfp_flags(dev, gfp);
  memory = (*(ops->alloc_coherent))(dev, size, dma_handle, tmp___2);
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
  return (memory);
}
}
__inline static void dma_free_coherent(struct device *dev , size_t size , void *vaddr ,
                                       dma_addr_t bus ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_159_continue: /* CIL Label */ ;
    {
    _flags = __raw_local_save_flags();
    }
    goto while_159_break;
  }
  while_159_break: /* CIL Label */ ;
  }
  {
  tmp___0 = raw_irqs_disabled_flags(_flags);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  __ret_warn_on = tmp___1;
  tmp___2 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
  if (tmp___2) {
    {
    warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h",
                       294);
    }
  }
  {
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  tmp___3 = get_order((unsigned long )size);
  tmp___4 = dma_release_from_coherent(dev, tmp___3, vaddr);
  }
  if (tmp___4) {
    return;
  }
  {
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
  if (ops->free_coherent) {
    {
    (*(ops->free_coherent))(dev, size, vaddr, bus);
    }
  }
  return;
}
}
__inline static u64 dma_get_mask(struct device *dev ) 
{ 

  {
  if (dev) {
    if (dev->dma_mask) {
      if (*(dev->dma_mask)) {
        return (*(dev->dma_mask));
      }
    }
  }
  return ((1ULL << 32) - 1ULL);
}
}
extern u64 dma_get_required_mask(struct device *dev ) ;
__inline static unsigned int dma_get_max_seg_size(struct device *dev ) 
{ unsigned int tmp ;

  {
  if (dev->dma_parms) {
    {
    tmp = (dev->dma_parms)->max_segment_size;
    }
  } else {
    {
    tmp = 65536U;
    }
  }
  return (tmp);
}
}
__inline static unsigned int dma_set_max_seg_size(struct device *dev , unsigned int size ) 
{ 

  {
  if (dev->dma_parms) {
    {
    (dev->dma_parms)->max_segment_size = size;
    }
    return (0U);
  } else {
    return (4294967291U);
  }
}
}
__inline static unsigned long dma_get_seg_boundary(struct device *dev ) 
{ unsigned long tmp ;

  {
  if (dev->dma_parms) {
    {
    tmp = (dev->dma_parms)->segment_boundary_mask;
    }
  } else {
    {
    tmp = 4294967295UL;
    }
  }
  return (tmp);
}
}
__inline static int dma_set_seg_boundary(struct device *dev , unsigned long mask ) 
{ 

  {
  if (dev->dma_parms) {
    {
    (dev->dma_parms)->segment_boundary_mask = mask;
    }
    return (0);
  } else {
    return (-5);
  }
}
}
extern void *dmam_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                 gfp_t gfp ) ;
extern void dmam_free_coherent(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
extern void *dmam_alloc_noncoherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t gfp ) ;
extern void dmam_free_noncoherent(struct device *dev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
extern int dmam_declare_coherent_memory(struct device *dev , dma_addr_t bus_addr ,
                                        dma_addr_t device_addr , size_t size , int flags ) ;
extern void dmam_release_declared_memory(struct device *dev ) ;
extern struct dma_pool *dma_pool_create(char const   *name , struct device *dev ,
                                        size_t size , size_t align , size_t allocation ) ;
extern void dma_pool_destroy(struct dma_pool *pool ) ;
extern void *dma_pool_alloc(struct dma_pool *pool , gfp_t mem_flags , dma_addr_t *handle ) ;
extern void dma_pool_free(struct dma_pool *pool , void *vaddr , dma_addr_t addr ) ;
extern struct dma_pool *dmam_pool_create(char const   *name , struct device *dev ,
                                         size_t size , size_t align , size_t allocation ) ;
extern void dmam_pool_destroy(struct dma_pool *pool ) ;
__inline static int usb_endpoint_num(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return ((int )((int const   )epd->bEndpointAddress & 15));
}
}
__inline static int usb_endpoint_type(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return ((int )((int const   )epd->bmAttributes & 3));
}
}
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return (((int const   )epd->bEndpointAddress & 128) == 128);
}
}
__inline static int usb_endpoint_dir_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return (((int const   )epd->bEndpointAddress & 128) == 0);
}
}
__inline static int usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return (((int const   )epd->bmAttributes & 3) == 2);
}
}
__inline static int usb_endpoint_xfer_control(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return (((int const   )epd->bmAttributes & 3) == 0);
}
}
__inline static int usb_endpoint_xfer_int(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return (((int const   )epd->bmAttributes & 3) == 3);
}
}
__inline static int usb_endpoint_xfer_isoc(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
  return (((int const   )epd->bmAttributes & 3) == 1);
}
}
__inline static int usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = usb_endpoint_xfer_bulk(epd);
  }
  if (tmp) {
    {
    tmp___0 = usb_endpoint_dir_in(epd);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
__inline static int usb_endpoint_is_bulk_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = usb_endpoint_xfer_bulk(epd);
  }
  if (tmp) {
    {
    tmp___0 = usb_endpoint_dir_out(epd);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
__inline static int usb_endpoint_is_int_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = usb_endpoint_xfer_int(epd);
  }
  if (tmp) {
    {
    tmp___0 = usb_endpoint_dir_in(epd);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
__inline static int usb_endpoint_is_int_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = usb_endpoint_xfer_int(epd);
  }
  if (tmp) {
    {
    tmp___0 = usb_endpoint_dir_out(epd);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
__inline static int usb_endpoint_is_isoc_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = usb_endpoint_xfer_isoc(epd);
  }
  if (tmp) {
    {
    tmp___0 = usb_endpoint_dir_in(epd);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
__inline static int usb_endpoint_is_isoc_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = usb_endpoint_xfer_isoc(epd);
  }
  if (tmp) {
    {
    tmp___0 = usb_endpoint_dir_out(epd);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
extern int nr_irqs ;
extern struct irq_desc *irq_to_desc(unsigned int irq ) ;
extern int file_caps_enabled ;
__inline static kernel_cap_t cap_combine(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_160_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_161_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_161_break;
      }
      {
      dest.cap[__capi] = a.cap[__capi] | b.cap[__capi];
      __capi ++;
      }
    }
    while_161_break: /* CIL Label */ ;
    }
    goto while_160_break;
  }
  while_160_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static kernel_cap_t cap_intersect(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_162_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_163_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_163_break;
      }
      {
      dest.cap[__capi] = a.cap[__capi] & b.cap[__capi];
      __capi ++;
      }
    }
    while_163_break: /* CIL Label */ ;
    }
    goto while_162_break;
  }
  while_162_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static kernel_cap_t cap_drop(kernel_cap_t a , kernel_cap_t drop ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_164_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_165_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_165_break;
      }
      {
      dest.cap[__capi] = a.cap[__capi] & ~ drop.cap[__capi];
      __capi ++;
      }
    }
    while_165_break: /* CIL Label */ ;
    }
    goto while_164_break;
  }
  while_164_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static kernel_cap_t cap_invert(kernel_cap_t c ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_166_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_167_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_167_break;
      }
      {
      dest.cap[__capi] = ~ c.cap[__capi];
      __capi ++;
      }
    }
    while_167_break: /* CIL Label */ ;
    }
    goto while_166_break;
  }
  while_166_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static int cap_isclear(kernel_cap_t a ) 
{ unsigned int __capi ;

  {
  {
  __capi = 0U;
  }
  {
  while (1) {
    while_168_continue: /* CIL Label */ ;
    if (! (__capi < 2U)) {
      goto while_168_break;
    }
    if (a.cap[__capi] != 0U) {
      return (0);
    }
    {
    __capi ++;
    }
  }
  while_168_break: /* CIL Label */ ;
  }
  return (1);
}
}
__inline static int cap_issubset(kernel_cap_t a , kernel_cap_t set ) 
{ kernel_cap_t dest ;
  int tmp ;

  {
  {
  dest = cap_drop(a, set);
  tmp = cap_isclear(dest);
  }
  return (tmp);
}
}
__inline static int cap_is_fs_cap(int cap ) 
{ kernel_cap_t __cap_fs_set ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
  __cap_fs_set.cap[1] = (__u32 )1;
  }
  return (! (! ((unsigned int )(1 << (cap & 31)) & __cap_fs_set.cap[cap >> 5])));
}
}
__inline static kernel_cap_t cap_drop_fs_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
  __cap_fs_set.cap[1] = (__u32 )1;
  tmp = cap_drop(a, __cap_fs_set);
  }
  return (tmp);
}
}
__inline static kernel_cap_t cap_raise_fs_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
  __cap_fs_set.cap[1] = (__u32 )1;
  tmp = cap_intersect(permitted, __cap_fs_set);
  tmp___0 = cap_combine(a, tmp);
  }
  return (tmp___0);
}
}
__inline static kernel_cap_t cap_drop_nfsd_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
  __cap_fs_set.cap[1] = (__u32 )1;
  tmp = cap_drop(a, __cap_fs_set);
  }
  return (tmp);
}
}
__inline static kernel_cap_t cap_raise_nfsd_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_nfsd_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
  __cap_nfsd_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
  __cap_nfsd_set.cap[1] = (__u32 )1;
  tmp = cap_intersect(permitted, __cap_nfsd_set);
  tmp___0 = cap_combine(a, tmp);
  }
  return (tmp___0);
}
}
extern kernel_cap_t const   __cap_empty_set ;
extern kernel_cap_t const   __cap_full_set ;
extern kernel_cap_t const   __cap_init_eff_set ;
extern int capable(int cap ) ;
extern int get_vfs_caps_from_disk(struct dentry  const  *dentry , struct cpu_vfs_cap_data *cpu_caps ) ;
extern int copy_semundo(unsigned long clone_flags , struct task_struct *tsk ) ;
extern void exit_sem(struct task_struct *tsk ) ;
extern void do_notify_resume(struct pt_regs * , void * , __u32  ) ;
extern void do_schedule_next_timer(struct siginfo *info ) ;
__inline static void copy_siginfo(struct siginfo *to , struct siginfo *from ) 
{ 

  {
  if (from->si_code < 0) {
    {
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )sizeof(*to));
    }
  } else {
    {
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )(4UL * sizeof(int ) + sizeof(from->_sifields._sigchld)));
    }
  }
  return;
}
}
extern int copy_siginfo_to_user(struct siginfo *to , struct siginfo *from ) ;
__inline static void sigaddset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
  sig = (unsigned long )(_sig - 1);
  set->sig[0] |= 1UL << sig;
  }
  return;
}
}
__inline static void sigdelset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
  sig = (unsigned long )(_sig - 1);
  set->sig[0] &= ~ (1UL << sig);
  }
  return;
}
}
__inline static int sigismember(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
  sig = (unsigned long )(_sig - 1);
  }
  return ((int )(1UL & (set->sig[0] >> sig)));
}
}
__inline static int sigfindinword(unsigned long word ) 
{ unsigned long tmp ;

  {
  {
  tmp = ffz(~ word);
  }
  return ((int )tmp);
}
}
extern void _NSIG_WORDS_is_unsupported_size(void) ;
__inline static int sigisemptyset(sigset_t *set ) 
{ 

  {
  if (1 == 4) {
    goto switch_169_4;
  } else {
    if (1 == 2) {
      goto switch_169_2;
    } else {
      if (1 == 1) {
        goto switch_169_1;
      } else {
        {
        goto switch_169_default;
        if (0) {
          switch_169_4: /* CIL Label */ 
          return ((((set->sig[3] | set->sig[2]) | set->sig[1]) | set->sig[0]) == 0UL);
          switch_169_2: /* CIL Label */ 
          return ((set->sig[1] | set->sig[0]) == 0UL);
          switch_169_1: /* CIL Label */ 
          return (set->sig[0] == 0UL);
          switch_169_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
          return (0);
        } else {
          switch_169_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
__inline static void sigorsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  if (1 == 4) {
    goto switch_170_4;
  } else {
    if (1 == 2) {
      goto switch_170_2;
    } else {
      if (1 == 1) {
        goto switch_170_1;
      } else {
        {
        goto switch_170_default;
        if (0) {
          switch_170_4: /* CIL Label */ 
          {
          a3 = a->sig[3];
          a2 = a->sig[2];
          b3 = b->sig[3];
          b2 = b->sig[2];
          r->sig[3] = a3 | b3;
          r->sig[2] = a2 | b2;
          }
          switch_170_2: /* CIL Label */ 
          {
          a1 = a->sig[1];
          b1 = b->sig[1];
          r->sig[1] = a1 | b1;
          }
          switch_170_1: /* CIL Label */ 
          {
          a0 = a->sig[0];
          b0 = b->sig[0];
          r->sig[0] = a0 | b0;
          }
          goto switch_170_break;
          switch_170_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_170_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void sigandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  if (1 == 4) {
    goto switch_171_4;
  } else {
    if (1 == 2) {
      goto switch_171_2;
    } else {
      if (1 == 1) {
        goto switch_171_1;
      } else {
        {
        goto switch_171_default;
        if (0) {
          switch_171_4: /* CIL Label */ 
          {
          a3 = a->sig[3];
          a2 = a->sig[2];
          b3 = b->sig[3];
          b2 = b->sig[2];
          r->sig[3] = a3 & b3;
          r->sig[2] = a2 & b2;
          }
          switch_171_2: /* CIL Label */ 
          {
          a1 = a->sig[1];
          b1 = b->sig[1];
          r->sig[1] = a1 & b1;
          }
          switch_171_1: /* CIL Label */ 
          {
          a0 = a->sig[0];
          b0 = b->sig[0];
          r->sig[0] = a0 & b0;
          }
          goto switch_171_break;
          switch_171_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_171_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void signandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  if (1 == 4) {
    goto switch_172_4;
  } else {
    if (1 == 2) {
      goto switch_172_2;
    } else {
      if (1 == 1) {
        goto switch_172_1;
      } else {
        {
        goto switch_172_default;
        if (0) {
          switch_172_4: /* CIL Label */ 
          {
          a3 = a->sig[3];
          a2 = a->sig[2];
          b3 = b->sig[3];
          b2 = b->sig[2];
          r->sig[3] = a3 & ~ b3;
          r->sig[2] = a2 & ~ b2;
          }
          switch_172_2: /* CIL Label */ 
          {
          a1 = a->sig[1];
          b1 = b->sig[1];
          r->sig[1] = a1 & ~ b1;
          }
          switch_172_1: /* CIL Label */ 
          {
          a0 = a->sig[0];
          b0 = b->sig[0];
          r->sig[0] = a0 & ~ b0;
          }
          goto switch_172_break;
          switch_172_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_172_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void signotset(sigset_t *set ) 
{ 

  {
  if (1 == 4) {
    goto switch_173_4;
  } else {
    if (1 == 2) {
      goto switch_173_2;
    } else {
      if (1 == 1) {
        goto switch_173_1;
      } else {
        {
        goto switch_173_default;
        if (0) {
          switch_173_4: /* CIL Label */ 
          {
          set->sig[3] = ~ set->sig[3];
          set->sig[2] = ~ set->sig[2];
          }
          switch_173_2: /* CIL Label */ 
          {
          set->sig[1] = ~ set->sig[1];
          }
          switch_173_1: /* CIL Label */ 
          {
          set->sig[0] = ~ set->sig[0];
          }
          goto switch_173_break;
          switch_173_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_173_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void sigemptyset(sigset_t *set ) 
{ 

  {
  if (1 == 2) {
    goto switch_174_2;
  } else {
    if (1 == 1) {
      goto switch_174_1;
    } else {
      {
      goto switch_174_default;
      if (0) {
        switch_174_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)set, 0UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_174_break;
        switch_174_2: /* CIL Label */ 
        {
        set->sig[1] = 0UL;
        }
        switch_174_1: /* CIL Label */ 
        {
        set->sig[0] = 0UL;
        }
        goto switch_174_break;
      } else {
        switch_174_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void sigfillset(sigset_t *set ) 
{ 

  {
  if (1 == 2) {
    goto switch_175_2;
  } else {
    if (1 == 1) {
      goto switch_175_1;
    } else {
      {
      goto switch_175_default;
      if (0) {
        switch_175_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)set, 4294967295UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_175_break;
        switch_175_2: /* CIL Label */ 
        {
        set->sig[1] = 0xffffffffUL;
        }
        switch_175_1: /* CIL Label */ 
        {
        set->sig[0] = 0xffffffffUL;
        }
        goto switch_175_break;
      } else {
        switch_175_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void sigaddsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] |= mask;
  }
  return;
}
}
__inline static void sigdelsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] &= ~ mask;
  }
  return;
}
}
__inline static int sigtestsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  return ((set->sig[0] & mask) != 0UL);
}
}
__inline static void siginitset(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] = mask;
  }
  if (1 == 2) {
    goto switch_176_2;
  } else {
    if (1 == 1) {
      goto switch_176_1;
    } else {
      {
      goto switch_176_default;
      if (0) {
        switch_176_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)(& set->sig[1]), 0UL, 0U);
        }
        goto switch_176_break;
        switch_176_2: /* CIL Label */ 
        {
        set->sig[1] = 0UL;
        }
        switch_176_1: /* CIL Label */ 
        {

        }
      } else {
        switch_176_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void siginitsetinv(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] = ~ mask;
  }
  if (1 == 2) {
    goto switch_177_2;
  } else {
    if (1 == 1) {
      goto switch_177_1;
    } else {
      {
      goto switch_177_default;
      if (0) {
        switch_177_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)(& set->sig[1]), 4294967295UL, 0U);
        }
        goto switch_177_break;
        switch_177_2: /* CIL Label */ 
        {
        set->sig[1] = 0xffffffffUL;
        }
        switch_177_1: /* CIL Label */ 
        {

        }
      } else {
        switch_177_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void init_sigpending(struct sigpending *sig ) 
{ 

  {
  {
  sigemptyset(& sig->signal);
  INIT_LIST_HEAD(& sig->list);
  }
  return;
}
}
extern void flush_sigqueue(struct sigpending *queue ) ;
__inline static int valid_signal(unsigned long sig ) 
{ int tmp ;

  {
  if (sig <= 64UL) {
    {
    tmp = 1;
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern int next_signal(struct sigpending *pending , sigset_t *mask ) ;
extern int group_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ) ;
extern int __group_send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern long do_sigpending(void * , unsigned long  ) ;
extern int sigprocmask(int  , sigset_t * , sigset_t * ) ;
extern int show_unhandled_signals ;
extern int get_signal_to_deliver(siginfo_t *info , struct k_sigaction *return_ka ,
                                 struct pt_regs *regs , void *cookie ) ;
extern void exit_signals(struct task_struct *tsk ) ;
extern struct kmem_cache *sighand_cachep ;
extern int unhandled_signal(struct task_struct *tsk , int sig ) ;
extern void signals_init(void) ;
extern void path_get(struct path * ) ;
extern void path_put(struct path * ) ;
extern struct pid init_struct_pid ;
__inline static struct pid *get_pid(struct pid *pid ) 
{ 

  {
  if (pid) {
    {
    atomic_inc(& pid->count);
    }
  }
  return (pid);
}
}
extern void put_pid(struct pid *pid ) ;
extern struct task_struct *pid_task(struct pid *pid , enum pid_type  ) ;
extern struct task_struct *get_pid_task(struct pid *pid , enum pid_type  ) ;
extern struct pid *get_task_pid(struct task_struct *task , enum pid_type type ) ;
extern void attach_pid(struct task_struct *task , enum pid_type type , struct pid *pid ) ;
extern void detach_pid(struct task_struct *task , enum pid_type  ) ;
extern void change_pid(struct task_struct *task , enum pid_type  , struct pid *pid ) ;
extern void transfer_pid(struct task_struct *old , struct task_struct *new , enum pid_type  ) ;
extern struct pid_namespace init_pid_ns ;
extern struct pid *find_pid_ns(int nr , struct pid_namespace *ns ) ;
extern struct pid *find_vpid(int nr ) ;
extern struct pid *find_get_pid(int nr ) ;
extern struct pid *find_ge_pid(int nr , struct pid_namespace * ) ;
extern int next_pidmap(struct pid_namespace *pid_ns , int last ) ;
extern struct pid *alloc_pid(struct pid_namespace *ns ) ;
extern void free_pid(struct pid *pid ) ;
__inline static struct pid_namespace *ns_of_pid(struct pid *pid ) 
{ struct pid_namespace *ns ;

  {
  {
  ns = (struct pid_namespace *)((void *)0);
  }
  if (pid) {
    {
    ns = pid->numbers[pid->level].ns;
    }
  }
  return (ns);
}
}
__inline static pid_t pid_nr(struct pid *pid ) 
{ pid_t nr ;

  {
  {
  nr = 0;
  }
  if (pid) {
    {
    nr = pid->numbers[0].nr;
    }
  }
  return (nr);
}
}
extern pid_t pid_nr_ns(struct pid *pid , struct pid_namespace *ns ) ;
extern pid_t pid_vnr(struct pid *pid ) ;
extern int percpu_counter_batch ;
extern int __percpu_counter_init(struct percpu_counter *fbc , s64 amount , struct lock_class_key *key ) ;
extern void percpu_counter_destroy(struct percpu_counter *fbc ) ;
extern void percpu_counter_set(struct percpu_counter *fbc , s64 amount ) ;
extern void __percpu_counter_add(struct percpu_counter *fbc , s64 amount , s32 batch ) ;
extern s64 __percpu_counter_sum(struct percpu_counter *fbc ) ;
__inline static void percpu_counter_add(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
  __percpu_counter_add(fbc, amount, percpu_counter_batch);
  }
  return;
}
}
__inline static s64 percpu_counter_sum_positive(struct percpu_counter *fbc ) 
{ s64 ret ;
  s64 tmp ;
  s64 tmp___0 ;

  {
  {
  tmp = __percpu_counter_sum(fbc);
  ret = tmp;
  }
  if (ret < 0LL) {
    {
    tmp___0 = 0LL;
    }
  } else {
    {
    tmp___0 = ret;
    }
  }
  return (tmp___0);
}
}
__inline static s64 percpu_counter_sum(struct percpu_counter *fbc ) 
{ s64 tmp ;

  {
  {
  tmp = __percpu_counter_sum(fbc);
  }
  return (tmp);
}
}
__inline static s64 percpu_counter_read(struct percpu_counter *fbc ) 
{ 

  {
  return (fbc->count);
}
}
__inline static s64 percpu_counter_read_positive(struct percpu_counter *fbc ) 
{ s64 ret ;

  {
  {
  ret = fbc->count;
  __asm__  volatile   ("": : : "memory");
  }
  if (ret >= 0LL) {
    return (ret);
  }
  return (1LL);
}
}
__inline static void percpu_counter_inc(struct percpu_counter *fbc ) 
{ 

  {
  {
  percpu_counter_add(fbc, 1LL);
  }
  return;
}
}
__inline static void percpu_counter_dec(struct percpu_counter *fbc ) 
{ 

  {
  {
  percpu_counter_add(fbc, -1LL);
  }
  return;
}
}
__inline static void percpu_counter_sub(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
  percpu_counter_add(fbc, - amount);
  }
  return;
}
}
extern int prop_descriptor_init(struct prop_descriptor *pd , int shift ) ;
extern void prop_change_shift(struct prop_descriptor *pd , int new_shift ) ;
extern int prop_local_init_percpu(struct prop_local_percpu *pl ) ;
extern void prop_local_destroy_percpu(struct prop_local_percpu *pl ) ;
extern void __prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) ;
extern void prop_fraction_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                 long *numerator , long *denominator ) ;
__inline static void prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
  while (1) {
    while_178_continue: /* CIL Label */ ;
    {
    while (1) {
      while_179_continue: /* CIL Label */ ;
      {
      flags = __raw_local_irq_save();
      }
      goto while_179_break;
    }
    while_179_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_180_continue: /* CIL Label */ ;
      goto while_180_break;
    }
    while_180_break: /* CIL Label */ ;
    }
    goto while_178_break;
  }
  while_178_break: /* CIL Label */ ;
  }
  {
  __prop_inc_percpu(pd, pl);
  }
  {
  while (1) {
    while_181_continue: /* CIL Label */ ;
    {
    tmp = raw_irqs_disabled_flags(flags);
    }
    if (tmp) {
      {
      raw_local_irq_restore(flags);
      }
      {
      while (1) {
        while_182_continue: /* CIL Label */ ;
        goto while_182_break;
      }
      while_182_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_183_continue: /* CIL Label */ ;
        goto while_183_break;
      }
      while_183_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_restore(flags);
      }
    }
    goto while_181_break;
  }
  while_181_break: /* CIL Label */ ;
  }
  return;
}
}
extern void __prop_inc_percpu_max(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                  long frac ) ;
extern int prop_local_init_single(struct prop_local_single *pl ) ;
extern void prop_local_destroy_single(struct prop_local_single *pl ) ;
extern void __prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) ;
extern void prop_fraction_single(struct prop_descriptor *pd , struct prop_local_single *pl ,
                                 long *numerator , long *denominator ) ;
__inline static void prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
  while (1) {
    while_184_continue: /* CIL Label */ ;
    {
    while (1) {
      while_185_continue: /* CIL Label */ ;
      {
      flags = __raw_local_irq_save();
      }
      goto while_185_break;
    }
    while_185_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_186_continue: /* CIL Label */ ;
      goto while_186_break;
    }
    while_186_break: /* CIL Label */ ;
    }
    goto while_184_break;
  }
  while_184_break: /* CIL Label */ ;
  }
  {
  __prop_inc_single(pd, pl);
  }
  {
  while (1) {
    while_187_continue: /* CIL Label */ ;
    {
    tmp = raw_irqs_disabled_flags(flags);
    }
    if (tmp) {
      {
      raw_local_irq_restore(flags);
      }
      {
      while (1) {
        while_188_continue: /* CIL Label */ ;
        goto while_188_break;
      }
      while_188_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_189_continue: /* CIL Label */ ;
        goto while_189_break;
      }
      while_189_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_restore(flags);
      }
    }
    goto while_187_break;
  }
  while_187_break: /* CIL Label */ ;
  }
  return;
}
}
extern void __secure_computing(int  ) ;
__inline static void secure_computing(int this_syscall ) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = current_thread_info();
  tmp___0 = test_ti_thread_flag(tmp, 8);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    __secure_computing(this_syscall);
    }
  }
  return;
}
}
extern long prctl_get_seccomp(void) ;
extern long prctl_set_seccomp(unsigned long  ) ;
__inline static void plist_head_init(struct plist_head *head , spinlock_t *lock ) 
{ 

  {
  {
  INIT_LIST_HEAD(& head->prio_list);
  INIT_LIST_HEAD(& head->node_list);
  }
  return;
}
}
__inline static void plist_node_init(struct plist_node *node , int prio ) 
{ 

  {
  {
  node->prio = prio;
  plist_head_init(& node->plist, (spinlock_t *)((void *)0));
  }
  return;
}
}
extern void plist_add(struct plist_node *node , struct plist_head *head ) ;
extern void plist_del(struct plist_node *node , struct plist_head *head ) ;
__inline static int plist_head_empty(struct plist_head  const  *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty(& head->node_list);
  }
  return (tmp);
}
}
__inline static int plist_node_empty(struct plist_node  const  *node ) 
{ int tmp ;

  {
  {
  tmp = plist_head_empty(& node->plist);
  }
  return (tmp);
}
}
__inline static struct plist_node *plist_first(struct plist_head  const  *head ) 
{ struct list_head  const  *__mptr ;

  {
  {
  __mptr = (struct list_head  const  *)head->node_list.next;
  }
  return ((struct plist_node *)((char *)__mptr - (unsigned int )(& ((struct plist_node *)0)->plist.node_list)));
}
}
__inline static int rt_mutex_debug_check_no_locks_freed(void const   *from , unsigned long len ) 
{ 

  {
  return (0);
}
}
__inline static int rt_mutex_is_locked(struct rt_mutex *lock ) 
{ 

  {
  return ((unsigned long )lock->owner != (unsigned long )((void *)0));
}
}
extern void __rt_mutex_init(struct rt_mutex *lock , char const   *name ) ;
extern void rt_mutex_destroy(struct rt_mutex *lock ) ;
extern void rt_mutex_lock(struct rt_mutex *lock ) ;
extern int rt_mutex_lock_interruptible(struct rt_mutex *lock , int detect_deadlock ) ;
extern int rt_mutex_timed_lock(struct rt_mutex *lock , struct hrtimer_sleeper *timeout ,
                               int detect_deadlock ) ;
extern int rt_mutex_trylock(struct rt_mutex *lock ) ;
extern void rt_mutex_unlock(struct rt_mutex *lock ) ;
extern int getrusage(struct task_struct *p , int who , struct rusage *ru ) ;
__inline static void hrtimer_set_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
  timer->_expires = time;
  timer->_softexpires = time;
  }
  return;
}
}
__inline static void hrtimer_set_expires_range(struct hrtimer *timer , ktime_t time ,
                                               ktime_t delta ) 
{ 

  {
  {
  timer->_softexpires = time;
  timer->_expires = ktime_add_safe(time, delta);
  }
  return;
}
}
__inline static void hrtimer_set_expires_range_ns(struct hrtimer *timer , ktime_t time ,
                                                  unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
__inline static void hrtimer_set_expires_tv64(struct hrtimer *timer , s64 tv64 ) 
{ 

  {
  {
  timer->_expires.tv64 = tv64;
  timer->_softexpires.tv64 = tv64;
  }
  return;
}
}
__inline static void hrtimer_add_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
  timer->_expires = ktime_add_safe(timer->_expires, time);
  timer->_softexpires = ktime_add_safe(timer->_softexpires, time);
  }
  return;
}
}
__inline static void hrtimer_add_expires_ns(struct hrtimer *timer , u64 ns ) 
{ ktime_t __constr_expr_0 ;
  ktime_t __constr_expr_1 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )timer->_expires.tv64 + ns);
  timer->_expires = __constr_expr_0;
  __constr_expr_1.tv64 = (s64 )((u64 )timer->_softexpires.tv64 + ns);
  timer->_softexpires = __constr_expr_1;
  }
  return;
}
}
__inline static ktime_t hrtimer_get_expires(struct hrtimer  const  *timer ) 
{ 

  {
  return (timer->_expires);
}
}
__inline static ktime_t hrtimer_get_softexpires(struct hrtimer  const  *timer ) 
{ 

  {
  return (timer->_softexpires);
}
}
__inline static s64 hrtimer_get_expires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
  return ((long long )timer->_expires.tv64);
}
}
__inline static s64 hrtimer_get_softexpires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
  return ((long long )timer->_softexpires.tv64);
}
}
__inline static ktime_t hrtimer_expires_remaining(struct hrtimer  const  *timer ) 
{ ktime_t __constr_expr_0 ;
  ktime_t tmp ;

  {
  {
  tmp = (*((timer->base)->get_time))();
  __constr_expr_0.tv64 = (s64 )(timer->_expires.tv64 - (s64 const   )tmp.tv64);
  }
  return (__constr_expr_0);
}
}
extern void clock_was_set(void) ;
extern void hres_timers_resume(void) ;
extern void hrtimer_interrupt(struct clock_event_device *dev ) ;
__inline static ktime_t hrtimer_cb_get_time(struct hrtimer *timer ) 
{ ktime_t tmp ;

  {
  {
  tmp = (*((timer->base)->get_time))();
  }
  return (tmp);
}
}
__inline static int hrtimer_is_hres_active(struct hrtimer *timer ) 
{ 

  {
  return (((timer->base)->cpu_base)->hres_active);
}
}
extern void hrtimer_peek_ahead_timers(void) ;
extern ktime_t ktime_get(void) ;
extern ktime_t ktime_get_real(void) ;
extern struct tick_device per_cpu__tick_cpu_device  __attribute__((__section__(".data.percpu"))) ;
extern void hrtimer_init(struct hrtimer *timer , clockid_t which_clock , enum hrtimer_mode mode ) ;
__inline static void hrtimer_init_on_stack(struct hrtimer *timer , clockid_t which_clock ,
                                           enum hrtimer_mode mode ) 
{ 

  {
  {
  hrtimer_init(timer, which_clock, mode);
  }
  return;
}
}
__inline static void destroy_hrtimer_on_stack(struct hrtimer *timer ) 
{ 

  {
  return;
}
}
extern int hrtimer_start(struct hrtimer *timer , ktime_t tim , enum hrtimer_mode mode ) ;
extern int hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long range_ns ,
                                  enum hrtimer_mode mode ) ;
extern int __hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long delta_ns ,
                                    enum hrtimer_mode mode , int wakeup ) ;
extern int hrtimer_cancel(struct hrtimer *timer ) ;
extern int hrtimer_try_to_cancel(struct hrtimer *timer ) ;
__inline static int hrtimer_start_expires(struct hrtimer *timer , enum hrtimer_mode mode ) 
{ unsigned long delta ;
  ktime_t soft ;
  ktime_t hard ;
  ktime_t __constr_expr_0 ;
  int tmp ;

  {
  {
  soft = hrtimer_get_softexpires((struct hrtimer  const  *)timer);
  hard = hrtimer_get_expires((struct hrtimer  const  *)timer);
  __constr_expr_0.tv64 = hard.tv64 - soft.tv64;
  delta = (unsigned long )__constr_expr_0.tv64;
  tmp = hrtimer_start_range_ns(timer, soft, delta, mode);
  }
  return (tmp);
}
}
__inline static int hrtimer_restart(struct hrtimer *timer ) 
{ int tmp ;

  {
  {
  tmp = hrtimer_start_expires(timer, (enum hrtimer_mode )0);
  }
  return (tmp);
}
}
extern ktime_t hrtimer_get_remaining(struct hrtimer  const  *timer ) ;
extern int hrtimer_get_res(clockid_t which_clock , struct timespec *tp ) ;
extern ktime_t hrtimer_get_next_event(void) ;
__inline static int hrtimer_active(struct hrtimer  const  *timer ) 
{ 

  {
  return (timer->state != 0UL);
}
}
__inline static int hrtimer_is_queued(struct hrtimer *timer ) 
{ 

  {
  return ((int )(timer->state & 1UL));
}
}
__inline static int hrtimer_callback_running(struct hrtimer *timer ) 
{ 

  {
  return ((int )(timer->state & 2UL));
}
}
extern u64 hrtimer_forward(struct hrtimer *timer , ktime_t now , ktime_t interval ) ;
__inline static u64 hrtimer_forward_now(struct hrtimer *timer , ktime_t interval ) 
{ ktime_t tmp ;
  u64 tmp___0 ;

  {
  {
  tmp = (*((timer->base)->get_time))();
  tmp___0 = hrtimer_forward(timer, tmp, interval);
  }
  return (tmp___0);
}
}
extern long hrtimer_nanosleep(struct timespec *rqtp , struct timespec *rmtp , enum hrtimer_mode mode ,
                              clockid_t clockid ) ;
extern long hrtimer_nanosleep_restart(struct restart_block *restart_block ) ;
extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl , struct task_struct *tsk ) ;
extern int schedule_hrtimeout_range(ktime_t *expires , unsigned long delta , enum hrtimer_mode mode ) ;
extern int schedule_hrtimeout(ktime_t *expires , enum hrtimer_mode mode ) ;
extern void hrtimer_run_queues(void) ;
extern void hrtimer_run_pending(void) ;
extern void hrtimers_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern u64 ktime_divns(ktime_t kt , s64 div ) ;
extern void sysrq_timer_list_show(void) ;
__inline static void timer_stats_account_hrtimer(struct hrtimer *timer ) 
{ 

  {
  {
  timer_stats_update_stats((void *)timer, timer->start_pid, timer->start_site, (void *)timer->function,
                           timer->start_comm, 0U);
  }
  return;
}
}
extern void __timer_stats_hrtimer_set_start_info(struct hrtimer *timer , void *addr ) ;
__inline static void timer_stats_hrtimer_set_start_info(struct hrtimer *timer ) 
{ void *tmp ;

  {
  {
  tmp = __builtin_return_address(0U);
  __timer_stats_hrtimer_set_start_info(timer, tmp);
  }
  return;
}
}
__inline static void timer_stats_hrtimer_clear_start_info(struct hrtimer *timer ) 
{ 

  {
  {
  timer->start_site = (void *)0;
  }
  return;
}
}
__inline static void account_scheduler_latency(struct task_struct *task , int usecs ,
                                               int inter ) 
{ 

  {
  return;
}
}
extern void setup_sysctl_set(struct ctl_table_set *p , struct ctl_table_set *parent ,
                             int (*is_seen)(struct ctl_table_set * ) ) ;
extern void sysctl_head_get(struct ctl_table_header * ) ;
extern void sysctl_head_put(struct ctl_table_header * ) ;
extern int sysctl_is_seen(struct ctl_table_header * ) ;
extern struct ctl_table_header *sysctl_head_grab(struct ctl_table_header * ) ;
extern struct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev ) ;
extern struct ctl_table_header *__sysctl_head_next(struct nsproxy *namespaces , struct ctl_table_header *prev ) ;
extern void sysctl_head_finish(struct ctl_table_header *prev ) ;
extern int sysctl_perm(struct ctl_table_root *root , struct ctl_table *table , int op ) ;
extern int proc_dostring(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
extern int proc_dointvec(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
extern int proc_dointvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                size_t * , loff_t * ) ;
extern int proc_dointvec_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                 size_t * , loff_t * ) ;
extern int proc_dointvec_userhz_jiffies(struct ctl_table * , int  , struct file * ,
                                        void * , size_t * , loff_t * ) ;
extern int proc_dointvec_ms_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                    size_t * , loff_t * ) ;
extern int proc_doulongvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                  size_t * , loff_t * ) ;
extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table , int  , struct file * ,
                                             void * , size_t * , loff_t * ) ;
extern int do_sysctl(int *name , int nlen , void *oldval , size_t *oldlenp , void *newval ,
                     size_t newlen ) ;
extern ctl_handler sysctl_data ;
extern ctl_handler sysctl_string ;
extern ctl_handler sysctl_intvec ;
extern ctl_handler sysctl_jiffies ;
extern ctl_handler sysctl_ms_jiffies ;
extern void register_sysctl_root(struct ctl_table_root *root ) ;
extern struct ctl_table_header *__register_sysctl_paths(struct ctl_table_root *root ,
                                                        struct nsproxy *namespaces ,
                                                        struct ctl_path  const  *path ,
                                                        struct ctl_table *table ) ;
extern struct ctl_table_header *register_sysctl_table(struct ctl_table *table ) ;
extern struct ctl_table_header *register_sysctl_paths(struct ctl_path  const  *path ,
                                                      struct ctl_table *table ) ;
extern void unregister_sysctl_table(struct ctl_table_header *table ) ;
extern int sysctl_check_table(struct nsproxy *namespaces , struct ctl_table *table ) ;
__inline static key_ref_t make_key_ref(struct key  const  *key , unsigned long possession ) 
{ 

  {
  return ((struct __key_reference_with_attributes *)((unsigned long )key | possession));
}
}
__inline static struct key *key_ref_to_ptr(key_ref_t key_ref ) 
{ 

  {
  return ((struct key *)((unsigned long )key_ref & 0xfffffffeUL));
}
}
__inline static unsigned long is_key_possessed(key_ref_t key_ref ) 
{ 

  {
  return ((unsigned long )key_ref & 1UL);
}
}
extern struct key *key_alloc(struct key_type *type , char const   *desc , uid_t uid ,
                             gid_t gid , struct cred  const  *cred , key_perm_t perm ,
                             unsigned long flags ) ;
extern void key_revoke(struct key *key ) ;
extern void key_put(struct key *key ) ;
__inline static struct key *key_get(struct key *key ) 
{ 

  {
  if (key) {
    {
    atomic_inc(& key->usage);
    }
  }
  return (key);
}
}
__inline static void key_ref_put(key_ref_t key_ref ) 
{ struct key *tmp ;

  {
  {
  tmp = key_ref_to_ptr(key_ref);
  key_put(tmp);
  }
  return;
}
}
extern struct key *request_key(struct key_type *type , char const   *description ,
                               char const   *callout_info ) ;
extern struct key *request_key_with_auxdata(struct key_type *type , char const   *description ,
                                            void const   *callout_info , size_t callout_len ,
                                            void *aux ) ;
extern struct key *request_key_async(struct key_type *type , char const   *description ,
                                     void const   *callout_info , size_t callout_len ) ;
extern struct key *request_key_async_with_auxdata(struct key_type *type , char const   *description ,
                                                  void const   *callout_info , size_t callout_len ,
                                                  void *aux ) ;
extern int wait_for_key_construction(struct key *key , bool intr ) ;
extern int key_validate(struct key *key ) ;
extern key_ref_t key_create_or_update(key_ref_t keyring , char const   *type , char const   *description ,
                                      void const   *payload , size_t plen , key_perm_t perm ,
                                      unsigned long flags ) ;
extern int key_update(key_ref_t key , void const   *payload , size_t plen ) ;
extern int key_link(struct key *keyring , struct key *key ) ;
extern int key_unlink(struct key *keyring , struct key *key ) ;
extern struct key *keyring_alloc(char const   *description , uid_t uid , gid_t gid ,
                                 struct cred  const  *cred , unsigned long flags ,
                                 struct key *dest ) ;
extern int keyring_clear(struct key *keyring ) ;
extern key_ref_t keyring_search(key_ref_t keyring , struct key_type *type , char const   *description ) ;
extern int keyring_add_key(struct key *keyring , struct key *key ) ;
extern struct key *key_lookup(key_serial_t id ) ;
__inline static key_serial_t key_serial(struct key *key ) 
{ key_serial_t tmp ;

  {
  if (key) {
    {
    tmp = key->serial;
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern ctl_table key_sysctls[] ;
extern int install_thread_keyring_to_cred(struct cred *cred ) ;
extern void key_fsuid_changed(struct task_struct *tsk ) ;
extern void key_fsgid_changed(struct task_struct *tsk ) ;
extern void key_init(void) ;
__inline static struct group_info *get_group_info(struct group_info *gi ) 
{ 

  {
  {
  atomic_inc(& gi->usage);
  }
  return (gi);
}
}
extern struct group_info *groups_alloc(int  ) ;
extern struct group_info init_groups ;
extern void groups_free(struct group_info * ) ;
extern int set_current_groups(struct group_info * ) ;
extern int set_groups(struct cred * , struct group_info * ) ;
extern int groups_search(struct group_info  const  * , gid_t  ) ;
extern int in_group_p(gid_t  ) ;
extern int in_egroup_p(gid_t  ) ;
extern void __put_cred(struct cred * ) ;
extern int copy_creds(struct task_struct * , unsigned long  ) ;
extern struct cred *prepare_creds(void) ;
extern struct cred *prepare_exec_creds(void) ;
extern struct cred *prepare_usermodehelper_creds(void) ;
extern int commit_creds(struct cred * ) ;
extern void abort_creds(struct cred * ) ;
extern struct cred  const  *override_creds(struct cred  const  * ) ;
extern void revert_creds(struct cred  const  * ) ;
extern struct cred *prepare_kernel_cred(struct task_struct * ) ;
extern int change_create_files_as(struct cred * , struct inode * ) ;
extern int set_security_override(struct cred * , u32  ) ;
extern int set_security_override_from_ctx(struct cred * , char const   * ) ;
extern int set_create_files_as(struct cred * , struct inode * ) ;
extern void cred_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
__inline static struct cred *get_new_cred(struct cred *cred ) 
{ 

  {
  {
  atomic_inc(& cred->usage);
  }
  return (cred);
}
}
__inline static struct cred  const  *get_cred(struct cred  const  *cred ) 
{ struct cred *tmp ;

  {
  {
  tmp = get_new_cred((struct cred *)cred);
  }
  return ((struct cred  const  *)tmp);
}
}
__inline static void put_cred(struct cred  const  *_cred ) 
{ struct cred *cred ;
  long tmp ;
  int tmp___0 ;

  {
  {
  cred = (struct cred *)_cred;
  }
  {
  while (1) {
    while_190_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (cred->usage.counter <= (int volatile   )0))),
                           0L);
    }
    if (tmp) {
      {
      while (1) {
        while_191_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"),
                             "i" (207), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_192_continue: /* CIL Label */ ;
        }
        while_192_break: /* CIL Label */ ;
        }
        goto while_191_break;
      }
      while_191_break: /* CIL Label */ ;
      }
    }
    goto while_190_break;
  }
  while_190_break: /* CIL Label */ ;
  }
  {
  tmp___0 = atomic_dec_and_test(& cred->usage);
  }
  if (tmp___0) {
    {
    __put_cred(cred);
    }
  }
  return;
}
}
extern unsigned long avenrun[] ;
extern unsigned long total_forks ;
extern int nr_threads ;
extern unsigned long per_cpu__process_counts  __attribute__((__section__(".data.percpu"))) ;
extern int nr_processes(void) ;
extern unsigned long nr_running(void) ;
extern unsigned long nr_uninterruptible(void) ;
extern unsigned long nr_active(void) ;
extern unsigned long nr_iowait(void) ;
extern unsigned long get_parent_ip(unsigned long addr ) ;
__inline static void proc_sched_show_task(struct task_struct *p , struct seq_file *m ) 
{ 

  {
  return;
}
}
__inline static void print_cfs_rq(struct seq_file *m , int cpu , struct cfs_rq *cfs_rq ) 
{ 

  {
  return;
}
}
extern unsigned long long time_sync_thresh ;
extern rwlock_t tasklist_lock ;
extern spinlock_t mmlist_lock ;
extern void sched_init(void) ;
extern void sched_init_smp(void) ;
extern void ( __attribute__((__regparm__(0))) schedule_tail)(struct task_struct *prev ) ;
extern void init_idle(struct task_struct *idle , int cpu ) ;
extern void init_idle_bootup_task(struct task_struct *idle ) ;
extern int runqueue_is_locked(void) ;
extern void task_rq_unlock_wait(struct task_struct *p ) ;
extern cpumask_var_t nohz_cpu_mask ;
extern int select_nohz_load_balancer(int cpu ) ;
extern void show_state_filter(unsigned long state_filter ) ;
__inline static void show_state(void) 
{ 

  {
  {
  show_state_filter(0UL);
  }
  return;
}
}
extern void show_regs(struct pt_regs * ) ;
extern void show_stack(struct task_struct *task , unsigned long *sp ) ;
extern void io_schedule(void) ;
extern long io_schedule_timeout(long timeout ) ;
extern void trap_init(void) ;
extern void update_process_times(int user ) ;
extern void scheduler_tick(void) ;
extern void sched_show_task(struct task_struct *p ) ;
extern char __sched_text_start[] ;
extern char __sched_text_end[] ;
extern int in_sched_functions(unsigned long addr ) ;
extern long schedule_timeout(long timeout ) ;
extern long schedule_timeout_interruptible(long timeout ) ;
extern long schedule_timeout_killable(long timeout ) ;
extern long schedule_timeout_uninterruptible(long timeout ) ;
extern void ( __attribute__((__regparm__(0))) __schedule)(void) ;
extern void ( __attribute__((__regparm__(0))) schedule)(void) ;
extern int mutex_spin_on_owner(struct mutex *lock , struct thread_info *owner ) ;
extern int sysctl_max_map_count ;
__inline static size_t iov_length(struct iovec  const  *iov , unsigned long nr_segs ) 
{ unsigned long seg ;
  size_t ret ;

  {
  {
  ret = (size_t )0;
  seg = 0UL;
  }
  {
  while (1) {
    while_193_continue: /* CIL Label */ ;
    if (! (seg < nr_segs)) {
      goto while_193_break;
    }
    {
    ret += (size_t )(iov + seg)->iov_len;
    seg ++;
    }
  }
  while_193_break: /* CIL Label */ ;
  }
  return (ret);
}
}
extern unsigned long iov_shorten(struct iovec *iov , unsigned long nr_segs , size_t to ) ;
extern unsigned int aio_max_size ;
extern ssize_t wait_on_sync_kiocb(struct kiocb *iocb ) ;
extern int aio_put_req(struct kiocb *iocb ) ;
extern void kick_iocb(struct kiocb *iocb ) ;
extern int aio_complete(struct kiocb *iocb , long res , long res2 ) ;
extern void exit_aio(struct mm_struct *mm ) ;
__inline static struct kiocb *list_kiocb(struct list_head *h ) 
{ struct list_head  const  *__mptr ;

  {
  {
  __mptr = (struct list_head  const  *)h;
  }
  return ((struct kiocb *)((char *)__mptr - (unsigned int )(& ((struct kiocb *)0)->ki_list)));
}
}
extern unsigned long aio_nr ;
extern unsigned long aio_max_nr ;
extern unsigned long arch_get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                            unsigned long  , unsigned long  ) ;
extern unsigned long arch_get_unmapped_area_topdown(struct file *filp , unsigned long addr ,
                                                    unsigned long len , unsigned long pgoff ,
                                                    unsigned long flags ) ;
extern void arch_unmap_area(struct mm_struct * , unsigned long  ) ;
extern void arch_unmap_area_topdown(struct mm_struct * , unsigned long  ) ;
__inline static unsigned long get_mm_hiwater_rss(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  long tmp ;
  long tmp___0 ;
  unsigned long _max2 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
  _max1 = mm->hiwater_rss;
  tmp___1 = atomic_long_read(& mm->_file_rss);
  tmp___2 = atomic_long_read(& mm->_anon_rss);
  _max2 = (unsigned long )tmp___1 + (unsigned long )tmp___2;
  }
  if (_max1 > _max2) {
    {
    tmp___3 = _max1;
    }
  } else {
    {
    tmp___3 = _max2;
    }
  }
  return (tmp___3);
}
}
__inline static unsigned long get_mm_hiwater_vm(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp ;

  {
  {
  _max1 = mm->hiwater_vm;
  _max2 = mm->total_vm;
  }
  if (_max1 > _max2) {
    {
    tmp = _max1;
    }
  } else {
    {
    tmp = _max2;
    }
  }
  return (tmp);
}
}
extern void set_dumpable(struct mm_struct *mm , int value ) ;
extern int get_dumpable(struct mm_struct *mm ) ;
__inline static int signal_group_exit(struct signal_struct  const  *sig ) 
{ int tmp ;

  {
  if (sig->flags & 8U) {
    {
    tmp = 1;
    }
  } else {
    if ((unsigned long )sig->group_exit_task != (unsigned long )((void *)0)) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
extern int uids_sysfs_init(void) ;
extern struct user_struct *find_user(uid_t  ) ;
extern struct user_struct root_user ;
__inline static int sched_info_on(void) 
{ 

  {
  return (1);
}
}
extern int sched_mc_power_savings ;
extern int sched_smt_power_savings ;
__inline static int sd_balance_for_mc_power(void) 
{ 

  {
  if (sched_smt_power_savings) {
    return (256);
  }
  return (0);
}
}
__inline static int sd_balance_for_package_power(void) 
{ 

  {
  if (sched_mc_power_savings | sched_smt_power_savings) {
    return (256);
  }
  return (0);
}
}
__inline static int sd_power_saving_flags(void) 
{ 

  {
  if (sched_mc_power_savings | sched_smt_power_savings) {
    return (2);
  }
  return (0);
}
}
__inline static struct cpumask *sched_group_cpus(struct sched_group *sg ) 
{ int tmp ;

  {
  return ((struct cpumask *)(sg->cpumask));
}
}
__inline static struct cpumask *sched_domain_span(struct sched_domain *sd ) 
{ int tmp ;

  {
  return ((struct cpumask *)(sd->span));
}
}
extern void partition_sched_domains(int ndoms_new , struct cpumask *doms_new , struct sched_domain_attr *dattr_new ) ;
__inline static int test_sd_parent(struct sched_domain *sd , int flag ) 
{ 

  {
  if (sd->parent) {
    if ((sd->parent)->flags & flag) {
      return (1);
    }
  }
  return (0);
}
}
__inline static int rt_prio(int prio ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! (prio < 100))), 0L);
  }
  if (tmp) {
    return (1);
  }
  return (0);
}
}
__inline static int rt_task(struct task_struct *p ) 
{ int tmp ;

  {
  {
  tmp = rt_prio(p->prio);
  }
  return (tmp);
}
}
__inline static struct pid *task_pid(struct task_struct *task ) 
{ 

  {
  return (task->pids[0].pid);
}
}
__inline static struct pid *task_tgid(struct task_struct *task ) 
{ 

  {
  return ((task->group_leader)->pids[0].pid);
}
}
__inline static struct pid *task_pgrp(struct task_struct *task ) 
{ 

  {
  return ((task->group_leader)->pids[1].pid);
}
}
__inline static struct pid *task_session(struct task_struct *task ) 
{ 

  {
  return ((task->group_leader)->pids[2].pid);
}
}
extern pid_t __task_pid_nr_ns(struct task_struct *task , enum pid_type type , struct pid_namespace *ns ) ;
__inline static pid_t task_pid_nr(struct task_struct *tsk ) 
{ 

  {
  return (tsk->pid);
}
}
__inline static pid_t task_pid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, ns);
  }
  return (tmp);
}
}
__inline static pid_t task_pid_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, (struct pid_namespace *)((void *)0));
  }
  return (tmp);
}
}
__inline static pid_t task_tgid_nr(struct task_struct *tsk ) 
{ 

  {
  return (tsk->tgid);
}
}
extern pid_t task_tgid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) ;
__inline static pid_t task_tgid_vnr(struct task_struct *tsk ) 
{ struct pid *tmp ;
  pid_t tmp___0 ;

  {
  {
  tmp = task_tgid(tsk);
  tmp___0 = pid_vnr(tmp);
  }
  return (tmp___0);
}
}
__inline static pid_t task_pgrp_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, ns);
  }
  return (tmp);
}
}
__inline static pid_t task_pgrp_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, (struct pid_namespace *)((void *)0));
  }
  return (tmp);
}
}
__inline static pid_t task_session_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, ns);
  }
  return (tmp);
}
}
__inline static pid_t task_session_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, (struct pid_namespace *)((void *)0));
  }
  return (tmp);
}
}
__inline static pid_t task_pgrp_nr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = task_pgrp_nr_ns(tsk, & init_pid_ns);
  }
  return (tmp);
}
}
__inline static int pid_alive(struct task_struct *p ) 
{ 

  {
  return ((unsigned long )p->pids[0].pid != (unsigned long )((void *)0));
}
}
__inline static int is_global_init(struct task_struct *tsk ) 
{ 

  {
  return (tsk->pid == 1);
}
}
extern int is_container_init(struct task_struct *tsk ) ;
extern struct pid *cad_pid ;
extern void free_task(struct task_struct *tsk ) ;
extern void __put_task_struct(struct task_struct *t ) ;
__inline static void put_task_struct(struct task_struct *t ) 
{ int tmp ;

  {
  {
  tmp = atomic_dec_and_test(& t->usage);
  }
  if (tmp) {
    {
    __put_task_struct(t);
    }
  }
  return;
}
}
extern cputime_t task_utime(struct task_struct *p ) ;
extern cputime_t task_stime(struct task_struct *p ) ;
extern cputime_t task_gtime(struct task_struct *p ) ;
extern int set_cpus_allowed_ptr(struct task_struct *p , struct cpumask  const  *new_mask ) ;
__inline static int set_cpus_allowed(struct task_struct *p , cpumask_t new_mask ) 
{ int tmp ;

  {
  {
  tmp = set_cpus_allowed_ptr(p, (struct cpumask  const  *)(& new_mask));
  }
  return (tmp);
}
}
extern int sched_clock_stable ;
extern unsigned long long sched_clock(void) ;
extern void sched_clock_init(void) ;
extern u64 sched_clock_cpu(int cpu ) ;
extern void sched_clock_tick(void) ;
extern void sched_clock_idle_sleep_event(void) ;
extern void sched_clock_idle_wakeup_event(u64 delta_ns ) ;
extern unsigned long long cpu_clock(int cpu ) ;
extern unsigned long long task_sched_runtime(struct task_struct *task ) ;
extern unsigned long long thread_group_sched_runtime(struct task_struct *task ) ;
extern void sched_exec(void) ;
extern void idle_task_exit(void) ;
extern void sched_idle_next(void) ;
extern void wake_up_idle_cpu(int cpu ) ;
extern unsigned int sysctl_sched_latency ;
extern unsigned int sysctl_sched_min_granularity ;
extern unsigned int sysctl_sched_wakeup_granularity ;
extern unsigned int sysctl_sched_shares_ratelimit ;
extern unsigned int sysctl_sched_shares_thresh ;
extern unsigned int sysctl_sched_rt_period ;
extern int sysctl_sched_rt_runtime ;
extern int sched_rt_handler(struct ctl_table *table , int write , struct file *filp ,
                            void *buffer , size_t *lenp , loff_t *ppos ) ;
extern unsigned int sysctl_sched_compat_yield ;
extern int rt_mutex_getprio(struct task_struct *p ) ;
extern void rt_mutex_setprio(struct task_struct *p , int prio ) ;
extern void rt_mutex_adjust_pi(struct task_struct *p ) ;
extern void set_user_nice(struct task_struct *p , long nice ) ;
extern int task_prio(struct task_struct  const  *p ) ;
extern int task_nice(struct task_struct  const  *p ) ;
extern int can_nice(struct task_struct  const  *p , int nice ) ;
extern int task_curr(struct task_struct  const  *p ) ;
extern int idle_cpu(int cpu ) ;
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param * ) ;
extern int sched_setscheduler_nocheck(struct task_struct * , int  , struct sched_param * ) ;
extern struct task_struct *idle_task(int cpu ) ;
extern struct task_struct *curr_task(int cpu ) ;
extern void set_curr_task(int cpu , struct task_struct *p ) ;
extern void yield(void) ;
extern struct exec_domain default_exec_domain ;
__inline static int kstack_end(void *addr ) 
{ 

  {
  return (! ((((unsigned long )addr + sizeof(void *)) - 1UL) & (((1UL << 12) << 1) - sizeof(void *))));
}
}
extern union thread_union init_thread_union ;
extern struct task_struct init_task ;
extern struct mm_struct init_mm ;
extern struct task_struct *find_task_by_pid_type_ns(int type , int pid , struct pid_namespace *ns ) ;
extern struct task_struct *find_task_by_vpid(pid_t nr ) ;
extern struct task_struct *find_task_by_pid_ns(pid_t nr , struct pid_namespace *ns ) ;
extern void __set_special_pids(struct pid *pid ) ;
extern struct user_struct *alloc_uid(struct user_namespace * , uid_t  ) ;
__inline static struct user_struct *get_uid(struct user_struct *u ) 
{ 

  {
  {
  atomic_inc(& u->__count);
  }
  return (u);
}
}
extern void free_uid(struct user_struct * ) ;
extern void release_uids(struct user_namespace *ns ) ;
extern void do_timer(unsigned long ticks ) ;
extern int wake_up_state(struct task_struct *tsk , unsigned int state ) ;
extern int wake_up_process(struct task_struct *tsk ) ;
extern void wake_up_new_task(struct task_struct *tsk , unsigned long clone_flags ) ;
extern void kick_process(struct task_struct *tsk ) ;
extern void sched_fork(struct task_struct *p , int clone_flags ) ;
extern void sched_dead(struct task_struct *p ) ;
extern void proc_caches_init(void) ;
extern void flush_signals(struct task_struct * ) ;
extern void ignore_signals(struct task_struct * ) ;
extern void flush_signal_handlers(struct task_struct * , int force_default ) ;
extern int dequeue_signal(struct task_struct *tsk , sigset_t *mask , siginfo_t *info ) ;
__inline static int dequeue_signal_lock(struct task_struct *tsk , sigset_t *mask ,
                                        siginfo_t *info ) 
{ unsigned long flags ;
  int ret ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_194_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& (tsk->sighand)->siglock);
    }
    goto while_194_break;
  }
  while_194_break: /* CIL Label */ ;
  }
  {
  ret = dequeue_signal(tsk, mask, info);
  }
  {
  while (1) {
    while_195_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, flags);
    }
    goto while_195_break;
  }
  while_195_break: /* CIL Label */ ;
  }
  return (ret);
}
}
extern void block_all_signals(int (*notifier)(void *priv ) , void *priv , sigset_t *mask ) ;
extern void unblock_all_signals(void) ;
extern void release_task(struct task_struct *p ) ;
extern int send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int force_sigsegv(int  , struct task_struct * ) ;
extern int force_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int __kill_pgrp_info(int sig , struct siginfo *info , struct pid *pgrp ) ;
extern int kill_pid_info(int sig , struct siginfo *info , struct pid *pid ) ;
extern int kill_pid_info_as_uid(int  , struct siginfo * , struct pid * , uid_t  ,
                                uid_t  , u32  ) ;
extern int kill_pgrp(struct pid *pid , int sig , int priv ) ;
extern int kill_pid(struct pid *pid , int sig , int priv ) ;
extern int kill_proc_info(int  , struct siginfo * , pid_t  ) ;
extern int do_notify_parent(struct task_struct * , int  ) ;
extern void force_sig(int  , struct task_struct * ) ;
extern void force_sig_specific(int  , struct task_struct * ) ;
extern int send_sig(int  , struct task_struct * , int  ) ;
extern void zap_other_threads(struct task_struct *p ) ;
extern struct sigqueue *sigqueue_alloc(void) ;
extern void sigqueue_free(struct sigqueue * ) ;
extern int send_sigqueue(struct sigqueue * , struct task_struct * , int group ) ;
extern int do_sigaction(int  , struct k_sigaction * , struct k_sigaction * ) ;
extern int do_sigaltstack(stack_t const   * , stack_t * , unsigned long  ) ;
__inline static int kill_cad_pid(int sig , int priv ) 
{ int tmp ;

  {
  {
  tmp = kill_pid(cad_pid, sig, priv);
  }
  return (tmp);
}
}
__inline static int is_si_special(struct siginfo  const  *info ) 
{ 

  {
  return ((unsigned long )info <= (unsigned long )((struct siginfo *)2));
}
}
__inline static int on_sig_stack(unsigned long sp ) 
{ struct task_struct *tmp ;
  struct task_struct *tmp___0 ;

  {
  {
  tmp = get_current();
  tmp___0 = get_current();
  }
  return (sp - tmp->sas_ss_sp < (unsigned long )tmp___0->sas_ss_size);
}
}
__inline static int sas_ss_flags(unsigned long sp ) 
{ struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;

  {
  {
  tmp___4 = get_current();
  }
  if (tmp___4->sas_ss_size == 0U) {
    {
    tmp___3 = 2;
    }
  } else {
    {
    tmp___2 = on_sig_stack(sp);
    }
    if (tmp___2) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
    {
    tmp___3 = tmp___1;
    }
  }
  return (tmp___3);
}
}
extern struct mm_struct *mm_alloc(void) ;
extern void __mmdrop(struct mm_struct * ) ;
__inline static void mmdrop(struct mm_struct *mm ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = atomic_dec_and_test(& mm->mm_count);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    {
    __mmdrop(mm);
    }
  }
  return;
}
}
extern void mmput(struct mm_struct * ) ;
extern struct mm_struct *get_task_mm(struct task_struct *task ) ;
extern void mm_release(struct task_struct * , struct mm_struct * ) ;
extern struct mm_struct *dup_mm(struct task_struct *tsk ) ;
extern int copy_thread(unsigned long  , unsigned long  , unsigned long  , struct task_struct * ,
                       struct pt_regs * ) ;
extern void flush_thread(void) ;
extern void exit_thread(void) ;
extern void exit_files(struct task_struct * ) ;
extern void __cleanup_signal(struct signal_struct * ) ;
extern void __cleanup_sighand(struct sighand_struct * ) ;
extern void exit_itimers(struct signal_struct * ) ;
extern void flush_itimer_signals(void) ;
extern void do_group_exit(int  ) ;
extern void daemonize(char const   *  , ...) ;
extern int allow_signal(int  ) ;
extern int disallow_signal(int  ) ;
extern int do_execve(char * , char ** , char ** , struct pt_regs * ) ;
extern long do_fork(unsigned long  , unsigned long  , struct pt_regs * , unsigned long  ,
                    int * , int * ) ;
extern struct task_struct *fork_idle(int  ) ;
extern void set_task_comm(struct task_struct *tsk , char *from ) ;
extern char *get_task_comm(char *to , struct task_struct *tsk ) ;
extern unsigned long wait_task_inactive(struct task_struct * , long match_state ) ;
extern bool is_single_threaded(struct task_struct * ) ;
__inline static int has_group_leader_pid(struct task_struct *p ) 
{ 

  {
  return (p->pid == p->tgid);
}
}
__inline static int same_thread_group(struct task_struct *p1 , struct task_struct *p2 ) 
{ 

  {
  return (p1->tgid == p2->tgid);
}
}
__inline static struct task_struct *next_thread(struct task_struct  const  *p ) 
{ struct list_head  const  *__mptr ;
  struct list_head *_________p1 ;

  {
  {
  _________p1 = (struct list_head *)*((struct list_head * const volatile  *)(& p->thread_group.next));
  }
  {
  while (1) {
    while_196_continue: /* CIL Label */ ;
    goto while_196_break;
  }
  while_196_break: /* CIL Label */ ;
  }
  {
  __mptr = (struct list_head  const  *)_________p1;
  }
  return ((struct task_struct *)((char *)__mptr - (unsigned int )(& ((struct task_struct *)0)->thread_group)));
}
}
__inline static int thread_group_empty(struct task_struct *p ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)(& p->thread_group));
  }
  return (tmp);
}
}
__inline static int task_detached(struct task_struct *p ) 
{ 

  {
  return (p->exit_signal == -1);
}
}
__inline static void task_lock(struct task_struct *p ) 
{ 

  {
  {
  _spin_lock(& p->alloc_lock);
  }
  return;
}
}
__inline static void task_unlock(struct task_struct *p ) 
{ 

  {
  {
  while (1) {
    while_197_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& p->alloc_lock.raw_lock);
    }
    goto while_197_break;
  }
  while_197_break: /* CIL Label */ ;
  }
  return;
}
}
extern struct sighand_struct *lock_task_sighand(struct task_struct *tsk , unsigned long *flags ) ;
__inline static void unlock_task_sighand(struct task_struct *tsk , unsigned long *flags ) 
{ unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
  while (1) {
    while_198_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, *flags);
    }
    goto while_198_break;
  }
  while_198_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void setup_thread_stack(struct task_struct *p , struct task_struct *org ) 
{ 

  {
  {
  *((struct thread_info *)p->stack) = *((struct thread_info *)org->stack);
  ((struct thread_info *)p->stack)->task = p;
  }
  return;
}
}
__inline static unsigned long *end_of_stack(struct task_struct *p ) 
{ 

  {
  return ((unsigned long *)((struct thread_info *)p->stack + 1));
}
}
__inline static int object_is_on_stack(void *obj ) 
{ void *stack ;
  struct task_struct *tmp ;
  int tmp___0 ;

  {
  {
  tmp = get_current();
  stack = tmp->stack;
  }
  if ((unsigned long )obj >= (unsigned long )stack) {
    if ((unsigned long )obj < (unsigned long )(stack + ((1UL << 12) << 1))) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
extern void thread_info_cache_init(void) ;
__inline static unsigned long stack_not_used(struct task_struct *p ) 
{ unsigned long *n ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;

  {
  {
  tmp = end_of_stack(p);
  n = tmp;
  }
  {
  while (1) {
    while_199_continue: /* CIL Label */ ;
    {
    n ++;
    }
    if (! (! *n)) {
      goto while_199_break;
    }
  }
  while_199_break: /* CIL Label */ ;
  }
  {
  tmp___0 = end_of_stack(p);
  }
  return ((unsigned long )n - (unsigned long )tmp___0);
}
}
__inline static void set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
  set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return;
}
}
__inline static void clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
  clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return;
}
}
__inline static int test_and_set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static int test_and_clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static void set_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
  set_tsk_thread_flag(tsk, 3);
  }
  return;
}
}
__inline static void clear_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
  clear_tsk_thread_flag(tsk, 3);
  }
  return;
}
}
__inline static int test_tsk_need_resched(struct task_struct *tsk ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = test_tsk_thread_flag(tsk, 3);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  return ((int )tmp___1);
}
}
__inline static int signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = test_tsk_thread_flag(p, 2);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  return ((int )tmp___1);
}
}
extern int __fatal_signal_pending(struct task_struct *p ) ;
__inline static int fatal_signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = signal_pending(p);
  }
  if (tmp) {
    {
    tmp___0 = __fatal_signal_pending(p);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
__inline static int signal_pending_state(long state , struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! (state & 129L)) {
    return (0);
  }
  {
  tmp = signal_pending(p);
  }
  if (! tmp) {
    return (0);
  }
  if (state & 1L) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___0 = __fatal_signal_pending(p);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  }
  return (tmp___1);
}
}
__inline static int need_resched(void) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = current_thread_info();
  tmp___0 = test_ti_thread_flag(tmp, 3);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  return ((int )tmp___2);
}
}
__inline static int cond_resched(void) 
{ int tmp ;

  {
  {
  tmp = _cond_resched();
  }
  return (tmp);
}
}
extern int cond_resched_lock(spinlock_t *lock ) ;
extern int cond_resched_softirq(void) ;
__inline static int spin_needbreak(spinlock_t *lock ) 
{ 

  {
  return (0);
}
}
extern void thread_group_cputime(struct task_struct *tsk , struct task_cputime *times ) ;
extern void thread_group_cputimer(struct task_struct *tsk , struct task_cputime *times ) ;
__inline static void thread_group_cputime_init(struct signal_struct *sig ) 
{ struct task_cputime __constr_expr_0 ;
  spinlock_t __constr_expr_1 ;

  {
  {
  __constr_expr_0.utime = 0UL;
  __constr_expr_0.stime = 0UL;
  __constr_expr_0.sum_exec_runtime = 0ULL;
  sig->cputimer.cputime = __constr_expr_0;
  }
  {
  while (1) {
    while_200_continue: /* CIL Label */ ;
    {
    __constr_expr_1.raw_lock.slock = 0U;
    sig->cputimer.lock = __constr_expr_1;
    }
    goto while_200_break;
  }
  while_200_break: /* CIL Label */ ;
  }
  {
  sig->cputimer.running = 0;
  }
  return;
}
}
__inline static void thread_group_cputime_free(struct signal_struct *sig ) 
{ 

  {
  return;
}
}
extern void recalc_sigpending_and_wake(struct task_struct *t ) ;
extern void recalc_sigpending(void) ;
extern void signal_wake_up(struct task_struct *t , int resume_stopped ) ;
__inline static unsigned int task_cpu(struct task_struct  const  *p ) 
{ 

  {
  return (((struct thread_info *)p->stack)->cpu);
}
}
extern void set_task_cpu(struct task_struct *p , unsigned int cpu ) ;
extern void arch_pick_mmap_layout(struct mm_struct *mm ) ;
extern void __trace_special(void *__tr , void *__data , unsigned long arg1 , unsigned long arg2 ,
                            unsigned long arg3 ) ;
extern long sched_setaffinity(pid_t pid , struct cpumask  const  *new_mask ) ;
extern long sched_getaffinity(pid_t pid , struct cpumask *mask ) ;
extern void normalize_rt_tasks(void) ;
extern struct task_group init_task_group ;
extern struct task_group *sched_create_group(struct task_group *parent ) ;
extern void sched_destroy_group(struct task_group *tg ) ;
extern void sched_move_task(struct task_struct *tsk ) ;
extern int sched_group_set_shares(struct task_group *tg , unsigned long shares ) ;
extern unsigned long sched_group_shares(struct task_group *tg ) ;
extern int task_can_switch_user(struct user_struct *up , struct task_struct *tsk ) ;
__inline static void add_rchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
  tsk->ioac.rchar += (u64 )amt;
  }
  return;
}
}
__inline static void add_wchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
  tsk->ioac.wchar += (u64 )amt;
  }
  return;
}
}
__inline static void inc_syscr(struct task_struct *tsk ) 
{ 

  {
  {
  (tsk->ioac.syscr) ++;
  }
  return;
}
}
__inline static void inc_syscw(struct task_struct *tsk ) 
{ 

  {
  {
  (tsk->ioac.syscw) ++;
  }
  return;
}
}
__inline static void mm_update_next_owner(struct mm_struct *mm ) 
{ 

  {
  return;
}
}
__inline static void mm_init_owner(struct mm_struct *mm , struct task_struct *p ) 
{ 

  {
  return;
}
}
extern int __reacquire_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void __release_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static int reacquire_kernel_lock(struct task_struct *task ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
  tmp___0 = __builtin_expect((long )(! (! (task->lock_depth >= 0))), 0L);
  }
  if (tmp___0) {
    {
    tmp = __reacquire_kernel_lock();
    }
    return (tmp);
  }
  return (0);
}
}
extern void lock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void unlock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static void cycle_kernel_lock(void) 
{ 

  {
  {
  lock_kernel();
  unlock_kernel();
  }
  return;
}
}
__inline static int irq_canonicalize(int irq ) 
{ int tmp ;

  {
  if (irq == 2) {
    {
    tmp = 9;
    }
  } else {
    {
    tmp = irq;
    }
  }
  return (tmp);
}
}
extern void fixup_irqs(void) ;
extern void (*generic_interrupt_extension)(void) ;
extern void init_IRQ(void) ;
extern void native_init_IRQ(void) ;
extern bool handle_irq(unsigned int irq , struct pt_regs *regs ) ;
extern unsigned int do_IRQ(struct pt_regs *regs ) ;
extern int vector_used_by_percpu_irq(unsigned int vector ) ;
extern struct pt_regs *per_cpu__irq_regs  __attribute__((__section__(".data.percpu"))) ;
__inline static struct pt_regs *get_irq_regs(void) 
{ struct pt_regs *ret__ ;

  {
  if ((int )sizeof(per_cpu__irq_regs) == 1) {
    goto switch_201_1;
  } else {
    if ((int )sizeof(per_cpu__irq_regs) == 2) {
      goto switch_201_2;
    } else {
      if ((int )sizeof(per_cpu__irq_regs) == 4) {
        goto switch_201_4;
      } else {
        if ((int )sizeof(per_cpu__irq_regs) == 8) {
          goto switch_201_8;
        } else {
          {
          goto switch_201_default;
          if (0) {
            switch_201_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_201_break;
            switch_201_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_201_break;
            switch_201_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_201_break;
            switch_201_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_201_break;
            switch_201_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_201_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  return (ret__);
}
}
__inline static struct pt_regs *set_irq_regs(struct pt_regs *new_regs ) 
{ struct pt_regs *old_regs ;
  T__ tmp__ ;

  {
  {
  old_regs = get_irq_regs();
  }
  {
  while (1) {
    while_202_continue: /* CIL Label */ ;
    if ((int )sizeof(per_cpu__irq_regs) == 1) {
      goto switch_203_1;
    } else {
      if ((int )sizeof(per_cpu__irq_regs) == 2) {
        goto switch_203_2;
      } else {
        if ((int )sizeof(per_cpu__irq_regs) == 4) {
          goto switch_203_4;
        } else {
          if ((int )sizeof(per_cpu__irq_regs) == 8) {
            goto switch_203_8;
          } else {
            {
            goto switch_203_default;
            if (0) {
              switch_203_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "qi" (new_regs));
              }
              goto switch_203_break;
              switch_203_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_203_break;
              switch_203_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_203_break;
              switch_203_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "re" (new_regs));
              }
              goto switch_203_break;
              switch_203_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_203_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_202_break;
  }
  while_202_break: /* CIL Label */ ;
  }
  return (old_regs);
}
}
extern void arch_init_copy_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ,
                                     int cpu ) ;
extern void arch_free_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ) ;
extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc , int cpu ) ;
extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq , int cpu ) ;
__inline static struct irq_desc *irq_remap_to_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
  return (desc);
}
}
extern void create_prof_cpu_mask(struct proc_dir_entry *de ) ;
extern int create_proc_profile(void) ;
extern int prof_on  __attribute__((__section__(".data.read_mostly"))) ;
extern int profile_init(void) ;
extern int profile_setup(char *str ) ;
extern void profile_tick(int type ) ;
extern void profile_hits(int type , void *ip , unsigned int nr_hits ) ;
__inline static void profile_hit(int type , void *ip ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! (prof_on == type))), 0L);
  }
  if (tmp) {
    {
    profile_hits(type, ip, 1U);
    }
  }
  return;
}
}
extern void profile_task_exit(struct task_struct *task ) ;
extern int profile_handoff_task(struct task_struct *task ) ;
extern void profile_munmap(unsigned long addr ) ;
extern int task_handoff_register(struct notifier_block *n ) ;
extern int task_handoff_unregister(struct notifier_block *n ) ;
extern int profile_event_register(enum profile_type  , struct notifier_block *n ) ;
extern int profile_event_unregister(enum profile_type  , struct notifier_block *n ) ;
extern int register_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern void unregister_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern char _text[] ;
extern char _stext[] ;
extern char _etext[] ;
extern char _data[] ;
extern char _sdata[] ;
extern char _edata[] ;
extern char __bss_start[] ;
extern char __bss_stop[] ;
extern char __init_begin[] ;
extern char __init_end[] ;
extern char _sinittext[] ;
extern char _einittext[] ;
extern char _end[] ;
extern char __per_cpu_load[] ;
extern char __per_cpu_start[] ;
extern char __per_cpu_end[] ;
extern char __kprobes_text_start[] ;
extern char __kprobes_text_end[] ;
extern char __initdata_begin[] ;
extern char __initdata_end[] ;
extern char __start_rodata[] ;
extern char __end_rodata[] ;
extern char __brk_base[] ;
extern char __brk_limit[] ;
extern void apic_timer_interrupt(void) ;
extern void generic_interrupt(void) ;
extern void error_interrupt(void) ;
extern void spurious_interrupt(void) ;
extern void thermal_interrupt(void) ;
extern void reschedule_interrupt(void) ;
extern void invalidate_interrupt(void) ;
extern void invalidate_interrupt0(void) ;
extern void invalidate_interrupt1(void) ;
extern void invalidate_interrupt2(void) ;
extern void invalidate_interrupt3(void) ;
extern void invalidate_interrupt4(void) ;
extern void invalidate_interrupt5(void) ;
extern void invalidate_interrupt6(void) ;
extern void invalidate_interrupt7(void) ;
extern void irq_move_cleanup_interrupt(void) ;
extern void threshold_interrupt(void) ;
extern void call_function_interrupt(void) ;
extern void call_function_single_interrupt(void) ;
extern void disable_8259A_irq(unsigned int irq ) ;
extern void enable_8259A_irq(unsigned int irq ) ;
extern int i8259A_irq_pending(unsigned int irq ) ;
extern void make_8259A_irq(unsigned int irq ) ;
extern void init_8259A(int aeoi ) ;
extern unsigned long io_apic_irqs ;
extern void init_VISWS_APIC_irqs(void) ;
extern void setup_IO_APIC(void) ;
extern void disable_IO_APIC(void) ;
extern int IO_APIC_get_PCI_irq_vector(int bus , int slot , int fn ) ;
extern void setup_ioapic_dest(void) ;
extern void enable_IO_APIC(void) ;
extern atomic_t irq_err_count ;
extern atomic_t irq_mis_count ;
extern void eisa_set_level_irq(unsigned int irq ) ;
extern void smp_apic_timer_interrupt(struct pt_regs * ) ;
extern void smp_spurious_interrupt(struct pt_regs * ) ;
extern void smp_error_interrupt(struct pt_regs * ) ;
extern void smp_reschedule_interrupt(struct pt_regs * ) ;
extern void smp_call_function_interrupt(struct pt_regs * ) ;
extern void smp_call_function_single_interrupt(struct pt_regs * ) ;
extern void smp_invalidate_interrupt(struct pt_regs * ) ;
extern void (*interrupt[224])(void)  __attribute__((__section__(".init.rodata"))) ;
extern vector_irq_t per_cpu__vector_irq  __attribute__((__section__(".data.percpu"))) ;
extern void lock_vector_lock(void) ;
extern void unlock_vector_lock(void) ;
extern void __setup_vector_irq(int cpu ) ;
extern int setup_irq(unsigned int irq , struct irqaction *new ) ;
extern void remove_irq(unsigned int irq , struct irqaction *act ) ;
extern void move_native_irq(int irq ) ;
extern void move_masked_irq(int irq ) ;
extern int no_irq_affinity ;
__inline static int irq_balancing_disabled(unsigned int irq ) 
{ struct irq_desc *desc ;

  {
  {
  desc = irq_to_desc(irq);
  }
  return ((int )(desc->status & 4194304U));
}
}
extern irqreturn_t handle_IRQ_event(unsigned int irq , struct irqaction *action ) ;
extern void handle_level_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_fasteoi_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_edge_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_simple_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_percpu_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_bad_irq(unsigned int irq , struct irq_desc *desc ) ;
__inline static void generic_handle_irq_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
  {
  (*(desc->handle_irq))(irq, desc);
  }
  return;
}
}
__inline static void generic_handle_irq(unsigned int irq ) 
{ struct irq_desc *tmp ;

  {
  {
  tmp = irq_to_desc(irq);
  generic_handle_irq_desc(irq, tmp);
  }
  return;
}
}
extern void note_interrupt(unsigned int irq , struct irq_desc *desc , irqreturn_t action_ret ) ;
extern void check_irq_resend(struct irq_desc *desc , unsigned int irq ) ;
extern int noirqdebug_setup(char *str ) ;
extern int can_request_irq(unsigned int irq , unsigned long irqflags ) ;
extern struct irq_chip no_irq_chip ;
extern struct irq_chip dummy_irq_chip ;
extern void set_irq_chip_and_handler(unsigned int irq , struct irq_chip *chip , void (*handle)(unsigned int irq ,
                                                                                               struct irq_desc *desc ) ) ;
extern void set_irq_chip_and_handler_name(unsigned int irq , struct irq_chip *chip ,
                                          void (*handle)(unsigned int irq , struct irq_desc *desc ) ,
                                          char const   *name ) ;
extern void __set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                struct irq_desc *desc ) ,
                              int is_chained , char const   *name ) ;
__inline static void __set_irq_handler_unlocked(int irq , void (*handler)(unsigned int irq ,
                                                                          struct irq_desc *desc ) ) 
{ struct irq_desc *desc ;

  {
  {
  desc = irq_to_desc((unsigned int )irq);
  desc->handle_irq = handler;
  }
  return;
}
}
__inline static void set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                       struct irq_desc *desc ) ) 
{ 

  {
  {
  __set_irq_handler(irq, handle, 0, (char const   *)((void *)0));
  }
  return;
}
}
__inline static void set_irq_chained_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                               struct irq_desc *desc ) ) 
{ 

  {
  {
  __set_irq_handler(irq, handle, 1, (char const   *)((void *)0));
  }
  return;
}
}
extern void set_irq_noprobe(unsigned int irq ) ;
extern void set_irq_probe(unsigned int irq ) ;
extern unsigned int create_irq_nr(unsigned int irq_want ) ;
extern int create_irq(void) ;
extern void destroy_irq(unsigned int irq ) ;
__inline static int irq_has_action(unsigned int irq ) 
{ struct irq_desc *desc ;
  struct irq_desc *tmp ;

  {
  {
  tmp = irq_to_desc(irq);
  desc = tmp;
  }
  return ((unsigned long )desc->action != (unsigned long )((void *)0));
}
}
extern void dynamic_irq_init(unsigned int irq ) ;
extern void dynamic_irq_cleanup(unsigned int irq ) ;
extern int set_irq_chip(unsigned int irq , struct irq_chip *chip ) ;
extern int set_irq_data(unsigned int irq , void *data ) ;
extern int set_irq_chip_data(unsigned int irq , void *data ) ;
extern int set_irq_type(unsigned int irq , unsigned int type ) ;
extern int set_irq_msi(unsigned int irq , struct msi_desc *entry ) ;
__inline static bool init_alloc_desc_masks(struct irq_desc *desc , int cpu , bool boot ) 
{ int node ;
  bool tmp ;
  bool tmp___0 ;

  {
  if (boot) {
    {
    alloc_bootmem_cpumask_var(& desc->affinity);
    cpumask_setall(desc->affinity);
    alloc_bootmem_cpumask_var(& desc->pending_mask);
    cpumask_clear(desc->pending_mask);
    }
    return ((_Bool)1);
  }
  {
  node = 0;
  tmp = alloc_cpumask_var_node(& desc->affinity, 32U, node);
  }
  if (! tmp) {
    return ((_Bool)0);
  }
  {
  cpumask_setall(desc->affinity);
  tmp___0 = alloc_cpumask_var_node(& desc->pending_mask, 32U, node);
  }
  if (! tmp___0) {
    {
    free_cpumask_var((struct cpumask *)(desc->affinity));
    }
    return ((_Bool)0);
  }
  {
  cpumask_clear(desc->pending_mask);
  }
  return ((_Bool)1);
}
}
__inline static void init_copy_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
  return;
}
}
__inline static void free_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
  {
  free_cpumask_var((struct cpumask *)(old_desc->affinity));
  free_cpumask_var((struct cpumask *)(old_desc->pending_mask));
  }
  return;
}
}
extern irq_cpustat_t per_cpu__irq_stat  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
extern void ack_bad_irq(unsigned int irq ) ;
extern u64 arch_irq_stat_cpu(unsigned int cpu ) ;
extern u64 arch_irq_stat(void) ;
extern void synchronize_irq(unsigned int irq ) ;
extern void rcu_irq_enter(void) ;
extern void rcu_irq_exit(void) ;
extern void rcu_nmi_enter(void) ;
extern void rcu_nmi_exit(void) ;
extern void irq_enter(void) ;
extern void irq_exit(void) ;
extern irqreturn_t no_action(int cpl , void *dev_id ) ;
extern int request_threaded_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                irqreturn_t (*thread_fn)(int  , void * ) , unsigned long flags ,
                                char const   *name , void *dev ) ;
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ int tmp ;

  {
  {
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                             flags, name, dev);
  }
  return (tmp);
}
}
extern void exit_irq_thread(void) ;
extern void free_irq(unsigned int  , void * ) ;
extern int devm_request_threaded_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     irqreturn_t (*thread_fn)(int  , void * ) , unsigned long irqflags ,
                                     char const   *devname , void *dev_id ) ;
__inline static int devm_request_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     unsigned long irqflags , char const   *devname ,
                                     void *dev_id ) 
{ int tmp ;

  {
  {
  tmp = devm_request_threaded_irq(dev, irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                                  irqflags, devname, dev_id);
  }
  return (tmp);
}
}
extern void devm_free_irq(struct device *dev , unsigned int irq , void *dev_id ) ;
extern void disable_irq_nosync(unsigned int irq ) ;
extern void disable_irq(unsigned int irq ) ;
extern void enable_irq(unsigned int irq ) ;
extern void suspend_device_irqs(void) ;
extern void resume_device_irqs(void) ;
extern int check_wakeup_irqs(void) ;
extern cpumask_var_t irq_default_affinity ;
extern int irq_set_affinity(unsigned int irq , struct cpumask  const  *cpumask ) ;
extern int irq_can_set_affinity(unsigned int irq ) ;
extern int irq_select_affinity(unsigned int irq ) ;
__inline static void disable_irq_nosync_lockdep(unsigned int irq ) 
{ 

  {
  {
  disable_irq_nosync(irq);
  }
  return;
}
}
__inline static void disable_irq_nosync_lockdep_irqsave(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
  disable_irq_nosync(irq);
  }
  return;
}
}
__inline static void disable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
  disable_irq(irq);
  }
  return;
}
}
__inline static void enable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
  enable_irq(irq);
  }
  return;
}
}
__inline static void enable_irq_lockdep_irqrestore(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
  enable_irq(irq);
  }
  return;
}
}
extern int set_irq_wake(unsigned int irq , unsigned int on ) ;
__inline static int enable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
  tmp = set_irq_wake(irq, 1U);
  }
  return (tmp);
}
}
__inline static int disable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
  tmp = set_irq_wake(irq, 0U);
  }
  return (tmp);
}
}
extern char *softirq_to_name[9] ;
extern void ( __attribute__((__regparm__(0))) do_softirq)(void) ;
extern void ( __attribute__((__regparm__(0))) __do_softirq)(void) ;
extern void open_softirq(int nr , void (*action)(struct softirq_action * ) ) ;
extern void softirq_init(void) ;
extern void raise_softirq_irqoff(unsigned int nr ) ;
extern void raise_softirq(unsigned int nr ) ;
extern void wakeup_softirqd(void) ;
extern struct list_head per_cpu__softirq_work_list[9]  __attribute__((__section__(".data.percpu"))) ;
extern void send_remote_softirq(struct call_single_data *cp , int cpu , int softirq ) ;
extern void __send_remote_softirq(struct call_single_data *cp , int cpu , int this_cpu ,
                                  int softirq ) ;
__inline static int tasklet_trylock(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = test_and_set_bit(1, (unsigned long volatile   *)(& t->state));
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  return (tmp___0);
}
}
__inline static void tasklet_unlock(struct tasklet_struct *t ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  clear_bit(1, (unsigned long volatile   *)(& t->state));
  }
  return;
}
}
__inline static void tasklet_unlock_wait(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_204_continue: /* CIL Label */ ;
    {
    tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& t->state));
    }
    if (! tmp) {
      goto while_204_break;
    }
    {
    __asm__  volatile   ("": : : "memory");
    }
  }
  while_204_break: /* CIL Label */ ;
  }
  return;
}
}
extern void __tasklet_schedule(struct tasklet_struct *t ) ;
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
  if (! tmp) {
    {
    __tasklet_schedule(t);
    }
  }
  return;
}
}
extern void __tasklet_hi_schedule(struct tasklet_struct *t ) ;
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
  if (! tmp) {
    {
    __tasklet_hi_schedule(t);
    }
  }
  return;
}
}
__inline static void tasklet_disable_nosync(struct tasklet_struct *t ) 
{ 

  {
  {
  atomic_inc(& t->count);
  __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
__inline static void tasklet_disable(struct tasklet_struct *t ) 
{ 

  {
  {
  tasklet_disable_nosync(t);
  tasklet_unlock_wait(t);
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
  return;
}
}
__inline static void tasklet_enable(struct tasklet_struct *t ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  atomic_dec(& t->count);
  }
  return;
}
}
extern void tasklet_kill(struct tasklet_struct *t ) ;
extern void tasklet_kill_immediate(struct tasklet_struct *t , unsigned int cpu ) ;
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
extern unsigned long probe_irq_on(void) ;
extern int probe_irq_off(unsigned long  ) ;
extern unsigned int probe_irq_mask(unsigned long  ) ;
extern void init_irq_proc(void) ;
extern int show_interrupts(struct seq_file *p , void *v ) ;
extern int early_irq_init(void) ;
extern int arch_probe_nr_irqs(void) ;
extern int arch_early_irq_init(void) ;
extern int arch_init_chip_data(struct irq_desc *desc , int cpu ) ;
extern unsigned int __invalid_size_argument_for_IOC ;
__inline static int old_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < 256U) {
    if ((dev & ((1U << 20) - 1U)) < 256U) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static u16 old_encode_dev(dev_t dev ) 
{ 

  {
  return ((unsigned short )(((dev >> 20) << 8) | (dev & ((1U << 20) - 1U))));
}
}
__inline static dev_t old_decode_dev(u16 val ) 
{ 

  {
  return ((unsigned int )(((((int )val >> 8) & 255) << 20) | ((int )val & 255)));
}
}
__inline static int new_valid_dev(dev_t dev ) 
{ 

  {
  return (1);
}
}
__inline static u32 new_encode_dev(dev_t dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
  major = dev >> 20;
  minor = dev & ((1U << 20) - 1U);
  }
  return (((minor & 255U) | (major << 8)) | ((minor & 4294967040U) << 12));
}
}
__inline static dev_t new_decode_dev(u32 dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
  major = (dev & 1048320U) >> 8;
  minor = (dev & 255U) | ((dev >> 12) & 1048320U);
  }
  return ((major << 20) | minor);
}
}
__inline static u64 huge_encode_dev(dev_t dev ) 
{ u32 tmp ;

  {
  {
  tmp = new_encode_dev(dev);
  }
  return ((unsigned long long )tmp);
}
}
__inline static dev_t huge_decode_dev(u64 dev ) 
{ dev_t tmp ;

  {
  {
  tmp = new_decode_dev((unsigned int )dev);
  }
  return (tmp);
}
}
__inline static int sysv_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < (unsigned int )(1 << 14)) {
    if ((dev & ((1U << 20) - 1U)) < (unsigned int )(1 << 18)) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static u32 sysv_encode_dev(dev_t dev ) 
{ 

  {
  return ((dev & ((1U << 20) - 1U)) | ((dev >> 20) << 18));
}
}
__inline static unsigned int sysv_major(u32 dev ) 
{ 

  {
  return ((dev >> 18) & 16383U);
}
}
__inline static unsigned int sysv_minor(u32 dev ) 
{ 

  {
  return (dev & 262143U);
}
}
__inline static void __list_add_rcu(struct list_head *new , struct list_head *prev ,
                                    struct list_head *next ) 
{ 

  {
  {
  new->next = next;
  new->prev = prev;
  __asm__  volatile   ("": : : "memory");
  prev->next = new;
  next->prev = new;
  }
  return;
}
}
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add_rcu(new, head, head->next);
  }
  return;
}
}
__inline static void list_add_tail_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add_rcu(new, head->prev, head);
  }
  return;
}
}
__inline static void list_del_rcu(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_del_init_rcu(struct hlist_node *n ) 
{ int tmp ;

  {
  {
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
  if (! tmp) {
    {
    __hlist_del(n);
    n->pprev = (struct hlist_node **)((void *)0);
    }
  }
  return;
}
}
__inline static void list_replace_rcu(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
  new->next = old->next;
  new->prev = old->prev;
  __asm__  volatile   ("": : : "memory");
  (new->prev)->next = new;
  (new->next)->prev = new;
  old->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *at ;
  int tmp ;

  {
  {
  first = list->next;
  last = list->prev;
  at = head->next;
  tmp = list_empty((struct list_head  const  *)head);
  }
  if (tmp) {
    return;
  }
  {
  INIT_LIST_HEAD(list);
  (*sync)();
  last->next = at;
  __asm__  volatile   ("": : : "memory");
  head->next = first;
  first->prev = head;
  at->prev = last;
  }
  return;
}
}
__inline static void hlist_del_rcu(struct hlist_node *n ) 
{ 

  {
  {
  __hlist_del(n);
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_replace_rcu(struct hlist_node *old , struct hlist_node *new ) 
{ struct hlist_node *next ;

  {
  {
  next = old->next;
  new->next = next;
  new->pprev = old->pprev;
  __asm__  volatile   ("": : : "memory");
  *(new->pprev) = new;
  }
  if (next) {
    {
    (new->next)->pprev = & new->next;
    }
  }
  {
  old->pprev = (struct hlist_node **)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_add_head_rcu(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
  first = h->first;
  n->next = first;
  n->pprev = & h->first;
  __asm__  volatile   ("": : : "memory");
  h->first = n;
  }
  if (first) {
    {
    first->pprev = & n->next;
    }
  }
  return;
}
}
__inline static void hlist_add_before_rcu(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
  n->pprev = next->pprev;
  n->next = next;
  __asm__  volatile   ("": : : "memory");
  *(n->pprev) = n;
  next->pprev = & n->next;
  }
  return;
}
}
__inline static void hlist_add_after_rcu(struct hlist_node *prev , struct hlist_node *n ) 
{ 

  {
  {
  n->next = prev->next;
  n->pprev = & prev->next;
  __asm__  volatile   ("": : : "memory");
  prev->next = n;
  }
  if (n->next) {
    {
    (n->next)->pprev = & n->next;
    }
  }
  return;
}
}
extern struct dentry_stat_t dentry_stat ;
__inline static unsigned long partial_name_hash(unsigned long c , unsigned long prevhash ) 
{ 

  {
  return (((prevhash + (c << 4)) + (c >> 4)) * 11UL);
}
}
__inline static unsigned long end_name_hash(unsigned long hash ) 
{ 

  {
  return ((unsigned long )((unsigned int )hash));
}
}
__inline static unsigned int full_name_hash(unsigned char const   *name , unsigned int len ) 
{ unsigned long hash ;
  unsigned char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  hash = 0UL;
  }
  {
  while (1) {
    while_205_continue: /* CIL Label */ ;
    {
    tmp___0 = len;
    len --;
    }
    if (! tmp___0) {
      goto while_205_break;
    }
    {
    tmp = name;
    name ++;
    hash = partial_name_hash((unsigned long )*tmp, hash);
    }
  }
  while_205_break: /* CIL Label */ ;
  }
  {
  tmp___1 = end_name_hash(hash);
  }
  return ((unsigned int )tmp___1);
}
}
extern spinlock_t dcache_lock ;
extern seqlock_t rename_lock ;
__inline static void __d_drop(struct dentry *dentry ) 
{ 

  {
  if (! (dentry->d_flags & 16U)) {
    {
    dentry->d_flags |= 16U;
    hlist_del_rcu(& dentry->d_hash);
    }
  }
  return;
}
}
__inline static void d_drop(struct dentry *dentry ) 
{ 

  {
  {
  _spin_lock(& dcache_lock);
  _spin_lock(& dentry->d_lock);
  __d_drop(dentry);
  }
  {
  while (1) {
    while_206_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dentry->d_lock.raw_lock);
    }
    goto while_206_break;
  }
  while_206_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_207_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dcache_lock.raw_lock);
    }
    goto while_207_break;
  }
  while_207_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int dname_external(struct dentry *dentry ) 
{ 

  {
  return ((unsigned long )dentry->d_name.name != (unsigned long )(dentry->d_iname));
}
}
extern void d_instantiate(struct dentry * , struct inode * ) ;
extern struct dentry *d_instantiate_unique(struct dentry * , struct inode * ) ;
extern struct dentry *d_materialise_unique(struct dentry * , struct inode * ) ;
extern void d_delete(struct dentry * ) ;
extern struct dentry *d_alloc(struct dentry * , struct qstr  const  * ) ;
extern struct dentry *d_splice_alias(struct inode * , struct dentry * ) ;
extern struct dentry *d_add_ci(struct dentry * , struct inode * , struct qstr * ) ;
extern struct dentry *d_obtain_alias(struct inode * ) ;
extern void shrink_dcache_sb(struct super_block * ) ;
extern void shrink_dcache_parent(struct dentry * ) ;
extern void shrink_dcache_for_umount(struct super_block * ) ;
extern int d_invalidate(struct dentry * ) ;
extern struct dentry *d_alloc_root(struct inode * ) ;
extern void d_genocide(struct dentry * ) ;
extern struct dentry *d_find_alias(struct inode * ) ;
extern void d_prune_aliases(struct inode * ) ;
extern int have_submounts(struct dentry * ) ;
extern void d_rehash(struct dentry * ) ;
__inline static void d_add(struct dentry *entry , struct inode *inode ) 
{ 

  {
  {
  d_instantiate(entry, inode);
  d_rehash(entry);
  }
  return;
}
}
__inline static struct dentry *d_add_unique(struct dentry *entry , struct inode *inode ) 
{ struct dentry *res ;
  struct dentry *tmp ;

  {
  {
  res = d_instantiate_unique(entry, inode);
  }
  if ((unsigned long )res != (unsigned long )((void *)0)) {
    {
    tmp = res;
    }
  } else {
    {
    tmp = entry;
    }
  }
  {
  d_rehash(tmp);
  }
  return (res);
}
}
extern void d_move(struct dentry * , struct dentry * ) ;
extern struct dentry *d_ancestor(struct dentry * , struct dentry * ) ;
extern struct dentry *d_lookup(struct dentry * , struct qstr * ) ;
extern struct dentry *__d_lookup(struct dentry * , struct qstr * ) ;
extern struct dentry *d_hash_and_lookup(struct dentry * , struct qstr * ) ;
extern int d_validate(struct dentry * , struct dentry * ) ;
extern char *dynamic_dname(struct dentry * , char * , int  , char const   *  , ...) ;
extern char *__d_path(struct path  const  *path , struct path *root , char * , int  ) ;
extern char *d_path(struct path  const  * , char * , int  ) ;
extern char *dentry_path(struct dentry * , char * , int  ) ;
__inline static struct dentry *dget(struct dentry *dentry ) 
{ long tmp ;

  {
  if (dentry) {
    {
    while (1) {
      while_208_continue: /* CIL Label */ ;
      {
      tmp = __builtin_expect((long )(! (! (! dentry->d_count.counter))), 0L);
      }
      if (tmp) {
        {
        while (1) {
          while_209_continue: /* CIL Label */ ;
          {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b, %c0\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"),
                               "i" (334), "i" (sizeof(struct bug_entry )));
          }
          {
          while (1) {
            while_210_continue: /* CIL Label */ ;
          }
          while_210_break: /* CIL Label */ ;
          }
          goto while_209_break;
        }
        while_209_break: /* CIL Label */ ;
        }
      }
      goto while_208_break;
    }
    while_208_break: /* CIL Label */ ;
    }
    {
    atomic_inc(& dentry->d_count);
    }
  }
  return (dentry);
}
}
extern struct dentry *dget_locked(struct dentry * ) ;
__inline static int d_unhashed(struct dentry *dentry ) 
{ 

  {
  return ((int )(dentry->d_flags & 16U));
}
}
__inline static struct dentry *dget_parent(struct dentry *dentry ) 
{ struct dentry *ret ;

  {
  {
  _spin_lock(& dentry->d_lock);
  ret = dget(dentry->d_parent);
  }
  {
  while (1) {
    while_211_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dentry->d_lock.raw_lock);
    }
    goto while_211_break;
  }
  while_211_break: /* CIL Label */ ;
  }
  return (ret);
}
}
extern void dput(struct dentry * ) ;
__inline static int d_mountpoint(struct dentry *dentry ) 
{ 

  {
  return (dentry->d_mounted);
}
}
extern struct vfsmount *lookup_mnt(struct vfsmount * , struct dentry * ) ;
extern struct dentry *lookup_create(struct nameidata *nd , int is_dir ) ;
extern int sysctl_vfs_cache_pressure ;
__inline static void *radix_tree_ptr_to_indirect(void *ptr ) 
{ 

  {
  return ((void *)((unsigned long )ptr | 1UL));
}
}
__inline static void *radix_tree_indirect_to_ptr(void *ptr ) 
{ 

  {
  return ((void *)((unsigned long )ptr & 0xfffffffeUL));
}
}
__inline static int radix_tree_is_indirect_ptr(void *ptr ) 
{ 

  {
  return ((int )((unsigned long )ptr & 1UL));
}
}
__inline static void *radix_tree_deref_slot(void **pslot ) 
{ void *ret ;
  void *_________p1 ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  _________p1 = (void *)*((void * volatile  *)pslot);
  }
  {
  while (1) {
    while_212_continue: /* CIL Label */ ;
    goto while_212_break;
  }
  while_212_break: /* CIL Label */ ;
  }
  {
  ret = _________p1;
  tmp = radix_tree_is_indirect_ptr(ret);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    {
    ret = (void *)0xffffffffUL;
    }
  }
  return (ret);
}
}
__inline static void radix_tree_replace_slot(void **pslot , void *item ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  while (1) {
    while_213_continue: /* CIL Label */ ;
    {
    tmp = radix_tree_is_indirect_ptr(item);
    }
    if (tmp) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
    {
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
    if (tmp___1) {
      {
      while (1) {
        while_214_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"),
                             "i" (154), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_215_continue: /* CIL Label */ ;
        }
        while_215_break: /* CIL Label */ ;
        }
        goto while_214_break;
      }
      while_214_break: /* CIL Label */ ;
      }
    }
    goto while_213_break;
  }
  while_213_break: /* CIL Label */ ;
  }
  {
  __asm__  volatile   ("": : : "memory");
  *pslot = item;
  }
  return;
}
}
extern int radix_tree_insert(struct radix_tree_root * , unsigned long  , void * ) ;
extern void *radix_tree_lookup(struct radix_tree_root * , unsigned long  ) ;
extern void **radix_tree_lookup_slot(struct radix_tree_root * , unsigned long  ) ;
extern void *radix_tree_delete(struct radix_tree_root * , unsigned long  ) ;
extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root , void **results ,
                                           unsigned long first_index , unsigned int max_items ) ;
extern unsigned int radix_tree_gang_lookup_slot(struct radix_tree_root *root , void ***results ,
                                                unsigned long first_index , unsigned int max_items ) ;
extern unsigned long radix_tree_next_hole(struct radix_tree_root *root , unsigned long index ,
                                          unsigned long max_scan ) ;
extern int radix_tree_preload(gfp_t gfp_mask ) ;
extern void radix_tree_init(void) ;
extern void *radix_tree_tag_set(struct radix_tree_root *root , unsigned long index ,
                                unsigned int tag ) ;
extern void *radix_tree_tag_clear(struct radix_tree_root *root , unsigned long index ,
                                  unsigned int tag ) ;
extern int radix_tree_tag_get(struct radix_tree_root *root , unsigned long index ,
                              unsigned int tag ) ;
extern unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *root , void **results ,
                                               unsigned long first_index , unsigned int max_items ,
                                               unsigned int tag ) ;
extern unsigned int radix_tree_gang_lookup_tag_slot(struct radix_tree_root *root ,
                                                    void ***results , unsigned long first_index ,
                                                    unsigned int max_items , unsigned int tag ) ;
extern int radix_tree_tagged(struct radix_tree_root *root , unsigned int tag ) ;
__inline static void radix_tree_preload_end(void) 
{ 

  {
  {
  while (1) {
    while_216_continue: /* CIL Label */ ;
    goto while_216_break;
  }
  while_216_break: /* CIL Label */ ;
  }
  return;
}
}
extern void inode_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void inode_init_early(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void files_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern struct files_stat_struct files_stat ;
extern int get_max_files(void) ;
extern int sysctl_nr_open ;
extern struct inodes_stat_t inodes_stat ;
extern int leases_enable ;
extern int lease_break_time ;
extern int dir_notify_enable ;
extern int qtree_write_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_read_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_delete_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_release_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_entry_unused(struct qtree_mem_dqinfo *info , char *disk ) ;
__inline static int qtree_depth(struct qtree_mem_dqinfo *info ) 
{ unsigned int epb ;
  unsigned long long entries ;
  int i ;

  {
  {
  epb = info->dqi_usable_bs >> 2;
  entries = (unsigned long long )epb;
  i = 1;
  }
  {
  while (1) {
    while_217_continue: /* CIL Label */ ;
    if (! (entries < 1ULL << 32)) {
      goto while_217_break;
    }
    {
    entries *= (unsigned long long )epb;
    i ++;
    }
  }
  while_217_break: /* CIL Label */ ;
  }
  return (i);
}
}
extern spinlock_t dq_data_lock ;
extern void mark_info_dirty(struct super_block *sb , int type ) ;
__inline static int info_dirty(struct mem_dqinfo *info ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(16U, (unsigned long const volatile   *)(& info->dqi_flags));
  }
  return (tmp);
}
}
extern struct dqstats dqstats ;
__inline static unsigned int dquot_state_flag(unsigned int flags , int type ) 
{ 

  {
  if (type == 0) {
    return (flags);
  }
  return (flags << 3);
}
}
__inline static unsigned int dquot_generic_flag(unsigned int flags , int type ) 
{ 

  {
  if (type == 0) {
    return (flags);
  }
  return (flags >> 3);
}
}
extern int register_quota_format(struct quota_format_type *fmt ) ;
extern void unregister_quota_format(struct quota_format_type *fmt ) ;
extern size_t iov_iter_copy_from_user_atomic(struct page *page , struct iov_iter *i ,
                                             unsigned long offset , size_t bytes ) ;
extern size_t iov_iter_copy_from_user(struct page *page , struct iov_iter *i , unsigned long offset ,
                                      size_t bytes ) ;
extern void iov_iter_advance(struct iov_iter *i , size_t bytes ) ;
extern int iov_iter_fault_in_readable(struct iov_iter *i , size_t bytes ) ;
extern size_t iov_iter_single_seg_count(struct iov_iter *i ) ;
__inline static void iov_iter_init(struct iov_iter *i , struct iovec  const  *iov ,
                                   unsigned long nr_segs , size_t count , size_t written ) 
{ 

  {
  {
  i->iov = iov;
  i->nr_segs = nr_segs;
  i->iov_offset = 0U;
  i->count = count + written;
  iov_iter_advance(i, written);
  }
  return;
}
}
__inline static size_t iov_iter_count(struct iov_iter *i ) 
{ 

  {
  return (i->count);
}
}
extern int pagecache_write_begin(struct file * , struct address_space *mapping , loff_t pos ,
                                 unsigned int len , unsigned int flags , struct page **pagep ,
                                 void **fsdata ) ;
extern int pagecache_write_end(struct file * , struct address_space *mapping , loff_t pos ,
                               unsigned int len , unsigned int copied , struct page *page ,
                               void *fsdata ) ;
extern int mapping_tagged(struct address_space *mapping , int tag ) ;
__inline static int mapping_mapped(struct address_space *mapping ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = prio_tree_empty((struct prio_tree_root  const  *)(& mapping->i_mmap));
  }
  if (tmp) {
    {
    tmp___0 = list_empty((struct list_head  const  *)(& mapping->i_mmap_nonlinear));
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
  } else {
    {
    tmp___1 = 1;
    }
  }
  return (tmp___1);
}
}
__inline static int mapping_writably_mapped(struct address_space *mapping ) 
{ 

  {
  return (mapping->i_mmap_writable != 0U);
}
}
__inline static loff_t i_size_read(struct inode  const  *inode ) 
{ loff_t i_size ;
  unsigned int seq ;
  int tmp ;

  {
  {
  while (1) {
    while_218_continue: /* CIL Label */ ;
    {
    seq = read_seqcount_begin(& inode->i_size_seqcount);
    i_size = (long long )inode->i_size;
    tmp = read_seqcount_retry(& inode->i_size_seqcount, seq);
    }
    if (! tmp) {
      goto while_218_break;
    }
  }
  while_218_break: /* CIL Label */ ;
  }
  return (i_size);
}
}
__inline static void i_size_write(struct inode *inode , loff_t i_size ) 
{ 

  {
  {
  write_seqcount_begin(& inode->i_size_seqcount);
  inode->i_size = i_size;
  write_seqcount_end(& inode->i_size_seqcount);
  }
  return;
}
}
__inline static unsigned int iminor(struct inode  const  *inode ) 
{ 

  {
  return ((unsigned int )(inode->i_rdev & (unsigned int const   )((1U << 20) - 1U)));
}
}
__inline static unsigned int imajor(struct inode  const  *inode ) 
{ 

  {
  return ((unsigned int )(inode->i_rdev >> 20));
}
}
extern struct block_device *I_BDEV(struct inode *inode ) ;
__inline static int ra_has_index(struct file_ra_state *ra , unsigned long index ) 
{ int tmp ;

  {
  if (index >= ra->start) {
    if (index < ra->start + (unsigned long )ra->size) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern spinlock_t files_lock ;
__inline static void file_take_write(struct file *filp ) 
{ 

  {
  return;
}
}
__inline static int file_check_writeable(struct file *filp ) 
{ 

  {
  return (0);
}
}
extern void locks_start_grace(struct lock_manager * ) ;
extern void locks_end_grace(struct lock_manager * ) ;
extern int locks_in_grace(void) ;
__inline static int nfs_compare_fh(struct nfs_fh  const  *a , struct nfs_fh  const  *b ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((int const   )a->size != (int const   )b->size) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp = __builtin_memcmp((void const   *)(a->data), (void const   *)(b->data), (unsigned int )a->size);
    }
    if (tmp != 0) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static void nfs_copy_fh(struct nfs_fh *target , struct nfs_fh  const  *source ) 
{ 

  {
  {
  target->size = (unsigned short )source->size;
  __memcpy((void *)(target->data), (void const   *)(source->data), (unsigned int )source->size);
  }
  return;
}
}
extern void send_sigio(struct fown_struct *fown , int fd , int band ) ;
extern int do_sync_mapping_range(struct address_space *mapping , loff_t offset , loff_t endbyte ,
                                 unsigned int flags ) ;
extern int fcntl_getlk(struct file * , struct flock * ) ;
extern int fcntl_setlk(unsigned int  , struct file * , unsigned int  , struct flock * ) ;
extern int fcntl_getlk64(struct file * , struct flock64 * ) ;
extern int fcntl_setlk64(unsigned int  , struct file * , unsigned int  , struct flock64 * ) ;
extern int fcntl_setlease(unsigned int fd , struct file *filp , long arg ) ;
extern int fcntl_getlease(struct file *filp ) ;
extern void locks_init_lock(struct file_lock * ) ;
extern void locks_copy_lock(struct file_lock * , struct file_lock * ) ;
extern void __locks_copy_lock(struct file_lock * , struct file_lock  const  * ) ;
extern void locks_remove_posix(struct file * , fl_owner_t  ) ;
extern void locks_remove_flock(struct file * ) ;
extern void posix_test_lock(struct file * , struct file_lock * ) ;
extern int posix_lock_file(struct file * , struct file_lock * , struct file_lock * ) ;
extern int posix_lock_file_wait(struct file * , struct file_lock * ) ;
extern int posix_unblock_lock(struct file * , struct file_lock * ) ;
extern int vfs_test_lock(struct file * , struct file_lock * ) ;
extern int vfs_lock_file(struct file * , unsigned int  , struct file_lock * , struct file_lock * ) ;
extern int vfs_cancel_lock(struct file *filp , struct file_lock *fl ) ;
extern int flock_lock_file_wait(struct file *filp , struct file_lock *fl ) ;
extern int __break_lease(struct inode *inode , unsigned int flags ) ;
extern void lease_get_mtime(struct inode * , struct timespec *time ) ;
extern int generic_setlease(struct file * , long  , struct file_lock ** ) ;
extern int vfs_setlease(struct file * , long  , struct file_lock ** ) ;
extern int lease_modify(struct file_lock ** , int  ) ;
extern int lock_may_read(struct inode * , loff_t start , unsigned long count ) ;
extern int lock_may_write(struct inode * , loff_t start , unsigned long count ) ;
extern int fasync_helper(int  , struct file * , int  , struct fasync_struct ** ) ;
extern void kill_fasync(struct fasync_struct ** , int  , int  ) ;
extern void __kill_fasync(struct fasync_struct * , int  , int  ) ;
extern int __f_setown(struct file *filp , struct pid * , enum pid_type  , int force ) ;
extern int f_setown(struct file *filp , unsigned long arg , int force ) ;
extern void f_delown(struct file *filp ) ;
extern pid_t f_getown(struct file *filp ) ;
extern int send_sigurg(struct fown_struct *fown ) ;
extern struct list_head super_blocks ;
extern spinlock_t sb_lock ;
extern struct timespec current_fs_time(struct super_block *sb ) ;
extern void lock_super(struct super_block * ) ;
extern void unlock_super(struct super_block * ) ;
extern int vfs_create(struct inode * , struct dentry * , int  , struct nameidata * ) ;
extern int vfs_mkdir(struct inode * , struct dentry * , int  ) ;
extern int vfs_mknod(struct inode * , struct dentry * , int  , dev_t  ) ;
extern int vfs_symlink(struct inode * , struct dentry * , char const   * ) ;
extern int vfs_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
extern int vfs_unlink(struct inode * , struct dentry * ) ;
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern void dentry_unhash(struct dentry *dentry ) ;
extern int file_permission(struct file * , int  ) ;
extern int fiemap_fill_next_extent(struct fiemap_extent_info *info , u64 logical ,
                                   u64 phys , u64 len , u32 flags ) ;
extern int fiemap_check_flags(struct fiemap_extent_info *fieinfo , u32 fs_flags ) ;
extern int generic_osync_inode(struct inode * , struct address_space * , int  ) ;
extern ssize_t rw_copy_check_uvector(int type , struct iovec  const  *uvector , unsigned long nr_segs ,
                                     unsigned long fast_segs , struct iovec *fast_pointer ,
                                     struct iovec **ret_pointer ) ;
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
extern ssize_t vfs_readv(struct file * , struct iovec  const  * , unsigned long  ,
                         loff_t * ) ;
extern ssize_t vfs_writev(struct file * , struct iovec  const  * , unsigned long  ,
                          loff_t * ) ;
extern void __mark_inode_dirty(struct inode * , int  ) ;
__inline static void mark_inode_dirty(struct inode *inode ) 
{ 

  {
  {
  __mark_inode_dirty(inode, 7);
  }
  return;
}
}
__inline static void mark_inode_dirty_sync(struct inode *inode ) 
{ 

  {
  {
  __mark_inode_dirty(inode, 1);
  }
  return;
}
}
__inline static void inc_nlink(struct inode *inode ) 
{ 

  {
  {
  (inode->i_nlink) ++;
  }
  return;
}
}
__inline static void inode_inc_link_count(struct inode *inode ) 
{ 

  {
  {
  inc_nlink(inode);
  mark_inode_dirty(inode);
  }
  return;
}
}
__inline static void drop_nlink(struct inode *inode ) 
{ 

  {
  {
  (inode->i_nlink) --;
  }
  return;
}
}
__inline static void clear_nlink(struct inode *inode ) 
{ 

  {
  {
  inode->i_nlink = 0U;
  }
  return;
}
}
__inline static void inode_dec_link_count(struct inode *inode ) 
{ 

  {
  {
  drop_nlink(inode);
  mark_inode_dirty(inode);
  }
  return;
}
}
__inline static void inode_inc_iversion(struct inode *inode ) 
{ 

  {
  {
  _spin_lock(& inode->i_lock);
  (inode->i_version) ++;
  }
  {
  while (1) {
    while_219_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& inode->i_lock.raw_lock);
    }
    goto while_219_break;
  }
  while_219_break: /* CIL Label */ ;
  }
  return;
}
}
extern void touch_atime(struct vfsmount *mnt , struct dentry *dentry ) ;
__inline static void file_accessed(struct file *file ) 
{ 

  {
  if (! (file->f_flags & 262144U)) {
    {
    touch_atime(file->f_path.mnt, file->f_path.dentry);
    }
  }
  return;
}
}
extern int sync_inode(struct inode *inode , struct writeback_control *wbc ) ;
extern int get_sb_ns(struct file_system_type *fs_type , int flags , void *data , int (*fill_super)(struct super_block * ,
                                                                                                   void * ,
                                                                                                   int  ) ,
                     struct vfsmount *mnt ) ;
extern int get_sb_bdev(struct file_system_type *fs_type , int flags , char const   *dev_name ,
                       void *data , int (*fill_super)(struct super_block * , void * ,
                                                      int  ) , struct vfsmount *mnt ) ;
extern int get_sb_single(struct file_system_type *fs_type , int flags , void *data ,
                         int (*fill_super)(struct super_block * , void * , int  ) ,
                         struct vfsmount *mnt ) ;
extern int get_sb_nodev(struct file_system_type *fs_type , int flags , void *data ,
                        int (*fill_super)(struct super_block * , void * , int  ) ,
                        struct vfsmount *mnt ) ;
extern void generic_shutdown_super(struct super_block *sb ) ;
extern void kill_block_super(struct super_block *sb ) ;
extern void kill_anon_super(struct super_block *sb ) ;
extern void kill_litter_super(struct super_block *sb ) ;
extern void deactivate_super(struct super_block *sb ) ;
extern void deactivate_locked_super(struct super_block *sb ) ;
extern int set_anon_super(struct super_block *s , void *data ) ;
extern struct super_block *sget(struct file_system_type *type , int (*test)(struct super_block * ,
                                                                            void * ) ,
                                int (*set)(struct super_block * , void * ) , void *data ) ;
extern int get_sb_pseudo(struct file_system_type * , char * , struct super_operations  const  *ops ,
                         unsigned long  , struct vfsmount *mnt ) ;
extern void simple_set_mnt(struct vfsmount *mnt , struct super_block *sb ) ;
extern int __put_super_and_need_restart(struct super_block *sb ) ;
extern int register_filesystem(struct file_system_type * ) ;
extern int unregister_filesystem(struct file_system_type * ) ;
extern struct vfsmount *kern_mount_data(struct file_system_type * , void *data ) ;
extern int may_umount_tree(struct vfsmount * ) ;
extern int may_umount(struct vfsmount * ) ;
extern long do_mount(char * , char * , char * , unsigned long  , void * ) ;
extern struct vfsmount *collect_mounts(struct vfsmount * , struct dentry * ) ;
extern void drop_collected_mounts(struct vfsmount * ) ;
extern int vfs_statfs(struct dentry * , struct kstatfs * ) ;
extern int current_umask(void) ;
extern struct kobject *fs_kobj ;
extern int rw_verify_area(int  , struct file * , loff_t * , size_t  ) ;
extern int locks_mandatory_locked(struct inode * ) ;
extern int locks_mandatory_area(int  , struct inode * , struct file * , loff_t  ,
                                size_t  ) ;
__inline static int __mandatory_lock(struct inode *ino ) 
{ 

  {
  return (((int )ino->i_mode & 1032) == 1024);
}
}
__inline static int mandatory_lock(struct inode *ino ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((ino->i_sb)->s_flags & 64UL) {
    {
    tmp = __mandatory_lock(ino);
    }
    if (tmp) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
__inline static int locks_verify_locked(struct inode *inode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = mandatory_lock(inode);
  }
  if (tmp___0) {
    {
    tmp = locks_mandatory_locked(inode);
    }
    return (tmp);
  }
  return (0);
}
}
__inline static int locks_verify_truncate(struct inode *inode , struct file *filp ,
                                          loff_t size ) 
{ loff_t tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (inode->i_flock) {
    {
    tmp___2 = mandatory_lock(inode);
    }
    if (tmp___2) {
      if (size < inode->i_size) {
        {
        tmp = inode->i_size - size;
        }
      } else {
        {
        tmp = size - inode->i_size;
        }
      }
      if (size < inode->i_size) {
        {
        tmp___0 = size;
        }
      } else {
        {
        tmp___0 = inode->i_size;
        }
      }
      {
      tmp___1 = locks_mandatory_area(2, inode, filp, tmp___0, (unsigned int )tmp);
      }
      return (tmp___1);
    }
  }
  return (0);
}
}
__inline static int break_lease(struct inode *inode , unsigned int mode ) 
{ int tmp ;

  {
  if (inode->i_flock) {
    {
    tmp = __break_lease(inode, mode);
    }
    return (tmp);
  }
  return (0);
}
}
extern int do_truncate(struct dentry * , loff_t start , unsigned int time_attrs ,
                       struct file *filp ) ;
extern long do_sys_open(int dfd , char const   *filename , int flags , int mode ) ;
extern struct file *filp_open(char const   * , int  , int  ) ;
extern struct file *dentry_open(struct dentry * , struct vfsmount * , int  , struct cred  const  * ) ;
extern int filp_close(struct file * , fl_owner_t id ) ;
extern char *getname(char const   * ) ;
extern void vfs_caches_init_early(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern void vfs_caches_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern struct kmem_cache *names_cachep ;
extern void putname(char const   *name ) ;
extern int register_blkdev(unsigned int  , char const   * ) ;
extern void unregister_blkdev(unsigned int  , char const   * ) ;
extern struct block_device *bdget(dev_t  ) ;
extern void bd_set_size(struct block_device * , loff_t size ) ;
extern void bd_forget(struct inode *inode ) ;
extern void bdput(struct block_device * ) ;
extern struct block_device *open_by_devnum(dev_t  , fmode_t  ) ;
extern void invalidate_bdev(struct block_device * ) ;
extern int sync_blockdev(struct block_device *bdev ) ;
extern struct super_block *freeze_bdev(struct block_device * ) ;
extern void emergency_thaw_all(void) ;
extern int thaw_bdev(struct block_device *bdev , struct super_block *sb ) ;
extern int fsync_bdev(struct block_device * ) ;
extern int fsync_super(struct super_block * ) ;
extern int fsync_no_super(struct block_device * ) ;
extern struct file_operations  const  def_blk_fops ;
extern struct file_operations  const  def_chr_fops ;
extern struct file_operations  const  bad_sock_fops ;
extern struct file_operations  const  def_fifo_fops ;
extern int ioctl_by_bdev(struct block_device * , unsigned int  , unsigned long  ) ;
extern int blkdev_ioctl(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
extern long compat_blkdev_ioctl(struct file * , unsigned int  , unsigned long  ) ;
extern int blkdev_get(struct block_device * , fmode_t  ) ;
extern int blkdev_put(struct block_device * , fmode_t  ) ;
extern int bd_claim(struct block_device * , void * ) ;
extern void bd_release(struct block_device * ) ;
extern int bd_claim_by_disk(struct block_device * , void * , struct gendisk * ) ;
extern void bd_release_from_disk(struct block_device * , struct gendisk * ) ;
extern int alloc_chrdev_region(dev_t * , unsigned int  , unsigned int  , char const   * ) ;
extern int register_chrdev_region(dev_t  , unsigned int  , char const   * ) ;
extern int register_chrdev(unsigned int  , char const   * , struct file_operations  const  * ) ;
extern void unregister_chrdev(unsigned int  , char const   * ) ;
extern void unregister_chrdev_region(dev_t  , unsigned int  ) ;
extern void chrdev_show(struct seq_file * , off_t  ) ;
extern char const   *__bdevname(dev_t  , char *buffer ) ;
extern char const   *bdevname(struct block_device *bdev , char *buffer ) ;
extern struct block_device *lookup_bdev(char const   * ) ;
extern struct block_device *open_bdev_exclusive(char const   * , fmode_t  , void * ) ;
extern void close_bdev_exclusive(struct block_device * , fmode_t  ) ;
extern void blkdev_show(struct seq_file * , off_t  ) ;
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
extern void make_bad_inode(struct inode * ) ;
extern int is_bad_inode(struct inode * ) ;
extern struct file_operations  const  read_pipefifo_fops ;
extern struct file_operations  const  write_pipefifo_fops ;
extern struct file_operations  const  rdwr_pipefifo_fops ;
extern int fs_may_remount_ro(struct super_block * ) ;
extern void check_disk_size_change(struct gendisk *disk , struct block_device *bdev ) ;
extern int revalidate_disk(struct gendisk * ) ;
extern int check_disk_change(struct block_device * ) ;
extern int __invalidate_device(struct block_device * ) ;
extern int invalidate_partition(struct gendisk * , int  ) ;
extern int invalidate_inodes(struct super_block * ) ;
extern unsigned long __invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                                unsigned long end , bool be_atomic ) ;
extern unsigned long invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                              unsigned long end ) ;
__inline static unsigned long invalidate_inode_pages(struct address_space *mapping ) 
{ unsigned long tmp ;

  {
  {
  tmp = invalidate_mapping_pages(mapping, 0UL, ~ 0UL);
  }
  return (tmp);
}
}
__inline static void invalidate_remote_inode(struct inode *inode ) 
{ 

  {
  if (((int )inode->i_mode & 61440) == 32768) {
    {
    invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
    }
  } else {
    if (((int )inode->i_mode & 61440) == 16384) {
      {
      invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
      }
    } else {
      if (((int )inode->i_mode & 61440) == 40960) {
        {
        invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
        }
      }
    }
  }
  return;
}
}
extern int invalidate_inode_pages2(struct address_space *mapping ) ;
extern int invalidate_inode_pages2_range(struct address_space *mapping , unsigned long start ,
                                         unsigned long end ) ;
extern void generic_sync_sb_inodes(struct super_block *sb , struct writeback_control *wbc ) ;
extern int write_inode_now(struct inode * , int  ) ;
extern int filemap_fdatawrite(struct address_space * ) ;
extern int filemap_flush(struct address_space * ) ;
extern int filemap_fdatawait(struct address_space * ) ;
extern int filemap_write_and_wait(struct address_space *mapping ) ;
extern int filemap_write_and_wait_range(struct address_space *mapping , loff_t lstart ,
                                        loff_t lend ) ;
extern int wait_on_page_writeback_range(struct address_space *mapping , unsigned long start ,
                                        unsigned long end ) ;
extern int __filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                      loff_t end , int sync_mode ) ;
extern int filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                    loff_t end ) ;
extern int vfs_fsync(struct file *file , struct dentry *dentry , int datasync ) ;
extern void sync_supers(void) ;
extern void sync_filesystems(int wait ) ;
extern void __fsync_super(struct super_block *sb ) ;
extern void emergency_sync(void) ;
extern void emergency_remount(void) ;
extern int do_remount_sb(struct super_block *sb , int flags , void *data , int force ) ;
extern sector_t bmap(struct inode * , sector_t  ) ;
extern int notify_change(struct dentry * , struct iattr * ) ;
extern int inode_permission(struct inode * , int  ) ;
extern int generic_permission(struct inode * , int  , int (*check_acl)(struct inode * ,
                                                                       int  ) ) ;
__inline static bool execute_ok(struct inode *inode ) 
{ int tmp ;

  {
  if ((int )inode->i_mode & 73) {
    {
    tmp = 1;
    }
  } else {
    if (((int )inode->i_mode & 61440) == 16384) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return ((_Bool )tmp);
}
}
extern int get_write_access(struct inode * ) ;
extern int deny_write_access(struct file * ) ;
__inline static void put_write_access(struct inode *inode ) 
{ 

  {
  {
  atomic_dec(& inode->i_writecount);
  }
  return;
}
}
__inline static void allow_write_access(struct file *file ) 
{ 

  {
  if (file) {
    {
    atomic_inc(& ((file->f_path.dentry)->d_inode)->i_writecount);
    }
  }
  return;
}
}
extern int do_pipe_flags(int * , int  ) ;
extern struct file *create_read_pipe(struct file *f , int flags ) ;
extern struct file *create_write_pipe(int flags ) ;
extern void free_write_pipe(struct file * ) ;
extern struct file *do_filp_open(int dfd , char const   *pathname , int open_flag ,
                                 int mode , int acc_mode ) ;
extern int may_open(struct path * , int  , int  ) ;
extern int kernel_read(struct file * , unsigned long  , char * , unsigned long  ) ;
extern struct file *open_exec(char const   * ) ;
extern int is_subdir(struct dentry * , struct dentry * ) ;
extern ino_t find_inode_number(struct dentry * , struct qstr * ) ;
extern loff_t default_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t vfs_llseek(struct file *file , loff_t offset , int origin ) ;
extern struct inode *inode_init_always(struct super_block * , struct inode * ) ;
extern void inode_init_once(struct inode * ) ;
extern void inode_add_to_lists(struct super_block * , struct inode * ) ;
extern void iput(struct inode * ) ;
extern struct inode *igrab(struct inode * ) ;
extern ino_t iunique(struct super_block * , ino_t  ) ;
extern int inode_needs_sync(struct inode *inode ) ;
extern void generic_delete_inode(struct inode *inode ) ;
extern void generic_drop_inode(struct inode *inode ) ;
extern struct inode *ilookup5_nowait(struct super_block *sb , unsigned long hashval ,
                                     int (*test)(struct inode * , void * ) , void *data ) ;
extern struct inode *ilookup5(struct super_block *sb , unsigned long hashval , int (*test)(struct inode * ,
                                                                                           void * ) ,
                              void *data ) ;
extern struct inode *ilookup(struct super_block *sb , unsigned long ino ) ;
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*test)(struct inode * ,
                                                                                      void * ) ,
                                  int (*set)(struct inode * , void * ) , void * ) ;
extern struct inode *iget_locked(struct super_block * , unsigned long  ) ;
extern int insert_inode_locked4(struct inode * , unsigned long  , int (*test)(struct inode * ,
                                                                              void * ) ,
                                void * ) ;
extern int insert_inode_locked(struct inode * ) ;
extern void unlock_new_inode(struct inode * ) ;
extern void __iget(struct inode *inode ) ;
extern void iget_failed(struct inode * ) ;
extern void clear_inode(struct inode * ) ;
extern void destroy_inode(struct inode * ) ;
extern struct inode *new_inode(struct super_block * ) ;
extern int should_remove_suid(struct dentry * ) ;
extern int file_remove_suid(struct file * ) ;
extern void __insert_inode_hash(struct inode * , unsigned long hashval ) ;
extern void remove_inode_hash(struct inode * ) ;
__inline static void insert_inode_hash(struct inode *inode ) 
{ 

  {
  {
  __insert_inode_hash(inode, inode->i_ino);
  }
  return;
}
}
extern struct file *get_empty_filp(void) ;
extern void file_move(struct file *f , struct list_head *list ) ;
extern void file_kill(struct file *f ) ;
extern void submit_bio(int  , struct bio * ) ;
extern int bdev_read_only(struct block_device * ) ;
extern int set_blocksize(struct block_device * , int  ) ;
extern int sb_set_blocksize(struct super_block * , int  ) ;
extern int sb_min_blocksize(struct super_block * , int  ) ;
extern int sb_has_dirty_inodes(struct super_block * ) ;
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
extern int generic_file_readonly_mmap(struct file * , struct vm_area_struct * ) ;
extern int file_read_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
extern int generic_write_checks(struct file *file , loff_t *pos , size_t *count ,
                                int isblk ) ;
extern ssize_t generic_file_aio_read(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                     loff_t  ) ;
extern ssize_t generic_file_aio_write(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                      loff_t  ) ;
extern ssize_t generic_file_aio_write_nolock(struct kiocb * , struct iovec  const  * ,
                                             unsigned long  , loff_t  ) ;
extern ssize_t generic_file_direct_write(struct kiocb * , struct iovec  const  * ,
                                         unsigned long * , loff_t  , loff_t * , size_t  ,
                                         size_t  ) ;
extern ssize_t generic_file_buffered_write(struct kiocb * , struct iovec  const  * ,
                                           unsigned long  , loff_t  , loff_t * , size_t  ,
                                           ssize_t  ) ;
extern ssize_t do_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
extern ssize_t do_sync_write(struct file *filp , char const   *buf , size_t len ,
                             loff_t *ppos ) ;
extern int generic_segment_checks(struct iovec  const  *iov , unsigned long *nr_segs ,
                                  size_t *count , int access_flags ) ;
extern ssize_t generic_file_splice_read(struct file * , loff_t * , struct pipe_inode_info * ,
                                        size_t  , unsigned int  ) ;
extern ssize_t generic_file_splice_write(struct pipe_inode_info * , struct file * ,
                                         loff_t * , size_t  , unsigned int  ) ;
extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe , struct file *out ,
                                       loff_t * , size_t len , unsigned int flags ) ;
extern long do_splice_direct(struct file *in , loff_t *ppos , struct file *out , size_t len ,
                             unsigned int flags ) ;
extern void file_ra_state_init(struct file_ra_state *ra , struct address_space *mapping ) ;
extern loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t generic_file_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t generic_file_llseek_unlocked(struct file *file , loff_t offset , int origin ) ;
extern int generic_file_open(struct inode *inode , struct file *filp ) ;
extern int nonseekable_open(struct inode *inode , struct file *filp ) ;
__inline static int xip_truncate_page(struct address_space *mapping , loff_t from ) 
{ 

  {
  return (0);
}
}
extern ssize_t __blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                    struct block_device *bdev , struct iovec  const  *iov ,
                                    loff_t offset , unsigned long nr_segs , get_block_t *get_block ,
                                    dio_iodone_t *end_io , int lock_type ) ;
__inline static ssize_t blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                           struct block_device *bdev , struct iovec  const  *iov ,
                                           loff_t offset , unsigned long nr_segs ,
                                           get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 1);
  }
  return (tmp);
}
}
__inline static ssize_t blockdev_direct_IO_no_locking(int rw , struct kiocb *iocb ,
                                                      struct inode *inode , struct block_device *bdev ,
                                                      struct iovec  const  *iov ,
                                                      loff_t offset , unsigned long nr_segs ,
                                                      get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 2);
  }
  return (tmp);
}
}
__inline static ssize_t blockdev_direct_IO_own_locking(int rw , struct kiocb *iocb ,
                                                       struct inode *inode , struct block_device *bdev ,
                                                       struct iovec  const  *iov ,
                                                       loff_t offset , unsigned long nr_segs ,
                                                       get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 3);
  }
  return (tmp);
}
}
extern struct file_operations  const  generic_ro_fops ;
extern int vfs_readlink(struct dentry * , char * , int  , char const   * ) ;
extern int vfs_follow_link(struct nameidata * , char const   * ) ;
extern int page_readlink(struct dentry * , char * , int  ) ;
extern void *page_follow_link_light(struct dentry * , struct nameidata * ) ;
extern void page_put_link(struct dentry * , struct nameidata * , void * ) ;
extern int __page_symlink(struct inode *inode , char const   *symname , int len ,
                          int nofs ) ;
extern int page_symlink(struct inode *inode , char const   *symname , int len ) ;
extern struct inode_operations  const  page_symlink_inode_operations ;
extern int generic_readlink(struct dentry * , char * , int  ) ;
extern void generic_fillattr(struct inode * , struct kstat * ) ;
extern int vfs_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern void inode_add_bytes(struct inode *inode , loff_t bytes ) ;
extern void inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
extern loff_t inode_get_bytes(struct inode *inode ) ;
extern void inode_set_bytes(struct inode *inode , loff_t bytes ) ;
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               u64  , unsigned int  ) , void * ) ;
extern int vfs_stat(char * , struct kstat * ) ;
extern int vfs_lstat(char * , struct kstat * ) ;
extern int vfs_fstat(unsigned int  , struct kstat * ) ;
extern int vfs_fstatat(int  , char * , struct kstat * , int  ) ;
extern int do_vfs_ioctl(struct file *filp , unsigned int fd , unsigned int cmd , unsigned long arg ) ;
extern int __generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                  u64 start , u64 len , get_block_t *get_block ) ;
extern int generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                u64 start , u64 len , get_block_t *get_block ) ;
extern void get_filesystem(struct file_system_type *fs ) ;
extern void put_filesystem(struct file_system_type *fs ) ;
extern struct file_system_type *get_fs_type(char const   *name ) ;
extern struct super_block *get_super(struct block_device * ) ;
extern struct super_block *user_get_super(dev_t  ) ;
extern void drop_super(struct super_block *sb ) ;
extern int dcache_dir_open(struct inode * , struct file * ) ;
extern int dcache_dir_close(struct inode * , struct file * ) ;
extern loff_t dcache_dir_lseek(struct file * , loff_t  , int  ) ;
extern int dcache_readdir(struct file * , void * , int (*)(void * , char const   * ,
                                                           int  , loff_t  , u64  ,
                                                           unsigned int  ) ) ;
extern int simple_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern int simple_statfs(struct dentry * , struct kstatfs * ) ;
extern int simple_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_unlink(struct inode * , struct dentry * ) ;
extern int simple_rmdir(struct inode * , struct dentry * ) ;
extern int simple_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_sync_file(struct file * , struct dentry * , int  ) ;
extern int simple_empty(struct dentry * ) ;
extern int simple_readpage(struct file *file , struct page *page ) ;
extern int simple_prepare_write(struct file *file , struct page *page , unsigned int offset ,
                                unsigned int to ) ;
extern int simple_write_begin(struct file *file , struct address_space *mapping ,
                              loff_t pos , unsigned int len , unsigned int flags ,
                              struct page **pagep , void **fsdata ) ;
extern int simple_write_end(struct file *file , struct address_space *mapping , loff_t pos ,
                            unsigned int len , unsigned int copied , struct page *page ,
                            void *fsdata ) ;
extern struct dentry *simple_lookup(struct inode * , struct dentry * , struct nameidata * ) ;
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
extern struct file_operations  const  simple_dir_operations ;
extern struct inode_operations  const  simple_dir_inode_operations ;
extern struct dentry *d_alloc_name(struct dentry * , char const   * ) ;
extern int simple_fill_super(struct super_block * , int  , struct tree_descr * ) ;
extern int simple_pin_fs(struct file_system_type * , struct vfsmount **mount , int *count ) ;
extern void simple_release_fs(struct vfsmount **mount , int *count ) ;
extern ssize_t simple_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
extern int inode_change_ok(struct inode * , struct iattr * ) ;
extern int inode_setattr(struct inode * , struct iattr * ) ;
extern void file_update_time(struct file *file ) ;
extern int generic_show_options(struct seq_file *m , struct vfsmount *mnt ) ;
extern void save_mount_options(struct super_block *sb , char *options ) ;
extern void replace_mount_options(struct super_block *sb , char *options ) ;
__inline static ino_t parent_ino(struct dentry *dentry ) 
{ ino_t res ;

  {
  {
  _spin_lock(& dentry->d_lock);
  res = ((dentry->d_parent)->d_inode)->i_ino;
  }
  {
  while (1) {
    while_220_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dentry->d_lock.raw_lock);
    }
    goto while_220_break;
  }
  while_220_break: /* CIL Label */ ;
  }
  return (res);
}
}
extern char *simple_transaction_get(struct file *file , char const   *buf , size_t size ) ;
extern ssize_t simple_transaction_read(struct file *file , char *buf , size_t size ,
                                       loff_t *pos ) ;
extern int simple_transaction_release(struct inode *inode , struct file *file ) ;
extern void simple_transaction_set(struct file *file , size_t n ) ;
extern int simple_attr_open(struct inode *inode , struct file *file , int (*get)(void * ,
                                                                                 u64 * ) ,
                            int (*set)(void * , u64  ) , char const   *fmt ) ;
extern int simple_attr_release(struct inode *inode , struct file *file ) ;
extern ssize_t simple_attr_read(struct file *file , char *buf , size_t len , loff_t *ppos ) ;
extern ssize_t simple_attr_write(struct file *file , char const   *buf , size_t len ,
                                 loff_t *ppos ) ;
extern int proc_nr_files(struct ctl_table *table , int write , struct file *filp ,
                         void *buffer , size_t *lenp , loff_t *ppos ) ;
extern int get_filesystem_list(char *buf )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ void *tmp ;

  {
  {
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
  }
  return (tmp);
}
}
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 

  {
  {
  dev_set_drvdata(& intf->dev, data);
  }
  return;
}
}
struct usb_interface *usb_get_intf(struct usb_interface *intf ) ;
void usb_put_intf(struct usb_interface *intf ) ;
int __usb_get_extra_descriptor(char *buffer , unsigned int size , unsigned char type ,
                               void **ptr ) ;
struct usb_device *usb_get_dev(struct usb_device *dev ) ;
void usb_put_dev(struct usb_device *dev ) ;
int usb_lock_device_for_reset(struct usb_device *udev , struct usb_interface  const  *iface ) ;
int usb_reset_device(struct usb_device *udev ) ;
void usb_queue_reset_device(struct usb_interface *iface ) ;
struct usb_device *usb_find_device(u16 vendor_id , u16 product_id ) ;
int usb_autopm_set_interface(struct usb_interface *intf ) ;
int usb_autopm_get_interface(struct usb_interface *intf ) ;
void usb_autopm_put_interface(struct usb_interface *intf ) ;
int usb_autopm_get_interface_async(struct usb_interface *intf ) ;
void usb_autopm_put_interface_async(struct usb_interface *intf ) ;
__inline static void usb_autopm_enable(struct usb_interface *intf ) 
{ 

  {
  {
  intf->pm_usage_cnt = 0;
  usb_autopm_set_interface(intf);
  }
  return;
}
}
__inline static void usb_autopm_disable(struct usb_interface *intf ) 
{ 

  {
  {
  intf->pm_usage_cnt = 1;
  usb_autopm_set_interface(intf);
  }
  return;
}
}
__inline static void usb_mark_last_busy(struct usb_device *udev ) 
{ 

  {
  {
  udev->last_busy = (unsigned long )jiffies;
  }
  return;
}
}
int usb_get_current_frame_number(struct usb_device *dev ) ;
int usb_driver_claim_interface(struct usb_driver *driver , struct usb_interface *iface ,
                               void *priv ) ;
__inline static int usb_interface_claimed(struct usb_interface *iface ) 
{ 

  {
  return ((unsigned long )iface->dev.driver != (unsigned long )((void *)0));
}
}
void usb_driver_release_interface(struct usb_driver *driver , struct usb_interface *iface ) ;
struct usb_device_id  const  *usb_match_id(struct usb_interface *interface , struct usb_device_id  const  *id ) ;
int usb_match_one_id(struct usb_interface *interface , struct usb_device_id  const  *id ) ;
struct usb_interface *usb_find_interface(struct usb_driver *drv , int minor ) ;
struct usb_interface *usb_ifnum_to_if(struct usb_device  const  *dev , unsigned int ifnum ) ;
struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface  const  *intf ,
                                                    unsigned int altnum ) ;
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ int actual ;
  int tmp ;

  {
  {
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, dev->devpath);
  }
  if (actual >= (int )size) {
    {
    tmp = -1;
    }
  } else {
    {
    tmp = actual;
    }
  }
  return (tmp);
}
}
ssize_t usb_store_new_id(struct usb_dynids *dynids , struct device_driver *driver ,
                         char const   *buf , size_t count ) ;
struct bus_type usb_bus_type ;
int usb_register_driver(struct usb_driver *new_driver , struct module *owner , char const   *mod_name ) ;
__inline static int usb_register(struct usb_driver *driver ) 
{ int tmp ;

  {
  {
  tmp = usb_register_driver(driver, (struct module *)0, "SomeModule");
  }
  return (tmp);
}
}
void usb_deregister(struct usb_driver *driver ) ;
int usb_register_device_driver(struct usb_device_driver *new_udriver , struct module *owner ) ;
void usb_deregister_device_driver(struct usb_device_driver *udriver ) ;
int usb_register_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) ;
void usb_deregister_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) ;
int usb_disabled(void) ;
__inline static void init_usb_anchor(struct usb_anchor *anchor ) 
{ spinlock_t __constr_expr_0 ;

  {
  {
  INIT_LIST_HEAD(& anchor->urb_list);
  init_waitqueue_head(& anchor->wait);
  }
  {
  while (1) {
    while_221_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    anchor->lock = __constr_expr_0;
    }
    goto while_221_break;
  }
  while_221_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void usb_fill_control_urb(struct urb *urb , struct usb_device *dev ,
                                          unsigned int pipe , unsigned char *setup_packet ,
                                          void *transfer_buffer , int buffer_length ,
                                          void (*complete_fn)(struct urb * ) , void *context ) 
{ 

  {
  {
  urb->dev = dev;
  urb->pipe = pipe;
  urb->setup_packet = setup_packet;
  urb->transfer_buffer = transfer_buffer;
  urb->transfer_buffer_length = (unsigned int )buffer_length;
  urb->complete = complete_fn;
  urb->context = context;
  }
  return;
}
}
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 

  {
  {
  urb->dev = dev;
  urb->pipe = pipe;
  urb->transfer_buffer = transfer_buffer;
  urb->transfer_buffer_length = (unsigned int )buffer_length;
  urb->complete = complete_fn;
  urb->context = context;
  }
  return;
}
}
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval ) 
{ 

  {
  {
  urb->dev = dev;
  urb->pipe = pipe;
  urb->transfer_buffer = transfer_buffer;
  urb->transfer_buffer_length = (unsigned int )buffer_length;
  urb->complete = complete_fn;
  urb->context = context;
  }
  if ((unsigned int )dev->speed == 3U) {
    {
    urb->interval = 1 << (interval - 1);
    }
  } else {
    {
    urb->interval = interval;
    }
  }
  {
  urb->start_frame = -1;
  }
  return;
}
}
void usb_init_urb(struct urb *urb ) ;
struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) ;
void usb_free_urb(struct urb *urb ) ;
struct urb *usb_get_urb(struct urb *urb ) ;
int usb_submit_urb(struct urb *urb , gfp_t mem_flags ) ;
int usb_unlink_urb(struct urb *urb ) ;
void usb_kill_urb(struct urb *urb ) ;
void usb_poison_urb(struct urb *urb ) ;
void usb_unpoison_urb(struct urb *urb ) ;
void usb_kill_anchored_urbs(struct usb_anchor *anchor ) ;
void usb_poison_anchored_urbs(struct usb_anchor *anchor ) ;
void usb_unpoison_anchored_urbs(struct usb_anchor *anchor ) ;
void usb_unlink_anchored_urbs(struct usb_anchor *anchor ) ;
void usb_anchor_urb(struct urb *urb , struct usb_anchor *anchor ) ;
void usb_unanchor_urb(struct urb *urb ) ;
int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor , unsigned int timeout ) ;
struct urb *usb_get_from_anchor(struct usb_anchor *anchor ) ;
void usb_scuttle_anchored_urbs(struct usb_anchor *anchor ) ;
int usb_anchor_empty(struct usb_anchor *anchor ) ;
__inline static int usb_urb_dir_in(struct urb *urb ) 
{ 

  {
  return ((urb->transfer_flags & 512U) == 512U);
}
}
__inline static int usb_urb_dir_out(struct urb *urb ) 
{ 

  {
  return ((urb->transfer_flags & 512U) == 0U);
}
}
void *usb_buffer_alloc(struct usb_device *dev , size_t size , gfp_t mem_flags , dma_addr_t *dma ) ;
void usb_buffer_free(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) ;
int usb_buffer_map_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                      int nents ) ;
void usb_buffer_unmap_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                         int n_hw_ents ) ;
int usb_control_msg(struct usb_device *dev , unsigned int pipe , __u8 request , __u8 requesttype ,
                    __u16 value , __u16 index , void *data , __u16 size , int timeout ) ;
int usb_interrupt_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                      int len , int *actual_length , int timeout ) ;
int usb_bulk_msg(struct usb_device *usb_dev , unsigned int pipe , void *data , int len ,
                 int *actual_length , int timeout ) ;
int usb_get_descriptor(struct usb_device *dev , unsigned char type , unsigned char index ,
                       void *buf , int size ) ;
int usb_get_status(struct usb_device *dev , int type , int target , void *data ) ;
int usb_string(struct usb_device *dev , int index , char *buf , size_t size ) ;
int usb_clear_halt(struct usb_device *dev , int pipe ) ;
int usb_reset_configuration(struct usb_device *dev ) ;
int usb_set_interface(struct usb_device *dev , int interface , int alternate ) ;
void usb_reset_endpoint(struct usb_device *dev , unsigned int epaddr ) ;
int usb_driver_set_configuration(struct usb_device *udev , int config ) ;
int usb_sg_init(struct usb_sg_request *io , struct usb_device *dev , unsigned int pipe ,
                unsigned int period , struct scatterlist *sg , int nents , size_t length ,
                gfp_t mem_flags ) ;
void usb_sg_cancel(struct usb_sg_request *io ) ;
void usb_sg_wait(struct usb_sg_request *io ) ;
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 

  {
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
__inline static __u16 usb_maxpacket(struct usb_device *udev , int pipe , int is_out ) 
{ struct usb_host_endpoint *ep ;
  unsigned int epnum ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  {
  epnum = (unsigned int )((pipe >> 15) & 15);
  }
  if (is_out) {
    {
    __ret_warn_on = ! (! (pipe & 128));
    tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
    if (tmp) {
      {
      warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h",
                         1528);
      }
    }
    {
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    ep = udev->ep_out[epnum];
    }
  } else {
    {
    __ret_warn_on___0 = ! (! (! (pipe & 128)));
    tmp___0 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
    if (tmp___0) {
      {
      warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h",
                         1531);
      }
    }
    {
    __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    ep = udev->ep_in[epnum];
    }
  }
  if (! ep) {
    return ((unsigned short)0);
  }
  return (ep->desc.wMaxPacketSize);
}
}
void usb_register_notify(struct notifier_block *nb ) ;
void usb_unregister_notify(struct notifier_block *nb ) ;
__inline static struct usb_bus *hcd_to_bus(struct usb_hcd *hcd ) 
{ 

  {
  return (& hcd->self);
}
}
__inline static struct usb_hcd *bus_to_hcd(struct usb_bus *bus ) 
{ struct usb_bus  const  *__mptr ;

  {
  {
  __mptr = (struct usb_bus  const  *)bus;
  }
  return ((struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->self)));
}
}
int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd , struct urb *urb ) ;
int usb_hcd_check_unlink_urb(struct usb_hcd *hcd , struct urb *urb , int status ) ;
void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd , struct urb *urb ) ;
int usb_hcd_submit_urb(struct urb *urb , gfp_t mem_flags ) ;
int usb_hcd_unlink_urb(struct urb *urb , int status ) ;
void usb_hcd_giveback_urb(struct usb_hcd *hcd , struct urb *urb , int status ) ;
void usb_hcd_flush_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) ;
void usb_hcd_disable_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) ;
void usb_hcd_reset_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) ;
void usb_hcd_synchronize_unlinks(struct usb_device *udev ) ;
int usb_hcd_get_frame_number(struct usb_device *udev ) ;
struct usb_hcd *usb_create_hcd(struct hc_driver  const  *driver , struct device *dev ,
                               char const   *bus_name ) ;
struct usb_hcd *usb_get_hcd(struct usb_hcd *hcd ) ;
void usb_put_hcd(struct usb_hcd *hcd ) ;
int usb_add_hcd(struct usb_hcd *hcd , unsigned int irqnum , unsigned long irqflags ) ;
void usb_remove_hcd(struct usb_hcd *hcd ) ;
void usb_hcd_platform_shutdown(struct platform_device *dev ) ;
int usb_hcd_pci_probe(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
void usb_hcd_pci_remove(struct pci_dev *dev ) ;
int usb_hcd_pci_suspend(struct pci_dev *dev , pm_message_t message ) ;
int usb_hcd_pci_resume(struct pci_dev *dev ) ;
void usb_hcd_pci_shutdown(struct pci_dev *dev ) ;
int hcd_buffer_create(struct usb_hcd *hcd ) ;
void hcd_buffer_destroy(struct usb_hcd *hcd ) ;
void *hcd_buffer_alloc(struct usb_bus *bus , size_t size , gfp_t mem_flags , dma_addr_t *dma ) ;
void hcd_buffer_free(struct usb_bus *bus , size_t size , void *addr , dma_addr_t dma ) ;
irqreturn_t usb_hcd_irq(int irq , void *__hcd ) ;
void usb_hc_died(struct usb_hcd *hcd ) ;
void usb_hcd_poll_rh_status(struct usb_hcd *hcd ) ;
struct usb_device *usb_alloc_dev(struct usb_device *parent , struct usb_bus *bus ,
                                 unsigned int port1 ) ;
int usb_new_device(struct usb_device *udev ) ;
void usb_disconnect(struct usb_device **pdev ) ;
int usb_get_configuration(struct usb_device *dev ) ;
void usb_destroy_configuration(struct usb_device *dev ) ;
int usb_hub_clear_tt_buffer(struct urb *urb ) ;
void usb_ep0_reinit(struct usb_device *udev ) ;
long usb_calc_bus_time(int speed , int is_input , int isoc , int bytecount ) ;
void usb_set_device_state(struct usb_device *udev , enum usb_device_state new_state ) ;
struct list_head usb_bus_list ;
struct mutex usb_bus_list_lock ;
wait_queue_head_t usb_kill_urb_queue ;
extern int usb_find_interface_driver(struct usb_device *dev , struct usb_interface *interface ) ;
void usb_hcd_resume_root_hub(struct usb_hcd *hcd ) ;
void usb_root_hub_lost_power(struct usb_device *rhdev ) ;
int hcd_bus_suspend(struct usb_device *rhdev , pm_message_t msg ) ;
int hcd_bus_resume(struct usb_device *rhdev , pm_message_t msg ) ;
void usbfs_update_special(void) ;
int usbfs_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
void usbfs_cleanup(void) ;
struct usb_mon_operations *mon_ops ;
__inline static void usbmon_urb_submit(struct usb_bus *bus , struct urb *urb ) 
{ 

  {
  if (bus->monitored) {
    {
    (*(mon_ops->urb_submit))(bus, urb);
    }
  }
  return;
}
}
__inline static void usbmon_urb_submit_error(struct usb_bus *bus , struct urb *urb ,
                                             int error ) 
{ 

  {
  if (bus->monitored) {
    {
    (*(mon_ops->urb_submit_error))(bus, urb, error);
    }
  }
  return;
}
}
__inline static void usbmon_urb_complete(struct usb_bus *bus , struct urb *urb , int status ) 
{ 

  {
  if (bus->monitored) {
    {
    (*(mon_ops->urb_complete))(bus, urb, status);
    }
  }
  return;
}
}
int usb_mon_register(struct usb_mon_operations *ops ) ;
void usb_mon_deregister(void) ;
struct rw_semaphore ehci_cf_port_reset_rwsem ;
unsigned long usb_hcds_loaded ;
static size_t const   pool_max[4]  = {      (size_t const   )32,      (size_t const   )128,      (size_t const   )512,      (size_t const   )((1UL << 12) / 2UL)};
int hcd_buffer_create(struct usb_hcd *hcd ) 
{ char name[16] ;
  int i ;
  int size ;

  {
  if (! (hcd->self.controller)->dma_mask) {
    if (! ((hcd->driver)->flags & 2)) {
      return (0);
    }
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_222_continue: /* CIL Label */ ;
    if (! (i < 4)) {
      goto while_222_break;
    }
    {
    size = (int )pool_max[i];
    }
    if (! size) {
      goto __Cont;
    }
    {
    snprintf(name, (unsigned int )sizeof(name), "buffer-%d", size);
    hcd->pool[i] = dma_pool_create((char const   *)(name), hcd->self.controller, (unsigned int )size,
                                   (unsigned int )size, 0U);
    }
    if (! hcd->pool[i]) {
      {
      hcd_buffer_destroy(hcd);
      }
      return (-12);
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_222_break: /* CIL Label */ ;
  }
  return (0);
}
}
void hcd_buffer_destroy(struct usb_hcd *hcd ) 
{ int i ;
  struct dma_pool *pool ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_223_continue: /* CIL Label */ ;
    if (! (i < 4)) {
      goto while_223_break;
    }
    {
    pool = hcd->pool[i];
    }
    if (pool) {
      {
      dma_pool_destroy(pool);
      hcd->pool[i] = (struct dma_pool *)((void *)0);
      }
    }
    {
    i ++;
    }
  }
  while_223_break: /* CIL Label */ ;
  }
  return;
}
}
void *hcd_buffer_alloc(struct usb_bus *bus , size_t size , gfp_t mem_flags , dma_addr_t *dma ) 
{ struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
  tmp = bus_to_hcd(bus);
  hcd = tmp;
  }
  if (! (bus->controller)->dma_mask) {
    if (! ((hcd->driver)->flags & 2)) {
      {
      *dma = ~ 0U;
      tmp___0 = kmalloc(size, mem_flags);
      }
      return (tmp___0);
    }
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_224_continue: /* CIL Label */ ;
    if (! (i < 4)) {
      goto while_224_break;
    }
    if (size <= (size_t )pool_max[i]) {
      {
      tmp___1 = dma_pool_alloc(hcd->pool[i], mem_flags, dma);
      }
      return (tmp___1);
    }
    {
    i ++;
    }
  }
  while_224_break: /* CIL Label */ ;
  }
  {
  tmp___2 = dma_alloc_coherent(hcd->self.controller, size, dma, mem_flags);
  }
  return (tmp___2);
}
}
void hcd_buffer_free(struct usb_bus *bus , size_t size , void *addr , dma_addr_t dma ) 
{ struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  int i ;

  {
  {
  tmp = bus_to_hcd(bus);
  hcd = tmp;
  }
  if (! addr) {
    return;
  }
  if (! (bus->controller)->dma_mask) {
    if (! ((hcd->driver)->flags & 2)) {
      {
      kfree((void const   *)addr);
      }
      return;
    }
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_225_continue: /* CIL Label */ ;
    if (! (i < 4)) {
      goto while_225_break;
    }
    if (size <= (size_t )pool_max[i]) {
      {
      dma_pool_free(hcd->pool[i], addr, dma);
      }
      return;
    }
    {
    i ++;
    }
  }
  while_225_break: /* CIL Label */ ;
  }
  {
  dma_free_coherent(hcd->self.controller, size, addr, dma);
  }
  return;
}
}
static unsigned long __force_order___0  ;
__inline static unsigned long native_read_cr0___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static void native_write_cr0___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static void native_write_cr2___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static void native_write_cr3___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___0): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static void load_cr3___0(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___0((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___0(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___0();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___0((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___0(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___0();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___0((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___0(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_39 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___0(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___0(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___0(u64 ns ) ;
static union ktime  const  ktime_zero___0  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___0(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___0.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___0(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___0((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___0  ;
int usb_create_sysfs_dev_files(struct usb_device *udev ) ;
void usb_remove_sysfs_dev_files(struct usb_device *udev ) ;
int usb_create_sysfs_intf_files(struct usb_interface *intf ) ;
void usb_remove_sysfs_intf_files(struct usb_interface *intf ) ;
int usb_create_ep_devs(struct device *parent , struct usb_host_endpoint *endpoint ,
                       struct usb_device *udev ) ;
void usb_remove_ep_devs(struct usb_host_endpoint *endpoint ) ;
void usb_enable_endpoint(struct usb_device *dev , struct usb_host_endpoint *ep , bool reset_ep ) ;
void usb_enable_interface(struct usb_device *dev , struct usb_interface *intf , bool reset_eps ) ;
void usb_disable_endpoint(struct usb_device *dev , unsigned int epaddr , bool reset_hardware ) ;
void usb_disable_interface(struct usb_device *dev , struct usb_interface *intf , bool reset_hardware ) ;
void usb_release_interface_cache(struct kref *ref ) ;
void usb_disable_device(struct usb_device *dev , int skip_ep0 ) ;
int usb_deauthorize_device(struct usb_device *usb_dev ) ;
int usb_authorize_device(struct usb_device *usb_dev ) ;
void usb_detect_quirks(struct usb_device *udev ) ;
int usb_get_device_descriptor(struct usb_device *dev , unsigned int size ) ;
char *usb_cache_string(struct usb_device *udev , int index ) ;
int usb_set_configuration(struct usb_device *dev , int configuration ) ;
int usb_choose_configuration(struct usb_device *udev ) ;
void usb_kick_khubd(struct usb_device *hdev ) ;
int usb_match_device(struct usb_device *dev , struct usb_device_id  const  *id ) ;
void usb_forced_unbind_intf(struct usb_interface *intf ) ;
void usb_rebind_intf(struct usb_interface *intf ) ;
int usb_hub_init(void) ;
void usb_hub_cleanup(void) ;
int usb_major_init(void) ;
void usb_major_cleanup(void) ;
int usb_host_init(void) ;
void usb_host_cleanup(void) ;
int usb_suspend(struct device *dev , pm_message_t msg ) ;
int usb_resume(struct device *dev , pm_message_t msg ) ;
void usb_autosuspend_work(struct work_struct *work ) ;
void usb_autoresume_work(struct work_struct *work ) ;
int usb_port_suspend(struct usb_device *udev , pm_message_t msg ) ;
int usb_port_resume(struct usb_device *udev , pm_message_t msg ) ;
int usb_external_suspend_device(struct usb_device *udev , pm_message_t msg ) ;
int usb_external_resume_device(struct usb_device *udev , pm_message_t msg ) ;
__inline static void usb_pm_lock(struct usb_device *udev ) 
{ 

  {
  {
  mutex_lock(& udev->pm_mutex);
  }
  return;
}
}
__inline static void usb_pm_unlock(struct usb_device *udev ) 
{ 

  {
  {
  mutex_unlock(& udev->pm_mutex);
  }
  return;
}
}
void usb_autosuspend_device(struct usb_device *udev ) ;
void usb_try_autosuspend_device(struct usb_device *udev ) ;
int usb_autoresume_device(struct usb_device *udev ) ;
struct workqueue_struct *ksuspend_usb_wq ;
struct device_type usb_device_type ;
struct device_type usb_if_device_type ;
struct usb_device_driver usb_generic_driver ;
__inline static int is_usb_device(struct device  const  *dev ) 
{ 

  {
  return ((unsigned long )dev->type == (unsigned long )(& usb_device_type));
}
}
__inline static int is_usb_device_driver(struct device_driver *drv ) 
{ struct device_driver  const  *__mptr ;

  {
  {
  __mptr = (struct device_driver  const  *)drv;
  }
  return (((struct usbdrv_wrap *)((char *)__mptr - (unsigned int )(& ((struct usbdrv_wrap *)0)->driver)))->for_devices);
}
}
__inline static void mark_active(struct usb_interface *f ) 
{ 

  {
  {
  f->is_active = 1U;
  }
  return;
}
}
__inline static void mark_quiesced(struct usb_interface *f ) 
{ 

  {
  {
  f->is_active = 0U;
  }
  return;
}
}
__inline static int is_active(struct usb_interface  const  *f ) 
{ 

  {
  return ((int )f->is_active);
}
}
char const   *usbcore_name ;
struct attribute_group *usb_device_groups[3] ;
struct attribute_group *usb_interface_groups[3] ;
struct mutex usbfs_mutex ;
struct usb_driver usbfs_driver ;
struct file_operations  const  usbfs_devices_fops ;
struct file_operations  const  usbdev_file_operations ;
void usbfs_conn_disc_event(void) ;
int usb_devio_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
void usb_devio_cleanup(void) ;
void usb_notify_add_device(struct usb_device *udev ) ;
void usb_notify_remove_device(struct usb_device *udev ) ;
void usb_notify_add_bus(struct usb_bus *ubus ) ;
void usb_notify_remove_bus(struct usb_bus *ubus ) ;
__inline static char const   *plural(int n ) 
{ char const   *tmp ;

  {
  if (n == 1) {
    {
    tmp = "";
    }
  } else {
    {
    tmp = "s";
    }
  }
  return (tmp);
}
}
static int find_next_descriptor(unsigned char *buffer , int size , int dt1 , int dt2 ,
                                int *num_skipped ) 
{ struct usb_descriptor_header *h ;
  int n ;
  unsigned char *buffer0 ;

  {
  {
  n = 0;
  buffer0 = buffer;
  }
  {
  while (1) {
    while_226_continue: /* CIL Label */ ;
    if (! (size > 0)) {
      goto while_226_break;
    }
    {
    h = (struct usb_descriptor_header *)buffer;
    }
    if ((int )h->bDescriptorType == dt1) {
      goto while_226_break;
    } else {
      if ((int )h->bDescriptorType == dt2) {
        goto while_226_break;
      }
    }
    {
    buffer += (int )h->bLength;
    size -= (int )h->bLength;
    n ++;
    }
  }
  while_226_break: /* CIL Label */ ;
  }
  if (num_skipped) {
    {
    *num_skipped = n;
    }
  }
  return (buffer - buffer0);
}
}
static int usb_parse_endpoint(struct device *ddev , int cfgno , int inum , int asnum ,
                              struct usb_host_interface *ifp , int num_ep , unsigned char *buffer ,
                              int size ) 
{ unsigned char *buffer0 ;
  struct usb_endpoint_descriptor *d ;
  struct usb_host_endpoint *endpoint ;
  int n ;
  int i ;
  int j ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  struct device  const  *__mptr ;
  struct device  const  *__mptr___0 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  struct device  const  *__mptr___1 ;
  int tmp___9 ;
  unsigned int maxp ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  struct device  const  *__mptr___2 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
  {
  buffer0 = buffer;
  d = (struct usb_endpoint_descriptor *)buffer;
  buffer += (int )d->bLength;
  size -= (int )d->bLength;
  }
  if ((int )d->bLength >= 9) {
    {
    n = 9;
    }
  } else {
    if ((int )d->bLength >= 7) {
      {
      n = 7;
      }
    } else {
      {
      tmp = dev_name((struct device  const  *)ddev);
      tmp___0 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d interface %d altsetting %d has an invalid endpoint descriptor of length %d, skipping\n",
             tmp___0, tmp, cfgno, inum, asnum, d->bLength);
      }
      goto skip_to_next_endpoint_or_interface_descriptor;
    }
  }
  {
  i = (int )d->bEndpointAddress & -129;
  }
  if (i >= 16) {
    {
    tmp___1 = dev_name((struct device  const  *)ddev);
    tmp___2 = dev_driver_string((struct device  const  *)ddev);
    printk("<4>%s %s: config %d interface %d altsetting %d has an invalid endpoint with address 0x%X, skipping\n",
           tmp___2, tmp___1, cfgno, inum, asnum, d->bEndpointAddress);
    }
    goto skip_to_next_endpoint_or_interface_descriptor;
  } else {
    if (i == 0) {
      {
      tmp___1 = dev_name((struct device  const  *)ddev);
      tmp___2 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d interface %d altsetting %d has an invalid endpoint with address 0x%X, skipping\n",
             tmp___2, tmp___1, cfgno, inum, asnum, d->bEndpointAddress);
      }
      goto skip_to_next_endpoint_or_interface_descriptor;
    }
  }
  if ((int )ifp->desc.bNumEndpoints >= num_ep) {
    goto skip_to_next_endpoint_or_interface_descriptor;
  }
  {
  endpoint = ifp->endpoint + ifp->desc.bNumEndpoints;
  ifp->desc.bNumEndpoints = (__u8 )((int )ifp->desc.bNumEndpoints + 1);
  __memcpy((void *)(& endpoint->desc), (void const   *)d, (unsigned int )n);
  INIT_LIST_HEAD(& endpoint->urb_list);
  i = 0;
  j = 255;
  tmp___4 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)d);
  }
  if (tmp___4) {
    {
    i = 1;
    __mptr = (struct device  const  *)ddev;
    }
    if ((int )((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)))->speed == 3) {
      goto switch_227_3;
    } else {
      {
      goto switch_227_default;
      if (0) {
        switch_227_3: /* CIL Label */ 
        {
        n = fls((int )d->bInterval * 8);
        }
        if (n == 0) {
          {
          n = 9;
          }
        }
        {
        j = 16;
        }
        goto switch_227_break;
        switch_227_default: /* CIL Label */ 
        {
        n = 32;
        }
        goto switch_227_break;
      } else {
        switch_227_break: /* CIL Label */ ;
      }
      }
    }
  } else {
    {
    tmp___3 = usb_endpoint_xfer_isoc((struct usb_endpoint_descriptor  const  *)d);
    }
    if (tmp___3) {
      {
      i = 1;
      j = 16;
      __mptr___0 = (struct device  const  *)ddev;
      }
      if ((int )((struct usb_device *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_device *)0)->dev)))->speed == 3) {
        goto switch_228_3;
      } else {
        {
        goto switch_228_default;
        if (0) {
          switch_228_3: /* CIL Label */ 
          {
          n = 9;
          }
          goto switch_228_break;
          switch_228_default: /* CIL Label */ 
          {
          n = 6;
          }
          goto switch_228_break;
        } else {
          switch_228_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  if ((int )d->bInterval < i) {
    {
    tmp___5 = dev_name((struct device  const  *)ddev);
    tmp___6 = dev_driver_string((struct device  const  *)ddev);
    printk("<4>%s %s: config %d interface %d altsetting %d endpoint 0x%X has an invalid bInterval %d, changing to %d\n",
           tmp___6, tmp___5, cfgno, inum, asnum, d->bEndpointAddress, d->bInterval,
           n);
    endpoint->desc.bInterval = (unsigned char )n;
    }
  } else {
    if ((int )d->bInterval > j) {
      {
      tmp___5 = dev_name((struct device  const  *)ddev);
      tmp___6 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d interface %d altsetting %d endpoint 0x%X has an invalid bInterval %d, changing to %d\n",
             tmp___6, tmp___5, cfgno, inum, asnum, d->bEndpointAddress, d->bInterval,
             n);
      endpoint->desc.bInterval = (unsigned char )n;
      }
    }
  }
  {
  __mptr___1 = (struct device  const  *)ddev;
  }
  if ((unsigned int )((struct usb_device *)((char *)__mptr___1 - (unsigned int )(& ((struct usb_device *)0)->dev)))->speed == 1U) {
    {
    tmp___9 = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)d);
    }
    if (tmp___9) {
      {
      tmp___7 = dev_name((struct device  const  *)ddev);
      tmp___8 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d interface %d altsetting %d endpoint 0x%X is Bulk; changing to Interrupt\n",
             tmp___8, tmp___7, cfgno, inum, asnum, d->bEndpointAddress);
      endpoint->desc.bmAttributes = (unsigned char)3;
      endpoint->desc.bInterval = (unsigned char)1;
      }
      if ((int )endpoint->desc.wMaxPacketSize > 8) {
        {
        endpoint->desc.wMaxPacketSize = (unsigned short)8;
        }
      }
    }
  }
  {
  __mptr___2 = (struct device  const  *)ddev;
  }
  if ((unsigned int )((struct usb_device *)((char *)__mptr___2 - (unsigned int )(& ((struct usb_device *)0)->dev)))->speed == 3U) {
    {
    tmp___12 = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)d);
    }
    if (tmp___12) {
      {
      maxp = (unsigned int )((int )endpoint->desc.wMaxPacketSize & 2047);
      }
      if (maxp != 512U) {
        {
        tmp___10 = dev_name((struct device  const  *)ddev);
        tmp___11 = dev_driver_string((struct device  const  *)ddev);
        printk("<4>%s %s: config %d interface %d altsetting %d bulk endpoint 0x%X has invalid maxpacket %d\n",
               tmp___11, tmp___10, cfgno, inum, asnum, d->bEndpointAddress, maxp);
        }
      }
    }
  }
  {
  endpoint->extra = buffer;
  i = find_next_descriptor(buffer, size, 5, 4, & n);
  endpoint->extralen = i;
  }
  if (n > 0) {

  }
  return ((buffer - buffer0) + i);
  skip_to_next_endpoint_or_interface_descriptor: 
  {
  i = find_next_descriptor(buffer, size, 5, 4, (int *)((void *)0));
  }
  return ((buffer - buffer0) + i);
}
}
void usb_release_interface_cache(struct kref *ref ) 
{ struct usb_interface_cache *intfc ;
  struct kref  const  *__mptr ;
  int j ;
  struct usb_host_interface *alt ;

  {
  {
  __mptr = (struct kref  const  *)ref;
  intfc = (struct usb_interface_cache *)((char *)__mptr - (unsigned int )(& ((struct usb_interface_cache *)0)->ref));
  j = 0;
  }
  {
  while (1) {
    while_229_continue: /* CIL Label */ ;
    if (! ((unsigned int )j < intfc->num_altsetting)) {
      goto while_229_break;
    }
    {
    alt = & intfc->altsetting[j];
    kfree((void const   *)alt->endpoint);
    kfree((void const   *)alt->string);
    j ++;
    }
  }
  while_229_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)intfc);
  }
  return;
}
}
static int usb_parse_interface(struct device *ddev , int cfgno , struct usb_host_config *config ,
                               unsigned char *buffer , int size , u8 *inums , u8 *nalts ) 
{ unsigned char *buffer0 ;
  struct usb_interface_descriptor *d ;
  int inum ;
  int asnum ;
  struct usb_interface_cache *intfc ;
  struct usb_host_interface *alt ;
  int i ;
  int n ;
  int len ;
  int retval ;
  int num_ep ;
  int num_ep_orig ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
  buffer0 = buffer;
  d = (struct usb_interface_descriptor *)buffer;
  buffer += (int )d->bLength;
  size -= (int )d->bLength;
  }
  if ((int )d->bLength < 9) {
    goto skip_to_next_interface_descriptor;
  }
  {
  intfc = (struct usb_interface_cache *)((void *)0);
  inum = (int )d->bInterfaceNumber;
  i = 0;
  }
  {
  while (1) {
    while_230_continue: /* CIL Label */ ;
    if (! (i < (int )config->desc.bNumInterfaces)) {
      goto while_230_break;
    }
    if ((int )*(inums + i) == inum) {
      {
      intfc = config->intf_cache[i];
      }
      goto while_230_break;
    }
    {
    i ++;
    }
  }
  while_230_break: /* CIL Label */ ;
  }
  if (! intfc) {
    goto skip_to_next_interface_descriptor;
  } else {
    if (intfc->num_altsetting >= (unsigned int )*(nalts + i)) {
      goto skip_to_next_interface_descriptor;
    }
  }
  {
  asnum = (int )d->bAlternateSetting;
  i = 0;
  alt = & intfc->altsetting[0];
  }
  {
  while (1) {
    while_231_continue: /* CIL Label */ ;
    if (! ((unsigned int )i < intfc->num_altsetting)) {
      goto while_231_break;
    }
    if ((int )alt->desc.bAlternateSetting == asnum) {
      {
      tmp = dev_name((struct device  const  *)ddev);
      tmp___0 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: Duplicate descriptor for config %d interface %d altsetting %d, skipping\n",
             tmp___0, tmp, cfgno, inum, asnum);
      }
      goto skip_to_next_interface_descriptor;
    }
    {
    i ++;
    alt ++;
    }
  }
  while_231_break: /* CIL Label */ ;
  }
  {
  (intfc->num_altsetting) ++;
  __constant_memcpy((void *)(& alt->desc), (void const   *)d, 9U);
  alt->extra = buffer;
  i = find_next_descriptor(buffer, size, 5, 4, & n);
  alt->extralen = i;
  }
  if (n > 0) {

  }
  {
  buffer += i;
  size -= i;
  num_ep_orig = (int )alt->desc.bNumEndpoints;
  num_ep = num_ep_orig;
  alt->desc.bNumEndpoints = (unsigned char)0;
  }
  if (num_ep > 30) {
    {
    tmp___4 = dev_name((struct device  const  *)ddev);
    tmp___5 = dev_driver_string((struct device  const  *)ddev);
    printk("<4>%s %s: too many endpoints for config %d interface %d altsetting %d: %d, using maximum allowed: %d\n",
           tmp___5, tmp___4, cfgno, inum, asnum, num_ep, 30);
    num_ep = 30;
    }
  }
  if (num_ep > 0) {
    {
    len = (int )(sizeof(struct usb_host_endpoint ) * (unsigned long )num_ep);
    tmp___6 = kzalloc((unsigned int )len, 208U);
    alt->endpoint = (struct usb_host_endpoint *)tmp___6;
    }
    if (! alt->endpoint) {
      return (-12);
    }
  }
  {
  n = 0;
  }
  {
  while (1) {
    while_232_continue: /* CIL Label */ ;
    if (! (size > 0)) {
      goto while_232_break;
    }
    if ((int )((struct usb_descriptor_header *)buffer)->bDescriptorType == 4) {
      goto while_232_break;
    }
    {
    retval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt, num_ep, buffer, size);
    }
    if (retval < 0) {
      return (retval);
    }
    {
    n ++;
    buffer += retval;
    size -= retval;
    }
  }
  while_232_break: /* CIL Label */ ;
  }
  if (n != num_ep_orig) {
    {
    tmp___7 = plural(n);
    tmp___8 = dev_name((struct device  const  *)ddev);
    tmp___9 = dev_driver_string((struct device  const  *)ddev);
    printk("<4>%s %s: config %d interface %d altsetting %d has %d endpoint descriptor%s, different from the interface descriptor\'s value: %d\n",
           tmp___9, tmp___8, cfgno, inum, asnum, n, tmp___7, num_ep_orig);
    }
  }
  return (buffer - buffer0);
  skip_to_next_interface_descriptor: 
  {
  i = find_next_descriptor(buffer, size, 4, 4, (int *)((void *)0));
  }
  return ((buffer - buffer0) + i);
}
}
static int usb_parse_configuration(struct device *ddev , int cfgidx , struct usb_host_config *config ,
                                   unsigned char *buffer , int size ) 
{ unsigned char *buffer0 ;
  int cfgno ;
  int nintf ;
  int nintf_orig ;
  int i ;
  int j ;
  int n ;
  struct usb_interface_cache *intfc ;
  unsigned char *buffer2 ;
  int size2 ;
  struct usb_descriptor_header *header ;
  int len ;
  int retval ;
  u8 inums[32] ;
  u8 nalts[32] ;
  unsigned int iad_num ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  struct usb_interface_descriptor *d ;
  int inum ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  void *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;

  {
  {
  buffer0 = buffer;
  iad_num = 0U;
  __constant_memcpy((void *)(& config->desc), (void const   *)buffer, 9U);
  }
  if ((int )config->desc.bDescriptorType != 2) {
    {
    tmp = dev_name((struct device  const  *)ddev);
    tmp___0 = dev_driver_string((struct device  const  *)ddev);
    printk("<3>%s %s: invalid descriptor for config index %d: type = 0x%X, length = %d\n",
           tmp___0, tmp, cfgidx, config->desc.bDescriptorType, config->desc.bLength);
    }
    return (-22);
  } else {
    if ((int )config->desc.bLength < 9) {
      {
      tmp = dev_name((struct device  const  *)ddev);
      tmp___0 = dev_driver_string((struct device  const  *)ddev);
      printk("<3>%s %s: invalid descriptor for config index %d: type = 0x%X, length = %d\n",
             tmp___0, tmp, cfgidx, config->desc.bDescriptorType, config->desc.bLength);
      }
      return (-22);
    }
  }
  {
  cfgno = (int )config->desc.bConfigurationValue;
  buffer += (int )config->desc.bLength;
  size -= (int )config->desc.bLength;
  nintf_orig = (int )config->desc.bNumInterfaces;
  nintf = nintf_orig;
  }
  if (nintf > 32) {
    {
    tmp___1 = dev_name((struct device  const  *)ddev);
    tmp___2 = dev_driver_string((struct device  const  *)ddev);
    printk("<4>%s %s: config %d has too many interfaces: %d, using maximum allowed: %d\n",
           tmp___2, tmp___1, cfgno, nintf, 32);
    nintf = 32;
    }
  }
  {
  n = 0;
  buffer2 = buffer;
  size2 = size;
  }
  {
  while (1) {
    while_233_continue: /* CIL Label */ ;
    if (! (size2 > 0)) {
      goto while_233_break;
    }
    if ((unsigned long )size2 < sizeof(struct usb_descriptor_header )) {
      {
      tmp___3 = plural(size2);
      tmp___4 = dev_name((struct device  const  *)ddev);
      tmp___5 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d descriptor has %d excess byte%s, ignoring\n", tmp___5,
             tmp___4, cfgno, size2, tmp___3);
      }
      goto while_233_break;
    }
    {
    header = (struct usb_descriptor_header *)buffer2;
    }
    if ((int )header->bLength > size2) {
      {
      tmp___6 = dev_name((struct device  const  *)ddev);
      tmp___7 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d has an invalid descriptor of length %d, skipping remainder of the config\n",
             tmp___7, tmp___6, cfgno, header->bLength);
      }
      goto while_233_break;
    } else {
      if ((int )header->bLength < 2) {
        {
        tmp___6 = dev_name((struct device  const  *)ddev);
        tmp___7 = dev_driver_string((struct device  const  *)ddev);
        printk("<4>%s %s: config %d has an invalid descriptor of length %d, skipping remainder of the config\n",
               tmp___7, tmp___6, cfgno, header->bLength);
        }
        goto while_233_break;
      }
    }
    if ((int )header->bDescriptorType == 4) {
      {
      d = (struct usb_interface_descriptor *)header;
      }
      if ((int )d->bLength < 9) {
        {
        tmp___8 = dev_name((struct device  const  *)ddev);
        tmp___9 = dev_driver_string((struct device  const  *)ddev);
        printk("<4>%s %s: config %d has an invalid interface descriptor of length %d, skipping\n",
               tmp___9, tmp___8, cfgno, d->bLength);
        }
        goto __Cont;
      }
      {
      inum = (int )d->bInterfaceNumber;
      }
      if (inum >= nintf_orig) {
        {
        tmp___10 = dev_name((struct device  const  *)ddev);
        tmp___11 = dev_driver_string((struct device  const  *)ddev);
        printk("<4>%s %s: config %d has an invalid interface number: %d but max is %d\n",
               tmp___11, tmp___10, cfgno, inum, nintf_orig - 1);
        }
      }
      {
      i = 0;
      }
      {
      while (1) {
        while_234_continue: /* CIL Label */ ;
        if (! (i < n)) {
          goto while_234_break;
        }
        if ((int )inums[i] == inum) {
          goto while_234_break;
        }
        {
        i ++;
        }
      }
      while_234_break: /* CIL Label */ ;
      }
      if (i < n) {
        if ((int )nalts[i] < 255) {
          {
          nalts[i] = (u8 )((int )nalts[i] + 1);
          }
        }
      } else {
        if (n < 32) {
          {
          inums[n] = (unsigned char )inum;
          nalts[n] = (unsigned char)1;
          n ++;
          }
        }
      }
    } else {
      if ((int )header->bDescriptorType == 11) {
        if (iad_num == 16U) {
          {
          tmp___12 = dev_name((struct device  const  *)ddev);
          tmp___13 = dev_driver_string((struct device  const  *)ddev);
          printk("<4>%s %s: found more Interface Association Descriptors than allocated for in configuration %d\n",
                 tmp___13, tmp___12, cfgno);
          }
        } else {
          {
          config->intf_assoc[iad_num] = (struct usb_interface_assoc_descriptor *)header;
          iad_num ++;
          }
        }
      } else {
        if ((int )header->bDescriptorType == 1) {
          {
          tmp___14 = dev_name((struct device  const  *)ddev);
          tmp___15 = dev_driver_string((struct device  const  *)ddev);
          printk("<4>%s %s: config %d contains an unexpected descriptor of type 0x%X, skipping\n",
                 tmp___15, tmp___14, cfgno, header->bDescriptorType);
          }
        } else {
          if ((int )header->bDescriptorType == 2) {
            {
            tmp___14 = dev_name((struct device  const  *)ddev);
            tmp___15 = dev_driver_string((struct device  const  *)ddev);
            printk("<4>%s %s: config %d contains an unexpected descriptor of type 0x%X, skipping\n",
                   tmp___15, tmp___14, cfgno, header->bDescriptorType);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
    buffer2 += (int )header->bLength;
    size2 -= (int )header->bLength;
    }
  }
  while_233_break: /* CIL Label */ ;
  }
  {
  size = buffer2 - buffer;
  config->desc.wTotalLength = (unsigned short )(buffer2 - buffer0);
  }
  if (n != nintf) {
    {
    tmp___16 = plural(n);
    tmp___17 = dev_name((struct device  const  *)ddev);
    tmp___18 = dev_driver_string((struct device  const  *)ddev);
    printk("<4>%s %s: config %d has %d interface%s, different from the descriptor\'s value: %d\n",
           tmp___18, tmp___17, cfgno, n, tmp___16, nintf_orig);
    }
  } else {
    if (n == 0) {
      {
      tmp___19 = dev_name((struct device  const  *)ddev);
      tmp___20 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d has no interfaces?\n", tmp___20, tmp___19, cfgno);
      }
    }
  }
  {
  nintf = n;
  config->desc.bNumInterfaces = (unsigned char )nintf;
  i = 0;
  }
  {
  while (1) {
    while_235_continue: /* CIL Label */ ;
    if (! (i < nintf)) {
      goto while_235_break;
    }
    {
    j = 0;
    }
    {
    while (1) {
      while_236_continue: /* CIL Label */ ;
      if (! (j < nintf)) {
        goto while_236_break;
      }
      if ((int )inums[j] == i) {
        goto while_236_break;
      }
      {
      j ++;
      }
    }
    while_236_break: /* CIL Label */ ;
    }
    if (j >= nintf) {
      {
      tmp___21 = dev_name((struct device  const  *)ddev);
      tmp___22 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config %d has no interface number %d\n", tmp___22, tmp___21,
             cfgno, i);
      }
    }
    {
    i ++;
    }
  }
  while_235_break: /* CIL Label */ ;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_237_continue: /* CIL Label */ ;
    if (! (i < nintf)) {
      goto while_237_break;
    }
    {
    j = (int )nalts[i];
    }
    if (j > 128) {
      {
      tmp___23 = dev_name((struct device  const  *)ddev);
      tmp___24 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: too many alternate settings for config %d interface %d: %d, using maximum allowed: %d\n",
             tmp___24, tmp___23, cfgno, inums[i], j, 128);
      j = 128;
      nalts[i] = (unsigned char )j;
      }
    }
    {
    len = (int )(sizeof(*intfc) + sizeof(struct usb_host_interface ) * (unsigned long )j);
    tmp___25 = kzalloc((unsigned int )len, 208U);
    intfc = (struct usb_interface_cache *)tmp___25;
    config->intf_cache[i] = intfc;
    }
    if (! intfc) {
      return (-12);
    }
    {
    kref_init(& intfc->ref);
    i ++;
    }
  }
  while_237_break: /* CIL Label */ ;
  }
  {
  config->extra = buffer;
  i = find_next_descriptor(buffer, size, 4, 4, & n);
  config->extralen = i;
  }
  if (n > 0) {

  }
  {
  buffer += i;
  size -= i;
  }
  {
  while (1) {
    while_238_continue: /* CIL Label */ ;
    if (! (size > 0)) {
      goto while_238_break;
    }
    {
    retval = usb_parse_interface(ddev, cfgno, config, buffer, size, inums, nalts);
    }
    if (retval < 0) {
      return (retval);
    }
    {
    buffer += retval;
    size -= retval;
    }
  }
  while_238_break: /* CIL Label */ ;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_239_continue: /* CIL Label */ ;
    if (! (i < nintf)) {
      goto while_239_break;
    }
    {
    intfc = config->intf_cache[i];
    j = 0;
    }
    {
    while (1) {
      while_240_continue: /* CIL Label */ ;
      if (! ((unsigned int )j < intfc->num_altsetting)) {
        goto while_240_break;
      }
      {
      n = 0;
      }
      {
      while (1) {
        while_241_continue: /* CIL Label */ ;
        if (! ((unsigned int )n < intfc->num_altsetting)) {
          goto while_241_break;
        }
        if ((int )intfc->altsetting[n].desc.bAlternateSetting == j) {
          goto while_241_break;
        }
        {
        n ++;
        }
      }
      while_241_break: /* CIL Label */ ;
      }
      if ((unsigned int )n >= intfc->num_altsetting) {
        {
        tmp___29 = dev_name((struct device  const  *)ddev);
        tmp___30 = dev_driver_string((struct device  const  *)ddev);
        printk("<4>%s %s: config %d interface %d has no altsetting %d\n", tmp___30,
               tmp___29, cfgno, inums[i], j);
        }
      }
      {
      j ++;
      }
    }
    while_240_break: /* CIL Label */ ;
    }
    {
    i ++;
    }
  }
  while_239_break: /* CIL Label */ ;
  }
  return (0);
}
}
void usb_destroy_configuration(struct usb_device *dev ) 
{ int c ;
  int i ;
  struct usb_host_config *cf ;

  {
  if (! dev->config) {
    return;
  }
  if (dev->rawdescriptors) {
    {
    i = 0;
    }
    {
    while (1) {
      while_242_continue: /* CIL Label */ ;
      if (! (i < (int )dev->descriptor.bNumConfigurations)) {
        goto while_242_break;
      }
      {
      kfree((void const   *)*(dev->rawdescriptors + i));
      i ++;
      }
    }
    while_242_break: /* CIL Label */ ;
    }
    {
    kfree((void const   *)dev->rawdescriptors);
    dev->rawdescriptors = (char **)((void *)0);
    }
  }
  {
  c = 0;
  }
  {
  while (1) {
    while_243_continue: /* CIL Label */ ;
    if (! (c < (int )dev->descriptor.bNumConfigurations)) {
      goto while_243_break;
    }
    {
    cf = dev->config + c;
    kfree((void const   *)cf->string);
    i = 0;
    }
    {
    while (1) {
      while_244_continue: /* CIL Label */ ;
      if (! (i < (int )cf->desc.bNumInterfaces)) {
        goto while_244_break;
      }
      if (cf->intf_cache[i]) {
        {
        kref_put(& (cf->intf_cache[i])->ref, & usb_release_interface_cache);
        }
      }
      {
      i ++;
      }
    }
    while_244_break: /* CIL Label */ ;
    }
    {
    c ++;
    }
  }
  while_243_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)dev->config);
  dev->config = (struct usb_host_config *)((void *)0);
  }
  return;
}
}
int usb_get_configuration(struct usb_device *dev ) 
{ struct device *ddev ;
  int ncfg ;
  int result ;
  unsigned int cfgno ;
  unsigned int length ;
  unsigned char *buffer ;
  unsigned char *bigbuffer ;
  struct usb_config_descriptor *desc ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int _max1 ;
  int _max2 ;
  int tmp___12 ;
  void *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;

  {
  {
  ddev = & dev->dev;
  ncfg = (int )dev->descriptor.bNumConfigurations;
  result = 0;
  cfgno = 0U;
  }
  if (dev->authorized == 0U) {
    goto out_not_authorized;
  }
  {
  result = -12;
  }
  if (ncfg > 8) {
    {
    tmp = dev_name((struct device  const  *)ddev);
    tmp___0 = dev_driver_string((struct device  const  *)ddev);
    printk("<4>%s %s: too many configurations: %d, using maximum allowed: %d\n", tmp___0,
           tmp, ncfg, 8);
    ncfg = 8;
    dev->descriptor.bNumConfigurations = (unsigned char )ncfg;
    }
  }
  if (ncfg < 1) {
    {
    tmp___1 = dev_name((struct device  const  *)ddev);
    tmp___2 = dev_driver_string((struct device  const  *)ddev);
    printk("<3>%s %s: no configurations\n", tmp___2, tmp___1);
    }
    return (-22);
  }
  {
  length = (unsigned int )((unsigned long )ncfg * sizeof(struct usb_host_config ));
  tmp___3 = kzalloc(length, 208U);
  dev->config = (struct usb_host_config *)tmp___3;
  }
  if (! dev->config) {
    goto err2;
  }
  {
  length = (unsigned int )((unsigned long )ncfg * sizeof(char *));
  tmp___4 = kzalloc(length, 208U);
  dev->rawdescriptors = (char **)tmp___4;
  }
  if (! dev->rawdescriptors) {
    goto err2;
  }
  {
  tmp___5 = kmalloc(9U, 208U);
  buffer = (unsigned char *)tmp___5;
  }
  if (! buffer) {
    goto err2;
  }
  {
  desc = (struct usb_config_descriptor *)buffer;
  result = 0;
  }
  {
  while (1) {
    while_245_continue: /* CIL Label */ ;
    if (! (cfgno < (unsigned int )ncfg)) {
      goto while_245_break;
    }
    {
    result = usb_get_descriptor(dev, (unsigned char)2, (unsigned char )cfgno, (void *)buffer,
                                9);
    }
    if (result < 0) {
      {
      tmp___6 = dev_name((struct device  const  *)ddev);
      tmp___7 = dev_driver_string((struct device  const  *)ddev);
      printk("<3>%s %s: unable to read config index %d descriptor/%s: %d\n", tmp___7,
             tmp___6, cfgno, "start", result);
      tmp___8 = dev_name((struct device  const  *)ddev);
      tmp___9 = dev_driver_string((struct device  const  *)ddev);
      printk("<3>%s %s: chopping to %d config(s)\n", tmp___9, tmp___8, cfgno);
      dev->descriptor.bNumConfigurations = (unsigned char )cfgno;
      }
      goto while_245_break;
    } else {
      if (result < 4) {
        {
        tmp___10 = dev_name((struct device  const  *)ddev);
        tmp___11 = dev_driver_string((struct device  const  *)ddev);
        printk("<3>%s %s: config index %d descriptor too short (expected %i, got %i)\n",
               tmp___11, tmp___10, cfgno, 9, result);
        result = -22;
        }
        goto err;
      }
    }
    {
    _max1 = (int )desc->wTotalLength;
    _max2 = 9;
    }
    if (_max1 > _max2) {
      {
      tmp___12 = _max1;
      }
    } else {
      {
      tmp___12 = _max2;
      }
    }
    {
    length = (unsigned int )tmp___12;
    tmp___13 = kmalloc(length, 208U);
    bigbuffer = (unsigned char *)tmp___13;
    }
    if (! bigbuffer) {
      {
      result = -12;
      }
      goto err;
    }
    {
    result = usb_get_descriptor(dev, (unsigned char)2, (unsigned char )cfgno, (void *)bigbuffer,
                                (int )length);
    }
    if (result < 0) {
      {
      tmp___14 = dev_name((struct device  const  *)ddev);
      tmp___15 = dev_driver_string((struct device  const  *)ddev);
      printk("<3>%s %s: unable to read config index %d descriptor/%s\n", tmp___15,
             tmp___14, cfgno, "all");
      kfree((void const   *)bigbuffer);
      }
      goto err;
    }
    if ((unsigned int )result < length) {
      {
      tmp___16 = dev_name((struct device  const  *)ddev);
      tmp___17 = dev_driver_string((struct device  const  *)ddev);
      printk("<4>%s %s: config index %d descriptor too short (expected %i, got %i)\n",
             tmp___17, tmp___16, cfgno, length, result);
      length = (unsigned int )result;
      }
    }
    {
    *(dev->rawdescriptors + cfgno) = (char *)bigbuffer;
    result = usb_parse_configuration(& dev->dev, (int )cfgno, dev->config + cfgno,
                                     bigbuffer, (int )length);
    }
    if (result < 0) {
      {
      cfgno ++;
      }
      goto err;
    }
    {
    cfgno ++;
    }
  }
  while_245_break: /* CIL Label */ ;
  }
  {
  result = 0;
  }
  err: 
  {
  kfree((void const   *)buffer);
  }
  out_not_authorized: 
  {
  dev->descriptor.bNumConfigurations = (unsigned char )cfgno;
  }
  err2: 
  if (result == -12) {
    {
    tmp___18 = dev_name((struct device  const  *)ddev);
    tmp___19 = dev_driver_string((struct device  const  *)ddev);
    printk("<3>%s %s: out of memory\n", tmp___19, tmp___18);
    }
  }
  return (result);
}
}
static unsigned long __force_order___1  ;
__inline static unsigned long native_read_cr0___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static void native_write_cr0___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static void native_write_cr2___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static void native_write_cr3___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___1): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static void load_cr3___1(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___1((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___1(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___1();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___1((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___1(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___1();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___1((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___1(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_38 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___1(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___1(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
static struct lock_class_key __key___1  ;
__inline static ktime_t ns_to_ktime___1(u64 ns ) ;
static union ktime  const  ktime_zero___1  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___1(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___1.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___1(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___1((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
extern int fixup_exception(struct pt_regs *regs ) ;
extern int __get_user_1(void) ;
extern int __get_user_2(void) ;
extern int __get_user_4(void) ;
extern int __get_user_8(void) ;
extern int __get_user_bad(void) ;
extern void __put_user_bad(void) ;
extern void __put_user_1(void) ;
extern void __put_user_2(void) ;
extern void __put_user_4(void) ;
extern void __put_user_8(void) ;
extern struct movsl_mask movsl_mask ;
extern unsigned long __copy_to_user_ll(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll_nozero(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll_nocache(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll_nocache_nozero(void *to , void const   *from ,
                                                        unsigned long n ) ;
__inline static unsigned long __copy_to_user_inatomic(void *to , void const   *from ,
                                                      unsigned long n ) 
{ unsigned long ret ;
  unsigned long tmp ;

  {
  if (0) {
    if ((int )n == 1) {
      goto switch_246_1;
    } else {
      if ((int )n == 2) {
        goto switch_246_2;
      } else {
        if ((int )n == 4) {
          goto switch_246_4;
        } else {
          if (0) {
            switch_246_1: /* CIL Label */ 
            {
            while (1) {
              while_247_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_248_1;
              } else {
                if (1 == 2) {
                  goto switch_248_2;
                } else {
                  if (1 == 4) {
                    goto switch_248_4;
                  } else {
                    if (1 == 8) {
                      goto switch_248_8;
                    } else {
                      {
                      goto switch_248_default;
                      if (0) {
                        switch_248_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_248_break;
                        switch_248_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_248_break;
                        switch_248_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_248_break;
                        switch_248_8: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u8 *)from)),
                                             "r" ((u8 *)to), "i" (1), "0" (ret));
                        }
                        goto switch_248_break;
                        switch_248_default: /* CIL Label */ 
                        {
                        __put_user_bad();
                        }
                      } else {
                        switch_248_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_247_break;
            }
            while_247_break: /* CIL Label */ ;
            }
            return (ret);
            switch_246_2: /* CIL Label */ 
            {
            while (1) {
              while_249_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_250_1;
              } else {
                if (2 == 2) {
                  goto switch_250_2;
                } else {
                  if (2 == 4) {
                    goto switch_250_4;
                  } else {
                    if (2 == 8) {
                      goto switch_250_8;
                    } else {
                      {
                      goto switch_250_default;
                      if (0) {
                        switch_250_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_250_break;
                        switch_250_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_250_break;
                        switch_250_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_250_break;
                        switch_250_8: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u16 *)from)),
                                             "r" ((u16 *)to), "i" (2), "0" (ret));
                        }
                        goto switch_250_break;
                        switch_250_default: /* CIL Label */ 
                        {
                        __put_user_bad();
                        }
                      } else {
                        switch_250_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_249_break;
            }
            while_249_break: /* CIL Label */ ;
            }
            return (ret);
            switch_246_4: /* CIL Label */ 
            {
            while (1) {
              while_251_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_252_1;
              } else {
                if (4 == 2) {
                  goto switch_252_2;
                } else {
                  if (4 == 4) {
                    goto switch_252_4;
                  } else {
                    if (4 == 8) {
                      goto switch_252_8;
                    } else {
                      {
                      goto switch_252_default;
                      if (0) {
                        switch_252_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_252_break;
                        switch_252_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_252_break;
                        switch_252_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_252_break;
                        switch_252_8: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u32 *)from)),
                                             "r" ((u32 *)to), "i" (4), "0" (ret));
                        }
                        goto switch_252_break;
                        switch_252_default: /* CIL Label */ 
                        {
                        __put_user_bad();
                        }
                      } else {
                        switch_252_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_251_break;
            }
            while_251_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_246_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp = __copy_to_user_ll(to, from, n);
  }
  return (tmp);
}
}
__inline static unsigned long __copy_to_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
  might_fault();
  tmp = __copy_to_user_inatomic(to, from, n);
  }
  return (tmp);
}
}
__inline static unsigned long __copy_from_user_inatomic(void *to , void const   *from ,
                                                        unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  if (0) {
    if ((int )n == 1) {
      goto switch_253_1;
    } else {
      if ((int )n == 2) {
        goto switch_253_2;
      } else {
        if ((int )n == 4) {
          goto switch_253_4;
        } else {
          if (0) {
            switch_253_1: /* CIL Label */ 
            {
            while (1) {
              while_254_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_255_1;
              } else {
                if (1 == 2) {
                  goto switch_255_2;
                } else {
                  if (1 == 4) {
                    goto switch_255_4;
                  } else {
                    if (1 == 8) {
                      goto switch_255_8;
                    } else {
                      {
                      goto switch_255_default;
                      if (0) {
                        switch_255_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_255_break;
                        switch_255_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_255_break;
                        switch_255_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_255_break;
                        switch_255_8: /* CIL Label */ 
                        {
                        tmp = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_255_break;
                        switch_255_default: /* CIL Label */ 
                        {
                        tmp___0 = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_255_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_254_break;
            }
            while_254_break: /* CIL Label */ ;
            }
            return (ret);
            switch_253_2: /* CIL Label */ 
            {
            while (1) {
              while_256_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_257_1;
              } else {
                if (2 == 2) {
                  goto switch_257_2;
                } else {
                  if (2 == 4) {
                    goto switch_257_4;
                  } else {
                    if (2 == 8) {
                      goto switch_257_8;
                    } else {
                      {
                      goto switch_257_default;
                      if (0) {
                        switch_257_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_257_break;
                        switch_257_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_257_break;
                        switch_257_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_257_break;
                        switch_257_8: /* CIL Label */ 
                        {
                        tmp___1 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_257_break;
                        switch_257_default: /* CIL Label */ 
                        {
                        tmp___2 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_257_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_256_break;
            }
            while_256_break: /* CIL Label */ ;
            }
            return (ret);
            switch_253_4: /* CIL Label */ 
            {
            while (1) {
              while_258_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_259_1;
              } else {
                if (4 == 2) {
                  goto switch_259_2;
                } else {
                  if (4 == 4) {
                    goto switch_259_4;
                  } else {
                    if (4 == 8) {
                      goto switch_259_8;
                    } else {
                      {
                      goto switch_259_default;
                      if (0) {
                        switch_259_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_259_break;
                        switch_259_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_259_break;
                        switch_259_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_259_break;
                        switch_259_8: /* CIL Label */ 
                        {
                        tmp___3 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_259_break;
                        switch_259_default: /* CIL Label */ 
                        {
                        tmp___4 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_259_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_258_break;
            }
            while_258_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_253_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp___5 = __copy_from_user_ll_nozero(to, from, n);
  }
  return (tmp___5);
}
}
__inline static unsigned long __copy_from_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
  might_fault();
  }
  if (0) {
    if ((int )n == 1) {
      goto switch_260_1;
    } else {
      if ((int )n == 2) {
        goto switch_260_2;
      } else {
        if ((int )n == 4) {
          goto switch_260_4;
        } else {
          if (0) {
            switch_260_1: /* CIL Label */ 
            {
            while (1) {
              while_261_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_262_1;
              } else {
                if (1 == 2) {
                  goto switch_262_2;
                } else {
                  if (1 == 4) {
                    goto switch_262_4;
                  } else {
                    if (1 == 8) {
                      goto switch_262_8;
                    } else {
                      {
                      goto switch_262_default;
                      if (0) {
                        switch_262_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_262_break;
                        switch_262_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_262_break;
                        switch_262_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_262_break;
                        switch_262_8: /* CIL Label */ 
                        {
                        tmp = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_262_break;
                        switch_262_default: /* CIL Label */ 
                        {
                        tmp___0 = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_262_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_261_break;
            }
            while_261_break: /* CIL Label */ ;
            }
            return (ret);
            switch_260_2: /* CIL Label */ 
            {
            while (1) {
              while_263_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_264_1;
              } else {
                if (2 == 2) {
                  goto switch_264_2;
                } else {
                  if (2 == 4) {
                    goto switch_264_4;
                  } else {
                    if (2 == 8) {
                      goto switch_264_8;
                    } else {
                      {
                      goto switch_264_default;
                      if (0) {
                        switch_264_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_264_break;
                        switch_264_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_264_break;
                        switch_264_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_264_break;
                        switch_264_8: /* CIL Label */ 
                        {
                        tmp___1 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_264_break;
                        switch_264_default: /* CIL Label */ 
                        {
                        tmp___2 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_264_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_263_break;
            }
            while_263_break: /* CIL Label */ ;
            }
            return (ret);
            switch_260_4: /* CIL Label */ 
            {
            while (1) {
              while_265_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_266_1;
              } else {
                if (4 == 2) {
                  goto switch_266_2;
                } else {
                  if (4 == 4) {
                    goto switch_266_4;
                  } else {
                    if (4 == 8) {
                      goto switch_266_8;
                    } else {
                      {
                      goto switch_266_default;
                      if (0) {
                        switch_266_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_266_break;
                        switch_266_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_266_break;
                        switch_266_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_266_break;
                        switch_266_8: /* CIL Label */ 
                        {
                        tmp___3 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_266_break;
                        switch_266_default: /* CIL Label */ 
                        {
                        tmp___4 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_266_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_265_break;
            }
            while_265_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_260_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp___5 = __copy_from_user_ll(to, from, n);
  }
  return (tmp___5);
}
}
__inline static unsigned long __copy_from_user_nocache(void *to , void const   *from ,
                                                       unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
  might_fault();
  }
  if (0) {
    if ((int )n == 1) {
      goto switch_267_1;
    } else {
      if ((int )n == 2) {
        goto switch_267_2;
      } else {
        if ((int )n == 4) {
          goto switch_267_4;
        } else {
          if (0) {
            switch_267_1: /* CIL Label */ 
            {
            while (1) {
              while_268_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_269_1;
              } else {
                if (1 == 2) {
                  goto switch_269_2;
                } else {
                  if (1 == 4) {
                    goto switch_269_4;
                  } else {
                    if (1 == 8) {
                      goto switch_269_8;
                    } else {
                      {
                      goto switch_269_default;
                      if (0) {
                        switch_269_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_269_break;
                        switch_269_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_269_break;
                        switch_269_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_269_break;
                        switch_269_8: /* CIL Label */ 
                        {
                        tmp = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_269_break;
                        switch_269_default: /* CIL Label */ 
                        {
                        tmp___0 = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_269_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_268_break;
            }
            while_268_break: /* CIL Label */ ;
            }
            return (ret);
            switch_267_2: /* CIL Label */ 
            {
            while (1) {
              while_270_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_271_1;
              } else {
                if (2 == 2) {
                  goto switch_271_2;
                } else {
                  if (2 == 4) {
                    goto switch_271_4;
                  } else {
                    if (2 == 8) {
                      goto switch_271_8;
                    } else {
                      {
                      goto switch_271_default;
                      if (0) {
                        switch_271_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_271_break;
                        switch_271_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_271_break;
                        switch_271_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_271_break;
                        switch_271_8: /* CIL Label */ 
                        {
                        tmp___1 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_271_break;
                        switch_271_default: /* CIL Label */ 
                        {
                        tmp___2 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_271_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_270_break;
            }
            while_270_break: /* CIL Label */ ;
            }
            return (ret);
            switch_267_4: /* CIL Label */ 
            {
            while (1) {
              while_272_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_273_1;
              } else {
                if (4 == 2) {
                  goto switch_273_2;
                } else {
                  if (4 == 4) {
                    goto switch_273_4;
                  } else {
                    if (4 == 8) {
                      goto switch_273_8;
                    } else {
                      {
                      goto switch_273_default;
                      if (0) {
                        switch_273_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_273_break;
                        switch_273_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_273_break;
                        switch_273_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_273_break;
                        switch_273_8: /* CIL Label */ 
                        {
                        tmp___3 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_273_break;
                        switch_273_default: /* CIL Label */ 
                        {
                        tmp___4 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_273_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_272_break;
            }
            while_272_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_267_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp___5 = __copy_from_user_ll_nocache(to, from, n);
  }
  return (tmp___5);
}
}
__inline static unsigned long __copy_from_user_inatomic_nocache(void *to , void const   *from ,
                                                                unsigned long n ) 
{ unsigned long tmp ;

  {
  {
  tmp = __copy_from_user_ll_nocache_nozero(to, from, n);
  }
  return (tmp);
}
}
extern unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
extern unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) ;
extern long strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long __strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long strnlen_user(char const   *str , long n ) ;
extern unsigned long clear_user(void *mem , unsigned long len ) ;
extern unsigned long __clear_user(void *mem , unsigned long len ) ;
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 

  {
  if (p) {
    if (wait_address) {
      {
      (*(p->qproc))(filp, wait_address, p);
      }
    }
  }
  return;
}
}
__inline static void init_poll_funcptr(poll_table *pt , void (*qproc)(struct file * ,
                                                                      wait_queue_head_t * ,
                                                                      struct poll_table_struct * ) ) 
{ 

  {
  {
  pt->qproc = qproc;
  }
  return;
}
}
extern void poll_initwait(struct poll_wqueues *pwq ) ;
extern void poll_freewait(struct poll_wqueues *pwq ) ;
extern int poll_schedule_timeout(struct poll_wqueues *pwq , int state , ktime_t *expires ,
                                 unsigned long slack ) ;
__inline static int poll_schedule(struct poll_wqueues *pwq , int state ) 
{ int tmp ;

  {
  {
  tmp = poll_schedule_timeout(pwq, state, (ktime_t *)((void *)0), 0UL);
  }
  return (tmp);
}
}
__inline static int get_fd_set(unsigned long nr , void *ufdset , unsigned long *fdset ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  nr = (((nr + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long );
  }
  if (ufdset) {
    {
    tmp___1 = copy_from_user((void *)fdset, (void const   *)ufdset, nr);
    }
    if (tmp___1) {
      {
      tmp___0 = -14;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
    return (tmp___0);
  }
  {
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )nr);
  }
  return (0);
}
}
__inline static unsigned long set_fd_set(unsigned long nr , void *ufdset , unsigned long *fdset ) 
{ unsigned long tmp ;

  {
  if (ufdset) {
    {
    tmp = __copy_to_user(ufdset, (void const   *)fdset, (((nr + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long ));
    }
    return (tmp);
  }
  return (0UL);
}
}
__inline static void zero_fd_set(unsigned long nr , unsigned long *fdset ) 
{ 

  {
  {
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )((((nr + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long )));
  }
  return;
}
}
extern int do_select(int n , fd_set_bits *fds , struct timespec *end_time ) ;
extern int do_sys_poll(struct pollfd *ufds , unsigned int nfds , struct timespec *end_time ) ;
extern int core_sys_select(int n , fd_set *inp , fd_set *outp , fd_set *exp , struct timespec *end_time ) ;
extern int poll_select_set_timeout(struct timespec *to , long sec , long nsec ) ;
static char const   *format_topo  =    "\nT:  Bus=%2.2d Lev=%2.2d Prnt=%2.2d Port=%2.2d Cnt=%2.2d Dev#=%3d Spd=%3s MxCh=%2d\n";
static char const   *format_string_manufacturer  =    "S:  Manufacturer=%.100s\n";
static char const   *format_string_product  =    "S:  Product=%.100s\n";
static char const   *format_string_serialnumber  =    "S:  SerialNumber=%.100s\n";
static char const   *format_bandwidth  =    "B:  Alloc=%3d/%3d us (%2d%%), #Int=%3d, #Iso=%3d\n";
static char const   *format_device1  =    "D:  Ver=%2x.%02x Cls=%02x(%-5s) Sub=%02x Prot=%02x MxPS=%2d #Cfgs=%3d\n";
static char const   *format_device2  =    "P:  Vendor=%04x ProdID=%04x Rev=%2x.%02x\n";
static char const   *format_config  =    "C:%c #Ifs=%2d Cfg#=%2d Atr=%02x MxPwr=%3dmA\n";
static char const   *format_iad  =    "A:  FirstIf#=%2d IfCount=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x\n";
static char const   *format_iface  =    "I:%c If#=%2d Alt=%2d #EPs=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x Driver=%s\n";
static char const   *format_endpt  =    "E:  Ad=%02x(%c) Atr=%02x(%-4s) MxPS=%4d Ivl=%d%cs\n";
static wait_queue_head_t deviceconndiscwq  =    {{{0U}},
    {& deviceconndiscwq.task_list, & deviceconndiscwq.task_list}};
static unsigned int conndiscevcnt  ;
static struct class_info  const  clas_info[16]  = 
  {      {0, (char *)">ifc"}, 
        {1, (char *)"audio"}, 
        {2, (char *)"comm."}, 
        {3, (char *)"HID"}, 
        {9, (char *)"hub"}, 
        {5, (char *)"PID"}, 
        {7, (char *)"print"}, 
        {8, (char *)"stor."}, 
        {10, (char *)"data"}, 
        {254, (char *)"app."}, 
        {255, (char *)"vend."}, 
        {6, (char *)"still"}, 
        {11, (char *)"scard"}, 
        {13, (char *)"c-sec"}, 
        {14, (char *)"video"}, 
        {-1, (char *)"unk."}};
void usbfs_conn_disc_event(void) 
{ 

  {
  {
  conndiscevcnt ++;
  __wake_up(& deviceconndiscwq, 3U, 1, (void *)0);
  }
  return;
}
}
static char const   *class_decode(int class ) 
{ int ix ;

  {
  {
  ix = 0;
  }
  {
  while (1) {
    while_274_continue: /* CIL Label */ ;
    if (! (clas_info[ix].class != -1)) {
      goto while_274_break;
    }
    if (clas_info[ix].class == (int const   )class) {
      goto while_274_break;
    }
    {
    ix ++;
    }
  }
  while_274_break: /* CIL Label */ ;
  }
  return ((char const   *)clas_info[ix].class_name);
}
}
static char *usb_dump_endpoint_descriptor(int speed , char *start , char *end , struct usb_endpoint_descriptor  const  *desc ) 
{ char dir ;
  char unit ;
  char *type ;
  unsigned int interval ;
  unsigned int bandwidth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  bandwidth = 1U;
  }
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  {
  tmp___0 = usb_endpoint_dir_in(desc);
  }
  if (tmp___0) {
    {
    dir = (char )'I';
    }
  } else {
    {
    dir = (char )'O';
    }
  }
  if (speed == 3) {
    if (((int )((unsigned short )desc->wMaxPacketSize) & (3 << 11)) == 1 << 11) {
      goto switch_275_exp_0;
    } else {
      if (((int )((unsigned short )desc->wMaxPacketSize) & (3 << 11)) == 2 << 11) {
        goto switch_275_exp_1;
      } else {
        if (0) {
          switch_275_exp_0: /* CIL Label */ 
          {
          bandwidth = 2U;
          }
          goto switch_275_break;
          switch_275_exp_1: /* CIL Label */ 
          {
          bandwidth = 3U;
          }
          goto switch_275_break;
        } else {
          switch_275_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
  tmp___1 = usb_endpoint_type(desc);
  }
  if (tmp___1 == 0) {
    goto switch_276_0;
  } else {
    if (tmp___1 == 1) {
      goto switch_276_1;
    } else {
      if (tmp___1 == 2) {
        goto switch_276_2;
      } else {
        if (tmp___1 == 3) {
          goto switch_276_3;
        } else {
          {
          goto switch_276_default;
          if (0) {
            switch_276_0: /* CIL Label */ 
            {
            type = (char *)"Ctrl";
            }
            if (speed == 3) {
              {
              interval = (unsigned int )desc->bInterval;
              }
            } else {
              {
              interval = 0U;
              }
            }
            {
            dir = (char )'B';
            }
            goto switch_276_break;
            switch_276_1: /* CIL Label */ 
            {
            type = (char *)"Isoc";
            interval = (unsigned int )(1 << ((int const   )desc->bInterval - 1));
            }
            goto switch_276_break;
            switch_276_2: /* CIL Label */ 
            {
            type = (char *)"Bulk";
            }
            if (speed == 3) {
              if ((int )dir == 79) {
                {
                interval = (unsigned int )desc->bInterval;
                }
              } else {
                {
                interval = 0U;
                }
              }
            } else {
              {
              interval = 0U;
              }
            }
            goto switch_276_break;
            switch_276_3: /* CIL Label */ 
            {
            type = (char *)"Int.";
            }
            if (speed == 3) {
              {
              interval = (unsigned int )(1 << ((int const   )desc->bInterval - 1));
              }
            } else {
              {
              interval = (unsigned int )desc->bInterval;
              }
            }
            goto switch_276_break;
            switch_276_default: /* CIL Label */ 
            {

            }
            return (start);
          } else {
            switch_276_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if (speed == 3) {
    {
    tmp___2 = 125;
    }
  } else {
    {
    tmp___2 = 1000;
    }
  }
  {
  interval *= (unsigned int )tmp___2;
  }
  if (interval % 1000U) {
    {
    unit = (char )'u';
    }
  } else {
    {
    unit = (char )'m';
    interval /= 1000U;
    }
  }
  {
  tmp___3 = sprintf(start, format_endpt, desc->bEndpointAddress, dir, desc->bmAttributes,
                    type, (unsigned int )((int )((unsigned short )desc->wMaxPacketSize) & 2047) * bandwidth,
                    interval, unit);
  start += tmp___3;
  }
  return (start);
}
}
static char *usb_dump_interface_descriptor(char *start , char *end , struct usb_interface_cache  const  *intfc ,
                                           struct usb_interface  const  *iface , int setno ) 
{ struct usb_interface_descriptor  const  *desc ;
  char const   *driver_name ;
  int active ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  driver_name = "";
  active = 0;
  }
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  {
  desc = & intfc->altsetting[setno].desc;
  }
  if (iface) {
    if (iface->dev.driver) {
      {
      driver_name = (iface->dev.driver)->name;
      }
    } else {
      {
      driver_name = "(none)";
      }
    }
    {
    active = (unsigned long )desc == (unsigned long )(& (iface->cur_altsetting)->desc);
    }
  }
  {
  tmp = class_decode((int )desc->bInterfaceClass);
  }
  if (active) {
    {
    tmp___0 = '*';
    }
  } else {
    {
    tmp___0 = ' ';
    }
  }
  {
  tmp___1 = sprintf(start, format_iface, tmp___0, desc->bInterfaceNumber, desc->bAlternateSetting,
                    desc->bNumEndpoints, desc->bInterfaceClass, tmp, desc->bInterfaceSubClass,
                    desc->bInterfaceProtocol, driver_name);
  start += tmp___1;
  }
  return (start);
}
}
static char *usb_dump_interface(int speed , char *start , char *end , struct usb_interface_cache  const  *intfc ,
                                struct usb_interface  const  *iface , int setno ) 
{ struct usb_host_interface  const  *desc ;
  int i ;

  {
  {
  desc = (struct usb_host_interface  const  *)(& intfc->altsetting[setno]);
  start = usb_dump_interface_descriptor(start, end, intfc, iface, setno);
  i = 0;
  }
  {
  while (1) {
    while_277_continue: /* CIL Label */ ;
    if (! (i < (int )desc->desc.bNumEndpoints)) {
      goto while_277_break;
    }
    if ((unsigned long )start > (unsigned long )end) {
      return (start);
    }
    {
    start = usb_dump_endpoint_descriptor(speed, start, end, (struct usb_endpoint_descriptor  const  *)(& (desc->endpoint + i)->desc));
    i ++;
    }
  }
  while_277_break: /* CIL Label */ ;
  }
  return (start);
}
}
static char *usb_dump_iad_descriptor(char *start , char *end , struct usb_interface_assoc_descriptor  const  *iad ) 
{ char const   *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  {
  tmp = class_decode((int )iad->bFunctionClass);
  tmp___0 = sprintf(start, format_iad, iad->bFirstInterface, iad->bInterfaceCount,
                    iad->bFunctionClass, tmp, iad->bFunctionSubClass, iad->bFunctionProtocol);
  start += tmp___0;
  }
  return (start);
}
}
static char *usb_dump_config_descriptor(char *start , char *end , struct usb_config_descriptor  const  *desc ,
                                        int active ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  if (active) {
    {
    tmp = '*';
    }
  } else {
    {
    tmp = ' ';
    }
  }
  {
  tmp___0 = sprintf(start, format_config, tmp, desc->bNumInterfaces, desc->bConfigurationValue,
                    desc->bmAttributes, (int const   )desc->bMaxPower * 2);
  start += tmp___0;
  }
  return (start);
}
}
static char *usb_dump_config(int speed , char *start , char *end , struct usb_host_config  const  *config ,
                             int active ) 
{ int i ;
  int j ;
  struct usb_interface_cache *intfc ;
  struct usb_interface *interface ;
  int tmp ;

  {
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  if (! config) {
    {
    tmp = sprintf(start, "(null Cfg. desc.)\n");
    }
    return (start + tmp);
  }
  {
  start = usb_dump_config_descriptor(start, end, & config->desc, active);
  i = 0;
  }
  {
  while (1) {
    while_278_continue: /* CIL Label */ ;
    if (! (i < 16)) {
      goto while_278_break;
    }
    if ((unsigned long )config->intf_assoc[i] == (unsigned long )((void *)0)) {
      goto while_278_break;
    }
    {
    start = usb_dump_iad_descriptor(start, end, (struct usb_interface_assoc_descriptor  const  *)config->intf_assoc[i]);
    i ++;
    }
  }
  while_278_break: /* CIL Label */ ;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_279_continue: /* CIL Label */ ;
    if (! (i < (int )config->desc.bNumInterfaces)) {
      goto while_279_break;
    }
    {
    intfc = config->intf_cache[i];
    interface = config->interface[i];
    j = 0;
    }
    {
    while (1) {
      while_280_continue: /* CIL Label */ ;
      if (! ((unsigned int )j < intfc->num_altsetting)) {
        goto while_280_break;
      }
      if ((unsigned long )start > (unsigned long )end) {
        return (start);
      }
      {
      start = usb_dump_interface(speed, start, end, (struct usb_interface_cache  const  *)intfc,
                                 (struct usb_interface  const  *)interface, j);
      j ++;
      }
    }
    while_280_break: /* CIL Label */ ;
    }
    {
    i ++;
    }
  }
  while_279_break: /* CIL Label */ ;
  }
  return (start);
}
}
static char *usb_dump_device_descriptor(char *start , char *end , struct usb_device_descriptor  const  *desc ) 
{ u16 bcdUSB ;
  u16 bcdDevice ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  bcdUSB = (unsigned short )desc->bcdUSB;
  bcdDevice = (unsigned short )desc->bcdDevice;
  }
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  {
  tmp = class_decode((int )desc->bDeviceClass);
  tmp___0 = sprintf(start, format_device1, (int )bcdUSB >> 8, (int )bcdUSB & 255,
                    desc->bDeviceClass, tmp, desc->bDeviceSubClass, desc->bDeviceProtocol,
                    desc->bMaxPacketSize0, desc->bNumConfigurations);
  start += tmp___0;
  }
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  {
  tmp___1 = sprintf(start, format_device2, (unsigned short )desc->idVendor, (unsigned short )desc->idProduct,
                    (int )bcdDevice >> 8, (int )bcdDevice & 255);
  start += tmp___1;
  }
  return (start);
}
}
static char *usb_dump_device_strings(char *start , char *end , struct usb_device *dev ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  if (dev->manufacturer) {
    {
    tmp = sprintf(start, format_string_manufacturer, dev->manufacturer);
    start += tmp;
    }
  }
  if ((unsigned long )start > (unsigned long )end) {
    goto out;
  }
  if (dev->product) {
    {
    tmp___0 = sprintf(start, format_string_product, dev->product);
    start += tmp___0;
    }
  }
  if ((unsigned long )start > (unsigned long )end) {
    goto out;
  }
  if (dev->serial) {
    {
    tmp___1 = sprintf(start, format_string_serialnumber, dev->serial);
    start += tmp___1;
    }
  }
  out: 
  return (start);
}
}
static char *usb_dump_desc(char *start , char *end , struct usb_device *dev ) 
{ int i ;

  {
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  {
  start = usb_dump_device_descriptor(start, end, (struct usb_device_descriptor  const  *)(& dev->descriptor));
  }
  if ((unsigned long )start > (unsigned long )end) {
    return (start);
  }
  {
  start = usb_dump_device_strings(start, end, dev);
  i = 0;
  }
  {
  while (1) {
    while_281_continue: /* CIL Label */ ;
    if (! (i < (int )dev->descriptor.bNumConfigurations)) {
      goto while_281_break;
    }
    if ((unsigned long )start > (unsigned long )end) {
      return (start);
    }
    {
    start = usb_dump_config((int )dev->speed, start, end, (struct usb_host_config  const  *)(dev->config + i),
                            (unsigned long )(dev->config + i) == (unsigned long )dev->actconfig);
    i ++;
    }
  }
  while_281_break: /* CIL Label */ ;
  }
  return (start);
}
}
static ssize_t usb_device_dump(char **buffer , size_t *nbytes , loff_t *skip_bytes ,
                               loff_t *file_offset , struct usb_device *usbdev , struct usb_bus *bus ,
                               int level , int index , int count ) 
{ int chix ;
  int ret ;
  int cnt ;
  int parent_devnum ;
  char *pages_start ;
  char *data_end ;
  char *speed ;
  unsigned int length ;
  ssize_t total_written ;
  unsigned long tmp ;
  int tmp___0 ;
  int max ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  struct usb_device *childdev ;

  {
  {
  cnt = 0;
  parent_devnum = 0;
  total_written = 0;
  }
  if (*nbytes <= 0U) {
    return (0);
  }
  if (level > 6) {
    return (0);
  }
  {
  tmp = __get_free_pages(208U, 1U);
  pages_start = (char *)tmp;
  }
  if (! pages_start) {
    return (-12);
  }
  if (usbdev->parent) {
    if ((usbdev->parent)->devnum != -1) {
      {
      parent_devnum = (usbdev->parent)->devnum;
      }
    }
  }
  if ((int )usbdev->speed == 1) {
    goto switch_282_1;
  } else {
    if ((int )usbdev->speed == 0) {
      goto switch_282_0;
    } else {
      if ((int )usbdev->speed == 2) {
        goto switch_282_0;
      } else {
        if ((int )usbdev->speed == 3) {
          goto switch_282_3;
        } else {
          {
          goto switch_282_default;
          if (0) {
            switch_282_1: /* CIL Label */ 
            {
            speed = (char *)"1.5";
            }
            goto switch_282_break;
            switch_282_0: /* CIL Label */ 
            switch_282_2: /* CIL Label */ 
            {
            speed = (char *)"12 ";
            }
            goto switch_282_break;
            switch_282_3: /* CIL Label */ 
            {
            speed = (char *)"480";
            }
            goto switch_282_break;
            switch_282_default: /* CIL Label */ 
            {
            speed = (char *)"?? ";
            }
          } else {
            switch_282_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  tmp___0 = sprintf(pages_start, format_topo, bus->busnum, level, parent_devnum, index,
                    count, usbdev->devnum, speed, usbdev->maxchild);
  data_end = pages_start + tmp___0;
  }
  if (level == 0) {
    if ((unsigned int )usbdev->speed == 3U) {
      {
      max = 800;
      }
    } else {
      {
      max = 900;
      }
    }
    {
    tmp___1 = sprintf(data_end, format_bandwidth, bus->bandwidth_allocated, max, (100 * bus->bandwidth_allocated + max / 2) / max,
                      bus->bandwidth_int_reqs, bus->bandwidth_isoc_reqs);
    data_end += tmp___1;
    }
  }
  {
  data_end = usb_dump_desc(data_end, (pages_start + 2UL * (1UL << 12)) - 256, usbdev);
  }
  if ((unsigned long )data_end > (unsigned long )((pages_start + 2UL * (1UL << 12)) - 256)) {
    {
    tmp___2 = sprintf(data_end, "(truncated)\n");
    data_end += tmp___2;
    }
  }
  {
  length = (unsigned int )(data_end - pages_start);
  }
  if ((loff_t )length > *skip_bytes) {
    {
    length = (unsigned int )((loff_t )length - *skip_bytes);
    }
    if (length > *nbytes) {
      {
      length = *nbytes;
      }
    }
    {
    tmp___3 = copy_to_user((void *)*buffer, (void const   *)(pages_start + *skip_bytes),
                           (unsigned long )length);
    }
    if (tmp___3) {
      {
      free_pages((unsigned long )pages_start, 1U);
      }
      return (-14);
    }
    {
    *nbytes -= length;
    *file_offset += (loff_t )length;
    total_written = (int )((unsigned int )total_written + length);
    *buffer += length;
    *skip_bytes = 0LL;
    }
  } else {
    {
    *skip_bytes -= (loff_t )length;
    }
  }
  {
  free_pages((unsigned long )pages_start, 1U);
  chix = 0;
  }
  {
  while (1) {
    while_283_continue: /* CIL Label */ ;
    if (! (chix < usbdev->maxchild)) {
      goto while_283_break;
    }
    {
    childdev = usbdev->children[chix];
    }
    if (childdev) {
      {
      down(& childdev->dev.sem);
      cnt ++;
      ret = usb_device_dump(buffer, nbytes, skip_bytes, file_offset, childdev, bus,
                            level + 1, chix, cnt);
      up(& childdev->dev.sem);
      }
      if (ret == -14) {
        return (total_written);
      }
      {
      total_written += ret;
      }
    }
    {
    chix ++;
    }
  }
  while_283_break: /* CIL Label */ ;
  }
  return (total_written);
}
}
static ssize_t usb_device_read(struct file *file , char *buf , size_t nbytes , loff_t *ppos ) 
{ struct usb_bus *bus ;
  ssize_t ret ;
  ssize_t total_written ;
  loff_t skip_bytes ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  total_written = 0;
  skip_bytes = *ppos;
  }
  if (*ppos < 0LL) {
    return (-22);
  }
  if (nbytes <= 0U) {
    return (0);
  }
  {
  tmp = current_thread_info();
  __asm__  ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (buf),
            "g" ((long )nbytes), "rm" (tmp->addr_limit.seg));
  }
  if (flag == 0UL) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
  if (! tmp___1) {
    return (-14);
  }
  {
  mutex_lock(& usb_bus_list_lock);
  __mptr = (struct list_head  const  *)usb_bus_list.next;
  bus = (struct usb_bus *)((char *)__mptr - (unsigned int )(& ((struct usb_bus *)0)->bus_list));
  }
  {
  while (1) {
    while_284_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)bus->bus_list.next);
    }
    if (! ((unsigned long )(& bus->bus_list) != (unsigned long )(& usb_bus_list))) {
      goto while_284_break;
    }
    if (! bus->root_hub) {
      goto __Cont;
    }
    {
    down(& (bus->root_hub)->dev.sem);
    ret = usb_device_dump(& buf, & nbytes, & skip_bytes, ppos, bus->root_hub, bus,
                          0, 0, 0);
    up(& (bus->root_hub)->dev.sem);
    }
    if (ret < 0) {
      {
      mutex_unlock(& usb_bus_list_lock);
      }
      return (ret);
    }
    {
    total_written += ret;
    }
    __Cont: /* CIL Label */ 
    {
    __mptr___0 = (struct list_head  const  *)bus->bus_list.next;
    bus = (struct usb_bus *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_bus *)0)->bus_list));
    }
  }
  while_284_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& usb_bus_list_lock);
  }
  return (total_written);
}
}
static unsigned int usb_device_poll(struct file *file , struct poll_table_struct *wait ) 
{ struct usb_device_status *st ;
  unsigned int mask ;
  void *tmp ;

  {
  {
  st = (struct usb_device_status *)file->private_data;
  mask = 0U;
  lock_kernel();
  }
  if (! st) {
    {
    tmp = kmalloc((unsigned int )sizeof(struct usb_device_status ), 208U);
    st = (struct usb_device_status *)tmp;
    }
    if (file->private_data) {
      {
      kfree((void const   *)st);
      st = (struct usb_device_status *)file->private_data;
      }
      goto lost_race;
    }
    if (! st) {
      {
      unlock_kernel();
      }
      return (1U);
    }
    {
    st->lastev = conndiscevcnt;
    file->private_data = (void *)st;
    mask = 1U;
    }
  }
  lost_race: 
  if (file->f_mode & 1U) {
    {
    poll_wait(file, & deviceconndiscwq, wait);
    }
  }
  if (st->lastev != conndiscevcnt) {
    {
    mask |= 1U;
    }
  }
  {
  st->lastev = conndiscevcnt;
  unlock_kernel();
  }
  return (mask);
}
}
static int usb_device_open(struct inode *inode , struct file *file ) 
{ 

  {
  {
  file->private_data = (void *)0;
  }
  return (0);
}
}
static int usb_device_release(struct inode *inode , struct file *file ) 
{ 

  {
  {
  kfree((void const   *)file->private_data);
  file->private_data = (void *)0;
  }
  return (0);
}
}
static loff_t usb_device_lseek(struct file *file , loff_t offset , int orig ) 
{ loff_t ret ;

  {
  {
  lock_kernel();
  }
  if (orig == 0) {
    goto switch_285_0;
  } else {
    if (orig == 1) {
      goto switch_285_1;
    } else {
      if (orig == 2) {
        goto switch_285_2;
      } else {
        {
        goto switch_285_2;
        if (0) {
          switch_285_0: /* CIL Label */ 
          {
          file->f_pos = offset;
          ret = file->f_pos;
          }
          goto switch_285_break;
          switch_285_1: /* CIL Label */ 
          {
          file->f_pos += offset;
          ret = file->f_pos;
          }
          goto switch_285_break;
          switch_285_2: /* CIL Label */ 
          switch_285_default: /* CIL Label */ 
          {
          ret = -22LL;
          }
        } else {
          switch_285_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  {
  unlock_kernel();
  }
  return (ret);
}
}
struct file_operations  const  usbfs_devices_fops  = 
     {(struct module *)0, & usb_device_lseek, & usb_device_read, (ssize_t (*)(struct file * ,
                                                                            char const   * ,
                                                                            size_t  ,
                                                                            loff_t * ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, & usb_device_poll,
    (int (*)(struct inode * , struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & usb_device_open, (int (*)(struct file * ,
                                                                                      fl_owner_t id ))0,
    & usb_device_release, (int (*)(struct file * , struct dentry * , int datasync ))0,
    (int (*)(struct kiocb * , int datasync ))0, (int (*)(int  , struct file * , int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct page * ,
                                                                         int  , size_t  ,
                                                                         loff_t * ,
                                                                         int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0};
static unsigned long __force_order___2  ;
__inline static unsigned long native_read_cr0___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static void native_write_cr0___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static void native_write_cr2___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static void native_write_cr3___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___2): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static void load_cr3___2(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___2((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___2(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___2();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___2((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___2(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___2();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___2((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___2(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_38___0 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___2(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___2(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
static struct lock_class_key __key___2  ;
__inline static ktime_t ns_to_ktime___2(u64 ns ) ;
static union ktime  const  ktime_zero___2  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___2(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___2.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___2(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___2((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
extern void cdev_init(struct cdev * , struct file_operations  const  * ) ;
extern struct cdev *cdev_alloc(void) ;
extern void cdev_put(struct cdev *p ) ;
extern int cdev_add(struct cdev * , dev_t  , unsigned int  ) ;
extern void cdev_del(struct cdev * ) ;
extern void cd_forget(struct inode * ) ;
extern struct backing_dev_info directly_mappable_cdev_bdi ;
extern int __register_binfmt(struct linux_binfmt *fmt , int insert ) ;
__inline static int register_binfmt(struct linux_binfmt *fmt ) 
{ int tmp ;

  {
  {
  tmp = __register_binfmt(fmt, 0);
  }
  return (tmp);
}
}
__inline static int insert_binfmt(struct linux_binfmt *fmt ) 
{ int tmp ;

  {
  {
  tmp = __register_binfmt(fmt, 1);
  }
  return (tmp);
}
}
extern void unregister_binfmt(struct linux_binfmt * ) ;
extern int prepare_binprm(struct linux_binprm * ) ;
extern int remove_arg_zero(struct linux_binprm * ) ;
extern int search_binary_handler(struct linux_binprm * , struct pt_regs * ) ;
extern int flush_old_exec(struct linux_binprm *bprm ) ;
extern int suid_dumpable ;
extern int setup_arg_pages(struct linux_binprm *bprm , unsigned long stack_top , int executable_stack ) ;
extern int bprm_mm_init(struct linux_binprm *bprm ) ;
extern int copy_strings_kernel(int argc , char **argv , struct linux_binprm *bprm ) ;
extern void install_exec_creds(struct linux_binprm *bprm ) ;
extern void do_coredump(long signr , int exit_code , struct pt_regs *regs ) ;
extern int set_binfmt(struct linux_binfmt *new ) ;
extern void free_bprm(struct linux_binprm * ) ;
extern long do_shmat(int shmid , char *shmaddr , int shmflg , unsigned long *addr ) ;
extern int is_file_shm_hugepages(struct file *file ) ;
extern long do_msgsnd(int msqid , long mtype , void *mtext , size_t msgsz , int msgflg ) ;
extern long do_msgrcv(int msqid , long *pmtype , void *mtext , size_t msgsz , long msgtyp ,
                      int msgflg ) ;
extern struct in6_addr  const  in6addr_any ;
extern struct in6_addr  const  in6addr_loopback ;
extern struct in6_addr  const  in6addr_linklocal_allnodes ;
extern struct in6_addr  const  in6addr_linklocal_allrouters ;
extern void *flow_cache_lookup(struct net *net , struct flowi *key , u16 family ,
                               u8 dir , int (*resolver)(struct net *net , struct flowi *key ,
                                                        u16 family , u8 dir , void **objp ,
                                                        atomic_t **obj_refp ) ) ;
extern void flow_cache_flush(void) ;
extern atomic_t flow_cache_genid ;
__inline static int flow_cache_uli_match(struct flowi *fl1 , struct flowi *fl2 ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((int )fl1->proto == (int )fl2->proto) {
    {
    tmp = __builtin_memcmp((void const   *)(& fl1->uli_u), (void const   *)(& fl2->uli_u),
                           (unsigned int )sizeof(fl1->uli_u));
    }
    if (tmp) {
      {
      tmp___0 = 0;
      }
    } else {
      {
      tmp___0 = 1;
      }
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
extern int cap_capable(struct task_struct *tsk , struct cred  const  *cred , int cap ,
                       int audit ) ;
extern int cap_settime(struct timespec *ts , struct timezone *tz ) ;
extern int cap_ptrace_may_access(struct task_struct *child , unsigned int mode ) ;
extern int cap_ptrace_traceme(struct task_struct *parent ) ;
extern int cap_capget(struct task_struct *target , kernel_cap_t *effective , kernel_cap_t *inheritable ,
                      kernel_cap_t *permitted ) ;
extern int cap_capset(struct cred *new , struct cred  const  *old , kernel_cap_t const   *effective ,
                      kernel_cap_t const   *inheritable , kernel_cap_t const   *permitted ) ;
extern int cap_bprm_set_creds(struct linux_binprm *bprm ) ;
extern int cap_bprm_secureexec(struct linux_binprm *bprm ) ;
extern int cap_inode_setxattr(struct dentry *dentry , char const   *name , void const   *value ,
                              size_t size , int flags ) ;
extern int cap_inode_removexattr(struct dentry *dentry , char const   *name ) ;
extern int cap_inode_need_killpriv(struct dentry *dentry ) ;
extern int cap_inode_killpriv(struct dentry *dentry ) ;
extern int cap_task_fix_setuid(struct cred *new , struct cred  const  *old , int flags ) ;
extern int cap_task_prctl(int option , unsigned long arg2 , unsigned long arg3 , unsigned long arg4 ,
                          unsigned long arg5 ) ;
extern int cap_task_setscheduler(struct task_struct *p , int policy , struct sched_param *lp ) ;
extern int cap_task_setioprio(struct task_struct *p , int ioprio ) ;
extern int cap_task_setnice(struct task_struct *p , int nice ) ;
extern int cap_syslog(int type ) ;
extern int cap_vm_enough_memory(struct mm_struct *mm , long pages ) ;
extern int cap_netlink_send(struct sock *sk , struct sk_buff *skb ) ;
extern int cap_netlink_recv(struct sk_buff *skb , int cap ) ;
__inline static void security_init_mnt_opts(struct security_mnt_opts *opts ) 
{ 

  {
  {
  opts->mnt_opts = (char **)((void *)0);
  opts->mnt_opts_flags = (int *)((void *)0);
  opts->num_mnt_opts = 0;
  }
  return;
}
}
__inline static void security_free_mnt_opts(struct security_mnt_opts *opts ) 
{ int i ;

  {
  if (opts->mnt_opts) {
    {
    i = 0;
    }
    {
    while (1) {
      while_286_continue: /* CIL Label */ ;
      if (! (i < opts->num_mnt_opts)) {
        goto while_286_break;
      }
      {
      kfree((void const   *)*(opts->mnt_opts + i));
      i ++;
      }
    }
    while_286_break: /* CIL Label */ ;
    }
  }
  {
  kfree((void const   *)opts->mnt_opts);
  opts->mnt_opts = (char **)((void *)0);
  kfree((void const   *)opts->mnt_opts_flags);
  opts->mnt_opts_flags = (int *)((void *)0);
  opts->num_mnt_opts = 0;
  }
  return;
}
}
extern int security_init(void) ;
extern int security_module_enable(struct security_operations *ops ) ;
extern int register_security(struct security_operations *ops ) ;
extern int security_ptrace_may_access(struct task_struct *child , unsigned int mode ) ;
extern int security_ptrace_traceme(struct task_struct *parent ) ;
extern int security_capget(struct task_struct *target , kernel_cap_t *effective ,
                           kernel_cap_t *inheritable , kernel_cap_t *permitted ) ;
extern int security_capset(struct cred *new , struct cred  const  *old , kernel_cap_t const   *effective ,
                           kernel_cap_t const   *inheritable , kernel_cap_t const   *permitted ) ;
extern int security_capable(int cap ) ;
extern int security_real_capable(struct task_struct *tsk , int cap ) ;
extern int security_real_capable_noaudit(struct task_struct *tsk , int cap ) ;
extern int security_acct(struct file *file ) ;
extern int security_sysctl(struct ctl_table *table , int op ) ;
extern int security_quotactl(int cmds , int type , int id , struct super_block *sb ) ;
extern int security_quota_on(struct dentry *dentry ) ;
extern int security_syslog(int type ) ;
extern int security_settime(struct timespec *ts , struct timezone *tz ) ;
extern int security_vm_enough_memory(long pages ) ;
extern int security_vm_enough_memory_mm(struct mm_struct *mm , long pages ) ;
extern int security_vm_enough_memory_kern(long pages ) ;
extern int security_bprm_set_creds(struct linux_binprm *bprm ) ;
extern int security_bprm_check(struct linux_binprm *bprm ) ;
extern void security_bprm_committing_creds(struct linux_binprm *bprm ) ;
extern void security_bprm_committed_creds(struct linux_binprm *bprm ) ;
extern int security_bprm_secureexec(struct linux_binprm *bprm ) ;
extern int security_sb_alloc(struct super_block *sb ) ;
extern void security_sb_free(struct super_block *sb ) ;
extern int security_sb_copy_data(char *orig , char *copy ) ;
extern int security_sb_kern_mount(struct super_block *sb , int flags , void *data ) ;
extern int security_sb_show_options(struct seq_file *m , struct super_block *sb ) ;
extern int security_sb_statfs(struct dentry *dentry ) ;
extern int security_sb_mount(char *dev_name , struct path *path , char *type , unsigned long flags ,
                             void *data ) ;
extern int security_sb_check_sb(struct vfsmount *mnt , struct path *path ) ;
extern int security_sb_umount(struct vfsmount *mnt , int flags ) ;
extern void security_sb_umount_close(struct vfsmount *mnt ) ;
extern void security_sb_umount_busy(struct vfsmount *mnt ) ;
extern void security_sb_post_remount(struct vfsmount *mnt , unsigned long flags ,
                                     void *data ) ;
extern void security_sb_post_addmount(struct vfsmount *mnt , struct path *mountpoint ) ;
extern int security_sb_pivotroot(struct path *old_path , struct path *new_path ) ;
extern void security_sb_post_pivotroot(struct path *old_path , struct path *new_path ) ;
extern int security_sb_set_mnt_opts(struct super_block *sb , struct security_mnt_opts *opts ) ;
extern void security_sb_clone_mnt_opts(struct super_block  const  *oldsb , struct super_block *newsb ) ;
extern int security_sb_parse_opts_str(char *options , struct security_mnt_opts *opts ) ;
extern int security_inode_alloc(struct inode *inode ) ;
extern void security_inode_free(struct inode *inode ) ;
extern int security_inode_init_security(struct inode *inode , struct inode *dir ,
                                        char **name , void **value , size_t *len ) ;
extern int security_inode_create(struct inode *dir , struct dentry *dentry , int mode ) ;
extern int security_inode_link(struct dentry *old_dentry , struct inode *dir , struct dentry *new_dentry ) ;
extern int security_inode_unlink(struct inode *dir , struct dentry *dentry ) ;
extern int security_inode_symlink(struct inode *dir , struct dentry *dentry , char const   *old_name ) ;
extern int security_inode_mkdir(struct inode *dir , struct dentry *dentry , int mode ) ;
extern int security_inode_rmdir(struct inode *dir , struct dentry *dentry ) ;
extern int security_inode_mknod(struct inode *dir , struct dentry *dentry , int mode ,
                                dev_t dev ) ;
extern int security_inode_rename(struct inode *old_dir , struct dentry *old_dentry ,
                                 struct inode *new_dir , struct dentry *new_dentry ) ;
extern int security_inode_readlink(struct dentry *dentry ) ;
extern int security_inode_follow_link(struct dentry *dentry , struct nameidata *nd ) ;
extern int security_inode_permission(struct inode *inode , int mask ) ;
extern int security_inode_setattr(struct dentry *dentry , struct iattr *attr ) ;
extern int security_inode_getattr(struct vfsmount *mnt , struct dentry *dentry ) ;
extern void security_inode_delete(struct inode *inode ) ;
extern int security_inode_setxattr(struct dentry *dentry , char const   *name , void const   *value ,
                                   size_t size , int flags ) ;
extern void security_inode_post_setxattr(struct dentry *dentry , char const   *name ,
                                         void const   *value , size_t size , int flags ) ;
extern int security_inode_getxattr(struct dentry *dentry , char const   *name ) ;
extern int security_inode_listxattr(struct dentry *dentry ) ;
extern int security_inode_removexattr(struct dentry *dentry , char const   *name ) ;
extern int security_inode_need_killpriv(struct dentry *dentry ) ;
extern int security_inode_killpriv(struct dentry *dentry ) ;
extern int security_inode_getsecurity(struct inode  const  *inode , char const   *name ,
                                      void **buffer , bool alloc ) ;
extern int security_inode_setsecurity(struct inode *inode , char const   *name , void const   *value ,
                                      size_t size , int flags ) ;
extern int security_inode_listsecurity(struct inode *inode , char *buffer , size_t buffer_size ) ;
extern void security_inode_getsecid(struct inode  const  *inode , u32 *secid ) ;
extern int security_file_permission(struct file *file , int mask ) ;
extern int security_file_alloc(struct file *file ) ;
extern void security_file_free(struct file *file ) ;
extern int security_file_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) ;
extern int security_file_mmap(struct file *file , unsigned long reqprot , unsigned long prot ,
                              unsigned long flags , unsigned long addr , unsigned long addr_only ) ;
extern int security_file_mprotect(struct vm_area_struct *vma , unsigned long reqprot ,
                                  unsigned long prot ) ;
extern int security_file_lock(struct file *file , unsigned int cmd ) ;
extern int security_file_fcntl(struct file *file , unsigned int cmd , unsigned long arg ) ;
extern int security_file_set_fowner(struct file *file ) ;
extern int security_file_send_sigiotask(struct task_struct *tsk , struct fown_struct *fown ,
                                        int sig ) ;
extern int security_file_receive(struct file *file ) ;
extern int security_dentry_open(struct file *file , struct cred  const  *cred ) ;
extern int security_task_create(unsigned long clone_flags ) ;
extern void security_cred_free(struct cred *cred ) ;
extern int security_prepare_creds(struct cred *new , struct cred  const  *old , gfp_t gfp ) ;
extern void security_commit_creds(struct cred *new , struct cred  const  *old ) ;
extern int security_kernel_act_as(struct cred *new , u32 secid ) ;
extern int security_kernel_create_files_as(struct cred *new , struct inode *inode ) ;
extern int security_task_setuid(uid_t id0 , uid_t id1 , uid_t id2 , int flags ) ;
extern int security_task_fix_setuid(struct cred *new , struct cred  const  *old ,
                                    int flags ) ;
extern int security_task_setgid(gid_t id0 , gid_t id1 , gid_t id2 , int flags ) ;
extern int security_task_setpgid(struct task_struct *p , pid_t pgid ) ;
extern int security_task_getpgid(struct task_struct *p ) ;
extern int security_task_getsid(struct task_struct *p ) ;
extern void security_task_getsecid(struct task_struct *p , u32 *secid ) ;
extern int security_task_setgroups(struct group_info *group_info ) ;
extern int security_task_setnice(struct task_struct *p , int nice ) ;
extern int security_task_setioprio(struct task_struct *p , int ioprio ) ;
extern int security_task_getioprio(struct task_struct *p ) ;
extern int security_task_setrlimit(unsigned int resource , struct rlimit *new_rlim ) ;
extern int security_task_setscheduler(struct task_struct *p , int policy , struct sched_param *lp ) ;
extern int security_task_getscheduler(struct task_struct *p ) ;
extern int security_task_movememory(struct task_struct *p ) ;
extern int security_task_kill(struct task_struct *p , struct siginfo *info , int sig ,
                              u32 secid ) ;
extern int security_task_wait(struct task_struct *p ) ;
extern int security_task_prctl(int option , unsigned long arg2 , unsigned long arg3 ,
                               unsigned long arg4 , unsigned long arg5 ) ;
extern void security_task_to_inode(struct task_struct *p , struct inode *inode ) ;
extern int security_ipc_permission(struct kern_ipc_perm *ipcp , short flag ) ;
extern void security_ipc_getsecid(struct kern_ipc_perm *ipcp , u32 *secid ) ;
extern int security_msg_msg_alloc(struct msg_msg *msg ) ;
extern void security_msg_msg_free(struct msg_msg *msg ) ;
extern int security_msg_queue_alloc(struct msg_queue *msq ) ;
extern void security_msg_queue_free(struct msg_queue *msq ) ;
extern int security_msg_queue_associate(struct msg_queue *msq , int msqflg ) ;
extern int security_msg_queue_msgctl(struct msg_queue *msq , int cmd ) ;
extern int security_msg_queue_msgsnd(struct msg_queue *msq , struct msg_msg *msg ,
                                     int msqflg ) ;
extern int security_msg_queue_msgrcv(struct msg_queue *msq , struct msg_msg *msg ,
                                     struct task_struct *target , long type , int mode ) ;
extern int security_shm_alloc(struct shmid_kernel *shp ) ;
extern void security_shm_free(struct shmid_kernel *shp ) ;
extern int security_shm_associate(struct shmid_kernel *shp , int shmflg ) ;
extern int security_shm_shmctl(struct shmid_kernel *shp , int cmd ) ;
extern int security_shm_shmat(struct shmid_kernel *shp , char *shmaddr , int shmflg ) ;
extern int security_sem_alloc(struct sem_array *sma ) ;
extern void security_sem_free(struct sem_array *sma ) ;
extern int security_sem_associate(struct sem_array *sma , int semflg ) ;
extern int security_sem_semctl(struct sem_array *sma , int cmd ) ;
extern int security_sem_semop(struct sem_array *sma , struct sembuf *sops , unsigned int nsops ,
                              int alter ) ;
extern void security_d_instantiate(struct dentry *dentry , struct inode *inode ) ;
extern int security_getprocattr(struct task_struct *p , char *name , char **value ) ;
extern int security_setprocattr(struct task_struct *p , char *name , void *value ,
                                size_t size ) ;
extern int security_netlink_send(struct sock *sk , struct sk_buff *skb ) ;
extern int security_netlink_recv(struct sk_buff *skb , int cap ) ;
extern int security_secid_to_secctx(u32 secid , char **secdata , u32 *seclen ) ;
extern int security_secctx_to_secid(char const   *secdata , u32 seclen , u32 *secid ) ;
extern void security_release_secctx(char *secdata , u32 seclen ) ;
extern int security_unix_stream_connect(struct socket *sock , struct socket *other ,
                                        struct sock *newsk ) ;
extern int security_unix_may_send(struct socket *sock , struct socket *other ) ;
extern int security_socket_create(int family , int type , int protocol , int kern ) ;
extern int security_socket_post_create(struct socket *sock , int family , int type ,
                                       int protocol , int kern ) ;
extern int security_socket_bind(struct socket *sock , struct sockaddr *address , int addrlen ) ;
extern int security_socket_connect(struct socket *sock , struct sockaddr *address ,
                                   int addrlen ) ;
extern int security_socket_listen(struct socket *sock , int backlog ) ;
extern int security_socket_accept(struct socket *sock , struct socket *newsock ) ;
extern int security_socket_sendmsg(struct socket *sock , struct msghdr *msg , int size ) ;
extern int security_socket_recvmsg(struct socket *sock , struct msghdr *msg , int size ,
                                   int flags ) ;
extern int security_socket_getsockname(struct socket *sock ) ;
extern int security_socket_getpeername(struct socket *sock ) ;
extern int security_socket_getsockopt(struct socket *sock , int level , int optname ) ;
extern int security_socket_setsockopt(struct socket *sock , int level , int optname ) ;
extern int security_socket_shutdown(struct socket *sock , int how ) ;
extern int security_sock_rcv_skb(struct sock *sk , struct sk_buff *skb ) ;
extern int security_socket_getpeersec_stream(struct socket *sock , char *optval ,
                                             int *optlen , unsigned int len ) ;
extern int security_socket_getpeersec_dgram(struct socket *sock , struct sk_buff *skb ,
                                            u32 *secid ) ;
extern int security_sk_alloc(struct sock *sk , int family , gfp_t priority ) ;
extern void security_sk_free(struct sock *sk ) ;
extern void security_sk_clone(struct sock  const  *sk , struct sock *newsk ) ;
extern void security_sk_classify_flow(struct sock *sk , struct flowi *fl ) ;
extern void security_req_classify_flow(struct request_sock  const  *req , struct flowi *fl ) ;
extern void security_sock_graft(struct sock *sk , struct socket *parent ) ;
extern int security_inet_conn_request(struct sock *sk , struct sk_buff *skb , struct request_sock *req ) ;
extern void security_inet_csk_clone(struct sock *newsk , struct request_sock  const  *req ) ;
extern void security_inet_conn_established(struct sock *sk , struct sk_buff *skb ) ;
__inline static int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp , struct xfrm_user_sec_ctx *sec_ctx ) 
{ 

  {
  return (0);
}
}
__inline static int security_xfrm_policy_clone(struct xfrm_sec_ctx *old , struct xfrm_sec_ctx **new_ctxp ) 
{ 

  {
  return (0);
}
}
__inline static void security_xfrm_policy_free(struct xfrm_sec_ctx *ctx ) 
{ 

  {
  return;
}
}
__inline static int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx ) 
{ 

  {
  return (0);
}
}
__inline static int security_xfrm_state_alloc(struct xfrm_state *x , struct xfrm_user_sec_ctx *sec_ctx ) 
{ 

  {
  return (0);
}
}
__inline static int security_xfrm_state_alloc_acquire(struct xfrm_state *x , struct xfrm_sec_ctx *polsec ,
                                                      u32 secid ) 
{ 

  {
  return (0);
}
}
__inline static void security_xfrm_state_free(struct xfrm_state *x ) 
{ 

  {
  return;
}
}
__inline static int security_xfrm_state_delete(struct xfrm_state *x ) 
{ 

  {
  return (0);
}
}
__inline static int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx , u32 fl_secid ,
                                                u8 dir ) 
{ 

  {
  return (0);
}
}
__inline static int security_xfrm_state_pol_flow_match(struct xfrm_state *x , struct xfrm_policy *xp ,
                                                       struct flowi *fl ) 
{ 

  {
  return (1);
}
}
__inline static int security_xfrm_decode_session(struct sk_buff *skb , u32 *secid ) 
{ 

  {
  return (0);
}
}
__inline static void security_skb_classify_flow(struct sk_buff *skb , struct flowi *fl ) 
{ 

  {
  return;
}
}
__inline static int security_path_unlink(struct path *dir , struct dentry *dentry ) 
{ 

  {
  return (0);
}
}
__inline static int security_path_mkdir(struct path *dir , struct dentry *dentry ,
                                        int mode ) 
{ 

  {
  return (0);
}
}
__inline static int security_path_mknod(struct path *dir , struct dentry *dentry ,
                                        int mode , unsigned int dev ) 
{ 

  {
  return (0);
}
}
__inline static int security_path_truncate(struct path *path , loff_t length , unsigned int time_attrs ) 
{ 

  {
  return (0);
}
}
__inline static int security_path_symlink(struct path *dir , struct dentry *dentry ,
                                          char const   *old_name ) 
{ 

  {
  return (0);
}
}
__inline static int security_path_link(struct dentry *old_dentry , struct path *new_dir ,
                                       struct dentry *new_dentry ) 
{ 

  {
  return (0);
}
}
__inline static int security_path_rename(struct path *old_dir , struct dentry *old_dentry ,
                                         struct path *new_dir , struct dentry *new_dentry ) 
{ 

  {
  return (0);
}
}
extern int security_key_alloc(struct key *key , struct cred  const  *cred , unsigned long flags ) ;
extern void security_key_free(struct key *key ) ;
extern int security_key_permission(key_ref_t key_ref , struct cred  const  *cred ,
                                   key_perm_t perm ) ;
extern int security_key_getsecurity(struct key *key , char **_buffer ) ;
extern int security_audit_rule_init(u32 field , u32 op , char *rulestr , void **lsmrule ) ;
extern int security_audit_rule_known(struct audit_krule *krule ) ;
extern int security_audit_rule_match(u32 secid , u32 field , u32 op , void *lsmrule ,
                                     struct audit_context *actx ) ;
extern void security_audit_rule_free(void *lsmrule ) ;
__inline static struct dentry *securityfs_create_dir(char const   *name , struct dentry *parent ) 
{ void *tmp ;

  {
  {
  tmp = ERR_PTR(-19L);
  }
  return ((struct dentry *)tmp);
}
}
__inline static struct dentry *securityfs_create_file(char const   *name , mode_t mode ,
                                                      struct dentry *parent , void *data ,
                                                      struct file_operations  const  *fops ) 
{ void *tmp ;

  {
  {
  tmp = ERR_PTR(-19L);
  }
  return ((struct dentry *)tmp);
}
}
__inline static void securityfs_remove(struct dentry *dentry ) 
{ 

  {
  return;
}
}
__inline static char *alloc_secdata(void) 
{ unsigned long tmp ;

  {
  {
  tmp = get_zeroed_page(208U);
  }
  return ((char *)tmp);
}
}
__inline static void free_secdata(void *secdata ) 
{ 

  {
  {
  free_pages((unsigned long )secdata, 0U);
  }
  return;
}
}
struct mutex usbfs_mutex  =    {{(int volatile   )1}, {{0U}}, {& usbfs_mutex.wait_list, & usbfs_mutex.wait_list},
    (struct thread_info *)0};
static int usbfs_snoop  ;
__inline static int *__check_usbfs_snoop(void) 
{ 

  {
  return (& usbfs_snoop);
}
}
static int __param_perm_check_usbfs_snoop  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
static char const   __param_str_usbfs_snoop[23]  = 
  {      (char const   )'S',      (char const   )'o',      (char const   )'m',      (char const   )'e', 
        (char const   )'M',      (char const   )'o',      (char const   )'d',      (char const   )'u', 
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'u', 
        (char const   )'s',      (char const   )'b',      (char const   )'f',      (char const   )'s', 
        (char const   )'_',      (char const   )'s',      (char const   )'n',      (char const   )'o', 
        (char const   )'o',      (char const   )'p',      (char const   )'\000'};
static struct kernel_param  const  __param_usbfs_snoop  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_usbfs_snoop, 420U, & param_set_bool, & param_get_bool, {(void *)(& usbfs_snoop)}};
static int connected(struct dev_state *ps ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = list_empty((struct list_head  const  *)(& ps->list));
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    if ((unsigned int )(ps->dev)->state != 0U) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
static loff_t usbdev_lseek(struct file *file , loff_t offset , int orig ) 
{ loff_t ret ;

  {
  {
  lock_kernel();
  }
  if (orig == 0) {
    goto switch_287_0;
  } else {
    if (orig == 1) {
      goto switch_287_1;
    } else {
      if (orig == 2) {
        goto switch_287_2;
      } else {
        {
        goto switch_287_2;
        if (0) {
          switch_287_0: /* CIL Label */ 
          {
          file->f_pos = offset;
          ret = file->f_pos;
          }
          goto switch_287_break;
          switch_287_1: /* CIL Label */ 
          {
          file->f_pos += offset;
          ret = file->f_pos;
          }
          goto switch_287_break;
          switch_287_2: /* CIL Label */ 
          switch_287_default: /* CIL Label */ 
          {
          ret = -22LL;
          }
        } else {
          switch_287_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  {
  unlock_kernel();
  }
  return (ret);
}
}
static ssize_t usbdev_read(struct file *file , char *buf , size_t nbytes , loff_t *ppos ) 
{ struct dev_state *ps ;
  struct usb_device *dev ;
  ssize_t ret ;
  unsigned int len ;
  loff_t pos ;
  int i ;
  int tmp ;
  struct usb_device_descriptor temp_desc ;
  unsigned long tmp___0 ;
  struct usb_config_descriptor *config ;
  unsigned int length ;
  unsigned int alloclen ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
  ps = (struct dev_state *)file->private_data;
  dev = ps->dev;
  ret = 0;
  pos = *ppos;
  down(& dev->dev.sem);
  tmp = connected(ps);
  }
  if (tmp) {
    if (pos < 0LL) {
      {
      ret = -22;
      }
      goto err;
    }
  } else {
    {
    ret = -19;
    }
    goto err;
  }
  if (pos < (loff_t )sizeof(struct usb_device_descriptor )) {
    {
    __constant_memcpy((void *)(& temp_desc), (void const   *)(& dev->descriptor),
                      (unsigned int )sizeof(dev->descriptor));
    }
    {
    while (1) {
      while_288_continue: /* CIL Label */ ;
      goto while_288_break;
    }
    while_288_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_289_continue: /* CIL Label */ ;
      goto while_289_break;
    }
    while_289_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_290_continue: /* CIL Label */ ;
      goto while_290_break;
    }
    while_290_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_291_continue: /* CIL Label */ ;
      goto while_291_break;
    }
    while_291_break: /* CIL Label */ ;
    }
    {
    len = (unsigned int )((loff_t )sizeof(struct usb_device_descriptor ) - pos);
    }
    if (len > nbytes) {
      {
      len = nbytes;
      }
    }
    {
    tmp___0 = copy_to_user((void *)buf, (void const   *)((char *)(& temp_desc) + pos),
                           (unsigned long )len);
    }
    if (tmp___0) {
      {
      ret = -14;
      }
      goto err;
    }
    {
    *ppos += (loff_t )len;
    buf += len;
    nbytes -= len;
    ret = (int )((unsigned int )ret + len);
    }
  }
  {
  pos = (long long )sizeof(struct usb_device_descriptor );
  i = 0;
  }
  {
  while (1) {
    while_292_continue: /* CIL Label */ ;
    if (nbytes) {
      if (! (i < (int )dev->descriptor.bNumConfigurations)) {
        goto while_292_break;
      }
    } else {
      goto while_292_break;
    }
    {
    config = (struct usb_config_descriptor *)*(dev->rawdescriptors + i);
    length = (unsigned int )config->wTotalLength;
    }
    if (*ppos < pos + (loff_t )length) {
      {
      alloclen = (unsigned int )(dev->config + i)->desc.wTotalLength;
      len = (unsigned int )((loff_t )length - (*ppos - pos));
      }
      if (len > nbytes) {
        {
        len = nbytes;
        }
      }
      if ((loff_t )alloclen > *ppos - pos) {
        {
        alloclen = (unsigned int )((loff_t )alloclen - (*ppos - pos));
        _min1 = len;
        _min2 = alloclen;
        }
        if (_min1 < _min2) {
          {
          tmp___1 = _min1;
          }
        } else {
          {
          tmp___1 = _min2;
          }
        }
        {
        tmp___2 = copy_to_user((void *)buf, (void const   *)(*(dev->rawdescriptors + i) + (*ppos - pos)),
                               (unsigned long )tmp___1);
        }
        if (tmp___2) {
          {
          ret = -14;
          }
          goto err;
        }
      }
      {
      *ppos += (loff_t )len;
      buf += len;
      nbytes -= len;
      ret = (int )((unsigned int )ret + len);
      }
    }
    {
    pos += (loff_t )length;
    i ++;
    }
  }
  while_292_break: /* CIL Label */ ;
  }
  err: 
  {
  up(& dev->dev.sem);
  }
  return (ret);
}
}
static struct async *alloc_async(unsigned int numisoframes ) 
{ struct async *as ;
  void *tmp ;

  {
  {
  tmp = kzalloc((unsigned int )sizeof(struct async ), 208U);
  as = (struct async *)tmp;
  }
  if (! as) {
    return ((struct async *)((void *)0));
  }
  {
  as->urb = usb_alloc_urb((int )numisoframes, 208U);
  }
  if (! as->urb) {
    {
    kfree((void const   *)as);
    }
    return ((struct async *)((void *)0));
  }
  return (as);
}
}
static void free_async(struct async *as ) 
{ 

  {
  {
  put_pid(as->pid);
  kfree((void const   *)(as->urb)->transfer_buffer);
  kfree((void const   *)(as->urb)->setup_packet);
  usb_free_urb(as->urb);
  kfree((void const   *)as);
  }
  return;
}
}
static void async_newpending(struct async *as ) 
{ struct dev_state *ps ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  ps = as->ps;
  }
  {
  while (1) {
    while_293_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& ps->lock);
    }
    goto while_293_break;
  }
  while_293_break: /* CIL Label */ ;
  }
  {
  list_add_tail(& as->asynclist, & ps->async_pending);
  }
  {
  while (1) {
    while_294_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& ps->lock, flags);
    }
    goto while_294_break;
  }
  while_294_break: /* CIL Label */ ;
  }
  return;
}
}
static void async_removepending(struct async *as ) 
{ struct dev_state *ps ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  ps = as->ps;
  }
  {
  while (1) {
    while_295_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& ps->lock);
    }
    goto while_295_break;
  }
  while_295_break: /* CIL Label */ ;
  }
  {
  list_del_init(& as->asynclist);
  }
  {
  while (1) {
    while_296_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& ps->lock, flags);
    }
    goto while_296_break;
  }
  while_296_break: /* CIL Label */ ;
  }
  return;
}
}
static struct async *async_getcompleted(struct dev_state *ps ) 
{ unsigned long flags ;
  struct async *as ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  int tmp ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  as = (struct async *)((void *)0);
  }
  {
  while (1) {
    while_297_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& ps->lock);
    }
    goto while_297_break;
  }
  while_297_break: /* CIL Label */ ;
  }
  {
  tmp = list_empty((struct list_head  const  *)(& ps->async_completed));
  }
  if (! tmp) {
    {
    __mptr = (struct list_head  const  *)ps->async_completed.next;
    as = (struct async *)((char *)__mptr - (unsigned int )(& ((struct async *)0)->asynclist));
    list_del_init(& as->asynclist);
    }
  }
  {
  while (1) {
    while_298_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& ps->lock, flags);
    }
    goto while_298_break;
  }
  while_298_break: /* CIL Label */ ;
  }
  return (as);
}
}
static struct async *async_getpending(struct dev_state *ps , void *userurb ) 
{ unsigned long flags ;
  struct async *as ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;

  {
  {
  while (1) {
    while_299_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& ps->lock);
    }
    goto while_299_break;
  }
  while_299_break: /* CIL Label */ ;
  }
  {
  __mptr = (struct list_head  const  *)ps->async_pending.next;
  as = (struct async *)((char *)__mptr - (unsigned int )(& ((struct async *)0)->asynclist));
  }
  {
  while (1) {
    while_300_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)as->asynclist.next);
    }
    if (! ((unsigned long )(& as->asynclist) != (unsigned long )(& ps->async_pending))) {
      goto while_300_break;
    }
    if ((unsigned long )as->userurb == (unsigned long )userurb) {
      {
      list_del_init(& as->asynclist);
      }
      {
      while (1) {
        while_301_continue: /* CIL Label */ ;
        {
        _spin_unlock_irqrestore(& ps->lock, flags);
        }
        goto while_301_break;
      }
      while_301_break: /* CIL Label */ ;
      }
      return (as);
    }
    {
    __mptr___0 = (struct list_head  const  *)as->asynclist.next;
    as = (struct async *)((char *)__mptr___0 - (unsigned int )(& ((struct async *)0)->asynclist));
    }
  }
  while_300_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_302_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& ps->lock, flags);
    }
    goto while_302_break;
  }
  while_302_break: /* CIL Label */ ;
  }
  return ((struct async *)((void *)0));
}
}
static void snoop_urb(struct urb *urb , void *userurb ) 
{ unsigned int j ;
  unsigned char *data ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;

  {
  {
  data = (unsigned char *)urb->transfer_buffer;
  }
  if (! usbfs_snoop) {
    return;
  }
  {
  tmp___1 = usb_urb_dir_in(urb);
  }
  if (tmp___1) {
    {
    tmp___0 = "IN";
    }
  } else {
    {
    tmp___0 = "OUT";
    }
  }
  {
  tmp___2 = dev_name((struct device  const  *)(& (urb->dev)->dev));
  tmp___3 = dev_driver_string((struct device  const  *)(& (urb->dev)->dev));
  printk("<6>%s %s: direction=%s\n", tmp___3, tmp___2, tmp___0);
  tmp___4 = dev_name((struct device  const  *)(& (urb->dev)->dev));
  tmp___5 = dev_driver_string((struct device  const  *)(& (urb->dev)->dev));
  printk("<6>%s %s: userurb=%p\n", tmp___5, tmp___4, userurb);
  tmp___6 = dev_name((struct device  const  *)(& (urb->dev)->dev));
  tmp___7 = dev_driver_string((struct device  const  *)(& (urb->dev)->dev));
  printk("<6>%s %s: transfer_buffer_length=%u\n", tmp___7, tmp___6, urb->transfer_buffer_length);
  tmp___8 = dev_name((struct device  const  *)(& (urb->dev)->dev));
  tmp___9 = dev_driver_string((struct device  const  *)(& (urb->dev)->dev));
  printk("<6>%s %s: actual_length=%u\n", tmp___9, tmp___8, urb->actual_length);
  tmp___10 = dev_name((struct device  const  *)(& (urb->dev)->dev));
  tmp___11 = dev_driver_string((struct device  const  *)(& (urb->dev)->dev));
  printk("<6>%s %s: data: ", tmp___11, tmp___10);
  j = 0U;
  }
  {
  while (1) {
    while_303_continue: /* CIL Label */ ;
    if (! (j < urb->transfer_buffer_length)) {
      goto while_303_break;
    }
    {
    printk("%02x ", *(data + j));
    j ++;
    }
  }
  while_303_break: /* CIL Label */ ;
  }
  {
  printk("\n");
  }
  return;
}
}
static void async_completed(struct urb *urb ) 
{ struct async *as ;
  struct dev_state *ps ;
  struct siginfo sinfo ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  as = (struct async *)urb->context;
  ps = as->ps;
  _spin_lock(& ps->lock);
  list_move_tail(& as->asynclist, & ps->async_completed);
  }
  {
  while (1) {
    while_304_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& ps->lock.raw_lock);
    }
    goto while_304_break;
  }
  while_304_break: /* CIL Label */ ;
  }
  {
  as->status = urb->status;
  }
  if (as->signr) {
    {
    sinfo.si_signo = (int )as->signr;
    sinfo.si_errno = as->status;
    sinfo.si_code = -4;
    sinfo._sifields._sigfault._addr = as->userurb;
    kill_pid_info_as_uid((int )as->signr, & sinfo, as->pid, as->uid, as->euid, as->secid);
    }
  }
  {
  while (1) {
    while_305_continue: /* CIL Label */ ;
    if (usbfs_snoop) {
      {
      tmp = dev_name((struct device  const  *)(& (urb->dev)->dev));
      tmp___0 = dev_driver_string((struct device  const  *)(& (urb->dev)->dev));
      printk("<6>%s %s: urb complete\n", tmp___0, tmp);
      }
    }
    goto while_305_break;
  }
  while_305_break: /* CIL Label */ ;
  }
  {
  snoop_urb(urb, as->userurb);
  __wake_up(& ps->wait, 3U, 1, (void *)0);
  }
  return;
}
}
static void destroy_async(struct dev_state *ps , struct list_head *list ) 
{ struct async *as ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;

  {
  {
  while (1) {
    while_306_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& ps->lock);
    }
    goto while_306_break;
  }
  while_306_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_307_continue: /* CIL Label */ ;
    {
    tmp = list_empty((struct list_head  const  *)list);
    }
    if (tmp) {
      goto while_307_break;
    }
    {
    __mptr = (struct list_head  const  *)list->next;
    as = (struct async *)((char *)__mptr - (unsigned int )(& ((struct async *)0)->asynclist));
    list_del_init(& as->asynclist);
    }
    {
    while (1) {
      while_308_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& ps->lock, flags);
      }
      goto while_308_break;
    }
    while_308_break: /* CIL Label */ ;
    }
    {
    usb_kill_urb(as->urb);
    }
    {
    while (1) {
      while_309_continue: /* CIL Label */ ;
      {
      flags = _spin_lock_irqsave(& ps->lock);
      }
      goto while_309_break;
    }
    while_309_break: /* CIL Label */ ;
    }
  }
  while_307_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_310_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& ps->lock, flags);
    }
    goto while_310_break;
  }
  while_310_break: /* CIL Label */ ;
  }
  return;
}
}
static void destroy_async_on_interface(struct dev_state *ps , unsigned int ifnum ) 
{ struct list_head *p ;
  struct list_head *q ;
  struct list_head hitlist ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  INIT_LIST_HEAD(& hitlist);
  }
  {
  while (1) {
    while_311_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& ps->lock);
    }
    goto while_311_break;
  }
  while_311_break: /* CIL Label */ ;
  }
  {
  p = ps->async_pending.next;
  q = p->next;
  }
  {
  while (1) {
    while_312_continue: /* CIL Label */ ;
    if (! ((unsigned long )p != (unsigned long )(& ps->async_pending))) {
      goto while_312_break;
    }
    {
    __mptr = (struct list_head  const  *)p;
    }
    if (ifnum == ((struct async *)((char *)__mptr - (unsigned int )(& ((struct async *)0)->asynclist)))->ifnum) {
      {
      list_move_tail(p, & hitlist);
      }
    }
    {
    p = q;
    q = p->next;
    }
  }
  while_312_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_313_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& ps->lock, flags);
    }
    goto while_313_break;
  }
  while_313_break: /* CIL Label */ ;
  }
  {
  destroy_async(ps, & hitlist);
  }
  return;
}
}
static void destroy_all_async(struct dev_state *ps ) 
{ 

  {
  {
  destroy_async(ps, & ps->async_pending);
  }
  return;
}
}
static int driver_probe(struct usb_interface *intf , struct usb_device_id  const  *id ) 
{ 

  {
  return (-19);
}
}
static void driver_disconnect(struct usb_interface *intf ) 
{ struct dev_state *ps ;
  void *tmp ;
  unsigned int ifnum ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = usb_get_intfdata(intf);
  ps = (struct dev_state *)tmp;
  ifnum = (unsigned int )(intf->altsetting)->desc.bInterfaceNumber;
  }
  if (! ps) {
    return;
  }
  {
  tmp___2 = __builtin_expect((long )(! (! ((unsigned long )ifnum < 8UL * sizeof(ps->ifclaimed)))),
                             1L);
  }
  if (tmp___2) {
    {
    clear_bit((int )ifnum, (unsigned long volatile   *)(& ps->ifclaimed));
    }
  } else {
    {
    tmp___0 = dev_name((struct device  const  *)(& intf->dev));
    tmp___1 = dev_driver_string((struct device  const  *)(& intf->dev));
    printk("<4>%s %s: interface number %u out of range\n", tmp___1, tmp___0, ifnum);
    }
  }
  {
  usb_set_intfdata(intf, (void *)0);
  destroy_async_on_interface(ps, ifnum);
  }
  return;
}
}
static int driver_suspend(struct usb_interface *intf , pm_message_t msg ) 
{ 

  {
  return (0);
}
}
static int driver_resume(struct usb_interface *intf ) 
{ 

  {
  return (0);
}
}
struct usb_driver usbfs_driver  = 
     {"usbfs", & driver_probe, & driver_disconnect, (int (*)(struct usb_interface *intf ,
                                                           unsigned int code , void *buf ))0,
    & driver_suspend, & driver_resume, (int (*)(struct usb_interface *intf ))0, (int (*)(struct usb_interface *intf ))0,
    (int (*)(struct usb_interface *intf ))0, (struct usb_device_id  const  *)0, {{{0U}},
                                                                                 {(struct list_head *)0,
                                                                                  (struct list_head *)0}},
    {{(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
      (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
      (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
      (struct attribute_group **)0, (struct dev_pm_ops *)0, (struct driver_private *)0},
     0}, 0U, 0U, 0U};
static int claimintf(struct dev_state *ps , unsigned int ifnum ) 
{ struct usb_device *dev ;
  struct usb_interface *intf ;
  int err ;
  int tmp ;
  int tmp___0 ;

  {
  {
  dev = ps->dev;
  }
  if ((unsigned long )ifnum >= 8UL * sizeof(ps->ifclaimed)) {
    return (-22);
  }
  {
  tmp___0 = variable_test_bit((int )ifnum, (unsigned long const volatile   *)(& ps->ifclaimed));
  }
  if (tmp___0) {
    return (0);
  }
  {
  intf = usb_ifnum_to_if((struct usb_device  const  *)dev, ifnum);
  }
  if (! intf) {
    {
    err = -2;
    }
  } else {
    {
    err = usb_driver_claim_interface(& usbfs_driver, intf, (void *)ps);
    }
  }
  if (err == 0) {
    {
    set_bit(ifnum, (unsigned long volatile   *)(& ps->ifclaimed));
    }
  }
  return (err);
}
}
static int releaseintf(struct dev_state *ps , unsigned int ifnum ) 
{ struct usb_device *dev ;
  struct usb_interface *intf ;
  int err ;
  int tmp ;

  {
  {
  err = -22;
  }
  if ((unsigned long )ifnum >= 8UL * sizeof(ps->ifclaimed)) {
    return (err);
  }
  {
  dev = ps->dev;
  intf = usb_ifnum_to_if((struct usb_device  const  *)dev, ifnum);
  }
  if (! intf) {
    {
    err = -2;
    }
  } else {
    {
    tmp = test_and_clear_bit((int )ifnum, (unsigned long volatile   *)(& ps->ifclaimed));
    }
    if (tmp) {
      {
      usb_driver_release_interface(& usbfs_driver, intf);
      err = 0;
      }
    }
  }
  return (err);
}
}
static int checkintf(struct dev_state *ps , unsigned int ifnum ) 
{ int tmp ;
  int tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  pid_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
  if ((unsigned int )(ps->dev)->state != 7U) {
    return (-113);
  }
  if ((unsigned long )ifnum >= 8UL * sizeof(ps->ifclaimed)) {
    return (-22);
  }
  {
  tmp___0 = variable_test_bit((int )ifnum, (unsigned long const volatile   *)(& ps->ifclaimed));
  }
  if (tmp___0) {
    return (0);
  }
  {
  tmp___1 = get_current();
  tmp___2 = get_current();
  tmp___3 = task_pid_nr(tmp___2);
  tmp___4 = dev_name((struct device  const  *)(& (ps->dev)->dev));
  tmp___5 = dev_driver_string((struct device  const  *)(& (ps->dev)->dev));
  printk("<4>%s %s: usbfs: process %d (%s) did not claim interface %u before use\n",
         tmp___5, tmp___4, tmp___3, tmp___1->comm, ifnum);
  tmp___6 = claimintf(ps, ifnum);
  }
  return (tmp___6);
}
}
static int findintfep(struct usb_device *dev , unsigned int ep ) 
{ unsigned int i ;
  unsigned int j ;
  unsigned int e ;
  struct usb_interface *intf ;
  struct usb_host_interface *alts ;
  struct usb_endpoint_descriptor *endpt ;

  {
  if (ep & 4294967152U) {
    return (-22);
  }
  if (! dev->actconfig) {
    return (-3);
  }
  {
  i = 0U;
  }
  {
  while (1) {
    while_314_continue: /* CIL Label */ ;
    if (! (i < (unsigned int )(dev->actconfig)->desc.bNumInterfaces)) {
      goto while_314_break;
    }
    {
    intf = (dev->actconfig)->interface[i];
    j = 0U;
    }
    {
    while (1) {
      while_315_continue: /* CIL Label */ ;
      if (! (j < intf->num_altsetting)) {
        goto while_315_break;
      }
      {
      alts = intf->altsetting + j;
      e = 0U;
      }
      {
      while (1) {
        while_316_continue: /* CIL Label */ ;
        if (! (e < (unsigned int )alts->desc.bNumEndpoints)) {
          goto while_316_break;
        }
        {
        endpt = & (alts->endpoint + e)->desc;
        }
        if ((unsigned int )endpt->bEndpointAddress == ep) {
          return ((int )alts->desc.bInterfaceNumber);
        }
        {
        e ++;
        }
      }
      while_316_break: /* CIL Label */ ;
      }
      {
      j ++;
      }
    }
    while_315_break: /* CIL Label */ ;
    }
    {
    i ++;
    }
  }
  while_314_break: /* CIL Label */ ;
  }
  return (-2);
}
}
static int check_ctrlrecip(struct dev_state *ps , unsigned int requesttype , unsigned int index ) 
{ int ret ;

  {
  {
  ret = 0;
  }
  if ((unsigned int )(ps->dev)->state != 4U) {
    if ((unsigned int )(ps->dev)->state != 6U) {
      if ((unsigned int )(ps->dev)->state != 7U) {
        return (-113);
      }
    }
  }
  if ((unsigned int )(2 << 5) == ((unsigned int )(3 << 5) & requesttype)) {
    return (0);
  }
  {
  index &= 255U;
  }
  if ((int )(requesttype & 31U) == 2) {
    goto switch_317_2;
  } else {
    if ((int )(requesttype & 31U) == 1) {
      goto switch_317_1;
    } else {
      if (0) {
        switch_317_2: /* CIL Label */ 
        {
        ret = findintfep(ps->dev, index);
        }
        if (ret >= 0) {
          {
          ret = checkintf(ps, (unsigned int )ret);
          }
        }
        goto switch_317_break;
        switch_317_1: /* CIL Label */ 
        {
        ret = checkintf(ps, index);
        }
        goto switch_317_break;
      } else {
        switch_317_break: /* CIL Label */ ;
      }
    }
  }
  return (ret);
}
}
static int match_devt(struct device *dev , void *data ) 
{ 

  {
  return (dev->devt == (unsigned int )((unsigned long )data));
}
}
static struct usb_device *usbdev_lookup_by_devt(dev_t devt ) 
{ struct device *dev ;
  struct device  const  *__mptr ;

  {
  {
  dev = bus_find_device(& usb_bus_type, (struct device *)((void *)0), (void *)((unsigned long )devt),
                        & match_devt);
  }
  if (! dev) {
    return ((struct usb_device *)((void *)0));
  }
  {
  __mptr = (struct device  const  *)dev;
  }
  return ((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)));
}
}
static int usbdev_open(struct inode *inode , struct file *file ) 
{ struct usb_device *dev ;
  struct dev_state *ps ;
  struct cred  const  *cred ;
  struct task_struct *tmp ;
  int ret ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  spinlock_t __constr_expr_0 ;
  struct task_struct *tmp___2 ;
  struct pid *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  pid_t tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
  dev = (struct usb_device *)((void *)0);
  tmp = get_current();
  cred = tmp->cred;
  lock_kernel();
  mutex_lock(& usbfs_mutex);
  ret = -12;
  tmp___0 = kmalloc((unsigned int )sizeof(struct dev_state ), 208U);
  ps = (struct dev_state *)tmp___0;
  }
  if (! ps) {
    goto out;
  }
  {
  ret = -19;
  tmp___1 = imajor((struct inode  const  *)inode);
  }
  if (tmp___1 == 189U) {
    {
    dev = usbdev_lookup_by_devt(inode->i_rdev);
    }
  }
  if (! dev) {
    {
    dev = (struct usb_device *)inode->i_private;
    }
    if (dev) {
      if (dev->usbfs_dentry) {
        if ((unsigned long )(dev->usbfs_dentry)->d_inode == (unsigned long )inode) {
          {
          usb_get_dev(dev);
          }
        } else {
          {
          dev = (struct usb_device *)((void *)0);
          }
        }
      } else {
        {
        dev = (struct usb_device *)((void *)0);
        }
      }
    } else {
      {
      dev = (struct usb_device *)((void *)0);
      }
    }
  }
  if (! dev) {
    goto out;
  } else {
    if ((unsigned int )dev->state == 0U) {
      goto out;
    }
  }
  {
  ret = usb_autoresume_device(dev);
  }
  if (ret) {
    goto out;
  }
  {
  ret = 0;
  ps->dev = dev;
  ps->file = file;
  }
  {
  while (1) {
    while_318_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    ps->lock = __constr_expr_0;
    }
    goto while_318_break;
  }
  while_318_break: /* CIL Label */ ;
  }
  {
  INIT_LIST_HEAD(& ps->list);
  INIT_LIST_HEAD(& ps->async_pending);
  INIT_LIST_HEAD(& ps->async_completed);
  init_waitqueue_head(& ps->wait);
  ps->discsignr = 0U;
  tmp___2 = get_current();
  tmp___3 = task_pid(tmp___2);
  ps->disc_pid = get_pid(tmp___3);
  ps->disc_uid = (unsigned int )cred->uid;
  ps->disc_euid = (unsigned int )cred->euid;
  ps->disccontext = (void *)0;
  ps->ifclaimed = 0UL;
  tmp___4 = get_current();
  security_task_getsecid(tmp___4, & ps->secid);
  __asm__  volatile   ("": : : "memory");
  list_add_tail(& ps->list, & dev->filelist);
  file->private_data = (void *)ps;
  }
  {
  while (1) {
    while_319_continue: /* CIL Label */ ;
    if (usbfs_snoop) {
      {
      tmp___5 = get_current();
      tmp___6 = get_current();
      tmp___7 = task_pid_nr(tmp___6);
      tmp___8 = dev_name((struct device  const  *)(& dev->dev));
      tmp___9 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<6>%s %s: opened by process %d: %s\n", tmp___9, tmp___8, tmp___7, tmp___5->comm);
      }
    }
    goto while_319_break;
  }
  while_319_break: /* CIL Label */ ;
  }
  out: 
  if (ret) {
    {
    kfree((void const   *)ps);
    usb_put_dev(dev);
    }
  }
  {
  mutex_unlock(& usbfs_mutex);
  unlock_kernel();
  }
  return (ret);
}
}
static int usbdev_release(struct inode *inode , struct file *file ) 
{ struct dev_state *ps ;
  struct usb_device *dev ;
  unsigned int ifnum ;
  struct async *as ;
  int tmp ;
  int tmp___0 ;

  {
  {
  ps = (struct dev_state *)file->private_data;
  dev = ps->dev;
  down(& dev->dev.sem);
  mutex_lock(& usbfs_mutex);
  list_del_init(& ps->list);
  mutex_unlock(& usbfs_mutex);
  ifnum = 0U;
  }
  {
  while (1) {
    while_320_continue: /* CIL Label */ ;
    if (ps->ifclaimed) {
      if (! ((unsigned long )ifnum < 8UL * sizeof(ps->ifclaimed))) {
        goto while_320_break;
      }
    } else {
      goto while_320_break;
    }
    {
    tmp___0 = variable_test_bit((int )ifnum, (unsigned long const volatile   *)(& ps->ifclaimed));
    }
    if (tmp___0) {
      {
      releaseintf(ps, ifnum);
      }
    }
    {
    ifnum ++;
    }
  }
  while_320_break: /* CIL Label */ ;
  }
  {
  destroy_all_async(ps);
  usb_autosuspend_device(dev);
  up(& dev->dev.sem);
  usb_put_dev(dev);
  put_pid(ps->disc_pid);
  as = async_getcompleted(ps);
  }
  {
  while (1) {
    while_321_continue: /* CIL Label */ ;
    if (! as) {
      goto while_321_break;
    }
    {
    free_async(as);
    as = async_getcompleted(ps);
    }
  }
  while_321_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)ps);
  }
  return (0);
}
}
static int proc_control(struct dev_state *ps , void *arg ) 
{ struct usb_device *dev ;
  struct usbdevfs_ctrltransfer ctrl ;
  unsigned int tmo ;
  unsigned char *tbuf ;
  unsigned int wLength ;
  int i ;
  int j ;
  int ret ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  unsigned int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  unsigned int tmp___15 ;
  struct task_struct *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;

  {
  {
  dev = ps->dev;
  tmp = copy_from_user((void *)(& ctrl), (void const   *)arg, sizeof(ctrl));
  }
  if (tmp) {
    return (-14);
  }
  {
  ret = check_ctrlrecip(ps, (unsigned int )ctrl.bRequestType, (unsigned int )ctrl.wIndex);
  }
  if (ret) {
    return (ret);
  }
  {
  wLength = (unsigned int )ctrl.wLength;
  }
  if ((unsigned long )wLength > 1UL << 12) {
    return (-22);
  }
  {
  tmp___0 = __get_free_pages(208U, 0U);
  tbuf = (unsigned char *)tmp___0;
  }
  if (! tbuf) {
    return (-12);
  }
  {
  tmo = ctrl.timeout;
  }
  if ((int )ctrl.bRequestType & 128) {
    if (ctrl.wLength) {
      {
      tmp___1 = current_thread_info();
      __asm__  ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (ctrl.data),
                "g" ((long )ctrl.wLength), "rm" (tmp___1->addr_limit.seg));
      }
      if (flag == 0UL) {
        {
        tmp___2 = 1;
        }
      } else {
        {
        tmp___2 = 0;
        }
      }
      {
      tmp___3 = __builtin_expect((long )tmp___2, 1L);
      }
      if (! tmp___3) {
        {
        free_pages((unsigned long )tbuf, 0U);
        }
        return (-22);
      }
    }
    {
    while (1) {
      while_322_continue: /* CIL Label */ ;
      if (usbfs_snoop) {
        {
        tmp___4 = dev_name((struct device  const  *)(& dev->dev));
        tmp___5 = dev_driver_string((struct device  const  *)(& dev->dev));
        printk("<6>%s %s: control read: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x wLength=%04x\n",
               tmp___5, tmp___4, ctrl.bRequest, ctrl.bRequestType, ctrl.wValue, ctrl.wIndex,
               ctrl.wLength);
        }
      }
      goto while_322_break;
    }
    while_322_break: /* CIL Label */ ;
    }
    {
    up(& dev->dev.sem);
    tmp___6 = __create_pipe(dev, 0U);
    i = usb_control_msg(dev, ((unsigned int )(2 << 30) | tmp___6) | 128U, ctrl.bRequest,
                        ctrl.bRequestType, ctrl.wValue, ctrl.wIndex, (void *)tbuf,
                        ctrl.wLength, (int )tmo);
    down(& dev->dev.sem);
    }
    if (i > 0) {
      if (ctrl.wLength) {
        if (usbfs_snoop) {
          {
          tmp___7 = dev_name((struct device  const  *)(& dev->dev));
          tmp___8 = dev_driver_string((struct device  const  *)(& dev->dev));
          printk("<6>%s %s: control read: data ", tmp___8, tmp___7);
          j = 0;
          }
          {
          while (1) {
            while_323_continue: /* CIL Label */ ;
            if (! (j < i)) {
              goto while_323_break;
            }
            {
            printk("%02x ", *(tbuf + j));
            j ++;
            }
          }
          while_323_break: /* CIL Label */ ;
          }
          {
          printk("\n");
          }
        }
        {
        tmp___9 = copy_to_user(ctrl.data, (void const   *)tbuf, (unsigned long )i);
        }
        if (tmp___9) {
          {
          free_pages((unsigned long )tbuf, 0U);
          }
          return (-14);
        }
      }
    }
  } else {
    if (ctrl.wLength) {
      {
      tmp___10 = copy_from_user((void *)tbuf, (void const   *)ctrl.data, (unsigned long )ctrl.wLength);
      }
      if (tmp___10) {
        {
        free_pages((unsigned long )tbuf, 0U);
        }
        return (-14);
      }
    }
    {
    while (1) {
      while_324_continue: /* CIL Label */ ;
      if (usbfs_snoop) {
        {
        tmp___11 = dev_name((struct device  const  *)(& dev->dev));
        tmp___12 = dev_driver_string((struct device  const  *)(& dev->dev));
        printk("<6>%s %s: control write: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x wLength=%04x\n",
               tmp___12, tmp___11, ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
               ctrl.wIndex, ctrl.wLength);
        }
      }
      goto while_324_break;
    }
    while_324_break: /* CIL Label */ ;
    }
    if (usbfs_snoop) {
      {
      tmp___13 = dev_name((struct device  const  *)(& dev->dev));
      tmp___14 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<6>%s %s: control write: data: ", tmp___14, tmp___13);
      j = 0;
      }
      {
      while (1) {
        while_325_continue: /* CIL Label */ ;
        if (! (j < (int )ctrl.wLength)) {
          goto while_325_break;
        }
        {
        printk("%02x ", *(tbuf + j));
        j ++;
        }
      }
      while_325_break: /* CIL Label */ ;
      }
      {
      printk("\n");
      }
    }
    {
    up(& dev->dev.sem);
    tmp___15 = __create_pipe(dev, 0U);
    i = usb_control_msg(dev, (unsigned int )(2 << 30) | tmp___15, ctrl.bRequest, ctrl.bRequestType,
                        ctrl.wValue, ctrl.wIndex, (void *)tbuf, ctrl.wLength, (int )tmo);
    down(& dev->dev.sem);
    }
  }
  {
  free_pages((unsigned long )tbuf, 0U);
  }
  if (i < 0) {
    if (i != -32) {
      {
      tmp___16 = get_current();
      tmp___17 = dev_name((struct device  const  *)(& dev->dev));
      tmp___18 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<7>%s %s: usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\n",
             tmp___18, tmp___17, tmp___16->comm, ctrl.bRequestType, ctrl.bRequest,
             ctrl.wLength, i);
      }
    }
  }
  return (i);
}
}
static int proc_bulk(struct dev_state *ps , void *arg ) 
{ struct usb_device *dev ;
  struct usbdevfs_bulktransfer bulk ;
  unsigned int tmo ;
  unsigned int len1 ;
  unsigned int pipe ;
  int len2 ;
  unsigned char *tbuf ;
  int i ;
  int j ;
  int ret ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  __u16 tmp___2 ;
  void *tmp___3 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;

  {
  {
  dev = ps->dev;
  tmp = copy_from_user((void *)(& bulk), (void const   *)arg, sizeof(bulk));
  }
  if (tmp) {
    return (-14);
  }
  {
  ret = findintfep(ps->dev, bulk.ep);
  }
  if (ret < 0) {
    return (ret);
  }
  {
  ret = checkintf(ps, (unsigned int )ret);
  }
  if (ret) {
    return (ret);
  }
  if (bulk.ep & 128U) {
    {
    tmp___0 = __create_pipe(dev, bulk.ep & 127U);
    pipe = ((unsigned int )(3 << 30) | tmp___0) | 128U;
    }
  } else {
    {
    tmp___1 = __create_pipe(dev, bulk.ep & 127U);
    pipe = (unsigned int )(3 << 30) | tmp___1;
    }
  }
  {
  tmp___2 = usb_maxpacket(dev, (int )pipe, ! (bulk.ep & 128U));
  }
  if (! tmp___2) {
    return (-22);
  }
  {
  len1 = bulk.len;
  }
  if (len1 > 16384U) {
    return (-22);
  }
  {
  tmp___3 = kmalloc(len1, 208U);
  tbuf = (unsigned char *)tmp___3;
  }
  if (! tbuf) {
    return (-12);
  }
  {
  tmo = bulk.timeout;
  }
  if (bulk.ep & 128U) {
    if (len1) {
      {
      tmp___4 = current_thread_info();
      __asm__  ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (bulk.data),
                "g" ((long )len1), "rm" (tmp___4->addr_limit.seg));
      }
      if (flag == 0UL) {
        {
        tmp___5 = 1;
        }
      } else {
        {
        tmp___5 = 0;
        }
      }
      {
      tmp___6 = __builtin_expect((long )tmp___5, 1L);
      }
      if (! tmp___6) {
        {
        kfree((void const   *)tbuf);
        }
        return (-22);
      }
    }
    {
    while (1) {
      while_326_continue: /* CIL Label */ ;
      if (usbfs_snoop) {
        {
        tmp___7 = dev_name((struct device  const  *)(& dev->dev));
        tmp___8 = dev_driver_string((struct device  const  *)(& dev->dev));
        printk("<6>%s %s: bulk read: len=0x%02x timeout=%04d\n", tmp___8, tmp___7,
               bulk.len, bulk.timeout);
        }
      }
      goto while_326_break;
    }
    while_326_break: /* CIL Label */ ;
    }
    {
    up(& dev->dev.sem);
    i = usb_bulk_msg(dev, pipe, (void *)tbuf, (int )len1, & len2, (int )tmo);
    down(& dev->dev.sem);
    }
    if (! i) {
      if (len2) {
        if (usbfs_snoop) {
          {
          tmp___9 = dev_name((struct device  const  *)(& dev->dev));
          tmp___10 = dev_driver_string((struct device  const  *)(& dev->dev));
          printk("<6>%s %s: bulk read: data ", tmp___10, tmp___9);
          j = 0;
          }
          {
          while (1) {
            while_327_continue: /* CIL Label */ ;
            if (! (j < len2)) {
              goto while_327_break;
            }
            {
            printk("%02x ", *(tbuf + j));
            j ++;
            }
          }
          while_327_break: /* CIL Label */ ;
          }
          {
          printk("\n");
          }
        }
        {
        tmp___11 = copy_to_user(bulk.data, (void const   *)tbuf, (unsigned long )len2);
        }
        if (tmp___11) {
          {
          kfree((void const   *)tbuf);
          }
          return (-14);
        }
      }
    }
  } else {
    if (len1) {
      {
      tmp___12 = copy_from_user((void *)tbuf, (void const   *)bulk.data, (unsigned long )len1);
      }
      if (tmp___12) {
        {
        kfree((void const   *)tbuf);
        }
        return (-14);
      }
    }
    {
    while (1) {
      while_328_continue: /* CIL Label */ ;
      if (usbfs_snoop) {
        {
        tmp___13 = dev_name((struct device  const  *)(& dev->dev));
        tmp___14 = dev_driver_string((struct device  const  *)(& dev->dev));
        printk("<6>%s %s: bulk write: len=0x%02x timeout=%04d\n", tmp___14, tmp___13,
               bulk.len, bulk.timeout);
        }
      }
      goto while_328_break;
    }
    while_328_break: /* CIL Label */ ;
    }
    if (usbfs_snoop) {
      {
      tmp___15 = dev_name((struct device  const  *)(& dev->dev));
      tmp___16 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<6>%s %s: bulk write: data: ", tmp___16, tmp___15);
      j = 0;
      }
      {
      while (1) {
        while_329_continue: /* CIL Label */ ;
        if (! ((unsigned int )j < len1)) {
          goto while_329_break;
        }
        {
        printk("%02x ", *(tbuf + j));
        j ++;
        }
      }
      while_329_break: /* CIL Label */ ;
      }
      {
      printk("\n");
      }
    }
    {
    up(& dev->dev.sem);
    i = usb_bulk_msg(dev, pipe, (void *)tbuf, (int )len1, & len2, (int )tmo);
    down(& dev->dev.sem);
    }
  }
  {
  kfree((void const   *)tbuf);
  }
  if (i < 0) {
    return (i);
  }
  return (len2);
}
}
static int proc_resetep(struct dev_state *ps , void *arg ) 
{ unsigned int ep ;
  int ret ;
  int __ret_gu ;
  unsigned long __val_gu ;

  {
  {
  might_fault();
  }
  if ((int )sizeof(*((unsigned int *)arg)) == 1) {
    goto switch_330_1;
  } else {
    if ((int )sizeof(*((unsigned int *)arg)) == 2) {
      goto switch_330_2;
    } else {
      if ((int )sizeof(*((unsigned int *)arg)) == 4) {
        goto switch_330_4;
      } else {
        if ((int )sizeof(*((unsigned int *)arg)) == 8) {
          goto switch_330_8;
        } else {
          {
          goto switch_330_default;
          if (0) {
            switch_330_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "1": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_330_break;
            switch_330_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "2": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_330_break;
            switch_330_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "4": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_330_break;
            switch_330_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_330_break;
            switch_330_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_330_break;
          } else {
            switch_330_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ep = (unsigned int )__val_gu;
  }
  if (__ret_gu) {
    return (-14);
  }
  {
  ret = findintfep(ps->dev, ep);
  }
  if (ret < 0) {
    return (ret);
  }
  {
  ret = checkintf(ps, (unsigned int )ret);
  }
  if (ret) {
    return (ret);
  }
  {
  usb_reset_endpoint(ps->dev, ep);
  }
  return (0);
}
}
static int proc_clearhalt(struct dev_state *ps , void *arg ) 
{ unsigned int ep ;
  int pipe ;
  int ret ;
  int __ret_gu ;
  unsigned long __val_gu ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
  might_fault();
  }
  if ((int )sizeof(*((unsigned int *)arg)) == 1) {
    goto switch_331_1;
  } else {
    if ((int )sizeof(*((unsigned int *)arg)) == 2) {
      goto switch_331_2;
    } else {
      if ((int )sizeof(*((unsigned int *)arg)) == 4) {
        goto switch_331_4;
      } else {
        if ((int )sizeof(*((unsigned int *)arg)) == 8) {
          goto switch_331_8;
        } else {
          {
          goto switch_331_default;
          if (0) {
            switch_331_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "1": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_331_break;
            switch_331_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "2": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_331_break;
            switch_331_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "4": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_331_break;
            switch_331_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_331_break;
            switch_331_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_331_break;
          } else {
            switch_331_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ep = (unsigned int )__val_gu;
  }
  if (__ret_gu) {
    return (-14);
  }
  {
  ret = findintfep(ps->dev, ep);
  }
  if (ret < 0) {
    return (ret);
  }
  {
  ret = checkintf(ps, (unsigned int )ret);
  }
  if (ret) {
    return (ret);
  }
  if (ep & 128U) {
    {
    tmp = __create_pipe(ps->dev, ep & 127U);
    pipe = (int )(((unsigned int )(3 << 30) | tmp) | 128U);
    }
  } else {
    {
    tmp___0 = __create_pipe(ps->dev, ep & 127U);
    pipe = (int )((unsigned int )(3 << 30) | tmp___0);
    }
  }
  {
  tmp___1 = usb_clear_halt(ps->dev, pipe);
  }
  return (tmp___1);
}
}
static int proc_getdriver(struct dev_state *ps , void *arg ) 
{ struct usbdevfs_getdriver gd ;
  struct usb_interface *intf ;
  int ret ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  tmp = copy_from_user((void *)(& gd), (void const   *)arg, sizeof(gd));
  }
  if (tmp) {
    return (-14);
  }
  {
  intf = usb_ifnum_to_if((struct usb_device  const  *)ps->dev, gd.interface);
  }
  if (! intf) {
    {
    ret = -61;
    }
  } else {
    if (! intf->dev.driver) {
      {
      ret = -61;
      }
    } else {
      {
      strncpy(gd.driver, (intf->dev.driver)->name, (unsigned int )sizeof(gd.driver));
      tmp___1 = copy_to_user(arg, (void const   *)(& gd), sizeof(gd));
      }
      if (tmp___1) {
        {
        ret = -14;
        }
      } else {
        {
        ret = 0;
        }
      }
    }
  }
  return (ret);
}
}
static int proc_connectinfo(struct dev_state *ps , void *arg ) 
{ struct usbdevfs_connectinfo ci ;
  unsigned long tmp ;

  {
  {
  ci.devnum = (unsigned int )(ps->dev)->devnum;
  ci.slow = (unsigned char )((unsigned int )(ps->dev)->speed == 1U);
  tmp = copy_to_user(arg, (void const   *)(& ci), sizeof(ci));
  }
  if (tmp) {
    return (-14);
  }
  return (0);
}
}
static int proc_resetdevice(struct dev_state *ps ) 
{ int tmp ;

  {
  {
  tmp = usb_reset_device(ps->dev);
  }
  return (tmp);
}
}
static int proc_setintf(struct dev_state *ps , void *arg ) 
{ struct usbdevfs_setinterface setintf ;
  int ret ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp = copy_from_user((void *)(& setintf), (void const   *)arg, sizeof(setintf));
  }
  if (tmp) {
    return (-14);
  }
  {
  ret = checkintf(ps, setintf.interface);
  }
  if (ret) {
    return (ret);
  }
  {
  tmp___0 = usb_set_interface(ps->dev, (int )setintf.interface, (int )setintf.altsetting);
  }
  return (tmp___0);
}
}
static int proc_setconfig(struct dev_state *ps , void *arg ) 
{ int u ;
  int status ;
  struct usb_host_config *actconfig ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int i ;
  struct task_struct *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
  status = 0;
  might_fault();
  }
  if ((int )sizeof(*((int *)arg)) == 1) {
    goto switch_332_1;
  } else {
    if ((int )sizeof(*((int *)arg)) == 2) {
      goto switch_332_2;
    } else {
      if ((int )sizeof(*((int *)arg)) == 4) {
        goto switch_332_4;
      } else {
        if ((int )sizeof(*((int *)arg)) == 8) {
          goto switch_332_8;
        } else {
          {
          goto switch_332_default;
          if (0) {
            switch_332_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "1": "=a" (__ret_gu), "=d" (__val_gu): "0" ((int *)arg));
            }
            goto switch_332_break;
            switch_332_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "2": "=a" (__ret_gu), "=d" (__val_gu): "0" ((int *)arg));
            }
            goto switch_332_break;
            switch_332_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "4": "=a" (__ret_gu), "=d" (__val_gu): "0" ((int *)arg));
            }
            goto switch_332_break;
            switch_332_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((int *)arg));
            }
            goto switch_332_break;
            switch_332_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((int *)arg));
            }
            goto switch_332_break;
          } else {
            switch_332_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  u = (int )__val_gu;
  }
  if (__ret_gu) {
    return (-14);
  }
  {
  actconfig = (ps->dev)->actconfig;
  }
  if (actconfig) {
    {
    i = 0;
    }
    {
    while (1) {
      while_333_continue: /* CIL Label */ ;
      if (! (i < (int )actconfig->desc.bNumInterfaces)) {
        goto while_333_break;
      }
      {
      tmp___2 = usb_interface_claimed(actconfig->interface[i]);
      }
      if (tmp___2) {
        {
        tmp = get_current();
        tmp___0 = dev_name((struct device  const  *)(& (ps->dev)->dev));
        tmp___1 = dev_driver_string((struct device  const  *)(& (ps->dev)->dev));
        printk("<4>%s %s: usbfs: interface %d claimed by %s while \'%s\' sets config #%d\n",
               tmp___1, tmp___0, ((actconfig->interface[i])->cur_altsetting)->desc.bInterfaceNumber,
               ((actconfig->interface[i])->dev.driver)->name, tmp->comm, u);
        status = -16;
        }
        goto while_333_break;
      }
      {
      i ++;
      }
    }
    while_333_break: /* CIL Label */ ;
    }
  }
  if (status == 0) {
    if (actconfig) {
      if ((int )actconfig->desc.bConfigurationValue == u) {
        {
        status = usb_reset_configuration(ps->dev);
        }
      } else {
        {
        status = usb_set_configuration(ps->dev, u);
        }
      }
    } else {
      {
      status = usb_set_configuration(ps->dev, u);
      }
    }
  }
  return (status);
}
}
static int proc_do_submiturb(struct dev_state *ps , struct usbdevfs_urb *uurb , struct usbdevfs_iso_packet_desc *iso_frame_desc ,
                             void *arg ) 
{ struct usbdevfs_iso_packet_desc *isopkt ;
  struct usb_host_endpoint *ep ;
  struct async *as ;
  struct usb_ctrlrequest *dr ;
  struct cred  const  *cred ;
  struct task_struct *tmp ;
  unsigned int u ;
  unsigned int totlen ;
  unsigned int isofrmlen ;
  int ret ;
  int ifnum ;
  int is_in ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  __u16 tmp___5 ;
  __u16 tmp___6 ;
  __u16 tmp___7 ;
  __u16 tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  unsigned long tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___22 ;
  int tmp___23 ;
  long tmp___24 ;
  unsigned int tmp___25 ;
  int _min1 ;
  int _min2 ;
  int tmp___26 ;
  struct task_struct *tmp___27 ;
  struct pid *tmp___28 ;
  struct task_struct *tmp___29 ;
  unsigned long tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;

  {
  {
  isopkt = (struct usbdevfs_iso_packet_desc *)((void *)0);
  dr = (struct usb_ctrlrequest *)((void *)0);
  tmp = get_current();
  cred = tmp->cred;
  ifnum = -1;
  }
  if (uurb->flags & 4294967068U) {
    return (-22);
  }
  if (uurb->buffer_length > 0) {
    if (! uurb->buffer) {
      return (-22);
    }
  }
  if ((int )uurb->type == 2) {
    if (! (((int )uurb->endpoint & -129) == 0)) {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    ifnum = findintfep(ps->dev, (unsigned int )uurb->endpoint);
    }
    if (ifnum < 0) {
      return (ifnum);
    }
    {
    ret = checkintf(ps, (unsigned int )ifnum);
    }
    if (ret) {
      return (ret);
    }
  }
  if (((int )uurb->endpoint & 128) != 0) {
    {
    is_in = 1;
    ep = (ps->dev)->ep_in[(int )uurb->endpoint & 15];
    }
  } else {
    {
    is_in = 0;
    ep = (ps->dev)->ep_out[(int )uurb->endpoint & 15];
    }
  }
  if (! ep) {
    return (-2);
  }
  if ((int )uurb->type == 2) {
    goto switch_334_2;
  } else {
    if ((int )uurb->type == 3) {
      goto switch_334_3;
    } else {
      if ((int )uurb->type == 0) {
        goto switch_334_0;
      } else {
        if ((int )uurb->type == 1) {
          goto switch_334_1;
        } else {
          {
          goto switch_334_default;
          if (0) {
            switch_334_2: /* CIL Label */ 
            {
            tmp___0 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)(& ep->desc));
            }
            if (! tmp___0) {
              return (-22);
            }
            if (uurb->buffer_length < 8) {
              return (-22);
            } else {
              if (uurb->buffer_length > 16392) {
                return (-22);
              }
            }
            {
            tmp___1 = kmalloc((unsigned int )sizeof(struct usb_ctrlrequest ), 208U);
            dr = (struct usb_ctrlrequest *)tmp___1;
            }
            if (! dr) {
              return (-12);
            }
            {
            tmp___2 = copy_from_user((void *)dr, (void const   *)uurb->buffer, 8UL);
            }
            if (tmp___2) {
              {
              kfree((void const   *)dr);
              }
              return (-14);
            }
            {
            tmp___3 = __le16_to_cpup((__le16 const   *)(& dr->wLength));
            }
            if (uurb->buffer_length < (int )tmp___3 + 8) {
              {
              kfree((void const   *)dr);
              }
              return (-22);
            }
            {
            tmp___4 = __le16_to_cpup((__le16 const   *)(& dr->wIndex));
            ret = check_ctrlrecip(ps, (unsigned int )dr->bRequestType, (unsigned int )tmp___4);
            }
            if (ret) {
              {
              kfree((void const   *)dr);
              }
              return (ret);
            }
            {
            uurb->number_of_packets = 0;
            tmp___5 = __le16_to_cpup((__le16 const   *)(& dr->wLength));
            uurb->buffer_length = (int )tmp___5;
            uurb->buffer += 8;
            }
            if ((int )dr->bRequestType & 128) {
              if (uurb->buffer_length) {
                {
                is_in = 1;
                uurb->endpoint = (unsigned char )((int )uurb->endpoint | 128);
                }
              } else {
                {
                is_in = 0;
                uurb->endpoint = (unsigned char )((int )uurb->endpoint & -129);
                }
              }
            } else {
              {
              is_in = 0;
              uurb->endpoint = (unsigned char )((int )uurb->endpoint & -129);
              }
            }
            {
            while (1) {
              while_335_continue: /* CIL Label */ ;
              if (usbfs_snoop) {
                {
                tmp___6 = __le16_to_cpup((__le16 const   *)(& dr->wLength));
                tmp___7 = __le16_to_cpup((__le16 const   *)(& dr->wIndex));
                tmp___8 = __le16_to_cpup((__le16 const   *)(& dr->wValue));
                tmp___9 = dev_name((struct device  const  *)(& (ps->dev)->dev));
                tmp___10 = dev_driver_string((struct device  const  *)(& (ps->dev)->dev));
                printk("<6>%s %s: control urb: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x wLength=%04x\n",
                       tmp___10, tmp___9, dr->bRequest, dr->bRequestType, tmp___8,
                       tmp___7, tmp___6);
                }
              }
              goto while_335_break;
            }
            while_335_break: /* CIL Label */ ;
            }
            goto switch_334_break;
            switch_334_3: /* CIL Label */ 
            {
            tmp___11 = usb_endpoint_type((struct usb_endpoint_descriptor  const  *)(& ep->desc));
            }
            if (tmp___11 == 0) {
              goto switch_336_0;
            } else {
              if (tmp___11 == 1) {
                goto switch_336_0;
              } else {
                if (0) {
                  switch_336_0: /* CIL Label */ 
                  switch_336_1: /* CIL Label */ 
                  return (-22);
                } else {
                  switch_336_break: /* CIL Label */ ;
                }
              }
            }
            {
            uurb->number_of_packets = 0;
            }
            if (uurb->buffer_length > 16384) {
              return (-22);
            }
            {
            while (1) {
              while_337_continue: /* CIL Label */ ;
              if (usbfs_snoop) {
                {
                tmp___12 = dev_name((struct device  const  *)(& (ps->dev)->dev));
                tmp___13 = dev_driver_string((struct device  const  *)(& (ps->dev)->dev));
                printk("<6>%s %s: bulk urb\n", tmp___13, tmp___12);
                }
              }
              goto while_337_break;
            }
            while_337_break: /* CIL Label */ ;
            }
            goto switch_334_break;
            switch_334_0: /* CIL Label */ 
            if (uurb->number_of_packets < 1) {
              return (-22);
            } else {
              if (uurb->number_of_packets > 128) {
                return (-22);
              }
            }
            {
            tmp___14 = usb_endpoint_xfer_isoc((struct usb_endpoint_descriptor  const  *)(& ep->desc));
            }
            if (! tmp___14) {
              return (-22);
            }
            {
            isofrmlen = (unsigned int )(sizeof(struct usbdevfs_iso_packet_desc ) * (unsigned long )uurb->number_of_packets);
            tmp___15 = kmalloc(isofrmlen, 208U);
            isopkt = (struct usbdevfs_iso_packet_desc *)tmp___15;
            }
            if (! isopkt) {
              return (-12);
            }
            {
            tmp___16 = copy_from_user((void *)isopkt, (void const   *)iso_frame_desc,
                                      (unsigned long )isofrmlen);
            }
            if (tmp___16) {
              {
              kfree((void const   *)isopkt);
              }
              return (-14);
            }
            {
            u = 0U;
            totlen = u;
            }
            {
            while (1) {
              while_338_continue: /* CIL Label */ ;
              if (! (u < (unsigned int )uurb->number_of_packets)) {
                goto while_338_break;
              }
              if ((isopkt + u)->length > 8192U) {
                {
                kfree((void const   *)isopkt);
                }
                return (-22);
              }
              {
              totlen += (isopkt + u)->length;
              u ++;
              }
            }
            while_338_break: /* CIL Label */ ;
            }
            if (totlen > 32768U) {
              {
              kfree((void const   *)isopkt);
              }
              return (-22);
            }
            {
            uurb->buffer_length = (int )totlen;
            }
            {
            while (1) {
              while_339_continue: /* CIL Label */ ;
              if (usbfs_snoop) {
                {
                tmp___17 = dev_name((struct device  const  *)(& (ps->dev)->dev));
                tmp___18 = dev_driver_string((struct device  const  *)(& (ps->dev)->dev));
                printk("<6>%s %s: iso urb\n", tmp___18, tmp___17);
                }
              }
              goto while_339_break;
            }
            while_339_break: /* CIL Label */ ;
            }
            goto switch_334_break;
            switch_334_1: /* CIL Label */ 
            {
            uurb->number_of_packets = 0;
            tmp___19 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)(& ep->desc));
            }
            if (! tmp___19) {
              return (-22);
            }
            if (uurb->buffer_length > 16384) {
              return (-22);
            }
            {
            while (1) {
              while_340_continue: /* CIL Label */ ;
              if (usbfs_snoop) {
                {
                tmp___20 = dev_name((struct device  const  *)(& (ps->dev)->dev));
                tmp___21 = dev_driver_string((struct device  const  *)(& (ps->dev)->dev));
                printk("<6>%s %s: interrupt urb\n", tmp___21, tmp___20);
                }
              }
              goto while_340_break;
            }
            while_340_break: /* CIL Label */ ;
            }
            goto switch_334_break;
            switch_334_default: /* CIL Label */ 
            {

            }
            return (-22);
          } else {
            switch_334_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if (uurb->buffer_length > 0) {
    {
    tmp___22 = current_thread_info();
    __asm__  ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (uurb->buffer),
              "g" ((long )uurb->buffer_length), "rm" (tmp___22->addr_limit.seg));
    }
    if (flag == 0UL) {
      {
      tmp___23 = 1;
      }
    } else {
      {
      tmp___23 = 0;
      }
    }
    {
    tmp___24 = __builtin_expect((long )tmp___23, 1L);
    }
    if (! tmp___24) {
      {
      kfree((void const   *)isopkt);
      kfree((void const   *)dr);
      }
      return (-14);
    }
  }
  {
  as = alloc_async((unsigned int )uurb->number_of_packets);
  }
  if (! as) {
    {
    kfree((void const   *)isopkt);
    kfree((void const   *)dr);
    }
    return (-12);
  }
  if (uurb->buffer_length > 0) {
    {
    (as->urb)->transfer_buffer = kmalloc((unsigned int )uurb->buffer_length, 208U);
    }
    if (! (as->urb)->transfer_buffer) {
      {
      kfree((void const   *)isopkt);
      kfree((void const   *)dr);
      free_async(as);
      }
      return (-12);
    }
  }
  {
  (as->urb)->dev = ps->dev;
  tmp___25 = __create_pipe(ps->dev, (unsigned int )((int )uurb->endpoint & 15));
  (as->urb)->pipe = ((unsigned int )((int )uurb->type << 30) | tmp___25) | (unsigned int )((int )uurb->endpoint & 128);
  }
  if (is_in) {
    {
    u = 512U;
    }
  } else {
    {
    u = 0U;
    }
  }
  if (uurb->flags & 2U) {
    {
    u |= 2U;
    }
  }
  if (uurb->flags & 1U) {
    {
    u |= 1U;
    }
  }
  if (uurb->flags & 32U) {
    {
    u |= 32U;
    }
  }
  if (uurb->flags & 64U) {
    {
    u |= 64U;
    }
  }
  if (uurb->flags & 128U) {
    {
    u |= 128U;
    }
  }
  {
  (as->urb)->transfer_flags = u;
  (as->urb)->transfer_buffer_length = (unsigned int )uurb->buffer_length;
  (as->urb)->setup_packet = (unsigned char *)dr;
  (as->urb)->start_frame = uurb->start_frame;
  (as->urb)->number_of_packets = uurb->number_of_packets;
  }
  if ((int )uurb->type == 0) {
    goto _L___0;
  } else {
    if ((unsigned int )(ps->dev)->speed == 3U) {
      _L___0: /* CIL Label */ 
      {
      _min1 = 15;
      _min2 = (int )ep->desc.bInterval - 1;
      }
      if (_min1 < _min2) {
        {
        tmp___26 = _min1;
        }
      } else {
        {
        tmp___26 = _min2;
        }
      }
      {
      (as->urb)->interval = 1 << tmp___26;
      }
    } else {
      {
      (as->urb)->interval = (int )ep->desc.bInterval;
      }
    }
  }
  {
  (as->urb)->context = (void *)as;
  (as->urb)->complete = & async_completed;
  u = 0U;
  totlen = u;
  }
  {
  while (1) {
    while_341_continue: /* CIL Label */ ;
    if (! (u < (unsigned int )uurb->number_of_packets)) {
      goto while_341_break;
    }
    {
    (as->urb)->iso_frame_desc[u].offset = totlen;
    (as->urb)->iso_frame_desc[u].length = (isopkt + u)->length;
    totlen += (isopkt + u)->length;
    u ++;
    }
  }
  while_341_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)isopkt);
  as->ps = ps;
  as->userurb = arg;
  }
  if (is_in) {
    if (uurb->buffer_length > 0) {
      {
      as->userbuffer = uurb->buffer;
      }
    } else {
      {
      as->userbuffer = (void *)0;
      }
    }
  } else {
    {
    as->userbuffer = (void *)0;
    }
  }
  {
  as->signr = uurb->signr;
  as->ifnum = (unsigned int )ifnum;
  tmp___27 = get_current();
  tmp___28 = task_pid(tmp___27);
  as->pid = get_pid(tmp___28);
  as->uid = (unsigned int )cred->uid;
  as->euid = (unsigned int )cred->euid;
  tmp___29 = get_current();
  security_task_getsecid(tmp___29, & as->secid);
  }
  if (! is_in) {
    if (uurb->buffer_length > 0) {
      {
      tmp___30 = copy_from_user((as->urb)->transfer_buffer, (void const   *)uurb->buffer,
                                (unsigned long )uurb->buffer_length);
      }
      if (tmp___30) {
        {
        free_async(as);
        }
        return (-14);
      }
    }
  }
  {
  snoop_urb(as->urb, as->userurb);
  async_newpending(as);
  ret = usb_submit_urb(as->urb, 208U);
  }
  if (ret) {
    {
    tmp___31 = dev_name((struct device  const  *)(& (ps->dev)->dev));
    tmp___32 = dev_driver_string((struct device  const  *)(& (ps->dev)->dev));
    printk("<7>%s %s: usbfs: usb_submit_urb returned %d\n", tmp___32, tmp___31, ret);
    async_removepending(as);
    free_async(as);
    }
    return (ret);
  }
  return (0);
}
}
static int proc_submiturb(struct dev_state *ps , void *arg ) 
{ struct usbdevfs_urb uurb ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp = copy_from_user((void *)(& uurb), (void const   *)arg, sizeof(uurb));
  }
  if (tmp) {
    return (-14);
  }
  {
  tmp___0 = proc_do_submiturb(ps, & uurb, ((struct usbdevfs_urb *)arg)->iso_frame_desc,
                              arg);
  }
  return (tmp___0);
}
}
static int proc_unlinkurb(struct dev_state *ps , void *arg ) 
{ struct async *as ;

  {
  {
  as = async_getpending(ps, arg);
  }
  if (! as) {
    return (-22);
  }
  {
  usb_kill_urb(as->urb);
  }
  return (0);
}
}
static int processcompl(struct async *as , void **arg ) 
{ struct urb *urb ;
  struct usbdevfs_urb *userurb ;
  void *addr ;
  unsigned int i ;
  unsigned long tmp ;
  int __ret_pu ;
  int __pu_val ;
  int __ret_pu___0 ;
  int __pu_val___0 ;
  int __ret_pu___1 ;
  int __pu_val___1 ;
  int __ret_pu___2 ;
  unsigned int __pu_val___2 ;
  int __ret_pu___3 ;
  unsigned int __pu_val___3 ;
  int tmp___0 ;
  int __ret_pu___4 ;
  void *__pu_val___4 ;

  {
  {
  urb = as->urb;
  userurb = (struct usbdevfs_urb *)as->userurb;
  addr = as->userurb;
  }
  if (as->userbuffer) {
    {
    tmp = copy_to_user(as->userbuffer, (void const   *)urb->transfer_buffer, (unsigned long )urb->transfer_buffer_length);
    }
    if (tmp) {
      goto err_out;
    }
  }
  {
  might_fault();
  __pu_val = as->status;
  }
  if ((int )sizeof(userurb->status) == 1) {
    goto switch_342_1;
  } else {
    if ((int )sizeof(userurb->status) == 2) {
      goto switch_342_2;
    } else {
      if ((int )sizeof(userurb->status) == 4) {
        goto switch_342_4;
      } else {
        if ((int )sizeof(userurb->status) == 8) {
          goto switch_342_8;
        } else {
          {
          goto switch_342_default;
          if (0) {
            switch_342_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "1": "=a" (__ret_pu): "0" (__pu_val), "c" (& userurb->status): "ebx");
            }
            goto switch_342_break;
            switch_342_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "2": "=a" (__ret_pu): "0" (__pu_val), "c" (& userurb->status): "ebx");
            }
            goto switch_342_break;
            switch_342_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "4": "=a" (__ret_pu): "0" (__pu_val), "c" (& userurb->status): "ebx");
            }
            goto switch_342_break;
            switch_342_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "A" (__pu_val),
                                 "c" (& userurb->status): "ebx");
            }
            goto switch_342_break;
            switch_342_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "X": "=a" (__ret_pu): "0" (__pu_val), "c" (& userurb->status): "ebx");
            }
            goto switch_342_break;
          } else {
            switch_342_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if (__ret_pu) {
    goto err_out;
  }
  {
  might_fault();
  __pu_val___0 = (int )urb->actual_length;
  }
  if ((int )sizeof(userurb->actual_length) == 1) {
    goto switch_343_1;
  } else {
    if ((int )sizeof(userurb->actual_length) == 2) {
      goto switch_343_2;
    } else {
      if ((int )sizeof(userurb->actual_length) == 4) {
        goto switch_343_4;
      } else {
        if ((int )sizeof(userurb->actual_length) == 8) {
          goto switch_343_8;
        } else {
          {
          goto switch_343_default;
          if (0) {
            switch_343_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "1": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" (& userurb->actual_length): "ebx");
            }
            goto switch_343_break;
            switch_343_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "2": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" (& userurb->actual_length): "ebx");
            }
            goto switch_343_break;
            switch_343_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "4": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" (& userurb->actual_length): "ebx");
            }
            goto switch_343_break;
            switch_343_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "A" (__pu_val___0),
                                 "c" (& userurb->actual_length): "ebx");
            }
            goto switch_343_break;
            switch_343_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "X": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" (& userurb->actual_length): "ebx");
            }
            goto switch_343_break;
          } else {
            switch_343_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if (__ret_pu___0) {
    goto err_out;
  }
  {
  might_fault();
  __pu_val___1 = urb->error_count;
  }
  if ((int )sizeof(userurb->error_count) == 1) {
    goto switch_344_1;
  } else {
    if ((int )sizeof(userurb->error_count) == 2) {
      goto switch_344_2;
    } else {
      if ((int )sizeof(userurb->error_count) == 4) {
        goto switch_344_4;
      } else {
        if ((int )sizeof(userurb->error_count) == 8) {
          goto switch_344_8;
        } else {
          {
          goto switch_344_default;
          if (0) {
            switch_344_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "1": "=a" (__ret_pu___1): "0" (__pu_val___1), "c" (& userurb->error_count): "ebx");
            }
            goto switch_344_break;
            switch_344_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "2": "=a" (__ret_pu___1): "0" (__pu_val___1), "c" (& userurb->error_count): "ebx");
            }
            goto switch_344_break;
            switch_344_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "4": "=a" (__ret_pu___1): "0" (__pu_val___1), "c" (& userurb->error_count): "ebx");
            }
            goto switch_344_break;
            switch_344_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___1): "A" (__pu_val___1),
                                 "c" (& userurb->error_count): "ebx");
            }
            goto switch_344_break;
            switch_344_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "X": "=a" (__ret_pu___1): "0" (__pu_val___1), "c" (& userurb->error_count): "ebx");
            }
            goto switch_344_break;
          } else {
            switch_344_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if (__ret_pu___1) {
    goto err_out;
  }
  {
  tmp___0 = usb_endpoint_xfer_isoc((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
  }
  if (tmp___0) {
    {
    i = 0U;
    }
    {
    while (1) {
      while_345_continue: /* CIL Label */ ;
      if (! (i < (unsigned int )urb->number_of_packets)) {
        goto while_345_break;
      }
      {
      might_fault();
      __pu_val___2 = urb->iso_frame_desc[i].actual_length;
      }
      if ((int )sizeof(userurb->iso_frame_desc[i].actual_length) == 1) {
        goto switch_346_1;
      } else {
        if ((int )sizeof(userurb->iso_frame_desc[i].actual_length) == 2) {
          goto switch_346_2;
        } else {
          if ((int )sizeof(userurb->iso_frame_desc[i].actual_length) == 4) {
            goto switch_346_4;
          } else {
            if ((int )sizeof(userurb->iso_frame_desc[i].actual_length) == 8) {
              goto switch_346_8;
            } else {
              {
              goto switch_346_default;
              if (0) {
                switch_346_1: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "1": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                     "c" (& userurb->iso_frame_desc[i].actual_length): "ebx");
                }
                goto switch_346_break;
                switch_346_2: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "2": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                     "c" (& userurb->iso_frame_desc[i].actual_length): "ebx");
                }
                goto switch_346_break;
                switch_346_4: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "4": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                     "c" (& userurb->iso_frame_desc[i].actual_length): "ebx");
                }
                goto switch_346_break;
                switch_346_8: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___2): "A" (__pu_val___2),
                                     "c" (& userurb->iso_frame_desc[i].actual_length): "ebx");
                }
                goto switch_346_break;
                switch_346_default: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "X": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                     "c" (& userurb->iso_frame_desc[i].actual_length): "ebx");
                }
                goto switch_346_break;
              } else {
                switch_346_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
      if (__ret_pu___2) {
        goto err_out;
      }
      {
      might_fault();
      __pu_val___3 = (unsigned int )urb->iso_frame_desc[i].status;
      }
      if ((int )sizeof(userurb->iso_frame_desc[i].status) == 1) {
        goto switch_347_1;
      } else {
        if ((int )sizeof(userurb->iso_frame_desc[i].status) == 2) {
          goto switch_347_2;
        } else {
          if ((int )sizeof(userurb->iso_frame_desc[i].status) == 4) {
            goto switch_347_4;
          } else {
            if ((int )sizeof(userurb->iso_frame_desc[i].status) == 8) {
              goto switch_347_8;
            } else {
              {
              goto switch_347_default;
              if (0) {
                switch_347_1: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "1": "=a" (__ret_pu___3): "0" (__pu_val___3),
                                     "c" (& userurb->iso_frame_desc[i].status): "ebx");
                }
                goto switch_347_break;
                switch_347_2: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "2": "=a" (__ret_pu___3): "0" (__pu_val___3),
                                     "c" (& userurb->iso_frame_desc[i].status): "ebx");
                }
                goto switch_347_break;
                switch_347_4: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "4": "=a" (__ret_pu___3): "0" (__pu_val___3),
                                     "c" (& userurb->iso_frame_desc[i].status): "ebx");
                }
                goto switch_347_break;
                switch_347_8: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___3): "A" (__pu_val___3),
                                     "c" (& userurb->iso_frame_desc[i].status): "ebx");
                }
                goto switch_347_break;
                switch_347_default: /* CIL Label */ 
                {
                __asm__  volatile   ("call __put_user_"
                                     "X": "=a" (__ret_pu___3): "0" (__pu_val___3),
                                     "c" (& userurb->iso_frame_desc[i].status): "ebx");
                }
                goto switch_347_break;
              } else {
                switch_347_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
      if (__ret_pu___3) {
        goto err_out;
      }
      {
      i ++;
      }
    }
    while_345_break: /* CIL Label */ ;
    }
  }
  {
  free_async(as);
  might_fault();
  __pu_val___4 = addr;
  }
  if ((int )sizeof(*arg) == 1) {
    goto switch_348_1;
  } else {
    if ((int )sizeof(*arg) == 2) {
      goto switch_348_2;
    } else {
      if ((int )sizeof(*arg) == 4) {
        goto switch_348_4;
      } else {
        if ((int )sizeof(*arg) == 8) {
          goto switch_348_8;
        } else {
          {
          goto switch_348_default;
          if (0) {
            switch_348_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "1": "=a" (__ret_pu___4): "0" (__pu_val___4), "c" (arg): "ebx");
            }
            goto switch_348_break;
            switch_348_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "2": "=a" (__ret_pu___4): "0" (__pu_val___4), "c" (arg): "ebx");
            }
            goto switch_348_break;
            switch_348_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "4": "=a" (__ret_pu___4): "0" (__pu_val___4), "c" (arg): "ebx");
            }
            goto switch_348_break;
            switch_348_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___4): "A" (__pu_val___4),
                                 "c" (arg): "ebx");
            }
            goto switch_348_break;
            switch_348_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __put_user_"
                                 "X": "=a" (__ret_pu___4): "0" (__pu_val___4), "c" (arg): "ebx");
            }
            goto switch_348_break;
          } else {
            switch_348_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if (__ret_pu___4) {
    return (-14);
  }
  return (0);
  err_out: 
  {
  free_async(as);
  }
  return (-14);
}
}
static struct async *reap_as(struct dev_state *ps ) 
{ wait_queue_t wait ;
  struct task_struct *tmp ;
  struct async *as ;
  struct usb_device *dev ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;

  {
  {
  tmp = get_current();
  wait.flags = 0U;
  wait.private = (void *)tmp;
  wait.func = & default_wake_function;
  wait.task_list.next = (struct list_head *)((void *)0);
  wait.task_list.prev = (struct list_head *)((void *)0);
  as = (struct async *)((void *)0);
  dev = ps->dev;
  add_wait_queue(& ps->wait, & wait);
  }
  {
  while (1) {
    while_349_continue: /* CIL Label */ ;
    {
    while (1) {
      while_350_continue: /* CIL Label */ ;
      {
      tmp___0 = get_current();
      tmp___0->state = (long volatile   )1;
      }
      goto while_350_break;
    }
    while_350_break: /* CIL Label */ ;
    }
    {
    as = async_getcompleted(ps);
    }
    if (as) {
      goto while_349_break;
    }
    {
    tmp___1 = get_current();
    tmp___2 = signal_pending(tmp___1);
    }
    if (tmp___2) {
      goto while_349_break;
    }
    {
    up(& dev->dev.sem);
    schedule();
    down(& dev->dev.sem);
    }
  }
  while_349_break: /* CIL Label */ ;
  }
  {
  remove_wait_queue(& ps->wait, & wait);
  }
  {
  while (1) {
    while_351_continue: /* CIL Label */ ;
    {
    tmp___6 = get_current();
    __xchg(0UL, (void volatile   *)(& tmp___6->state), (int )sizeof(tmp___5->state));
    }
    goto while_351_break;
  }
  while_351_break: /* CIL Label */ ;
  }
  return (as);
}
}
static int proc_reapurb(struct dev_state *ps , void *arg ) 
{ struct async *as ;
  struct async *tmp ;
  int tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = reap_as(ps);
  as = tmp;
  }
  if (as) {
    {
    tmp___0 = processcompl(as, (void **)arg);
    }
    return (tmp___0);
  }
  {
  tmp___1 = get_current();
  tmp___2 = signal_pending(tmp___1);
  }
  if (tmp___2) {
    return (-4);
  }
  return (-5);
}
}
static int proc_reapurbnonblock(struct dev_state *ps , void *arg ) 
{ struct async *as ;
  int tmp ;

  {
  {
  as = async_getcompleted(ps);
  }
  if (! as) {
    return (-11);
  }
  {
  tmp = processcompl(as, (void **)arg);
  }
  return (tmp);
}
}
static int proc_disconnectsignal(struct dev_state *ps , void *arg ) 
{ struct usbdevfs_disconnectsignal ds ;
  unsigned long tmp ;

  {
  {
  tmp = copy_from_user((void *)(& ds), (void const   *)arg, sizeof(ds));
  }
  if (tmp) {
    return (-14);
  }
  {
  ps->discsignr = ds.signr;
  ps->disccontext = ds.context;
  }
  return (0);
}
}
static int proc_claiminterface(struct dev_state *ps , void *arg ) 
{ unsigned int ifnum ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int tmp ;

  {
  {
  might_fault();
  }
  if ((int )sizeof(*((unsigned int *)arg)) == 1) {
    goto switch_352_1;
  } else {
    if ((int )sizeof(*((unsigned int *)arg)) == 2) {
      goto switch_352_2;
    } else {
      if ((int )sizeof(*((unsigned int *)arg)) == 4) {
        goto switch_352_4;
      } else {
        if ((int )sizeof(*((unsigned int *)arg)) == 8) {
          goto switch_352_8;
        } else {
          {
          goto switch_352_default;
          if (0) {
            switch_352_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "1": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_352_break;
            switch_352_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "2": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_352_break;
            switch_352_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "4": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_352_break;
            switch_352_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_352_break;
            switch_352_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_352_break;
          } else {
            switch_352_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ifnum = (unsigned int )__val_gu;
  }
  if (__ret_gu) {
    return (-14);
  }
  {
  tmp = claimintf(ps, ifnum);
  }
  return (tmp);
}
}
static int proc_releaseinterface(struct dev_state *ps , void *arg ) 
{ unsigned int ifnum ;
  int ret ;
  int __ret_gu ;
  unsigned long __val_gu ;

  {
  {
  might_fault();
  }
  if ((int )sizeof(*((unsigned int *)arg)) == 1) {
    goto switch_353_1;
  } else {
    if ((int )sizeof(*((unsigned int *)arg)) == 2) {
      goto switch_353_2;
    } else {
      if ((int )sizeof(*((unsigned int *)arg)) == 4) {
        goto switch_353_4;
      } else {
        if ((int )sizeof(*((unsigned int *)arg)) == 8) {
          goto switch_353_8;
        } else {
          {
          goto switch_353_default;
          if (0) {
            switch_353_1: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "1": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_353_break;
            switch_353_2: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "2": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_353_break;
            switch_353_4: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "4": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_353_break;
            switch_353_8: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_353_break;
            switch_353_default: /* CIL Label */ 
            {
            __asm__  volatile   ("call __get_user_"
                                 "X": "=a" (__ret_gu), "=d" (__val_gu): "0" ((unsigned int *)arg));
            }
            goto switch_353_break;
          } else {
            switch_353_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ifnum = (unsigned int )__val_gu;
  }
  if (__ret_gu) {
    return (-14);
  }
  {
  ret = releaseintf(ps, ifnum);
  }
  if (ret < 0) {
    return (ret);
  }
  {
  destroy_async_on_interface(ps, ifnum);
  }
  return (0);
}
}
static int proc_ioctl(struct dev_state *ps , struct usbdevfs_ioctl *ctl ) 
{ int size ;
  void *buf ;
  int retval ;
  struct usb_interface *intf ;
  struct usb_driver *driver ;
  unsigned long tmp ;
  int tmp___0 ;
  struct device_driver  const  *__mptr ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  struct device_driver  const  *__mptr___0 ;
  unsigned long tmp___3 ;

  {
  {
  buf = (void *)0;
  retval = 0;
  intf = (struct usb_interface *)((void *)0);
  driver = (struct usb_driver *)((void *)0);
  size = (ctl->ioctl_code >> 16) & ((1 << 14) - 1);
  }
  if (size > 0) {
    {
    buf = kmalloc((unsigned int )size, 208U);
    }
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      return (-12);
    }
    if ((unsigned int )((ctl->ioctl_code >> 30) & ((1 << 2) - 1)) & 1U) {
      {
      tmp = copy_from_user(buf, (void const   *)ctl->data, (unsigned long )size);
      }
      if (tmp) {
        {
        kfree((void const   *)buf);
        }
        return (-14);
      }
    } else {
      {
      __constant_c_memset(buf, 0UL, (unsigned int )size);
      }
    }
  }
  {
  tmp___0 = connected(ps);
  }
  if (! tmp___0) {
    {
    kfree((void const   *)buf);
    }
    return (-19);
  }
  if ((unsigned int )(ps->dev)->state != 7U) {
    {
    retval = -113;
    }
  } else {
    {
    intf = usb_ifnum_to_if((struct usb_device  const  *)ps->dev, (unsigned int )ctl->ifno);
    }
    if (intf) {
      if (ctl->ioctl_code == ((unsigned int )(85 << 8) | 22U)) {
        goto switch_354_exp_2;
      } else {
        if (ctl->ioctl_code == ((unsigned int )(85 << 8) | 23U)) {
          goto switch_354_exp_3;
        } else {
          {
          goto switch_354_default;
          if (0) {
            switch_354_exp_2: /* CIL Label */ 
            if (intf->dev.driver) {
              {
              __mptr = (struct device_driver  const  *)intf->dev.driver;
              driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
              usb_driver_release_interface(driver, intf);
              }
            } else {
              {
              retval = -61;
              }
            }
            goto switch_354_break;
            switch_354_exp_3: /* CIL Label */ 
            if (! intf->dev.driver) {
              {
              retval = device_attach(& intf->dev);
              }
            } else {
              {
              retval = -16;
              }
            }
            goto switch_354_break;
            switch_354_default: /* CIL Label */ 
            {

            }
            if (intf->dev.driver) {
              {
              __mptr___0 = (struct device_driver  const  *)intf->dev.driver;
              driver = (struct usb_driver *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
              }
            }
            if ((unsigned long )driver == (unsigned long )((void *)0)) {
              {
              retval = -25;
              }
            } else {
              if ((unsigned long )driver->ioctl == (unsigned long )((void *)0)) {
                {
                retval = -25;
                }
              } else {
                {
                retval = (*(driver->ioctl))(intf, (unsigned int )ctl->ioctl_code,
                                            buf);
                }
                if (retval == -515) {
                  {
                  retval = -25;
                  }
                }
              }
            }
          } else {
            switch_354_break: /* CIL Label */ ;
          }
          }
        }
      }
    } else {
      {
      retval = -22;
      }
    }
  }
  if (retval >= 0) {
    if (((unsigned int )((ctl->ioctl_code >> 30) & ((1 << 2) - 1)) & 2U) != 0U) {
      if (size > 0) {
        {
        tmp___3 = copy_to_user(ctl->data, (void const   *)buf, (unsigned long )size);
        }
        if (tmp___3 != 0UL) {
          {
          retval = -14;
          }
        }
      }
    }
  }
  {
  kfree((void const   *)buf);
  }
  return (retval);
}
}
static int proc_ioctl_default(struct dev_state *ps , void *arg ) 
{ struct usbdevfs_ioctl ctrl ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp = copy_from_user((void *)(& ctrl), (void const   *)arg, sizeof(ctrl));
  }
  if (tmp) {
    return (-14);
  }
  {
  tmp___0 = proc_ioctl(ps, & ctrl);
  }
  return (tmp___0);
}
}
static int usbdev_ioctl(struct inode *inode , struct file *file , unsigned int cmd ,
                        unsigned long arg ) 
{ struct dev_state *ps ;
  struct usb_device *dev ;
  void *p ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;

  {
  {
  ps = (struct dev_state *)file->private_data;
  dev = ps->dev;
  p = (void *)arg;
  ret = -25;
  }
  if (! (file->f_mode & 2U)) {
    return (-1);
  }
  {
  down(& dev->dev.sem);
  tmp = connected(ps);
  }
  if (! tmp) {
    {
    up(& dev->dev.sem);
    }
    return (-19);
  }
  if ((int )cmd == ((unsigned long )((3U << 30) | (unsigned int )(85 << 8)) | (sizeof(struct usbdevfs_ctrltransfer ) << 16))) {
    goto switch_355_exp_4;
  } else {
    if ((int )cmd == ((unsigned long )(((3U << 30) | (unsigned int )(85 << 8)) | 2U) | (sizeof(struct usbdevfs_bulktransfer ) << 16))) {
      goto switch_355_exp_5;
    } else {
      if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 3U) | (sizeof(unsigned int ) << 16))) {
        goto switch_355_exp_6;
      } else {
        if ((int )cmd == ((unsigned int )(85 << 8) | 20U)) {
          goto switch_355_exp_7;
        } else {
          if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 21U) | (sizeof(unsigned int ) << 16))) {
            goto switch_355_exp_8;
          } else {
            if ((int )cmd == ((unsigned long )(((1U << 30) | (unsigned int )(85 << 8)) | 8U) | (sizeof(struct usbdevfs_getdriver ) << 16))) {
              goto switch_355_exp_9;
            } else {
              if ((int )cmd == ((unsigned long )(((1U << 30) | (unsigned int )(85 << 8)) | 17U) | (sizeof(struct usbdevfs_connectinfo ) << 16))) {
                goto switch_355_exp_10;
              } else {
                if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 4U) | (sizeof(struct usbdevfs_setinterface ) << 16))) {
                  goto switch_355_exp_11;
                } else {
                  if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 5U) | (sizeof(unsigned int ) << 16))) {
                    goto switch_355_exp_12;
                  } else {
                    if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 10U) | (sizeof(struct usbdevfs_urb ) << 16))) {
                      goto switch_355_exp_13;
                    } else {
                      if ((int )cmd == ((unsigned int )(85 << 8) | 11U)) {
                        goto switch_355_exp_14;
                      } else {
                        if ((int )cmd == ((unsigned long )(((1U << 30) | (unsigned int )(85 << 8)) | 12U) | (sizeof(void *) << 16))) {
                          goto switch_355_exp_15;
                        } else {
                          if ((int )cmd == ((unsigned long )(((1U << 30) | (unsigned int )(85 << 8)) | 13U) | (sizeof(void *) << 16))) {
                            goto switch_355_exp_16;
                          } else {
                            if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 14U) | (sizeof(struct usbdevfs_disconnectsignal ) << 16))) {
                              goto switch_355_exp_17;
                            } else {
                              if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 15U) | (sizeof(unsigned int ) << 16))) {
                                goto switch_355_exp_18;
                              } else {
                                if ((int )cmd == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 16U) | (sizeof(unsigned int ) << 16))) {
                                  goto switch_355_exp_19;
                                } else {
                                  if ((int )cmd == ((unsigned long )(((3U << 30) | (unsigned int )(85 << 8)) | 18U) | (sizeof(struct usbdevfs_ioctl ) << 16))) {
                                    goto switch_355_exp_20;
                                  } else {
                                    if (0) {
                                      switch_355_exp_4: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_356_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___0 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___1 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: CONTROL\n", tmp___1,
                                                 tmp___0, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_356_break;
                                      }
                                      while_356_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_control(ps, p);
                                      }
                                      if (ret >= 0) {
                                        {
                                        inode->i_mtime = current_kernel_time();
                                        }
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_5: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_357_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___2 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___3 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: BULK\n", tmp___3,
                                                 tmp___2, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_357_break;
                                      }
                                      while_357_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_bulk(ps, p);
                                      }
                                      if (ret >= 0) {
                                        {
                                        inode->i_mtime = current_kernel_time();
                                        }
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_6: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_358_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___4 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___5 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: RESETEP\n", tmp___5,
                                                 tmp___4, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_358_break;
                                      }
                                      while_358_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_resetep(ps, p);
                                      }
                                      if (ret >= 0) {
                                        {
                                        inode->i_mtime = current_kernel_time();
                                        }
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_7: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_359_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___6 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___7 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: RESET\n", tmp___7,
                                                 tmp___6, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_359_break;
                                      }
                                      while_359_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_resetdevice(ps);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_8: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_360_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___8 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___9 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: CLEAR_HALT\n", tmp___9,
                                                 tmp___8, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_360_break;
                                      }
                                      while_360_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_clearhalt(ps, p);
                                      }
                                      if (ret >= 0) {
                                        {
                                        inode->i_mtime = current_kernel_time();
                                        }
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_9: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_361_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___10 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___11 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: GETDRIVER\n", tmp___11,
                                                 tmp___10, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_361_break;
                                      }
                                      while_361_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_getdriver(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_10: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_362_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___12 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___13 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: CONNECTINFO\n", tmp___13,
                                                 tmp___12, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_362_break;
                                      }
                                      while_362_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_connectinfo(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_11: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_363_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___14 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___15 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: SETINTERFACE\n", tmp___15,
                                                 tmp___14, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_363_break;
                                      }
                                      while_363_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_setintf(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_12: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_364_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___16 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___17 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: SETCONFIGURATION\n",
                                                 tmp___17, tmp___16, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_364_break;
                                      }
                                      while_364_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_setconfig(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_13: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_365_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___18 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___19 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: SUBMITURB\n", tmp___19,
                                                 tmp___18, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_365_break;
                                      }
                                      while_365_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_submiturb(ps, p);
                                      }
                                      if (ret >= 0) {
                                        {
                                        inode->i_mtime = current_kernel_time();
                                        }
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_14: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_366_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___20 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___21 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: DISCARDURB\n", tmp___21,
                                                 tmp___20, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_366_break;
                                      }
                                      while_366_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_unlinkurb(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_15: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_367_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___22 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___23 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: REAPURB\n", tmp___23,
                                                 tmp___22, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_367_break;
                                      }
                                      while_367_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_reapurb(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_16: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_368_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___24 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___25 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: REAPURBDELAY\n", tmp___25,
                                                 tmp___24, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_368_break;
                                      }
                                      while_368_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_reapurbnonblock(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_17: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_369_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___26 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___27 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: DISCSIGNAL\n", tmp___27,
                                                 tmp___26, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_369_break;
                                      }
                                      while_369_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_disconnectsignal(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_18: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_370_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___28 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___29 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: CLAIMINTERFACE\n",
                                                 tmp___29, tmp___28, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_370_break;
                                      }
                                      while_370_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_claiminterface(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_19: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_371_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___30 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___31 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: RELEASEINTERFACE\n",
                                                 tmp___31, tmp___30, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_371_break;
                                      }
                                      while_371_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_releaseinterface(ps, p);
                                      }
                                      goto switch_355_break;
                                      switch_355_exp_20: /* CIL Label */ 
                                      {
                                      while (1) {
                                        while_372_continue: /* CIL Label */ ;
                                        if (usbfs_snoop) {
                                          {
                                          tmp___32 = dev_name((struct device  const  *)(& dev->dev));
                                          tmp___33 = dev_driver_string((struct device  const  *)(& dev->dev));
                                          printk("<6>%s %s: %s: IOCTL\n", tmp___33,
                                                 tmp___32, "usbdev_ioctl");
                                          }
                                        }
                                        goto while_372_break;
                                      }
                                      while_372_break: /* CIL Label */ ;
                                      }
                                      {
                                      ret = proc_ioctl_default(ps, p);
                                      }
                                      goto switch_355_break;
                                    } else {
                                      switch_355_break: /* CIL Label */ ;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
  up(& dev->dev.sem);
  }
  if (ret >= 0) {
    {
    inode->i_atime = current_kernel_time();
    }
  }
  return (ret);
}
}
static unsigned int usbdev_poll(struct file *file , struct poll_table_struct *wait ) 
{ struct dev_state *ps ;
  unsigned int mask ;
  int tmp ;
  int tmp___0 ;

  {
  {
  ps = (struct dev_state *)file->private_data;
  mask = 0U;
  poll_wait(file, & ps->wait, wait);
  }
  if (file->f_mode & 2U) {
    {
    tmp = list_empty((struct list_head  const  *)(& ps->async_completed));
    }
    if (! tmp) {
      {
      mask |= 260U;
      }
    }
  }
  {
  tmp___0 = connected(ps);
  }
  if (! tmp___0) {
    {
    mask |= 24U;
    }
  }
  return (mask);
}
}
struct file_operations  const  usbdev_file_operations  = 
     {(struct module *)0, & usbdev_lseek, & usbdev_read, (ssize_t (*)(struct file * ,
                                                                    char const   * ,
                                                                    size_t  , loff_t * ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, & usbdev_poll,
    & usbdev_ioctl, (long (*)(struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (int (*)(struct file * ,
                                                                           struct vm_area_struct * ))0,
    & usbdev_open, (int (*)(struct file * , fl_owner_t id ))0, & usbdev_release, (int (*)(struct file * ,
                                                                                          struct dentry * ,
                                                                                          int datasync ))0,
    (int (*)(struct kiocb * , int datasync ))0, (int (*)(int  , struct file * , int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct page * ,
                                                                         int  , size_t  ,
                                                                         loff_t * ,
                                                                         int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0};
static void usbdev_remove(struct usb_device *udev ) 
{ struct dev_state *ps ;
  struct siginfo sinfo ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  {
  while (1) {
    while_373_continue: /* CIL Label */ ;
    {
    tmp = list_empty((struct list_head  const  *)(& udev->filelist));
    }
    if (tmp) {
      goto while_373_break;
    }
    {
    __mptr = (struct list_head  const  *)udev->filelist.next;
    ps = (struct dev_state *)((char *)__mptr - (unsigned int )(& ((struct dev_state *)0)->list));
    destroy_all_async(ps);
    __wake_up(& ps->wait, 3U, 0, (void *)0);
    list_del_init(& ps->list);
    }
    if (ps->discsignr) {
      {
      sinfo.si_signo = (int )ps->discsignr;
      sinfo.si_errno = 32;
      sinfo.si_code = -4;
      sinfo._sifields._sigfault._addr = ps->disccontext;
      kill_pid_info_as_uid((int )ps->discsignr, & sinfo, ps->disc_pid, ps->disc_uid,
                           ps->disc_euid, ps->secid);
      }
    }
  }
  while_373_break: /* CIL Label */ ;
  }
  return;
}
}
static int usbdev_notify(struct notifier_block *self , unsigned long action , void *dev ) 
{ 

  {
  if ((int )action == 1) {
    goto switch_374_1;
  } else {
    if ((int )action == 2) {
      goto switch_374_2;
    } else {
      if (0) {
        switch_374_1: /* CIL Label */ 
        {

        }
        goto switch_374_break;
        switch_374_2: /* CIL Label */ 
        {
        while (1) {
          while_375_continue: /* CIL Label */ ;
          goto while_375_break;
        }
        while_375_break: /* CIL Label */ ;
        }
        {
        usbdev_remove((struct usb_device *)dev);
        }
        goto switch_374_break;
      } else {
        switch_374_break: /* CIL Label */ ;
      }
    }
  }
  return (1);
}
}
static struct notifier_block usbdev_nb  =    {& usbdev_notify, (struct notifier_block *)0, 0};
static struct cdev usb_device_cdev  ;
int usb_devio_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
int usb_devio_init(void) 
{ int retval ;

  {
  {
  retval = register_chrdev_region((unsigned int )(189 << 20), 8192U, "usb_device");
  }
  if (retval) {
    {
    printk("<3>Unable to register minors for usb_device\n");
    }
    goto out;
  }
  {
  cdev_init(& usb_device_cdev, & usbdev_file_operations);
  retval = cdev_add(& usb_device_cdev, (unsigned int )(189 << 20), 8192U);
  }
  if (retval) {
    {
    printk("<3>Unable to get usb_device major %d\n", 189);
    }
    goto error_cdev;
  }
  {
  usb_register_notify(& usbdev_nb);
  }
  out: 
  return (retval);
  error_cdev: 
  {
  unregister_chrdev_region((unsigned int )(189 << 20), 8192U);
  }
  goto out;
}
}
void usb_devio_cleanup(void) 
{ 

  {
  {
  usb_unregister_notify(& usbdev_nb);
  cdev_del(& usb_device_cdev);
  unregister_chrdev_region((unsigned int )(189 << 20), 8192U);
  }
  return;
}
}
static unsigned long __force_order___3  ;
__inline static unsigned long native_read_cr0___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static void native_write_cr0___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static void native_write_cr2___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static void native_write_cr3___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___3): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static void load_cr3___3(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___3((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___3(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___3();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___3((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___3(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___3();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___3((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___3(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___0 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___3(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___3(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___3(u64 ns ) ;
static union ktime  const  ktime_zero___3  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___3(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___3.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___3  ;
__inline static void hrtimer_set_expires_range_ns___3(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___3((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
ssize_t usb_store_new_id(struct usb_dynids *dynids , struct device_driver *driver ,
                         char const   *buf , size_t count ) 
{ struct usb_dynid *dynid ;
  u32 idVendor ;
  u32 idProduct ;
  int fields ;
  int retval ;
  void *tmp ;
  struct device_driver *tmp___0 ;

  {
  {
  idVendor = (u32 )0;
  idProduct = (u32 )0;
  fields = 0;
  retval = 0;
  fields = sscanf(buf, "%x %x", & idVendor, & idProduct);
  }
  if (fields < 2) {
    return (-22);
  }
  {
  tmp = kzalloc((unsigned int )sizeof(*dynid), 208U);
  dynid = (struct usb_dynid *)tmp;
  }
  if (! dynid) {
    return (-12);
  }
  {
  INIT_LIST_HEAD(& dynid->node);
  dynid->id.idVendor = (unsigned short )idVendor;
  dynid->id.idProduct = (unsigned short )idProduct;
  dynid->id.match_flags = (unsigned short)3;
  _spin_lock(& dynids->lock);
  list_add_tail(& dynid->node, & dynids->list);
  }
  {
  while (1) {
    while_376_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dynids->lock.raw_lock);
    }
    goto while_376_break;
  }
  while_376_break: /* CIL Label */ ;
  }
  {
  tmp___0 = get_driver(driver);
  }
  if (tmp___0) {
    {
    retval = driver_attach(driver);
    put_driver(driver);
    }
  }
  if (retval) {
    return (retval);
  }
  return ((int )count);
}
}
static char const   __kstrtab_usb_store_new_id[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'n',      (char const   )'e', 
        (char const   )'w',      (char const   )'_',      (char const   )'i',      (char const   )'d', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_store_new_id  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_store_new_id), __kstrtab_usb_store_new_id};
static ssize_t store_new_id(struct device_driver *driver , char const   *buf , size_t count ) 
{ struct usb_driver *usb_drv ;
  struct device_driver  const  *__mptr ;
  ssize_t tmp ;

  {
  {
  __mptr = (struct device_driver  const  *)driver;
  usb_drv = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
  tmp = usb_store_new_id(& usb_drv->dynids, driver, buf, count);
  }
  return (tmp);
}
}
static struct driver_attribute driver_attr_new_id  =    {{"new_id", (struct module *)0, (mode_t )128}, (ssize_t (*)(struct device_driver *driver ,
                                                               char *buf ))((void *)0),
    & store_new_id};
static int usb_create_newid_file(struct usb_driver *usb_drv ) 
{ int error ;

  {
  {
  error = 0;
  }
  if (usb_drv->no_dynamic_id) {
    goto exit;
  }
  if ((unsigned long )usb_drv->probe != (unsigned long )((void *)0)) {
    {
    error = driver_create_file(& usb_drv->drvwrap.driver, & driver_attr_new_id);
    }
  }
  exit: 
  return (error);
}
}
static void usb_remove_newid_file(struct usb_driver *usb_drv ) 
{ 

  {
  if (usb_drv->no_dynamic_id) {
    return;
  }
  if ((unsigned long )usb_drv->probe != (unsigned long )((void *)0)) {
    {
    driver_remove_file(& usb_drv->drvwrap.driver, & driver_attr_new_id);
    }
  }
  return;
}
}
static void usb_free_dynids(struct usb_driver *usb_drv ) 
{ struct usb_dynid *dynid ;
  struct usb_dynid *n ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  _spin_lock(& usb_drv->dynids.lock);
  __mptr = (struct list_head  const  *)usb_drv->dynids.list.next;
  dynid = (struct usb_dynid *)((char *)__mptr - (unsigned int )(& ((struct usb_dynid *)0)->node));
  __mptr___0 = (struct list_head  const  *)dynid->node.next;
  n = (struct usb_dynid *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_dynid *)0)->node));
  }
  {
  while (1) {
    while_377_continue: /* CIL Label */ ;
    if (! ((unsigned long )(& dynid->node) != (unsigned long )(& usb_drv->dynids.list))) {
      goto while_377_break;
    }
    {
    list_del(& dynid->node);
    kfree((void const   *)dynid);
    dynid = n;
    __mptr___1 = (struct list_head  const  *)n->node.next;
    n = (struct usb_dynid *)((char *)__mptr___1 - (unsigned int )(& ((struct usb_dynid *)0)->node));
    }
  }
  while_377_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_378_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& usb_drv->dynids.lock.raw_lock);
    }
    goto while_378_break;
  }
  while_378_break: /* CIL Label */ ;
  }
  return;
}
}
static struct usb_device_id  const  *usb_match_dynamic_id(struct usb_interface *intf ,
                                                          struct usb_driver *drv ) 
{ struct usb_dynid *dynid ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;

  {
  {
  _spin_lock(& drv->dynids.lock);
  __mptr = (struct list_head  const  *)drv->dynids.list.next;
  dynid = (struct usb_dynid *)((char *)__mptr - (unsigned int )(& ((struct usb_dynid *)0)->node));
  }
  {
  while (1) {
    while_379_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)dynid->node.next);
    }
    if (! ((unsigned long )(& dynid->node) != (unsigned long )(& drv->dynids.list))) {
      goto while_379_break;
    }
    {
    tmp = usb_match_one_id(intf, (struct usb_device_id  const  *)(& dynid->id));
    }
    if (tmp) {
      {
      while (1) {
        while_380_continue: /* CIL Label */ ;
        {
        __raw_spin_unlock(& drv->dynids.lock.raw_lock);
        }
        goto while_380_break;
      }
      while_380_break: /* CIL Label */ ;
      }
      return ((struct usb_device_id  const  *)(& dynid->id));
    }
    {
    __mptr___0 = (struct list_head  const  *)dynid->node.next;
    dynid = (struct usb_dynid *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_dynid *)0)->node));
    }
  }
  while_379_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_381_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& drv->dynids.lock.raw_lock);
    }
    goto while_381_break;
  }
  while_381_break: /* CIL Label */ ;
  }
  return ((struct usb_device_id  const  *)((void *)0));
}
}
static int usb_probe_device(struct device *dev ) 
{ struct usb_device_driver *udriver ;
  struct device_driver  const  *__mptr ;
  struct usb_device *udev ;
  int error ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  struct device  const  *__mptr___0 ;

  {
  {
  __mptr = (struct device_driver  const  *)dev->driver;
  udriver = (struct usb_device_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_device_driver *)0)->drvwrap.driver));
  error = -19;
  tmp___1 = is_usb_device((struct device  const  *)dev);
  }
  if (! tmp___1) {
    return (error);
  }
  {
  __mptr___0 = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_device *)0)->dev));
  udev->pm_usage_cnt = ! udriver->supports_autosuspend;
  error = (*(udriver->probe))(udev);
  }
  return (error);
}
}
static int usb_unbind_device(struct device *dev ) 
{ struct usb_device_driver *udriver ;
  struct device_driver  const  *__mptr ;
  struct device  const  *__mptr___0 ;

  {
  {
  __mptr = (struct device_driver  const  *)dev->driver;
  udriver = (struct usb_device_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_device_driver *)0)->drvwrap.driver));
  __mptr___0 = (struct device  const  *)dev;
  (*(udriver->disconnect))((struct usb_device *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_device *)0)->dev)));
  }
  return (0);
}
}
static void usb_cancel_queued_reset(struct usb_interface *iface ) 
{ 

  {
  if (iface->reset_running == 0U) {
    {
    cancel_work_sync(& iface->reset_ws);
    }
  }
  return;
}
}
static int usb_probe_interface(struct device *dev ) 
{ struct usb_driver *driver ;
  struct device_driver  const  *__mptr ;
  struct usb_interface *intf ;
  struct usb_device *udev ;
  struct usb_device_id  const  *id ;
  int error ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  struct device  const  *__mptr___0 ;
  struct device  const  *__mptr___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
  __mptr = (struct device_driver  const  *)dev->driver;
  driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
  error = -19;
  tmp___1 = is_usb_device((struct device  const  *)dev);
  }
  if (tmp___1) {
    return (error);
  }
  {
  __mptr___0 = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_interface *)0)->dev));
  __mptr___1 = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr___1 - (unsigned int )(& ((struct usb_device *)0)->dev));
  intf->needs_binding = 0U;
  }
  if (udev->authorized == 0U) {
    {
    tmp___2 = dev_name((struct device  const  *)(& intf->dev));
    tmp___3 = dev_driver_string((struct device  const  *)(& intf->dev));
    printk("<3>%s %s: Device is not authorized for usage\n", tmp___3, tmp___2);
    }
    return (-19);
  }
  {
  id = usb_match_id(intf, driver->id_table);
  }
  if (! id) {
    {
    id = usb_match_dynamic_id(intf, driver);
    }
  }
  if (id) {
    {
    error = usb_autoresume_device(udev);
    }
    if (error) {
      return (error);
    }
    {
    mark_active(intf);
    intf->condition = (enum usb_interface_condition )1;
    intf->pm_usage_cnt = ! driver->supports_autosuspend;
    }
    if (intf->needs_altsetting0) {
      {
      usb_set_interface(udev, (int )(intf->altsetting + 0)->desc.bInterfaceNumber,
                        0);
      intf->needs_altsetting0 = 0U;
      }
    }
    {
    error = (*(driver->probe))(intf, id);
    }
    if (error) {
      {
      mark_quiesced(intf);
      intf->needs_remote_wakeup = 0U;
      intf->condition = (enum usb_interface_condition )0;
      usb_cancel_queued_reset(intf);
      }
    } else {
      {
      intf->condition = (enum usb_interface_condition )2;
      }
    }
    {
    usb_autosuspend_device(udev);
    }
  }
  return (error);
}
}
static int usb_unbind_interface(struct device *dev ) 
{ struct usb_driver *driver ;
  struct device_driver  const  *__mptr ;
  struct usb_interface *intf ;
  struct device  const  *__mptr___0 ;
  struct usb_device *udev ;
  int error ;
  struct device  const  *__mptr___1 ;

  {
  {
  __mptr = (struct device_driver  const  *)dev->driver;
  driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
  __mptr___0 = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_interface *)0)->dev));
  intf->condition = (enum usb_interface_condition )3;
  __mptr___1 = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr___1 - (unsigned int )(& ((struct usb_device *)0)->dev));
  error = usb_autoresume_device(udev);
  }
  if (! driver->soft_unbind) {
    {
    usb_disable_interface(udev, intf, (_Bool)0);
    }
  }
  {
  (*(driver->disconnect))(intf);
  usb_cancel_queued_reset(intf);
  }
  if ((int )(intf->cur_altsetting)->desc.bAlternateSetting == 0) {
    {
    usb_enable_interface(udev, intf, (_Bool)0);
    }
  } else {
    if (! error) {
      if ((unsigned int )intf->dev.power.status == 1U) {
        {
        usb_set_interface(udev, (int )(intf->altsetting + 0)->desc.bInterfaceNumber,
                          0);
        }
      } else {
        {
        intf->needs_altsetting0 = 1U;
        }
      }
    } else {
      {
      intf->needs_altsetting0 = 1U;
      }
    }
  }
  {
  usb_set_intfdata(intf, (void *)0);
  intf->condition = (enum usb_interface_condition )0;
  mark_quiesced(intf);
  intf->needs_remote_wakeup = 0U;
  }
  if (! error) {
    {
    usb_autosuspend_device(udev);
    }
  }
  return (0);
}
}
int usb_driver_claim_interface(struct usb_driver *driver , struct usb_interface *iface ,
                               void *priv ) 
{ struct device *dev ;
  struct usb_device *udev ;
  struct device  const  *__mptr ;
  int retval ;
  int tmp ;

  {
  {
  dev = & iface->dev;
  __mptr = (struct device  const  *)iface->dev.parent;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  retval = 0;
  }
  if (dev->driver) {
    return (-16);
  }
  {
  dev->driver = & driver->drvwrap.driver;
  usb_set_intfdata(iface, priv);
  iface->needs_binding = 0U;
  usb_pm_lock(udev);
  iface->condition = (enum usb_interface_condition )2;
  mark_active(iface);
  iface->pm_usage_cnt = ! driver->supports_autosuspend;
  usb_pm_unlock(udev);
  tmp = device_is_registered(dev);
  }
  if (tmp) {
    {
    retval = device_bind_driver(dev);
    }
  }
  return (retval);
}
}
static char const   __kstrtab_usb_driver_claim_interface[27]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'d',      (char const   )'r',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'c', 
        (char const   )'l',      (char const   )'a',      (char const   )'i',      (char const   )'m', 
        (char const   )'_',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'f',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_driver_claim_interface  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_driver_claim_interface), __kstrtab_usb_driver_claim_interface};
void usb_driver_release_interface(struct usb_driver *driver ,
                                  struct usb_interface *iface ) 
{ struct device *dev ;
  struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  dev = & iface->dev;
  __mptr = (struct device  const  *)iface->dev.parent;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if (! dev->driver) {
    return;
  } else {
    if ((unsigned long )dev->driver != (unsigned long )(& driver->drvwrap.driver)) {
      return;
    }
  }
  if ((unsigned int )iface->condition != 2U) {
    return;
  }
  {
  tmp = device_is_registered(dev);
  }
  if (tmp) {
    {
    iface->condition = (enum usb_interface_condition )3;
    device_release_driver(dev);
    }
  } else {
    {
    iface->condition = (enum usb_interface_condition )0;
    usb_cancel_queued_reset(iface);
    }
  }
  {
  dev->driver = (struct device_driver *)((void *)0);
  usb_set_intfdata(iface, (void *)0);
  usb_pm_lock(udev);
  iface->condition = (enum usb_interface_condition )0;
  mark_quiesced(iface);
  iface->needs_remote_wakeup = 0U;
  usb_pm_unlock(udev);
  }
  return;
}
}
static char const   __kstrtab_usb_driver_release_interface[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'d',      (char const   )'r',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'s',      (char const   )'e',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'f',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_driver_release_interface  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_driver_release_interface), __kstrtab_usb_driver_release_interface};
int usb_match_device(struct usb_device *dev ,
                     struct usb_device_id  const  *id ) 
{ 

  {
  if ((int const   )id->match_flags & 1) {
    if ((int const   )id->idVendor != (int const   )dev->descriptor.idVendor) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 2) {
    if ((int const   )id->idProduct != (int const   )dev->descriptor.idProduct) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 4) {
    if ((int const   )id->bcdDevice_lo > (int const   )dev->descriptor.bcdDevice) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 8) {
    if ((int const   )id->bcdDevice_hi < (int const   )dev->descriptor.bcdDevice) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 16) {
    if ((int const   )id->bDeviceClass != (int const   )dev->descriptor.bDeviceClass) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 32) {
    if ((int const   )id->bDeviceSubClass != (int const   )dev->descriptor.bDeviceSubClass) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 64) {
    if ((int const   )id->bDeviceProtocol != (int const   )dev->descriptor.bDeviceProtocol) {
      return (0);
    }
  }
  return (1);
}
}
int usb_match_one_id(struct usb_interface *interface , struct usb_device_id  const  *id ) 
{ struct usb_host_interface *intf ;
  struct usb_device *dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    return (0);
  }
  {
  intf = interface->cur_altsetting;
  __mptr = (struct device  const  *)interface->dev.parent;
  dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = usb_match_device(dev, id);
  }
  if (! tmp) {
    return (0);
  }
  if ((int )dev->descriptor.bDeviceClass == 255) {
    if (! ((int const   )id->match_flags & 1)) {
      if ((int const   )id->match_flags & 896) {
        return (0);
      }
    }
  }
  if ((int const   )id->match_flags & 128) {
    if ((int const   )id->bInterfaceClass != (int const   )intf->desc.bInterfaceClass) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 256) {
    if ((int const   )id->bInterfaceSubClass != (int const   )intf->desc.bInterfaceSubClass) {
      return (0);
    }
  }
  if ((int const   )id->match_flags & 512) {
    if ((int const   )id->bInterfaceProtocol != (int const   )intf->desc.bInterfaceProtocol) {
      return (0);
    }
  }
  return (1);
}
}
static char const   __kstrtab_usb_match_one_id[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )'_',      (char const   )'o',      (char const   )'n', 
        (char const   )'e',      (char const   )'_',      (char const   )'i',      (char const   )'d', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_match_one_id  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_match_one_id), __kstrtab_usb_match_one_id};
struct usb_device_id  const  *usb_match_id(struct usb_interface *interface , struct usb_device_id  const  *id ) 
{ int tmp ;

  {
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    return ((struct usb_device_id  const  *)((void *)0));
  }
  {
  while (1) {
    while_382_continue: /* CIL Label */ ;
    if (! id->idVendor) {
      if (! id->idProduct) {
        if (! id->bDeviceClass) {
          if (! id->bInterfaceClass) {
            if (! id->driver_info) {
              goto while_382_break;
            }
          }
        }
      }
    }
    {
    tmp = usb_match_one_id(interface, id);
    }
    if (tmp) {
      return (id);
    }
    {
    id ++;
    }
  }
  while_382_break: /* CIL Label */ ;
  }
  return ((struct usb_device_id  const  *)((void *)0));
}
}
static char const   __kstrtab_usb_match_id[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )'_',      (char const   )'i',      (char const   )'d', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_match_id  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_match_id), __kstrtab_usb_match_id};
static int usb_device_match(struct device *dev , struct device_driver *drv ) 
{ int tmp ;
  struct usb_interface *intf ;
  struct usb_driver *usb_drv ;
  struct usb_device_id  const  *id ;
  int tmp___0 ;
  struct device  const  *__mptr ;
  struct device_driver  const  *__mptr___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = is_usb_device((struct device  const  *)dev);
  }
  if (tmp___1) {
    {
    tmp = is_usb_device_driver(drv);
    }
    if (! tmp) {
      return (0);
    }
    return (1);
  } else {
    {
    tmp___0 = is_usb_device_driver(drv);
    }
    if (tmp___0) {
      return (0);
    }
    {
    __mptr = (struct device  const  *)dev;
    intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
    __mptr___0 = (struct device_driver  const  *)drv;
    usb_drv = (struct usb_driver *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
    id = usb_match_id(intf, usb_drv->id_table);
    }
    if (id) {
      return (1);
    }
    {
    id = usb_match_dynamic_id(intf, usb_drv);
    }
    if (id) {
      return (1);
    }
  }
  return (0);
}
}
static int usb_uevent(struct device *dev , struct kobj_uevent_env *env ) 
{ struct usb_device *usb_dev ;
  char const   *tmp ;
  struct device  const  *__mptr ;
  struct usb_interface *intf ;
  struct device  const  *__mptr___0 ;
  struct device  const  *__mptr___1 ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  tmp___0 = is_usb_device((struct device  const  *)dev);
  }
  if (tmp___0) {
    {
    __mptr = (struct device  const  *)dev;
    usb_dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
    }
  } else {
    {
    __mptr___0 = (struct device  const  *)dev;
    intf = (struct usb_interface *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_interface *)0)->dev));
    __mptr___1 = (struct device  const  *)intf->dev.parent;
    usb_dev = (struct usb_device *)((char *)__mptr___1 - (unsigned int )(& ((struct usb_device *)0)->dev));
    }
  }
  if (usb_dev->devnum < 0) {
    return (-19);
  }
  if (! usb_dev->bus) {
    return (-19);
  }
  {
  tmp___3 = add_uevent_var(env, "DEVICE=/proc/bus/usb/%03d/%03d", (usb_dev->bus)->busnum,
                           usb_dev->devnum);
  }
  if (tmp___3) {
    return (-12);
  }
  {
  tmp___4 = add_uevent_var(env, "PRODUCT=%x/%x/%x", usb_dev->descriptor.idVendor,
                           usb_dev->descriptor.idProduct, usb_dev->descriptor.bcdDevice);
  }
  if (tmp___4) {
    return (-12);
  }
  {
  tmp___5 = add_uevent_var(env, "TYPE=%d/%d/%d", usb_dev->descriptor.bDeviceClass,
                           usb_dev->descriptor.bDeviceSubClass, usb_dev->descriptor.bDeviceProtocol);
  }
  if (tmp___5) {
    return (-12);
  }
  return (0);
}
}
int usb_register_device_driver(struct usb_device_driver *new_udriver , struct module *owner ) 
{ int retval ;
  int tmp ;

  {
  {
  retval = 0;
  tmp = usb_disabled();
  }
  if (tmp) {
    return (-19);
  }
  {
  new_udriver->drvwrap.for_devices = 1;
  new_udriver->drvwrap.driver.name = (char const   *)((char *)new_udriver->name);
  new_udriver->drvwrap.driver.bus = & usb_bus_type;
  new_udriver->drvwrap.driver.probe = & usb_probe_device;
  new_udriver->drvwrap.driver.remove = & usb_unbind_device;
  new_udriver->drvwrap.driver.owner = owner;
  retval = driver_register(& new_udriver->drvwrap.driver);
  }
  if (! retval) {
    {
    printk("<6>%s: registered new device driver %s\n", usbcore_name, new_udriver->name);
    usbfs_update_special();
    }
  } else {
    {
    printk("<3>%s: error %d registering device \tdriver %s\n", usbcore_name, retval,
           new_udriver->name);
    }
  }
  return (retval);
}
}
static char const   __kstrtab_usb_register_device_driver[27]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'d',      (char const   )'r',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_register_device_driver  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_register_device_driver), __kstrtab_usb_register_device_driver};
void usb_deregister_device_driver(struct usb_device_driver *udriver ) 
{ 

  {
  {
  printk("<6>%s: deregistering device driver %s\n", usbcore_name, udriver->name);
  driver_unregister(& udriver->drvwrap.driver);
  usbfs_update_special();
  }
  return;
}
}
static char const   __kstrtab_usb_deregister_device_driver[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'v',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'_',      (char const   )'d',      (char const   )'r', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_deregister_device_driver  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_deregister_device_driver), __kstrtab_usb_deregister_device_driver};
int usb_register_driver(struct usb_driver *new_driver ,
                        struct module *owner , char const   *mod_name ) 
{ int retval ;
  int tmp ;
  spinlock_t __constr_expr_0 ;

  {
  {
  retval = 0;
  tmp = usb_disabled();
  }
  if (tmp) {
    return (-19);
  }
  {
  new_driver->drvwrap.for_devices = 0;
  new_driver->drvwrap.driver.name = (char const   *)((char *)new_driver->name);
  new_driver->drvwrap.driver.bus = & usb_bus_type;
  new_driver->drvwrap.driver.probe = & usb_probe_interface;
  new_driver->drvwrap.driver.remove = & usb_unbind_interface;
  new_driver->drvwrap.driver.owner = owner;
  new_driver->drvwrap.driver.mod_name = mod_name;
  }
  {
  while (1) {
    while_383_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    new_driver->dynids.lock = __constr_expr_0;
    }
    goto while_383_break;
  }
  while_383_break: /* CIL Label */ ;
  }
  {
  INIT_LIST_HEAD(& new_driver->dynids.list);
  retval = driver_register(& new_driver->drvwrap.driver);
  }
  if (! retval) {
    {
    printk("<6>%s: registered new interface driver %s\n", usbcore_name, new_driver->name);
    usbfs_update_special();
    usb_create_newid_file(new_driver);
    }
  } else {
    {
    printk("<3>%s: error %d registering interface \tdriver %s\n", usbcore_name, retval,
           new_driver->name);
    }
  }
  return (retval);
}
}
static char const   __kstrtab_usb_register_driver[20]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'d',      (char const   )'r',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_register_driver  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_register_driver), __kstrtab_usb_register_driver};
void usb_deregister(struct usb_driver *driver ) 
{ 

  {
  {
  printk("<6>%s: deregistering interface driver %s\n", usbcore_name, driver->name);
  usb_remove_newid_file(driver);
  usb_free_dynids(driver);
  driver_unregister(& driver->drvwrap.driver);
  usbfs_update_special();
  }
  return;
}
}
static char const   __kstrtab_usb_deregister[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_deregister  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_deregister), __kstrtab_usb_deregister};
void usb_forced_unbind_intf(struct usb_interface *intf ) 
{ struct usb_driver *driver ;
  struct device_driver  const  *__mptr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  __mptr = (struct device_driver  const  *)intf->dev.driver;
  driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
  usb_driver_release_interface(driver, intf);
  intf->needs_binding = 1U;
  }
  return;
}
}
void usb_rebind_intf(struct usb_interface *intf ) 
{ int rc ;
  struct usb_driver *driver ;
  struct device_driver  const  *__mptr ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  if (intf->dev.driver) {
    {
    __mptr = (struct device_driver  const  *)intf->dev.driver;
    driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
    usb_driver_release_interface(driver, intf);
    }
  }
  if ((unsigned int )intf->dev.power.status == 1U) {
    {
    intf->needs_binding = 0U;
    rc = device_attach(& intf->dev);
    }
    if (rc < 0) {
      {
      tmp___1 = dev_name((struct device  const  *)(& intf->dev));
      tmp___2 = dev_driver_string((struct device  const  *)(& intf->dev));
      printk("<4>%s %s: rebind failed: %d\n", tmp___2, tmp___1, rc);
      }
    }
  }
  return;
}
}
static void do_unbind_rebind(struct usb_device *udev , int action ) 
{ struct usb_host_config *config ;
  int i ;
  struct usb_interface *intf ;
  struct usb_driver *drv ;
  struct device_driver  const  *__mptr ;

  {
  {
  config = udev->actconfig;
  }
  if (config) {
    {
    i = 0;
    }
    {
    while (1) {
      while_384_continue: /* CIL Label */ ;
      if (! (i < (int )config->desc.bNumInterfaces)) {
        goto while_384_break;
      }
      {
      intf = config->interface[i];
      }
      if (action == 0) {
        goto switch_385_0;
      } else {
        if (action == 1) {
          goto switch_385_1;
        } else {
          if (0) {
            switch_385_0: /* CIL Label */ 
            if (intf->dev.driver) {
              {
              __mptr = (struct device_driver  const  *)intf->dev.driver;
              drv = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
              }
              if (! drv->suspend) {
                {
                usb_forced_unbind_intf(intf);
                }
              } else {
                if (! drv->resume) {
                  {
                  usb_forced_unbind_intf(intf);
                  }
                }
              }
            }
            goto switch_385_break;
            switch_385_1: /* CIL Label */ 
            if (intf->needs_binding) {
              {
              usb_rebind_intf(intf);
              }
            }
            goto switch_385_break;
          } else {
            switch_385_break: /* CIL Label */ ;
          }
        }
      }
      {
      i ++;
      }
    }
    while_384_break: /* CIL Label */ ;
    }
  }
  return;
}
}
static int usb_suspend_device(struct usb_device *udev , pm_message_t msg ) 
{ struct usb_device_driver *udriver ;
  int status ;
  struct device_driver  const  *__mptr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = 0;
  }
  if ((unsigned int )udev->state == 0U) {
    goto done;
  } else {
    if ((unsigned int )udev->state == 8U) {
      goto done;
    }
  }
  if (udev->dev.driver) {
    {
    __mptr = (struct device_driver  const  *)udev->dev.driver;
    udriver = (struct usb_device_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_device_driver *)0)->drvwrap.driver));
    }
  } else {
    {
    udev->do_remote_wakeup = 0U;
    udriver = & usb_generic_driver;
    }
  }
  {
  status = (*(udriver->suspend))(udev, msg);
  }
  done: 
  {

  }
  return (status);
}
}
static int usb_resume_device(struct usb_device *udev , pm_message_t msg ) 
{ struct usb_device_driver *udriver ;
  int status ;
  struct device_driver  const  *__mptr ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = 0;
  }
  if ((unsigned int )udev->state == 0U) {
    goto done;
  }
  if ((unsigned long )udev->dev.driver == (unsigned long )((void *)0)) {
    {
    status = -107;
    }
    goto done;
  }
  if (udev->quirks & 2U) {
    {
    udev->reset_resume = 1U;
    }
  }
  {
  __mptr = (struct device_driver  const  *)udev->dev.driver;
  udriver = (struct usb_device_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_device_driver *)0)->drvwrap.driver));
  status = (*(udriver->resume))(udev, msg);
  }
  done: 
  {

  }
  if (status == 0) {
    {
    udev->autoresume_disabled = 0U;
    }
  }
  return (status);
}
}
static int usb_suspend_interface(struct usb_device *udev , struct usb_interface *intf ,
                                 pm_message_t msg ) 
{ struct usb_driver *driver ;
  int status ;
  int tmp ;
  struct device_driver  const  *__mptr ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
  status = 0;
  }
  if ((unsigned int )udev->state == 0U) {
    goto done;
  } else {
    {
    tmp = is_active((struct usb_interface  const  *)intf);
    }
    if (! tmp) {
      goto done;
    }
  }
  if ((unsigned int )intf->condition == 0U) {
    goto done;
  }
  {
  __mptr = (struct device_driver  const  *)intf->dev.driver;
  driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
  }
  if (driver->suspend) {
    {
    status = (*(driver->suspend))(intf, msg);
    }
    if (status == 0) {
      {
      mark_quiesced(intf);
      }
    } else {
      if (! (msg.event & 1024)) {
        {
        tmp___0 = dev_name((struct device  const  *)(& intf->dev));
        tmp___1 = dev_driver_string((struct device  const  *)(& intf->dev));
        printk("<3>%s %s: %s error %d\n", tmp___1, tmp___0, "suspend", status);
        }
      }
    }
  } else {
    {
    intf->needs_binding = 1U;
    tmp___2 = dev_name((struct device  const  *)(& intf->dev));
    tmp___3 = dev_driver_string((struct device  const  *)(& intf->dev));
    printk("<4>%s %s: no %s for driver %s?\n", tmp___3, tmp___2, "suspend", driver->name);
    mark_quiesced(intf);
    }
  }
  done: 
  {

  }
  return (status);
}
}
static int usb_resume_interface(struct usb_device *udev , struct usb_interface *intf ,
                                pm_message_t msg , int reset_resume ) 
{ struct usb_driver *driver ;
  int status ;
  int tmp ;
  struct device_driver  const  *__mptr ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
  status = 0;
  }
  if ((unsigned int )udev->state == 0U) {
    goto done;
  } else {
    {
    tmp = is_active((struct usb_interface  const  *)intf);
    }
    if (tmp) {
      goto done;
    }
  }
  if ((unsigned int )intf->condition == 3U) {
    goto done;
  }
  if ((unsigned int )intf->condition == 0U) {
    if (intf->needs_altsetting0) {
      if ((unsigned int )intf->dev.power.status == 1U) {
        {
        usb_set_interface(udev, (int )(intf->altsetting + 0)->desc.bInterfaceNumber,
                          0);
        intf->needs_altsetting0 = 0U;
        }
      }
    }
    goto done;
  }
  if (intf->needs_binding) {
    goto done;
  }
  {
  __mptr = (struct device_driver  const  *)intf->dev.driver;
  driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
  }
  if (reset_resume) {
    if (driver->reset_resume) {
      {
      status = (*(driver->reset_resume))(intf);
      }
      if (status) {
        {
        tmp___0 = dev_name((struct device  const  *)(& intf->dev));
        tmp___1 = dev_driver_string((struct device  const  *)(& intf->dev));
        printk("<3>%s %s: %s error %d\n", tmp___1, tmp___0, "reset_resume", status);
        }
      }
    } else {
      {
      intf->needs_binding = 1U;
      tmp___2 = dev_name((struct device  const  *)(& intf->dev));
      tmp___3 = dev_driver_string((struct device  const  *)(& intf->dev));
      printk("<4>%s %s: no %s for driver %s?\n", tmp___3, tmp___2, "reset_resume",
             driver->name);
      }
    }
  } else {
    if (driver->resume) {
      {
      status = (*(driver->resume))(intf);
      }
      if (status) {
        {
        tmp___4 = dev_name((struct device  const  *)(& intf->dev));
        tmp___5 = dev_driver_string((struct device  const  *)(& intf->dev));
        printk("<3>%s %s: %s error %d\n", tmp___5, tmp___4, "resume", status);
        }
      }
    } else {
      {
      intf->needs_binding = 1U;
      tmp___6 = dev_name((struct device  const  *)(& intf->dev));
      tmp___7 = dev_driver_string((struct device  const  *)(& intf->dev));
      printk("<4>%s %s: no %s for driver %s?\n", tmp___7, tmp___6, "resume", driver->name);
      }
    }
  }
  done: 
  {

  }
  if (status == 0) {
    if ((unsigned int )intf->condition == 2U) {
      {
      mark_active(intf);
      }
    }
  }
  return (status);
}
}
static int autosuspend_check(struct usb_device *udev , int reschedule ) 
{ int i ;
  struct usb_interface *intf ;
  unsigned long suspend_time ;
  unsigned long j ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_driver *driver ;
  struct device_driver  const  *__mptr ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  if (udev->pm_usage_cnt > 0) {
    return (-16);
  }
  if (udev->autosuspend_delay < 0) {
    return (-1);
  } else {
    if (udev->autosuspend_disabled) {
      return (-1);
    }
  }
  {
  suspend_time = udev->last_busy + (unsigned long )udev->autosuspend_delay;
  }
  if (udev->actconfig) {
    {
    i = 0;
    }
    {
    while (1) {
      while_386_continue: /* CIL Label */ ;
      if (! (i < (int )(udev->actconfig)->desc.bNumInterfaces)) {
        goto while_386_break;
      }
      {
      intf = (udev->actconfig)->interface[i];
      tmp = is_active((struct usb_interface  const  *)intf);
      }
      if (! tmp) {
        goto __Cont;
      }
      if (intf->pm_usage_cnt > 0) {
        return (-16);
      }
      if (intf->needs_remote_wakeup) {
        if (! udev->do_remote_wakeup) {
          return (-95);
        }
      }
      if (udev->quirks & 2U) {
        {
        __mptr = (struct device_driver  const  *)intf->dev.driver;
        driver = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
        }
        if (! driver->reset_resume) {
          return (-95);
        } else {
          if (intf->needs_remote_wakeup) {
            return (-95);
          }
        }
      }
      __Cont: /* CIL Label */ 
      {
      i ++;
      }
    }
    while_386_break: /* CIL Label */ ;
    }
  }
  {
  j = (unsigned long )jiffies;
  }
  if ((long )j - (long )suspend_time < 0L) {
    {
    reschedule = 1;
    }
  } else {
    {
    suspend_time = j + 1000UL;
    }
  }
  if (reschedule) {
    {
    tmp___3 = timer_pending((struct timer_list  const  *)(& udev->autosuspend.timer));
    }
    if (! tmp___3) {
      {
      tmp___2 = round_jiffies_up_relative(suspend_time - j);
      queue_delayed_work(ksuspend_usb_wq, & udev->autosuspend, tmp___2);
      }
    }
    return (-11);
  }
  return (0);
}
}
static int usb_suspend_both(struct usb_device *udev , pm_message_t msg ) 
{ int status ;
  int i ;
  struct usb_interface *intf ;
  struct usb_device *parent ;
  int tmp ;
  pm_message_t msg2 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  status = 0;
  i = 0;
  parent = udev->parent;
  }
  if ((unsigned int )udev->state == 0U) {
    goto done;
  } else {
    if ((unsigned int )udev->state == 8U) {
      goto done;
    }
  }
  {
  tmp = device_may_wakeup(& udev->dev);
  udev->do_remote_wakeup = (unsigned int )tmp;
  }
  if (msg.event & 1024) {
    {
    status = autosuspend_check(udev, 0);
    }
    if (status < 0) {
      goto done;
    }
  }
  if (udev->actconfig) {
    {
    while (1) {
      while_387_continue: /* CIL Label */ ;
      if (! (i < (int )(udev->actconfig)->desc.bNumInterfaces)) {
        goto while_387_break;
      }
      {
      intf = (udev->actconfig)->interface[i];
      status = usb_suspend_interface(udev, intf, msg);
      }
      if (status != 0) {
        goto while_387_break;
      }
      {
      i ++;
      }
    }
    while_387_break: /* CIL Label */ ;
    }
  }
  if (status == 0) {
    {
    status = usb_suspend_device(udev, msg);
    }
  }
  if (status != 0) {
    {
    msg2.event = msg.event ^ 18;
    }
    {
    while (1) {
      while_388_continue: /* CIL Label */ ;
      {
      i --;
      }
      if (! (i >= 0)) {
        goto while_388_break;
      }
      {
      intf = (udev->actconfig)->interface[i];
      usb_resume_interface(udev, intf, msg2, 0);
      }
    }
    while_388_break: /* CIL Label */ ;
    }
    if (msg.event & 1024) {
      {
      autosuspend_check(udev, status == -16);
      }
    }
  } else {
    {
    cancel_delayed_work(& udev->autosuspend);
    udev->can_submit = 0U;
    i = 0;
    }
    {
    while (1) {
      while_389_continue: /* CIL Label */ ;
      if (! (i < 16)) {
        goto while_389_break;
      }
      {
      usb_hcd_flush_endpoint(udev, udev->ep_out[i]);
      usb_hcd_flush_endpoint(udev, udev->ep_in[i]);
      i ++;
      }
    }
    while_389_break: /* CIL Label */ ;
    }
    if (parent) {
      if ((unsigned int )udev->state == 8U) {
        {
        usb_autosuspend_device(parent);
        }
      }
    }
  }
  done: 
  {

  }
  return (status);
}
}
static int usb_resume_both(struct usb_device *udev , pm_message_t msg ) 
{ int status ;
  int i ;
  struct usb_interface *intf ;
  struct usb_device *parent ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = 0;
  parent = udev->parent;
  cancel_delayed_work(& udev->autosuspend);
  }
  if ((unsigned int )udev->state == 0U) {
    {
    status = -19;
    }
    goto done;
  }
  {
  udev->can_submit = 1U;
  }
  if ((unsigned int )udev->state == 8U) {
    if (msg.event & 1024) {
      if (udev->autoresume_disabled) {
        {
        status = -1;
        }
        goto done;
      }
    }
    if (parent) {
      {
      status = usb_autoresume_device(parent);
      }
      if (status == 0) {
        {
        status = usb_resume_device(udev, msg);
        }
        if (status) {
          goto _L;
        } else {
          if ((unsigned int )udev->state == 0U) {
            _L: /* CIL Label */ 
            {
            usb_autosuspend_device(parent);
            }
            if ((unsigned int )udev->state == 0U) {
              {
              udev->discon_suspended = 1U;
              }
            }
          }
        }
      }
    } else {
      {
      status = usb_resume_device(udev, msg);
      }
    }
  } else {
    if (udev->reset_resume) {
      {
      status = usb_resume_device(udev, msg);
      }
    }
  }
  if (status == 0) {
    if (udev->actconfig) {
      {
      i = 0;
      }
      {
      while (1) {
        while_390_continue: /* CIL Label */ ;
        if (! (i < (int )(udev->actconfig)->desc.bNumInterfaces)) {
          goto while_390_break;
        }
        {
        intf = (udev->actconfig)->interface[i];
        usb_resume_interface(udev, intf, msg, (int )udev->reset_resume);
        i ++;
        }
      }
      while_390_break: /* CIL Label */ ;
      }
    }
  }
  done: 
  {

  }
  if (! status) {
    {
    udev->reset_resume = 0U;
    }
  }
  return (status);
}
}
static int usb_autopm_do_device(struct usb_device *udev , int inc_usage_cnt ) 
{ int status ;
  int __ret_warn_on ;
  long tmp ;
  struct pm_message __constr_expr_0 ;
  struct pm_message __constr_expr_1 ;

  {
  {
  status = 0;
  usb_pm_lock(udev);
  udev->auto_pm = 1U;
  udev->pm_usage_cnt += inc_usage_cnt;
  __ret_warn_on = ! (! (udev->pm_usage_cnt < 0));
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
  if (tmp) {
    {
    warn_slowpath_null("driver.c", 1345);
    }
  }
  {
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
  if (inc_usage_cnt) {
    {
    udev->last_busy = (unsigned long )jiffies;
    }
  }
  if (inc_usage_cnt >= 0) {
    if (udev->pm_usage_cnt > 0) {
      if ((unsigned int )udev->state == 8U) {
        {
        __constr_expr_0.event = 1040;
        status = usb_resume_both(udev, __constr_expr_0);
        }
      }
      if (status != 0) {
        {
        udev->pm_usage_cnt -= inc_usage_cnt;
        }
      } else {
        if (inc_usage_cnt) {
          {
          udev->last_busy = (unsigned long )jiffies;
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (inc_usage_cnt <= 0) {
      if (udev->pm_usage_cnt <= 0) {
        {
        __constr_expr_1.event = 1026;
        status = usb_suspend_both(udev, __constr_expr_1);
        }
      }
    }
  }
  {
  usb_pm_unlock(udev);
  }
  return (status);
}
}
void usb_autosuspend_work(struct work_struct *work ) 
{ struct usb_device *udev ;
  struct work_struct  const  *__mptr ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->autosuspend.work));
  usb_autopm_do_device(udev, 0);
  }
  return;
}
}
void usb_autoresume_work(struct work_struct *work ) 
{ struct usb_device *udev ;
  struct work_struct  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->autoresume));
  tmp = usb_autopm_do_device(udev, 1);
  }
  if (tmp == 0) {
    {
    usb_autopm_do_device(udev, -1);
    }
  }
  return;
}
}
void usb_autosuspend_device(struct usb_device *udev ) 
{ int status ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = usb_autopm_do_device(udev, -1);
  }
  return;
}
}
void usb_try_autosuspend_device(struct usb_device *udev ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  usb_autopm_do_device(udev, 0);
  }
  return;
}
}
int usb_autoresume_device(struct usb_device *udev ) 
{ int status ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = usb_autopm_do_device(udev, 1);
  }
  return (status);
}
}
static int usb_autopm_do_interface(struct usb_interface *intf , int inc_usage_cnt ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int status ;
  struct pm_message __constr_expr_0 ;
  struct pm_message __constr_expr_1 ;

  {
  {
  __mptr = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  status = 0;
  usb_pm_lock(udev);
  }
  if ((unsigned int )intf->condition == 0U) {
    {
    status = -19;
    }
  } else {
    {
    udev->auto_pm = 1U;
    intf->pm_usage_cnt += inc_usage_cnt;
    udev->last_busy = (unsigned long )jiffies;
    }
    if (inc_usage_cnt >= 0) {
      if (intf->pm_usage_cnt > 0) {
        if ((unsigned int )udev->state == 8U) {
          {
          __constr_expr_0.event = 1040;
          status = usb_resume_both(udev, __constr_expr_0);
          }
        }
        if (status != 0) {
          {
          intf->pm_usage_cnt -= inc_usage_cnt;
          }
        } else {
          {
          udev->last_busy = (unsigned long )jiffies;
          }
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (inc_usage_cnt <= 0) {
        if (intf->pm_usage_cnt <= 0) {
          {
          __constr_expr_1.event = 1026;
          status = usb_suspend_both(udev, __constr_expr_1);
          }
        }
      }
    }
  }
  {
  usb_pm_unlock(udev);
  }
  return (status);
}
}
void usb_autopm_put_interface(struct usb_interface *intf ) 
{ int status ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = usb_autopm_do_interface(intf, -1);
  }
  return;
}
}
static char const   __kstrtab_usb_autopm_put_interface[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'o', 
        (char const   )'p',      (char const   )'m',      (char const   )'_',      (char const   )'p', 
        (char const   )'u',      (char const   )'t',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'f',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_autopm_put_interface  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_autopm_put_interface), __kstrtab_usb_autopm_put_interface};
void usb_autopm_put_interface_async(struct usb_interface *intf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int status ;
  unsigned long tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  __mptr = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  status = 0;
  }
  if ((unsigned int )intf->condition == 0U) {
    {
    status = -19;
    }
  } else {
    {
    udev->last_busy = (unsigned long )jiffies;
    (intf->pm_usage_cnt) --;
    }
    if (udev->autosuspend_disabled) {
      {
      status = -1;
      }
    } else {
      if (udev->autosuspend_delay < 0) {
        {
        status = -1;
        }
      } else {
        if (intf->pm_usage_cnt <= 0) {
          {
          tmp___0 = timer_pending((struct timer_list  const  *)(& udev->autosuspend.timer));
          }
          if (! tmp___0) {
            {
            tmp = round_jiffies_up_relative((unsigned long )udev->autosuspend_delay);
            queue_delayed_work(ksuspend_usb_wq, & udev->autosuspend, tmp);
            }
          }
        }
      }
    }
  }
  return;
}
}
static char const   __kstrtab_usb_autopm_put_interface_async[31]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'o', 
        (char const   )'p',      (char const   )'m',      (char const   )'_',      (char const   )'p', 
        (char const   )'u',      (char const   )'t',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'f',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )'_',      (char const   )'a',      (char const   )'s',      (char const   )'y', 
        (char const   )'n',      (char const   )'c',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_autopm_put_interface_async  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_autopm_put_interface_async), __kstrtab_usb_autopm_put_interface_async};
int usb_autopm_get_interface(struct usb_interface *intf ) 
{ int status ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = usb_autopm_do_interface(intf, 1);
  }
  return (status);
}
}
static char const   __kstrtab_usb_autopm_get_interface[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'o', 
        (char const   )'p',      (char const   )'m',      (char const   )'_',      (char const   )'g', 
        (char const   )'e',      (char const   )'t',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'f',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_autopm_get_interface  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_autopm_get_interface), __kstrtab_usb_autopm_get_interface};
int usb_autopm_get_interface_async(struct usb_interface *intf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int status ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  status = 0;
  }
  if ((unsigned int )intf->condition == 0U) {
    {
    status = -19;
    }
  } else {
    if (udev->autoresume_disabled) {
      {
      status = -1;
      }
    } else {
      {
      (intf->pm_usage_cnt) ++;
      }
      if (intf->pm_usage_cnt > 0) {
        if ((unsigned int )udev->state == 8U) {
          {
          queue_work(ksuspend_usb_wq, & udev->autoresume);
          }
        }
      }
    }
  }
  return (status);
}
}
static char const   __kstrtab_usb_autopm_get_interface_async[31]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'o', 
        (char const   )'p',      (char const   )'m',      (char const   )'_',      (char const   )'g', 
        (char const   )'e',      (char const   )'t',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'f',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )'_',      (char const   )'a',      (char const   )'s',      (char const   )'y', 
        (char const   )'n',      (char const   )'c',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_autopm_get_interface_async  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_autopm_get_interface_async), __kstrtab_usb_autopm_get_interface_async};
int usb_autopm_set_interface(struct usb_interface *intf ) 
{ int status ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  status = usb_autopm_do_interface(intf, 0);
  }
  return (status);
}
}
static char const   __kstrtab_usb_autopm_set_interface[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'o', 
        (char const   )'p',      (char const   )'m',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'f',      (char const   )'a',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_autopm_set_interface  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_autopm_set_interface), __kstrtab_usb_autopm_set_interface};
int usb_external_suspend_device(struct usb_device *udev ,
                                pm_message_t msg ) 
{ int status ;

  {
  {
  do_unbind_rebind(udev, 0);
  usb_pm_lock(udev);
  udev->auto_pm = 0U;
  status = usb_suspend_both(udev, msg);
  usb_pm_unlock(udev);
  }
  return (status);
}
}
int usb_external_resume_device(struct usb_device *udev , pm_message_t msg ) 
{ int status ;

  {
  {
  usb_pm_lock(udev);
  udev->auto_pm = 0U;
  status = usb_resume_both(udev, msg);
  udev->last_busy = (unsigned long )jiffies;
  usb_pm_unlock(udev);
  }
  if (status == 0) {
    {
    do_unbind_rebind(udev, 1);
    }
  }
  if (status == 0) {
    {
    usb_try_autosuspend_device(udev);
    }
  }
  return (status);
}
}
int usb_suspend(struct device *dev , pm_message_t msg ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if ((unsigned int )udev->state == 8U) {
    if (udev->parent) {
      {
      udev->skip_sys_resume = 1U;
      }
    } else {
      if ((unsigned int )udev->speed != 3U) {
        {
        udev->skip_sys_resume = 1U;
        }
      }
    }
    return (0);
  }
  {
  udev->skip_sys_resume = 0U;
  tmp = usb_external_suspend_device(udev, msg);
  }
  return (tmp);
}
}
int usb_resume(struct device *dev , pm_message_t msg ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if (udev->skip_sys_resume) {
    return (0);
  }
  {
  tmp = usb_external_resume_device(udev, msg);
  }
  return (tmp);
}
}
struct bus_type usb_bus_type  = 
     {"usb", (struct bus_attribute *)0, (struct device_attribute *)0, (struct driver_attribute *)0,
    & usb_device_match, & usb_uevent, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (void (*)(struct device *dev ))0, (int (*)(struct device *dev , pm_message_t state ))0,
    (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (struct dev_pm_ops *)0, (struct bus_type_private *)0};
static unsigned long __force_order___4  ;
__inline static unsigned long native_read_cr0___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static void native_write_cr0___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static void native_write_cr2___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static void native_write_cr3___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___4): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static void load_cr3___4(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___4((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___4((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___4((unsigned long )cr4);
  }
  return;
}
}
extern void *idr_find(struct idr *idp , int id ) ;
extern int idr_pre_get(struct idr *idp , gfp_t gfp_mask ) ;
extern int idr_get_new(struct idr *idp , void *ptr , int *id ) ;
extern int idr_get_new_above(struct idr *idp , void *ptr , int starting_id , int *id ) ;
extern int idr_for_each(struct idr *idp , int (*fn)(int id , void *p , void *data ) ,
                        void *data ) ;
extern void *idr_get_next(struct idr *idp , int *nextid ) ;
extern void *idr_replace(struct idr *idp , void *ptr , int id ) ;
extern void idr_remove(struct idr *idp , int id ) ;
extern void idr_remove_all(struct idr *idp ) ;
extern void idr_destroy(struct idr *idp ) ;
extern void idr_init(struct idr *idp ) ;
extern int ida_pre_get(struct ida *ida , gfp_t gfp_mask ) ;
extern int ida_get_new_above(struct ida *ida , int starting_id , int *p_id ) ;
extern int ida_get_new(struct ida *ida , int *p_id ) ;
extern void ida_remove(struct ida *ida , int id ) ;
extern void ida_destroy(struct ida *ida ) ;
extern void ida_init(struct ida *ida ) ;
extern void idr_init_cache(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
__inline static u64 div_u64_rem___4(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_39___0 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___4(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___4(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___4(u64 ns ) ;
static union ktime  const  ktime_zero___4  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___4(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___4.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___4(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___4((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___4  ;
static int usb_endpoint_major  ;
static struct idr endpoint_idr  =    {(struct idr_layer *)((void *)0), (struct idr_layer *)((void *)0), 0, 0, {{0U}}};
static ssize_t show_ep_bLength(struct device *dev ,
                               struct device_attribute *attr , char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (ep->desc)->bLength);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bLength  =    {{"bLength", (struct module *)0, (mode_t )292}, & show_ep_bLength, (ssize_t (*)(struct device *dev ,
                                                                                   struct device_attribute *attr ,
                                                                                   char const   *buf ,
                                                                                   size_t count ))((void *)0)};
static ssize_t show_ep_bEndpointAddress(struct device *dev ,
                                        struct device_attribute *attr , char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (ep->desc)->bEndpointAddress);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bEndpointAddress  =    {{"bEndpointAddress", (struct module *)0, (mode_t )292}, & show_ep_bEndpointAddress,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_ep_bmAttributes(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (ep->desc)->bmAttributes);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bmAttributes  =    {{"bmAttributes", (struct module *)0, (mode_t )292}, & show_ep_bmAttributes, (ssize_t (*)(struct device *dev ,
                                                                                             struct device_attribute *attr ,
                                                                                             char const   *buf ,
                                                                                             size_t count ))((void *)0)};
static ssize_t show_ep_bInterval(struct device *dev ,
                                 struct device_attribute *attr , char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (ep->desc)->bInterval);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bInterval  =    {{"bInterval", (struct module *)0, (mode_t )292}, & show_ep_bInterval, (ssize_t (*)(struct device *dev ,
                                                                                       struct device_attribute *attr ,
                                                                                       char const   *buf ,
                                                                                       size_t count ))((void *)0)};
static ssize_t show_ep_wMaxPacketSize(struct device *dev ,
                                      struct device_attribute *attr , char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  tmp = sprintf(buf, "%04x\n", (int )(ep->desc)->wMaxPacketSize & 2047);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_wMaxPacketSize  =    {{"wMaxPacketSize", (struct module *)0, (mode_t )292}, & show_ep_wMaxPacketSize,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_ep_type(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  char *type ;
  int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  type = (char *)"unknown";
  tmp = usb_endpoint_type((struct usb_endpoint_descriptor  const  *)ep->desc);
  }
  if (tmp == 0) {
    goto switch_391_0;
  } else {
    if (tmp == 1) {
      goto switch_391_1;
    } else {
      if (tmp == 2) {
        goto switch_391_2;
      } else {
        if (tmp == 3) {
          goto switch_391_3;
        } else {
          if (0) {
            switch_391_0: /* CIL Label */ 
            {
            type = (char *)"Control";
            }
            goto switch_391_break;
            switch_391_1: /* CIL Label */ 
            {
            type = (char *)"Isoc";
            }
            goto switch_391_break;
            switch_391_2: /* CIL Label */ 
            {
            type = (char *)"Bulk";
            }
            goto switch_391_break;
            switch_391_3: /* CIL Label */ 
            {
            type = (char *)"Interrupt";
            }
            goto switch_391_break;
          } else {
            switch_391_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp___0 = sprintf(buf, "%s\n", type);
  }
  return (tmp___0);
}
}
static struct device_attribute dev_attr_type  =    {{"type", (struct module *)0, (mode_t )292}, & show_ep_type, (ssize_t (*)(struct device *dev ,
                                                                             struct device_attribute *attr ,
                                                                             char const   *buf ,
                                                                             size_t count ))((void *)0)};
static ssize_t show_ep_interval(struct device *dev ,
                                struct device_attribute *attr , char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  char unit ;
  unsigned int interval ;
  unsigned int in ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  interval = 0U;
  in = (unsigned int )((int )(ep->desc)->bEndpointAddress & 128);
  tmp = usb_endpoint_type((struct usb_endpoint_descriptor  const  *)ep->desc);
  }
  if (tmp == 0) {
    goto switch_392_0;
  } else {
    if (tmp == 1) {
      goto switch_392_1;
    } else {
      if (tmp == 2) {
        goto switch_392_2;
      } else {
        if (tmp == 3) {
          goto switch_392_3;
        } else {
          if (0) {
            switch_392_0: /* CIL Label */ 
            if ((unsigned int )(ep->udev)->speed == 3U) {
              {
              interval = (unsigned int )(ep->desc)->bInterval;
              }
            }
            goto switch_392_break;
            switch_392_1: /* CIL Label */ 
            {
            interval = (unsigned int )(1 << ((int )(ep->desc)->bInterval - 1));
            }
            goto switch_392_break;
            switch_392_2: /* CIL Label */ 
            if ((unsigned int )(ep->udev)->speed == 3U) {
              if (! in) {
                {
                interval = (unsigned int )(ep->desc)->bInterval;
                }
              }
            }
            goto switch_392_break;
            switch_392_3: /* CIL Label */ 
            if ((unsigned int )(ep->udev)->speed == 3U) {
              {
              interval = (unsigned int )(1 << ((int )(ep->desc)->bInterval - 1));
              }
            } else {
              {
              interval = (unsigned int )(ep->desc)->bInterval;
              }
            }
            goto switch_392_break;
          } else {
            switch_392_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  if ((unsigned int )(ep->udev)->speed == 3U) {
    {
    tmp___0 = 125;
    }
  } else {
    {
    tmp___0 = 1000;
    }
  }
  {
  interval *= (unsigned int )tmp___0;
  }
  if (interval % 1000U) {
    {
    unit = (char )'u';
    }
  } else {
    {
    unit = (char )'m';
    interval /= 1000U;
    }
  }
  {
  tmp___1 = sprintf(buf, "%d%cs\n", interval, unit);
  }
  return (tmp___1);
}
}
static struct device_attribute dev_attr_interval  =    {{"interval", (struct module *)0, (mode_t )292}, & show_ep_interval, (ssize_t (*)(struct device *dev ,
                                                                                     struct device_attribute *attr ,
                                                                                     char const   *buf ,
                                                                                     size_t count ))((void *)0)};
static ssize_t show_ep_direction(struct device *dev ,
                                 struct device_attribute *attr , char *buf ) 
{ struct ep_device *ep ;
  struct device  const  *__mptr ;
  char *direction ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  tmp___0 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)ep->desc);
  }
  if (tmp___0) {
    {
    direction = (char *)"both";
    }
  } else {
    {
    tmp = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)ep->desc);
    }
    if (tmp) {
      {
      direction = (char *)"in";
      }
    } else {
      {
      direction = (char *)"out";
      }
    }
  }
  {
  tmp___1 = sprintf(buf, "%s\n", direction);
  }
  return (tmp___1);
}
}
static struct device_attribute dev_attr_direction  =    {{"direction", (struct module *)0, (mode_t )292}, & show_ep_direction, (ssize_t (*)(struct device *dev ,
                                                                                       struct device_attribute *attr ,
                                                                                       char const   *buf ,
                                                                                       size_t count ))((void *)0)};
static struct attribute *ep_dev_attrs[9]  = 
  {      & dev_attr_bLength.attr,      & dev_attr_bEndpointAddress.attr,      & dev_attr_bmAttributes.attr,      & dev_attr_bInterval.attr, 
        & dev_attr_wMaxPacketSize.attr,      & dev_attr_interval.attr,      & dev_attr_type.attr,      & dev_attr_direction.attr, 
        (struct attribute *)((void *)0)};
static struct attribute_group ep_dev_attr_grp  =    {(char const   *)0, (mode_t (*)(struct kobject * , struct attribute * , int  ))0,
    ep_dev_attrs};
static struct attribute_group *ep_dev_groups[2]  = {      & ep_dev_attr_grp,      (struct attribute_group *)((void *)0)};
static int usb_endpoint_major_init(void) 
{ dev_t dev ;
  int error ;

  {
  {
  error = alloc_chrdev_region(& dev, 0U, 262144U, "usb_endpoint");
  }
  if (error) {
    {
    printk("<3>Unable to get a dynamic major for usb endpoints.\n");
    }
    return (error);
  }
  {
  usb_endpoint_major = (int )(dev >> 20);
  }
  return (error);
}
}
static void usb_endpoint_major_cleanup(void) 
{ 

  {
  {
  unregister_chrdev_region((unsigned int )(usb_endpoint_major << 20), 262144U);
  }
  return;
}
}
static int endpoint_get_minor(struct ep_device *ep_dev ) ;
static struct mutex minor_lock  =    {{(int volatile   )1}, {{0U}}, {& minor_lock.wait_list, & minor_lock.wait_list},
    (struct thread_info *)0};
static int endpoint_get_minor(struct ep_device *ep_dev ) 
{ int retval ;
  int id ;
  int tmp ;

  {
  {
  retval = -12;
  mutex_lock(& minor_lock);
  tmp = idr_pre_get(& endpoint_idr, 208U);
  }
  if (tmp == 0) {
    goto exit;
  }
  {
  retval = idr_get_new(& endpoint_idr, (void *)ep_dev, & id);
  }
  if (retval < 0) {
    if (retval == -11) {
      {
      retval = -12;
      }
    }
    goto exit;
  }
  {
  ep_dev->minor = (int )((unsigned int )id & ((1U << (sizeof(int ) * 8UL - 1UL)) - 1U));
  }
  exit: 
  {
  mutex_unlock(& minor_lock);
  }
  return (retval);
}
}
static void endpoint_free_minor(struct ep_device *ep_dev ) 
{ 

  {
  {
  idr_remove(& endpoint_idr, ep_dev->minor);
  }
  return;
}
}
static struct endpoint_class *ep_class  ;
static struct lock_class_key __key___5  ;
static int init_endpoint_class(void) 
{ int result ;
  void *tmp ;
  struct class *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
  result = 0;
  }
  if ((unsigned long )ep_class != (unsigned long )((void *)0)) {
    {
    kref_get(& ep_class->kref);
    }
    goto exit;
  }
  {
  tmp = kmalloc((unsigned int )sizeof(*ep_class), 208U);
  ep_class = (struct endpoint_class *)tmp;
  }
  if (! ep_class) {
    {
    result = -12;
    }
    goto exit;
  }
  {
  kref_init(& ep_class->kref);
  tmp___0 = __class_create((struct module *)0, "usb_endpoint", & __key___5);
  ep_class->class = tmp___0;
  tmp___2 = IS_ERR((void const   *)ep_class->class);
  }
  if (tmp___2) {
    {
    tmp___1 = PTR_ERR((void const   *)ep_class->class);
    result = (int )tmp___1;
    }
    goto class_create_error;
  }
  {
  result = usb_endpoint_major_init();
  }
  if (result) {
    goto endpoint_major_error;
  }
  goto exit;
  endpoint_major_error: 
  {
  class_destroy(ep_class->class);
  }
  class_create_error: 
  {
  kfree((void const   *)ep_class);
  ep_class = (struct endpoint_class *)((void *)0);
  }
  exit: 
  return (result);
}
}
static void release_endpoint_class(struct kref *kref ) 
{ 

  {
  {
  class_destroy(ep_class->class);
  kfree((void const   *)ep_class);
  ep_class = (struct endpoint_class *)((void *)0);
  usb_endpoint_major_cleanup();
  }
  return;
}
}
static void destroy_endpoint_class(void) 
{ 

  {
  if (ep_class) {
    {
    kref_put(& ep_class->kref, & release_endpoint_class);
    }
  }
  return;
}
}
static void ep_device_release(struct device *dev ) 
{ struct ep_device *ep_dev ;
  struct device  const  *__mptr ;

  {
  {
  __mptr = (struct device  const  *)dev;
  ep_dev = (struct ep_device *)((char *)__mptr - (unsigned int )(& ((struct ep_device *)0)->dev));
  endpoint_free_minor(ep_dev);
  kfree((void const   *)ep_dev);
  }
  return;
}
}
int usb_create_ep_devs(struct device *parent , struct usb_host_endpoint *endpoint ,
                       struct usb_device *udev ) 
{ char name[8] ;
  struct ep_device *ep_dev ;
  int retval ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  retval = init_endpoint_class();
  }
  if (retval) {
    goto exit;
  }
  {
  tmp = kzalloc((unsigned int )sizeof(*ep_dev), 208U);
  ep_dev = (struct ep_device *)tmp;
  }
  if (! ep_dev) {
    {
    retval = -12;
    }
    goto error_alloc;
  }
  {
  retval = endpoint_get_minor(ep_dev);
  }
  if (retval) {
    {
    tmp___0 = dev_name((struct device  const  *)(& ep_dev->dev));
    tmp___1 = dev_name((struct device  const  *)parent);
    tmp___2 = dev_driver_string((struct device  const  *)parent);
    printk("<3>%s %s: can not allocate minor number for %s\n", tmp___2, tmp___1, tmp___0);
    }
    goto error_register;
  }
  {
  ep_dev->desc = & endpoint->desc;
  ep_dev->udev = udev;
  ep_dev->dev.groups = ep_dev_groups;
  ep_dev->dev.devt = (unsigned int )((usb_endpoint_major << 20) | ep_dev->minor);
  ep_dev->dev.class = ep_class->class;
  ep_dev->dev.parent = parent;
  ep_dev->dev.release = & ep_device_release;
  dev_set_name(& ep_dev->dev, "usbdev%d.%d_ep%02x", (udev->bus)->busnum, udev->devnum,
               endpoint->desc.bEndpointAddress);
  retval = device_register(& ep_dev->dev);
  }
  if (retval) {
    goto error_chrdev;
  }
  {
  sprintf(name, "ep_%02x", endpoint->desc.bEndpointAddress);
  retval = sysfs_create_link(& parent->kobj, & ep_dev->dev.kobj, (char const   *)(name));
  }
  if (retval) {
    goto error_link;
  }
  {
  endpoint->ep_dev = ep_dev;
  }
  return (retval);
  error_link: 
  {
  device_unregister(& ep_dev->dev);
  destroy_endpoint_class();
  }
  return (retval);
  error_chrdev: 
  {
  endpoint_free_minor(ep_dev);
  }
  error_register: 
  {
  kfree((void const   *)ep_dev);
  }
  error_alloc: 
  {
  destroy_endpoint_class();
  }
  exit: 
  return (retval);
}
}
void usb_remove_ep_devs(struct usb_host_endpoint *endpoint ) 
{ struct ep_device *ep_dev ;
  char name[8] ;

  {
  {
  ep_dev = endpoint->ep_dev;
  }
  if (ep_dev) {
    {
    sprintf(name, "ep_%02x", endpoint->desc.bEndpointAddress);
    sysfs_remove_link(& (ep_dev->dev.parent)->kobj, (char const   *)(name));
    device_unregister(& ep_dev->dev);
    endpoint->ep_dev = (struct ep_device *)((void *)0);
    destroy_endpoint_class();
    }
  }
  return;
}
}
static unsigned long __force_order___5  ;
__inline static unsigned long native_read_cr0___5(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___5));
  }
  return (val);
}
}
__inline static void native_write_cr0___5(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___5));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___5(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___5));
  }
  return (val);
}
}
__inline static void native_write_cr2___5(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___5));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___5(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___5));
  }
  return (val);
}
}
__inline static void native_write_cr3___5(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___5));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___5(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___5));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___5(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___5): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___5(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___5));
  }
  return;
}
}
__inline static void load_cr3___5(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___5((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___5(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___5();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___5((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___5(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___5();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___5((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___5(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___1 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___5(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___5(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___5(u64 ns ) ;
static union ktime  const  ktime_zero___5  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___5(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___5.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___5(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___5((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___6  ;
static struct file_operations  const  *usb_minors[256]  ;
static struct rw_semaphore minor_rwsem  =    {0L, {{0U}}, {& minor_rwsem.wait_list, & minor_rwsem.wait_list}};
static int usb_open(struct inode *inode , struct file *file ) 
{ int minor ;
  unsigned int tmp ;
  struct file_operations  const  *c ;
  int err ;
  struct file_operations  const  *old_fops ;
  struct file_operations  const  *new_fops ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = iminor((struct inode  const  *)inode);
  minor = (int )tmp;
  err = -19;
  new_fops = (struct file_operations  const  *)((void *)0);
  lock_kernel();
  down_read(& minor_rwsem);
  c = usb_minors[minor];
  }
  if (! c) {
    goto done;
  } else {
    if (c) {
      {
      tmp___1 = try_module_get((struct module *)c->owner);
      }
      if (tmp___1) {
        {
        new_fops = c;
        }
      } else {
        {
        new_fops = (struct file_operations  const  *)((void *)0);
        }
      }
    } else {
      {
      new_fops = (struct file_operations  const  *)((void *)0);
      }
    }
    if (! new_fops) {
      goto done;
    }
  }
  {
  old_fops = file->f_op;
  file->f_op = new_fops;
  }
  if ((file->f_op)->open) {
    {
    err = (*((file->f_op)->open))(inode, file);
    }
  }
  if (err) {
    {
    while (1) {
      while_393_continue: /* CIL Label */ ;
      if (file->f_op) {
        {
        module_put((struct module *)(file->f_op)->owner);
        }
      }
      goto while_393_break;
    }
    while_393_break: /* CIL Label */ ;
    }
    if (old_fops) {
      {
      tmp___3 = try_module_get((struct module *)old_fops->owner);
      }
      if (tmp___3) {
        {
        file->f_op = old_fops;
        }
      } else {
        {
        file->f_op = (struct file_operations  const  *)((void *)0);
        }
      }
    } else {
      {
      file->f_op = (struct file_operations  const  *)((void *)0);
      }
    }
  }
  {
  while (1) {
    while_394_continue: /* CIL Label */ ;
    if (old_fops) {
      {
      module_put((struct module *)old_fops->owner);
      }
    }
    goto while_394_break;
  }
  while_394_break: /* CIL Label */ ;
  }
  done: 
  {
  up_read(& minor_rwsem);
  unlock_kernel();
  }
  return (err);
}
}
static struct file_operations  const  usb_fops  = 
     {(struct module *)0, (loff_t (*)(struct file * , loff_t  , int  ))0, (ssize_t (*)(struct file * ,
                                                                                     char * ,
                                                                                     size_t  ,
                                                                                     loff_t * ))0,
    (ssize_t (*)(struct file * , char const   * , size_t  , loff_t * ))0, (ssize_t (*)(struct kiocb * ,
                                                                                       struct iovec  const  * ,
                                                                                       unsigned long  ,
                                                                                       loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    (int (*)(struct inode * , struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & usb_open, (int (*)(struct file * ,
                                                                               fl_owner_t id ))0,
    (int (*)(struct inode * , struct file * ))0, (int (*)(struct file * , struct dentry * ,
                                                          int datasync ))0, (int (*)(struct kiocb * ,
                                                                                     int datasync ))0,
    (int (*)(int  , struct file * , int  ))0, (int (*)(struct file * , int  , struct file_lock * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0};
static struct usb_class *usb_class  ;
static struct lock_class_key __key___7  ;
static int init_usb_class(void) 
{ int result ;
  void *tmp ;
  struct class *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
  result = 0;
  }
  if ((unsigned long )usb_class != (unsigned long )((void *)0)) {
    {
    kref_get(& usb_class->kref);
    }
    goto exit;
  }
  {
  tmp = kmalloc((unsigned int )sizeof(*usb_class), 208U);
  usb_class = (struct usb_class *)tmp;
  }
  if (! usb_class) {
    {
    result = -12;
    }
    goto exit;
  }
  {
  kref_init(& usb_class->kref);
  tmp___0 = __class_create((struct module *)0, "usb", & __key___7);
  usb_class->class = tmp___0;
  tmp___2 = IS_ERR((void const   *)usb_class->class);
  }
  if (tmp___2) {
    {
    tmp___1 = IS_ERR((void const   *)usb_class->class);
    result = (int )tmp___1;
    printk("<3>class_create failed for usb devices\n");
    kfree((void const   *)usb_class);
    usb_class = (struct usb_class *)((void *)0);
    }
  }
  exit: 
  return (result);
}
}
static void release_usb_class(struct kref *kref ) 
{ 

  {
  {
  class_destroy(usb_class->class);
  kfree((void const   *)usb_class);
  usb_class = (struct usb_class *)((void *)0);
  }
  return;
}
}
static void destroy_usb_class(void) 
{ 

  {
  if (usb_class) {
    {
    kref_put(& usb_class->kref, & release_usb_class);
    }
  }
  return;
}
}
int usb_major_init(void) 
{ int error ;

  {
  {
  error = register_chrdev(180U, "usb", & usb_fops);
  }
  if (error) {
    {
    printk("<3>Unable to get major %d for usb devices\n", 180);
    }
  }
  return (error);
}
}
void usb_major_cleanup(void) 
{ 

  {
  {
  unregister_chrdev(180U, "usb");
  }
  return;
}
}
int usb_register_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) 
{ int retval ;
  int minor_base ;
  int minor ;
  char name[20] ;
  char *temp ;
  long tmp ;
  long tmp___0 ;

  {
  {
  retval = -22;
  minor_base = class_driver->minor_base;
  minor = 0;
  intf->minor = -1;
  }
  {
  while (1) {
    while_395_continue: /* CIL Label */ ;
    goto while_395_break;
  }
  while_395_break: /* CIL Label */ ;
  }
  if ((unsigned long )class_driver->fops == (unsigned long )((void *)0)) {
    goto exit;
  }
  {
  down_write(& minor_rwsem);
  minor = minor_base;
  }
  {
  while (1) {
    while_396_continue: /* CIL Label */ ;
    if (! (minor < 256)) {
      goto while_396_break;
    }
    if (usb_minors[minor]) {
      goto __Cont;
    }
    {
    usb_minors[minor] = class_driver->fops;
    retval = 0;
    }
    goto while_396_break;
    __Cont: /* CIL Label */ 
    {
    minor ++;
    }
  }
  while_396_break: /* CIL Label */ ;
  }
  {
  up_write(& minor_rwsem);
  }
  if (retval) {
    goto exit;
  }
  {
  retval = init_usb_class();
  }
  if (retval) {
    goto exit;
  }
  {
  intf->minor = minor;
  snprintf(name, (unsigned int )sizeof(name), (char const   *)class_driver->name,
           minor - minor_base);
  temp = strrchr((char const   *)(name), '/');
  }
  if (temp) {
    if ((int )*(temp + 1) != 0) {
      {
      temp ++;
      }
    } else {
      {
      temp = name;
      }
    }
  } else {
    {
    temp = name;
    }
  }
  {
  intf->usb_dev = device_create(usb_class->class, & intf->dev, (unsigned int )((180 << 20) | minor),
                                (void *)0, "%s", temp);
  tmp___0 = IS_ERR((void const   *)intf->usb_dev);
  }
  if (tmp___0) {
    {
    down_write(& minor_rwsem);
    usb_minors[intf->minor] = (struct file_operations  const  *)((void *)0);
    up_write(& minor_rwsem);
    tmp = PTR_ERR((void const   *)intf->usb_dev);
    retval = (int )tmp;
    }
  }
  exit: 
  return (retval);
}
}
static char const   __kstrtab_usb_register_dev[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_register_dev  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_register_dev), __kstrtab_usb_register_dev};
void usb_deregister_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) 
{ int minor_base ;
  char name[20] ;

  {
  {
  minor_base = class_driver->minor_base;
  }
  if (intf->minor == -1) {
    return;
  }
  {
  while (1) {
    while_397_continue: /* CIL Label */ ;
    goto while_397_break;
  }
  while_397_break: /* CIL Label */ ;
  }
  {
  down_write(& minor_rwsem);
  usb_minors[intf->minor] = (struct file_operations  const  *)((void *)0);
  up_write(& minor_rwsem);
  snprintf(name, (unsigned int )sizeof(name), (char const   *)class_driver->name,
           intf->minor - minor_base);
  device_destroy(usb_class->class, (unsigned int )((180 << 20) | intf->minor));
  intf->usb_dev = (struct device *)((void *)0);
  intf->minor = -1;
  destroy_usb_class();
  }
  return;
}
}
static char const   __kstrtab_usb_deregister_dev[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'v',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_deregister_dev  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_deregister_dev), __kstrtab_usb_deregister_dev};
static unsigned long __force_order___6  ;
__inline static unsigned long native_read_cr0___6(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___6));
  }
  return (val);
}
}
__inline static void native_write_cr0___6(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___6));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___6(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___6));
  }
  return (val);
}
}
__inline static void native_write_cr2___6(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___6));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___6(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___6));
  }
  return (val);
}
}
__inline static void native_write_cr3___6(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___6));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___6(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___6));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___6(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___6): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___6(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___6));
  }
  return;
}
}
__inline static void load_cr3___6(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___6((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___6(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___6();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___6((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___6(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___6();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___6((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___6(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_39___1 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___6(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___6(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___6(u64 ns ) ;
static union ktime  const  ktime_zero___6  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___6(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___6.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___6(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___6((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___8  ;
static int is_rndis(struct usb_interface_descriptor *desc ) 
{ int tmp ;

  {
  if ((int )desc->bInterfaceClass == 2) {
    if ((int )desc->bInterfaceSubClass == 2) {
      if ((int )desc->bInterfaceProtocol == 255) {
        {
        tmp = 1;
        }
      } else {
        {
        tmp = 0;
        }
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
static int is_activesync(struct usb_interface_descriptor *desc ) 
{ int tmp ;

  {
  if ((int )desc->bInterfaceClass == 239) {
    if ((int )desc->bInterfaceSubClass == 1) {
      if ((int )desc->bInterfaceProtocol == 1) {
        {
        tmp = 1;
        }
      } else {
        {
        tmp = 0;
        }
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
int usb_choose_configuration(struct usb_device *udev ) 
{ int i ;
  int num_configs ;
  int insufficient_power ;
  struct usb_host_config *c ;
  struct usb_host_config *best ;
  struct usb_interface_descriptor *desc ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
  insufficient_power = 0;
  best = (struct usb_host_config *)((void *)0);
  c = udev->config;
  num_configs = (int )udev->descriptor.bNumConfigurations;
  i = 0;
  }
  {
  while (1) {
    while_398_continue: /* CIL Label */ ;
    if (! (i < num_configs)) {
      goto while_398_break;
    }
    {
    desc = (struct usb_interface_descriptor *)((void *)0);
    }
    if ((int )c->desc.bNumInterfaces > 0) {
      {
      desc = & (c->intf_cache[0])->altsetting[0].desc;
      }
    }
    if ((int )c->desc.bMaxPower * 2 > (int )udev->bus_mA) {
      {
      insufficient_power ++;
      }
      goto __Cont;
    }
    if (i == 0) {
      if (desc) {
        {
        tmp = is_rndis(desc);
        }
        if (tmp) {
          goto __Cont;
        } else {
          {
          tmp___0 = is_activesync(desc);
          }
          if (tmp___0) {
            goto __Cont;
          } else {
            goto _L___1;
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      _L___0: /* CIL Label */ 
      if ((int )udev->descriptor.bDeviceClass != 255) {
        if (! desc) {
          {
          best = c;
          }
          goto while_398_break;
        } else {
          if ((int )desc->bInterfaceClass != 255) {
            {
            best = c;
            }
            goto while_398_break;
          } else {
            goto _L;
          }
        }
      } else {
        _L: /* CIL Label */ 
        if (! best) {
          {
          best = c;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    c ++;
    }
  }
  while_398_break: /* CIL Label */ ;
  }
  if (insufficient_power > 0) {
    {
    tmp___1 = plural(insufficient_power);
    tmp___2 = dev_name((struct device  const  *)(& udev->dev));
    tmp___3 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<6>%s %s: rejected %d configuration%s due to insufficient available bus power\n",
           tmp___3, tmp___2, insufficient_power, tmp___1);
    }
  }
  if (best) {
    {
    i = (int )best->desc.bConfigurationValue;
    tmp___4 = plural(num_configs);
    tmp___5 = dev_name((struct device  const  *)(& udev->dev));
    tmp___6 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<6>%s %s: configuration #%d chosen from %d choice%s\n", tmp___6, tmp___5,
           i, num_configs, tmp___4);
    }
  } else {
    {
    i = -1;
    tmp___7 = plural(num_configs);
    tmp___8 = dev_name((struct device  const  *)(& udev->dev));
    tmp___9 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<4>%s %s: no configuration chosen from %d choice%s\n", tmp___9, tmp___8,
           num_configs, tmp___7);
    }
  }
  return (i);
}
}
static int generic_probe(struct usb_device *udev ) 
{ int err ;
  int c ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  if (udev->authorized == 0U) {
    {
    tmp = dev_name((struct device  const  *)(& udev->dev));
    tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<3>%s %s: Device is not authorized for usage\n", tmp___0, tmp);
    }
  } else {
    {
    c = usb_choose_configuration(udev);
    }
    if (c >= 0) {
      {
      err = usb_set_configuration(udev, c);
      }
      if (err) {
        {
        tmp___1 = dev_name((struct device  const  *)(& udev->dev));
        tmp___2 = dev_driver_string((struct device  const  *)(& udev->dev));
        printk("<3>%s %s: can\'t set config #%d, error %d\n", tmp___2, tmp___1, c,
               err);
        }
      }
    }
  }
  {
  usb_notify_add_device(udev);
  }
  return (0);
}
}
static void generic_disconnect(struct usb_device *udev ) 
{ 

  {
  {
  usb_notify_remove_device(udev);
  }
  if (udev->actconfig) {
    {
    usb_set_configuration(udev, -1);
    }
  }
  return;
}
}
static int generic_suspend(struct usb_device *udev , pm_message_t msg ) 
{ int rc ;

  {
  if (! udev->parent) {
    {
    rc = hcd_bus_suspend(udev, msg);
    }
  } else {
    if (msg.event == 1) {
      {
      rc = 0;
      }
    } else {
      if (msg.event == 8) {
        {
        rc = 0;
        }
      } else {
        {
        rc = usb_port_suspend(udev, msg);
        }
      }
    }
  }
  return (rc);
}
}
static int generic_resume(struct usb_device *udev , pm_message_t msg ) 
{ int rc ;

  {
  if (! udev->parent) {
    {
    rc = hcd_bus_resume(udev, msg);
    }
  } else {
    {
    rc = usb_port_resume(udev, msg);
    }
  }
  return (rc);
}
}
struct usb_device_driver usb_generic_driver  =    {"usb", & generic_probe, & generic_disconnect, & generic_suspend, & generic_resume,
    {{(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
      (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
      (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
      (struct attribute_group **)0, (struct dev_pm_ops *)0, (struct driver_private *)0},
     0}, 1U};
static unsigned long __force_order___7  ;
__inline static unsigned long native_read_cr0___7(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___7));
  }
  return (val);
}
}
__inline static void native_write_cr0___7(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___7));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___7(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___7));
  }
  return (val);
}
}
__inline static void native_write_cr2___7(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___7));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___7(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___7));
  }
  return (val);
}
}
__inline static void native_write_cr3___7(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___7));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___7(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___7));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___7(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___7): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___7(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___7));
  }
  return;
}
}
__inline static void load_cr3___7(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___7((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___7(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___7();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___7((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___7(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___7();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___7((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___7(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___2 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___7(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___7(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___7(u64 ns ) ;
static union ktime  const  ktime_zero___7  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___7(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___7.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___7(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___7((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
extern struct nsproxy init_nsproxy ;
__inline static struct nsproxy *task_nsproxy(struct task_struct *tsk ) 
{ struct nsproxy *_________p1 ;

  {
  {
  _________p1 = (struct nsproxy *)*((struct nsproxy * volatile  *)(& tsk->nsproxy));
  }
  {
  while (1) {
    while_399_continue: /* CIL Label */ ;
    goto while_399_break;
  }
  while_399_break: /* CIL Label */ ;
  }
  return (_________p1);
}
}
extern int copy_namespaces(unsigned long flags , struct task_struct *tsk ) ;
extern void exit_task_namespaces(struct task_struct *tsk ) ;
extern void switch_task_namespaces(struct task_struct *tsk , struct nsproxy *new ) ;
extern void free_nsproxy(struct nsproxy *ns ) ;
extern int unshare_nsproxy_namespaces(unsigned long  , struct nsproxy ** , struct fs_struct * ) ;
__inline static void put_nsproxy(struct nsproxy *ns ) 
{ int tmp ;

  {
  {
  tmp = atomic_dec_and_test(& ns->count);
  }
  if (tmp) {
    {
    free_nsproxy(ns);
    }
  }
  return;
}
}
__inline static void get_nsproxy(struct nsproxy *ns ) 
{ 

  {
  {
  atomic_inc(& ns->count);
  }
  return;
}
}
extern int ns_cgroup_clone(struct task_struct *tsk , struct pid *pid ) ;
extern struct uts_namespace init_uts_ns ;
__inline static void get_uts_ns(struct uts_namespace *ns ) 
{ 

  {
  {
  kref_get(& ns->kref);
  }
  return;
}
}
extern struct uts_namespace *copy_utsname(unsigned long flags , struct uts_namespace *ns ) ;
extern void free_uts_ns(struct kref *kref ) ;
__inline static void put_uts_ns(struct uts_namespace *ns ) 
{ 

  {
  {
  kref_put(& ns->kref, & free_uts_ns);
  }
  return;
}
}
__inline static struct new_utsname *utsname(void) 
{ struct task_struct *tmp ;

  {
  {
  tmp = get_current();
  }
  return (& ((tmp->nsproxy)->uts_ns)->name);
}
}
__inline static struct new_utsname *init_utsname(void) 
{ 

  {
  return (& init_uts_ns.name);
}
}
extern struct rw_semaphore uts_sem ;
static struct lock_class_key __key___9  ;
__inline static u16 get_unaligned_le16(void const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __le16_to_cpup((__le16 const   *)((__le16 *)p));
  }
  return (tmp);
}
}
__inline static u32 get_unaligned_le32(void const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __le32_to_cpup((__le32 const   *)((__le32 *)p));
  }
  return (tmp);
}
}
__inline static u64 get_unaligned_le64(void const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __le64_to_cpup((__le64 const   *)((__le64 *)p));
  }
  return (tmp);
}
}
__inline static u16 get_unaligned_be16(void const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __be16_to_cpup((__be16 const   *)((__be16 *)p));
  }
  return (tmp);
}
}
__inline static u32 get_unaligned_be32(void const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __be32_to_cpup((__be32 const   *)((__be32 *)p));
  }
  return (tmp);
}
}
__inline static u64 get_unaligned_be64(void const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __be64_to_cpup((__be64 const   *)((__be64 *)p));
  }
  return (tmp);
}
}
__inline static void put_unaligned_le16(u16 val , void *p ) 
{ 

  {
  {
  *((__le16 *)p) = val;
  }
  return;
}
}
__inline static void put_unaligned_le32(u32 val , void *p ) 
{ 

  {
  {
  *((__le32 *)p) = val;
  }
  return;
}
}
__inline static void put_unaligned_le64(u64 val , void *p ) 
{ 

  {
  {
  *((__le64 *)p) = val;
  }
  return;
}
}
__inline static void put_unaligned_be16(u16 val , void *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __fswab16(val);
  *((__be16 *)p) = (unsigned short )((int )tmp);
  }
  return;
}
}
__inline static void put_unaligned_be32(u32 val , void *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __fswab32(val);
  *((__be32 *)p) = tmp;
  }
  return;
}
}
__inline static void put_unaligned_be64(u64 val , void *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __fswab64(val);
  *((__be64 *)p) = tmp;
  }
  return;
}
}
extern void __bad_unaligned_access_size(void) ;
extern int platform_device_register(struct platform_device * ) ;
extern void platform_device_unregister(struct platform_device * ) ;
extern struct bus_type platform_bus_type ;
extern struct device platform_bus ;
extern struct resource *platform_get_resource(struct platform_device * , unsigned int  ,
                                              unsigned int  ) ;
extern int platform_get_irq(struct platform_device * , unsigned int  ) ;
extern struct resource *platform_get_resource_byname(struct platform_device * , unsigned int  ,
                                                     char * ) ;
extern int platform_get_irq_byname(struct platform_device * , char * ) ;
extern int platform_add_devices(struct platform_device ** , int  ) ;
extern struct platform_device *platform_device_register_simple(char const   * , int id ,
                                                               struct resource * ,
                                                               unsigned int  ) ;
extern struct platform_device *platform_device_register_data(struct device * , char const   * ,
                                                             int  , void const   * ,
                                                             size_t  ) ;
extern struct platform_device *platform_device_alloc(char const   *name , int id ) ;
extern int platform_device_add_resources(struct platform_device *pdev , struct resource *res ,
                                         unsigned int num ) ;
extern int platform_device_add_data(struct platform_device *pdev , void const   *data ,
                                    size_t size ) ;
extern int platform_device_add(struct platform_device *pdev ) ;
extern void platform_device_del(struct platform_device *pdev ) ;
extern void platform_device_put(struct platform_device *pdev ) ;
extern int platform_driver_register(struct platform_driver * ) ;
extern void platform_driver_unregister(struct platform_driver * ) ;
extern int platform_driver_probe(struct platform_driver *driver , int (*probe)(struct platform_device * ) ) ;
extern int early_platform_driver_register(struct early_platform_driver *epdrv , char *buf ) ;
extern void early_platform_add_devices(struct platform_device **devs , int num ) ;
__inline static int is_early_platform_device(struct platform_device *pdev ) 
{ 

  {
  return (! pdev->dev.driver);
}
}
extern void early_platform_driver_register_all(char *class_str ) ;
extern int early_platform_driver_probe(char *class_str , int nr_probe , int user_only ) ;
extern void early_platform_cleanup(void) ;
struct usb_mon_operations *mon_ops  ;
unsigned long usb_hcds_loaded  ;
static char const   __kstrtab_usb_hcds_loaded[16]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'s', 
        (char const   )'_',      (char const   )'l',      (char const   )'o',      (char const   )'a', 
        (char const   )'d',      (char const   )'e',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcds_loaded  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcds_loaded), __kstrtab_usb_hcds_loaded};
struct list_head usb_bus_list  =    {& usb_bus_list, & usb_bus_list};
static char const   __kstrtab_usb_bus_list[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'b',      (char const   )'u',      (char const   )'s',      (char const   )'_', 
        (char const   )'l',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_bus_list  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_bus_list), __kstrtab_usb_bus_list};
static struct usb_busmap busmap  ;
struct mutex usb_bus_list_lock  =    {{(int volatile   )1}, {{0U}}, {& usb_bus_list_lock.wait_list, & usb_bus_list_lock.wait_list},
    (struct thread_info *)0};
static char const   __kstrtab_usb_bus_list_lock[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'b',      (char const   )'u',      (char const   )'s',      (char const   )'_', 
        (char const   )'l',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'_',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'k',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_bus_list_lock  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_bus_list_lock), __kstrtab_usb_bus_list_lock};
static spinlock_t hcd_root_hub_lock  =    {{0U}};
static spinlock_t hcd_urb_list_lock  =    {{0U}};
static spinlock_t hcd_urb_unlink_lock  =    {{0U}};
wait_queue_head_t usb_kill_urb_queue  =    {{{0U}}, {& usb_kill_urb_queue.task_list, & usb_kill_urb_queue.task_list}};
__inline static int is_root_hub(struct usb_device *udev ) 
{ 

  {
  return ((unsigned long )udev->parent == (unsigned long )((void *)0));
}
}
static u8 const   usb2_rh_dev_descriptor[18]  = 
  {      (u8 const   )18,      (u8 const   )1,      (u8 const   )0,      (u8 const   )2, 
        (u8 const   )9,      (u8 const   )0,      (u8 const   )0,      (u8 const   )64, 
        (u8 const   )107,      (u8 const   )29,      (u8 const   )2,      (u8 const   )0, 
        (u8 const   )((132638 >> 8) & 255),      (u8 const   )((132638 >> 16) & 255),      (u8 const   )3,      (u8 const   )2, 
        (u8 const   )1,      (u8 const   )1};
static u8 const   usb11_rh_dev_descriptor[18]  = 
  {      (u8 const   )18,      (u8 const   )1,      (u8 const   )16,      (u8 const   )1, 
        (u8 const   )9,      (u8 const   )0,      (u8 const   )0,      (u8 const   )64, 
        (u8 const   )107,      (u8 const   )29,      (u8 const   )1,      (u8 const   )0, 
        (u8 const   )((132638 >> 8) & 255),      (u8 const   )((132638 >> 16) & 255),      (u8 const   )3,      (u8 const   )2, 
        (u8 const   )1,      (u8 const   )1};
static u8 const   fs_rh_config_descriptor[25]  = 
  {      (u8 const   )9,      (u8 const   )2,      (u8 const   )25,      (u8 const   )0, 
        (u8 const   )1,      (u8 const   )1,      (u8 const   )0,      (u8 const   )192, 
        (u8 const   )0,      (u8 const   )9,      (u8 const   )4,      (u8 const   )0, 
        (u8 const   )0,      (u8 const   )1,      (u8 const   )9,      (u8 const   )0, 
        (u8 const   )0,      (u8 const   )0,      (u8 const   )7,      (u8 const   )5, 
        (u8 const   )129,      (u8 const   )3,      (u8 const   )2,      (u8 const   )0, 
        (u8 const   )255};
static u8 const   hs_rh_config_descriptor[25]  = 
  {      (u8 const   )9,      (u8 const   )2,      (u8 const   )25,      (u8 const   )0, 
        (u8 const   )1,      (u8 const   )1,      (u8 const   )0,      (u8 const   )192, 
        (u8 const   )0,      (u8 const   )9,      (u8 const   )4,      (u8 const   )0, 
        (u8 const   )0,      (u8 const   )1,      (u8 const   )9,      (u8 const   )0, 
        (u8 const   )0,      (u8 const   )0,      (u8 const   )7,      (u8 const   )5, 
        (u8 const   )129,      (u8 const   )3,      (u8 const   )4,      (u8 const   )0, 
        (u8 const   )12};
static unsigned int ascii2utf(char *s , u8 *utf , int utfmax ) 
{ unsigned int retval ;
  u8 *tmp ;
  char *tmp___0 ;
  u8 *tmp___1 ;

  {
  {
  retval = 0U;
  }
  {
  while (1) {
    while_400_continue: /* CIL Label */ ;
    if (*s) {
      if (! (utfmax > 1)) {
        goto while_400_break;
      }
    } else {
      goto while_400_break;
    }
    {
    tmp = utf;
    utf ++;
    tmp___0 = s;
    s ++;
    *tmp = (unsigned char )*tmp___0;
    tmp___1 = utf;
    utf ++;
    *tmp___1 = (unsigned char)0;
    utfmax -= 2;
    retval += 2U;
    }
  }
  while_400_break: /* CIL Label */ ;
  }
  if (utfmax > 0) {
    {
    *utf = (unsigned char )*s;
    retval ++;
    }
  }
  return (retval);
}
}
static unsigned int rh_string(int id , struct usb_hcd *hcd , u8 *data , unsigned int len ) 
{ char buf[100] ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  unsigned int tmp ;
  struct new_utsname *tmp___0 ;
  struct new_utsname *tmp___1 ;
  unsigned int tmp___2 ;
  size_t tmp___3 ;

  {
  if (id == 0) {
    {
    buf[0] = (char)4;
    buf[1] = (char)3;
    buf[2] = (char)9;
    buf[3] = (char)4;
    __min1 = len;
    __min2 = 4U;
    }
    if (__min1 < __min2) {
      {
      tmp = __min1;
      }
    } else {
      {
      tmp = __min2;
      }
    }
    {
    len = tmp;
    __memcpy((void *)data, (void const   *)(buf), len);
    }
    return (len);
  } else {
    if (id == 1) {
      {
      strlcpy(buf, hcd->self.bus_name, (unsigned int )sizeof(buf));
      }
    } else {
      if (id == 2) {
        {
        strlcpy(buf, hcd->product_desc, (unsigned int )sizeof(buf));
        }
      } else {
        if (id == 3) {
          {
          tmp___0 = init_utsname();
          tmp___1 = init_utsname();
          snprintf(buf, (unsigned int )sizeof(buf), "%s %s %s", tmp___1->sysname,
                   tmp___0->release, (hcd->driver)->description);
          }
        }
      }
    }
  }
  if ((int )len == 2) {
    goto switch_401_2;
  } else {
    if ((int )len == 1) {
      goto switch_401_1;
    } else {
      if ((int )len == 0) {
        goto switch_401_0;
      } else {
        {
        goto switch_401_default;
        if (0) {
          switch_401_default: /* CIL Label */ 
          {
          tmp___2 = ascii2utf(buf, data + 2, (int )(len - 2U));
          len = 2U + tmp___2;
          }
          switch_401_2: /* CIL Label */ 
          {
          *(data + 1) = (unsigned char)3;
          }
          switch_401_1: /* CIL Label */ 
          {
          tmp___3 = strlen((char const   *)(buf));
          *(data + 0) = (unsigned char )(2U * (tmp___3 + 1U));
          }
          switch_401_0: /* CIL Label */ 
          {

          }
        } else {
          switch_401_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return (len);
}
}
static int rh_call_control(struct usb_hcd *hcd , struct urb *urb ) 
{ struct usb_ctrlrequest *cmd ;
  u16 typeReq ;
  u16 wValue ;
  u16 wIndex ;
  u16 wLength ;
  u8 *ubuf ;
  u8 tbuf[sizeof(struct usb_hub_descriptor )]  __attribute__((__aligned__(4))) ;
  u8 const   *bufp ;
  unsigned int len ;
  int status ;
  u8 patch_wakeup ;
  u8 patch_protocol ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
  ubuf = (u8 *)urb->transfer_buffer;
  bufp = (u8 const   *)(tbuf);
  len = 0U;
  patch_wakeup = (u8 )0;
  patch_protocol = (u8 )0;
  }
  {
  while (1) {
    while_402_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_402_break;
  }
  while_402_break: /* CIL Label */ ;
  }
  {
  _spin_lock_irq(& hcd_root_hub_lock);
  status = usb_hcd_link_urb_to_ep(hcd, urb);
  }
  {
  while (1) {
    while_403_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_root_hub_lock.raw_lock);
    }
    {
    while (1) {
      while_404_continue: /* CIL Label */ ;
      {
      while (1) {
        while_405_continue: /* CIL Label */ ;
        goto while_405_break;
      }
      while_405_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_404_break;
    }
    while_404_break: /* CIL Label */ ;
    }
    goto while_403_break;
  }
  while_403_break: /* CIL Label */ ;
  }
  if (status) {
    return (status);
  }
  {
  urb->hcpriv = (void *)hcd;
  cmd = (struct usb_ctrlrequest *)urb->setup_packet;
  typeReq = (unsigned short )(((int )cmd->bRequestType << 8) | (int )cmd->bRequest);
  wValue = cmd->wValue;
  wIndex = cmd->wIndex;
  wLength = cmd->wLength;
  }
  if ((u32 )wLength > urb->transfer_buffer_length) {
    goto error;
  }
  {
  urb->actual_length = 0U;
  }
  if ((int )typeReq == 128 << 8) {
    goto switch_406_exp_21;
  } else {
    if ((int )typeReq == 1) {
      goto switch_406_1;
    } else {
      if ((int )typeReq == 3) {
        goto switch_406_3;
      } else {
        if ((int )typeReq == ((128 << 8) | 8)) {
          goto switch_406_exp_22;
        } else {
          if ((int )typeReq == 9) {
            goto switch_406_9;
          } else {
            if ((int )typeReq == ((128 << 8) | 6)) {
              goto switch_406_exp_23;
            } else {
              if ((int )typeReq == ((128 << 8) | 10)) {
                goto switch_406_exp_27;
              } else {
                if ((int )typeReq == 11) {
                  goto switch_406_11;
                } else {
                  if ((int )typeReq == 5) {
                    goto switch_406_5;
                  } else {
                    if ((int )typeReq == 129 << 8) {
                      goto switch_406_exp_28;
                    } else {
                      if ((int )typeReq == ((1 << 8) | 1)) {
                        goto switch_406_exp_29;
                      } else {
                        if ((int )typeReq == ((1 << 8) | 3)) {
                          goto switch_406_exp_29;
                        } else {
                          {
                          goto switch_406_default;
                          if (0) {
                            switch_406_exp_21: /* CIL Label */ 
                            {
                            tmp = device_may_wakeup(& (hcd->self.root_hub)->dev);
                            tbuf[0] = (unsigned char )((tmp << 1) | 1);
                            tbuf[1] = (unsigned char)0;
                            len = 2U;
                            }
                            goto switch_406_break;
                            switch_406_1: /* CIL Label */ 
                            if ((int )wValue == 1) {
                              {
                              device_set_wakeup_enable(& (hcd->self.root_hub)->dev,
                                                       0);
                              }
                            } else {
                              goto error;
                            }
                            goto switch_406_break;
                            switch_406_3: /* CIL Label */ 
                            {
                            tmp___0 = device_can_wakeup(& (hcd->self.root_hub)->dev);
                            }
                            if (tmp___0) {
                              if ((int )wValue == 1) {
                                {
                                device_set_wakeup_enable(& (hcd->self.root_hub)->dev,
                                                         1);
                                }
                              } else {
                                goto error;
                              }
                            } else {
                              goto error;
                            }
                            goto switch_406_break;
                            switch_406_exp_22: /* CIL Label */ 
                            {
                            tbuf[0] = (unsigned char)1;
                            len = 1U;
                            }
                            switch_406_9: /* CIL Label */ 
                            goto switch_406_break;
                            switch_406_exp_23: /* CIL Label */ 
                            if (((int )wValue & 65280) == 1 << 8) {
                              goto switch_407_exp_24;
                            } else {
                              if (((int )wValue & 65280) == 2 << 8) {
                                goto switch_407_exp_25;
                              } else {
                                if (((int )wValue & 65280) == 3 << 8) {
                                  goto switch_407_exp_26;
                                } else {
                                  {
                                  goto switch_407_default;
                                  if (0) {
                                    switch_407_exp_24: /* CIL Label */ 
                                    if ((hcd->driver)->flags & 32) {
                                      {
                                      bufp = usb2_rh_dev_descriptor;
                                      }
                                    } else {
                                      if ((hcd->driver)->flags & 16) {
                                        {
                                        bufp = usb11_rh_dev_descriptor;
                                        }
                                      } else {
                                        goto error;
                                      }
                                    }
                                    {
                                    len = 18U;
                                    }
                                    if (hcd->has_tt) {
                                      {
                                      patch_protocol = (unsigned char)1;
                                      }
                                    }
                                    goto switch_407_break;
                                    switch_407_exp_25: /* CIL Label */ 
                                    if ((hcd->driver)->flags & 32) {
                                      {
                                      bufp = hs_rh_config_descriptor;
                                      len = (unsigned int )sizeof(hs_rh_config_descriptor);
                                      }
                                    } else {
                                      {
                                      bufp = fs_rh_config_descriptor;
                                      len = (unsigned int )sizeof(fs_rh_config_descriptor);
                                      }
                                    }
                                    {
                                    tmp___1 = device_can_wakeup(& (hcd->self.root_hub)->dev);
                                    }
                                    if (tmp___1) {
                                      {
                                      patch_wakeup = (unsigned char)1;
                                      }
                                    }
                                    goto switch_407_break;
                                    switch_407_exp_26: /* CIL Label */ 
                                    if (((int )wValue & 255) < 4) {
                                      {
                                      urb->actual_length = rh_string((int )wValue & 255,
                                                                     hcd, ubuf, (unsigned int )wLength);
                                      }
                                    } else {
                                      goto error;
                                    }
                                    goto switch_407_break;
                                    switch_407_default: /* CIL Label */ 
                                    {

                                    }
                                    goto error;
                                  } else {
                                    switch_407_break: /* CIL Label */ ;
                                  }
                                  }
                                }
                              }
                            }
                            goto switch_406_break;
                            switch_406_exp_27: /* CIL Label */ 
                            {
                            tbuf[0] = (unsigned char)0;
                            len = 1U;
                            }
                            switch_406_11: /* CIL Label */ 
                            goto switch_406_break;
                            switch_406_5: /* CIL Label */ 
                            {

                            }
                            goto switch_406_break;
                            switch_406_exp_28: /* CIL Label */ 
                            {
                            tbuf[0] = (unsigned char)0;
                            tbuf[1] = (unsigned char)0;
                            len = 2U;
                            }
                            switch_406_exp_29: /* CIL Label */ 
                            switch_406_exp_30: /* CIL Label */ 
                            {

                            }
                            goto switch_406_break;
                            switch_406_default: /* CIL Label */ 
                            {

                            }
                            if ((int )typeReq == 40960) {
                              goto switch_408_40960;
                            } else {
                              if ((int )typeReq == 41728) {
                                goto switch_408_40960;
                              } else {
                                if ((int )typeReq == 40966) {
                                  goto switch_408_40966;
                                } else {
                                  if (0) {
                                    switch_408_40960: /* CIL Label */ 
                                    switch_408_41728: /* CIL Label */ 
                                    {
                                    len = 4U;
                                    }
                                    goto switch_408_break;
                                    switch_408_40966: /* CIL Label */ 
                                    {
                                    len = (unsigned int )sizeof(struct usb_hub_descriptor );
                                    }
                                    goto switch_408_break;
                                  } else {
                                    switch_408_break: /* CIL Label */ ;
                                  }
                                }
                              }
                            }
                            {
                            status = (*((hcd->driver)->hub_control))(hcd, typeReq,
                                                                     wValue, wIndex,
                                                                     (char *)(tbuf),
                                                                     wLength);
                            }
                            goto switch_406_break;
                            error: 
                            {
                            status = -32;
                            }
                          } else {
                            switch_406_break: /* CIL Label */ ;
                          }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (status) {
    {
    len = 0U;
    }
    if (status != -32) {

    }
  }
  if (len) {
    if (urb->transfer_buffer_length < len) {
      {
      len = urb->transfer_buffer_length;
      }
    }
    {
    urb->actual_length = len;
    __memcpy((void *)ubuf, (void const   *)bufp, len);
    }
    if (patch_wakeup) {
      if (len > (unsigned int )(& ((struct usb_config_descriptor *)0)->bmAttributes)) {
        {
        ((struct usb_config_descriptor *)ubuf)->bmAttributes = (unsigned char )((int )((struct usb_config_descriptor *)ubuf)->bmAttributes | (1 << 5));
        }
      }
    }
    if (patch_protocol) {
      if (len > (unsigned int )(& ((struct usb_device_descriptor *)0)->bDeviceProtocol)) {
        {
        ((struct usb_device_descriptor *)ubuf)->bDeviceProtocol = (unsigned char)1;
        }
      }
    }
  }
  {
  _spin_lock_irq(& hcd_root_hub_lock);
  usb_hcd_unlink_urb_from_ep(hcd, urb);
  }
  {
  while (1) {
    while_409_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_root_hub_lock.raw_lock);
    }
    goto while_409_break;
  }
  while_409_break: /* CIL Label */ ;
  }
  {
  usb_hcd_giveback_urb(hcd, urb, status);
  _spin_lock(& hcd_root_hub_lock);
  }
  {
  while (1) {
    while_410_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_root_hub_lock.raw_lock);
    }
    {
    while (1) {
      while_411_continue: /* CIL Label */ ;
      {
      while (1) {
        while_412_continue: /* CIL Label */ ;
        goto while_412_break;
      }
      while_412_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_411_break;
    }
    while_411_break: /* CIL Label */ ;
    }
    goto while_410_break;
  }
  while_410_break: /* CIL Label */ ;
  }
  return (0);
}
}
void usb_hcd_poll_rh_status(struct usb_hcd *hcd ) 
{ struct urb *urb ;
  int length ;
  unsigned long flags ;
  char buffer[4] ;
  long tmp ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
  tmp = __builtin_expect((long )(! (! (! hcd->rh_registered))), 0L);
  }
  if (tmp) {
    return;
  }
  if (! hcd->uses_new_polling) {
    if (! hcd->status_urb) {
      return;
    }
  }
  {
  length = (*((hcd->driver)->hub_status_data))(hcd, buffer);
  }
  if (length > 0) {
    {
    while (1) {
      while_413_continue: /* CIL Label */ ;
      {
      flags = _spin_lock_irqsave(& hcd_root_hub_lock);
      }
      goto while_413_break;
    }
    while_413_break: /* CIL Label */ ;
    }
    {
    urb = hcd->status_urb;
    }
    if (urb) {
      {
      hcd->poll_pending = 0U;
      hcd->status_urb = (struct urb *)((void *)0);
      urb->actual_length = (unsigned int )length;
      __memcpy(urb->transfer_buffer, (void const   *)(buffer), (unsigned int )length);
      usb_hcd_unlink_urb_from_ep(hcd, urb);
      }
      {
      while (1) {
        while_414_continue: /* CIL Label */ ;
        {
        __raw_spin_unlock(& hcd_root_hub_lock.raw_lock);
        }
        goto while_414_break;
      }
      while_414_break: /* CIL Label */ ;
      }
      {
      usb_hcd_giveback_urb(hcd, urb, 0);
      _spin_lock(& hcd_root_hub_lock);
      }
    } else {
      {
      length = 0;
      hcd->poll_pending = 1U;
      }
    }
    {
    while (1) {
      while_415_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& hcd_root_hub_lock, flags);
      }
      goto while_415_break;
    }
    while_415_break: /* CIL Label */ ;
    }
  }
  if (hcd->uses_new_polling) {
    {
    tmp___1 = hcd->poll_rh;
    }
  } else {
    if (length == 0) {
      if ((unsigned long )hcd->status_urb != (unsigned long )((void *)0)) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
    {
    tmp___1 = (unsigned int )tmp___0;
    }
  }
  if (tmp___1) {
    {
    mod_timer(& hcd->rh_timer, (unsigned long )((jiffies / (unsigned long volatile   )250 + (unsigned long volatile   )1) * (unsigned long volatile   )250));
    }
  }
  return;
}
}
static char const   __kstrtab_usb_hcd_poll_rh_status[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'p',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'_',      (char const   )'r',      (char const   )'h',      (char const   )'_', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'t', 
        (char const   )'u',      (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_poll_rh_status  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_poll_rh_status), __kstrtab_usb_hcd_poll_rh_status};
static void rh_timer_func(unsigned long _hcd ) 
{ 

  {
  {
  usb_hcd_poll_rh_status((struct usb_hcd *)_hcd);
  }
  return;
}
}
static int rh_queue_status(struct usb_hcd *hcd , struct urb *urb ) 
{ int retval ;
  unsigned long flags ;
  unsigned int len ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  len = (unsigned int )(1 + (urb->dev)->maxchild / 8);
  }
  {
  while (1) {
    while_416_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& hcd_root_hub_lock);
    }
    goto while_416_break;
  }
  while_416_break: /* CIL Label */ ;
  }
  if (hcd->status_urb) {
    {
    retval = -22;
    }
    goto done;
  } else {
    if (urb->transfer_buffer_length < len) {
      {
      retval = -22;
      }
      goto done;
    }
  }
  {
  retval = usb_hcd_link_urb_to_ep(hcd, urb);
  }
  if (retval) {
    goto done;
  }
  {
  hcd->status_urb = urb;
  urb->hcpriv = (void *)hcd;
  }
  if (! hcd->uses_new_polling) {
    {
    mod_timer(& hcd->rh_timer, (unsigned long )((jiffies / (unsigned long volatile   )250 + (unsigned long volatile   )1) * (unsigned long volatile   )250));
    }
  } else {
    if (hcd->poll_pending) {
      {
      mod_timer(& hcd->rh_timer, (unsigned long )jiffies);
      }
    }
  }
  {
  retval = 0;
  }
  done: 
  {
  while (1) {
    while_417_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& hcd_root_hub_lock, flags);
    }
    goto while_417_break;
  }
  while_417_break: /* CIL Label */ ;
  }
  return (retval);
}
}
static int rh_urb_enqueue(struct usb_hcd *hcd , struct urb *urb ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp___0 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
  }
  if (tmp___0) {
    {
    tmp = rh_queue_status(hcd, urb);
    }
    return (tmp);
  }
  {
  tmp___2 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
  }
  if (tmp___2) {
    {
    tmp___1 = rh_call_control(hcd, urb);
    }
    return (tmp___1);
  }
  return (-22);
}
}
static int usb_rh_urb_dequeue(struct usb_hcd *hcd , struct urb *urb , int status ) 
{ unsigned long flags ;
  int rc ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int tmp ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_418_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& hcd_root_hub_lock);
    }
    goto while_418_break;
  }
  while_418_break: /* CIL Label */ ;
  }
  {
  rc = usb_hcd_check_unlink_urb(hcd, urb, status);
  }
  if (rc) {
    goto done;
  }
  {
  tmp = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
  }
  if (! (tmp == 0)) {
    if (! hcd->uses_new_polling) {
      {
      del_timer(& hcd->rh_timer);
      }
    }
    if ((unsigned long )urb == (unsigned long )hcd->status_urb) {
      {
      hcd->status_urb = (struct urb *)((void *)0);
      usb_hcd_unlink_urb_from_ep(hcd, urb);
      }
      {
      while (1) {
        while_419_continue: /* CIL Label */ ;
        {
        __raw_spin_unlock(& hcd_root_hub_lock.raw_lock);
        }
        goto while_419_break;
      }
      while_419_break: /* CIL Label */ ;
      }
      {
      usb_hcd_giveback_urb(hcd, urb, status);
      _spin_lock(& hcd_root_hub_lock);
      }
    }
  }
  done: 
  {
  while (1) {
    while_420_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& hcd_root_hub_lock, flags);
    }
    goto while_420_break;
  }
  while_420_break: /* CIL Label */ ;
  }
  return (rc);
}
}
static ssize_t usb_host_authorized_default_show(struct device *dev , struct device_attribute *attr ,
                                                char *buf ) 
{ struct usb_device *rh_usb_dev ;
  struct device  const  *__mptr ;
  struct usb_bus *usb_bus ;
  struct usb_hcd *usb_hcd ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  rh_usb_dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  usb_bus = rh_usb_dev->bus;
  }
  if ((unsigned long )usb_bus == (unsigned long )((void *)0)) {
    return (-19);
  }
  {
  usb_hcd = bus_to_hcd(usb_bus);
  tmp = snprintf(buf, (unsigned int )(1UL << 12), "%u\n", usb_hcd->authorized_default);
  }
  return (tmp);
}
}
static ssize_t usb_host_authorized_default_store(struct device *dev , struct device_attribute *attr ,
                                                 char const   *buf , size_t size ) 
{ ssize_t result ;
  unsigned int val ;
  struct usb_device *rh_usb_dev ;
  struct device  const  *__mptr ;
  struct usb_bus *usb_bus ;
  struct usb_hcd *usb_hcd ;

  {
  {
  __mptr = (struct device  const  *)dev;
  rh_usb_dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  usb_bus = rh_usb_dev->bus;
  }
  if ((unsigned long )usb_bus == (unsigned long )((void *)0)) {
    return (-19);
  }
  {
  usb_hcd = bus_to_hcd(usb_bus);
  result = sscanf(buf, "%u\n", & val);
  }
  if (result == 1) {
    if (val) {
      {
      usb_hcd->authorized_default = 1U;
      }
    } else {
      {
      usb_hcd->authorized_default = 0U;
      }
    }
    {
    result = (int )size;
    }
  } else {
    {
    result = -22;
    }
  }
  return (result);
}
}
static struct device_attribute dev_attr_authorized_default  =    {{"authorized_default", (struct module *)0, (mode_t )420}, & usb_host_authorized_default_show,
    & usb_host_authorized_default_store};
static struct attribute *usb_bus_attrs[2]  = {      & dev_attr_authorized_default.attr,      (struct attribute *)((void *)0)};
static struct attribute_group usb_bus_attr_group  =    {(char const   *)((void *)0), (mode_t (*)(struct kobject * , struct attribute * ,
                                             int  ))0, usb_bus_attrs};
static struct class *usb_host_class  ;
static struct lock_class_key __key___10  ;
int usb_host_init(void) 
{ int retval ;
  struct class *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  retval = 0;
  tmp = __class_create((struct module *)0, "usb_host", & __key___10);
  usb_host_class = tmp;
  tmp___1 = IS_ERR((void const   *)usb_host_class);
  }
  if (tmp___1) {
    {
    tmp___0 = PTR_ERR((void const   *)usb_host_class);
    retval = (int )tmp___0;
    }
  }
  return (retval);
}
}
void usb_host_cleanup(void) 
{ 

  {
  {
  class_destroy(usb_host_class);
  }
  return;
}
}
static void usb_bus_init(struct usb_bus *bus ) 
{ 

  {
  {
  __constant_c_and_count_memset((void *)(& bus->devmap), 0UL, (unsigned int )sizeof(struct usb_devmap ));
  bus->devnum_next = 1;
  bus->root_hub = (struct usb_device *)((void *)0);
  bus->busnum = -1;
  bus->bandwidth_allocated = 0;
  bus->bandwidth_int_reqs = 0;
  bus->bandwidth_isoc_reqs = 0;
  INIT_LIST_HEAD(& bus->bus_list);
  }
  return;
}
}
static int usb_register_bus(struct usb_bus *bus ) 
{ int result ;
  int busnum ;
  unsigned long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
  result = -7;
  mutex_lock(& usb_bus_list_lock);
  tmp = find_next_zero_bit((unsigned long const   *)(busmap.busmap), 64UL, 1UL);
  busnum = (int )tmp;
  }
  if (busnum >= 64) {
    {
    printk("<3>%s: too many buses\n", usbcore_name);
    }
    goto error_find_busnum;
  }
  {
  set_bit((unsigned int )busnum, (unsigned long volatile   *)(busmap.busmap));
  bus->busnum = busnum;
  bus->dev = device_create(usb_host_class, bus->controller, 0U, (void *)bus, "usb_host%d",
                           busnum);
  tmp___0 = PTR_ERR((void const   *)bus->dev);
  result = (int )tmp___0;
  tmp___1 = IS_ERR((void const   *)bus->dev);
  }
  if (tmp___1) {
    goto error_create_class_dev;
  }
  {
  list_add(& bus->bus_list, & usb_bus_list);
  mutex_unlock(& usb_bus_list_lock);
  usb_notify_add_bus(bus);
  tmp___2 = dev_name((struct device  const  *)bus->controller);
  tmp___3 = dev_driver_string((struct device  const  *)bus->controller);
  printk("<6>%s %s: new USB bus registered, assigned bus number %d\n", tmp___3, tmp___2,
         bus->busnum);
  }
  return (0);
  error_create_class_dev: 
  {
  clear_bit(busnum, (unsigned long volatile   *)(busmap.busmap));
  }
  error_find_busnum: 
  {
  mutex_unlock(& usb_bus_list_lock);
  }
  return (result);
}
}
static void usb_deregister_bus(struct usb_bus *bus ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  tmp = dev_name((struct device  const  *)bus->controller);
  tmp___0 = dev_driver_string((struct device  const  *)bus->controller);
  printk("<6>%s %s: USB bus %d deregistered\n", tmp___0, tmp, bus->busnum);
  mutex_lock(& usb_bus_list_lock);
  list_del(& bus->bus_list);
  mutex_unlock(& usb_bus_list_lock);
  usb_notify_remove_bus(bus);
  clear_bit(bus->busnum, (unsigned long volatile   *)(busmap.busmap));
  device_unregister(bus->dev);
  }
  return;
}
}
static int register_root_hub(struct usb_hcd *hcd ) 
{ struct device *parent_dev ;
  struct usb_device *usb_dev ;
  int devnum ;
  int retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
  parent_dev = hcd->self.controller;
  usb_dev = hcd->self.root_hub;
  devnum = 1;
  usb_dev->devnum = devnum;
  (usb_dev->bus)->devnum_next = devnum + 1;
  __constant_c_and_count_memset((void *)(& (usb_dev->bus)->devmap.devicemap), 0UL,
                                (unsigned int )sizeof((usb_dev->bus)->devmap.devicemap));
  set_bit((unsigned int )devnum, (unsigned long volatile   *)((usb_dev->bus)->devmap.devicemap));
  usb_set_device_state(usb_dev, (enum usb_device_state )6);
  mutex_lock(& usb_bus_list_lock);
  usb_dev->ep0.desc.wMaxPacketSize = (unsigned short)64;
  retval = usb_get_device_descriptor(usb_dev, 18U);
  }
  if ((unsigned long )retval != sizeof(usb_dev->descriptor)) {
    {
    mutex_unlock(& usb_bus_list_lock);
    }
    if (retval < 0) {
      {
      tmp___2 = retval;
      }
    } else {
      {
      tmp___2 = -90;
      }
    }
    return (tmp___2);
  }
  {
  retval = usb_new_device(usb_dev);
  }
  if (retval) {
    {
    tmp___3 = dev_name((struct device  const  *)(& usb_dev->dev));
    tmp___4 = dev_name((struct device  const  *)parent_dev);
    tmp___5 = dev_driver_string((struct device  const  *)parent_dev);
    printk("<3>%s %s: can\'t register root hub for %s, %d\n", tmp___5, tmp___4, tmp___3,
           retval);
    }
  }
  {
  mutex_unlock(& usb_bus_list_lock);
  }
  if (retval == 0) {
    {
    _spin_lock_irq(& hcd_root_hub_lock);
    hcd->rh_registered = 1U;
    }
    {
    while (1) {
      while_421_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& hcd_root_hub_lock.raw_lock);
      }
      {
      while (1) {
        while_422_continue: /* CIL Label */ ;
        {
        while (1) {
          while_423_continue: /* CIL Label */ ;
          goto while_423_break;
        }
        while_423_break: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_422_break;
      }
      while_422_break: /* CIL Label */ ;
      }
      goto while_421_break;
    }
    while_421_break: /* CIL Label */ ;
    }
    if (hcd->state == 0) {
      {
      usb_hc_died(hcd);
      }
    }
  }
  return (retval);
}
}
long usb_calc_bus_time(int speed , int is_input , int isoc , int bytecount ) 
{ unsigned long tmp ;
  long tmp___0 ;

  {
  if (speed == 1) {
    goto switch_424_1;
  } else {
    if (speed == 2) {
      goto switch_424_2;
    } else {
      if (speed == 3) {
        goto switch_424_3;
      } else {
        {
        goto switch_424_default;
        if (0) {
          switch_424_1: /* CIL Label */ 
          if (is_input) {
            {
            tmp = (unsigned long )((67667L * (31L + 10L * (long )((56 * bytecount) / 6))) / 1000L);
            }
            return ((long )(65726UL + tmp));
          } else {
            {
            tmp = (unsigned long )((66700L * (31L + 10L * (long )((56 * bytecount) / 6))) / 1000L);
            }
            return ((long )(65773UL + tmp));
          }
          switch_424_2: /* CIL Label */ 
          if (isoc) {
            {
            tmp = (unsigned long )((8354L * (31L + 10L * (long )((56 * bytecount) / 6))) / 1000L);
            }
            if (is_input) {
              {
              tmp___0 = 7268L;
              }
            } else {
              {
              tmp___0 = 6265L;
              }
            }
            return ((long )((unsigned long )(tmp___0 + 1000L) + tmp));
          } else {
            {
            tmp = (unsigned long )((8354L * (31L + 10L * (long )((56 * bytecount) / 6))) / 1000L);
            }
            return ((long )(10107UL + tmp));
          }
          switch_424_3: /* CIL Label */ 
          if (isoc) {
            {
            tmp = (633232UL + 2083UL * (unsigned long )(3 + (56 * bytecount) / 6)) / 1000UL + 5UL;
            }
          } else {
            {
            tmp = (916520UL + 2083UL * (unsigned long )(3 + (56 * bytecount) / 6)) / 1000UL + 5UL;
            }
          }
          return ((long )tmp);
          switch_424_default: /* CIL Label */ 
          {

          }
          return (-1L);
        } else {
          switch_424_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
static char const   __kstrtab_usb_calc_bus_time[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'c',      (char const   )'a',      (char const   )'l',      (char const   )'c', 
        (char const   )'_',      (char const   )'b',      (char const   )'u',      (char const   )'s', 
        (char const   )'_',      (char const   )'t',      (char const   )'i',      (char const   )'m', 
        (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_calc_bus_time  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_calc_bus_time), __kstrtab_usb_calc_bus_time};
int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd , struct urb *urb ) 
{ int rc ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  rc = 0;
  _spin_lock(& hcd_urb_list_lock);
  tmp = __builtin_expect((long )(! (! urb->reject.counter)), 0L);
  }
  if (tmp) {
    {
    rc = -1;
    }
    goto done;
  }
  {
  tmp___0 = __builtin_expect((long )(! (! (! (urb->ep)->enabled))), 0L);
  }
  if (tmp___0) {
    {
    rc = -2;
    }
    goto done;
  }
  {
  tmp___1 = __builtin_expect((long )(! (! (! (urb->dev)->can_submit))), 0L);
  }
  if (tmp___1) {
    {
    rc = -113;
    }
    goto done;
  }
  if (hcd->state == 1) {
    goto switch_425_1;
  } else {
    if (hcd->state == 132) {
      goto switch_425_1;
    } else {
      {
      goto switch_425_default;
      if (0) {
        switch_425_1: /* CIL Label */ 
        switch_425_132: /* CIL Label */ 
        {
        urb->unlinked = 0;
        list_add_tail(& urb->urb_list, & (urb->ep)->urb_list);
        }
        goto switch_425_break;
        switch_425_default: /* CIL Label */ 
        {
        rc = -108;
        }
        goto done;
      } else {
        switch_425_break: /* CIL Label */ ;
      }
      }
    }
  }
  done: 
  {
  while (1) {
    while_426_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_urb_list_lock.raw_lock);
    }
    goto while_426_break;
  }
  while_426_break: /* CIL Label */ ;
  }
  return (rc);
}
}
static char const   __kstrtab_usb_hcd_link_urb_to_ep[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'k', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'_',      (char const   )'t',      (char const   )'o',      (char const   )'_', 
        (char const   )'e',      (char const   )'p',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_link_urb_to_ep  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_link_urb_to_ep), __kstrtab_usb_hcd_link_urb_to_ep};
int usb_hcd_check_unlink_urb(struct usb_hcd *hcd ,
                             struct urb *urb , int status ) 
{ struct list_head *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = (urb->ep)->urb_list.next;
  }
  {
  while (1) {
    while_427_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)tmp->next);
    }
    if (! ((unsigned long )tmp != (unsigned long )(& (urb->ep)->urb_list))) {
      goto while_427_break;
    }
    if ((unsigned long )tmp == (unsigned long )(& urb->urb_list)) {
      goto while_427_break;
    }
    {
    tmp = tmp->next;
    }
  }
  while_427_break: /* CIL Label */ ;
  }
  if ((unsigned long )tmp != (unsigned long )(& urb->urb_list)) {
    return (-43);
  }
  if (urb->unlinked) {
    return (-16);
  }
  {
  urb->unlinked = status;
  tmp___2 = constant_test_bit(2U, (unsigned long const volatile   *)(& hcd->flags));
  }
  if (! tmp___2) {
    {
    tmp___4 = is_root_hub(urb->dev);
    }
    if (! tmp___4) {
      {
      tmp___0 = dev_name((struct device  const  *)hcd->self.controller);
      tmp___1 = dev_driver_string((struct device  const  *)hcd->self.controller);
      printk("<4>%s %s: Unlink after no-IRQ?  Controller is probably using the wrong IRQ.\n",
             tmp___1, tmp___0);
      set_bit(2U, (unsigned long volatile   *)(& hcd->flags));
      }
    }
  }
  return (0);
}
}
static char const   __kstrtab_usb_hcd_check_unlink_urb[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'c', 
        (char const   )'k',      (char const   )'_',      (char const   )'u',      (char const   )'n', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'k', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_check_unlink_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_check_unlink_urb), __kstrtab_usb_hcd_check_unlink_urb};
void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd ,
                                struct urb *urb ) 
{ 

  {
  {
  _spin_lock(& hcd_urb_list_lock);
  list_del_init(& urb->urb_list);
  }
  {
  while (1) {
    while_428_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_urb_list_lock.raw_lock);
    }
    goto while_428_break;
  }
  while_428_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_hcd_unlink_urb_from_ep[27]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'k',      (char const   )'_',      (char const   )'u', 
        (char const   )'r',      (char const   )'b',      (char const   )'_',      (char const   )'f', 
        (char const   )'r',      (char const   )'o',      (char const   )'m',      (char const   )'_', 
        (char const   )'e',      (char const   )'p',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_unlink_urb_from_ep  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_unlink_urb_from_ep), __kstrtab_usb_hcd_unlink_urb_from_ep};
static int hcd_alloc_coherent(struct usb_bus *bus ,
                              gfp_t mem_flags , dma_addr_t *dma_handle , void **vaddr_handle ,
                              size_t size , enum dma_data_direction dir ) 
{ unsigned char *vaddr ;
  void *tmp ;
  void *__gu_p ;

  {
  {
  tmp = hcd_buffer_alloc(bus, (unsigned int )((unsigned long )size + sizeof(vaddr)),
                         mem_flags, dma_handle);
  vaddr = (unsigned char *)tmp;
  }
  if (! vaddr) {
    return (-12);
  }
  {
  __gu_p = (void *)((unsigned long *)(vaddr + size));
  }
  if ((int )sizeof(*((unsigned long *)(vaddr + size))) == 1) {
    goto switch_429_1;
  } else {
    if ((int )sizeof(*((unsigned long *)(vaddr + size))) == 2) {
      goto switch_429_2;
    } else {
      if ((int )sizeof(*((unsigned long *)(vaddr + size))) == 4) {
        goto switch_429_4;
      } else {
        if ((int )sizeof(*((unsigned long *)(vaddr + size))) == 8) {
          goto switch_429_8;
        } else {
          {
          goto switch_429_default;
          if (0) {
            switch_429_1: /* CIL Label */ 
            {
            *((u8 *)__gu_p) = (unsigned char )((unsigned long )*vaddr_handle);
            }
            goto switch_429_break;
            switch_429_2: /* CIL Label */ 
            {
            put_unaligned_le16((unsigned short )((unsigned long )*vaddr_handle), __gu_p);
            }
            goto switch_429_break;
            switch_429_4: /* CIL Label */ 
            {
            put_unaligned_le32((unsigned int )((unsigned long )*vaddr_handle), __gu_p);
            }
            goto switch_429_break;
            switch_429_8: /* CIL Label */ 
            {
            put_unaligned_le64((unsigned long long )((unsigned long )*vaddr_handle),
                               __gu_p);
            }
            goto switch_429_break;
            switch_429_default: /* CIL Label */ 
            {
            __bad_unaligned_access_size();
            }
            goto switch_429_break;
          } else {
            switch_429_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if ((unsigned int )dir == 1U) {
    {
    __memcpy((void *)vaddr, (void const   *)*vaddr_handle, size);
    }
  }
  {
  *vaddr_handle = (void *)vaddr;
  }
  return (0);
}
}
extern int ( /* missing proto */  __builtin_choose_expr)() ;
static void hcd_free_coherent(struct usb_bus *bus , dma_addr_t *dma_handle , void **vaddr_handle ,
                              size_t size , enum dma_data_direction dir ) 
{ unsigned char *vaddr ;
  void tmp ;
  u64 tmp___0 ;
  u32 tmp___1 ;
  u16 tmp___2 ;

  {
  {
  vaddr = (unsigned char *)*vaddr_handle;
  tmp___0 = get_unaligned_le64((void const   *)((unsigned long *)(vaddr + size)));
  vaddr = (unsigned char *)((void *)((unsigned long )tmp___0));
  }
  if ((unsigned int )dir == 2U) {
    {
    __memcpy((void *)vaddr, (void const   *)*vaddr_handle, size);
    }
  }
  {
  hcd_buffer_free(bus, (unsigned int )((unsigned long )size + sizeof(vaddr)), *vaddr_handle,
                  *dma_handle);
  *vaddr_handle = (void *)vaddr;
  *dma_handle = 0U;
  }
  return;
}
}
static int map_urb_for_dma(struct usb_hcd *hcd , struct urb *urb , gfp_t mem_flags ) 
{ enum dma_data_direction dir ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  ret = 0;
  tmp = is_root_hub(urb->dev);
  }
  if (tmp) {
    return (0);
  }
  {
  tmp___0 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
  }
  if (tmp___0) {
    if (! (urb->transfer_flags & 8U)) {
      if (hcd->self.uses_dma) {
        {
        urb->setup_dma = dma_map_single(hcd->self.controller, (void *)urb->setup_packet,
                                        (unsigned int )sizeof(struct usb_ctrlrequest ),
                                        (enum dma_data_direction )1);
        }
      } else {
        if ((hcd->driver)->flags & 2) {
          {
          ret = hcd_alloc_coherent((urb->dev)->bus, mem_flags, & urb->setup_dma, (void **)(& urb->setup_packet),
                                   (unsigned int )sizeof(struct usb_ctrlrequest ),
                                   (enum dma_data_direction )1);
          }
        }
      }
    }
  }
  {
  tmp___2 = usb_urb_dir_in(urb);
  }
  if (tmp___2) {
    {
    dir = (enum dma_data_direction )2;
    }
  } else {
    {
    dir = (enum dma_data_direction )1;
    }
  }
  if (ret == 0) {
    if (urb->transfer_buffer_length != 0U) {
      if (! (urb->transfer_flags & 4U)) {
        if (hcd->self.uses_dma) {
          {
          urb->transfer_dma = dma_map_single(hcd->self.controller, urb->transfer_buffer,
                                             urb->transfer_buffer_length, dir);
          }
        } else {
          if ((hcd->driver)->flags & 2) {
            {
            ret = hcd_alloc_coherent((urb->dev)->bus, mem_flags, & urb->transfer_dma,
                                     & urb->transfer_buffer, urb->transfer_buffer_length,
                                     dir);
            }
            if (ret) {
              {
              tmp___3 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
              }
              if (tmp___3) {
                if (! (urb->transfer_flags & 8U)) {
                  {
                  hcd_free_coherent((urb->dev)->bus, & urb->setup_dma, (void **)(& urb->setup_packet),
                                    (unsigned int )sizeof(struct usb_ctrlrequest ),
                                    (enum dma_data_direction )1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (ret);
}
}
static void unmap_urb_for_dma(struct usb_hcd *hcd , struct urb *urb ) 
{ enum dma_data_direction dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = is_root_hub(urb->dev);
  }
  if (tmp) {
    return;
  }
  {
  tmp___0 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
  }
  if (tmp___0) {
    if (! (urb->transfer_flags & 8U)) {
      if (hcd->self.uses_dma) {
        {
        dma_unmap_single(hcd->self.controller, urb->setup_dma, (unsigned int )sizeof(struct usb_ctrlrequest ),
                         (enum dma_data_direction )1);
        }
      } else {
        if ((hcd->driver)->flags & 2) {
          {
          hcd_free_coherent((urb->dev)->bus, & urb->setup_dma, (void **)(& urb->setup_packet),
                            (unsigned int )sizeof(struct usb_ctrlrequest ), (enum dma_data_direction )1);
          }
        }
      }
    }
  }
  {
  tmp___2 = usb_urb_dir_in(urb);
  }
  if (tmp___2) {
    {
    dir = (enum dma_data_direction )2;
    }
  } else {
    {
    dir = (enum dma_data_direction )1;
    }
  }
  if (urb->transfer_buffer_length != 0U) {
    if (! (urb->transfer_flags & 4U)) {
      if (hcd->self.uses_dma) {
        {
        dma_unmap_single(hcd->self.controller, urb->transfer_dma, urb->transfer_buffer_length,
                         dir);
        }
      } else {
        if ((hcd->driver)->flags & 2) {
          {
          hcd_free_coherent((urb->dev)->bus, & urb->transfer_dma, & urb->transfer_buffer,
                            urb->transfer_buffer_length, dir);
          }
        }
      }
    }
  }
  return;
}
}
int usb_hcd_submit_urb(struct urb *urb , gfp_t mem_flags ) 
{ int status ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = bus_to_hcd((urb->dev)->bus);
  hcd = tmp;
  usb_get_urb(urb);
  atomic_inc(& urb->use_count);
  atomic_inc(& (urb->dev)->urbnum);
  usbmon_urb_submit(& hcd->self, urb);
  status = map_urb_for_dma(hcd, urb, mem_flags);
  tmp___0 = __builtin_expect((long )(! (! status)), 0L);
  }
  if (tmp___0) {
    {
    usbmon_urb_submit_error(& hcd->self, urb, status);
    }
    goto error;
  }
  {
  tmp___1 = is_root_hub(urb->dev);
  }
  if (tmp___1) {
    {
    status = rh_urb_enqueue(hcd, urb);
    }
  } else {
    {
    status = (*((hcd->driver)->urb_enqueue))(hcd, urb, mem_flags);
    }
  }
  {
  tmp___2 = __builtin_expect((long )(! (! status)), 0L);
  }
  if (tmp___2) {
    {
    usbmon_urb_submit_error(& hcd->self, urb, status);
    unmap_urb_for_dma(hcd, urb);
    }
    error: 
    {
    urb->hcpriv = (void *)0;
    INIT_LIST_HEAD(& urb->urb_list);
    atomic_dec(& urb->use_count);
    atomic_dec(& (urb->dev)->urbnum);
    }
    if (urb->reject.counter) {
      {
      __wake_up(& usb_kill_urb_queue, 3U, 1, (void *)0);
      }
    }
    {
    usb_free_urb(urb);
    }
  }
  return (status);
}
}
static int unlink1(struct usb_hcd *hcd , struct urb *urb , int status ) 
{ int value ;
  int tmp ;

  {
  {
  tmp = is_root_hub(urb->dev);
  }
  if (tmp) {
    {
    value = usb_rh_urb_dequeue(hcd, urb, status);
    }
  } else {
    {
    value = (*((hcd->driver)->urb_dequeue))(hcd, urb, status);
    }
  }
  return (value);
}
}
int usb_hcd_unlink_urb(struct urb *urb , int status ) 
{ struct usb_hcd *hcd ;
  int retval ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  retval = -43;
  }
  {
  while (1) {
    while_430_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& hcd_urb_unlink_lock);
    }
    goto while_430_break;
  }
  while_430_break: /* CIL Label */ ;
  }
  if (urb->use_count.counter > (int volatile   )0) {
    {
    retval = 0;
    usb_get_dev(urb->dev);
    }
  }
  {
  while (1) {
    while_431_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& hcd_urb_unlink_lock, flags);
    }
    goto while_431_break;
  }
  while_431_break: /* CIL Label */ ;
  }
  if (retval == 0) {
    {
    hcd = bus_to_hcd((urb->dev)->bus);
    retval = unlink1(hcd, urb, status);
    usb_put_dev(urb->dev);
    }
  }
  if (retval == 0) {
    {
    retval = -115;
    }
  } else {
    if (retval != -43) {
      if (retval != -16) {

      }
    }
  }
  return (retval);
}
}
void usb_hcd_giveback_urb(struct usb_hcd *hcd , struct urb *urb , int status ) 
{ int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
  urb->hcpriv = (void *)0;
  tmp___1 = __builtin_expect((long )(! (! urb->unlinked)), 0L);
  }
  if (tmp___1) {
    {
    status = urb->unlinked;
    }
  } else {
    if (urb->transfer_flags & 1U) {
      if (urb->actual_length < urb->transfer_buffer_length) {
        if (! status) {
          {
          tmp = 1;
          }
        } else {
          {
          tmp = 0;
          }
        }
      } else {
        {
        tmp = 0;
        }
      }
    } else {
      {
      tmp = 0;
      }
    }
    {
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
    if (tmp___0) {
      {
      status = -121;
      }
    }
  }
  {
  unmap_urb_for_dma(hcd, urb);
  usbmon_urb_complete(& hcd->self, urb, status);
  usb_unanchor_urb(urb);
  urb->status = status;
  (*(urb->complete))(urb);
  atomic_dec(& urb->use_count);
  tmp___2 = __builtin_expect((long )(! (! urb->reject.counter)), 0L);
  }
  if (tmp___2) {
    {
    __wake_up(& usb_kill_urb_queue, 3U, 1, (void *)0);
    }
  }
  {
  usb_free_urb(urb);
  }
  return;
}
}
static char const   __kstrtab_usb_hcd_giveback_urb[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'g',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_giveback_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_giveback_urb), __kstrtab_usb_hcd_giveback_urb};
void usb_hcd_flush_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) 
{ struct usb_hcd *hcd ;
  struct urb *urb ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int is_in ;
  char *s ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (! ep) {
    return;
  }
  {
  while (1) {
    while_432_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_432_break;
  }
  while_432_break: /* CIL Label */ ;
  }
  {
  hcd = bus_to_hcd(udev->bus);
  _spin_lock_irq(& hcd_urb_list_lock);
  }
  rescan: 
  {
  __mptr = (struct list_head  const  *)ep->urb_list.next;
  urb = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->urb_list));
  }
  {
  while (1) {
    while_433_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)urb->urb_list.next);
    }
    if (! ((unsigned long )(& urb->urb_list) != (unsigned long )(& ep->urb_list))) {
      goto while_433_break;
    }
    if (urb->unlinked) {
      goto __Cont;
    }
    {
    usb_get_urb(urb);
    is_in = usb_urb_dir_in(urb);
    }
    {
    while (1) {
      while_434_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& hcd_urb_list_lock.raw_lock);
      }
      goto while_434_break;
    }
    while_434_break: /* CIL Label */ ;
    }
    {
    unlink1(hcd, urb, -108);
    }
    if (0) {
      {
      tmp = usb_endpoint_type((struct usb_endpoint_descriptor  const  *)(& ep->desc));
      }
      if (tmp == 0) {
        goto switch_435_0;
      } else {
        if (tmp == 2) {
          goto switch_435_2;
        } else {
          if (tmp == 3) {
            goto switch_435_3;
          } else {
            {
            goto switch_435_default;
            if (0) {
              switch_435_0: /* CIL Label */ 
              {
              s = (char *)"";
              }
              goto switch_435_break;
              switch_435_2: /* CIL Label */ 
              {
              s = (char *)"-bulk";
              }
              goto switch_435_break;
              switch_435_3: /* CIL Label */ 
              {
              s = (char *)"-intr";
              }
              goto switch_435_break;
              switch_435_default: /* CIL Label */ 
              {
              s = (char *)"-iso";
              }
              goto switch_435_break;
            } else {
              switch_435_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
      if (is_in) {
        {
        tmp___0 = "in";
        }
      } else {
        {
        tmp___0 = "out";
        }
      }
      {
      tmp___1 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)(& ep->desc));
      tmp___2 = dev_name((struct device  const  *)hcd->self.controller);
      tmp___3 = dev_driver_string((struct device  const  *)hcd->self.controller);
      printk("<7>%s %s: shutdown urb %p ep%d%s%s\n", tmp___3, tmp___2, urb, tmp___1,
             tmp___0, s);
      }
    }
    {
    usb_free_urb(urb);
    _spin_lock(& hcd_urb_list_lock);
    }
    goto rescan;
    __Cont: /* CIL Label */ 
    {
    __mptr___0 = (struct list_head  const  *)urb->urb_list.next;
    urb = (struct urb *)((char *)__mptr___0 - (unsigned int )(& ((struct urb *)0)->urb_list));
    }
  }
  while_433_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_436_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_urb_list_lock.raw_lock);
    }
    {
    while (1) {
      while_437_continue: /* CIL Label */ ;
      {
      while (1) {
        while_438_continue: /* CIL Label */ ;
        goto while_438_break;
      }
      while_438_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_437_break;
    }
    while_437_break: /* CIL Label */ ;
    }
    goto while_436_break;
  }
  while_436_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_439_continue: /* CIL Label */ ;
    {
    tmp___5 = list_empty((struct list_head  const  *)(& ep->urb_list));
    }
    if (tmp___5) {
      goto while_439_break;
    }
    {
    _spin_lock_irq(& hcd_urb_list_lock);
    urb = (struct urb *)((void *)0);
    tmp___4 = list_empty((struct list_head  const  *)(& ep->urb_list));
    }
    if (! tmp___4) {
      {
      __mptr___1 = (struct list_head  const  *)ep->urb_list.prev;
      urb = (struct urb *)((char *)__mptr___1 - (unsigned int )(& ((struct urb *)0)->urb_list));
      usb_get_urb(urb);
      }
    }
    {
    while (1) {
      while_440_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& hcd_urb_list_lock.raw_lock);
      }
      {
      while (1) {
        while_441_continue: /* CIL Label */ ;
        {
        while (1) {
          while_442_continue: /* CIL Label */ ;
          goto while_442_break;
        }
        while_442_break: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_441_break;
      }
      while_441_break: /* CIL Label */ ;
      }
      goto while_440_break;
    }
    while_440_break: /* CIL Label */ ;
    }
    if (urb) {
      {
      usb_kill_urb(urb);
      usb_free_urb(urb);
      }
    }
  }
  while_439_break: /* CIL Label */ ;
  }
  return;
}
}
void usb_hcd_disable_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) 
{ struct usb_hcd *hcd ;

  {
  {
  while (1) {
    while_443_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_443_break;
  }
  while_443_break: /* CIL Label */ ;
  }
  {
  hcd = bus_to_hcd(udev->bus);
  }
  if ((hcd->driver)->endpoint_disable) {
    {
    (*((hcd->driver)->endpoint_disable))(hcd, ep);
    }
  }
  return;
}
}
void usb_hcd_reset_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) 
{ struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  int epnum ;
  int tmp___0 ;
  int is_out ;
  int tmp___1 ;
  int is_control ;
  int tmp___2 ;

  {
  {
  tmp = bus_to_hcd(udev->bus);
  hcd = tmp;
  }
  if ((hcd->driver)->endpoint_reset) {
    {
    (*((hcd->driver)->endpoint_reset))(hcd, ep);
    }
  } else {
    {
    tmp___0 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)(& ep->desc));
    epnum = tmp___0;
    tmp___1 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)(& ep->desc));
    is_out = tmp___1;
    tmp___2 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)(& ep->desc));
    is_control = tmp___2;
    udev->toggle[is_out] &= (unsigned int )(~ (1 << epnum));
    }
    if (is_control) {
      {
      udev->toggle[! is_out] &= (unsigned int )(~ (1 << epnum));
      }
    }
  }
  return;
}
}
void usb_hcd_synchronize_unlinks(struct usb_device *udev ) 
{ 

  {
  {
  _spin_lock_irq(& hcd_urb_unlink_lock);
  }
  {
  while (1) {
    while_444_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_urb_unlink_lock.raw_lock);
    }
    {
    while (1) {
      while_445_continue: /* CIL Label */ ;
      {
      while (1) {
        while_446_continue: /* CIL Label */ ;
        goto while_446_break;
      }
      while_446_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_445_break;
    }
    while_445_break: /* CIL Label */ ;
    }
    goto while_444_break;
  }
  while_444_break: /* CIL Label */ ;
  }
  return;
}
}
int usb_hcd_get_frame_number(struct usb_device *udev ) 
{ struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  int tmp___0 ;

  {
  {
  tmp = bus_to_hcd(udev->bus);
  hcd = tmp;
  }
  if (! (hcd->state & 1)) {
    return (-108);
  }
  {
  tmp___0 = (*((hcd->driver)->get_frame_number))(hcd);
  }
  return (tmp___0);
}
}
int hcd_bus_suspend(struct usb_device *rhdev , pm_message_t msg ) 
{ struct usb_hcd *hcd ;
  struct usb_bus  const  *__mptr ;
  int status ;
  int old_state ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
  __mptr = (struct usb_bus  const  *)rhdev->bus;
  hcd = (struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->self));
  old_state = hcd->state;
  }
  if (! (hcd->driver)->bus_suspend) {
    {
    status = -2;
    }
  } else {
    {
    hcd->state = 133;
    status = (*((hcd->driver)->bus_suspend))(hcd);
    }
  }
  if (status == 0) {
    {
    usb_set_device_state(rhdev, (enum usb_device_state )8);
    hcd->state = 4;
    }
  } else {
    {
    hcd->state = old_state;
    }
  }
  return (status);
}
}
int hcd_bus_resume(struct usb_device *rhdev , pm_message_t msg ) 
{ struct usb_hcd *hcd ;
  struct usb_bus  const  *__mptr ;
  int status ;
  int old_state ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
  __mptr = (struct usb_bus  const  *)rhdev->bus;
  hcd = (struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->self));
  old_state = hcd->state;
  }
  if (! (hcd->driver)->bus_resume) {
    return (-2);
  }
  if (hcd->state == 1) {
    return (0);
  }
  {
  hcd->state = 132;
  status = (*((hcd->driver)->bus_resume))(hcd);
  }
  if (status == 0) {
    {
    msleep(10U);
    }
    if (rhdev->actconfig) {
      {
      tmp___2 = 7;
      }
    } else {
      {
      tmp___2 = 6;
      }
    }
    {
    usb_set_device_state(rhdev, (enum usb_device_state )tmp___2);
    hcd->state = 1;
    }
  } else {
    {
    hcd->state = old_state;
    }
    if (status != -108) {
      {
      usb_hc_died(hcd);
      }
    }
  }
  return (status);
}
}
static void hcd_resume_work(struct work_struct *work ) 
{ struct usb_hcd *hcd ;
  struct work_struct  const  *__mptr ;
  struct usb_device *udev ;
  struct pm_message __constr_expr_0 ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  hcd = (struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->wakeup_work));
  udev = hcd->self.root_hub;
  down(& udev->dev.sem);
  usb_mark_last_busy(udev);
  __constr_expr_0.event = 528;
  usb_external_resume_device(udev, __constr_expr_0);
  up(& udev->dev.sem);
  }
  return;
}
}
void usb_hcd_resume_root_hub(struct usb_hcd *hcd ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_447_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& hcd_root_hub_lock);
    }
    goto while_447_break;
  }
  while_447_break: /* CIL Label */ ;
  }
  if (hcd->rh_registered) {
    {
    queue_work(ksuspend_usb_wq, & hcd->wakeup_work);
    }
  }
  {
  while (1) {
    while_448_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& hcd_root_hub_lock, flags);
    }
    goto while_448_break;
  }
  while_448_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_hcd_resume_root_hub[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'u', 
        (char const   )'m',      (char const   )'e',      (char const   )'_',      (char const   )'r', 
        (char const   )'o',      (char const   )'o',      (char const   )'t',      (char const   )'_', 
        (char const   )'h',      (char const   )'u',      (char const   )'b',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_resume_root_hub  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_resume_root_hub), __kstrtab_usb_hcd_resume_root_hub};
irqreturn_t usb_hcd_irq(int irq ,
                        void *__hcd ) 
{ struct usb_hcd *hcd ;
  unsigned long flags ;
  irqreturn_t rc ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  long tmp ;
  irqreturn_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp___5 ;

  {
  {
  hcd = (struct usb_hcd *)__hcd;
  }
  {
  while (1) {
    while_449_continue: /* CIL Label */ ;
    {
    while (1) {
      while_450_continue: /* CIL Label */ ;
      {
      flags = __raw_local_irq_save();
      }
      goto while_450_break;
    }
    while_450_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_451_continue: /* CIL Label */ ;
      goto while_451_break;
    }
    while_451_break: /* CIL Label */ ;
    }
    goto while_449_break;
  }
  while_449_break: /* CIL Label */ ;
  }
  if (hcd->state == 0) {
    {
    tmp___3 = 1;
    }
  } else {
    {
    tmp___1 = constant_test_bit(1U, (unsigned long const volatile   *)(& hcd->flags));
    }
    if (tmp___1) {
      {
      tmp___3 = 0;
      }
    } else {
      {
      tmp___3 = 1;
      }
    }
  }
  {
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
  if (tmp___4) {
    {
    rc = (enum irqreturn )0;
    }
  } else {
    {
    tmp___0 = (*((hcd->driver)->irq))(hcd);
    }
    if ((unsigned int )tmp___0 == 0U) {
      {
      rc = (enum irqreturn )0;
      }
    } else {
      {
      set_bit(2U, (unsigned long volatile   *)(& hcd->flags));
      tmp = __builtin_expect((long )(! (! (hcd->state == 0))), 0L);
      }
      if (tmp) {
        {
        usb_hc_died(hcd);
        }
      }
      {
      rc = (enum irqreturn )1;
      }
    }
  }
  {
  while (1) {
    while_452_continue: /* CIL Label */ ;
    {
    tmp___5 = raw_irqs_disabled_flags(flags);
    }
    if (tmp___5) {
      {
      raw_local_irq_restore(flags);
      }
      {
      while (1) {
        while_453_continue: /* CIL Label */ ;
        goto while_453_break;
      }
      while_453_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_454_continue: /* CIL Label */ ;
        goto while_454_break;
      }
      while_454_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_restore(flags);
      }
    }
    goto while_452_break;
  }
  while_452_break: /* CIL Label */ ;
  }
  return (rc);
}
}
void usb_hc_died(struct usb_hcd *hcd ) 
{ unsigned long flags ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  tmp = dev_name((struct device  const  *)hcd->self.controller);
  tmp___0 = dev_driver_string((struct device  const  *)hcd->self.controller);
  printk("<3>%s %s: HC died; cleaning up\n", tmp___0, tmp);
  }
  {
  while (1) {
    while_455_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& hcd_root_hub_lock);
    }
    goto while_455_break;
  }
  while_455_break: /* CIL Label */ ;
  }
  if (hcd->rh_registered) {
    {
    hcd->poll_rh = 0U;
    usb_set_device_state(hcd->self.root_hub, (enum usb_device_state )0);
    usb_kick_khubd(hcd->self.root_hub);
    }
  }
  {
  while (1) {
    while_456_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& hcd_root_hub_lock, flags);
    }
    goto while_456_break;
  }
  while_456_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_hc_died[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'_',      (char const   )'d', 
        (char const   )'i',      (char const   )'e',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hc_died  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hc_died), __kstrtab_usb_hc_died};
struct usb_hcd *usb_create_hcd(struct hc_driver  const  *driver , struct device *dev ,
                               char const   *bus_name ) 
{ struct usb_hcd *hcd ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  atomic_long_t __constr_expr_0 ;

  {
  {
  tmp = kzalloc((unsigned int )(sizeof(*hcd) + (unsigned long )driver->hcd_priv_size),
                208U);
  hcd = (struct usb_hcd *)tmp;
  }
  if (! hcd) {
    return ((struct usb_hcd *)((void *)0));
  }
  {
  dev_set_drvdata(dev, (void *)hcd);
  kref_init(& hcd->kref);
  usb_bus_init(& hcd->self);
  hcd->self.controller = dev;
  hcd->self.bus_name = bus_name;
  hcd->self.uses_dma = (unsigned char )((unsigned long )dev->dma_mask != (unsigned long )((void *)0));
  init_timer_key(& hcd->rh_timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0));
  hcd->rh_timer.function = & rh_timer_func;
  hcd->rh_timer.data = (unsigned long )hcd;
  }
  {
  while (1) {
    while_457_continue: /* CIL Label */ ;
    {
    __constr_expr_0.counter = (int volatile   )0;
    hcd->wakeup_work.data = __constr_expr_0;
    INIT_LIST_HEAD(& hcd->wakeup_work.entry);
    }
    {
    while (1) {
      while_458_continue: /* CIL Label */ ;
      {
      hcd->wakeup_work.func = & hcd_resume_work;
      }
      goto while_458_break;
    }
    while_458_break: /* CIL Label */ ;
    }
    goto while_457_break;
  }
  while_457_break: /* CIL Label */ ;
  }
  {
  hcd->driver = driver;
  }
  if (driver->product_desc) {
    {
    hcd->product_desc = (char const   *)driver->product_desc;
    }
  } else {
    {
    hcd->product_desc = "USB Host Controller";
    }
  }
  return (hcd);
}
}
static char const   __kstrtab_usb_create_hcd[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'c',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'_',      (char const   )'h', 
        (char const   )'c',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_create_hcd  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_create_hcd), __kstrtab_usb_create_hcd};
static void hcd_release(struct kref *kref ) 
{ struct usb_hcd *hcd ;
  struct kref  const  *__mptr ;

  {
  {
  __mptr = (struct kref  const  *)kref;
  hcd = (struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->kref));
  kfree((void const   *)hcd);
  }
  return;
}
}
struct usb_hcd *usb_get_hcd(struct usb_hcd *hcd ) 
{ 

  {
  if (hcd) {
    {
    kref_get(& hcd->kref);
    }
  }
  return (hcd);
}
}
static char const   __kstrtab_usb_get_hcd[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_hcd  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_hcd), __kstrtab_usb_get_hcd};
void usb_put_hcd(struct usb_hcd *hcd ) 
{ 

  {
  if (hcd) {
    {
    kref_put(& hcd->kref, & hcd_release);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_put_hcd[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'p',      (char const   )'u',      (char const   )'t',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_put_hcd  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_put_hcd), __kstrtab_usb_put_hcd};
int usb_add_hcd(struct usb_hcd *hcd , unsigned int irqnum , unsigned long irqflags ) 
{ int retval ;
  struct usb_device *rhdev ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int tmp___21 ;

  {
  {
  tmp = dev_name((struct device  const  *)hcd->self.controller);
  tmp___0 = dev_driver_string((struct device  const  *)hcd->self.controller);
  printk("<6>%s %s: %s\n", tmp___0, tmp, hcd->product_desc);
  }
  if (hcd->wireless) {
    {
    hcd->authorized_default = 0U;
    }
  } else {
    {
    hcd->authorized_default = 1U;
    }
  }
  {
  set_bit(1U, (unsigned long volatile   *)(& hcd->flags));
  retval = hcd_buffer_create(hcd);
  }
  if (retval != 0) {
    return (retval);
  }
  {
  retval = usb_register_bus(& hcd->self);
  }
  if (retval < 0) {
    goto err_register_bus;
  }
  {
  rhdev = usb_alloc_dev((struct usb_device *)((void *)0), & hcd->self, 0U);
  }
  if ((unsigned long )rhdev == (unsigned long )((void *)0)) {
    {
    tmp___3 = dev_name((struct device  const  *)hcd->self.controller);
    tmp___4 = dev_driver_string((struct device  const  *)hcd->self.controller);
    printk("<3>%s %s: unable to allocate root hub\n", tmp___4, tmp___3);
    retval = -12;
    }
    goto err_allocate_root_hub;
  }
  if ((hcd->driver)->flags & 32) {
    {
    rhdev->speed = (enum usb_device_speed )3;
    }
  } else {
    {
    rhdev->speed = (enum usb_device_speed )2;
    }
  }
  {
  hcd->self.root_hub = rhdev;
  device_init_wakeup(& rhdev->dev, 1);
  }
  if ((hcd->driver)->reset) {
    {
    retval = (*((hcd->driver)->reset))(hcd);
    }
    if (retval < 0) {
      {
      tmp___5 = dev_name((struct device  const  *)hcd->self.controller);
      tmp___6 = dev_driver_string((struct device  const  *)hcd->self.controller);
      printk("<3>%s %s: can\'t setup\n", tmp___6, tmp___5);
      }
      goto err_request_irq;
    }
  }
  {
  tmp___9 = device_can_wakeup(hcd->self.controller);
  }
  if (tmp___9) {
    {
    tmp___10 = device_can_wakeup(& (hcd->self.root_hub)->dev);
    }
    if (tmp___10) {

    }
  }
  if ((hcd->driver)->irq) {
    if (irqflags & 128UL) {
      {
      irqflags &= 0xffffffdfUL;
      }
    }
    {
    snprintf(hcd->irq_descr, (unsigned int )sizeof(hcd->irq_descr), "%s:usb%d", (hcd->driver)->description,
             hcd->self.busnum);
    retval = request_irq(irqnum, & usb_hcd_irq, irqflags, (char const   *)(hcd->irq_descr),
                         (void *)hcd);
    }
    if (retval != 0) {
      {
      tmp___11 = dev_name((struct device  const  *)hcd->self.controller);
      tmp___12 = dev_driver_string((struct device  const  *)hcd->self.controller);
      printk("<3>%s %s: request interrupt %d failed\n", tmp___12, tmp___11, irqnum);
      }
      goto err_request_irq;
    }
    {
    hcd->irq = (int )irqnum;
    }
    if ((hcd->driver)->flags & 1) {
      {
      tmp___13 = "io mem";
      }
    } else {
      {
      tmp___13 = "io base";
      }
    }
    {
    tmp___14 = dev_name((struct device  const  *)hcd->self.controller);
    tmp___15 = dev_driver_string((struct device  const  *)hcd->self.controller);
    printk("<6>%s %s: irq %d, %s 0x%08llx\n", tmp___15, tmp___14, irqnum, tmp___13,
           hcd->rsrc_start);
    }
  } else {
    {
    hcd->irq = -1;
    }
    if (hcd->rsrc_start) {
      if ((hcd->driver)->flags & 1) {
        {
        tmp___16 = "io mem";
        }
      } else {
        {
        tmp___16 = "io base";
        }
      }
      {
      tmp___17 = dev_name((struct device  const  *)hcd->self.controller);
      tmp___18 = dev_driver_string((struct device  const  *)hcd->self.controller);
      printk("<6>%s %s: %s 0x%08llx\n", tmp___18, tmp___17, tmp___16, hcd->rsrc_start);
      }
    }
  }
  {
  retval = (*((hcd->driver)->start))(hcd);
  }
  if (retval < 0) {
    {
    tmp___19 = dev_name((struct device  const  *)hcd->self.controller);
    tmp___20 = dev_driver_string((struct device  const  *)hcd->self.controller);
    printk("<3>%s %s: startup error %d\n", tmp___20, tmp___19, retval);
    }
    goto err_hcd_driver_start;
  }
  {
  _min1 = 500U;
  _min2 = hcd->power_budget;
  }
  if (_min1 < _min2) {
    {
    tmp___21 = _min1;
    }
  } else {
    {
    tmp___21 = _min2;
    }
  }
  {
  rhdev->bus_mA = (unsigned short )tmp___21;
  retval = register_root_hub(hcd);
  }
  if (retval != 0) {
    goto err_register_root_hub;
  }
  {
  retval = sysfs_create_group(& rhdev->dev.kobj, (struct attribute_group  const  *)(& usb_bus_attr_group));
  }
  if (retval < 0) {
    {
    printk("<3>Cannot register USB bus sysfs attributes: %d\n", retval);
    }
    goto error_create_attr_group;
  }
  if (hcd->uses_new_polling) {
    if (hcd->poll_rh) {
      {
      usb_hcd_poll_rh_status(hcd);
      }
    }
  }
  return (retval);
  error_create_attr_group: 
  {
  mutex_lock(& usb_bus_list_lock);
  usb_disconnect(& hcd->self.root_hub);
  mutex_unlock(& usb_bus_list_lock);
  }
  err_register_root_hub: 
  {
  (*((hcd->driver)->stop))(hcd);
  }
  err_hcd_driver_start: 
  if (hcd->irq >= 0) {
    {
    free_irq(irqnum, (void *)hcd);
    }
  }
  err_request_irq: 
  err_hcd_driver_setup: 
  {
  hcd->self.root_hub = (struct usb_device *)((void *)0);
  usb_put_dev(rhdev);
  }
  err_allocate_root_hub: 
  {
  usb_deregister_bus(& hcd->self);
  }
  err_register_bus: 
  {
  hcd_buffer_destroy(hcd);
  }
  return (retval);
}
}
static char const   __kstrtab_usb_add_hcd[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_add_hcd  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_add_hcd), __kstrtab_usb_add_hcd};
void usb_remove_hcd(struct usb_hcd *hcd ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  tmp = dev_name((struct device  const  *)hcd->self.controller);
  tmp___0 = dev_driver_string((struct device  const  *)hcd->self.controller);
  printk("<6>%s %s: remove, state %x\n", tmp___0, tmp, hcd->state);
  }
  if (hcd->state & 1) {
    {
    hcd->state = 133;
    }
  }
  {
  _spin_lock_irq(& hcd_root_hub_lock);
  hcd->rh_registered = 0U;
  }
  {
  while (1) {
    while_459_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hcd_root_hub_lock.raw_lock);
    }
    {
    while (1) {
      while_460_continue: /* CIL Label */ ;
      {
      while (1) {
        while_461_continue: /* CIL Label */ ;
        goto while_461_break;
      }
      while_461_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_460_break;
    }
    while_460_break: /* CIL Label */ ;
    }
    goto while_459_break;
  }
  while_459_break: /* CIL Label */ ;
  }
  {
  cancel_work_sync(& hcd->wakeup_work);
  sysfs_remove_group(& (hcd->self.root_hub)->dev.kobj, (struct attribute_group  const  *)(& usb_bus_attr_group));
  mutex_lock(& usb_bus_list_lock);
  usb_disconnect(& hcd->self.root_hub);
  mutex_unlock(& usb_bus_list_lock);
  (*((hcd->driver)->stop))(hcd);
  hcd->state = 0;
  hcd->poll_rh = 0U;
  del_timer_sync(& hcd->rh_timer);
  }
  if (hcd->irq >= 0) {
    {
    free_irq((unsigned int )hcd->irq, (void *)hcd);
    }
  }
  {
  usb_deregister_bus(& hcd->self);
  hcd_buffer_destroy(hcd);
  }
  return;
}
}
static char const   __kstrtab_usb_remove_hcd[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'_',      (char const   )'h', 
        (char const   )'c',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_remove_hcd  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_remove_hcd), __kstrtab_usb_remove_hcd};
void usb_hcd_platform_shutdown(struct platform_device *dev ) 
{ struct usb_hcd *hcd ;
  void *tmp ;

  {
  {
  tmp = dev_get_drvdata((struct device  const  *)(& dev->dev));
  hcd = (struct usb_hcd *)tmp;
  }
  if ((hcd->driver)->shutdown) {
    {
    (*((hcd->driver)->shutdown))(hcd);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_hcd_platform_shutdown[26]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'p',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'m', 
        (char const   )'_',      (char const   )'s',      (char const   )'h',      (char const   )'u', 
        (char const   )'t',      (char const   )'d',      (char const   )'o',      (char const   )'w', 
        (char const   )'n',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_platform_shutdown  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_platform_shutdown), __kstrtab_usb_hcd_platform_shutdown};
int usb_mon_register(struct usb_mon_operations *ops ) 
{ 

  {
  if (mon_ops) {
    return (-16);
  }
  {
  mon_ops = ops;
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
  return (0);
}
}
static char const   __kstrtab_usb_mon_register[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'m',      (char const   )'o',      (char const   )'n',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_mon_register  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_mon_register), __kstrtab_usb_mon_register};
void usb_mon_deregister(void) 
{ 

  {
  if ((unsigned long )mon_ops == (unsigned long )((void *)0)) {
    {
    printk("<3>USB: monitor was not registered\n");
    }
    return;
  }
  {
  mon_ops = (struct usb_mon_operations *)((void *)0);
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
  return;
}
}
static char const   __kstrtab_usb_mon_deregister[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'m',      (char const   )'o',      (char const   )'n',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_mon_deregister  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_mon_deregister), __kstrtab_usb_mon_deregister};
static unsigned long __force_order___8  ;
__inline static unsigned long native_read_cr0___8(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___8));
  }
  return (val);
}
}
__inline static void native_write_cr0___8(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___8));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___8(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___8));
  }
  return (val);
}
}
__inline static void native_write_cr2___8(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___8));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___8(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___8));
  }
  return (val);
}
}
__inline static void native_write_cr3___8(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___8));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___8(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___8));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___8(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___8): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___8(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___8));
  }
  return;
}
}
__inline static void load_cr3___8(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___8((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___8(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___8();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___8((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___8(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___8();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___8((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___8(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___3 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___8(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___8(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___8(u64 ns ) ;
static union ktime  const  ktime_zero___8  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___8(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___8.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___11  ;
extern void __iowrite32_copy(void *to , void const   *from , size_t count ) ;
extern void __iowrite64_copy(void *to , void const   *from , size_t count ) ;
extern int ioremap_page_range(unsigned long addr , unsigned long end , unsigned long phys_addr ,
                              pgprot_t prot ) ;
extern void *devm_ioport_map(struct device *dev , unsigned long port , unsigned int nr ) ;
extern void devm_ioport_unmap(struct device *dev , void *addr ) ;
extern void *devm_ioremap(struct device *dev , resource_size_t offset , unsigned long size ) ;
extern void *devm_ioremap_nocache(struct device *dev , resource_size_t offset , unsigned long size ) ;
extern void devm_iounmap(struct device *dev , void *addr ) ;
extern int check_signature(void const volatile   *io_addr , unsigned char const   *signature ,
                           int length ) ;
extern void devm_ioremap_release(struct device *dev , void *res ) ;
__inline static char const   *pci_slot_name(struct pci_slot  const  *slot ) 
{ char const   *tmp ;

  {
  {
  tmp = kobject_name(& slot->kobj);
  }
  return (tmp);
}
}
extern struct pci_dev *alloc_pci_dev(void) ;
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 

  {
  return (pdev->error_state != 1U);
}
}
__inline static struct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *pci_dev ,
                                                               char cap ) 
{ struct pci_cap_saved_state *tmp ;
  struct hlist_node *pos ;
  struct hlist_node  const  *__mptr ;

  {
  {
  pos = pci_dev->saved_cap_space.first;
  }
  {
  while (1) {
    while_462_continue: /* CIL Label */ ;
    if (pos) {
      {
      prefetch((void const   *)pos->next);
      __mptr = (struct hlist_node  const  *)pos;
      tmp = (struct pci_cap_saved_state *)((char *)__mptr - (unsigned int )(& ((struct pci_cap_saved_state *)0)->next));
      }
    } else {
      goto while_462_break;
    }
    if ((int )tmp->cap_nr == (int )cap) {
      return (tmp);
    }
    {
    pos = pos->next;
    }
  }
  while_462_break: /* CIL Label */ ;
  }
  return ((struct pci_cap_saved_state *)((void *)0));
}
}
__inline static void pci_add_saved_cap(struct pci_dev *pci_dev , struct pci_cap_saved_state *new_cap ) 
{ 

  {
  {
  hlist_add_head(& new_cap->next, & pci_dev->saved_cap_space);
  }
  return;
}
}
__inline static bool pci_is_root_bus(struct pci_bus *pbus ) 
{ 

  {
  return ((_Bool )(! pbus->parent));
}
}
__inline static bool pci_dev_msi_enabled(struct pci_dev *pci_dev ) 
{ int tmp ;

  {
  if (pci_dev->msi_enabled) {
    {
    tmp = 1;
    }
  } else {
    if (pci_dev->msix_enabled) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return ((_Bool )tmp);
}
}
extern int raw_pci_read(unsigned int domain , unsigned int bus , unsigned int devfn ,
                        int reg , int len , u32 *val ) ;
extern int raw_pci_write(unsigned int domain , unsigned int bus , unsigned int devfn ,
                         int reg , int len , u32 val ) ;
extern struct bus_type pci_bus_type ;
extern struct list_head pci_root_buses ;
extern int no_pci_devices(void) ;
extern void pcibios_fixup_bus(struct pci_bus * ) ;
extern int pcibios_enable_device(struct pci_dev * , int mask ) ;
extern char *pcibios_setup(char *str ) ;
extern void pcibios_align_resource(void * , struct resource * , resource_size_t  ,
                                   resource_size_t  ) ;
extern void pcibios_update_irq(struct pci_dev * , int irq ) ;
extern struct pci_bus *pci_find_bus(int domain , int busnr ) ;
extern void pci_bus_add_devices(struct pci_bus  const  *bus ) ;
extern struct pci_bus *pci_scan_bus_parented(struct device *parent , int bus , struct pci_ops *ops ,
                                             void *sysdata ) ;
__inline static struct pci_bus *pci_scan_bus(int bus , struct pci_ops *ops , void *sysdata )  __attribute__((__section__(".devinit.text"))) ;
__inline static struct pci_bus *pci_scan_bus(int bus , struct pci_ops *ops , void *sysdata ) 
{ struct pci_bus *root_bus ;

  {
  {
  root_bus = pci_scan_bus_parented((struct device *)((void *)0), bus, ops, sysdata);
  }
  if (root_bus) {
    {
    pci_bus_add_devices((struct pci_bus  const  *)root_bus);
    }
  }
  return (root_bus);
}
}
extern struct pci_bus *pci_create_bus(struct device *parent , int bus , struct pci_ops *ops ,
                                      void *sysdata ) ;
extern struct pci_bus *pci_add_new_bus(struct pci_bus *parent , struct pci_dev *dev ,
                                       int busnr ) ;
extern struct pci_slot *pci_create_slot(struct pci_bus *parent , int slot_nr , char const   *name ,
                                        struct hotplug_slot *hotplug ) ;
extern void pci_destroy_slot(struct pci_slot *slot ) ;
extern void pci_renumber_slot(struct pci_slot *slot , int slot_nr ) ;
extern int pci_scan_slot(struct pci_bus *bus , int devfn ) ;
extern struct pci_dev *pci_scan_single_device(struct pci_bus *bus , int devfn ) ;
extern void pci_device_add(struct pci_dev *dev , struct pci_bus *bus ) ;
extern unsigned int pci_scan_child_bus(struct pci_bus *bus ) ;
extern int pci_bus_add_device(struct pci_dev *dev ) ;
extern void pci_read_bridge_bases(struct pci_bus *child ) ;
extern struct resource *pci_find_parent_resource(struct pci_dev  const  *dev , struct resource *res ) ;
extern u8 pci_swizzle_interrupt_pin(struct pci_dev *dev , u8 pin ) ;
extern int pci_get_interrupt_pin(struct pci_dev *dev , struct pci_dev **bridge ) ;
extern u8 pci_common_swizzle(struct pci_dev *dev , u8 *pinp ) ;
extern struct pci_dev *pci_dev_get(struct pci_dev *dev ) ;
extern void pci_dev_put(struct pci_dev *dev ) ;
extern void pci_remove_bus(struct pci_bus *b ) ;
extern void pci_remove_bus_device(struct pci_dev *dev ) ;
extern void pci_stop_bus_device(struct pci_dev *dev ) ;
extern void pci_setup_cardbus(struct pci_bus *bus ) ;
extern void pci_sort_breadthfirst(void) ;
extern enum pci_lost_interrupt_reason pci_lost_interrupt(struct pci_dev *dev ) ;
extern int pci_find_capability(struct pci_dev *dev , int cap ) ;
extern int pci_find_next_capability(struct pci_dev *dev , u8 pos , int cap ) ;
extern int pci_find_ext_capability(struct pci_dev *dev , int cap ) ;
extern int pci_find_ht_capability(struct pci_dev *dev , int ht_cap ) ;
extern int pci_find_next_ht_capability(struct pci_dev *dev , int pos , int ht_cap ) ;
extern struct pci_bus *pci_find_next_bus(struct pci_bus  const  *from ) ;
extern struct pci_dev *pci_get_device(unsigned int vendor , unsigned int device ,
                                      struct pci_dev *from ) ;
extern struct pci_dev *pci_get_subsys(unsigned int vendor , unsigned int device ,
                                      unsigned int ss_vendor , unsigned int ss_device ,
                                      struct pci_dev *from ) ;
extern struct pci_dev *pci_get_slot(struct pci_bus *bus , unsigned int devfn ) ;
extern struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) ;
extern struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
extern int pci_dev_present(struct pci_device_id  const  *ids ) ;
extern int pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u8 *val ) ;
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
extern int pci_bus_write_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u8 val ) ;
extern int pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u16 val ) ;
extern int pci_bus_write_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                      u32 val ) ;
__inline static int pci_read_config_byte(struct pci_dev *dev , int where , u8 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_read_config_dword(struct pci_dev *dev , int where , u32 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_byte(struct pci_dev *dev , int where , u8 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_word(struct pci_dev *dev , int where , u16 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_dword(struct pci_dev *dev , int where , u32 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev *dev ) ;
extern int pci_enable_device_io(struct pci_dev *dev ) ;
extern int pci_enable_device_mem(struct pci_dev *dev ) ;
extern int pci_reenable_device(struct pci_dev * ) ;
extern int pcim_enable_device(struct pci_dev *pdev ) ;
extern void pcim_pin_device(struct pci_dev *pdev ) ;
__inline static int pci_is_enabled(struct pci_dev *pdev ) 
{ 

  {
  return (pdev->enable_cnt.counter > (int volatile   )0);
}
}
__inline static int pci_is_managed(struct pci_dev *pdev ) 
{ 

  {
  return ((int )pdev->is_managed);
}
}
extern void pci_disable_device(struct pci_dev *dev ) ;
extern void pci_set_master(struct pci_dev *dev ) ;
extern void pci_clear_master(struct pci_dev *dev ) ;
extern int pci_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
extern int pci_set_mwi(struct pci_dev *dev ) ;
extern int pci_try_set_mwi(struct pci_dev *dev ) ;
extern void pci_clear_mwi(struct pci_dev *dev ) ;
extern void pci_intx(struct pci_dev *dev , int enable ) ;
extern void pci_msi_off(struct pci_dev *dev ) ;
extern int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) ;
extern int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) ;
extern int pci_set_dma_max_seg_size(struct pci_dev *dev , unsigned int size ) ;
extern int pci_set_dma_seg_boundary(struct pci_dev *dev , unsigned long mask ) ;
extern int pcix_get_max_mmrbc(struct pci_dev *dev ) ;
extern int pcix_get_mmrbc(struct pci_dev *dev ) ;
extern int pcix_set_mmrbc(struct pci_dev *dev , int mmrbc ) ;
extern int pcie_get_readrq(struct pci_dev *dev ) ;
extern int pcie_set_readrq(struct pci_dev *dev , int rq ) ;
extern int pci_reset_function(struct pci_dev *dev ) ;
extern int pci_execute_reset_function(struct pci_dev *dev ) ;
extern void pci_update_resource(struct pci_dev *dev , int resno ) ;
extern int pci_assign_resource(struct pci_dev *dev , int i ) ;
extern int pci_select_bars(struct pci_dev *dev , unsigned long flags ) ;
extern int pci_enable_rom(struct pci_dev *pdev ) ;
extern void pci_disable_rom(struct pci_dev *pdev ) ;
extern void *pci_map_rom(struct pci_dev *pdev , size_t *size ) ;
extern void pci_unmap_rom(struct pci_dev *pdev , void *rom ) ;
extern size_t pci_get_rom_size(struct pci_dev *pdev , void *rom , size_t size ) ;
extern int pci_save_state(struct pci_dev *dev ) ;
extern int pci_restore_state(struct pci_dev *dev ) ;
extern int __pci_complete_power_transition(struct pci_dev *dev , pci_power_t state ) ;
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
extern pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) ;
extern bool pci_pme_capable(struct pci_dev *dev , pci_power_t state ) ;
extern void pci_pme_active(struct pci_dev *dev , bool enable ) ;
extern int pci_enable_wake(struct pci_dev *dev , pci_power_t state , int enable ) ;
extern int pci_wake_from_d3(struct pci_dev *dev , bool enable ) ;
extern pci_power_t pci_target_state(struct pci_dev *dev ) ;
extern int pci_prepare_to_sleep(struct pci_dev *dev ) ;
extern int pci_back_from_sleep(struct pci_dev *dev ) ;
extern int pci_bus_find_capability(struct pci_bus *bus , unsigned int devfn , int cap ) ;
extern unsigned int pci_rescan_bus(struct pci_bus *bus ) ;
extern ssize_t pci_read_vpd(struct pci_dev *dev , loff_t pos , size_t count , void *buf ) ;
extern ssize_t pci_write_vpd(struct pci_dev *dev , loff_t pos , size_t count , void const   *buf ) ;
extern int pci_vpd_truncate(struct pci_dev *dev , size_t size ) ;
extern void pci_bus_assign_resources(struct pci_bus  const  *bus ) ;
extern void pci_bus_size_bridges(struct pci_bus *bus ) ;
extern int pci_claim_resource(struct pci_dev * , int  ) ;
extern void pci_assign_unassigned_resources(void) ;
extern void pdev_enable_device(struct pci_dev * ) ;
extern void pdev_sort_resources(struct pci_dev * , struct resource_list * ) ;
extern int pci_enable_resources(struct pci_dev * , int mask ) ;
extern void pci_fixup_irqs(u8 (*)(struct pci_dev * , u8 * ) , int (*)(struct pci_dev * ,
                                                                      u8  , u8  ) ) ;
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
extern int pci_request_regions_exclusive(struct pci_dev * , char const   * ) ;
extern void pci_release_regions(struct pci_dev * ) ;
extern int pci_request_region(struct pci_dev * , int  , char const   * ) ;
extern int pci_request_region_exclusive(struct pci_dev * , int  , char const   * ) ;
extern void pci_release_region(struct pci_dev * , int  ) ;
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
extern int pci_request_selected_regions_exclusive(struct pci_dev * , int  , char const   * ) ;
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
extern int pci_bus_alloc_resource(struct pci_bus *bus , struct resource *res , resource_size_t size ,
                                  resource_size_t align , resource_size_t min , unsigned int type_mask ,
                                  void (*alignf)(void * , struct resource * , resource_size_t  ,
                                                 resource_size_t  ) , void *alignf_data ) ;
extern void pci_enable_bridges(struct pci_bus *bus ) ;
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   *mod_name ) ;
extern void pci_unregister_driver(struct pci_driver *dev ) ;
extern void pci_remove_behind_bridge(struct pci_dev *dev ) ;
extern struct pci_driver *pci_dev_driver(struct pci_dev  const  *dev ) ;
extern struct pci_device_id  const  *pci_match_id(struct pci_device_id  const  *ids ,
                                                  struct pci_dev *dev ) ;
extern int pci_scan_bridge(struct pci_bus *bus , struct pci_dev *dev , int max , int pass ) ;
extern void pci_walk_bus(struct pci_bus *top , void (*cb)(struct pci_dev * , void * ) ,
                         void *userdata ) ;
extern int pci_cfg_space_size_ext(struct pci_dev *dev ) ;
extern int pci_cfg_space_size(struct pci_dev *dev ) ;
extern unsigned char pci_bus_max_busnr(struct pci_bus *bus ) ;
extern int pci_enable_msi_block(struct pci_dev *dev , unsigned int nvec ) ;
extern void pci_msi_shutdown(struct pci_dev *dev ) ;
extern void pci_disable_msi(struct pci_dev *dev ) ;
extern int pci_msix_table_size(struct pci_dev *dev ) ;
extern int pci_enable_msix(struct pci_dev *dev , struct msix_entry *entries , int nvec ) ;
extern void pci_msix_shutdown(struct pci_dev *dev ) ;
extern void pci_disable_msix(struct pci_dev *dev ) ;
extern void msi_remove_pci_irq_vectors(struct pci_dev *dev ) ;
extern void pci_restore_msi_state(struct pci_dev *dev ) ;
extern int pci_msi_enabled(void) ;
extern int ht_create_irq(struct pci_dev *dev , int idx ) ;
extern void ht_destroy_irq(unsigned int irq ) ;
extern void pci_block_user_cfg_access(struct pci_dev *dev ) ;
extern void pci_unblock_user_cfg_access(struct pci_dev *dev ) ;
extern int pci_domains_supported ;
extern int pci_routeirq ;
extern struct pci_bus *pci_scan_bus_on_node(int busno , struct pci_ops *ops , int node ) ;
extern struct pci_bus *pci_scan_bus_with_sysdata(int busno ) ;
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ struct pci_sysdata *sd ;

  {
  {
  sd = (struct pci_sysdata *)bus->sysdata;
  }
  return (sd->domain);
}
}
__inline static int pci_proc_domain(struct pci_bus *bus ) 
{ int tmp ;

  {
  {
  tmp = pci_domain_nr(bus);
  }
  return (tmp);
}
}
extern unsigned int pcibios_assign_all_busses(void) ;
extern unsigned long pci_mem_start ;
extern void pcibios_config_init(void) ;
extern struct pci_bus *pcibios_scan_root(int bus ) ;
extern void pcibios_set_master(struct pci_dev *dev ) ;
extern void pcibios_penalize_isa_irq(int irq , int active ) ;
extern struct irq_routing_table *pcibios_get_irq_routing_table(void) ;
extern int pcibios_set_irq_routing(struct pci_dev *dev , int pin , int irq ) ;
extern int pci_mmap_page_range(struct pci_dev *dev , struct vm_area_struct *vma ,
                               enum pci_mmap_state mmap_state , int write_combine ) ;
extern void early_quirks(void) ;
__inline static void pci_dma_burst_advice(struct pci_dev *pdev , enum pci_dma_burst_strategy *strat ,
                                          unsigned long *strategy_parameter ) 
{ 

  {
  {
  *strat = (enum pci_dma_burst_strategy )0;
  *strategy_parameter = ~ 0UL;
  }
  return;
}
}
extern void pci_iommu_alloc(void) ;
__inline static int pci_dma_supported(struct pci_dev *hwdev , u64 mask ) 
{ struct device *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_supported(tmp, mask);
  }
  return (tmp___0);
}
}
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ struct device *tmp ;
  void *tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_alloc_coherent(tmp, size, dma_handle, 32U);
  }
  return (tmp___0);
}
}
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_free_coherent(tmp, size, vaddr, dma_handle);
  }
  return;
}
}
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_map_single(tmp, ptr, size, (enum dma_data_direction )direction);
  }
  return (tmp___0);
}
}
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_unmap_single(tmp, dma_addr, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_map_page(tmp, page, (unsigned int )offset, size, (enum dma_data_direction )direction);
  }
  return (tmp___0);
}
}
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_unmap_page(tmp, dma_address, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ struct device *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_map_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  }
  return (tmp___0);
}
}
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_unmap_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_single_for_cpu(tmp, dma_handle, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_single_for_device(tmp, dma_handle, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev , struct scatterlist *sg ,
                                             int nelems , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_sg_for_cpu(tmp, sg, nelems, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_sg_for_device(struct pci_dev *hwdev , struct scatterlist *sg ,
                                                int nelems , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_sg_for_device(tmp, sg, nelems, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr ) 
{ int tmp ;

  {
  {
  tmp = dma_mapping_error(& pdev->dev, dma_addr);
  }
  return (tmp);
}
}
__inline static void pcibios_resource_to_bus(struct pci_dev *dev , struct pci_bus_region *region ,
                                             struct resource *res ) 
{ 

  {
  {
  region->start = res->start;
  region->end = res->end;
  }
  return;
}
}
__inline static void pcibios_bus_to_resource(struct pci_dev *dev , struct resource *res ,
                                             struct pci_bus_region *region ) 
{ 

  {
  {
  res->start = region->start;
  res->end = region->end;
  }
  return;
}
}
__inline static struct resource *pcibios_select_root(struct pci_dev *pdev , struct resource *res ) 
{ struct resource *root ;

  {
  {
  root = (struct resource *)((void *)0);
  }
  if (res->flags & 256UL) {
    {
    root = & ioport_resource;
    }
  }
  if (res->flags & 512UL) {
    {
    root = & iomem_resource;
    }
  }
  return (root);
}
}
__inline static int pci_get_legacy_ide_irq(struct pci_dev *dev , int channel ) 
{ int tmp ;

  {
  if (channel) {
    {
    tmp = 15;
    }
  } else {
    {
    tmp = 14;
    }
  }
  return (tmp);
}
}
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;

  {
  {
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 

  {
  {
  dev_set_drvdata(& pdev->dev, data);
  }
  return;
}
}
__inline static char const   *pci_name(struct pci_dev *pdev ) 
{ char const   *tmp ;

  {
  {
  tmp = dev_name((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
__inline static void pci_resource_to_user(struct pci_dev  const  *dev , int bar ,
                                          struct resource  const  *rsrc , resource_size_t *start ,
                                          resource_size_t *end ) 
{ 

  {
  {
  *start = (unsigned int )rsrc->start;
  *end = (unsigned int )rsrc->end;
  }
  return;
}
}
extern void pci_fixup_device(enum pci_fixup_pass pass , struct pci_dev *dev ) ;
extern void *pcim_iomap(struct pci_dev *pdev , int bar , unsigned long maxlen ) ;
extern void pcim_iounmap(struct pci_dev *pdev , void *addr ) ;
extern void * const  *pcim_iomap_table(struct pci_dev *pdev ) ;
extern int pcim_iomap_regions(struct pci_dev *pdev , u16 mask , char const   *name ) ;
extern int pcim_iomap_regions_request_all(struct pci_dev *pdev , u16 mask , char const   *name ) ;
extern void pcim_iounmap_regions(struct pci_dev *pdev , u16 mask ) ;
extern int pci_pci_problems ;
extern unsigned long pci_cardbus_io_size ;
extern unsigned long pci_cardbus_mem_size ;
extern int pcibios_add_platform_entries(struct pci_dev *dev ) ;
extern void pcibios_disable_device(struct pci_dev *dev ) ;
extern int pcibios_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
extern void pci_mmcfg_early_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern void pci_mmcfg_late_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern int pci_ext_cfg_avail(struct pci_dev *dev ) ;
extern void *pci_ioremap_bar(struct pci_dev *pdev , int bar ) ;
__inline static int pci_enable_sriov(struct pci_dev *dev , int nr_virtfn ) 
{ 

  {
  return (-19);
}
}
__inline static void pci_disable_sriov(struct pci_dev *dev ) 
{ 

  {
  return;
}
}
__inline static irqreturn_t pci_sriov_migration(struct pci_dev *dev ) 
{ 

  {
  return ((enum irqreturn )0);
}
}
__inline static void hrtimer_set_expires_range_ns___8(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___8((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
int usb_hcd_pci_probe(struct pci_dev *dev , struct pci_device_id  const  *id ) 
{ struct hc_driver *driver ;
  struct usb_hcd *hcd ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  struct resource *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int region ;
  struct resource *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
  {
  tmp = usb_disabled();
  }
  if (tmp) {
    return (-19);
  }
  if (! id) {
    return (-22);
  }
  {
  driver = (struct hc_driver *)id->driver_data;
  }
  if (! driver) {
    return (-22);
  }
  {
  tmp___0 = pci_enable_device(dev);
  }
  if (tmp___0 < 0) {
    return (-19);
  }
  {
  dev->current_state = 0;
  }
  if (! dev->irq) {
    {
    tmp___1 = pci_name(dev);
    tmp___2 = dev_name((struct device  const  *)(& dev->dev));
    tmp___3 = dev_driver_string((struct device  const  *)(& dev->dev));
    printk("<3>%s %s: Found HC with no IRQ.  Check BIOS/PCI %s setup!\n", tmp___3,
           tmp___2, tmp___1);
    retval = -19;
    }
    goto err1;
  }
  {
  tmp___4 = pci_name(dev);
  hcd = usb_create_hcd((struct hc_driver  const  *)driver, & dev->dev, tmp___4);
  }
  if (! hcd) {
    {
    retval = -12;
    }
    goto err1;
  }
  if (driver->flags & 1) {
    {
    hcd->rsrc_start = (unsigned long long )dev->resource[0].start;
    }
    if (dev->resource[0].start == 0U) {
      if (dev->resource[0].end == dev->resource[0].start) {
        {
        hcd->rsrc_len = 0ULL;
        }
      } else {
        {
        hcd->rsrc_len = (unsigned long long )((dev->resource[0].end - dev->resource[0].start) + 1U);
        }
      }
    } else {
      {
      hcd->rsrc_len = (unsigned long long )((dev->resource[0].end - dev->resource[0].start) + 1U);
      }
    }
    {
    tmp___7 = __request_region(& iomem_resource, (unsigned int )hcd->rsrc_start, (unsigned int )hcd->rsrc_len,
                               driver->description, 0);
    }
    if (! tmp___7) {
      {
      retval = -16;
      }
      goto err2;
    }
    {
    hcd->regs = ioremap_nocache((unsigned int )hcd->rsrc_start, (unsigned long )hcd->rsrc_len);
    }
    if ((unsigned long )hcd->regs == (unsigned long )((void *)0)) {
      {
      retval = -14;
      }
      goto err3;
    }
  } else {
    {
    region = 0;
    }
    {
    while (1) {
      while_463_continue: /* CIL Label */ ;
      if (! (region < 6)) {
        goto while_463_break;
      }
      if (! (dev->resource[region].flags & 256UL)) {
        goto __Cont;
      }
      {
      hcd->rsrc_start = (unsigned long long )dev->resource[region].start;
      }
      if (dev->resource[region].start == 0U) {
        if (dev->resource[region].end == dev->resource[region].start) {
          {
          hcd->rsrc_len = 0ULL;
          }
        } else {
          {
          hcd->rsrc_len = (unsigned long long )((dev->resource[region].end - dev->resource[region].start) + 1U);
          }
        }
      } else {
        {
        hcd->rsrc_len = (unsigned long long )((dev->resource[region].end - dev->resource[region].start) + 1U);
        }
      }
      {
      tmp___10 = __request_region(& ioport_resource, (unsigned int )hcd->rsrc_start,
                                  (unsigned int )hcd->rsrc_len, driver->description,
                                  0);
      }
      if (tmp___10) {
        goto while_463_break;
      }
      __Cont: /* CIL Label */ 
      {
      region ++;
      }
    }
    while_463_break: /* CIL Label */ ;
    }
    if (region == 6) {
      {
      retval = -16;
      }
      goto err1;
    }
  }
  {
  pci_set_master(dev);
  retval = usb_add_hcd(hcd, dev->irq, 160UL);
  }
  if (retval != 0) {
    goto err4;
  }
  return (retval);
  err4: 
  if (driver->flags & 1) {
    {
    iounmap((void volatile   *)hcd->regs);
    }
    err3: 
    {
    __release_region(& iomem_resource, (unsigned int )hcd->rsrc_start, (unsigned int )hcd->rsrc_len);
    }
  } else {
    {
    __release_region(& ioport_resource, (unsigned int )hcd->rsrc_start, (unsigned int )hcd->rsrc_len);
    }
  }
  err2: 
  {
  usb_put_hcd(hcd);
  }
  err1: 
  {
  pci_disable_device(dev);
  tmp___13 = pci_name(dev);
  tmp___14 = dev_name((struct device  const  *)(& dev->dev));
  tmp___15 = dev_driver_string((struct device  const  *)(& dev->dev));
  printk("<3>%s %s: init %s fail, %d\n", tmp___15, tmp___14, tmp___13, retval);
  }
  return (retval);
}
}
static char const   __kstrtab_usb_hcd_pci_probe[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'p',      (char const   )'c',      (char const   )'i',      (char const   )'_', 
        (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'b', 
        (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_pci_probe  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_pci_probe), __kstrtab_usb_hcd_pci_probe};
void usb_hcd_pci_remove(struct pci_dev *dev ) 
{ struct usb_hcd *hcd ;
  void *tmp ;

  {
  {
  tmp = pci_get_drvdata(dev);
  hcd = (struct usb_hcd *)tmp;
  }
  if (! hcd) {
    return;
  }
  {
  usb_remove_hcd(hcd);
  }
  if ((hcd->driver)->flags & 1) {
    {
    iounmap((void volatile   *)hcd->regs);
    __release_region(& iomem_resource, (unsigned int )hcd->rsrc_start, (unsigned int )hcd->rsrc_len);
    }
  } else {
    {
    __release_region(& ioport_resource, (unsigned int )hcd->rsrc_start, (unsigned int )hcd->rsrc_len);
    }
  }
  {
  usb_put_hcd(hcd);
  pci_disable_device(dev);
  }
  return;
}
}
static char const   __kstrtab_usb_hcd_pci_remove[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'p',      (char const   )'c',      (char const   )'i',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_pci_remove  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_pci_remove), __kstrtab_usb_hcd_pci_remove};
int usb_hcd_pci_suspend(struct pci_dev *dev , pm_message_t message ) 
{ struct usb_hcd *hcd ;
  void *tmp ;
  int retval ;
  int wake ;
  int w ;
  int has_pci_pm ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
  {
  tmp = pci_get_drvdata(dev);
  hcd = (struct usb_hcd *)tmp;
  retval = 0;
  }
  if (! (hcd->state == 4)) {
    if (! (hcd->state == 0)) {
      {
      tmp___0 = dev_name((struct device  const  *)(& dev->dev));
      tmp___1 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<4>%s %s: Root hub is not suspended\n", tmp___1, tmp___0);
      retval = -16;
      }
      goto done;
    }
  }
  if (dev->current_state != 0) {
    goto done;
  }
  if ((hcd->driver)->pci_suspend) {
    {
    retval = (*((hcd->driver)->pci_suspend))(hcd, message);
    }
    {
    while (1) {
      while_464_continue: /* CIL Label */ ;
      {
      __suspend_report_result("usb_hcd_pci_suspend", (void *)(hcd->driver)->pci_suspend,
                              retval);
      }
      goto while_464_break;
    }
    while_464_break: /* CIL Label */ ;
    }
    if (retval) {
      goto done;
    }
  }
  {
  synchronize_irq(dev->irq);
  pci_disable_device(dev);
  pci_save_state(dev);
  }
  if (hcd->state == 4) {
    {
    tmp___2 = device_may_wakeup(& dev->dev);
    }
    if (tmp___2) {
      {
      tmp___3 = 1;
      }
    } else {
      {
      tmp___3 = 0;
      }
    }
  } else {
    {
    tmp___3 = 0;
    }
  }
  {
  wake = tmp___3;
  w = pci_wake_from_d3(dev, (_Bool )wake);
  }
  if (w < 0) {
    {
    wake = w;
    }
  }
  if (message.event == 1) {
    goto done;
  } else {
    if (message.event == 8) {
      goto done;
    }
  }
  {
  has_pci_pm = pci_find_capability(dev, 1);
  }
  if (! (! has_pci_pm)) {
    {
    retval = pci_set_power_state(dev, 3);
    }
    {
    while (1) {
      while_465_continue: /* CIL Label */ ;
      {
      __suspend_report_result("usb_hcd_pci_suspend", (void *)(& pci_set_power_state),
                              retval);
      }
      goto while_465_break;
    }
    while_465_break: /* CIL Label */ ;
    }
    if (! (retval == 0)) {
      {
      pci_restore_state(dev);
      }
    }
  }
  done: 
  return (retval);
}
}
static char const   __kstrtab_usb_hcd_pci_suspend[20]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'p',      (char const   )'c',      (char const   )'i',      (char const   )'_', 
        (char const   )'s',      (char const   )'u',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'n',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_pci_suspend  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_pci_suspend), __kstrtab_usb_hcd_pci_suspend};
int usb_hcd_pci_resume(struct pci_dev *dev ) 
{ struct usb_hcd *hcd ;
  int retval ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
  pci_restore_state(dev);
  tmp = pci_get_drvdata(dev);
  hcd = (struct usb_hcd *)tmp;
  }
  if (hcd->state != 4) {
    return (0);
  }
  {
  pci_enable_wake(dev, 0, 0);
  retval = pci_enable_device(dev);
  }
  if (retval < 0) {
    {
    tmp___2 = dev_name((struct device  const  *)(& dev->dev));
    tmp___3 = dev_driver_string((struct device  const  *)(& dev->dev));
    printk("<3>%s %s: can\'t re-enable after resume, %d!\n", tmp___3, tmp___2, retval);
    }
    return (retval);
  }
  {
  pci_set_master(dev);
  pci_wake_from_d3(dev, (_Bool)0);
  clear_bit(2, (unsigned long volatile   *)(& hcd->flags));
  }
  if ((hcd->driver)->pci_resume) {
    {
    retval = (*((hcd->driver)->pci_resume))(hcd);
    }
    if (retval) {
      {
      tmp___4 = dev_name((struct device  const  *)hcd->self.controller);
      tmp___5 = dev_driver_string((struct device  const  *)hcd->self.controller);
      printk("<3>%s %s: PCI post-resume error %d!\n", tmp___5, tmp___4, retval);
      usb_hc_died(hcd);
      }
    }
  }
  return (retval);
}
}
static char const   __kstrtab_usb_hcd_pci_resume[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'p',      (char const   )'c',      (char const   )'i',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'u', 
        (char const   )'m',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_pci_resume  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_pci_resume), __kstrtab_usb_hcd_pci_resume};
void usb_hcd_pci_shutdown(struct pci_dev *dev ) 
{ struct usb_hcd *hcd ;
  void *tmp ;

  {
  {
  tmp = pci_get_drvdata(dev);
  hcd = (struct usb_hcd *)tmp;
  }
  if (! hcd) {
    return;
  }
  if ((hcd->driver)->shutdown) {
    {
    (*((hcd->driver)->shutdown))(hcd);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_hcd_pci_shutdown[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'c',      (char const   )'d',      (char const   )'_', 
        (char const   )'p',      (char const   )'c',      (char const   )'i',      (char const   )'_', 
        (char const   )'s',      (char const   )'h',      (char const   )'u',      (char const   )'t', 
        (char const   )'d',      (char const   )'o',      (char const   )'w',      (char const   )'n', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hcd_pci_shutdown  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hcd_pci_shutdown), __kstrtab_usb_hcd_pci_shutdown};
static unsigned long __force_order___9  ;
__inline static unsigned long native_read_cr0___9(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___9));
  }
  return (val);
}
}
__inline static void native_write_cr0___9(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___9));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___9(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___9));
  }
  return (val);
}
}
__inline static void native_write_cr2___9(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___9));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___9(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___9));
  }
  return (val);
}
}
__inline static void native_write_cr3___9(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___9));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___9(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___9));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___9(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___9): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___9(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___9));
  }
  return;
}
}
__inline static void load_cr3___9(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___9((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___9(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___9();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___9((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___9(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___9();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___9((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___9(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___4 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___9(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___9(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___9(u64 ns ) ;
static union ktime  const  ktime_zero___9  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___9(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___9.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___9(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___9((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___12  ;
extern struct task_struct *( /* format attribute */  kthread_create)(int (*threadfn)(void *data ) ,
                                                                     void *data ,
                                                                     char const   *namefmt 
                                                                     , ...) ;
extern void kthread_bind(struct task_struct *k , unsigned int cpu ) ;
extern int kthread_stop(struct task_struct *k ) ;
extern int kthread_should_stop(void) ;
extern int kthreadd(void *unused ) ;
extern struct task_struct *kthreadd_task ;
__inline static int frozen(struct task_struct *p ) 
{ 

  {
  return ((int )(p->flags & 65536U));
}
}
__inline static int freezing(struct task_struct *p ) 
{ int tmp ;

  {
  {
  tmp = test_tsk_thread_flag(p, 23);
  }
  return (tmp);
}
}
__inline static void set_freeze_flag(struct task_struct *p ) 
{ 

  {
  {
  set_tsk_thread_flag(p, 23);
  }
  return;
}
}
__inline static void clear_freeze_flag(struct task_struct *p ) 
{ 

  {
  {
  clear_tsk_thread_flag(p, 23);
  }
  return;
}
}
__inline static bool should_send_signal(struct task_struct *p ) 
{ 

  {
  return ((_Bool )(! (p->flags & 2147483648U)));
}
}
extern int thaw_process(struct task_struct *p ) ;
extern void refrigerator(void) ;
extern int freeze_processes(void) ;
extern void thaw_processes(void) ;
__inline static int try_to_freeze(void) 
{ struct task_struct *tmp ;
  int tmp___0 ;

  {
  {
  tmp = get_current();
  tmp___0 = freezing(tmp);
  }
  if (tmp___0) {
    {
    refrigerator();
    }
    return (1);
  } else {
    return (0);
  }
}
}
extern bool freeze_task(struct task_struct *p , bool sig_only ) ;
extern void cancel_freezing(struct task_struct *p ) ;
extern int cgroup_frozen(struct task_struct *task ) ;
__inline static void freezer_do_not_count(void) 
{ struct task_struct *tmp ;
  struct task_struct *tmp___0 ;

  {
  {
  tmp___0 = get_current();
  }
  if (tmp___0->mm) {
    {
    tmp = get_current();
    tmp->flags |= 1073741824U;
    }
  }
  return;
}
}
__inline static void freezer_count(void) 
{ struct task_struct *tmp ;
  struct task_struct *tmp___0 ;

  {
  {
  tmp___0 = get_current();
  }
  if (tmp___0->mm) {
    {
    tmp = get_current();
    tmp->flags &= 3221225471U;
    try_to_freeze();
    }
  }
  return;
}
}
__inline static int freezer_should_skip(struct task_struct *p ) 
{ 

  {
  return (! (! (p->flags & 1073741824U)));
}
}
__inline static void set_freezable(void) 
{ struct task_struct *tmp ;

  {
  {
  tmp = get_current();
  tmp->flags &= 4294934527U;
  }
  return;
}
}
__inline static void set_freezable_with_signal(void) 
{ struct task_struct *tmp ;

  {
  {
  tmp = get_current();
  tmp->flags &= 2147450879U;
  }
  return;
}
}
static spinlock_t device_state_lock  =    {{0U}};
static spinlock_t hub_event_lock  =    {{0U}};
static struct list_head hub_event_list  =    {& hub_event_list, & hub_event_list};
static wait_queue_head_t khubd_wait  =    {{{0U}}, {& khubd_wait.task_list, & khubd_wait.task_list}};
static struct task_struct *khubd_task  ;
static int blinkenlights  =    0;
__inline static int *__check_blinkenlights(void) 
{ 

  {
  return (& blinkenlights);
}
}
static int __param_perm_check_blinkenlights  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
static char const   __param_str_blinkenlights[25]  = 
  {      (char const   )'S',      (char const   )'o',      (char const   )'m',      (char const   )'e', 
        (char const   )'M',      (char const   )'o',      (char const   )'d',      (char const   )'u', 
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'b', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'k', 
        (char const   )'e',      (char const   )'n',      (char const   )'l',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )'s', 
        (char const   )'\000'};
static struct kernel_param  const  __param_blinkenlights  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_blinkenlights, 292U, & param_set_bool, & param_get_bool, {(void *)(& blinkenlights)}};
static int initial_descriptor_timeout  =    5000;
__inline static int *__check_initial_descriptor_timeout(void) 
{ 

  {
  return (& initial_descriptor_timeout);
}
}
static int __param_perm_check_initial_descriptor_timeout  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
static char const   __param_str_initial_descriptor_timeout[38]  = 
  {      (char const   )'S',      (char const   )'o',      (char const   )'m',      (char const   )'e', 
        (char const   )'M',      (char const   )'o',      (char const   )'d',      (char const   )'u', 
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'i', 
        (char const   )'n',      (char const   )'i',      (char const   )'t',      (char const   )'i', 
        (char const   )'a',      (char const   )'l',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'s',      (char const   )'c',      (char const   )'r', 
        (char const   )'i',      (char const   )'p',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'_',      (char const   )'t',      (char const   )'i', 
        (char const   )'m',      (char const   )'e',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'\000'};
static struct kernel_param  const  __param_initial_descriptor_timeout  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_initial_descriptor_timeout, 420U, & param_set_int, & param_get_int,
    {(void *)(& initial_descriptor_timeout)}};
static int old_scheme_first  =    0;
__inline static int *__check_old_scheme_first(void) 
{ 

  {
  return (& old_scheme_first);
}
}
static int __param_perm_check_old_scheme_first  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
static char const   __param_str_old_scheme_first[28]  = 
  {      (char const   )'S',      (char const   )'o',      (char const   )'m',      (char const   )'e', 
        (char const   )'M',      (char const   )'o',      (char const   )'d',      (char const   )'u', 
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'o', 
        (char const   )'l',      (char const   )'d',      (char const   )'_',      (char const   )'s', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'m', 
        (char const   )'e',      (char const   )'_',      (char const   )'f',      (char const   )'i', 
        (char const   )'r',      (char const   )'s',      (char const   )'t',      (char const   )'\000'};
static struct kernel_param  const  __param_old_scheme_first  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_old_scheme_first, 420U, & param_set_bool, & param_get_bool, {(void *)(& old_scheme_first)}};
static int use_both_schemes  =    1;
__inline static int *__check_use_both_schemes(void) 
{ 

  {
  return (& use_both_schemes);
}
}
static int __param_perm_check_use_both_schemes  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
static char const   __param_str_use_both_schemes[28]  = 
  {      (char const   )'S',      (char const   )'o',      (char const   )'m',      (char const   )'e', 
        (char const   )'M',      (char const   )'o',      (char const   )'d',      (char const   )'u', 
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )'_',      (char const   )'b', 
        (char const   )'o',      (char const   )'t',      (char const   )'h',      (char const   )'_', 
        (char const   )'s',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'m',      (char const   )'e',      (char const   )'s',      (char const   )'\000'};
static struct kernel_param  const  __param_use_both_schemes  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_use_both_schemes, 420U, & param_set_bool, & param_get_bool, {(void *)(& use_both_schemes)}};
struct rw_semaphore ehci_cf_port_reset_rwsem  =    {0L,
    {{0U}}, {& ehci_cf_port_reset_rwsem.wait_list, & ehci_cf_port_reset_rwsem.wait_list}};
static char const   __kstrtab_ehci_cf_port_reset_rwsem[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'e',      (char const   )'h',      (char const   )'c',      (char const   )'i', 
        (char const   )'_',      (char const   )'c',      (char const   )'f',      (char const   )'_', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'_',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'_',      (char const   )'r', 
        (char const   )'w',      (char const   )'s',      (char const   )'e',      (char const   )'m', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_ehci_cf_port_reset_rwsem  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& ehci_cf_port_reset_rwsem), __kstrtab_ehci_cf_port_reset_rwsem};
static int usb_reset_and_verify_device(struct usb_device *udev ) ;
__inline static char *portspeed(int portstatus ) 
{ 

  {
  if (portstatus & (1 << 10)) {
    return ((char *)"480 Mb/s");
  } else {
    if (portstatus & (1 << 9)) {
      return ((char *)"1.5 Mb/s");
    } else {
      return ((char *)"12 Mb/s");
    }
  }
}
}
__inline static struct usb_hub *hdev_to_hub(struct usb_device *hdev ) 
{ void *tmp ;

  {
  {
  tmp = usb_get_intfdata((hdev->actconfig)->interface[0]);
  }
  return ((struct usb_hub *)tmp);
}
}
static int get_hub_descriptor(struct usb_device *hdev , void *data , int size ) 
{ int i ;
  int ret ;
  unsigned int tmp ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_466_continue: /* CIL Label */ ;
    if (! (i < 3)) {
      goto while_466_break;
    }
    {
    tmp = __create_pipe(hdev, 0U);
    ret = usb_control_msg(hdev, ((unsigned int )(2 << 30) | tmp) | 128U, (unsigned char)6,
                          (unsigned char )(128 | (1 << 5)), (unsigned short )(((1 << 5) | 9) << 8),
                          (unsigned short)0, data, (unsigned short )size, 5000);
    }
    if (ret >= 9) {
      return (ret);
    }
    {
    i ++;
    }
  }
  while_466_break: /* CIL Label */ ;
  }
  return (-22);
}
}
static int clear_hub_feature(struct usb_device *hdev , int feature ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
  tmp = __create_pipe(hdev, 0U);
  tmp___0 = usb_control_msg(hdev, (unsigned int )(2 << 30) | tmp, (unsigned char)1,
                            (unsigned char )(1 << 5), (unsigned short )feature, (unsigned short)0,
                            (void *)0, (unsigned short)0, 1000);
  }
  return (tmp___0);
}
}
static int clear_port_feature(struct usb_device *hdev , int port1 , int feature ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
  tmp = __create_pipe(hdev, 0U);
  tmp___0 = usb_control_msg(hdev, (unsigned int )(2 << 30) | tmp, (unsigned char)1,
                            (unsigned char )((1 << 5) | 3), (unsigned short )feature,
                            (unsigned short )port1, (void *)0, (unsigned short)0,
                            1000);
  }
  return (tmp___0);
}
}
static int set_port_feature(struct usb_device *hdev , int port1 , int feature ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
  tmp = __create_pipe(hdev, 0U);
  tmp___0 = usb_control_msg(hdev, (unsigned int )(2 << 30) | tmp, (unsigned char)3,
                            (unsigned char )((1 << 5) | 3), (unsigned short )feature,
                            (unsigned short )port1, (void *)0, (unsigned short)0,
                            1000);
  }
  return (tmp___0);
}
}
static void set_port_led(struct usb_hub *hub , int port1 , int selector ) 
{ int status ;
  int tmp ;
  char *s ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  tmp = set_port_feature(hub->hdev, (selector << 8) | port1, 22);
  status = tmp;
  }
  if (status < 0) {
    if (0) {
      if (selector == 1) {
        goto switch_467_1;
      } else {
        if (selector == 2) {
          goto switch_467_2;
        } else {
          if (selector == 3) {
            goto switch_467_3;
          } else {
            if (selector == 0) {
              goto switch_467_0;
            } else {
              {
              goto switch_467_default;
              if (0) {
                switch_467_1: /* CIL Label */ 
                {
                s = (char *)"amber";
                }
                goto switch_467_break;
                switch_467_2: /* CIL Label */ 
                {
                s = (char *)"green";
                }
                goto switch_467_break;
                switch_467_3: /* CIL Label */ 
                {
                s = (char *)"off";
                }
                goto switch_467_break;
                switch_467_0: /* CIL Label */ 
                {
                s = (char *)"auto";
                }
                goto switch_467_break;
                switch_467_default: /* CIL Label */ 
                {
                s = (char *)"??";
                }
                goto switch_467_break;
              } else {
                switch_467_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
      {
      tmp___0 = dev_name((struct device  const  *)hub->intfdev);
      tmp___1 = dev_driver_string((struct device  const  *)hub->intfdev);
      printk("<7>%s %s: port %d indicator %s status %d\n", tmp___1, tmp___0, port1,
             s, status);
      }
    }
  }
  return;
}
}
static void led_work(struct work_struct *work ) 
{ struct usb_hub *hub ;
  struct work_struct  const  *__mptr ;
  struct usb_device *hdev ;
  unsigned int i ;
  unsigned int changed ;
  int cursor ;
  unsigned int selector ;
  unsigned int mode ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  hub = (struct usb_hub *)((char *)__mptr - (unsigned int )(& ((struct usb_hub *)0)->leds.work));
  hdev = hub->hdev;
  changed = 0U;
  cursor = -1;
  }
  if ((unsigned int )hdev->state != 7U) {
    return;
  } else {
    if (hub->quiescing) {
      return;
    }
  }
  {
  i = 0U;
  }
  {
  while (1) {
    while_468_continue: /* CIL Label */ ;
    if (! (i < (unsigned int )(hub->descriptor)->bNbrPorts)) {
      goto while_468_break;
    }
    if ((int )hub->indicator[i] == 1) {
      goto switch_469_1;
    } else {
      if ((int )hub->indicator[i] == 2) {
        goto switch_469_2;
      } else {
        if ((int )hub->indicator[i] == 3) {
          goto switch_469_3;
        } else {
          if ((int )hub->indicator[i] == 4) {
            goto switch_469_4;
          } else {
            if ((int )hub->indicator[i] == 5) {
              goto switch_469_5;
            } else {
              if ((int )hub->indicator[i] == 6) {
                goto switch_469_6;
              } else {
                if ((int )hub->indicator[i] == 7) {
                  goto switch_469_7;
                } else {
                  {
                  goto switch_469_default;
                  if (0) {
                    switch_469_1: /* CIL Label */ 
                    {
                    cursor = (int )i;
                    selector = 0U;
                    mode = 0U;
                    }
                    goto switch_469_break;
                    switch_469_2: /* CIL Label */ 
                    {
                    selector = 2U;
                    mode = 3U;
                    }
                    goto switch_469_break;
                    switch_469_3: /* CIL Label */ 
                    {
                    selector = 3U;
                    mode = 2U;
                    }
                    goto switch_469_break;
                    switch_469_4: /* CIL Label */ 
                    {
                    selector = 1U;
                    mode = 5U;
                    }
                    goto switch_469_break;
                    switch_469_5: /* CIL Label */ 
                    {
                    selector = 3U;
                    mode = 4U;
                    }
                    goto switch_469_break;
                    switch_469_6: /* CIL Label */ 
                    {
                    selector = 2U;
                    mode = 7U;
                    }
                    goto switch_469_break;
                    switch_469_7: /* CIL Label */ 
                    {
                    selector = 1U;
                    mode = 6U;
                    }
                    goto switch_469_break;
                    switch_469_default: /* CIL Label */ 
                    {

                    }
                    goto __Cont;
                  } else {
                    switch_469_break: /* CIL Label */ ;
                  }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (selector != 0U) {
      {
      changed = 1U;
      }
    }
    {
    set_port_led(hub, (int )(i + 1U), (int )selector);
    hub->indicator[i] = (unsigned char )mode;
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_468_break: /* CIL Label */ ;
  }
  if (! changed) {
    if (blinkenlights) {
      {
      cursor ++;
      cursor %= (int )(hub->descriptor)->bNbrPorts;
      set_port_led(hub, cursor + 1, 2);
      hub->indicator[cursor] = (unsigned char)1;
      changed ++;
      }
    }
  }
  if (changed) {
    {
    schedule_delayed_work(& hub->leds, 666UL);
    }
  }
  return;
}
}
static int get_hub_status(struct usb_device *hdev , struct usb_hub_status *data ) 
{ int i ;
  int status ;
  unsigned int tmp ;

  {
  {
  status = -110;
  i = 0;
  }
  {
  while (1) {
    while_470_continue: /* CIL Label */ ;
    if (i < 5) {
      if (! (status == -110)) {
        goto while_470_break;
      }
    } else {
      goto while_470_break;
    }
    {
    tmp = __create_pipe(hdev, 0U);
    status = usb_control_msg(hdev, ((unsigned int )(2 << 30) | tmp) | 128U, (unsigned char)0,
                             (unsigned char )(128 | (1 << 5)), (unsigned short)0,
                             (unsigned short)0, (void *)data, (unsigned short )sizeof(*data),
                             1000);
    i ++;
    }
  }
  while_470_break: /* CIL Label */ ;
  }
  return (status);
}
}
static int get_port_status(struct usb_device *hdev , int port1 , struct usb_port_status *data ) 
{ int i ;
  int status ;
  unsigned int tmp ;

  {
  {
  status = -110;
  i = 0;
  }
  {
  while (1) {
    while_471_continue: /* CIL Label */ ;
    if (i < 5) {
      if (! (status == -110)) {
        goto while_471_break;
      }
    } else {
      goto while_471_break;
    }
    {
    tmp = __create_pipe(hdev, 0U);
    status = usb_control_msg(hdev, ((unsigned int )(2 << 30) | tmp) | 128U, (unsigned char)0,
                             (unsigned char )(128 | ((1 << 5) | 3)), (unsigned short)0,
                             (unsigned short )port1, (void *)data, (unsigned short )sizeof(*data),
                             1000);
    i ++;
    }
  }
  while_471_break: /* CIL Label */ ;
  }
  return (status);
}
}
static int hub_port_status(struct usb_hub *hub , int port1 , u16 *status , u16 *change ) 
{ int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  mutex_lock(& hub->status_mutex);
  ret = get_port_status(hub->hdev, port1, & (hub->status)->port);
  }
  if (ret < 4) {
    {
    tmp = dev_name((struct device  const  *)hub->intfdev);
    tmp___0 = dev_driver_string((struct device  const  *)hub->intfdev);
    printk("<3>%s %s: %s failed (err = %d)\n", tmp___0, tmp, "hub_port_status", ret);
    }
    if (ret >= 0) {
      {
      ret = -5;
      }
    }
  } else {
    {
    *status = (hub->status)->port.wPortStatus;
    *change = (hub->status)->port.wPortChange;
    ret = 0;
    }
  }
  {
  mutex_unlock(& hub->status_mutex);
  }
  return (ret);
}
}
static void kick_khubd(struct usb_hub *hub ) 
{ unsigned long flags ;
  struct device  const  *__mptr ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int tmp ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  __mptr = (struct device  const  *)hub->intfdev;
  ((struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev)))->pm_usage_cnt = 1;
  }
  {
  while (1) {
    while_472_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& hub_event_lock);
    }
    goto while_472_break;
  }
  while_472_break: /* CIL Label */ ;
  }
  if (! hub->disconnected) {
    {
    tmp = list_empty((struct list_head  const  *)(& hub->event_list));
    }
    if (tmp) {
      {
      list_add_tail(& hub->event_list, & hub_event_list);
      __wake_up(& khubd_wait, 3U, 1, (void *)0);
      }
    }
  }
  {
  while (1) {
    while_473_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& hub_event_lock, flags);
    }
    goto while_473_break;
  }
  while_473_break: /* CIL Label */ ;
  }
  return;
}
}
void usb_kick_khubd(struct usb_device *hdev ) 
{ struct usb_hub *tmp ;

  {
  {
  tmp = hdev_to_hub(hdev);
  kick_khubd(tmp);
  }
  return;
}
}
static void hub_irq(struct urb *urb ) 
{ struct usb_hub *hub ;
  int status ;
  unsigned int i ;
  unsigned long bits ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  hub = (struct usb_hub *)urb->context;
  status = urb->status;
  }
  if (status == -2) {
    goto switch_474_neg_2;
  } else {
    if (status == -104) {
      goto switch_474_neg_2;
    } else {
      if (status == -108) {
        goto switch_474_neg_2;
      } else {
        if (status == 0) {
          goto switch_474_0;
        } else {
          {
          goto switch_474_default;
          if (0) {
            switch_474_neg_2: /* CIL Label */ 
            switch_474_neg_104: /* CIL Label */ 
            switch_474_neg_108: /* CIL Label */ 
            return;
            switch_474_default: /* CIL Label */ 
            {
            (hub->nerrors) ++;
            }
            if (hub->nerrors < 10) {
              goto resubmit;
            } else {
              if (hub->error) {
                goto resubmit;
              }
            }
            {
            hub->error = status;
            }
            switch_474_0: /* CIL Label */ 
            {
            bits = 0UL;
            i = 0U;
            }
            {
            while (1) {
              while_475_continue: /* CIL Label */ ;
              if (! (i < urb->actual_length)) {
                goto while_475_break;
              }
              {
              bits |= (unsigned long )(*(hub->buffer))[i] << i * 8U;
              i ++;
              }
            }
            while_475_break: /* CIL Label */ ;
            }
            {
            hub->event_bits[0] = bits;
            }
            goto switch_474_break;
          } else {
            switch_474_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  hub->nerrors = 0;
  kick_khubd(hub);
  }
  resubmit: 
  if (hub->quiescing) {
    return;
  }
  {
  status = usb_submit_urb(hub->urb, 32U);
  }
  if (status != 0) {
    if (status != -19) {
      if (status != -1) {
        {
        tmp___1 = dev_name((struct device  const  *)hub->intfdev);
        tmp___2 = dev_driver_string((struct device  const  *)hub->intfdev);
        printk("<3>%s %s: resubmit --> %d\n", tmp___2, tmp___1, status);
        }
      }
    }
  }
  return;
}
}
__inline static int hub_clear_tt_buffer(struct usb_device *hdev , u16 devinfo , u16 tt ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
  tmp = __create_pipe(hdev, 0U);
  tmp___0 = usb_control_msg(hdev, ((unsigned int )(2 << 30) | tmp) | 128U, (unsigned char)8,
                            (unsigned char )((1 << 5) | 3), devinfo, tt, (void *)0,
                            (unsigned short)0, 1000);
  }
  return (tmp___0);
}
}
static void hub_tt_work(struct work_struct *work ) 
{ struct usb_hub *hub ;
  struct work_struct  const  *__mptr ;
  unsigned long flags ;
  int limit ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head *temp ;
  struct usb_tt_clear *clear ;
  struct usb_device *hdev ;
  struct hc_driver  const  *drv ;
  int status ;
  struct list_head  const  *__mptr___0 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  hub = (struct usb_hub *)((char *)__mptr - (unsigned int )(& ((struct usb_hub *)0)->tt.clear_work));
  limit = 100;
  }
  {
  while (1) {
    while_476_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& hub->tt.lock);
    }
    goto while_476_break;
  }
  while_476_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_477_continue: /* CIL Label */ ;
    {
    limit --;
    }
    if (limit) {
      {
      tmp___1 = list_empty((struct list_head  const  *)(& hub->tt.clear_list));
      }
      if (tmp___1) {
        goto while_477_break;
      }
    } else {
      goto while_477_break;
    }
    {
    hdev = hub->hdev;
    temp = hub->tt.clear_list.next;
    __mptr___0 = (struct list_head  const  *)temp;
    clear = (struct usb_tt_clear *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_tt_clear *)0)->clear_list));
    list_del(& clear->clear_list);
    }
    {
    while (1) {
      while_478_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& hub->tt.lock, flags);
      }
      goto while_478_break;
    }
    while_478_break: /* CIL Label */ ;
    }
    {
    status = hub_clear_tt_buffer(hdev, clear->devinfo, (unsigned short )clear->tt);
    }
    if (status) {
      {
      tmp = dev_name((struct device  const  *)(& hdev->dev));
      tmp___0 = dev_driver_string((struct device  const  *)(& hdev->dev));
      printk("<3>%s %s: clear tt %d (%04x) error %d\n", tmp___0, tmp, clear->tt, clear->devinfo,
             status);
      }
    }
    {
    drv = (clear->hcd)->driver;
    }
    if (drv->clear_tt_buffer_complete) {
      {
      (*(drv->clear_tt_buffer_complete))(clear->hcd, clear->ep);
      }
    }
    {
    kfree((void const   *)clear);
    }
    {
    while (1) {
      while_479_continue: /* CIL Label */ ;
      {
      flags = _spin_lock_irqsave(& hub->tt.lock);
      }
      goto while_479_break;
    }
    while_479_break: /* CIL Label */ ;
    }
  }
  while_477_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_480_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& hub->tt.lock, flags);
    }
    goto while_480_break;
  }
  while_480_break: /* CIL Label */ ;
  }
  return;
}
}
int usb_hub_clear_tt_buffer(struct urb *urb ) 
{ struct usb_device *udev ;
  int pipe ;
  struct usb_tt *tt ;
  unsigned long flags ;
  struct usb_tt_clear *clear ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  udev = urb->dev;
  pipe = (int )urb->pipe;
  tt = udev->tt;
  tmp___1 = kmalloc((unsigned int )sizeof(*clear), 32U);
  clear = (struct usb_tt_clear *)tmp___1;
  }
  if ((unsigned long )clear == (unsigned long )((void *)0)) {
    {
    tmp = dev_name((struct device  const  *)(& udev->dev));
    tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<3>%s %s: can\'t save CLEAR_TT_BUFFER state\n", tmp___0, tmp);
    }
    return (-12);
  }
  if (tt->multi) {
    {
    clear->tt = (unsigned int )udev->ttport;
    }
  } else {
    {
    clear->tt = 1U;
    }
  }
  {
  clear->devinfo = (unsigned short )((pipe >> 15) & 15);
  clear->devinfo = (unsigned short )((int )clear->devinfo | (udev->devnum << 4));
  }
  if (((pipe >> 30) & 3) == 2) {
    {
    tmp___2 = 0;
    }
  } else {
    {
    tmp___2 = 2 << 11;
    }
  }
  {
  clear->devinfo = (unsigned short )((int )clear->devinfo | tmp___2);
  }
  if (pipe & 128) {
    {
    clear->devinfo = (unsigned short )((int )clear->devinfo | (1 << 15));
    }
  }
  {
  clear->hcd = bus_to_hcd(udev->bus);
  clear->ep = urb->ep;
  }
  {
  while (1) {
    while_481_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& tt->lock);
    }
    goto while_481_break;
  }
  while_481_break: /* CIL Label */ ;
  }
  {
  list_add_tail(& clear->clear_list, & tt->clear_list);
  schedule_work(& tt->clear_work);
  }
  {
  while (1) {
    while_482_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& tt->lock, flags);
    }
    goto while_482_break;
  }
  while_482_break: /* CIL Label */ ;
  }
  return (0);
}
}
static char const   __kstrtab_usb_hub_clear_tt_buffer[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'h',      (char const   )'u',      (char const   )'b',      (char const   )'_', 
        (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'r',      (char const   )'_',      (char const   )'t',      (char const   )'t', 
        (char const   )'_',      (char const   )'b',      (char const   )'u',      (char const   )'f', 
        (char const   )'f',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_hub_clear_tt_buffer  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_hub_clear_tt_buffer), __kstrtab_usb_hub_clear_tt_buffer};
static unsigned int hub_power_on(struct usb_hub *hub ,
                                 bool do_delay ) 
{ int port1 ;
  unsigned int pgood_delay ;
  unsigned int delay ;
  u16 wHubCharacteristics ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned int _max1 ;
  unsigned int _max2 ;
  unsigned int tmp___3 ;

  {
  {
  pgood_delay = (unsigned int )((int )(hub->descriptor)->bPwrOn2PwrGood * 2);
  wHubCharacteristics = (hub->descriptor)->wHubCharacteristics;
  }
  if (((int )wHubCharacteristics & 3) < 2) {

  }
  {
  port1 = 1;
  }
  {
  while (1) {
    while_483_continue: /* CIL Label */ ;
    if (! (port1 <= (int )(hub->descriptor)->bNbrPorts)) {
      goto while_483_break;
    }
    {
    set_port_feature(hub->hdev, port1, 8);
    port1 ++;
    }
  }
  while_483_break: /* CIL Label */ ;
  }
  {
  _max1 = pgood_delay;
  _max2 = 100U;
  }
  if (_max1 > _max2) {
    {
    tmp___3 = _max1;
    }
  } else {
    {
    tmp___3 = _max2;
    }
  }
  {
  delay = tmp___3;
  }
  if (do_delay) {
    {
    msleep(delay);
    }
  }
  return (delay);
}
}
static int hub_hub_status(struct usb_hub *hub , u16 *status , u16 *change ) 
{ int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  mutex_lock(& hub->status_mutex);
  ret = get_hub_status(hub->hdev, & (hub->status)->hub);
  }
  if (ret < 0) {
    {
    tmp = dev_name((struct device  const  *)hub->intfdev);
    tmp___0 = dev_driver_string((struct device  const  *)hub->intfdev);
    printk("<3>%s %s: %s failed (err = %d)\n", tmp___0, tmp, "hub_hub_status", ret);
    }
  } else {
    {
    *status = (hub->status)->hub.wHubStatus;
    *change = (hub->status)->hub.wHubChange;
    ret = 0;
    }
  }
  {
  mutex_unlock(& hub->status_mutex);
  }
  return (ret);
}
}
static int hub_port_disable(struct usb_hub *hub , int port1 , int set_state ) 
{ struct usb_device *hdev ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  hdev = hub->hdev;
  ret = 0;
  }
  if (hdev->children[port1 - 1]) {
    if (set_state) {
      {
      usb_set_device_state(hdev->children[port1 - 1], (enum usb_device_state )0);
      }
    }
  }
  if (! hub->error) {
    {
    ret = clear_port_feature(hdev, port1, 1);
    }
  }
  if (ret) {
    {
    tmp = dev_name((struct device  const  *)hub->intfdev);
    tmp___0 = dev_driver_string((struct device  const  *)hub->intfdev);
    printk("<3>%s %s: cannot disable port %d (err = %d)\n", tmp___0, tmp, port1, ret);
    }
  }
  return (ret);
}
}
static void hub_port_logical_disconnect(struct usb_hub *hub , int port1 ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  hub_port_disable(hub, port1, 1);
  set_bit((unsigned int )port1, (unsigned long volatile   *)(hub->change_bits));
  kick_khubd(hub);
  }
  return;
}
}
static void hub_init_func2(struct work_struct *ws ) ;
static void hub_init_func3(struct work_struct *ws ) ;
static void hub_activate(struct usb_hub *hub , enum hub_activation_type type ) 
{ struct usb_device *hdev ;
  int port1 ;
  int status ;
  bool need_debounce_delay ;
  unsigned int delay ;
  unsigned long tmp ;
  struct device  const  *__mptr ;
  struct usb_device *udev ;
  u16 portstatus ;
  u16 portchange ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned long tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
  hdev = hub->hdev;
  need_debounce_delay = (bool )0;
  }
  if ((unsigned int )type == 1U) {
    goto init2;
  }
  if ((unsigned int )type == 2U) {
    goto init3;
  }
  if ((unsigned int )type != 4U) {
    if ((unsigned int )type == 0U) {
      {
      delay = hub_power_on(hub, (_Bool)0);
      }
      {
      while (1) {
        while_484_continue: /* CIL Label */ ;
        {
        hub->init_work.work.func = & hub_init_func2;
        }
        goto while_484_break;
      }
      while_484_break: /* CIL Label */ ;
      }
      {
      tmp = msecs_to_jiffies(delay);
      schedule_delayed_work(& hub->init_work, tmp);
      __mptr = (struct device  const  *)hub->intfdev;
      ((struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev)))->pm_usage_cnt = 1;
      }
      return;
    } else {
      {
      hub_power_on(hub, (_Bool)1);
      }
    }
  }
  init2: 
  {
  port1 = 1;
  }
  {
  while (1) {
    while_485_continue: /* CIL Label */ ;
    if (! (port1 <= hdev->maxchild)) {
      goto while_485_break;
    }
    {
    udev = hdev->children[port1 - 1];
    portchange = (unsigned short)0;
    portstatus = portchange;
    status = hub_port_status(hub, port1, & portstatus, & portchange);
    }
    if (! udev) {
      if ((int )portstatus & 1) {

      }
    }
    if ((int )portstatus & 2) {
      if ((unsigned int )type != 4U) {
        {
        clear_port_feature(hdev, port1, 1);
        portstatus = (unsigned short )((int )portstatus & -3);
        }
      } else {
        if (! ((int )portstatus & 1)) {
          {
          clear_port_feature(hdev, port1, 1);
          portstatus = (unsigned short )((int )portstatus & -3);
          }
        } else {
          if (! udev) {
            {
            clear_port_feature(hdev, port1, 1);
            portstatus = (unsigned short )((int )portstatus & -3);
            }
          } else {
            if ((unsigned int )udev->state == 0U) {
              {
              clear_port_feature(hdev, port1, 1);
              portstatus = (unsigned short )((int )portstatus & -3);
              }
            }
          }
        }
      }
    }
    if ((int )portchange & 1) {
      {
      need_debounce_delay = (_Bool)1;
      clear_port_feature(hub->hdev, port1, 16);
      }
    }
    if ((int )portchange & 2) {
      {
      need_debounce_delay = (_Bool)1;
      clear_port_feature(hub->hdev, port1, 17);
      }
    }
    if (! udev) {
      goto _L;
    } else {
      if ((unsigned int )udev->state == 0U) {
        _L: /* CIL Label */ 
        if (udev) {
          {
          set_bit((unsigned int )port1, (unsigned long volatile   *)(hub->change_bits));
          }
        } else {
          if ((int )portstatus & 1) {
            {
            set_bit((unsigned int )port1, (unsigned long volatile   *)(hub->change_bits));
            }
          }
        }
      } else {
        if ((int )portstatus & 2) {
          if (portchange) {
            {
            set_bit((unsigned int )port1, (unsigned long volatile   *)(hub->change_bits));
            }
          }
        } else {
          if (udev->persist_enabled) {
            {
            udev->reset_resume = 1U;
            set_bit((unsigned int )port1, (unsigned long volatile   *)(hub->change_bits));
            }
          } else {
            {
            usb_set_device_state(udev, (enum usb_device_state )0);
            set_bit((unsigned int )port1, (unsigned long volatile   *)(hub->change_bits));
            }
          }
        }
      }
    }
    {
    port1 ++;
    }
  }
  while_485_break: /* CIL Label */ ;
  }
  if (need_debounce_delay) {
    {
    delay = 100U;
    }
    if ((unsigned int )type == 1U) {
      {
      while (1) {
        while_486_continue: /* CIL Label */ ;
        {
        hub->init_work.work.func = & hub_init_func3;
        }
        goto while_486_break;
      }
      while_486_break: /* CIL Label */ ;
      }
      {
      tmp___2 = msecs_to_jiffies(delay);
      schedule_delayed_work(& hub->init_work, tmp___2);
      }
      return;
    } else {
      {
      msleep(delay);
      }
    }
  }
  init3: 
  {
  hub->quiescing = 0U;
  status = usb_submit_urb(hub->urb, 16U);
  }
  if (status < 0) {
    {
    tmp___3 = dev_name((struct device  const  *)hub->intfdev);
    tmp___4 = dev_driver_string((struct device  const  *)hub->intfdev);
    printk("<3>%s %s: activate --> %d\n", tmp___4, tmp___3, status);
    }
  }
  if (hub->has_indicators) {
    if (blinkenlights) {
      {
      schedule_delayed_work(& hub->leds, 666UL);
      }
    }
  }
  {
  kick_khubd(hub);
  }
  return;
}
}
static void hub_init_func2(struct work_struct *ws ) 
{ struct usb_hub *hub ;
  struct work_struct  const  *__mptr ;

  {
  {
  __mptr = (struct work_struct  const  *)ws;
  hub = (struct usb_hub *)((char *)__mptr - (unsigned int )(& ((struct usb_hub *)0)->init_work.work));
  hub_activate(hub, (enum hub_activation_type )1);
  }
  return;
}
}
static void hub_init_func3(struct work_struct *ws ) 
{ struct usb_hub *hub ;
  struct work_struct  const  *__mptr ;

  {
  {
  __mptr = (struct work_struct  const  *)ws;
  hub = (struct usb_hub *)((char *)__mptr - (unsigned int )(& ((struct usb_hub *)0)->init_work.work));
  hub_activate(hub, (enum hub_activation_type )2);
  }
  return;
}
}
static void hub_quiesce(struct usb_hub *hub , enum hub_quiescing_type type ) 
{ struct usb_device *hdev ;
  int i ;

  {
  {
  hdev = hub->hdev;
  cancel_delayed_work_sync(& hub->init_work);
  hub->quiescing = 1U;
  }
  if ((unsigned int )type != 2U) {
    {
    i = 0;
    }
    {
    while (1) {
      while_487_continue: /* CIL Label */ ;
      if (! (i < hdev->maxchild)) {
        goto while_487_break;
      }
      if (hdev->children[i]) {
        {
        usb_disconnect(& hdev->children[i]);
        }
      }
      {
      i ++;
      }
    }
    while_487_break: /* CIL Label */ ;
    }
  }
  {
  usb_kill_urb(hub->urb);
  }
  if (hub->has_indicators) {
    {
    cancel_delayed_work_sync(& hub->leds);
    }
  }
  if (hub->tt.hub) {
    {
    cancel_work_sync(& hub->tt.clear_work);
    }
  }
  return;
}
}
static int hub_pre_reset(struct usb_interface *intf ) 
{ struct usb_hub *hub ;
  void *tmp ;

  {
  {
  tmp = usb_get_intfdata(intf);
  hub = (struct usb_hub *)tmp;
  hub_quiesce(hub, (enum hub_quiescing_type )1);
  }
  return (0);
}
}
static int hub_post_reset(struct usb_interface *intf ) 
{ struct usb_hub *hub ;
  void *tmp ;

  {
  {
  tmp = usb_get_intfdata(intf);
  hub = (struct usb_hub *)tmp;
  hub_activate(hub, (enum hub_activation_type )3);
  }
  return (0);
}
}
static struct lock_class_key __key___13  ;
static int hub_configure(struct usb_hub *hub , struct usb_endpoint_descriptor *endpoint ) 
{ struct usb_device *hdev ;
  struct device *hub_dev ;
  u16 hubstatus ;
  u16 hubchange ;
  u16 wHubCharacteristics ;
  unsigned int pipe ;
  int maxp ;
  int ret ;
  char *message ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int i ;
  char portstr[32] ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  spinlock_t __constr_expr_0 ;
  atomic_long_t __constr_expr_1 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  int remaining ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char const   *tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  char const   *tmp___49 ;
  char const   *tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  unsigned int tmp___53 ;
  __u16 tmp___54 ;
  char const   *tmp___55 ;
  char const   *tmp___56 ;

  {
  {
  hdev = hub->hdev;
  hub_dev = hub->intfdev;
  tmp = usb_buffer_alloc(hdev, (unsigned int )sizeof(*(hub->buffer)), 208U, & hub->buffer_dma);
  hub->buffer = (char (*)[8])tmp;
  }
  if (! hub->buffer) {
    {
    message = (char *)"can\'t allocate hub irq buffer";
    ret = -12;
    }
    goto fail;
  }
  {
  tmp___0 = kmalloc((unsigned int )sizeof(*(hub->status)), 208U);
  hub->status = (union __anonunion_status_195 *)tmp___0;
  }
  if (! hub->status) {
    {
    message = (char *)"can\'t kmalloc hub status buffer";
    ret = -12;
    }
    goto fail;
  }
  {
  while (1) {
    while_488_continue: /* CIL Label */ ;
    {
    __mutex_init(& hub->status_mutex, "&hub->status_mutex", & __key___13);
    }
    goto while_488_break;
  }
  while_488_break: /* CIL Label */ ;
  }
  {
  tmp___1 = kmalloc((unsigned int )sizeof(*(hub->descriptor)), 208U);
  hub->descriptor = (struct usb_hub_descriptor *)tmp___1;
  }
  if (! hub->descriptor) {
    {
    message = (char *)"can\'t kmalloc hub descriptor";
    ret = -12;
    }
    goto fail;
  }
  {
  ret = get_hub_descriptor(hdev, (void *)hub->descriptor, (int )sizeof(*(hub->descriptor)));
  }
  if (ret < 0) {
    {
    message = (char *)"can\'t read hub descriptor";
    }
    goto fail;
  } else {
    if ((int )(hub->descriptor)->bNbrPorts > 31) {
      {
      message = (char *)"hub has too many ports!";
      ret = -19;
      }
      goto fail;
    }
  }
  {
  hdev->maxchild = (int )(hub->descriptor)->bNbrPorts;
  }
  if (hdev->maxchild == 1) {
    {
    tmp___2 = "";
    }
  } else {
    {
    tmp___2 = "s";
    }
  }
  {
  tmp___3 = dev_name((struct device  const  *)hub_dev);
  tmp___4 = dev_driver_string((struct device  const  *)hub_dev);
  printk("<6>%s %s: %d port%s detected\n", tmp___4, tmp___3, hdev->maxchild, tmp___2);
  wHubCharacteristics = (hub->descriptor)->wHubCharacteristics;
  }
  if ((int )wHubCharacteristics & 4) {
    {
    i = 0;
    }
    {
    while (1) {
      while_489_continue: /* CIL Label */ ;
      if (! (i < hdev->maxchild)) {
        goto while_489_break;
      }
      if ((int )(hub->descriptor)->DeviceRemovable[(i + 1) / 8] & (1 << (i + 1) % 8)) {
        {
        portstr[i] = (char )'F';
        }
      } else {
        {
        portstr[i] = (char )'R';
        }
      }
      {
      i ++;
      }
    }
    while_489_break: /* CIL Label */ ;
    }
    {
    portstr[hdev->maxchild] = (char)0;
    }
  }
  if (((int )wHubCharacteristics & 3) == 0) {
    goto switch_490_0;
  } else {
    if (((int )wHubCharacteristics & 3) == 1) {
      goto switch_490_1;
    } else {
      if (((int )wHubCharacteristics & 3) == 2) {
        goto switch_490_2;
      } else {
        if (((int )wHubCharacteristics & 3) == 3) {
          goto switch_490_2;
        } else {
          if (0) {
            switch_490_0: /* CIL Label */ 
            {

            }
            goto switch_490_break;
            switch_490_1: /* CIL Label */ 
            {

            }
            goto switch_490_break;
            switch_490_2: /* CIL Label */ 
            switch_490_3: /* CIL Label */ 
            {

            }
            goto switch_490_break;
          } else {
            switch_490_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  if (((int )wHubCharacteristics & 24) == 0) {
    goto switch_491_0;
  } else {
    if (((int )wHubCharacteristics & 24) == 8) {
      goto switch_491_8;
    } else {
      if (((int )wHubCharacteristics & 24) == 16) {
        goto switch_491_16;
      } else {
        if (((int )wHubCharacteristics & 24) == 24) {
          goto switch_491_16;
        } else {
          if (0) {
            switch_491_0: /* CIL Label */ 
            {

            }
            goto switch_491_break;
            switch_491_8: /* CIL Label */ 
            {

            }
            goto switch_491_break;
            switch_491_16: /* CIL Label */ 
            switch_491_24: /* CIL Label */ 
            {

            }
            goto switch_491_break;
          } else {
            switch_491_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  while (1) {
    while_492_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    hub->tt.lock = __constr_expr_0;
    }
    goto while_492_break;
  }
  while_492_break: /* CIL Label */ ;
  }
  {
  INIT_LIST_HEAD(& hub->tt.clear_list);
  }
  {
  while (1) {
    while_493_continue: /* CIL Label */ ;
    {
    __constr_expr_1.counter = (int volatile   )0;
    hub->tt.clear_work.data = __constr_expr_1;
    INIT_LIST_HEAD(& hub->tt.clear_work.entry);
    }
    {
    while (1) {
      while_494_continue: /* CIL Label */ ;
      {
      hub->tt.clear_work.func = & hub_tt_work;
      }
      goto while_494_break;
    }
    while_494_break: /* CIL Label */ ;
    }
    goto while_493_break;
  }
  while_493_break: /* CIL Label */ ;
  }
  if ((int )hdev->descriptor.bDeviceProtocol == 0) {
    goto switch_495_0;
  } else {
    if ((int )hdev->descriptor.bDeviceProtocol == 1) {
      goto switch_495_1;
    } else {
      if ((int )hdev->descriptor.bDeviceProtocol == 2) {
        goto switch_495_2;
      } else {
        {
        goto switch_495_default;
        if (0) {
          switch_495_0: /* CIL Label */ 
          goto switch_495_break;
          switch_495_1: /* CIL Label */ 
          {
          hub->tt.hub = hdev;
          }
          goto switch_495_break;
          switch_495_2: /* CIL Label */ 
          {
          ret = usb_set_interface(hdev, 0, 1);
          }
          if (ret == 0) {
            {
            hub->tt.multi = 1;
            }
          } else {
            {
            tmp___25 = dev_name((struct device  const  *)hub_dev);
            tmp___26 = dev_driver_string((struct device  const  *)hub_dev);
            printk("<3>%s %s: Using single TT (err %d)\n", tmp___26, tmp___25, ret);
            }
          }
          {
          hub->tt.hub = hdev;
          }
          goto switch_495_break;
          switch_495_default: /* CIL Label */ 
          {

          }
          goto switch_495_break;
        } else {
          switch_495_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  if (((int )wHubCharacteristics & 96) == 0) {
    goto switch_496_0;
  } else {
    if (((int )wHubCharacteristics & 96) == 32) {
      goto switch_496_32;
    } else {
      if (((int )wHubCharacteristics & 96) == 64) {
        goto switch_496_64;
      } else {
        if (((int )wHubCharacteristics & 96) == 96) {
          goto switch_496_96;
        } else {
          if (0) {
            switch_496_0: /* CIL Label */ 
            if ((int )hdev->descriptor.bDeviceProtocol != 0) {
              {
              hub->tt.think_time = 666U;
              }
            }
            goto switch_496_break;
            switch_496_32: /* CIL Label */ 
            {
            hub->tt.think_time = 1332U;
            }
            goto switch_496_break;
            switch_496_64: /* CIL Label */ 
            {
            hub->tt.think_time = 1998U;
            }
            goto switch_496_break;
            switch_496_96: /* CIL Label */ 
            {
            hub->tt.think_time = 2664U;
            }
            goto switch_496_break;
          } else {
            switch_496_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  if ((int )wHubCharacteristics & 128) {
    {
    hub->has_indicators = 1U;
    }
  }
  {
  ret = usb_get_status(hdev, 0, 0, (void *)(& hubstatus));
  }
  if (ret < 2) {
    {
    message = (char *)"can\'t get hub status";
    }
    goto fail;
  }
  {
  while (1) {
    while_497_continue: /* CIL Label */ ;
    goto while_497_break;
  }
  while_497_break: /* CIL Label */ ;
  }
  if ((unsigned long )hdev == (unsigned long )(hdev->bus)->root_hub) {
    if ((int )hdev->bus_mA == 0) {
      {
      hub->mA_per_port = 500U;
      }
    } else {
      if ((int )hdev->bus_mA >= 500) {
        {
        hub->mA_per_port = 500U;
        }
      } else {
        {
        hub->mA_per_port = (unsigned int )hdev->bus_mA;
        hub->limited_power = 1U;
        }
      }
    }
  } else {
    if (((int )hubstatus & 1) == 0) {
      {
      hub->limited_power = 1U;
      }
      if (hdev->maxchild > 0) {
        {
        remaining = (int )hdev->bus_mA - (int )(hub->descriptor)->bHubContrCurrent;
        }
        if (remaining < hdev->maxchild * 100) {
          {
          tmp___43 = dev_name((struct device  const  *)hub_dev);
          tmp___44 = dev_driver_string((struct device  const  *)hub_dev);
          printk("<4>%s %s: insufficient power available to use all downstream ports\n",
                 tmp___44, tmp___43);
          }
        }
        {
        hub->mA_per_port = 100U;
        }
      }
    } else {
      {
      hub->mA_per_port = 500U;
      }
    }
  }
  if (hub->mA_per_port < 500U) {

  }
  {
  ret = hub_hub_status(hub, & hubstatus, & hubchange);
  }
  if (ret < 0) {
    {
    message = (char *)"can\'t get hub status";
    }
    goto fail;
  }
  if ((int )(hdev->actconfig)->desc.bmAttributes & (1 << 6)) {

  }
  if (((int )wHubCharacteristics & 24) == 0) {

  }
  {
  tmp___53 = __create_pipe(hdev, (unsigned int )endpoint->bEndpointAddress);
  pipe = ((unsigned int )(1 << 30) | tmp___53) | 128U;
  tmp___54 = usb_maxpacket(hdev, (int )pipe, ! (pipe & 128U));
  maxp = (int )tmp___54;
  }
  if ((unsigned long )maxp > sizeof(*(hub->buffer))) {
    {
    maxp = (int )sizeof(*(hub->buffer));
    }
  }
  {
  hub->urb = usb_alloc_urb(0, 208U);
  }
  if (! hub->urb) {
    {
    message = (char *)"couldn\'t allocate interrupt urb";
    ret = -12;
    }
    goto fail;
  }
  {
  usb_fill_int_urb(hub->urb, hdev, pipe, (void *)(*(hub->buffer)), maxp, & hub_irq,
                   (void *)hub, (int )endpoint->bInterval);
  (hub->urb)->transfer_dma = hub->buffer_dma;
  (hub->urb)->transfer_flags |= 4U;
  }
  if (hub->has_indicators) {
    if (blinkenlights) {
      {
      hub->indicator[0] = (unsigned char)1;
      }
    }
  }
  {
  hub_activate(hub, (enum hub_activation_type )0);
  }
  return (0);
  fail: 
  {
  tmp___55 = dev_name((struct device  const  *)hub_dev);
  tmp___56 = dev_driver_string((struct device  const  *)hub_dev);
  printk("<3>%s %s: config failed, %s (err %d)\n", tmp___56, tmp___55, message, ret);
  }
  return (ret);
}
}
static void hub_release(struct kref *kref ) 
{ struct usb_hub *hub ;
  struct kref  const  *__mptr ;
  struct device  const  *__mptr___0 ;

  {
  {
  __mptr = (struct kref  const  *)kref;
  hub = (struct usb_hub *)((char *)__mptr - (unsigned int )(& ((struct usb_hub *)0)->kref));
  __mptr___0 = (struct device  const  *)hub->intfdev;
  usb_put_intf((struct usb_interface *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_interface *)0)->dev)));
  kfree((void const   *)hub);
  }
  return;
}
}
static unsigned int highspeed_hubs  ;
static void hub_disconnect(struct usb_interface *intf ) 
{ struct usb_hub *hub ;
  void *tmp ;

  {
  {
  tmp = usb_get_intfdata(intf);
  hub = (struct usb_hub *)tmp;
  _spin_lock_irq(& hub_event_lock);
  list_del_init(& hub->event_list);
  hub->disconnected = 1U;
  }
  {
  while (1) {
    while_498_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& hub_event_lock.raw_lock);
    }
    {
    while (1) {
      while_499_continue: /* CIL Label */ ;
      {
      while (1) {
        while_500_continue: /* CIL Label */ ;
        goto while_500_break;
      }
      while_500_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_499_break;
    }
    while_499_break: /* CIL Label */ ;
    }
    goto while_498_break;
  }
  while_498_break: /* CIL Label */ ;
  }
  {
  hub->error = 0;
  hub_quiesce(hub, (enum hub_quiescing_type )0);
  usb_set_intfdata(intf, (void *)0);
  }
  if ((unsigned int )(hub->hdev)->speed == 3U) {
    {
    highspeed_hubs --;
    }
  }
  {
  usb_free_urb(hub->urb);
  kfree((void const   *)hub->descriptor);
  kfree((void const   *)hub->status);
  usb_buffer_free(hub->hdev, (unsigned int )sizeof(*(hub->buffer)), (void *)hub->buffer,
                  hub->buffer_dma);
  kref_put(& hub->kref, & hub_release);
  }
  return;
}
}
static int hub_probe(struct usb_interface *intf , struct usb_device_id  const  *id ) 
{ struct usb_host_interface *desc ;
  struct usb_endpoint_descriptor *endpoint ;
  struct usb_device *hdev ;
  struct usb_hub *hub ;
  struct device  const  *__mptr ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  atomic_long_t __constr_expr_0 ;
  atomic_long_t __constr_expr_1 ;
  int tmp___9 ;

  {
  {
  desc = intf->cur_altsetting;
  __mptr = (struct device  const  *)intf->dev.parent;
  hdev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if ((int )hdev->level == 6) {
    {
    tmp = dev_name((struct device  const  *)(& intf->dev));
    tmp___0 = dev_driver_string((struct device  const  *)(& intf->dev));
    printk("<3>%s %s: Unsupported bus topology: hub nested too deep\n", tmp___0, tmp);
    }
    return (-7);
  }
  if ((int )desc->desc.bInterfaceSubClass != 0) {
    if ((int )desc->desc.bInterfaceSubClass != 1) {
      descriptor_error: 
      {
      tmp___1 = dev_name((struct device  const  *)(& intf->dev));
      tmp___2 = dev_driver_string((struct device  const  *)(& intf->dev));
      printk("<3>%s %s: bad descriptor, ignoring hub\n", tmp___2, tmp___1);
      }
      return (-5);
    }
  }
  if ((int )desc->desc.bNumEndpoints != 1) {
    goto descriptor_error;
  }
  {
  endpoint = & (desc->endpoint + 0)->desc;
  tmp___3 = usb_endpoint_is_int_in((struct usb_endpoint_descriptor  const  *)endpoint);
  }
  if (! tmp___3) {
    goto descriptor_error;
  }
  {
  tmp___4 = dev_name((struct device  const  *)(& intf->dev));
  tmp___5 = dev_driver_string((struct device  const  *)(& intf->dev));
  printk("<6>%s %s: USB hub found\n", tmp___5, tmp___4);
  tmp___6 = kzalloc((unsigned int )sizeof(*hub), 208U);
  hub = (struct usb_hub *)tmp___6;
  }
  if (! hub) {
    return (-12);
  }
  {
  kref_init(& hub->kref);
  INIT_LIST_HEAD(& hub->event_list);
  hub->intfdev = & intf->dev;
  hub->hdev = hdev;
  }
  {
  while (1) {
    while_501_continue: /* CIL Label */ ;
    {
    while (1) {
      while_502_continue: /* CIL Label */ ;
      {
      __constr_expr_0.counter = (int volatile   )0;
      hub->leds.work.data = __constr_expr_0;
      INIT_LIST_HEAD(& hub->leds.work.entry);
      }
      {
      while (1) {
        while_503_continue: /* CIL Label */ ;
        {
        hub->leds.work.func = & led_work;
        }
        goto while_503_break;
      }
      while_503_break: /* CIL Label */ ;
      }
      goto while_502_break;
    }
    while_502_break: /* CIL Label */ ;
    }
    {
    init_timer_key(& hub->leds.timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0));
    }
    goto while_501_break;
  }
  while_501_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_504_continue: /* CIL Label */ ;
    {
    while (1) {
      while_505_continue: /* CIL Label */ ;
      {
      __constr_expr_1.counter = (int volatile   )0;
      hub->init_work.work.data = __constr_expr_1;
      INIT_LIST_HEAD(& hub->init_work.work.entry);
      }
      {
      while (1) {
        while_506_continue: /* CIL Label */ ;
        {
        hub->init_work.work.func = (void (*)(struct work_struct *work ))((void *)0);
        }
        goto while_506_break;
      }
      while_506_break: /* CIL Label */ ;
      }
      goto while_505_break;
    }
    while_505_break: /* CIL Label */ ;
    }
    {
    init_timer_key(& hub->init_work.timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0));
    }
    goto while_504_break;
  }
  while_504_break: /* CIL Label */ ;
  }
  {
  usb_get_intf(intf);
  usb_set_intfdata(intf, (void *)hub);
  intf->needs_remote_wakeup = 1U;
  }
  if ((unsigned int )hdev->speed == 3U) {
    {
    highspeed_hubs ++;
    }
  }
  {
  tmp___9 = hub_configure(hub, endpoint);
  }
  if (tmp___9 >= 0) {
    return (0);
  }
  {
  hub_disconnect(intf);
  }
  return (-19);
}
}
static int hub_ioctl(struct usb_interface *intf , unsigned int code , void *user_data ) 
{ struct usb_device *hdev ;
  struct device  const  *__mptr ;
  struct usbdevfs_hub_portinfo *info ;
  int i ;

  {
  {
  __mptr = (struct device  const  *)intf->dev.parent;
  hdev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if ((int )code == ((unsigned long )(((2U << 30) | (unsigned int )(85 << 8)) | 19U) | (sizeof(struct usbdevfs_hub_portinfo ) << 16))) {
    goto switch_507_exp_31;
  } else {
    {
    goto switch_507_default;
    if (0) {
      switch_507_exp_31: /* CIL Label */ 
      {
      info = (struct usbdevfs_hub_portinfo *)user_data;
      _spin_lock_irq(& device_state_lock);
      }
      if (hdev->devnum <= 0) {
        {
        info->nports = (char)0;
        }
      } else {
        {
        info->nports = (char )hdev->maxchild;
        i = 0;
        }
        {
        while (1) {
          while_508_continue: /* CIL Label */ ;
          if (! (i < (int )info->nports)) {
            goto while_508_break;
          }
          if ((unsigned long )hdev->children[i] == (unsigned long )((void *)0)) {
            {
            info->port[i] = (char)0;
            }
          } else {
            {
            info->port[i] = (char )(hdev->children[i])->devnum;
            }
          }
          {
          i ++;
          }
        }
        while_508_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_509_continue: /* CIL Label */ ;
        {
        __raw_spin_unlock(& device_state_lock.raw_lock);
        }
        {
        while (1) {
          while_510_continue: /* CIL Label */ ;
          {
          while (1) {
            while_511_continue: /* CIL Label */ ;
            goto while_511_break;
          }
          while_511_break: /* CIL Label */ ;
          }
          {
          raw_local_irq_enable();
          }
          goto while_510_break;
        }
        while_510_break: /* CIL Label */ ;
        }
        goto while_509_break;
      }
      while_509_break: /* CIL Label */ ;
      }
      return ((int )info->nports + 1);
      switch_507_default: /* CIL Label */ 
      {

      }
      return (-38);
    } else {
      switch_507_break: /* CIL Label */ ;
    }
    }
  }
}
}
static void recursively_mark_NOTATTACHED(struct usb_device *udev ) 
{ int i ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_512_continue: /* CIL Label */ ;
    if (! (i < udev->maxchild)) {
      goto while_512_break;
    }
    if (udev->children[i]) {
      {
      recursively_mark_NOTATTACHED(udev->children[i]);
      }
    }
    {
    i ++;
    }
  }
  while_512_break: /* CIL Label */ ;
  }
  if ((unsigned int )udev->state == 8U) {
    {
    udev->discon_suspended = 1U;
    udev->active_duration -= (unsigned long )jiffies;
    }
  }
  {
  udev->state = (enum usb_device_state )0;
  }
  return;
}
}
void usb_set_device_state(struct usb_device *udev , enum usb_device_state new_state ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_513_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& device_state_lock);
    }
    goto while_513_break;
  }
  while_513_break: /* CIL Label */ ;
  }
  if (! ((unsigned int )udev->state == 0U)) {
    if ((unsigned int )new_state != 0U) {
      if (udev->parent) {
        if (! ((unsigned int )udev->state == 8U)) {
          if (! ((unsigned int )new_state == 8U)) {
            if ((unsigned int )new_state == 7U) {
              {
              device_init_wakeup(& udev->dev, (int )(udev->actconfig)->desc.bmAttributes & (1 << 5));
              }
            } else {
              {
              device_init_wakeup(& udev->dev, 0);
              }
            }
          }
        }
      }
      if ((unsigned int )udev->state == 8U) {
        if ((unsigned int )new_state != 8U) {
          {
          udev->active_duration -= (unsigned long )jiffies;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if ((unsigned int )new_state == 8U) {
          if ((unsigned int )udev->state != 8U) {
            {
            udev->active_duration += (unsigned long )jiffies;
            }
          }
        }
      }
      {
      udev->state = new_state;
      }
    } else {
      {
      recursively_mark_NOTATTACHED(udev);
      }
    }
  }
  {
  while (1) {
    while_514_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& device_state_lock, flags);
    }
    goto while_514_break;
  }
  while_514_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_set_device_state[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'s', 
        (char const   )'t',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_set_device_state  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_set_device_state), __kstrtab_usb_set_device_state};
static void choose_address(struct usb_device *udev ) 
{ int devnum ;
  struct usb_bus *bus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;

  {
  {
  bus = udev->bus;
  }
  if (udev->wusb) {
    {
    devnum = (int )udev->portnum + 1;
    }
    {
    while (1) {
      while_515_continue: /* CIL Label */ ;
      {
      tmp___0 = variable_test_bit(devnum, (unsigned long const volatile   *)(bus->devmap.devicemap));
      }
      if (tmp___0) {
        {
        tmp___1 = 1;
        }
      } else {
        {
        tmp___1 = 0;
        }
      }
      {
      tmp___2 = __builtin_expect((long )tmp___1, 0L);
      }
      if (tmp___2) {
        {
        while (1) {
          while_516_continue: /* CIL Label */ ;
          {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b, %c0\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("hub.c"), "i" (1347), "i" (sizeof(struct bug_entry )));
          }
          {
          while (1) {
            while_517_continue: /* CIL Label */ ;
          }
          while_517_break: /* CIL Label */ ;
          }
          goto while_516_break;
        }
        while_516_break: /* CIL Label */ ;
        }
      }
      goto while_515_break;
    }
    while_515_break: /* CIL Label */ ;
    }
  } else {
    {
    tmp___3 = find_next_zero_bit((unsigned long const   *)(bus->devmap.devicemap),
                                 128UL, (unsigned long )bus->devnum_next);
    devnum = (int )tmp___3;
    }
    if (devnum >= 128) {
      {
      tmp___4 = find_next_zero_bit((unsigned long const   *)(bus->devmap.devicemap),
                                   128UL, 1UL);
      devnum = (int )tmp___4;
      }
    }
    if (devnum >= 127) {
      {
      bus->devnum_next = 1;
      }
    } else {
      {
      bus->devnum_next = devnum + 1;
      }
    }
  }
  if (devnum < 128) {
    {
    set_bit((unsigned int )devnum, (unsigned long volatile   *)(bus->devmap.devicemap));
    udev->devnum = devnum;
    }
  }
  return;
}
}
static void release_address(struct usb_device *udev ) 
{ 

  {
  if (udev->devnum > 0) {
    {
    clear_bit(udev->devnum, (unsigned long volatile   *)((udev->bus)->devmap.devicemap));
    udev->devnum = -1;
    }
  }
  return;
}
}
static void update_address(struct usb_device *udev , int devnum ) 
{ 

  {
  if (! udev->wusb) {
    {
    udev->devnum = devnum;
    }
  }
  return;
}
}
static void usb_stop_pm(struct usb_device *udev ) 
{ 

  {
  {
  usb_pm_lock(udev);
  }
  if (udev->parent) {
    if (! udev->discon_suspended) {
      {
      usb_autosuspend_device(udev->parent);
      }
    }
  }
  {
  usb_pm_unlock(udev);
  cancel_delayed_work_sync(& udev->autosuspend);
  cancel_work_sync(& udev->autoresume);
  }
  return;
}
}
void usb_disconnect(struct usb_device **pdev ) 
{ struct usb_device *udev ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  udev = *pdev;
  }
  if (! udev) {
    return;
  }
  {
  usb_set_device_state(udev, (enum usb_device_state )0);
  tmp = dev_name((struct device  const  *)(& udev->dev));
  tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
  printk("<6>%s %s: USB disconnect, address %d\n", tmp___0, tmp, udev->devnum);
  down(& udev->dev.sem);
  i = 0;
  }
  {
  while (1) {
    while_518_continue: /* CIL Label */ ;
    if (! (i < 31)) {
      goto while_518_break;
    }
    if (udev->children[i]) {
      {
      usb_disconnect(& udev->children[i]);
      }
    }
    {
    i ++;
    }
  }
  while_518_break: /* CIL Label */ ;
  }
  {
  usb_disable_device(udev, 0);
  usb_hcd_synchronize_unlinks(udev);
  usb_remove_ep_devs(& udev->ep0);
  up(& udev->dev.sem);
  device_del(& udev->dev);
  release_address(udev);
  _spin_lock_irq(& device_state_lock);
  *pdev = (struct usb_device *)((void *)0);
  }
  {
  while (1) {
    while_519_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& device_state_lock.raw_lock);
    }
    {
    while (1) {
      while_520_continue: /* CIL Label */ ;
      {
      while (1) {
        while_521_continue: /* CIL Label */ ;
        goto while_521_break;
      }
      while_521_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_520_break;
    }
    while_520_break: /* CIL Label */ ;
    }
    goto while_519_break;
  }
  while_519_break: /* CIL Label */ ;
  }
  {
  usb_stop_pm(udev);
  put_device(& udev->dev);
  }
  return;
}
}
static void show_string(struct usb_device *udev , char *id , char *string ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (! string) {
    return;
  }
  {
  tmp = dev_name((struct device  const  *)(& udev->dev));
  tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
  printk("<6>%s %s: %s: %s\n", tmp___0, tmp, id, string);
  }
  return;
}
}
static void announce_device(struct usb_device *udev ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  tmp = dev_name((struct device  const  *)(& udev->dev));
  tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
  printk("<6>%s %s: New USB device found, idVendor=%04x, idProduct=%04x\n", tmp___0,
         tmp, udev->descriptor.idVendor, udev->descriptor.idProduct);
  tmp___1 = dev_name((struct device  const  *)(& udev->dev));
  tmp___2 = dev_driver_string((struct device  const  *)(& udev->dev));
  printk("<6>%s %s: New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\n",
         tmp___2, tmp___1, udev->descriptor.iManufacturer, udev->descriptor.iProduct,
         udev->descriptor.iSerialNumber);
  show_string(udev, (char *)"Product", udev->product);
  show_string(udev, (char *)"Manufacturer", udev->manufacturer);
  show_string(udev, (char *)"SerialNumber", udev->serial);
  }
  return;
}
}
static int usb_configure_device_otg(struct usb_device *udev ) 
{ int err ;

  {
  {
  err = 0;
  }
  return (err);
}
}
static int usb_configure_device(struct usb_device *udev ) 
{ int err ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if ((unsigned long )udev->config == (unsigned long )((void *)0)) {
    {
    err = usb_get_configuration(udev);
    }
    if (err < 0) {
      {
      tmp = dev_name((struct device  const  *)(& udev->dev));
      tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
      printk("<3>%s %s: can\'t read configurations, error %d\n", tmp___0, tmp, err);
      }
      goto fail;
    }
  }
  if (udev->wusb == 1U) {
    if (udev->authorized == 0U) {
      {
      udev->product = kstrdup("n/a (unauthorized)", 208U);
      udev->manufacturer = kstrdup("n/a (unauthorized)", 208U);
      udev->serial = kstrdup("n/a (unauthorized)", 208U);
      }
    } else {
      {
      udev->product = usb_cache_string(udev, (int )udev->descriptor.iProduct);
      udev->manufacturer = usb_cache_string(udev, (int )udev->descriptor.iManufacturer);
      udev->serial = usb_cache_string(udev, (int )udev->descriptor.iSerialNumber);
      }
    }
  } else {
    {
    udev->product = usb_cache_string(udev, (int )udev->descriptor.iProduct);
    udev->manufacturer = usb_cache_string(udev, (int )udev->descriptor.iManufacturer);
    udev->serial = usb_cache_string(udev, (int )udev->descriptor.iSerialNumber);
    }
  }
  {
  err = usb_configure_device_otg(udev);
  }
  fail: 
  return (err);
}
}
int usb_new_device(struct usb_device *udev ) 
{ int err ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (udev->parent) {
    {
    usb_autoresume_device(udev->parent);
    }
  }
  {
  usb_detect_quirks(udev);
  err = usb_configure_device(udev);
  }
  if (err < 0) {
    goto fail;
  }
  {
  udev->dev.devt = (unsigned int )((189 << 20) | (((udev->bus)->busnum - 1) * 128 + (udev->devnum - 1)));
  announce_device(udev);
  err = device_add(& udev->dev);
  }
  if (err) {
    {
    tmp = dev_name((struct device  const  *)(& udev->dev));
    tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<3>%s %s: can\'t device_add, error %d\n", tmp___0, tmp, err);
    }
    goto fail;
  }
  {
  usb_create_ep_devs(& udev->dev, & udev->ep0, udev);
  }
  return (err);
  fail: 
  {
  usb_set_device_state(udev, (enum usb_device_state )0);
  usb_stop_pm(udev);
  }
  return (err);
}
}
int usb_deauthorize_device(struct usb_device *usb_dev ) 
{ unsigned int cnt ;

  {
  {
  down(& usb_dev->dev.sem);
  }
  if (usb_dev->authorized == 0U) {
    goto out_unauthorized;
  }
  {
  usb_dev->authorized = 0U;
  usb_set_configuration(usb_dev, -1);
  usb_dev->product = kstrdup("n/a (unauthorized)", 208U);
  usb_dev->manufacturer = kstrdup("n/a (unauthorized)", 208U);
  usb_dev->serial = kstrdup("n/a (unauthorized)", 208U);
  kfree((void const   *)usb_dev->config);
  usb_dev->config = (struct usb_host_config *)((void *)0);
  cnt = 0U;
  }
  {
  while (1) {
    while_522_continue: /* CIL Label */ ;
    if (! (cnt < (unsigned int )usb_dev->descriptor.bNumConfigurations)) {
      goto while_522_break;
    }
    {
    kfree((void const   *)*(usb_dev->rawdescriptors + cnt));
    cnt ++;
    }
  }
  while_522_break: /* CIL Label */ ;
  }
  {
  usb_dev->descriptor.bNumConfigurations = (unsigned char)0;
  kfree((void const   *)usb_dev->rawdescriptors);
  }
  out_unauthorized: 
  {
  up(& usb_dev->dev.sem);
  }
  return (0);
}
}
int usb_authorize_device(struct usb_device *usb_dev ) 
{ int result ;
  int c ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
  result = 0;
  down(& usb_dev->dev.sem);
  }
  if (usb_dev->authorized == 1U) {
    goto error_configure;
  }
  {
  kfree((void const   *)usb_dev->product);
  usb_dev->product = (char *)((void *)0);
  kfree((void const   *)usb_dev->manufacturer);
  usb_dev->manufacturer = (char *)((void *)0);
  kfree((void const   *)usb_dev->serial);
  usb_dev->serial = (char *)((void *)0);
  result = usb_autoresume_device(usb_dev);
  }
  if (result < 0) {
    {
    tmp = dev_name((struct device  const  *)(& usb_dev->dev));
    tmp___0 = dev_driver_string((struct device  const  *)(& usb_dev->dev));
    printk("<3>%s %s: can\'t autoresume for authorization: %d\n", tmp___0, tmp, result);
    }
    goto error_configure;
  }
  {
  result = usb_get_device_descriptor(usb_dev, (unsigned int )sizeof(usb_dev->descriptor));
  }
  if (result < 0) {
    {
    tmp___1 = dev_name((struct device  const  *)(& usb_dev->dev));
    tmp___2 = dev_driver_string((struct device  const  *)(& usb_dev->dev));
    printk("<3>%s %s: can\'t re-read device descriptor for authorization: %d\n", tmp___2,
           tmp___1, result);
    }
    goto error_configure;
  }
  {
  usb_dev->authorized = 1U;
  result = usb_configure_device(usb_dev);
  }
  if (result < 0) {
    goto error_configure;
  }
  {
  c = usb_choose_configuration(usb_dev);
  }
  if (c >= 0) {
    {
    result = usb_set_configuration(usb_dev, c);
    }
    if (result) {
      {
      tmp___3 = dev_name((struct device  const  *)(& usb_dev->dev));
      tmp___4 = dev_driver_string((struct device  const  *)(& usb_dev->dev));
      printk("<3>%s %s: can\'t set config #%d, error %d\n", tmp___4, tmp___3, c, result);
      }
    }
  }
  {
  tmp___5 = dev_name((struct device  const  *)(& usb_dev->dev));
  tmp___6 = dev_driver_string((struct device  const  *)(& usb_dev->dev));
  printk("<6>%s %s: authorized to connect\n", tmp___6, tmp___5);
  }
  error_configure: 
  error_device_descriptor: 
  error_autoresume: 
  out_authorized: 
  {
  up(& usb_dev->dev.sem);
  }
  return (result);
}
}
static unsigned int hub_is_wusb(struct usb_hub *hub ) 
{ struct usb_hcd *hcd ;
  struct usb_bus  const  *__mptr ;

  {
  if ((unsigned long )(hub->hdev)->parent != (unsigned long )((void *)0)) {
    return (0U);
  }
  {
  __mptr = (struct usb_bus  const  *)(hub->hdev)->bus;
  hcd = (struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->self));
  }
  return (hcd->wireless);
}
}
static int hub_port_wait_reset(struct usb_hub *hub , int port1 , struct usb_device *udev ,
                               unsigned int delay ) 
{ int delay_time ;
  int ret ;
  u16 portstatus ;
  u16 portchange ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  delay_time = 0;
  }
  {
  while (1) {
    while_523_continue: /* CIL Label */ ;
    if (! (delay_time < 500)) {
      goto while_523_break;
    }
    {
    msleep(delay);
    ret = hub_port_status(hub, port1, & portstatus, & portchange);
    }
    if (ret < 0) {
      return (ret);
    }
    if (! ((int )portstatus & 1)) {
      return (-107);
    }
    if ((int )portchange & 1) {
      return (-107);
    }
    if (! ((int )portstatus & 16)) {
      if ((int )portstatus & 2) {
        {
        tmp = hub_is_wusb(hub);
        }
        if (tmp) {
          {
          udev->speed = (enum usb_device_speed )4;
          }
        } else {
          if ((int )portstatus & 1024) {
            {
            udev->speed = (enum usb_device_speed )3;
            }
          } else {
            if ((int )portstatus & 512) {
              {
              udev->speed = (enum usb_device_speed )1;
              }
            } else {
              {
              udev->speed = (enum usb_device_speed )2;
              }
            }
          }
        }
        return (0);
      }
    }
    if (delay_time >= 20) {
      {
      delay = 200U;
      }
    }
    {
    delay_time = (int )((unsigned int )delay_time + delay);
    }
  }
  while_523_break: /* CIL Label */ ;
  }
  return (-16);
}
}
static int hub_port_reset(struct usb_hub *hub , int port1 , struct usb_device *udev ,
                          unsigned int delay ) 
{ int i ;
  int status ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
  down_read(& ehci_cf_port_reset_rwsem);
  i = 0;
  }
  {
  while (1) {
    while_524_continue: /* CIL Label */ ;
    if (! (i < 5)) {
      goto while_524_break;
    }
    {
    status = set_port_feature(hub->hdev, port1, 4);
    }
    if (status) {
      {
      tmp = dev_name((struct device  const  *)hub->intfdev);
      tmp___0 = dev_driver_string((struct device  const  *)hub->intfdev);
      printk("<3>%s %s: cannot reset port %d (err = %d)\n", tmp___0, tmp, port1, status);
      }
    } else {
      {
      status = hub_port_wait_reset(hub, port1, udev, delay);
      }
      if (status) {
        if (status != -107) {

        }
      }
    }
    if (status == 0) {
      goto switch_525_0;
    } else {
      if (status == -107) {
        goto switch_525_neg_107;
      } else {
        if (status == -19) {
          goto switch_525_neg_107;
        } else {
          if (0) {
            switch_525_0: /* CIL Label */ 
            {
            msleep(50U);
            update_address(udev, 0);
            }
            switch_525_neg_107: /* CIL Label */ 
            switch_525_neg_19: /* CIL Label */ 
            {
            clear_port_feature(hub->hdev, port1, 20);
            }
            if (status) {
              {
              tmp___3 = 0;
              }
            } else {
              {
              tmp___3 = 5;
              }
            }
            {
            usb_set_device_state(udev, (enum usb_device_state )tmp___3);
            }
            goto done;
          } else {
            switch_525_break: /* CIL Label */ ;
          }
        }
      }
    }
    {
    delay = 200U;
    i ++;
    }
  }
  while_524_break: /* CIL Label */ ;
  }
  {
  tmp___6 = dev_name((struct device  const  *)hub->intfdev);
  tmp___7 = dev_driver_string((struct device  const  *)hub->intfdev);
  printk("<3>%s %s: Cannot enable port %i.  Maybe the USB cable is bad?\n", tmp___7,
         tmp___6, port1);
  }
  done: 
  {
  up_read(& ehci_cf_port_reset_rwsem);
  }
  return (status);
}
}
static int check_port_resume_type(struct usb_device *udev , struct usb_hub *hub ,
                                  int port1 , int status , unsigned int portchange ,
                                  unsigned int portstatus ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (status) {
    goto _L;
  } else {
    if ((portstatus & 261U) != 257U) {
      _L: /* CIL Label */ 
      if (status >= 0) {
        {
        status = -19;
        }
      }
    } else {
      if (! (portstatus & 2U)) {
        if (! udev->reset_resume) {
          if (udev->persist_enabled) {
            {
            udev->reset_resume = 1U;
            }
          } else {
            {
            status = -19;
            }
          }
        }
      }
    }
  }
  if (! status) {
    if (udev->reset_resume) {
      if (portchange & 1U) {
        {
        clear_port_feature(hub->hdev, port1, 16);
        }
      }
      if (portchange & 2U) {
        {
        clear_port_feature(hub->hdev, port1, 17);
        }
      }
    }
  }
  return (status);
}
}
int usb_port_suspend(struct usb_device *udev , pm_message_t msg ) 
{ struct usb_hub *hub ;
  struct usb_hub *tmp ;
  int port1 ;
  int status ;
  unsigned int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
  tmp = hdev_to_hub(udev->parent);
  hub = tmp;
  port1 = (int )udev->portnum;
  }
  if (udev->do_remote_wakeup) {
    {
    tmp___0 = __create_pipe(udev, 0U);
    status = usb_control_msg(udev, (unsigned int )(2 << 30) | tmp___0, (unsigned char)3,
                             (unsigned char)0, (unsigned short)1, (unsigned short)0,
                             (void *)0, (unsigned short)0, 5000);
    }
    if (status) {

    }
  }
  {
  status = set_port_feature(hub->hdev, port1, 2);
  }
  if (status) {
    {
    tmp___5 = __create_pipe(udev, 0U);
    usb_control_msg(udev, (unsigned int )(2 << 30) | tmp___5, (unsigned char)1, (unsigned char)0,
                    (unsigned short)1, (unsigned short)0, (void *)0, (unsigned short)0,
                    5000);
    }
  } else {
    {
    usb_set_device_state(udev, (enum usb_device_state )8);
    msleep(10U);
    }
  }
  return (status);
}
}
static int finish_port_resume(struct usb_device *udev ) 
{ int status ;
  u16 devstatus ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  unsigned int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
  status = 0;
  }
  if (udev->actconfig) {
    {
    tmp___2 = 7;
    }
  } else {
    {
    tmp___2 = 6;
    }
  }
  {
  usb_set_device_state(udev, (enum usb_device_state )tmp___2);
  }
  if (udev->reset_resume) {
    retry_reset_resume: 
    {
    status = usb_reset_and_verify_device(udev);
    }
  }
  if (status == 0) {
    {
    devstatus = (unsigned short)0;
    status = usb_get_status(udev, 0, 0, (void *)(& devstatus));
    }
    if (status >= 0) {
      if (status > 0) {
        {
        status = 0;
        }
      } else {
        {
        status = -19;
        }
      }
    }
    if (status) {
      if (! udev->reset_resume) {
        if (udev->persist_enabled) {
          {
          udev->reset_resume = 1U;
          }
          goto retry_reset_resume;
        }
      }
    }
  }
  if (! status) {
    if (udev->actconfig) {
      {
      while (1) {
        while_526_continue: /* CIL Label */ ;
        goto while_526_break;
      }
      while_526_break: /* CIL Label */ ;
      }
      if ((int )devstatus & (1 << 1)) {
        {
        tmp___7 = __create_pipe(udev, 0U);
        status = usb_control_msg(udev, (unsigned int )(2 << 30) | tmp___7, (unsigned char)1,
                                 (unsigned char)0, (unsigned short)1, (unsigned short)0,
                                 (void *)0, (unsigned short)0, 5000);
        }
        if (status) {

        }
      }
      {
      status = 0;
      }
    }
  }
  return (status);
}
}
int usb_port_resume(struct usb_device *udev , pm_message_t msg ) 
{ struct usb_hub *hub ;
  struct usb_hub *tmp ;
  int port1 ;
  int status ;
  u16 portchange ;
  u16 portstatus ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
  tmp = hdev_to_hub(udev->parent);
  hub = tmp;
  port1 = (int )udev->portnum;
  status = hub_port_status(hub, port1, & portstatus, & portchange);
  }
  if (status == 0) {
    if (! ((int )portstatus & 4)) {
      goto SuspendCleared;
    }
  }
  {
  set_bit((unsigned int )port1, (unsigned long volatile   *)(hub->busy_bits));
  status = clear_port_feature(hub->hdev, port1, 2);
  }
  if (! status) {
    {
    msleep(25U);
    status = hub_port_status(hub, port1, & portstatus, & portchange);
    msleep(10U);
    }
  }
  SuspendCleared: 
  if (status == 0) {
    if ((int )portchange & 4) {
      {
      clear_port_feature(hub->hdev, port1, 18);
      }
    }
  }
  {
  clear_bit(port1, (unsigned long volatile   *)(hub->busy_bits));
  status = check_port_resume_type(udev, hub, port1, status, (unsigned int )portchange,
                                  (unsigned int )portstatus);
  }
  if (status == 0) {
    {
    status = finish_port_resume(udev);
    }
  }
  if (status < 0) {
    {
    hub_port_logical_disconnect(hub, port1);
    }
  }
  return (status);
}
}
static int remote_wakeup(struct usb_device *udev ) 
{ int status ;
  char const   *tmp ;
  char const   *tmp___0 ;
  struct pm_message __constr_expr_0 ;

  {
  {
  status = 0;
  }
  if ((unsigned int )udev->state == 8U) {
    {
    usb_mark_last_busy(udev);
    __constr_expr_0.event = 528;
    status = usb_external_resume_device(udev, __constr_expr_0);
    }
  }
  return (status);
}
}
static int hub_suspend(struct usb_interface *intf , pm_message_t msg ) 
{ struct usb_hub *hub ;
  void *tmp ;
  struct usb_device *hdev ;
  unsigned int port1 ;
  struct usb_device *udev ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
  tmp = usb_get_intfdata(intf);
  hub = (struct usb_hub *)tmp;
  hdev = hub->hdev;
  port1 = 1U;
  }
  {
  while (1) {
    while_527_continue: /* CIL Label */ ;
    if (! (port1 <= (unsigned int )hdev->maxchild)) {
      goto while_527_break;
    }
    {
    udev = hdev->children[port1 - 1U];
    }
    if (udev) {
      if (udev->can_submit) {
        if (! (msg.event & 1024)) {

        }
        return (-16);
      }
    }
    {
    port1 ++;
    }
  }
  while_527_break: /* CIL Label */ ;
  }
  {
  hub_quiesce(hub, (enum hub_quiescing_type )2);
  }
  return (0);
}
}
static int hub_resume(struct usb_interface *intf ) 
{ struct usb_hub *hub ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  tmp = usb_get_intfdata(intf);
  hub = (struct usb_hub *)tmp;
  hub_activate(hub, (enum hub_activation_type )4);
  }
  return (0);
}
}
static int hub_reset_resume(struct usb_interface *intf ) 
{ struct usb_hub *hub ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  tmp = usb_get_intfdata(intf);
  hub = (struct usb_hub *)tmp;
  hub_activate(hub, (enum hub_activation_type )5);
  }
  return (0);
}
}
void usb_root_hub_lost_power(struct usb_device *rhdev ) 
{ char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  tmp = dev_name((struct device  const  *)(& rhdev->dev));
  tmp___0 = dev_driver_string((struct device  const  *)(& rhdev->dev));
  printk("<4>%s %s: root hub lost power or was reset\n", tmp___0, tmp);
  rhdev->reset_resume = 1U;
  }
  return;
}
}
static char const   __kstrtab_usb_root_hub_lost_power[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'o',      (char const   )'o',      (char const   )'t', 
        (char const   )'_',      (char const   )'h',      (char const   )'u',      (char const   )'b', 
        (char const   )'_',      (char const   )'l',      (char const   )'o',      (char const   )'s', 
        (char const   )'t',      (char const   )'_',      (char const   )'p',      (char const   )'o', 
        (char const   )'w',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_root_hub_lost_power  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_root_hub_lost_power), __kstrtab_usb_root_hub_lost_power};
static int hub_port_debounce(struct usb_hub *hub ,
                             int port1 ) 
{ int ret ;
  int total_time ;
  int stable_time ;
  u16 portchange ;
  u16 portstatus ;
  unsigned int connection ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  stable_time = 0;
  connection = 65535U;
  total_time = 0;
  }
  {
  while (1) {
    while_528_continue: /* CIL Label */ ;
    {
    ret = hub_port_status(hub, port1, & portstatus, & portchange);
    }
    if (ret < 0) {
      return (ret);
    }
    if (! ((int )portchange & 1)) {
      if ((unsigned int )((int )portstatus & 1) == connection) {
        {
        stable_time += 25;
        }
        if (stable_time >= 100) {
          goto while_528_break;
        }
      } else {
        {
        stable_time = 0;
        connection = (unsigned int )((int )portstatus & 1);
        }
      }
    } else {
      {
      stable_time = 0;
      connection = (unsigned int )((int )portstatus & 1);
      }
    }
    if ((int )portchange & 1) {
      {
      clear_port_feature(hub->hdev, port1, 16);
      }
    }
    if (total_time >= 1500) {
      goto while_528_break;
    }
    {
    msleep(25U);
    total_time += 25;
    }
  }
  while_528_break: /* CIL Label */ ;
  }
  if (stable_time < 100) {
    return (-110);
  }
  return ((int )portstatus);
}
}
void usb_ep0_reinit(struct usb_device *udev ) 
{ 

  {
  {
  usb_disable_endpoint(udev, 128U, (_Bool)1);
  usb_disable_endpoint(udev, 0U, (_Bool)1);
  usb_enable_endpoint(udev, & udev->ep0, (_Bool)1);
  }
  return;
}
}
static char const   __kstrtab_usb_ep0_reinit[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'e',      (char const   )'p',      (char const   )'0',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'i',      (char const   )'n', 
        (char const   )'i',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_ep0_reinit  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_ep0_reinit), __kstrtab_usb_ep0_reinit};
static int hub_set_address(struct usb_device *udev , int devnum ) 
{ int retval ;

  {
  if (devnum <= 1) {
    return (-22);
  }
  if ((unsigned int )udev->state == 6U) {
    return (0);
  }
  if ((unsigned int )udev->state != 5U) {
    return (-22);
  }
  {
  retval = usb_control_msg(udev, (unsigned int )(2 << 30), (unsigned char)5, (unsigned char)0,
                           (unsigned short )devnum, (unsigned short)0, (void *)0,
                           (unsigned short)0, 5000);
  }
  if (retval == 0) {
    {
    update_address(udev, devnum);
    usb_set_device_state(udev, (enum usb_device_state )6);
    usb_ep0_reinit(udev);
    }
  }
  return (retval);
}
}
static int hub_port_init(struct usb_hub *hub , struct usb_device *udev , int port1 ,
                         int retry_counter ) ;
static struct mutex usb_address0_mutex  =    {{(int volatile   )1}, {{0U}}, {& usb_address0_mutex.wait_list, & usb_address0_mutex.wait_list},
    (struct thread_info *)0};
static int hub_port_init(struct usb_hub *hub , struct usb_device *udev , int port1 ,
                         int retry_counter ) 
{ struct usb_device *hdev ;
  int i ;
  int j ;
  int retval ;
  unsigned int delay ;
  enum usb_device_speed oldspeed ;
  char *speed ;
  char *type ;
  int devnum ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  struct usb_device_descriptor *buf ;
  int r ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;

  {
  {
  hdev = hub->hdev;
  delay = 10U;
  oldspeed = udev->speed;
  devnum = udev->devnum;
  }
  if (! hdev->parent) {
    {
    delay = 50U;
    }
    if (port1 == (int )(hdev->bus)->otg_port) {
      {
      (hdev->bus)->b_hnp_enable = 0U;
      }
    }
  }
  if ((unsigned int )oldspeed == 1U) {
    {
    delay = 200U;
    }
  }
  {
  mutex_lock(& usb_address0_mutex);
  retval = hub_port_reset(hub, port1, udev, delay);
  }
  if (retval < 0) {
    goto fail;
  }
  {
  retval = -19;
  }
  if ((unsigned int )oldspeed != 0U) {
    if ((unsigned int )oldspeed != (unsigned int )udev->speed) {
      goto fail;
    }
  }
  {
  oldspeed = udev->speed;
  }
  if ((int )udev->speed == 4) {
    goto switch_529_4;
  } else {
    if ((int )udev->speed == 3) {
      goto switch_529_3;
    } else {
      if ((int )udev->speed == 2) {
        goto switch_529_2;
      } else {
        if ((int )udev->speed == 1) {
          goto switch_529_1;
        } else {
          {
          goto switch_529_default;
          if (0) {
            switch_529_4: /* CIL Label */ 
            {
            udev->ep0.desc.wMaxPacketSize = (unsigned short)512;
            }
            goto switch_529_break;
            switch_529_3: /* CIL Label */ 
            {
            udev->ep0.desc.wMaxPacketSize = (unsigned short)64;
            }
            goto switch_529_break;
            switch_529_2: /* CIL Label */ 
            {
            udev->ep0.desc.wMaxPacketSize = (unsigned short)64;
            }
            goto switch_529_break;
            switch_529_1: /* CIL Label */ 
            {
            udev->ep0.desc.wMaxPacketSize = (unsigned short)8;
            }
            goto switch_529_break;
            switch_529_default: /* CIL Label */ 
            {

            }
            goto fail;
          } else {
            switch_529_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  type = (char *)"";
  }
  if ((int )udev->speed == 1) {
    goto switch_530_1;
  } else {
    if ((int )udev->speed == 2) {
      goto switch_530_2;
    } else {
      if ((int )udev->speed == 3) {
        goto switch_530_3;
      } else {
        if ((int )udev->speed == 4) {
          goto switch_530_4;
        } else {
          {
          goto switch_530_default;
          if (0) {
            switch_530_1: /* CIL Label */ 
            {
            speed = (char *)"low";
            }
            goto switch_530_break;
            switch_530_2: /* CIL Label */ 
            {
            speed = (char *)"full";
            }
            goto switch_530_break;
            switch_530_3: /* CIL Label */ 
            {
            speed = (char *)"high";
            }
            goto switch_530_break;
            switch_530_4: /* CIL Label */ 
            {
            speed = (char *)"variable";
            type = (char *)"Wireless ";
            }
            goto switch_530_break;
            switch_530_default: /* CIL Label */ 
            {
            speed = (char *)"?";
            }
            goto switch_530_break;
          } else {
            switch_530_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  if (udev->config) {
    {
    tmp___1 = "reset";
    }
  } else {
    {
    tmp___1 = "new";
    }
  }
  {
  tmp___2 = dev_name((struct device  const  *)(& udev->dev));
  tmp___3 = dev_driver_string((struct device  const  *)(& udev->dev));
  printk("<6>%s %s: %s %s speed %sUSB device using %s and address %d\n", tmp___3,
         tmp___2, tmp___1, speed, type, (((udev->bus)->controller)->driver)->name,
         devnum);
  }
  if (hdev->tt) {
    {
    udev->tt = hdev->tt;
    udev->ttport = hdev->ttport;
    }
  } else {
    if ((unsigned int )udev->speed != 3U) {
      if ((unsigned int )hdev->speed == 3U) {
        {
        udev->tt = & hub->tt;
        udev->ttport = port1;
        }
      }
    }
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_531_continue: /* CIL Label */ ;
    if (! (i < 2)) {
      goto while_531_break;
    }
    if (retry_counter / 2 == old_scheme_first) {
      {
      r = 0;
      tmp___4 = kmalloc(64U, 16U);
      buf = (struct usb_device_descriptor *)tmp___4;
      }
      if (! buf) {
        {
        retval = -12;
        }
        goto __Cont;
      }
      {
      j = 0;
      }
      {
      while (1) {
        while_532_continue: /* CIL Label */ ;
        if (! (j < 3)) {
          goto while_532_break;
        }
        {
        buf->bMaxPacketSize0 = (unsigned char)0;
        r = usb_control_msg(udev, (unsigned int )((2 << 30) | 128), (unsigned char)6,
                            (unsigned char)128, (unsigned short )(1 << 8), (unsigned short)0,
                            (void *)buf, (unsigned short)64, initial_descriptor_timeout);
        }
        if ((int )buf->bMaxPacketSize0 == 8) {
          goto switch_533_8;
        } else {
          if ((int )buf->bMaxPacketSize0 == 16) {
            goto switch_533_8;
          } else {
            if ((int )buf->bMaxPacketSize0 == 32) {
              goto switch_533_8;
            } else {
              if ((int )buf->bMaxPacketSize0 == 64) {
                goto switch_533_8;
              } else {
                if ((int )buf->bMaxPacketSize0 == 255) {
                  goto switch_533_8;
                } else {
                  {
                  goto switch_533_default;
                  if (0) {
                    switch_533_8: /* CIL Label */ 
                    switch_533_16: /* CIL Label */ 
                    switch_533_32: /* CIL Label */ 
                    switch_533_64: /* CIL Label */ 
                    switch_533_255: /* CIL Label */ 
                    if ((int )buf->bDescriptorType == 1) {
                      {
                      r = 0;
                      }
                      goto switch_533_break;
                    }
                    switch_533_default: /* CIL Label */ 
                    {

                    }
                    if (r == 0) {
                      {
                      r = -71;
                      }
                    }
                    goto switch_533_break;
                  } else {
                    switch_533_break: /* CIL Label */ ;
                  }
                  }
                }
              }
            }
          }
        }
        if (r == 0) {
          goto while_532_break;
        }
        {
        j ++;
        }
      }
      while_532_break: /* CIL Label */ ;
      }
      {
      udev->descriptor.bMaxPacketSize0 = buf->bMaxPacketSize0;
      kfree((void const   *)buf);
      retval = hub_port_reset(hub, port1, udev, delay);
      }
      if (retval < 0) {
        goto fail;
      }
      if ((unsigned int )oldspeed != (unsigned int )udev->speed) {
        {
        retval = -19;
        }
        goto fail;
      }
      if (r) {
        {
        tmp___7 = dev_name((struct device  const  *)(& udev->dev));
        tmp___8 = dev_driver_string((struct device  const  *)(& udev->dev));
        printk("<3>%s %s: device descriptor read/64, error %d\n", tmp___8, tmp___7,
               r);
        retval = -90;
        }
        goto __Cont;
      }
    }
    if (udev->wusb == 0U) {
      {
      j = 0;
      }
      {
      while (1) {
        while_534_continue: /* CIL Label */ ;
        if (! (j < 2)) {
          goto while_534_break;
        }
        {
        retval = hub_set_address(udev, devnum);
        }
        if (retval >= 0) {
          goto while_534_break;
        }
        {
        msleep(200U);
        j ++;
        }
      }
      while_534_break: /* CIL Label */ ;
      }
      if (retval < 0) {
        {
        tmp___9 = dev_name((struct device  const  *)(& udev->dev));
        tmp___10 = dev_driver_string((struct device  const  *)(& udev->dev));
        printk("<3>%s %s: device not accepting address %d, error %d\n", tmp___10,
               tmp___9, devnum, retval);
        }
        goto fail;
      }
      {
      msleep(10U);
      }
      if (retry_counter / 2 == old_scheme_first) {
        goto while_531_break;
      }
    }
    {
    retval = usb_get_device_descriptor(udev, 8U);
    }
    if (retval < 8) {
      {
      tmp___11 = dev_name((struct device  const  *)(& udev->dev));
      tmp___12 = dev_driver_string((struct device  const  *)(& udev->dev));
      printk("<3>%s %s: device descriptor read/8, error %d\n", tmp___12, tmp___11,
             retval);
      }
      if (retval >= 0) {
        {
        retval = -90;
        }
      }
    } else {
      {
      retval = 0;
      }
      goto while_531_break;
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    msleep(100U);
    }
  }
  while_531_break: /* CIL Label */ ;
  }
  if (retval) {
    goto fail;
  }
  if ((int )udev->descriptor.bMaxPacketSize0 == 255) {
    {
    i = 512;
    }
  } else {
    {
    i = (int )udev->descriptor.bMaxPacketSize0;
    }
  }
  if ((int )udev->ep0.desc.wMaxPacketSize != i) {
    if ((unsigned int )udev->speed != 2U) {
      {
      tmp___13 = dev_name((struct device  const  *)(& udev->dev));
      tmp___14 = dev_driver_string((struct device  const  *)(& udev->dev));
      printk("<3>%s %s: ep0 maxpacket = %d\n", tmp___14, tmp___13, i);
      retval = -90;
      }
      goto fail;
    } else {
      if (! (i == 8)) {
        if (! (i == 16)) {
          if (! (i == 32)) {
            if (! (i == 64)) {
              {
              tmp___13 = dev_name((struct device  const  *)(& udev->dev));
              tmp___14 = dev_driver_string((struct device  const  *)(& udev->dev));
              printk("<3>%s %s: ep0 maxpacket = %d\n", tmp___14, tmp___13, i);
              retval = -90;
              }
              goto fail;
            }
          }
        }
      }
    }
    {
    udev->ep0.desc.wMaxPacketSize = (unsigned short )i;
    usb_ep0_reinit(udev);
    }
  }
  {
  retval = usb_get_device_descriptor(udev, 18U);
  }
  if (retval < (int )sizeof(udev->descriptor)) {
    {
    tmp___17 = dev_name((struct device  const  *)(& udev->dev));
    tmp___18 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<3>%s %s: device descriptor read/all, error %d\n", tmp___18, tmp___17,
           retval);
    }
    if (retval >= 0) {
      {
      retval = -42;
      }
    }
    goto fail;
  }
  {
  retval = 0;
  }
  fail: 
  if (retval) {
    {
    hub_port_disable(hub, port1, 0);
    update_address(udev, devnum);
    }
  }
  {
  mutex_unlock(& usb_address0_mutex);
  }
  return (retval);
}
}
static void check_highspeed(struct usb_hub *hub , struct usb_device *udev , int port1 ) 
{ struct usb_qualifier_descriptor *qual ;
  int status ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
  tmp = kmalloc((unsigned int )sizeof(*qual), 208U);
  qual = (struct usb_qualifier_descriptor *)tmp;
  }
  if ((unsigned long )qual == (unsigned long )((void *)0)) {
    return;
  }
  {
  status = usb_get_descriptor(udev, (unsigned char)6, (unsigned char)0, (void *)qual,
                              (int )sizeof(*qual));
  }
  if ((unsigned long )status == sizeof(*qual)) {
    {
    tmp___0 = dev_name((struct device  const  *)(& udev->dev));
    tmp___1 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<6>%s %s: not running at top speed; connect to a high speed hub\n", tmp___1,
           tmp___0);
    }
    if (hub->has_indicators) {
      {
      hub->indicator[port1 - 1] = (unsigned char)2;
      schedule_delayed_work(& hub->leds, 0UL);
      }
    }
  }
  {
  kfree((void const   *)qual);
  }
  return;
}
}
static unsigned int hub_power_remaining(struct usb_hub *hub ) 
{ struct usb_device *hdev ;
  int remaining ;
  int port1 ;
  struct usb_device *udev ;
  int delta ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  hdev = hub->hdev;
  }
  if (! hub->limited_power) {
    return (0U);
  }
  {
  remaining = (int )hdev->bus_mA - (int )(hub->descriptor)->bHubContrCurrent;
  port1 = 1;
  }
  {
  while (1) {
    while_535_continue: /* CIL Label */ ;
    if (! (port1 <= hdev->maxchild)) {
      goto while_535_break;
    }
    {
    udev = hdev->children[port1 - 1];
    }
    if (! udev) {
      goto __Cont;
    }
    if (udev->actconfig) {
      {
      delta = (int )(udev->actconfig)->desc.bMaxPower * 2;
      }
    } else {
      if (port1 != (int )(udev->bus)->otg_port) {
        {
        delta = 100;
        }
      } else {
        if (hdev->parent) {
          {
          delta = 100;
          }
        } else {
          {
          delta = 8;
          }
        }
      }
    }
    if ((unsigned int )delta > hub->mA_per_port) {
      {
      tmp = dev_name((struct device  const  *)(& udev->dev));
      tmp___0 = dev_driver_string((struct device  const  *)(& udev->dev));
      printk("<4>%s %s: %dmA is over %umA budget for port %d!\n", tmp___0, tmp, delta,
             hub->mA_per_port, port1);
      }
    }
    {
    remaining -= delta;
    }
    __Cont: /* CIL Label */ 
    {
    port1 ++;
    }
  }
  while_535_break: /* CIL Label */ ;
  }
  if (remaining < 0) {
    {
    tmp___1 = dev_name((struct device  const  *)hub->intfdev);
    tmp___2 = dev_driver_string((struct device  const  *)hub->intfdev);
    printk("<4>%s %s: %dmA over power budget!\n", tmp___2, tmp___1, - remaining);
    remaining = 0;
    }
  }
  return ((unsigned int )remaining);
}
}
static void hub_port_connect_change(struct usb_hub *hub , int port1 , u16 portstatus ,
                                    u16 portchange ) 
{ struct usb_device *hdev ;
  struct device *hub_dev ;
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  unsigned int wHubCharacteristics ;
  struct usb_device *udev ;
  int status ;
  int i ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  u16 devstat ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  unsigned int tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;

  {
  {
  hdev = hub->hdev;
  hub_dev = hub->intfdev;
  tmp = bus_to_hcd(hdev->bus);
  hcd = tmp;
  wHubCharacteristics = (unsigned int )(hub->descriptor)->wHubCharacteristics;
  }
  if (hub->has_indicators) {
    {
    set_port_led(hub, port1, 0);
    hub->indicator[port1 - 1] = (unsigned char)0;
    }
  }
  {
  udev = hdev->children[port1 - 1];
  }
  if ((int )portstatus & 1) {
    if (udev) {
      if ((unsigned int )udev->state != 0U) {
        {
        down(& udev->dev.sem);
        }
        if ((int )portstatus & 2) {
          {
          status = 0;
          }
        } else {
          if ((unsigned int )udev->state == 8U) {
            if (udev->persist_enabled) {
              if (udev->do_remote_wakeup) {
                {
                status = remote_wakeup(udev);
                }
              } else {
                {
                status = 0;
                }
              }
            } else {
              {
              status = -19;
              }
            }
          } else {
            {
            status = -19;
            }
          }
        }
        {
        up(& udev->dev.sem);
        }
        if (status == 0) {
          {
          clear_bit(port1, (unsigned long volatile   *)(hub->change_bits));
          }
          return;
        }
      }
    }
  }
  if (udev) {
    {
    usb_disconnect(& hdev->children[port1 - 1]);
    }
  }
  {
  clear_bit(port1, (unsigned long volatile   *)(hub->change_bits));
  }
  if ((int )portchange & 3) {
    {
    status = hub_port_debounce(hub, port1);
    }
    if (status < 0) {
      {
      tmp___5 = printk_ratelimit();
      }
      if (tmp___5) {
        {
        tmp___3 = dev_name((struct device  const  *)hub_dev);
        tmp___4 = dev_driver_string((struct device  const  *)hub_dev);
        printk("<3>%s %s: connect-debounce failed, port %d disabled\n", tmp___4, tmp___3,
               port1);
        }
      }
      {
      portstatus = (unsigned short )((int )portstatus & -2);
      }
    } else {
      {
      portstatus = (unsigned short )status;
      }
    }
  }
  if (! ((int )portstatus & 1)) {
    if ((wHubCharacteristics & 3U) < 2U) {
      if (! ((int )portstatus & (1 << 8))) {
        {
        set_port_feature(hdev, port1, 8);
        }
      }
    }
    if ((int )portstatus & 2) {
      goto done;
    }
    return;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_536_continue: /* CIL Label */ ;
    if (! (i < 2 * (use_both_schemes + 1))) {
      goto while_536_break;
    }
    {
    udev = usb_alloc_dev(hdev, hdev->bus, (unsigned int )port1);
    }
    if (! udev) {
      {
      tmp___6 = dev_name((struct device  const  *)hub_dev);
      tmp___7 = dev_driver_string((struct device  const  *)hub_dev);
      printk("<3>%s %s: couldn\'t allocate port %d usb_device\n", tmp___7, tmp___6,
             port1);
      }
      goto done;
    }
    {
    usb_set_device_state(udev, (enum usb_device_state )2);
    udev->speed = (enum usb_device_speed )0;
    udev->bus_mA = (unsigned short )hub->mA_per_port;
    udev->level = (unsigned char )((int )hdev->level + 1);
    udev->wusb = hub_is_wusb(hub);
    choose_address(udev);
    }
    if (udev->devnum <= 0) {
      {
      status = -107;
      }
      goto loop;
    }
    {
    status = hub_port_init(hub, udev, port1, i);
    }
    if (status < 0) {
      goto loop;
    }
    if ((int )udev->descriptor.bDeviceClass == 9) {
      if ((int )udev->bus_mA <= 100) {
        {
        status = usb_get_status(udev, 0, 0, (void *)(& devstat));
        }
        if (status < 2) {
          goto loop_disable;
        }
        {
        while (1) {
          while_537_continue: /* CIL Label */ ;
          goto while_537_break;
        }
        while_537_break: /* CIL Label */ ;
        }
        if (((int )devstat & 1) == 0) {
          {
          tmp___10 = dev_name((struct device  const  *)(& udev->dev));
          tmp___11 = dev_driver_string((struct device  const  *)(& udev->dev));
          printk("<3>%s %s: can\'t connect bus-powered hub to this port\n", tmp___11,
                 tmp___10);
          }
          if (hub->has_indicators) {
            {
            hub->indicator[port1 - 1] = (unsigned char)4;
            schedule_delayed_work(& hub->leds, 0UL);
            }
          }
          {
          status = -107;
          }
          goto loop_disable;
        }
      }
    }
    if ((int )udev->descriptor.bcdUSB >= 512) {
      if ((unsigned int )udev->speed == 2U) {
        if (highspeed_hubs != 0U) {
          {
          check_highspeed(hub, udev, port1);
          }
        }
      }
    }
    {
    status = 0;
    _spin_lock_irq(& device_state_lock);
    }
    if ((unsigned int )hdev->state == 0U) {
      {
      status = -107;
      }
    } else {
      {
      hdev->children[port1 - 1] = udev;
      }
    }
    {
    while (1) {
      while_538_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& device_state_lock.raw_lock);
      }
      {
      while (1) {
        while_539_continue: /* CIL Label */ ;
        {
        while (1) {
          while_540_continue: /* CIL Label */ ;
          goto while_540_break;
        }
        while_540_break: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_539_break;
      }
      while_539_break: /* CIL Label */ ;
      }
      goto while_538_break;
    }
    while_538_break: /* CIL Label */ ;
    }
    if (! status) {
      {
      status = usb_new_device(udev);
      }
      if (status) {
        {
        _spin_lock_irq(& device_state_lock);
        hdev->children[port1 - 1] = (struct usb_device *)((void *)0);
        }
        {
        while (1) {
          while_541_continue: /* CIL Label */ ;
          {
          __raw_spin_unlock(& device_state_lock.raw_lock);
          }
          {
          while (1) {
            while_542_continue: /* CIL Label */ ;
            {
            while (1) {
              while_543_continue: /* CIL Label */ ;
              goto while_543_break;
            }
            while_543_break: /* CIL Label */ ;
            }
            {
            raw_local_irq_enable();
            }
            goto while_542_break;
          }
          while_542_break: /* CIL Label */ ;
          }
          goto while_541_break;
        }
        while_541_break: /* CIL Label */ ;
        }
      }
    }
    if (status) {
      goto loop_disable;
    }
    {
    tmp___12 = hub_power_remaining(hub);
    status = (int )tmp___12;
    }
    if (status) {

    }
    return;
    loop_disable: 
    {
    hub_port_disable(hub, port1, 1);
    }
    loop: 
    {
    usb_ep0_reinit(udev);
    release_address(udev);
    usb_put_dev(udev);
    }
    if (status == -107) {
      goto while_536_break;
    } else {
      if (status == -524) {
        goto while_536_break;
      }
    }
    {
    i ++;
    }
  }
  while_536_break: /* CIL Label */ ;
  }
  if ((hub->hdev)->parent) {
    {
    tmp___15 = dev_name((struct device  const  *)hub_dev);
    tmp___16 = dev_driver_string((struct device  const  *)hub_dev);
    printk("<3>%s %s: unable to enumerate USB device on port %d\n", tmp___16, tmp___15,
           port1);
    }
  } else {
    if (! (hcd->driver)->port_handed_over) {
      {
      tmp___15 = dev_name((struct device  const  *)hub_dev);
      tmp___16 = dev_driver_string((struct device  const  *)hub_dev);
      printk("<3>%s %s: unable to enumerate USB device on port %d\n", tmp___16, tmp___15,
             port1);
      }
    } else {
      {
      tmp___17 = (*((hcd->driver)->port_handed_over))(hcd, port1);
      }
      if (! tmp___17) {
        {
        tmp___15 = dev_name((struct device  const  *)hub_dev);
        tmp___16 = dev_driver_string((struct device  const  *)hub_dev);
        printk("<3>%s %s: unable to enumerate USB device on port %d\n", tmp___16,
               tmp___15, port1);
        }
      }
    }
  }
  done: 
  {
  hub_port_disable(hub, port1, 1);
  }
  if ((hcd->driver)->relinquish_port) {
    if (! (hub->hdev)->parent) {
      {
      (*((hcd->driver)->relinquish_port))(hcd, port1);
      }
    }
  }
  return;
}
}
static void hub_events(void) 
{ struct list_head *tmp ;
  struct usb_device *hdev ;
  struct usb_interface *intf ;
  struct usb_hub *hub ;
  struct device *hub_dev ;
  u16 hubstatus ;
  u16 hubchange ;
  u16 portstatus ;
  u16 portchange ;
  int i ;
  int ret ;
  int connect_change ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  struct device  const  *__mptr___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  struct usb_device *udev ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
  {
  while (1) {
    while_544_continue: /* CIL Label */ ;
    {
    _spin_lock_irq(& hub_event_lock);
    tmp___0 = list_empty((struct list_head  const  *)(& hub_event_list));
    }
    if (tmp___0) {
      {
      while (1) {
        while_545_continue: /* CIL Label */ ;
        {
        __raw_spin_unlock(& hub_event_lock.raw_lock);
        }
        {
        while (1) {
          while_546_continue: /* CIL Label */ ;
          {
          while (1) {
            while_547_continue: /* CIL Label */ ;
            goto while_547_break;
          }
          while_547_break: /* CIL Label */ ;
          }
          {
          raw_local_irq_enable();
          }
          goto while_546_break;
        }
        while_546_break: /* CIL Label */ ;
        }
        goto while_545_break;
      }
      while_545_break: /* CIL Label */ ;
      }
      goto while_544_break;
    }
    {
    tmp = hub_event_list.next;
    list_del_init(tmp);
    __mptr = (struct list_head  const  *)tmp;
    hub = (struct usb_hub *)((char *)__mptr - (unsigned int )(& ((struct usb_hub *)0)->event_list));
    kref_get(& hub->kref);
    }
    {
    while (1) {
      while_548_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& hub_event_lock.raw_lock);
      }
      {
      while (1) {
        while_549_continue: /* CIL Label */ ;
        {
        while (1) {
          while_550_continue: /* CIL Label */ ;
          goto while_550_break;
        }
        while_550_break: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_549_break;
      }
      while_549_break: /* CIL Label */ ;
      }
      goto while_548_break;
    }
    while_548_break: /* CIL Label */ ;
    }
    {
    hdev = hub->hdev;
    hub_dev = hub->intfdev;
    __mptr___0 = (struct device  const  *)hub_dev;
    intf = (struct usb_interface *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_interface *)0)->dev));
    down(& hdev->dev.sem);
    tmp___4 = __builtin_expect((long )(! (! hub->disconnected)), 0L);
    }
    if (tmp___4) {
      goto loop;
    }
    if ((unsigned int )hdev->state == 0U) {
      {
      hub->error = -19;
      hub_quiesce(hub, (enum hub_quiescing_type )0);
      }
      goto loop;
    }
    {
    ret = usb_autopm_get_interface(intf);
    }
    if (ret) {
      goto loop;
    }
    if (hub->quiescing) {
      goto loop_autopm;
    }
    if (hub->error) {
      {
      ret = usb_reset_device(hdev);
      }
      if (ret) {
        goto loop_autopm;
      }
      {
      hub->nerrors = 0;
      hub->error = 0;
      }
    }
    {
    i = 1;
    }
    {
    while (1) {
      while_551_continue: /* CIL Label */ ;
      if (! (i <= (int )(hub->descriptor)->bNbrPorts)) {
        goto while_551_break;
      }
      {
      tmp___12 = variable_test_bit(i, (unsigned long const volatile   *)(hub->busy_bits));
      }
      if (tmp___12) {
        goto __Cont;
      }
      {
      tmp___14 = variable_test_bit(i, (unsigned long const volatile   *)(hub->change_bits));
      connect_change = tmp___14;
      tmp___15 = test_and_clear_bit(i, (unsigned long volatile   *)(hub->event_bits));
      }
      if (! tmp___15) {
        if (! connect_change) {
          goto __Cont;
        }
      }
      {
      ret = hub_port_status(hub, i, & portstatus, & portchange);
      }
      if (ret < 0) {
        goto __Cont;
      }
      if ((int )portchange & 1) {
        {
        clear_port_feature(hdev, i, 16);
        connect_change = 1;
        }
      }
      if ((int )portchange & 2) {
        if (! connect_change) {

        }
        {
        clear_port_feature(hdev, i, 17);
        }
        if (! ((int )portstatus & 2)) {
          if (! connect_change) {
            if (hdev->children[i - 1]) {
              {
              tmp___18 = dev_name((struct device  const  *)hub_dev);
              tmp___19 = dev_driver_string((struct device  const  *)hub_dev);
              printk("<3>%s %s: port %i disabled by hub (EMI?), re-enabling...\n",
                     tmp___19, tmp___18, i);
              connect_change = 1;
              }
            }
          }
        }
      }
      if ((int )portchange & 4) {
        {
        clear_port_feature(hdev, i, 18);
        udev = hdev->children[i - 1];
        }
        if (udev) {
          {
          down(& udev->dev.sem);
          ret = remote_wakeup(hdev->children[i - 1]);
          up(& udev->dev.sem);
          }
          if (ret < 0) {
            {
            connect_change = 1;
            }
          }
        } else {
          {
          ret = -19;
          hub_port_disable(hub, i, 1);
          }
        }
      }
      if ((int )portchange & 8) {
        {
        tmp___22 = dev_name((struct device  const  *)hub_dev);
        tmp___23 = dev_driver_string((struct device  const  *)hub_dev);
        printk("<3>%s %s: over-current change on port %d\n", tmp___23, tmp___22, i);
        clear_port_feature(hdev, i, 19);
        hub_power_on(hub, (_Bool)1);
        }
      }
      if ((int )portchange & 16) {
        {
        clear_port_feature(hdev, i, 20);
        }
      }
      if (connect_change) {
        {
        hub_port_connect_change(hub, i, portstatus, portchange);
        }
      }
      __Cont: /* CIL Label */ 
      {
      i ++;
      }
    }
    while_551_break: /* CIL Label */ ;
    }
    {
    tmp___33 = test_and_clear_bit(0, (unsigned long volatile   *)(hub->event_bits));
    }
    if (! (tmp___33 == 0)) {
      {
      tmp___32 = hub_hub_status(hub, & hubstatus, & hubchange);
      }
      if (tmp___32 < 0) {
        {
        tmp___26 = dev_name((struct device  const  *)hub_dev);
        tmp___27 = dev_driver_string((struct device  const  *)hub_dev);
        printk("<3>%s %s: get_hub_status failed\n", tmp___27, tmp___26);
        }
      } else {
        if ((int )hubchange & 1) {
          {
          clear_hub_feature(hdev, 0);
          }
          if ((int )hubstatus & 1) {
            {
            hub->limited_power = 1U;
            }
          } else {
            {
            hub->limited_power = 0U;
            }
          }
        }
        if ((int )hubchange & 2) {
          {
          msleep(500U);
          clear_hub_feature(hdev, 1);
          hub_power_on(hub, (_Bool)1);
          }
        }
      }
    }
    loop_autopm: 
    {
    tmp___34 = list_empty((struct list_head  const  *)(& hub->event_list));
    }
    if (tmp___34) {
      {
      usb_autopm_enable(intf);
      }
    }
    loop: 
    {
    up(& hdev->dev.sem);
    kref_put(& hub->kref, & hub_release);
    }
  }
  while_544_break: /* CIL Label */ ;
  }
  return;
}
}
static int hub_thread(void *__unused ) 
{ int __retval ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct task_struct *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct task_struct *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
  set_freezable();
  }
  {
  while (1) {
    while_552_continue: /* CIL Label */ ;
    {
    hub_events();
    }
    {
    while (1) {
      while_553_continue: /* CIL Label */ ;
      {
      __ret = 0;
      tmp___6 = list_empty((struct list_head  const  *)(& hub_event_list));
      }
      if (tmp___6) {
        {
        tmp___7 = kthread_should_stop();
        }
        if (! tmp___7) {
          {
          tmp___8 = get_current();
          tmp___9 = freezing(tmp___8);
          }
          if (! tmp___9) {
            {
            while (1) {
              while_554_continue: /* CIL Label */ ;
              {
              tmp = get_current();
              __wait.flags = 0U;
              __wait.private = (void *)tmp;
              __wait.func = & autoremove_wake_function;
              __wait.task_list.next = & __wait.task_list;
              __wait.task_list.prev = & __wait.task_list;
              }
              {
              while (1) {
                while_555_continue: /* CIL Label */ ;
                {
                prepare_to_wait(& khubd_wait, & __wait, 1);
                tmp___0 = list_empty((struct list_head  const  *)(& hub_event_list));
                }
                if (tmp___0) {
                  {
                  tmp___1 = kthread_should_stop();
                  }
                  if (tmp___1) {
                    goto while_555_break;
                  } else {
                    {
                    tmp___2 = get_current();
                    tmp___3 = freezing(tmp___2);
                    }
                    if (tmp___3) {
                      goto while_555_break;
                    }
                  }
                } else {
                  goto while_555_break;
                }
                {
                tmp___4 = get_current();
                tmp___5 = signal_pending(tmp___4);
                }
                if (! tmp___5) {
                  {
                  schedule();
                  }
                  goto __Cont;
                }
                {
                __ret = -512;
                }
                goto while_555_break;
                __Cont: /* CIL Label */ 
                {

                }
              }
              while_555_break: /* CIL Label */ ;
              }
              {
              finish_wait(& khubd_wait, & __wait);
              }
              goto while_554_break;
            }
            while_554_break: /* CIL Label */ ;
            }
          }
        }
      }
      {
      __retval = __ret;
      }
      if (__retval) {
        {
        tmp___12 = get_current();
        tmp___13 = freezing(tmp___12);
        }
        if (tmp___13) {
          goto _L;
        } else {
          goto while_553_break;
        }
      } else {
        _L: /* CIL Label */ 
        {
        tmp___10 = list_empty((struct list_head  const  *)(& hub_event_list));
        }
        if (tmp___10) {
          {
          tmp___11 = kthread_should_stop();
          }
          if (! tmp___11) {
            {
            __retval = -512;
            }
          }
        }
      }
      {
      tmp___14 = try_to_freeze();
      }
      if (! tmp___14) {
        goto while_553_break;
      }
    }
    while_553_break: /* CIL Label */ ;
    }
    {
    tmp___15 = kthread_should_stop();
    }
    if (tmp___15) {
      {
      tmp___16 = list_empty((struct list_head  const  *)(& hub_event_list));
      }
      if (tmp___16) {
        goto while_552_break;
      }
    }
  }
  while_552_break: /* CIL Label */ ;
  }
  return (0);
}
}
static struct usb_device_id hub_id_table[2]  = {      {(__u16 )16, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (__u8 )9, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 0UL}, 
        {(__u16 )128, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )9, (unsigned char)0,
      (unsigned char)0, 0UL}};
static struct usb_driver hub_driver  = 
     {"hub", & hub_probe, & hub_disconnect, & hub_ioctl, & hub_suspend, & hub_resume,
    & hub_reset_resume, & hub_pre_reset, & hub_post_reset, (struct usb_device_id  const  *)(hub_id_table),
    {{{0U}}, {(struct list_head *)0, (struct list_head *)0}}, {{(char const   *)0,
                                                                (struct bus_type *)0,
                                                                (struct module *)0,
                                                                (char const   *)0,
                                                                (int (*)(struct device *dev ))0,
                                                                (int (*)(struct device *dev ))0,
                                                                (void (*)(struct device *dev ))0,
                                                                (int (*)(struct device *dev ,
                                                                         pm_message_t state ))0,
                                                                (int (*)(struct device *dev ))0,
                                                                (struct attribute_group **)0,
                                                                (struct dev_pm_ops *)0,
                                                                (struct driver_private *)0},
                                                               0}, 0U, 1U, 0U};
int usb_hub_init(void) 
{ int tmp ;
  struct task_struct *__k ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = usb_register(& hub_driver);
  }
  if (tmp < 0) {
    {
    printk("<3>%s: can\'t register hub driver\n", usbcore_name);
    }
    return (-1);
  }
  {
  tmp___0 = kthread_create(& hub_thread, (void *)0, "khubd");
  __k = tmp___0;
  tmp___1 = IS_ERR((void const   *)__k);
  }
  if (! tmp___1) {
    {
    wake_up_process(__k);
    }
  }
  {
  khubd_task = __k;
  tmp___2 = IS_ERR((void const   *)khubd_task);
  }
  if (! tmp___2) {
    return (0);
  }
  {
  usb_deregister(& hub_driver);
  printk("<3>%s: can\'t start khubd\n", usbcore_name);
  }
  return (-1);
}
}
void usb_hub_cleanup(void) 
{ 

  {
  {
  kthread_stop(khubd_task);
  usb_deregister(& hub_driver);
  }
  return;
}
}
static int descriptors_changed(struct usb_device *udev , struct usb_device_descriptor *old_device_descriptor ) 
{ int changed ;
  unsigned int index ;
  unsigned int serial_len ;
  unsigned int len ;
  unsigned int old_length ;
  int length ;
  char *buf ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int _max1 ;
  unsigned int _max2 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;

  {
  {
  changed = 0;
  serial_len = 0U;
  tmp = __builtin_memcmp((void const   *)(& udev->descriptor), (void const   *)old_device_descriptor,
                         (unsigned int )sizeof(*old_device_descriptor));
  }
  if (tmp != 0) {
    return (1);
  }
  if (udev->serial) {
    {
    tmp___0 = strlen((char const   *)udev->serial);
    serial_len = tmp___0 + 1U;
    }
  }
  {
  len = serial_len;
  index = 0U;
  }
  {
  while (1) {
    while_556_continue: /* CIL Label */ ;
    if (! (index < (unsigned int )udev->descriptor.bNumConfigurations)) {
      goto while_556_break;
    }
    {
    old_length = (unsigned int )(udev->config + index)->desc.wTotalLength;
    _max1 = len;
    _max2 = old_length;
    }
    if (_max1 > _max2) {
      {
      tmp___1 = _max1;
      }
    } else {
      {
      tmp___1 = _max2;
      }
    }
    {
    len = tmp___1;
    index ++;
    }
  }
  while_556_break: /* CIL Label */ ;
  }
  {
  tmp___2 = kmalloc(len, 16U);
  buf = (char *)tmp___2;
  }
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
    tmp___3 = dev_name((struct device  const  *)(& udev->dev));
    tmp___4 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<3>%s %s: no mem to re-read configs after reset\n", tmp___4, tmp___3);
    }
    return (1);
  }
  {
  index = 0U;
  }
  {
  while (1) {
    while_557_continue: /* CIL Label */ ;
    if (! (index < (unsigned int )udev->descriptor.bNumConfigurations)) {
      goto while_557_break;
    }
    {
    old_length = (unsigned int )(udev->config + index)->desc.wTotalLength;
    length = usb_get_descriptor(udev, (unsigned char)2, (unsigned char )index, (void *)buf,
                                (int )old_length);
    }
    if ((unsigned int )length != old_length) {
      {
      changed = 1;
      }
      goto while_557_break;
    }
    {
    tmp___9 = __builtin_memcmp((void const   *)buf, (void const   *)*(udev->rawdescriptors + index),
                               old_length);
    }
    if (tmp___9 != 0) {
      {
      changed = 1;
      }
      goto while_557_break;
    }
    {
    index ++;
    }
  }
  while_557_break: /* CIL Label */ ;
  }
  if (! changed) {
    if (serial_len) {
      {
      length = usb_string(udev, (int )udev->descriptor.iSerialNumber, buf, serial_len);
      }
      if ((unsigned int )(length + 1) != serial_len) {
        {
        changed = 1;
        }
      } else {
        {
        tmp___14 = __builtin_memcmp((void const   *)buf, (void const   *)udev->serial,
                                    (unsigned int )length);
        }
        if (tmp___14 != 0) {
          {
          changed = 1;
          }
        }
      }
    }
  }
  {
  kfree((void const   *)buf);
  }
  return (changed);
}
}
static int usb_reset_and_verify_device(struct usb_device *udev ) 
{ struct usb_device *parent_hdev ;
  struct usb_hub *parent_hub ;
  struct usb_device_descriptor descriptor ;
  int i ;
  int ret ;
  int port1 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  struct usb_interface *intf ;
  struct usb_interface_descriptor *desc ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
  {
  parent_hdev = udev->parent;
  descriptor = udev->descriptor;
  ret = 0;
  port1 = (int )udev->portnum;
  }
  if ((unsigned int )udev->state == 0U) {
    return (-22);
  } else {
    if ((unsigned int )udev->state == 8U) {
      return (-22);
    }
  }
  if (! parent_hdev) {
    return (-21);
  }
  {
  parent_hub = hdev_to_hub(parent_hdev);
  set_bit((unsigned int )port1, (unsigned long volatile   *)(parent_hub->busy_bits));
  i = 0;
  }
  {
  while (1) {
    while_558_continue: /* CIL Label */ ;
    if (! (i < 2 * (use_both_schemes + 1))) {
      goto while_558_break;
    }
    {
    usb_ep0_reinit(udev);
    ret = hub_port_init(parent_hub, udev, port1, i);
    }
    if (ret >= 0) {
      goto while_558_break;
    } else {
      if (ret == -107) {
        goto while_558_break;
      } else {
        if (ret == -19) {
          goto while_558_break;
        }
      }
    }
    {
    i ++;
    }
  }
  while_558_break: /* CIL Label */ ;
  }
  {
  clear_bit(port1, (unsigned long volatile   *)(parent_hub->busy_bits));
  }
  if (ret < 0) {
    goto re_enumerate;
  }
  {
  tmp___5 = descriptors_changed(udev, & descriptor);
  }
  if (tmp___5) {
    {
    tmp___3 = dev_name((struct device  const  *)(& udev->dev));
    tmp___4 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<6>%s %s: device firmware changed\n", tmp___4, tmp___3);
    udev->descriptor = descriptor;
    }
    goto re_enumerate;
  }
  if (! udev->actconfig) {
    goto done;
  }
  {
  tmp___6 = __create_pipe(udev, 0U);
  ret = usb_control_msg(udev, (unsigned int )(2 << 30) | tmp___6, (unsigned char)9,
                        (unsigned char)0, (unsigned short )(udev->actconfig)->desc.bConfigurationValue,
                        (unsigned short)0, (void *)0, (unsigned short)0, 5000);
  }
  if (ret < 0) {
    {
    tmp___7 = dev_name((struct device  const  *)(& udev->dev));
    tmp___8 = dev_driver_string((struct device  const  *)(& udev->dev));
    printk("<3>%s %s: can\'t restore configuration #%d (error=%d)\n", tmp___8, tmp___7,
           (udev->actconfig)->desc.bConfigurationValue, ret);
    }
    goto re_enumerate;
  }
  {
  usb_set_device_state(udev, (enum usb_device_state )7);
  i = 0;
  }
  {
  while (1) {
    while_559_continue: /* CIL Label */ ;
    if (! (i < (int )(udev->actconfig)->desc.bNumInterfaces)) {
      goto while_559_break;
    }
    {
    intf = (udev->actconfig)->interface[i];
    desc = & (intf->cur_altsetting)->desc;
    }
    if ((int )desc->bAlternateSetting == 0) {
      {
      usb_disable_interface(udev, intf, (_Bool)1);
      usb_enable_interface(udev, intf, (_Bool)1);
      ret = 0;
      }
    } else {
      {
      ret = usb_set_interface(udev, (int )desc->bInterfaceNumber, (int )desc->bAlternateSetting);
      }
    }
    if (ret < 0) {
      {
      tmp___9 = dev_name((struct device  const  *)(& udev->dev));
      tmp___10 = dev_driver_string((struct device  const  *)(& udev->dev));
      printk("<3>%s %s: failed to restore interface %d altsetting %d (error=%d)\n",
             tmp___10, tmp___9, desc->bInterfaceNumber, desc->bAlternateSetting, ret);
      }
      goto re_enumerate;
    }
    {
    i ++;
    }
  }
  while_559_break: /* CIL Label */ ;
  }
  done: 
  return (0);
  re_enumerate: 
  {
  hub_port_logical_disconnect(parent_hub, port1);
  }
  return (-19);
}
}
int usb_reset_device(struct usb_device *udev ) 
{ int ret ;
  int i ;
  struct usb_host_config *config ;
  char const   *tmp ;
  char const   *tmp___0 ;
  struct usb_interface *cintf ;
  struct usb_driver *drv ;
  int unbind ;
  struct device_driver  const  *__mptr ;
  struct usb_interface *cintf___0 ;
  struct usb_driver *drv___0 ;
  int rebind ;
  struct device_driver  const  *__mptr___0 ;

  {
  {
  config = udev->actconfig;
  }
  if ((unsigned int )udev->state == 0U) {
    return (-22);
  } else {
    if ((unsigned int )udev->state == 8U) {
      return (-22);
    }
  }
  {
  usb_autoresume_device(udev);
  }
  if (config) {
    {
    i = 0;
    }
    {
    while (1) {
      while_560_continue: /* CIL Label */ ;
      if (! (i < (int )config->desc.bNumInterfaces)) {
        goto while_560_break;
      }
      {
      cintf = config->interface[i];
      unbind = 0;
      }
      if (cintf->dev.driver) {
        {
        __mptr = (struct device_driver  const  *)cintf->dev.driver;
        drv = (struct usb_driver *)((char *)__mptr - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
        }
        if (drv->pre_reset) {
          if (drv->post_reset) {
            {
            unbind = (*(drv->pre_reset))(cintf);
            }
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          if ((unsigned int )cintf->condition == 2U) {
            {
            unbind = 1;
            }
          }
        }
        if (unbind) {
          {
          usb_forced_unbind_intf(cintf);
          }
        }
      }
      {
      i ++;
      }
    }
    while_560_break: /* CIL Label */ ;
    }
  }
  {
  ret = usb_reset_and_verify_device(udev);
  }
  if (config) {
    {
    i = (int )config->desc.bNumInterfaces - 1;
    }
    {
    while (1) {
      while_561_continue: /* CIL Label */ ;
      if (! (i >= 0)) {
        goto while_561_break;
      }
      {
      cintf___0 = config->interface[i];
      rebind = (int )cintf___0->needs_binding;
      }
      if (! rebind) {
        if (cintf___0->dev.driver) {
          {
          __mptr___0 = (struct device_driver  const  *)cintf___0->dev.driver;
          drv___0 = (struct usb_driver *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver));
          }
          if (drv___0->post_reset) {
            {
            rebind = (*(drv___0->post_reset))(cintf___0);
            }
          } else {
            if ((unsigned int )cintf___0->condition == 2U) {
              {
              rebind = 1;
              }
            }
          }
        }
      }
      if (ret == 0) {
        if (rebind) {
          {
          usb_rebind_intf(cintf___0);
          }
        }
      }
      {
      i --;
      }
    }
    while_561_break: /* CIL Label */ ;
    }
  }
  {
  usb_autosuspend_device(udev);
  }
  return (ret);
}
}
static char const   __kstrtab_usb_reset_device[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'_',      (char const   )'d',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_reset_device  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_reset_device), __kstrtab_usb_reset_device};
void usb_queue_reset_device(struct usb_interface *iface ) 
{ 

  {
  {
  schedule_work(& iface->reset_ws);
  }
  return;
}
}
static char const   __kstrtab_usb_queue_reset_device[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'q',      (char const   )'u',      (char const   )'e',      (char const   )'u', 
        (char const   )'e',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_queue_reset_device  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_queue_reset_device), __kstrtab_usb_queue_reset_device};
static unsigned long __force_order___10  ;
__inline static unsigned long native_read_cr0___10(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___10));
  }
  return (val);
}
}
__inline static void native_write_cr0___10(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___10));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___10(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___10));
  }
  return (val);
}
}
__inline static void native_write_cr2___10(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___10));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___10(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___10));
  }
  return (val);
}
}
__inline static void native_write_cr3___10(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___10));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___10(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___10));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___10(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___10): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___10(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___10));
  }
  return;
}
}
__inline static void load_cr3___10(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___10((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___10(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___10();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___10((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___10(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___10();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___10((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___10(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___5 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___10(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___10(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___10(u64 ns ) ;
static union ktime  const  ktime_zero___10  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___10(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___10.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___14  ;
__inline static struct vfsmount *mntget(struct vfsmount *mnt ) 
{ 

  {
  if (mnt) {
    {
    atomic_inc(& mnt->mnt_count);
    }
  }
  return (mnt);
}
}
extern int mnt_want_write(struct vfsmount *mnt ) ;
extern void mnt_drop_write(struct vfsmount *mnt ) ;
extern void mntput_no_expire(struct vfsmount *mnt ) ;
extern void mnt_pin(struct vfsmount *mnt ) ;
extern void mnt_unpin(struct vfsmount *mnt ) ;
extern int __mnt_is_readonly(struct vfsmount *mnt ) ;
__inline static void mntput(struct vfsmount *mnt ) 
{ 

  {
  if (mnt) {
    {
    mnt->mnt_expiry_mark = 0;
    mntput_no_expire(mnt);
    }
  }
  return;
}
}
extern struct vfsmount *do_kern_mount(char const   *fstype , int flags , char const   *name ,
                                      void *data ) ;
extern struct vfsmount *vfs_kern_mount(struct file_system_type *type , int flags ,
                                       char const   *name , void *data ) ;
extern int do_add_mount(struct vfsmount *newmnt , struct path *path , int mnt_flags ,
                        struct list_head *fslist ) ;
extern void mark_mounts_for_expiry(struct list_head *mounts ) ;
extern spinlock_t vfsmount_lock ;
extern dev_t name_to_dev_t(char *name ) ;
__inline static void pagefault_disable(void) 
{ struct thread_info *tmp ;

  {
  {
  while (1) {
    while_562_continue: /* CIL Label */ ;
    {
    tmp = current_thread_info();
    (tmp->preempt_count) ++;
    }
    goto while_562_break;
  }
  while_562_break: /* CIL Label */ ;
  }
  {
  __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
__inline static void pagefault_enable(void) 
{ struct thread_info *tmp ;

  {
  {
  __asm__  volatile   ("": : : "memory");
  }
  {
  while (1) {
    while_563_continue: /* CIL Label */ ;
    {
    tmp = current_thread_info();
    (tmp->preempt_count) --;
    }
    goto while_563_break;
  }
  while_563_break: /* CIL Label */ ;
  }
  {
  __asm__  volatile   ("": : : "memory");
  }
  {
  while (1) {
    while_564_continue: /* CIL Label */ ;
    goto while_564_break;
  }
  while_564_break: /* CIL Label */ ;
  }
  return;
}
}
extern long probe_kernel_read(void *dst , void *src , size_t size ) ;
extern long probe_kernel_write(void *dst , void *src , size_t size ) ;
__inline static void flush_cache_range(struct vm_area_struct *vma , unsigned long start ,
                                       unsigned long end ) 
{ 

  {
  return;
}
}
__inline static void flush_dcache_page(struct page *page ) 
{ 

  {
  return;
}
}
__inline static void flush_dcache_mmap_lock(struct address_space *mapping ) 
{ 

  {
  return;
}
}
__inline static void flush_icache_range(unsigned long start , unsigned long end ) 
{ 

  {
  return;
}
}
__inline static void flush_icache_page(struct vm_area_struct *vma , struct page *page ) 
{ 

  {
  return;
}
}
__inline static void flush_icache_user_range(struct vm_area_struct *vma , struct page *page ,
                                             unsigned long addr , unsigned long len ) 
{ 

  {
  return;
}
}
__inline static void copy_to_user_page(struct vm_area_struct *vma , struct page *page ,
                                       unsigned long vaddr , void *dst , void const   *src ,
                                       unsigned long len ) 
{ 

  {
  {
  __memcpy(dst, src, (unsigned int )len);
  }
  return;
}
}
__inline static int PageNonWB(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(9U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageNonWB(struct page *page ) 
{ 

  {
  {
  set_bit(9U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageNonWB(struct page *page ) 
{ 

  {
  {
  clear_bit(9, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
extern int _set_memory_uc(unsigned long addr , int numpages ) ;
extern int _set_memory_wc(unsigned long addr , int numpages ) ;
extern int _set_memory_wb(unsigned long addr , int numpages ) ;
extern int set_memory_uc(unsigned long addr , int numpages ) ;
extern int set_memory_wc(unsigned long addr , int numpages ) ;
extern int set_memory_wb(unsigned long addr , int numpages ) ;
extern int set_memory_x(unsigned long addr , int numpages ) ;
extern int set_memory_nx(unsigned long addr , int numpages ) ;
extern int set_memory_ro(unsigned long addr , int numpages ) ;
extern int set_memory_rw(unsigned long addr , int numpages ) ;
extern int set_memory_np(unsigned long addr , int numpages ) ;
extern int set_memory_4k(unsigned long addr , int numpages ) ;
extern int set_memory_array_uc(unsigned long *addr , int addrinarray ) ;
extern int set_memory_array_wb(unsigned long *addr , int addrinarray ) ;
extern int set_pages_array_uc(struct page **pages , int addrinarray ) ;
extern int set_pages_array_wb(struct page **pages , int addrinarray ) ;
extern int set_pages_uc(struct page *page , int numpages ) ;
extern int set_pages_wb(struct page *page , int numpages ) ;
extern int set_pages_x(struct page *page , int numpages ) ;
extern int set_pages_nx(struct page *page , int numpages ) ;
extern int set_pages_ro(struct page *page , int numpages ) ;
extern int set_pages_rw(struct page *page , int numpages ) ;
extern void clflush_cache_range(void *addr , unsigned int size ) ;
extern void mark_rodata_ro(void) ;
extern int const   rodata_test_data ;
extern void set_kernel_text_rw(void) ;
extern void set_kernel_text_ro(void) ;
__inline static void flush_anon_page(struct vm_area_struct *vma , struct page *page ,
                                     unsigned long vmaddr ) 
{ 

  {
  return;
}
}
__inline static void debug_kmap_atomic(enum km_type type ) 
{ 

  {
  return;
}
}
__inline static void hrtimer_set_expires_range_ns___10(struct hrtimer *timer , ktime_t time ,
                                                       unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___10((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
__inline static void __native_flush_tlb(void) 
{ unsigned long tmp ;

  {
  {
  tmp = native_read_cr3___10();
  native_write_cr3___10(tmp);
  }
  return;
}
}
__inline static void __native_flush_tlb_global(void) 
{ unsigned long flags ;
  unsigned long cr4 ;

  {
  {
  while (1) {
    while_565_continue: /* CIL Label */ ;
    {
    flags = __raw_local_irq_save();
    }
    goto while_565_break;
  }
  while_565_break: /* CIL Label */ ;
  }
  {
  cr4 = native_read_cr4___10();
  native_write_cr4___10(cr4 & 0xffffff7fUL);
  native_write_cr4___10(cr4);
  raw_local_irq_restore(flags);
  }
  return;
}
}
__inline static void __native_flush_tlb_single(unsigned long addr ) 
{ 

  {
  {
  __asm__  volatile   ("invlpg (%0)": : "r" (addr): "memory");
  }
  return;
}
}
__inline static void __flush_tlb_all(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (13 >> 5 == 0) {
    if ((1UL << 13) & (unsigned long )(1 | (1 << 15))) {
      {
      tmp___1 = 1;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    if (13 >> 5 == 1) {
      goto _L___4;
    } else {
      _L___4: /* CIL Label */ 
      if (13 >> 5 == 2) {
        goto _L___3;
      } else {
        _L___3: /* CIL Label */ 
        if (13 >> 5 == 3) {
          goto _L___2;
        } else {
          _L___2: /* CIL Label */ 
          if (13 >> 5 == 4) {
            goto _L___1;
          } else {
            _L___1: /* CIL Label */ 
            if (13 >> 5 == 5) {
              goto _L___0;
            } else {
              _L___0: /* CIL Label */ 
              if (13 >> 5 == 6) {
                goto _L;
              } else {
                _L: /* CIL Label */ 
                if (13 >> 5 == 7) {
                  {
                  tmp = constant_test_bit(13U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                  tmp___1 = tmp;
                  }
                } else {
                  {
                  tmp = constant_test_bit(13U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                  tmp___1 = tmp;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (tmp___1) {
    {
    __native_flush_tlb_global();
    }
  } else {
    {
    __native_flush_tlb();
    }
  }
  return;
}
}
__inline static void __flush_tlb_one(unsigned long addr ) 
{ 

  {
  {
  __native_flush_tlb_single(addr);
  }
  return;
}
}
extern void flush_tlb_all(void) ;
extern void flush_tlb_current_task(void) ;
extern void flush_tlb_mm(struct mm_struct * ) ;
extern void flush_tlb_page(struct vm_area_struct * , unsigned long  ) ;
__inline static void flush_tlb_range(struct vm_area_struct *vma , unsigned long start ,
                                     unsigned long end ) 
{ 

  {
  {
  flush_tlb_mm(vma->vm_mm);
  }
  return;
}
}
extern void native_flush_tlb_others(struct cpumask  const  *cpumask , struct mm_struct *mm ,
                                    unsigned long va ) ;
extern struct tlb_state per_cpu__cpu_tlbstate  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
__inline static void reset_lazy_tlbstate(void) 
{ T_____0 tmp__ ;
  T_____1 tmp_____0 ;

  {
  {
  while (1) {
    while_566_continue: /* CIL Label */ ;
    if ((int )sizeof(per_cpu__cpu_tlbstate.state) == 1) {
      goto switch_567_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_tlbstate.state) == 2) {
        goto switch_567_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_tlbstate.state) == 4) {
          goto switch_567_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_tlbstate.state) == 8) {
            goto switch_567_8;
          } else {
            {
            goto switch_567_default;
            if (0) {
              switch_567_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.state): "qi" (0));
              }
              goto switch_567_break;
              switch_567_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.state): "ri" (0));
              }
              goto switch_567_break;
              switch_567_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.state): "ri" (0));
              }
              goto switch_567_break;
              switch_567_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.state): "re" (0));
              }
              goto switch_567_break;
              switch_567_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_567_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_566_break;
  }
  while_566_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_568_continue: /* CIL Label */ ;
    if ((int )sizeof(per_cpu__cpu_tlbstate.active_mm) == 1) {
      goto switch_569_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_tlbstate.active_mm) == 2) {
        goto switch_569_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_tlbstate.active_mm) == 4) {
          goto switch_569_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_tlbstate.active_mm) == 8) {
            goto switch_569_8;
          } else {
            {
            goto switch_569_default;
            if (0) {
              switch_569_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.active_mm): "qi" (& init_mm));
              }
              goto switch_569_break;
              switch_569_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.active_mm): "ri" (& init_mm));
              }
              goto switch_569_break;
              switch_569_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.active_mm): "ri" (& init_mm));
              }
              goto switch_569_break;
              switch_569_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__cpu_tlbstate.active_mm): "re" (& init_mm));
              }
              goto switch_569_break;
              switch_569_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_569_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_568_break;
  }
  while_568_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void flush_tlb_kernel_range(unsigned long start , unsigned long end ) 
{ 

  {
  {
  flush_tlb_all();
  }
  return;
}
}
extern void zap_low_mappings(void) ;
extern unsigned long highstart_pfn ;
extern unsigned long highend_pfn ;
extern void *kmap_high(struct page *page ) ;
extern void kunmap_high(struct page *page ) ;
extern void *kmap(struct page *page ) ;
extern void kunmap(struct page *page ) ;
extern void *kmap_atomic_prot(struct page *page , enum km_type type , pgprot_t prot ) ;
extern void *kmap_atomic(struct page *page , enum km_type type ) ;
extern void kunmap_atomic(void *kvaddr , enum km_type type ) ;
extern void *kmap_atomic_pfn(unsigned long pfn , enum km_type type ) ;
extern void *kmap_atomic_prot_pfn(unsigned long pfn , enum km_type type , pgprot_t prot ) ;
extern struct page *kmap_atomic_to_page(void *ptr ) ;
extern void add_highpages_with_active_regions(int nid , unsigned long start_pfn ,
                                              unsigned long end_pfn ) ;
extern unsigned int nr_free_highpages(void) ;
extern unsigned long totalhigh_pages ;
extern void kmap_flush_unused(void) ;
__inline static void clear_user_highpage(struct page *page , unsigned long vaddr ) 
{ void *addr ;
  void *tmp ;

  {
  {
  tmp = kmap_atomic(page, (enum km_type )3);
  addr = tmp;
  clear_user_page(addr, vaddr, page);
  kunmap_atomic(addr, (enum km_type )3);
  }
  return;
}
}
__inline static struct page *alloc_zeroed_user_highpage_movable(struct vm_area_struct *vma ,
                                                                unsigned long vaddr ) 
{ int ret__ ;
  struct page *tmp ;

  {
  if ((int )sizeof(per_cpu__cpu_number) == 1) {
    goto switch_570_1;
  } else {
    if ((int )sizeof(per_cpu__cpu_number) == 2) {
      goto switch_570_2;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 4) {
        goto switch_570_4;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 8) {
          goto switch_570_8;
        } else {
          {
          goto switch_570_default;
          if (0) {
            switch_570_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_570_break;
            switch_570_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_570_break;
            switch_570_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_570_break;
            switch_570_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_570_break;
            switch_570_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_570_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  tmp = alloc_pages_node(0, 1212626U, 0U);
  }
  return (tmp);
}
}
__inline static void clear_highpage(struct page *page ) 
{ void *kaddr ;
  void *tmp ;

  {
  {
  tmp = kmap_atomic(page, (enum km_type )3);
  kaddr = tmp;
  clear_page(kaddr);
  kunmap_atomic(kaddr, (enum km_type )3);
  }
  return;
}
}
__inline static void zero_user_segments(struct page *page , unsigned int start1 ,
                                        unsigned int end1 , unsigned int start2 ,
                                        unsigned int end2 ) 
{ void *kaddr ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = kmap_atomic(page, (enum km_type )3);
  kaddr = tmp;
  }
  {
  while (1) {
    while_571_continue: /* CIL Label */ ;
    if ((unsigned long )end1 > 1UL << 12) {
      {
      tmp___0 = 1;
      }
    } else {
      if ((unsigned long )end2 > 1UL << 12) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    }
    {
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
    if (tmp___1) {
      {
      while (1) {
        while_572_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/highmem.h"),
                             "i" (144), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_573_continue: /* CIL Label */ ;
        }
        while_573_break: /* CIL Label */ ;
        }
        goto while_572_break;
      }
      while_572_break: /* CIL Label */ ;
      }
    }
    goto while_571_break;
  }
  while_571_break: /* CIL Label */ ;
  }
  if (end1 > start1) {
    {
    __constant_c_memset(kaddr + start1, 0UL, end1 - start1);
    }
  }
  if (end2 > start2) {
    {
    __constant_c_memset(kaddr + start2, 0UL, end2 - start2);
    }
  }
  {
  kunmap_atomic(kaddr, (enum km_type )3);
  flush_dcache_page(page);
  }
  return;
}
}
__inline static void zero_user_segment(struct page *page , unsigned int start , unsigned int end ) 
{ 

  {
  {
  zero_user_segments(page, start, end, 0U, 0U);
  }
  return;
}
}
__inline static void zero_user(struct page *page , unsigned int start , unsigned int size ) 
{ 

  {
  {
  zero_user_segments(page, start, start + size, 0U, 0U);
  }
  return;
}
}
__inline static void memclear_highpage_flush(struct page *page , unsigned int offset ,
                                             unsigned int size ) 
{ 

  {
  {
  zero_user(page, offset, size);
  }
  return;
}
}
__inline static void copy_user_highpage(struct page *to , struct page *from , unsigned long vaddr ,
                                        struct vm_area_struct *vma ) 
{ char *vfrom ;
  char *vto ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  tmp = kmap_atomic(from, (enum km_type )3);
  vfrom = (char *)tmp;
  tmp___0 = kmap_atomic(to, (enum km_type )4);
  vto = (char *)tmp___0;
  copy_user_page((void *)vto, (void *)vfrom, vaddr, to);
  kunmap_atomic((void *)vfrom, (enum km_type )3);
  kunmap_atomic((void *)vto, (enum km_type )4);
  }
  return;
}
}
__inline static void copy_highpage(struct page *to , struct page *from ) 
{ char *vfrom ;
  char *vto ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  tmp = kmap_atomic(from, (enum km_type )3);
  vfrom = (char *)tmp;
  tmp___0 = kmap_atomic(to, (enum km_type )4);
  vto = (char *)tmp___0;
  copy_page((void *)vto, (void *)vfrom);
  kunmap_atomic((void *)vfrom, (enum km_type )3);
  kunmap_atomic((void *)vto, (enum km_type )4);
  }
  return;
}
}
__inline static void mapping_set_error(struct address_space *mapping , int error ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! error)), 0L);
  }
  if (tmp) {
    if (error == -28) {
      {
      set_bit(22U, (unsigned long volatile   *)(& mapping->flags));
      }
    } else {
      {
      set_bit(21U, (unsigned long volatile   *)(& mapping->flags));
      }
    }
  }
  return;
}
}
__inline static void mapping_set_unevictable(struct address_space *mapping ) 
{ 

  {
  {
  set_bit(24U, (unsigned long volatile   *)(& mapping->flags));
  }
  return;
}
}
__inline static void mapping_clear_unevictable(struct address_space *mapping ) 
{ 

  {
  {
  clear_bit(24, (unsigned long volatile   *)(& mapping->flags));
  }
  return;
}
}
__inline static int mapping_unevictable(struct address_space *mapping ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp___1 = __builtin_expect((long )(! (! mapping)), 1L);
  }
  if (tmp___1) {
    {
    tmp = constant_test_bit(24U, (unsigned long const volatile   *)(& mapping->flags));
    }
    return (tmp);
  }
  return (! (! mapping));
}
}
__inline static gfp_t mapping_gfp_mask(struct address_space *mapping ) 
{ 

  {
  return ((unsigned int )mapping->flags & (unsigned int )((1 << 21) - 1));
}
}
__inline static void mapping_set_gfp_mask(struct address_space *m , gfp_t mask ) 
{ 

  {
  {
  m->flags = (m->flags & ~ ((unsigned long )((unsigned int )((1 << 21) - 1)))) | (unsigned long )mask;
  }
  return;
}
}
extern void release_pages(struct page **pages , int nr , int cold ) ;
__inline static int page_cache_get_speculative(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  while (1) {
    while_574_continue: /* CIL Label */ ;
    goto while_574_break;
  }
  while_574_break: /* CIL Label */ ;
  }
  {
  tmp = get_page_unless_zero(page);
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return (0);
  }
  {
  while (1) {
    while_575_continue: /* CIL Label */ ;
    goto while_575_break;
  }
  while_575_break: /* CIL Label */ ;
  }
  return (1);
}
}
__inline static int page_cache_add_speculative(struct page *page , int count ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  while (1) {
    while_576_continue: /* CIL Label */ ;
    goto while_576_break;
  }
  while_576_break: /* CIL Label */ ;
  }
  {
  tmp = atomic_add_unless(& page->_count, count, 0);
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return (0);
  }
  {
  while (1) {
    while_577_continue: /* CIL Label */ ;
    goto while_577_break;
  }
  while_577_break: /* CIL Label */ ;
  }
  return (1);
}
}
__inline static int page_freeze_refs(struct page *page , int count ) 
{ unsigned long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = __cmpxchg((void volatile   *)(& page->_count.counter), (unsigned long )count,
                  0UL, (int )sizeof(page->_count.counter));
  }
  if ((int volatile   )tmp == (int volatile   )count) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
  return ((int )tmp___1);
}
}
__inline static void page_unfreeze_refs(struct page *page , int count ) 
{ 

  {
  {
  while (1) {
    while_578_continue: /* CIL Label */ ;
    goto while_578_break;
  }
  while_578_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_579_continue: /* CIL Label */ ;
    goto while_579_break;
  }
  while_579_break: /* CIL Label */ ;
  }
  {
  page->_count.counter = (int volatile   )count;
  }
  return;
}
}
__inline static struct page *__page_cache_alloc(gfp_t gfp ) 
{ int ret__ ;
  struct page *tmp ;

  {
  if ((int )sizeof(per_cpu__cpu_number) == 1) {
    goto switch_580_1;
  } else {
    if ((int )sizeof(per_cpu__cpu_number) == 2) {
      goto switch_580_2;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 4) {
        goto switch_580_4;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 8) {
          goto switch_580_8;
        } else {
          {
          goto switch_580_default;
          if (0) {
            switch_580_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_580_break;
            switch_580_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_580_break;
            switch_580_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_580_break;
            switch_580_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
            }
            goto switch_580_break;
            switch_580_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_580_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  tmp = alloc_pages_node(0, gfp, 0U);
  }
  return (tmp);
}
}
__inline static struct page *page_cache_alloc(struct address_space *x ) 
{ gfp_t tmp ;
  struct page *tmp___0 ;

  {
  {
  tmp = mapping_gfp_mask(x);
  tmp___0 = __page_cache_alloc(tmp);
  }
  return (tmp___0);
}
}
__inline static struct page *page_cache_alloc_cold(struct address_space *x ) 
{ gfp_t tmp ;
  struct page *tmp___0 ;

  {
  {
  tmp = mapping_gfp_mask(x);
  tmp___0 = __page_cache_alloc(tmp | 256U);
  }
  return (tmp___0);
}
}
extern struct page *find_get_page(struct address_space *mapping , unsigned long index ) ;
extern struct page *find_lock_page(struct address_space *mapping , unsigned long index ) ;
extern struct page *find_or_create_page(struct address_space *mapping , unsigned long index ,
                                        gfp_t gfp_mask ) ;
extern unsigned int find_get_pages(struct address_space *mapping , unsigned long start ,
                                   unsigned int nr_pages , struct page **pages ) ;
extern unsigned int find_get_pages_contig(struct address_space *mapping , unsigned long start ,
                                          unsigned int nr_pages , struct page **pages ) ;
extern unsigned int find_get_pages_tag(struct address_space *mapping , unsigned long *index ,
                                       int tag , unsigned int nr_pages , struct page **pages ) ;
extern struct page *grab_cache_page_write_begin(struct address_space *mapping , unsigned long index ,
                                                unsigned int flags ) ;
__inline static struct page *grab_cache_page(struct address_space *mapping , unsigned long index ) 
{ gfp_t tmp ;
  struct page *tmp___0 ;

  {
  {
  tmp = mapping_gfp_mask(mapping);
  tmp___0 = find_or_create_page(mapping, index, tmp);
  }
  return (tmp___0);
}
}
extern struct page *grab_cache_page_nowait(struct address_space *mapping , unsigned long index ) ;
extern struct page *read_cache_page_async(struct address_space *mapping , unsigned long index ,
                                          filler_t *filler , void *data ) ;
extern struct page *read_cache_page(struct address_space *mapping , unsigned long index ,
                                    filler_t *filler , void *data ) ;
extern int read_cache_pages(struct address_space *mapping , struct list_head *pages ,
                            filler_t *filler , void *data ) ;
__inline static struct page *read_mapping_page_async(struct address_space *mapping ,
                                                     unsigned long index , void *data ) 
{ filler_t *filler ;
  struct page *tmp ;

  {
  {
  filler = (filler_t *)(mapping->a_ops)->readpage;
  tmp = read_cache_page_async(mapping, index, filler, data);
  }
  return (tmp);
}
}
__inline static struct page *read_mapping_page(struct address_space *mapping , unsigned long index ,
                                               void *data ) 
{ filler_t *filler ;
  struct page *tmp ;

  {
  {
  filler = (filler_t *)(mapping->a_ops)->readpage;
  tmp = read_cache_page(mapping, index, filler, data);
  }
  return (tmp);
}
}
__inline static loff_t page_offset(struct page *page ) 
{ 

  {
  return ((long long )page->__annonCompField20.index << 12);
}
}
__inline static unsigned long linear_page_index(struct vm_area_struct *vma , unsigned long address ) 
{ unsigned long pgoff ;

  {
  {
  pgoff = (address - vma->vm_start) >> 12;
  pgoff += vma->vm_pgoff;
  }
  return (pgoff);
}
}
extern void __lock_page(struct page *page ) ;
extern int __lock_page_killable(struct page *page ) ;
extern void __lock_page_nosync(struct page *page ) ;
extern void unlock_page(struct page *page ) ;
__inline static void __set_page_locked(struct page *page ) 
{ 

  {
  {
  __set_bit(0, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __clear_page_locked(struct page *page ) 
{ 

  {
  {
  __clear_bit(0, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int trylock_page(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = test_and_set_bit_lock(0, (unsigned long volatile   *)(& page->flags));
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
  return ((int )tmp___1);
}
}
__inline static void lock_page(struct page *page ) 
{ int tmp ;

  {
  {
  while (1) {
    while_581_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_581_break;
  }
  while_581_break: /* CIL Label */ ;
  }
  {
  tmp = trylock_page(page);
  }
  if (! tmp) {
    {
    __lock_page(page);
    }
  }
  return;
}
}
__inline static int lock_page_killable(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_582_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_582_break;
  }
  while_582_break: /* CIL Label */ ;
  }
  {
  tmp___0 = trylock_page(page);
  }
  if (! tmp___0) {
    {
    tmp = __lock_page_killable(page);
    }
    return (tmp);
  }
  return (0);
}
}
__inline static void lock_page_nosync(struct page *page ) 
{ int tmp ;

  {
  {
  while (1) {
    while_583_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_583_break;
  }
  while_583_break: /* CIL Label */ ;
  }
  {
  tmp = trylock_page(page);
  }
  if (! tmp) {
    {
    __lock_page_nosync(page);
    }
  }
  return;
}
}
extern void wait_on_page_bit(struct page *page , int bit_nr ) ;
__inline static void wait_on_page_locked(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = PageLocked(page);
  }
  if (tmp) {
    {
    wait_on_page_bit(page, 0);
    }
  }
  return;
}
}
__inline static void wait_on_page_writeback(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = PageWriteback(page);
  }
  if (tmp) {
    {
    wait_on_page_bit(page, 13);
    }
  }
  return;
}
}
extern void end_page_writeback(struct page *page ) ;
extern void add_page_wait_queue(struct page *page , wait_queue_t *waiter ) ;
__inline static int fault_in_pages_writeable(char *uaddr , int size ) 
{ int ret ;
  long tmp ;
  int __pu_err ;
  char *end ;
  int __pu_err___0 ;

  {
  {
  tmp = __builtin_expect((long )(! (! (size == 0))), 0L);
  }
  if (tmp) {
    return (0);
  }
  {
  while (1) {
    while_584_continue: /* CIL Label */ ;
    {
    __pu_err = 0;
    }
    if ((int )sizeof(*uaddr) == 1) {
      goto switch_585_1;
    } else {
      if ((int )sizeof(*uaddr) == 2) {
        goto switch_585_2;
      } else {
        if ((int )sizeof(*uaddr) == 4) {
          goto switch_585_4;
        } else {
          if ((int )sizeof(*uaddr) == 8) {
            goto switch_585_8;
          } else {
            {
            goto switch_585_default;
            if (0) {
              switch_585_1: /* CIL Label */ 
              {
              __asm__  volatile   ("1:\tmov"
                                   "b"
                                   " %"
                                   "b"
                                   "1,%2\n"
                                   "2:\n"
                                   ".section .fixup,\"ax\"\n"
                                   "3:\tmov %3,%0\n"
                                   "\tjmp 2b\n"
                                   ".previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "1b"
                                   ","
                                   "3b"
                                   "\n"
                                   " .previous\n": "=r" (__pu_err): "iq" ((char)0),
                                   "m" (*((struct __large_struct *)uaddr)), "i" (-14),
                                   "0" (__pu_err));
              }
              goto switch_585_break;
              switch_585_2: /* CIL Label */ 
              {
              __asm__  volatile   ("1:\tmov"
                                   "w"
                                   " %"
                                   "w"
                                   "1,%2\n"
                                   "2:\n"
                                   ".section .fixup,\"ax\"\n"
                                   "3:\tmov %3,%0\n"
                                   "\tjmp 2b\n"
                                   ".previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "1b"
                                   ","
                                   "3b"
                                   "\n"
                                   " .previous\n": "=r" (__pu_err): "ir" ((char)0),
                                   "m" (*((struct __large_struct *)uaddr)), "i" (-14),
                                   "0" (__pu_err));
              }
              goto switch_585_break;
              switch_585_4: /* CIL Label */ 
              {
              __asm__  volatile   ("1:\tmov"
                                   "l"
                                   " %"
                                   "k"
                                   "1,%2\n"
                                   "2:\n"
                                   ".section .fixup,\"ax\"\n"
                                   "3:\tmov %3,%0\n"
                                   "\tjmp 2b\n"
                                   ".previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "1b"
                                   ","
                                   "3b"
                                   "\n"
                                   " .previous\n": "=r" (__pu_err): "ir" ((char)0),
                                   "m" (*((struct __large_struct *)uaddr)), "i" (-14),
                                   "0" (__pu_err));
              }
              goto switch_585_break;
              switch_585_8: /* CIL Label */ 
              {
              __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                   "2:\tmovl %%edx,4(%2)\n"
                                   "3:\n"
                                   ".section .fixup,\"ax\"\n"
                                   "4:\tmovl %3,%0\n"
                                   "\tjmp 3b\n"
                                   ".previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "1b"
                                   ","
                                   "4b"
                                   "\n"
                                   " .previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "2b"
                                   ","
                                   "4b"
                                   "\n"
                                   " .previous\n": "=r" (__pu_err): "A" ((char)0),
                                   "r" (uaddr), "i" (-14), "0" (__pu_err));
              }
              goto switch_585_break;
              switch_585_default: /* CIL Label */ 
              {
              __put_user_bad();
              }
            } else {
              switch_585_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_584_break;
  }
  while_584_break: /* CIL Label */ ;
  }
  {
  ret = __pu_err;
  }
  if (ret == 0) {
    {
    end = (uaddr + size) - 1;
    }
    if (((unsigned long )uaddr & ~ ((1UL << 12) - 1UL)) != ((unsigned long )end & ~ ((1UL << 12) - 1UL))) {
      {
      while (1) {
        while_586_continue: /* CIL Label */ ;
        {
        __pu_err___0 = 0;
        }
        if ((int )sizeof(*end) == 1) {
          goto switch_587_1;
        } else {
          if ((int )sizeof(*end) == 2) {
            goto switch_587_2;
          } else {
            if ((int )sizeof(*end) == 4) {
              goto switch_587_4;
            } else {
              if ((int )sizeof(*end) == 8) {
                goto switch_587_8;
              } else {
                {
                goto switch_587_default;
                if (0) {
                  switch_587_1: /* CIL Label */ 
                  {
                  __asm__  volatile   ("1:\tmov"
                                       "b"
                                       " %"
                                       "b"
                                       "1,%2\n"
                                       "2:\n"
                                       ".section .fixup,\"ax\"\n"
                                       "3:\tmov %3,%0\n"
                                       "\tjmp 2b\n"
                                       ".previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "1b"
                                       ","
                                       "3b"
                                       "\n"
                                       " .previous\n": "=r" (__pu_err___0): "iq" ((char)0),
                                       "m" (*((struct __large_struct *)end)), "i" (-14),
                                       "0" (__pu_err___0));
                  }
                  goto switch_587_break;
                  switch_587_2: /* CIL Label */ 
                  {
                  __asm__  volatile   ("1:\tmov"
                                       "w"
                                       " %"
                                       "w"
                                       "1,%2\n"
                                       "2:\n"
                                       ".section .fixup,\"ax\"\n"
                                       "3:\tmov %3,%0\n"
                                       "\tjmp 2b\n"
                                       ".previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "1b"
                                       ","
                                       "3b"
                                       "\n"
                                       " .previous\n": "=r" (__pu_err___0): "ir" ((char)0),
                                       "m" (*((struct __large_struct *)end)), "i" (-14),
                                       "0" (__pu_err___0));
                  }
                  goto switch_587_break;
                  switch_587_4: /* CIL Label */ 
                  {
                  __asm__  volatile   ("1:\tmov"
                                       "l"
                                       " %"
                                       "k"
                                       "1,%2\n"
                                       "2:\n"
                                       ".section .fixup,\"ax\"\n"
                                       "3:\tmov %3,%0\n"
                                       "\tjmp 2b\n"
                                       ".previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "1b"
                                       ","
                                       "3b"
                                       "\n"
                                       " .previous\n": "=r" (__pu_err___0): "ir" ((char)0),
                                       "m" (*((struct __large_struct *)end)), "i" (-14),
                                       "0" (__pu_err___0));
                  }
                  goto switch_587_break;
                  switch_587_8: /* CIL Label */ 
                  {
                  __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                       "2:\tmovl %%edx,4(%2)\n"
                                       "3:\n"
                                       ".section .fixup,\"ax\"\n"
                                       "4:\tmovl %3,%0\n"
                                       "\tjmp 3b\n"
                                       ".previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "1b"
                                       ","
                                       "4b"
                                       "\n"
                                       " .previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "2b"
                                       ","
                                       "4b"
                                       "\n"
                                       " .previous\n": "=r" (__pu_err___0): "A" ((char)0),
                                       "r" (end), "i" (-14), "0" (__pu_err___0));
                  }
                  goto switch_587_break;
                  switch_587_default: /* CIL Label */ 
                  {
                  __put_user_bad();
                  }
                } else {
                  switch_587_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
        goto while_586_break;
      }
      while_586_break: /* CIL Label */ ;
      }
      {
      ret = __pu_err___0;
      }
    }
  }
  return (ret);
}
}
__inline static int fault_in_pages_readable(char const   *uaddr , int size ) 
{ char volatile   c ;
  int ret ;
  long tmp ;
  int __gu_err ;
  unsigned long __gu_val ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *end ;
  int __gu_err___0 ;
  unsigned long __gu_val___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp = __builtin_expect((long )(! (! (size == 0))), 0L);
  }
  if (tmp) {
    return (0);
  }
  {
  while (1) {
    while_588_continue: /* CIL Label */ ;
    {
    __gu_err = 0;
    }
    if ((int )sizeof(*uaddr) == 1) {
      goto switch_589_1;
    } else {
      if ((int )sizeof(*uaddr) == 2) {
        goto switch_589_2;
      } else {
        if ((int )sizeof(*uaddr) == 4) {
          goto switch_589_4;
        } else {
          if ((int )sizeof(*uaddr) == 8) {
            goto switch_589_8;
          } else {
            {
            goto switch_589_default;
            if (0) {
              switch_589_1: /* CIL Label */ 
              {
              __asm__  volatile   ("1:\tmov"
                                   "b"
                                   " %2,%"
                                   "b"
                                   "1\n"
                                   "2:\n"
                                   ".section .fixup,\"ax\"\n"
                                   "3:\tmov %3,%0\n"
                                   "\txor"
                                   "b"
                                   " %"
                                   "b"
                                   "1,%"
                                   "b"
                                   "1\n"
                                   "\tjmp 2b\n"
                                   ".previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "1b"
                                   ","
                                   "3b"
                                   "\n"
                                   " .previous\n": "=r" (__gu_err), "=q" (__gu_val): "m" (*((struct __large_struct *)uaddr)),
                                   "i" (-14), "0" (__gu_err));
              }
              goto switch_589_break;
              switch_589_2: /* CIL Label */ 
              {
              __asm__  volatile   ("1:\tmov"
                                   "w"
                                   " %2,%"
                                   "w"
                                   "1\n"
                                   "2:\n"
                                   ".section .fixup,\"ax\"\n"
                                   "3:\tmov %3,%0\n"
                                   "\txor"
                                   "w"
                                   " %"
                                   "w"
                                   "1,%"
                                   "w"
                                   "1\n"
                                   "\tjmp 2b\n"
                                   ".previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "1b"
                                   ","
                                   "3b"
                                   "\n"
                                   " .previous\n": "=r" (__gu_err), "=r" (__gu_val): "m" (*((struct __large_struct *)uaddr)),
                                   "i" (-14), "0" (__gu_err));
              }
              goto switch_589_break;
              switch_589_4: /* CIL Label */ 
              {
              __asm__  volatile   ("1:\tmov"
                                   "l"
                                   " %2,%"
                                   "k"
                                   "1\n"
                                   "2:\n"
                                   ".section .fixup,\"ax\"\n"
                                   "3:\tmov %3,%0\n"
                                   "\txor"
                                   "l"
                                   " %"
                                   "k"
                                   "1,%"
                                   "k"
                                   "1\n"
                                   "\tjmp 2b\n"
                                   ".previous\n"
                                   " .section __ex_table,\"a\"\n"
                                   " "
                                   ".balign 4"
                                   " "
                                   "\n"
                                   " "
                                   ".long"
                                   " "
                                   "1b"
                                   ","
                                   "3b"
                                   "\n"
                                   " .previous\n": "=r" (__gu_err), "=r" (__gu_val): "m" (*((struct __large_struct *)uaddr)),
                                   "i" (-14), "0" (__gu_err));
              }
              goto switch_589_break;
              switch_589_8: /* CIL Label */ 
              {
              tmp___0 = __get_user_bad();
              __gu_val = (unsigned long )tmp___0;
              }
              goto switch_589_break;
              switch_589_default: /* CIL Label */ 
              {
              tmp___1 = __get_user_bad();
              __gu_val = (unsigned long )tmp___1;
              }
            } else {
              switch_589_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_588_break;
  }
  while_588_break: /* CIL Label */ ;
  }
  {
  c = (char volatile   )((char const   )__gu_val);
  ret = __gu_err;
  }
  if (ret == 0) {
    {
    end = (uaddr + size) - 1;
    }
    if (((unsigned long )uaddr & ~ ((1UL << 12) - 1UL)) != ((unsigned long )end & ~ ((1UL << 12) - 1UL))) {
      {
      while (1) {
        while_590_continue: /* CIL Label */ ;
        {
        __gu_err___0 = 0;
        }
        if ((int )sizeof(*end) == 1) {
          goto switch_591_1;
        } else {
          if ((int )sizeof(*end) == 2) {
            goto switch_591_2;
          } else {
            if ((int )sizeof(*end) == 4) {
              goto switch_591_4;
            } else {
              if ((int )sizeof(*end) == 8) {
                goto switch_591_8;
              } else {
                {
                goto switch_591_default;
                if (0) {
                  switch_591_1: /* CIL Label */ 
                  {
                  __asm__  volatile   ("1:\tmov"
                                       "b"
                                       " %2,%"
                                       "b"
                                       "1\n"
                                       "2:\n"
                                       ".section .fixup,\"ax\"\n"
                                       "3:\tmov %3,%0\n"
                                       "\txor"
                                       "b"
                                       " %"
                                       "b"
                                       "1,%"
                                       "b"
                                       "1\n"
                                       "\tjmp 2b\n"
                                       ".previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "1b"
                                       ","
                                       "3b"
                                       "\n"
                                       " .previous\n": "=r" (__gu_err___0), "=q" (__gu_val___0): "m" (*((struct __large_struct *)end)),
                                       "i" (-14), "0" (__gu_err___0));
                  }
                  goto switch_591_break;
                  switch_591_2: /* CIL Label */ 
                  {
                  __asm__  volatile   ("1:\tmov"
                                       "w"
                                       " %2,%"
                                       "w"
                                       "1\n"
                                       "2:\n"
                                       ".section .fixup,\"ax\"\n"
                                       "3:\tmov %3,%0\n"
                                       "\txor"
                                       "w"
                                       " %"
                                       "w"
                                       "1,%"
                                       "w"
                                       "1\n"
                                       "\tjmp 2b\n"
                                       ".previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "1b"
                                       ","
                                       "3b"
                                       "\n"
                                       " .previous\n": "=r" (__gu_err___0), "=r" (__gu_val___0): "m" (*((struct __large_struct *)end)),
                                       "i" (-14), "0" (__gu_err___0));
                  }
                  goto switch_591_break;
                  switch_591_4: /* CIL Label */ 
                  {
                  __asm__  volatile   ("1:\tmov"
                                       "l"
                                       " %2,%"
                                       "k"
                                       "1\n"
                                       "2:\n"
                                       ".section .fixup,\"ax\"\n"
                                       "3:\tmov %3,%0\n"
                                       "\txor"
                                       "l"
                                       " %"
                                       "k"
                                       "1,%"
                                       "k"
                                       "1\n"
                                       "\tjmp 2b\n"
                                       ".previous\n"
                                       " .section __ex_table,\"a\"\n"
                                       " "
                                       ".balign 4"
                                       " "
                                       "\n"
                                       " "
                                       ".long"
                                       " "
                                       "1b"
                                       ","
                                       "3b"
                                       "\n"
                                       " .previous\n": "=r" (__gu_err___0), "=r" (__gu_val___0): "m" (*((struct __large_struct *)end)),
                                       "i" (-14), "0" (__gu_err___0));
                  }
                  goto switch_591_break;
                  switch_591_8: /* CIL Label */ 
                  {
                  tmp___2 = __get_user_bad();
                  __gu_val___0 = (unsigned long )tmp___2;
                  }
                  goto switch_591_break;
                  switch_591_default: /* CIL Label */ 
                  {
                  tmp___3 = __get_user_bad();
                  __gu_val___0 = (unsigned long )tmp___3;
                  }
                } else {
                  switch_591_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
        goto while_590_break;
      }
      while_590_break: /* CIL Label */ ;
      }
      {
      c = (char volatile   )((char const   )__gu_val___0);
      ret = __gu_err___0;
      }
    }
  }
  return (ret);
}
}
extern int add_to_page_cache_locked(struct page *page , struct address_space *mapping ,
                                    unsigned long index , gfp_t gfp_mask ) ;
extern int add_to_page_cache_lru(struct page *page , struct address_space *mapping ,
                                 unsigned long index , gfp_t gfp_mask ) ;
extern void remove_from_page_cache(struct page *page ) ;
extern void __remove_from_page_cache(struct page *page ) ;
__inline static int add_to_page_cache(struct page *page , struct address_space *mapping ,
                                      unsigned long offset , gfp_t gfp_mask ) 
{ int error ;
  long tmp ;

  {
  {
  __set_page_locked(page);
  error = add_to_page_cache_locked(page, mapping, offset, gfp_mask);
  tmp = __builtin_expect((long )(! (! error)), 0L);
  }
  if (tmp) {
    {
    __clear_page_locked(page);
    }
  }
  return (error);
}
}
extern spinlock_t proc_subdir_lock ;
extern void proc_root_init(void) ;
extern void proc_flush_task(struct task_struct *task ) ;
extern struct dentry *proc_pid_lookup(struct inode *dir , struct dentry *dentry ,
                                      struct nameidata * ) ;
extern int proc_pid_readdir(struct file *filp , void *dirent , int (*filldir)(void * ,
                                                                              char const   * ,
                                                                              int  ,
                                                                              loff_t  ,
                                                                              u64  ,
                                                                              unsigned int  ) ) ;
extern unsigned long task_vsize(struct mm_struct * ) ;
extern int task_statm(struct mm_struct * , int * , int * , int * , int * ) ;
extern void task_mem(struct seq_file * , struct mm_struct * ) ;
extern void clear_refs_smap(struct mm_struct *mm ) ;
extern struct proc_dir_entry *de_get(struct proc_dir_entry *de ) ;
extern void de_put(struct proc_dir_entry *de ) ;
extern struct proc_dir_entry *create_proc_entry(char const   *name , mode_t mode ,
                                                struct proc_dir_entry *parent ) ;
extern struct proc_dir_entry *proc_create_data(char const   *name , mode_t mode ,
                                               struct proc_dir_entry *parent , struct file_operations  const  *proc_fops ,
                                               void *data ) ;
extern void remove_proc_entry(char const   *name , struct proc_dir_entry *parent ) ;
extern struct vfsmount *proc_mnt ;
extern int proc_fill_super(struct super_block * ) ;
extern struct inode *proc_get_inode(struct super_block * , unsigned int  , struct proc_dir_entry * ) ;
extern int proc_readdir(struct file * , void * , int (*)(void * , char const   * ,
                                                         int  , loff_t  , u64  , unsigned int  ) ) ;
extern struct dentry *proc_lookup(struct inode * , struct dentry * , struct nameidata * ) ;
extern int pid_ns_prepare_proc(struct pid_namespace *ns ) ;
extern void pid_ns_release_proc(struct pid_namespace *ns ) ;
extern void proc_tty_init(void) ;
extern void proc_tty_register_driver(struct tty_driver *driver ) ;
extern void proc_tty_unregister_driver(struct tty_driver *driver ) ;
extern struct proc_dir_entry *proc_symlink(char const   * , struct proc_dir_entry * ,
                                           char const   * ) ;
extern struct proc_dir_entry *proc_mkdir(char const   * , struct proc_dir_entry * ) ;
extern struct proc_dir_entry *proc_mkdir_mode(char const   *name , mode_t mode , struct proc_dir_entry *parent ) ;
__inline static struct proc_dir_entry *proc_create(char const   *name , mode_t mode ,
                                                   struct proc_dir_entry *parent ,
                                                   struct file_operations  const  *proc_fops ) 
{ struct proc_dir_entry *tmp ;

  {
  {
  tmp = proc_create_data(name, mode, parent, proc_fops, (void *)0);
  }
  return (tmp);
}
}
__inline static struct proc_dir_entry *create_proc_read_entry(char const   *name ,
                                                              mode_t mode , struct proc_dir_entry *base ,
                                                              read_proc_t *read_proc ,
                                                              void *data ) 
{ struct proc_dir_entry *res ;
  struct proc_dir_entry *tmp ;

  {
  {
  tmp = create_proc_entry(name, mode, base);
  res = tmp;
  }
  if (res) {
    {
    res->read_proc = read_proc;
    res->data = data;
    }
  }
  return (res);
}
}
extern struct proc_dir_entry *proc_net_fops_create(struct net *net , char const   *name ,
                                                   mode_t mode , struct file_operations  const  *fops ) ;
extern void proc_net_remove(struct net *net , char const   *name ) ;
extern struct proc_dir_entry *proc_net_mkdir(struct net *net , char const   *name ,
                                             struct proc_dir_entry *parent ) ;
extern void set_mm_exe_file(struct mm_struct *mm , struct file *new_exe_file ) ;
extern struct file *get_mm_exe_file(struct mm_struct *mm ) ;
extern void dup_mm_exe_file(struct mm_struct *oldmm , struct mm_struct *newmm ) ;
extern void kclist_add(struct kcore_list * , void * , size_t  ) ;
__inline static struct proc_inode *PROC_I(struct inode  const  *inode ) 
{ struct inode  const  *__mptr ;

  {
  {
  __mptr = inode;
  }
  return ((struct proc_inode *)((char *)__mptr - (unsigned int )(& ((struct proc_inode *)0)->vfs_inode)));
}
}
__inline static struct proc_dir_entry *PDE(struct inode  const  *inode ) 
{ struct proc_inode *tmp ;

  {
  {
  tmp = PROC_I(inode);
  }
  return (tmp->pde);
}
}
__inline static struct net *PDE_NET(struct proc_dir_entry *pde ) 
{ 

  {
  return ((struct net *)(pde->parent)->data);
}
}
extern int user_path_at(int  , char const   * , unsigned int  , struct path * ) ;
extern int kern_path(char const   * , unsigned int  , struct path * ) ;
extern int path_lookup(char const   * , unsigned int  , struct nameidata * ) ;
extern int vfs_path_lookup(struct dentry * , struct vfsmount * , char const   * ,
                           unsigned int  , struct nameidata * ) ;
extern struct file *lookup_instantiate_filp(struct nameidata *nd , struct dentry *dentry ,
                                            int (*open)(struct inode * , struct file * ) ) ;
extern struct file *nameidata_to_filp(struct nameidata *nd , int flags ) ;
extern void release_open_intent(struct nameidata * ) ;
extern struct dentry *lookup_one_len(char const   * , struct dentry * , int  ) ;
extern struct dentry *lookup_one_noperm(char const   * , struct dentry * ) ;
extern int follow_down(struct vfsmount ** , struct dentry ** ) ;
extern int follow_up(struct vfsmount ** , struct dentry ** ) ;
extern struct dentry *lock_rename(struct dentry * , struct dentry * ) ;
extern void unlock_rename(struct dentry * , struct dentry * ) ;
__inline static void nd_set_link(struct nameidata *nd , char *path ) 
{ 

  {
  {
  nd->saved_names[nd->depth] = path;
  }
  return;
}
}
__inline static char *nd_get_link(struct nameidata *nd ) 
{ 

  {
  return (nd->saved_names[nd->depth]);
}
}
__inline static void nd_terminate_link(void *name , size_t len , size_t maxlen ) 
{ size_t _min1 ;
  size_t _min2 ;
  size_t tmp ;

  {
  {
  _min1 = len;
  _min2 = maxlen;
  }
  if (_min1 < _min2) {
    {
    tmp = _min1;
    }
  } else {
    {
    tmp = _min2;
    }
  }
  {
  *((char *)name + tmp) = (char )'\000';
  }
  return;
}
}
extern int match_token(char * , struct match_token *table , substring_t *args ) ;
extern int match_int(substring_t * , int *result ) ;
extern int match_octal(substring_t * , int *result ) ;
extern int match_hex(substring_t * , int *result ) ;
extern size_t match_strlcpy(char * , substring_t const   * , size_t  ) ;
extern char *match_strdup(substring_t const   * ) ;
extern char *mangle_path(char *s , char *p , char *esc ) ;
extern int seq_open(struct file * , struct seq_operations  const  * ) ;
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
extern int seq_release(struct inode * , struct file * ) ;
extern int seq_escape(struct seq_file * , char const   * , char const   * ) ;
extern int seq_putc(struct seq_file *m , char c ) ;
extern int seq_puts(struct seq_file *m , char const   *s ) ;
extern int ( /* format attribute */  seq_printf)(struct seq_file * , char const   * 
                                                 , ...) ;
extern int seq_path(struct seq_file * , struct path * , char * ) ;
extern int seq_dentry(struct seq_file * , struct dentry * , char * ) ;
extern int seq_path_root(struct seq_file *m , struct path *path , struct path *root ,
                         char *esc ) ;
extern int seq_bitmap(struct seq_file *m , unsigned long const   *bits , unsigned int nr_bits ) ;
__inline static int seq_cpumask(struct seq_file *m , struct cpumask  const  *mask ) 
{ int tmp ;

  {
  {
  tmp = seq_bitmap(m, (unsigned long const   *)(mask->bits), (unsigned int )nr_cpu_ids);
  }
  return (tmp);
}
}
__inline static int seq_nodemask(struct seq_file *m , nodemask_t *mask ) 
{ int tmp ;

  {
  {
  tmp = seq_bitmap(m, (unsigned long const   *)(mask->bits), 1U);
  }
  return (tmp);
}
}
extern int seq_bitmap_list(struct seq_file *m , unsigned long const   *bits , unsigned int nr_bits ) ;
__inline static int seq_cpumask_list(struct seq_file *m , struct cpumask  const  *mask ) 
{ int tmp ;

  {
  {
  tmp = seq_bitmap_list(m, (unsigned long const   *)(mask->bits), (unsigned int )nr_cpu_ids);
  }
  return (tmp);
}
}
__inline static int seq_nodemask_list(struct seq_file *m , nodemask_t *mask ) 
{ int tmp ;

  {
  {
  tmp = seq_bitmap_list(m, (unsigned long const   *)(mask->bits), 1U);
  }
  return (tmp);
}
}
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
extern int single_release(struct inode * , struct file * ) ;
extern void *__seq_open_private(struct file * , struct seq_operations  const  * ,
                                int  ) ;
extern int seq_open_private(struct file * , struct seq_operations  const  * , int  ) ;
extern int seq_release_private(struct inode * , struct file * ) ;
extern struct list_head *seq_list_start(struct list_head *head , loff_t pos ) ;
extern struct list_head *seq_list_start_head(struct list_head *head , loff_t pos ) ;
extern struct list_head *seq_list_next(void *v , struct list_head *head , loff_t *ppos ) ;
static struct super_operations usbfs_ops ;
static struct file_operations  const  default_file_operations ;
static struct vfsmount *usbfs_mount  ;
static int usbfs_mount_count  ;
static int ignore_mount  =    0;
static struct dentry *devices_usbfs_dentry  ;
static int num_buses  ;
static uid_t devuid  ;
static uid_t busuid  ;
static uid_t listuid  ;
static gid_t devgid  ;
static gid_t busgid  ;
static gid_t listgid  ;
static umode_t devmode  =    (umode_t )420;
static umode_t busmode  =    (umode_t )365;
static umode_t listmode  =    (umode_t )292;
static int usbfs_show_options(struct seq_file *seq , struct vfsmount *mnt ) 
{ 

  {
  if (devuid != 0U) {
    {
    seq_printf(seq, ",devuid=%u", devuid);
    }
  }
  if (devgid != 0U) {
    {
    seq_printf(seq, ",devgid=%u", devgid);
    }
  }
  if ((int )devmode != 420) {
    {
    seq_printf(seq, ",devmode=%o", devmode);
    }
  }
  if (busuid != 0U) {
    {
    seq_printf(seq, ",busuid=%u", busuid);
    }
  }
  if (busgid != 0U) {
    {
    seq_printf(seq, ",busgid=%u", busgid);
    }
  }
  if ((int )busmode != 365) {
    {
    seq_printf(seq, ",busmode=%o", busmode);
    }
  }
  if (listuid != 0U) {
    {
    seq_printf(seq, ",listuid=%u", listuid);
    }
  }
  if (listgid != 0U) {
    {
    seq_printf(seq, ",listgid=%u", listgid);
    }
  }
  if ((int )listmode != 292) {
    {
    seq_printf(seq, ",listmode=%o", listmode);
    }
  }
  return (0);
}
}
static struct match_token tokens[10]  = 
  {      {0, "devuid=%u"}, 
        {1, "devgid=%u"}, 
        {2, "devmode=%o"}, 
        {3, "busuid=%u"}, 
        {4, "busgid=%u"}, 
        {5, "busmode=%o"}, 
        {6, "listuid=%u"}, 
        {7, "listgid=%u"}, 
        {8, "listmode=%o"}, 
        {9, (char const   *)((void *)0)}};
static int parse_options(struct super_block *s , char *data ) 
{ char *p ;
  int option ;
  substring_t args[3] ;
  int token ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
  devuid = 0U;
  busuid = 0U;
  listuid = 0U;
  devgid = 0U;
  busgid = 0U;
  listgid = 0U;
  devmode = (unsigned short)420;
  busmode = (unsigned short)365;
  listmode = (unsigned short)292;
  }
  {
  while (1) {
    while_592_continue: /* CIL Label */ ;
    {
    p = strsep(& data, ",");
    }
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
      goto while_592_break;
    }
    if (! *p) {
      goto while_592_continue;
    }
    {
    token = match_token(p, (struct match_token *)(tokens), args);
    }
    if (token == 0) {
      goto switch_593_0;
    } else {
      if (token == 1) {
        goto switch_593_1;
      } else {
        if (token == 2) {
          goto switch_593_2;
        } else {
          if (token == 3) {
            goto switch_593_3;
          } else {
            if (token == 4) {
              goto switch_593_4;
            } else {
              if (token == 5) {
                goto switch_593_5;
              } else {
                if (token == 6) {
                  goto switch_593_6;
                } else {
                  if (token == 7) {
                    goto switch_593_7;
                  } else {
                    if (token == 8) {
                      goto switch_593_8;
                    } else {
                      {
                      goto switch_593_default;
                      if (0) {
                        switch_593_0: /* CIL Label */ 
                        {
                        tmp = match_int(& args[0], & option);
                        }
                        if (tmp) {
                          return (-22);
                        }
                        {
                        devuid = (unsigned int )option;
                        }
                        goto switch_593_break;
                        switch_593_1: /* CIL Label */ 
                        {
                        tmp___0 = match_int(& args[0], & option);
                        }
                        if (tmp___0) {
                          return (-22);
                        }
                        {
                        devgid = (unsigned int )option;
                        }
                        goto switch_593_break;
                        switch_593_2: /* CIL Label */ 
                        {
                        tmp___1 = match_octal(& args[0], & option);
                        }
                        if (tmp___1) {
                          return (-22);
                        }
                        {
                        devmode = (unsigned short )(option & 511);
                        }
                        goto switch_593_break;
                        switch_593_3: /* CIL Label */ 
                        {
                        tmp___2 = match_int(& args[0], & option);
                        }
                        if (tmp___2) {
                          return (-22);
                        }
                        {
                        busuid = (unsigned int )option;
                        }
                        goto switch_593_break;
                        switch_593_4: /* CIL Label */ 
                        {
                        tmp___3 = match_int(& args[0], & option);
                        }
                        if (tmp___3) {
                          return (-22);
                        }
                        {
                        busgid = (unsigned int )option;
                        }
                        goto switch_593_break;
                        switch_593_5: /* CIL Label */ 
                        {
                        tmp___4 = match_octal(& args[0], & option);
                        }
                        if (tmp___4) {
                          return (-22);
                        }
                        {
                        busmode = (unsigned short )(option & 511);
                        }
                        goto switch_593_break;
                        switch_593_6: /* CIL Label */ 
                        {
                        tmp___5 = match_int(& args[0], & option);
                        }
                        if (tmp___5) {
                          return (-22);
                        }
                        {
                        listuid = (unsigned int )option;
                        }
                        goto switch_593_break;
                        switch_593_7: /* CIL Label */ 
                        {
                        tmp___6 = match_int(& args[0], & option);
                        }
                        if (tmp___6) {
                          return (-22);
                        }
                        {
                        listgid = (unsigned int )option;
                        }
                        goto switch_593_break;
                        switch_593_8: /* CIL Label */ 
                        {
                        tmp___7 = match_octal(& args[0], & option);
                        }
                        if (tmp___7) {
                          return (-22);
                        }
                        {
                        listmode = (unsigned short )(option & 511);
                        }
                        goto switch_593_break;
                        switch_593_default: /* CIL Label */ 
                        {
                        printk("<3>usbfs: unrecognised mount option \"%s\" or missing value\n",
                               p);
                        }
                        return (-22);
                      } else {
                        switch_593_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_592_break: /* CIL Label */ ;
  }
  return (0);
}
}
static void update_special(struct dentry *special ) 
{ 

  {
  {
  (special->d_inode)->i_uid = listuid;
  (special->d_inode)->i_gid = listgid;
  (special->d_inode)->i_mode = (unsigned short )(32768 | (int )listmode);
  }
  return;
}
}
static void update_dev(struct dentry *dev ) 
{ 

  {
  {
  (dev->d_inode)->i_uid = devuid;
  (dev->d_inode)->i_gid = devgid;
  (dev->d_inode)->i_mode = (unsigned short )(32768 | (int )devmode);
  }
  return;
}
}
static void update_bus(struct dentry *bus ) 
{ struct dentry *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  dev = (struct dentry *)((void *)0);
  (bus->d_inode)->i_uid = busuid;
  (bus->d_inode)->i_gid = busgid;
  (bus->d_inode)->i_mode = (unsigned short )(16384 | (int )busmode);
  mutex_lock(& (bus->d_inode)->i_mutex);
  __mptr = (struct list_head  const  *)bus->d_subdirs.next;
  dev = (struct dentry *)((char *)__mptr - (unsigned int )(& ((struct dentry *)0)->d_u.d_child));
  }
  {
  while (1) {
    while_594_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)dev->d_u.d_child.next);
    }
    if (! ((unsigned long )(& dev->d_u.d_child) != (unsigned long )(& bus->d_subdirs))) {
      goto while_594_break;
    }
    if (dev->d_inode) {
      {
      update_dev(dev);
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)dev->d_u.d_child.next;
    dev = (struct dentry *)((char *)__mptr___0 - (unsigned int )(& ((struct dentry *)0)->d_u.d_child));
    }
  }
  while_594_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& (bus->d_inode)->i_mutex);
  }
  return;
}
}
static void update_sb(struct super_block *sb ) 
{ struct dentry *root ;
  struct dentry *bus ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  root = sb->s_root;
  bus = (struct dentry *)((void *)0);
  }
  if (! root) {
    return;
  }
  {
  mutex_lock(& (root->d_inode)->i_mutex);
  __mptr = (struct list_head  const  *)root->d_subdirs.next;
  bus = (struct dentry *)((char *)__mptr - (unsigned int )(& ((struct dentry *)0)->d_u.d_child));
  }
  {
  while (1) {
    while_595_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)bus->d_u.d_child.next);
    }
    if (! ((unsigned long )(& bus->d_u.d_child) != (unsigned long )(& root->d_subdirs))) {
      goto while_595_break;
    }
    if (bus->d_inode) {
      if ((61440 & (int )(bus->d_inode)->i_mode) == 16384) {
        goto switch_596_16384;
      } else {
        if ((61440 & (int )(bus->d_inode)->i_mode) == 32768) {
          goto switch_596_32768;
        } else {
          {
          goto switch_596_default;
          if (0) {
            switch_596_16384: /* CIL Label */ 
            {
            update_bus(bus);
            }
            goto switch_596_break;
            switch_596_32768: /* CIL Label */ 
            {
            update_special(bus);
            }
            goto switch_596_break;
            switch_596_default: /* CIL Label */ 
            {
            printk("<4>usbfs: Unknown node %s mode %x found on remount!\n", bus->d_name.name,
                   (bus->d_inode)->i_mode);
            }
            goto switch_596_break;
          } else {
            switch_596_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)bus->d_u.d_child.next;
    bus = (struct dentry *)((char *)__mptr___0 - (unsigned int )(& ((struct dentry *)0)->d_u.d_child));
    }
  }
  while_595_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& (root->d_inode)->i_mutex);
  }
  return;
}
}
static int remount(struct super_block *sb , int *flags , char *data ) 
{ int tmp ;

  {
  if (ignore_mount) {
    return (0);
  }
  {
  tmp = parse_options(sb, data);
  }
  if (tmp) {
    {
    printk("<4>usbfs: mount parameter error.\n");
    }
    return (-22);
  }
  if (usbfs_mount) {
    if (usbfs_mount->mnt_sb) {
      {
      update_sb(usbfs_mount->mnt_sb);
      }
    }
  }
  return (0);
}
}
static struct inode *usbfs_get_inode(struct super_block *sb , int mode , dev_t dev ) 
{ struct inode *inode ;
  struct inode *tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct timespec tmp___2 ;
  struct timespec tmp___3 ;

  {
  {
  tmp = new_inode(sb);
  inode = tmp;
  }
  if (inode) {
    {
    inode->i_mode = (unsigned short )mode;
    tmp___0 = get_current();
    inode->i_uid = (unsigned int )(tmp___0->cred)->fsuid;
    tmp___1 = get_current();
    inode->i_gid = (unsigned int )(tmp___1->cred)->fsgid;
    tmp___3 = current_kernel_time();
    inode->i_ctime = tmp___3;
    tmp___2 = tmp___3;
    inode->i_mtime = tmp___2;
    inode->i_atime = tmp___2;
    }
    if ((mode & 61440) == 32768) {
      goto switch_597_32768;
    } else {
      if ((mode & 61440) == 16384) {
        goto switch_597_16384;
      } else {
        {
        goto switch_597_default;
        if (0) {
          switch_597_default: /* CIL Label */ 
          {
          init_special_inode(inode, (unsigned short )mode, dev);
          }
          goto switch_597_break;
          switch_597_32768: /* CIL Label */ 
          {
          inode->i_fop = & default_file_operations;
          }
          goto switch_597_break;
          switch_597_16384: /* CIL Label */ 
          {
          inode->i_op = & simple_dir_inode_operations;
          inode->i_fop = & simple_dir_operations;
          inc_nlink(inode);
          }
          goto switch_597_break;
        } else {
          switch_597_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return (inode);
}
}
static int usbfs_mknod(struct inode *dir , struct dentry *dentry , int mode , dev_t dev ) 
{ struct inode *inode ;
  struct inode *tmp ;
  int error ;

  {
  {
  tmp = usbfs_get_inode(dir->i_sb, mode, dev);
  inode = tmp;
  error = -1;
  }
  if (dentry->d_inode) {
    return (-17);
  }
  if (inode) {
    {
    d_instantiate(dentry, inode);
    dget(dentry);
    error = 0;
    }
  }
  return (error);
}
}
static int usbfs_mkdir(struct inode *dir , struct dentry *dentry , int mode ) 
{ int res ;

  {
  {
  mode = (mode & 1023) | 16384;
  res = usbfs_mknod(dir, dentry, mode, 0U);
  }
  if (! res) {
    {
    inc_nlink(dir);
    }
  }
  return (res);
}
}
static int usbfs_create(struct inode *dir , struct dentry *dentry , int mode ) 
{ int tmp ;

  {
  {
  mode = (mode & 4095) | 32768;
  tmp = usbfs_mknod(dir, dentry, mode, 0U);
  }
  return (tmp);
}
}
__inline static int usbfs_positive(struct dentry *dentry ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (dentry->d_inode) {
    {
    tmp = d_unhashed(dentry);
    }
    if (tmp) {
      {
      tmp___0 = 0;
      }
    } else {
      {
      tmp___0 = 1;
      }
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
static int usbfs_empty(struct dentry *dentry ) 
{ struct list_head *list ;
  struct dentry *de ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  {
  _spin_lock(& dcache_lock);
  list = dentry->d_subdirs.next;
  }
  {
  while (1) {
    while_598_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)list->next);
    }
    if (! ((unsigned long )list != (unsigned long )(& dentry->d_subdirs))) {
      goto while_598_break;
    }
    {
    __mptr = (struct list_head  const  *)list;
    de = (struct dentry *)((char *)__mptr - (unsigned int )(& ((struct dentry *)0)->d_u.d_child));
    tmp = usbfs_positive(de);
    }
    if (tmp) {
      {
      while (1) {
        while_599_continue: /* CIL Label */ ;
        {
        __raw_spin_unlock(& dcache_lock.raw_lock);
        }
        goto while_599_break;
      }
      while_599_break: /* CIL Label */ ;
      }
      return (0);
    }
    {
    list = list->next;
    }
  }
  while_598_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_600_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dcache_lock.raw_lock);
    }
    goto while_600_break;
  }
  while_600_break: /* CIL Label */ ;
  }
  return (1);
}
}
static int usbfs_unlink(struct inode *dir , struct dentry *dentry ) 
{ struct inode *inode ;

  {
  {
  inode = dentry->d_inode;
  mutex_lock(& inode->i_mutex);
  drop_nlink(dentry->d_inode);
  dput(dentry);
  mutex_unlock(& inode->i_mutex);
  d_delete(dentry);
  }
  return (0);
}
}
static int usbfs_rmdir(struct inode *dir , struct dentry *dentry ) 
{ int error ;
  struct inode *inode ;
  int tmp ;

  {
  {
  error = -39;
  inode = dentry->d_inode;
  mutex_lock(& inode->i_mutex);
  dentry_unhash(dentry);
  tmp = usbfs_empty(dentry);
  }
  if (tmp) {
    {
    drop_nlink(dentry->d_inode);
    drop_nlink(dentry->d_inode);
    dput(dentry);
    inode->i_flags |= 16U;
    drop_nlink(dir);
    error = 0;
    }
  }
  {
  mutex_unlock(& inode->i_mutex);
  }
  if (! error) {
    {
    d_delete(dentry);
    }
  }
  {
  dput(dentry);
  }
  return (error);
}
}
static ssize_t default_read_file(struct file *file , char *buf , size_t count , loff_t *ppos ) 
{ 

  {
  return (0);
}
}
static ssize_t default_write_file(struct file *file , char const   *buf , size_t count ,
                                  loff_t *ppos ) 
{ 

  {
  return ((int )count);
}
}
static loff_t default_file_lseek(struct file *file , loff_t offset , int orig ) 
{ loff_t retval ;

  {
  {
  retval = (loff_t )-22;
  mutex_lock(& ((file->f_path.dentry)->d_inode)->i_mutex);
  }
  if (orig == 0) {
    goto switch_601_0;
  } else {
    if (orig == 1) {
      goto switch_601_1;
    } else {
      {
      goto switch_601_default;
      if (0) {
        switch_601_0: /* CIL Label */ 
        if (offset > 0LL) {
          {
          file->f_pos = offset;
          retval = file->f_pos;
          }
        }
        goto switch_601_break;
        switch_601_1: /* CIL Label */ 
        if (offset + file->f_pos > 0LL) {
          {
          file->f_pos += offset;
          retval = file->f_pos;
          }
        }
        goto switch_601_break;
        switch_601_default: /* CIL Label */ 
        {

        }
        goto switch_601_break;
      } else {
        switch_601_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
  mutex_unlock(& ((file->f_path.dentry)->d_inode)->i_mutex);
  }
  return (retval);
}
}
static int default_open(struct inode *inode , struct file *file ) 
{ 

  {
  if (inode->i_private) {
    {
    file->private_data = inode->i_private;
    }
  }
  return (0);
}
}
static struct file_operations  const  default_file_operations  = 
     {(struct module *)0, & default_file_lseek, & default_read_file, & default_write_file,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    (int (*)(struct inode * , struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & default_open, (int (*)(struct file * ,
                                                                                   fl_owner_t id ))0,
    (int (*)(struct inode * , struct file * ))0, (int (*)(struct file * , struct dentry * ,
                                                          int datasync ))0, (int (*)(struct kiocb * ,
                                                                                     int datasync ))0,
    (int (*)(int  , struct file * , int  ))0, (int (*)(struct file * , int  , struct file_lock * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0};
static struct super_operations usbfs_ops  = 
     {(struct inode *(*)(struct super_block *sb ))0, (void (*)(struct inode * ))0, (void (*)(struct inode * ))0,
    (int (*)(struct inode * , int  ))0, & generic_delete_inode, (void (*)(struct inode * ))0,
    (void (*)(struct super_block * ))0, (void (*)(struct super_block * ))0, (int (*)(struct super_block *sb ,
                                                                                     int wait ))0,
    (int (*)(struct super_block * ))0, (int (*)(struct super_block * ))0, & simple_statfs,
    & remount, (void (*)(struct inode * ))0, (void (*)(struct super_block * ))0, & usbfs_show_options,
    (int (*)(struct seq_file * , struct vfsmount * ))0, (ssize_t (*)(struct super_block * ,
                                                                     int  , char * ,
                                                                     size_t  , loff_t  ))0,
    (ssize_t (*)(struct super_block * , int  , char const   * , size_t  , loff_t  ))0,
    (int (*)(struct super_block * , struct page * , gfp_t  ))0};
static int usbfs_fill_super(struct super_block *sb , void *data , int silent ) 
{ struct inode *inode ;
  struct dentry *root ;

  {
  {
  sb->s_blocksize = 1UL << 12;
  sb->s_blocksize_bits = (unsigned char)12;
  sb->s_magic = 40866UL;
  sb->s_op = (struct super_operations  const  *)(& usbfs_ops);
  sb->s_time_gran = 1U;
  inode = usbfs_get_inode(sb, 16877, 0U);
  }
  if (! inode) {
    {
    while (1) {
      while_602_continue: /* CIL Label */ ;
      goto while_602_break;
    }
    while_602_break: /* CIL Label */ ;
    }
    return (-12);
  }
  {
  root = d_alloc_root(inode);
  }
  if (! root) {
    {
    while (1) {
      while_603_continue: /* CIL Label */ ;
      goto while_603_break;
    }
    while_603_break: /* CIL Label */ ;
    }
    {
    iput(inode);
    }
    return (-12);
  }
  {
  sb->s_root = root;
  }
  return (0);
}
}
static int fs_create_by_name(char const   *name , mode_t mode , struct dentry *parent ,
                             struct dentry **dentry ) 
{ int error ;
  size_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  error = 0;
  }
  if (! parent) {
    if (usbfs_mount) {
      if (usbfs_mount->mnt_sb) {
        {
        parent = (usbfs_mount->mnt_sb)->s_root;
        }
      }
    }
  }
  if (! parent) {
    {
    while (1) {
      while_604_continue: /* CIL Label */ ;
      goto while_604_break;
    }
    while_604_break: /* CIL Label */ ;
    }
    return (-14);
  }
  {
  *dentry = (struct dentry *)((void *)0);
  mutex_lock(& (parent->d_inode)->i_mutex);
  tmp = strlen(name);
  *dentry = lookup_one_len(name, parent, (int )tmp);
  tmp___1 = IS_ERR((void const   *)dentry);
  }
  if (tmp___1) {
    {
    tmp___0 = PTR_ERR((void const   *)dentry);
    error = (int )tmp___0;
    }
  } else {
    if (((int )mode & 61440) == 16384) {
      {
      error = usbfs_mkdir(parent->d_inode, *dentry, (int )mode);
      }
    } else {
      {
      error = usbfs_create(parent->d_inode, *dentry, (int )mode);
      }
    }
  }
  {
  mutex_unlock(& (parent->d_inode)->i_mutex);
  }
  return (error);
}
}
static struct dentry *fs_create_file(char const   *name , mode_t mode , struct dentry *parent ,
                                     void *data , struct file_operations  const  *fops ,
                                     uid_t uid , gid_t gid ) 
{ struct dentry *dentry ;
  int error ;

  {
  {
  while (1) {
    while_605_continue: /* CIL Label */ ;
    goto while_605_break;
  }
  while_605_break: /* CIL Label */ ;
  }
  {
  error = fs_create_by_name(name, mode, parent, & dentry);
  }
  if (error) {
    {
    dentry = (struct dentry *)((void *)0);
    }
  } else {
    if (dentry->d_inode) {
      if (data) {
        {
        (dentry->d_inode)->i_private = data;
        }
      }
      if (fops) {
        {
        (dentry->d_inode)->i_fop = fops;
        }
      }
      {
      (dentry->d_inode)->i_uid = uid;
      (dentry->d_inode)->i_gid = gid;
      }
    }
  }
  return (dentry);
}
}
static void fs_remove_file(struct dentry *dentry ) 
{ struct dentry *parent ;
  int tmp ;

  {
  {
  parent = dentry->d_parent;
  }
  if (! parent) {
    return;
  } else {
    if (! parent->d_inode) {
      return;
    }
  }
  {
  mutex_lock(& (parent->d_inode)->i_mutex);
  tmp = usbfs_positive(dentry);
  }
  if (tmp) {
    if (dentry->d_inode) {
      if (((int )(dentry->d_inode)->i_mode & 61440) == 16384) {
        {
        usbfs_rmdir(parent->d_inode, dentry);
        }
      } else {
        {
        usbfs_unlink(parent->d_inode, dentry);
        }
      }
      {
      dput(dentry);
      }
    }
  }
  {
  mutex_unlock(& (parent->d_inode)->i_mutex);
  }
  return;
}
}
static int usb_get_sb(struct file_system_type *fs_type , int flags , char const   *dev_name___0 ,
                      void *data , struct vfsmount *mnt ) 
{ int tmp ;

  {
  {
  tmp = get_sb_single(fs_type, flags, data, & usbfs_fill_super, mnt);
  }
  return (tmp);
}
}
static struct file_system_type usb_fs_type  = 
     {"usbfs", 0, & usb_get_sb, & kill_litter_super, (struct module *)0, (struct file_system_type *)0,
    {(struct list_head *)0, (struct list_head *)0}, {}, {}, {}, {}, {}, {}};
static int create_special_files(void) 
{ struct dentry *parent ;
  int retval ;

  {
  {
  ignore_mount = 1;
  retval = simple_pin_fs(& usb_fs_type, & usbfs_mount, & usbfs_mount_count);
  }
  if (retval) {
    {
    printk("<3>Unable to get usbfs mount\n");
    }
    goto exit;
  }
  {
  ignore_mount = 0;
  parent = (usbfs_mount->mnt_sb)->s_root;
  devices_usbfs_dentry = fs_create_file("devices", (unsigned short )((int )listmode | 32768),
                                        parent, (void *)0, & usbfs_devices_fops, listuid,
                                        listgid);
  }
  if ((unsigned long )devices_usbfs_dentry == (unsigned long )((void *)0)) {
    {
    printk("<3>Unable to create devices usbfs file\n");
    retval = -19;
    }
    goto error_clean_mounts;
  }
  goto exit;
  error_clean_mounts: 
  {
  simple_release_fs(& usbfs_mount, & usbfs_mount_count);
  }
  exit: 
  return (retval);
}
}
static void remove_special_files(void) 
{ 

  {
  if (devices_usbfs_dentry) {
    {
    fs_remove_file(devices_usbfs_dentry);
    }
  }
  {
  devices_usbfs_dentry = (struct dentry *)((void *)0);
  simple_release_fs(& usbfs_mount, & usbfs_mount_count);
  }
  return;
}
}
void usbfs_update_special(void) 
{ struct inode *inode ;
  struct timespec tmp ;
  struct timespec tmp___0 ;

  {
  if (devices_usbfs_dentry) {
    {
    inode = devices_usbfs_dentry->d_inode;
    }
    if (inode) {
      {
      tmp___0 = current_kernel_time();
      inode->i_ctime = tmp___0;
      tmp = tmp___0;
      inode->i_mtime = tmp;
      inode->i_atime = tmp;
      }
    }
  }
  return;
}
}
static void usbfs_add_bus(struct usb_bus *bus ) 
{ struct dentry *parent ;
  char name[8] ;
  int retval ;

  {
  if (num_buses == 0) {
    {
    retval = create_special_files();
    }
    if (retval) {
      return;
    }
  }
  {
  num_buses ++;
  sprintf(name, "%03d", bus->busnum);
  parent = (usbfs_mount->mnt_sb)->s_root;
  bus->usbfs_dentry = fs_create_file((char const   *)(name), (unsigned short )((int )busmode | 16384),
                                     parent, (void *)bus, (struct file_operations  const  *)((void *)0),
                                     busuid, busgid);
  }
  if ((unsigned long )bus->usbfs_dentry == (unsigned long )((void *)0)) {
    {
    printk("<3>Error creating usbfs bus entry\n");
    }
    return;
  }
  return;
}
}
static void usbfs_remove_bus(struct usb_bus *bus ) 
{ 

  {
  if (bus->usbfs_dentry) {
    {
    fs_remove_file(bus->usbfs_dentry);
    bus->usbfs_dentry = (struct dentry *)((void *)0);
    }
  }
  {
  num_buses --;
  }
  if (num_buses <= 0) {
    {
    remove_special_files();
    num_buses = 0;
    }
  }
  return;
}
}
static void usbfs_add_device(struct usb_device *dev ) 
{ char name[8] ;
  int i ;
  int i_size ;
  struct usb_config_descriptor *config ;

  {
  {
  sprintf(name, "%03d", dev->devnum);
  dev->usbfs_dentry = fs_create_file((char const   *)(name), (unsigned short )((int )devmode | 32768),
                                     (dev->bus)->usbfs_dentry, (void *)dev, & usbdev_file_operations,
                                     devuid, devgid);
  }
  if ((unsigned long )dev->usbfs_dentry == (unsigned long )((void *)0)) {
    {
    printk("<3>Error creating usbfs device entry\n");
    }
    return;
  }
  {
  i_size = (int )sizeof(struct usb_device_descriptor );
  i = 0;
  }
  {
  while (1) {
    while_606_continue: /* CIL Label */ ;
    if (! (i < (int )dev->descriptor.bNumConfigurations)) {
      goto while_606_break;
    }
    {
    config = (struct usb_config_descriptor *)*(dev->rawdescriptors + i);
    i_size += (int )config->wTotalLength;
    i ++;
    }
  }
  while_606_break: /* CIL Label */ ;
  }
  if ((dev->usbfs_dentry)->d_inode) {
    {
    ((dev->usbfs_dentry)->d_inode)->i_size = (long long )i_size;
    }
  }
  return;
}
}
static void usbfs_remove_device(struct usb_device *dev ) 
{ 

  {
  if (dev->usbfs_dentry) {
    {
    fs_remove_file(dev->usbfs_dentry);
    dev->usbfs_dentry = (struct dentry *)((void *)0);
    }
  }
  return;
}
}
static int usbfs_notify(struct notifier_block *self , unsigned long action , void *dev ) 
{ 

  {
  if ((int )action == 1) {
    goto switch_607_1;
  } else {
    if ((int )action == 2) {
      goto switch_607_2;
    } else {
      if ((int )action == 3) {
        goto switch_607_3;
      } else {
        if ((int )action == 4) {
          goto switch_607_4;
        } else {
          if (0) {
            switch_607_1: /* CIL Label */ 
            {
            usbfs_add_device((struct usb_device *)dev);
            }
            goto switch_607_break;
            switch_607_2: /* CIL Label */ 
            {
            usbfs_remove_device((struct usb_device *)dev);
            }
            goto switch_607_break;
            switch_607_3: /* CIL Label */ 
            {
            usbfs_add_bus((struct usb_bus *)dev);
            }
            goto switch_607_break;
            switch_607_4: /* CIL Label */ 
            {
            usbfs_remove_bus((struct usb_bus *)dev);
            }
          } else {
            switch_607_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  usbfs_update_special();
  usbfs_conn_disc_event();
  }
  return (1);
}
}
static struct notifier_block usbfs_nb  =    {& usbfs_notify, (struct notifier_block *)0, 0};
static struct proc_dir_entry *usbdir  =    (struct proc_dir_entry *)((void *)0);
int usbfs_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
int usbfs_init(void) 
{ int retval ;

  {
  {
  retval = register_filesystem(& usb_fs_type);
  }
  if (retval) {
    return (retval);
  }
  {
  usb_register_notify(& usbfs_nb);
  usbdir = proc_mkdir("bus/usb", (struct proc_dir_entry *)((void *)0));
  }
  return (0);
}
}
void usbfs_cleanup(void) 
{ 

  {
  {
  usb_unregister_notify(& usbfs_nb);
  unregister_filesystem(& usb_fs_type);
  }
  if (usbdir) {
    {
    remove_proc_entry("bus/usb", (struct proc_dir_entry *)((void *)0));
    }
  }
  return;
}
}
static unsigned long __force_order___11  ;
__inline static unsigned long native_read_cr0___11(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___11));
  }
  return (val);
}
}
__inline static void native_write_cr0___11(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___11));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___11(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___11));
  }
  return (val);
}
}
__inline static void native_write_cr2___11(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___11));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___11(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___11));
  }
  return (val);
}
}
__inline static void native_write_cr3___11(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___11));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___11(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___11));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___11(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___11): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___11(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___11));
  }
  return;
}
}
__inline static void load_cr3___11(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___11((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___11(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___11();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___11((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___11(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___11();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___11((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___11(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_38___1 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___11(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___11(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___11(u64 ns ) ;
static union ktime  const  ktime_zero___11  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___11(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___11.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___15  ;
__inline static void hrtimer_set_expires_range_ns___11(struct hrtimer *timer , ktime_t time ,
                                                       unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___11((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
extern unsigned char _ctype[] ;
__inline static unsigned char __tolower(unsigned char c ) 
{ 

  {
  if (((int )_ctype[(int )c] & 1) != 0) {
    {
    c = (unsigned char )((int )c - -32);
    }
  }
  return (c);
}
}
__inline static unsigned char __toupper(unsigned char c ) 
{ 

  {
  if (((int )_ctype[(int )c] & 2) != 0) {
    {
    c = (unsigned char )((int )c - 32);
    }
  }
  return (c);
}
}
static void cancel_async_set_config(struct usb_device *udev ) ;
static void usb_api_blocking_completion(struct urb *urb ) 
{ struct api_context *ctx ;

  {
  {
  ctx = (struct api_context *)urb->context;
  ctx->status = urb->status;
  complete(& ctx->done);
  }
  return;
}
}
static int usb_start_wait_urb(struct urb *urb , int timeout , int *actual_length ) 
{ struct api_context ctx ;
  unsigned long expire ;
  int retval ;
  long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct task_struct *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
  init_completion(& ctx.done);
  urb->context = (void *)(& ctx);
  urb->actual_length = 0U;
  retval = usb_submit_urb(urb, 16U);
  tmp = __builtin_expect((long )(! (! retval)), 0L);
  }
  if (tmp) {
    goto out;
  }
  if (timeout) {
    {
    tmp___0 = msecs_to_jiffies((unsigned int )timeout);
    expire = tmp___0;
    }
  } else {
    {
    expire = (unsigned long )((long )(0xffffffffUL >> 1));
    }
  }
  {
  tmp___8 = wait_for_completion_timeout(& ctx.done, expire);
  }
  if (tmp___8) {
    {
    retval = ctx.status;
    }
  } else {
    {
    usb_kill_urb(urb);
    }
    if (ctx.status == -2) {
      {
      retval = -110;
      }
    } else {
      {
      retval = ctx.status;
      }
    }
  }
  out: 
  if (actual_length) {
    {
    *actual_length = (int )urb->actual_length;
    }
  }
  {
  usb_free_urb(urb);
  }
  return (retval);
}
}
static int usb_internal_control_msg(struct usb_device *usb_dev , unsigned int pipe ,
                                    struct usb_ctrlrequest *cmd , void *data , int len ,
                                    int timeout ) 
{ struct urb *urb ;
  int retv ;
  int length ;

  {
  {
  urb = usb_alloc_urb(0, 16U);
  }
  if (! urb) {
    return (-12);
  }
  {
  usb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data, len, & usb_api_blocking_completion,
                       (void *)0);
  retv = usb_start_wait_urb(urb, timeout, & length);
  }
  if (retv < 0) {
    return (retv);
  } else {
    return (length);
  }
}
}
int usb_control_msg(struct usb_device *dev , unsigned int pipe , __u8 request , __u8 requesttype ,
                    __u16 value , __u16 index , void *data , __u16 size , int timeout ) 
{ struct usb_ctrlrequest *dr ;
  int ret ;
  void *tmp ;

  {
  {
  tmp = kmalloc((unsigned int )sizeof(struct usb_ctrlrequest ), 16U);
  dr = (struct usb_ctrlrequest *)tmp;
  }
  if (! dr) {
    return (-12);
  }
  {
  dr->bRequestType = requesttype;
  dr->bRequest = request;
  dr->wValue = value;
  dr->wIndex = index;
  dr->wLength = size;
  ret = usb_internal_control_msg(dev, pipe, dr, data, (int )size, timeout);
  kfree((void const   *)dr);
  }
  return (ret);
}
}
static char const   __kstrtab_usb_control_msg[16]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'r',      (char const   )'o',      (char const   )'l',      (char const   )'_', 
        (char const   )'m',      (char const   )'s',      (char const   )'g',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_control_msg  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_control_msg), __kstrtab_usb_control_msg};
int usb_interrupt_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                      int len , int *actual_length , int timeout ) 
{ int tmp ;

  {
  {
  tmp = usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout);
  }
  return (tmp);
}
}
static char const   __kstrtab_usb_interrupt_msg[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'u',      (char const   )'p', 
        (char const   )'t',      (char const   )'_',      (char const   )'m',      (char const   )'s', 
        (char const   )'g',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_interrupt_msg  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_interrupt_msg), __kstrtab_usb_interrupt_msg};
int usb_bulk_msg(struct usb_device *usb_dev , unsigned int pipe , void *data , int len ,
                 int *actual_length , int timeout ) 
{ struct urb *urb ;
  struct usb_host_endpoint *ep ;
  struct usb_host_endpoint **tmp ;
  int tmp___0 ;

  {
  if (pipe & 128U) {
    {
    tmp = usb_dev->ep_in;
    }
  } else {
    {
    tmp = usb_dev->ep_out;
    }
  }
  {
  ep = *(tmp + ((pipe >> 15) & 15U));
  }
  if (! ep) {
    return (-22);
  } else {
    if (len < 0) {
      return (-22);
    }
  }
  {
  urb = usb_alloc_urb(0, 208U);
  }
  if (! urb) {
    return (-12);
  }
  if (((int )ep->desc.bmAttributes & 3) == 3) {
    {
    pipe = (pipe & (unsigned int )(~ (3 << 30))) | (unsigned int )(1 << 30);
    usb_fill_int_urb(urb, usb_dev, pipe, data, len, & usb_api_blocking_completion,
                     (void *)0, (int )ep->desc.bInterval);
    }
  } else {
    {
    usb_fill_bulk_urb(urb, usb_dev, pipe, data, len, & usb_api_blocking_completion,
                      (void *)0);
    }
  }
  {
  tmp___0 = usb_start_wait_urb(urb, timeout, actual_length);
  }
  return (tmp___0);
}
}
static char const   __kstrtab_usb_bulk_msg[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'b',      (char const   )'u',      (char const   )'l',      (char const   )'k', 
        (char const   )'_',      (char const   )'m',      (char const   )'s',      (char const   )'g', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_bulk_msg  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_bulk_msg), __kstrtab_usb_bulk_msg};
static void sg_clean(struct usb_sg_request *io ) 
{ int tmp ;

  {
  if (io->urbs) {
    {
    while (1) {
      while_608_continue: /* CIL Label */ ;
      {
      tmp = io->entries;
      (io->entries) --;
      }
      if (! tmp) {
        goto while_608_break;
      }
      {
      usb_free_urb(*(io->urbs + io->entries));
      }
    }
    while_608_break: /* CIL Label */ ;
    }
    {
    kfree((void const   *)io->urbs);
    io->urbs = (struct urb **)((void *)0);
    }
  }
  if ((unsigned long )(io->dev)->dev.dma_mask != (unsigned long )((void *)0)) {
    {
    usb_buffer_unmap_sg((struct usb_device  const  *)io->dev, io->pipe & 128, io->sg,
                        io->nents);
    }
  }
  {
  io->dev = (struct usb_device *)((void *)0);
  }
  return;
}
}
static void sg_complete(struct urb *urb ) 
{ struct usb_sg_request *io ;
  int status ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int i ;
  int found ;
  int retval ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
  io = (struct usb_sg_request *)urb->context;
  status = urb->status;
  _spin_lock(& io->lock);
  }
  if (io->status) {
    if (io->status != -104) {
      goto _L;
    } else {
      if (status != -104) {
        _L: /* CIL Label */ 
        if (urb->actual_length) {
          {
          tmp___1 = usb_urb_dir_in(urb);
          }
          if (tmp___1) {
            {
            tmp___0 = "in";
            }
          } else {
            {
            tmp___0 = "out";
            }
          }
          {
          tmp___2 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)(& (urb->ep)->desc));
          tmp___3 = dev_name((struct device  const  *)((io->dev)->bus)->controller);
          tmp___4 = dev_driver_string((struct device  const  *)((io->dev)->bus)->controller);
          printk("<3>%s %s: dev %s ep%d%s scatterlist error %d/%d\n", tmp___4, tmp___3,
                 (io->dev)->devpath, tmp___2, tmp___0, status, io->status);
          }
        }
      }
    }
  }
  if (io->status == 0) {
    if (status) {
      if (status != -104) {
        {
        io->status = status;
        }
        {
        while (1) {
          while_609_continue: /* CIL Label */ ;
          {
          __raw_spin_unlock(& io->lock.raw_lock);
          }
          goto while_609_break;
        }
        while_609_break: /* CIL Label */ ;
        }
        {
        i = 0;
        found = 0;
        }
        {
        while (1) {
          while_610_continue: /* CIL Label */ ;
          if (! (i < io->entries)) {
            goto while_610_break;
          }
          if (! *(io->urbs + i)) {
            goto __Cont;
          } else {
            if (! (*(io->urbs + i))->dev) {
              goto __Cont;
            }
          }
          if (found) {
            {
            retval = usb_unlink_urb(*(io->urbs + i));
            }
            if (retval != -115) {
              if (retval != -19) {
                if (retval != -16) {
                  {
                  tmp___5 = dev_name((struct device  const  *)(& (io->dev)->dev));
                  tmp___6 = dev_driver_string((struct device  const  *)(& (io->dev)->dev));
                  printk("<3>%s %s: %s, unlink --> %d\n", tmp___6, tmp___5, "sg_complete",
                         retval);
                  }
                }
              }
            }
          } else {
            if ((unsigned long )urb == (unsigned long )*(io->urbs + i)) {
              {
              found = 1;
              }
            }
          }
          __Cont: /* CIL Label */ 
          {
          i ++;
          }
        }
        while_610_break: /* CIL Label */ ;
        }
        {
        _spin_lock(& io->lock);
        }
      }
    }
  }
  {
  urb->dev = (struct usb_device *)((void *)0);
  io->bytes += urb->actual_length;
  (io->count) --;
  }
  if (! io->count) {
    {
    complete(& io->complete);
    }
  }
  {
  while (1) {
    while_611_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& io->lock.raw_lock);
    }
    goto while_611_break;
  }
  while_611_break: /* CIL Label */ ;
  }
  return;
}
}
int usb_sg_init(struct usb_sg_request *io , struct usb_device *dev , unsigned int pipe ,
                unsigned int period , struct scatterlist *sg , int nents , size_t length ,
                gfp_t mem_flags ) 
{ int i ;
  int urb_flags ;
  int dma ;
  spinlock_t __constr_expr_0 ;
  void *tmp ;
  unsigned int len ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  unsigned int tmp___0 ;

  {
  if (! io) {
    return (-22);
  } else {
    if (! dev) {
      return (-22);
    } else {
      if (! sg) {
        return (-22);
      } else {
        if (((pipe >> 30) & 3U) == 2U) {
          return (-22);
        } else {
          if (((pipe >> 30) & 3U) == 0U) {
            return (-22);
          } else {
            if (nents <= 0) {
              return (-22);
            }
          }
        }
      }
    }
  }
  {
  while (1) {
    while_612_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    io->lock = __constr_expr_0;
    }
    goto while_612_break;
  }
  while_612_break: /* CIL Label */ ;
  }
  {
  io->dev = dev;
  io->pipe = (int )pipe;
  io->sg = sg;
  io->nents = nents;
  dma = (unsigned long )dev->dev.dma_mask != (unsigned long )((void *)0);
  }
  if (dma) {
    {
    io->entries = usb_buffer_map_sg((struct usb_device  const  *)dev, (int )(pipe & 128U),
                                    sg, nents);
    }
  } else {
    {
    io->entries = nents;
    }
  }
  if (io->entries <= 0) {
    return (io->entries);
  }
  {
  tmp = kmalloc((unsigned int )((unsigned long )io->entries * sizeof(*(io->urbs))),
                mem_flags);
  io->urbs = (struct urb **)tmp;
  }
  if (! io->urbs) {
    goto nomem;
  }
  {
  urb_flags = 128;
  }
  if (dma) {
    {
    urb_flags |= 4;
    }
  }
  if (pipe & 128U) {
    {
    urb_flags |= 1;
    }
  }
  {
  i = 0;
  sg = sg;
  }
  {
  while (1) {
    while_613_continue: /* CIL Label */ ;
    if (! (i < io->entries)) {
      goto while_613_break;
    }
    {
    *(io->urbs + i) = usb_alloc_urb(0, mem_flags);
    }
    if (! *(io->urbs + i)) {
      {
      io->entries = i;
      }
      goto nomem;
    }
    {
    (*(io->urbs + i))->dev = (struct usb_device *)((void *)0);
    (*(io->urbs + i))->pipe = pipe;
    (*(io->urbs + i))->interval = (int )period;
    (*(io->urbs + i))->transfer_flags = (unsigned int )urb_flags;
    (*(io->urbs + i))->complete = & sg_complete;
    (*(io->urbs + i))->context = (void *)io;
    }
    if (dma) {
      {
      (*(io->urbs + i))->transfer_dma = sg->dma_address;
      len = sg->length;
      (*(io->urbs + i))->transfer_buffer = (void *)0;
      }
    } else {
      {
      (*(io->urbs + i))->transfer_buffer = sg_virt(sg);
      len = sg->length;
      }
    }
    if (length) {
      {
      __min1 = len;
      __min2 = length;
      }
      if (__min1 < __min2) {
        {
        tmp___0 = __min1;
        }
      } else {
        {
        tmp___0 = __min2;
        }
      }
      {
      len = tmp___0;
      length -= len;
      }
      if (length == 0U) {
        {
        io->entries = i + 1;
        }
      }
    }
    {
    (*(io->urbs + i))->transfer_buffer_length = len;
    i ++;
    sg = sg_next(sg);
    }
  }
  while_613_break: /* CIL Label */ ;
  }
  {
  i --;
  (*(io->urbs + i))->transfer_flags &= 4294967167U;
  io->count = io->entries;
  io->status = 0;
  io->bytes = 0U;
  init_completion(& io->complete);
  }
  return (0);
  nomem: 
  {
  sg_clean(io);
  }
  return (-12);
}
}
static char const   __kstrtab_usb_sg_init[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'g',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'i',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_sg_init  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_sg_init), __kstrtab_usb_sg_init};
void usb_sg_wait(struct usb_sg_request *io ) 
{ int i ;
  int entries ;
  int retval ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  entries = io->entries;
  _spin_lock_irq(& io->lock);
  i = 0;
  }
  {
  while (1) {
    while_614_continue: /* CIL Label */ ;
    if (i < entries) {
      if (! (! io->status)) {
        goto while_614_break;
      }
    } else {
      goto while_614_break;
    }
    {
    (*(io->urbs + i))->dev = io->dev;
    retval = usb_submit_urb(*(io->urbs + i), 32U);
    }
    {
    while (1) {
      while_615_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& io->lock.raw_lock);
      }
      {
      while (1) {
        while_616_continue: /* CIL Label */ ;
        {
        while (1) {
          while_617_continue: /* CIL Label */ ;
          goto while_617_break;
        }
        while_617_break: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_616_break;
      }
      while_616_break: /* CIL Label */ ;
      }
      goto while_615_break;
    }
    while_615_break: /* CIL Label */ ;
    }
    if (retval == -6) {
      goto switch_618_neg_6;
    } else {
      if (retval == -11) {
        goto switch_618_neg_6;
      } else {
        if (retval == -12) {
          goto switch_618_neg_6;
        } else {
          if (retval == 0) {
            goto switch_618_0;
          } else {
            {
            goto switch_618_default;
            if (0) {
              switch_618_neg_6: /* CIL Label */ 
              switch_618_neg_11: /* CIL Label */ 
              switch_618_neg_12: /* CIL Label */ 
              {
              (*(io->urbs + i))->dev = (struct usb_device *)((void *)0);
              retval = 0;
              yield();
              }
              goto switch_618_break;
              switch_618_0: /* CIL Label */ 
              {
              i ++;
              cpu_relax();
              }
              goto switch_618_break;
              switch_618_default: /* CIL Label */ 
              {
              (*(io->urbs + i))->dev = (struct usb_device *)((void *)0);
              (*(io->urbs + i))->status = retval;
              usb_sg_cancel(io);
              }
            } else {
              switch_618_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    _spin_lock_irq(& io->lock);
    }
    if (retval) {
      if (io->status == 0) {
        {
        io->status = retval;
        }
      } else {
        if (io->status == -104) {
          {
          io->status = retval;
          }
        }
      }
    }
  }
  while_614_break: /* CIL Label */ ;
  }
  {
  io->count -= entries - i;
  }
  if (io->count == 0) {
    {
    complete(& io->complete);
    }
  }
  {
  while (1) {
    while_619_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& io->lock.raw_lock);
    }
    {
    while (1) {
      while_620_continue: /* CIL Label */ ;
      {
      while (1) {
        while_621_continue: /* CIL Label */ ;
        goto while_621_break;
      }
      while_621_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_620_break;
    }
    while_620_break: /* CIL Label */ ;
    }
    goto while_619_break;
  }
  while_619_break: /* CIL Label */ ;
  }
  {
  wait_for_completion(& io->complete);
  sg_clean(io);
  }
  return;
}
}
static char const   __kstrtab_usb_sg_wait[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'g',      (char const   )'_',      (char const   )'w', 
        (char const   )'a',      (char const   )'i',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_sg_wait  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_sg_wait), __kstrtab_usb_sg_wait};
void usb_sg_cancel(struct usb_sg_request *io ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int i ;
  int retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_622_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& io->lock);
    }
    goto while_622_break;
  }
  while_622_break: /* CIL Label */ ;
  }
  if (! io->status) {
    {
    io->status = -104;
    }
    {
    while (1) {
      while_623_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& io->lock.raw_lock);
      }
      goto while_623_break;
    }
    while_623_break: /* CIL Label */ ;
    }
    {
    i = 0;
    }
    {
    while (1) {
      while_624_continue: /* CIL Label */ ;
      if (! (i < io->entries)) {
        goto while_624_break;
      }
      if (! (*(io->urbs + i))->dev) {
        goto __Cont;
      }
      {
      retval = usb_unlink_urb(*(io->urbs + i));
      }
      if (retval != -115) {
        if (retval != -16) {
          {
          tmp = dev_name((struct device  const  *)(& (io->dev)->dev));
          tmp___0 = dev_driver_string((struct device  const  *)(& (io->dev)->dev));
          printk("<4>%s %s: %s, unlink --> %d\n", tmp___0, tmp, "usb_sg_cancel", retval);
          }
        }
      }
      __Cont: /* CIL Label */ 
      {
      i ++;
      }
    }
    while_624_break: /* CIL Label */ ;
    }
    {
    _spin_lock(& io->lock);
    }
  }
  {
  while (1) {
    while_625_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& io->lock, flags);
    }
    goto while_625_break;
  }
  while_625_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_sg_cancel[14]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'g',      (char const   )'_',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'c',      (char const   )'e', 
        (char const   )'l',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_sg_cancel  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_sg_cancel), __kstrtab_usb_sg_cancel};
int usb_get_descriptor(struct usb_device *dev , unsigned char type , unsigned char index ,
                       void *buf , int size ) 
{ int i ;
  int result ;
  unsigned int tmp ;

  {
  {
  __constant_c_memset(buf, 0UL, (unsigned int )size);
  i = 0;
  }
  {
  while (1) {
    while_626_continue: /* CIL Label */ ;
    if (! (i < 3)) {
      goto while_626_break;
    }
    {
    tmp = __create_pipe(dev, 0U);
    result = usb_control_msg(dev, ((unsigned int )(2 << 30) | tmp) | 128U, (unsigned char)6,
                             (unsigned char)128, (unsigned short )(((int )type << 8) + (int )index),
                             (unsigned short)0, buf, (unsigned short )size, 5000);
    }
    if (result <= 0) {
      if (result != -110) {
        goto __Cont;
      }
    }
    if (result > 1) {
      if ((int )*((u8 *)buf + 1) != (int )type) {
        {
        result = -61;
        }
        goto __Cont;
      }
    }
    goto while_626_break;
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_626_break: /* CIL Label */ ;
  }
  return (result);
}
}
static char const   __kstrtab_usb_get_descriptor[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_descriptor  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_descriptor), __kstrtab_usb_get_descriptor};
static int usb_get_string(struct usb_device *dev , unsigned short langid , unsigned char index ,
                          void *buf , int size ) 
{ int i ;
  int result ;
  unsigned int tmp ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_627_continue: /* CIL Label */ ;
    if (! (i < 3)) {
      goto while_627_break;
    }
    {
    tmp = __create_pipe(dev, 0U);
    result = usb_control_msg(dev, ((unsigned int )(2 << 30) | tmp) | 128U, (unsigned char)6,
                             (unsigned char)128, (unsigned short )((3 << 8) + (int )index),
                             langid, buf, (unsigned short )size, 5000);
    }
    if (result == 0) {
      goto __Cont;
    } else {
      if (result == -32) {
        goto __Cont;
      }
    }
    if (result > 1) {
      if ((int )*((u8 *)buf + 1) != 3) {
        {
        result = -61;
        }
        goto __Cont;
      }
    }
    goto while_627_break;
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_627_break: /* CIL Label */ ;
  }
  return (result);
}
}
static void usb_try_string_workarounds(unsigned char *buf , int *length ) 
{ int newlength ;
  int oldlength ;

  {
  {
  oldlength = *length;
  newlength = 2;
  }
  {
  while (1) {
    while_628_continue: /* CIL Label */ ;
    if (! (newlength + 1 < oldlength)) {
      goto while_628_break;
    }
    if (! (((int )_ctype[(int )*(buf + newlength)] & 151) != 0)) {
      goto while_628_break;
    } else {
      if (*(buf + (newlength + 1))) {
        goto while_628_break;
      }
    }
    {
    newlength += 2;
    }
  }
  while_628_break: /* CIL Label */ ;
  }
  if (newlength > 2) {
    {
    *(buf + 0) = (unsigned char )newlength;
    *length = newlength;
    }
  }
  return;
}
}
static int usb_string_sub(struct usb_device *dev , unsigned int langid , unsigned int index ,
                          unsigned char *buf ) 
{ int rc ;

  {
  if (dev->quirks & 1U) {
    {
    rc = -5;
    }
  } else {
    {
    rc = usb_get_string(dev, (unsigned short )langid, (unsigned char )index, (void *)buf,
                        255);
    }
  }
  if (rc < 2) {
    {
    rc = usb_get_string(dev, (unsigned short )langid, (unsigned char )index, (void *)buf,
                        2);
    }
    if (rc == 2) {
      {
      rc = usb_get_string(dev, (unsigned short )langid, (unsigned char )index, (void *)buf,
                          (int )*(buf + 0));
      }
    }
  }
  if (rc >= 2) {
    if (! *(buf + 0)) {
      if (! *(buf + 1)) {
        {
        usb_try_string_workarounds(buf, & rc);
        }
      }
    }
    if ((int )*(buf + 0) < rc) {
      {
      rc = (int )*(buf + 0);
      }
    }
    {
    rc -= rc & 1;
    }
  }
  if (rc < 2) {
    if (rc < 0) {
      {
      rc = rc;
      }
    } else {
      {
      rc = -22;
      }
    }
  }
  return (rc);
}
}
static int usb_get_langid(struct usb_device *dev , unsigned char *tbuf ) 
{ int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  if (dev->have_langid) {
    return (0);
  }
  if (dev->string_langid < 0) {
    return (-32);
  }
  {
  err = usb_string_sub(dev, 0U, 0U, tbuf);
  }
  if (err == -61) {
    goto _L;
  } else {
    if (err > 0) {
      if (err < 4) {
        _L: /* CIL Label */ 
        {
        dev->string_langid = 1033;
        dev->have_langid = 1U;
        tmp = dev_name((struct device  const  *)(& dev->dev));
        tmp___0 = dev_driver_string((struct device  const  *)(& dev->dev));
        printk("<3>%s %s: string descriptor 0 malformed (err = %d), defaulting to 0x%04x\n",
               tmp___0, tmp, err, dev->string_langid);
        }
        return (0);
      }
    }
  }
  if (err < 0) {
    {
    tmp___1 = dev_name((struct device  const  *)(& dev->dev));
    tmp___2 = dev_driver_string((struct device  const  *)(& dev->dev));
    printk("<3>%s %s: string descriptor 0 read error: %d\n", tmp___2, tmp___1, err);
    dev->string_langid = -1;
    }
    return (-32);
  }
  {
  dev->string_langid = (int )*(tbuf + 2) | ((int )*(tbuf + 3) << 8);
  dev->have_langid = 1U;
  }
  return (0);
}
}
int usb_string(struct usb_device *dev , int index , char *buf , size_t size ) 
{ unsigned char *tbuf ;
  int err ;
  unsigned int u ;
  unsigned int idx ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  if ((unsigned int )dev->state == 8U) {
    return (-113);
  }
  if (size <= 0U) {
    return (-22);
  } else {
    if (! buf) {
      return (-22);
    } else {
      if (! index) {
        return (-22);
      }
    }
  }
  {
  *(buf + 0) = (char)0;
  tmp = kmalloc(256U, 16U);
  tbuf = (unsigned char *)tmp;
  }
  if (! tbuf) {
    return (-12);
  }
  {
  err = usb_get_langid(dev, tbuf);
  }
  if (err < 0) {
    goto errout;
  }
  {
  err = usb_string_sub(dev, (unsigned int )dev->string_langid, (unsigned int )index,
                       tbuf);
  }
  if (err < 0) {
    goto errout;
  }
  {
  size --;
  idx = 0U;
  u = 2U;
  }
  {
  while (1) {
    while_629_continue: /* CIL Label */ ;
    if (! (u < (unsigned int )err)) {
      goto while_629_break;
    }
    if (idx >= size) {
      goto while_629_break;
    }
    if (*(tbuf + (u + 1U))) {
      {
      tmp___0 = idx;
      idx ++;
      *(buf + tmp___0) = (char )'?';
      }
    } else {
      {
      tmp___1 = idx;
      idx ++;
      *(buf + tmp___1) = (char )*(tbuf + u);
      }
    }
    {
    u += 2U;
    }
  }
  while_629_break: /* CIL Label */ ;
  }
  {
  *(buf + idx) = (char)0;
  err = (int )idx;
  }
  if ((int )*(tbuf + 1) != 3) {

  }
  errout: 
  {
  kfree((void const   *)tbuf);
  }
  return (err);
}
}
static char const   __kstrtab_usb_string[11]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_string  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_string), __kstrtab_usb_string};
char *usb_cache_string(struct usb_device *udev , int index ) 
{ char *buf ;
  char *smallbuf ;
  int len ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  smallbuf = (char *)((void *)0);
  }
  if (index <= 0) {
    return ((char *)((void *)0));
  }
  {
  tmp = kmalloc(256U, 208U);
  buf = (char *)tmp;
  }
  if (buf) {
    {
    len = usb_string(udev, index, buf, 256U);
    }
    if (len > 0) {
      {
      len ++;
      tmp___0 = kmalloc((unsigned int )len, 208U);
      smallbuf = (char *)tmp___0;
      }
      if (! smallbuf) {
        return (buf);
      }
      {
      __memcpy((void *)smallbuf, (void const   *)buf, (unsigned int )len);
      }
    }
    {
    kfree((void const   *)buf);
    }
  }
  return (smallbuf);
}
}
int usb_get_device_descriptor(struct usb_device *dev , unsigned int size ) 
{ struct usb_device_descriptor *desc ;
  int ret ;
  void *tmp ;

  {
  if ((unsigned long )size > sizeof(*desc)) {
    return (-22);
  }
  {
  tmp = kmalloc((unsigned int )sizeof(*desc), 16U);
  desc = (struct usb_device_descriptor *)tmp;
  }
  if (! desc) {
    return (-12);
  }
  {
  ret = usb_get_descriptor(dev, (unsigned char)1, (unsigned char)0, (void *)desc,
                           (int )size);
  }
  if (ret >= 0) {
    {
    __memcpy((void *)(& dev->descriptor), (void const   *)desc, size);
    }
  }
  {
  kfree((void const   *)desc);
  }
  return (ret);
}
}
int usb_get_status(struct usb_device *dev , int type , int target , void *data ) 
{ int ret ;
  u16 *status ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  {
  tmp = kmalloc((unsigned int )sizeof(*status), 208U);
  status = (u16 *)tmp;
  }
  if (! status) {
    return (-12);
  }
  {
  tmp___0 = __create_pipe(dev, 0U);
  ret = usb_control_msg(dev, ((unsigned int )(2 << 30) | tmp___0) | 128U, (unsigned char)0,
                        (unsigned char )(128 | type), (unsigned short)0, (unsigned short )target,
                        (void *)status, (unsigned short )sizeof(*status), 5000);
  *((u16 *)data) = *status;
  kfree((void const   *)status);
  }
  return (ret);
}
}
static char const   __kstrtab_usb_get_status[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'t', 
        (char const   )'u',      (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_status  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_status), __kstrtab_usb_get_status};
int usb_clear_halt(struct usb_device *dev , int pipe ) 
{ int result ;
  int endp ;
  unsigned int tmp ;

  {
  {
  endp = (pipe >> 15) & 15;
  }
  if (pipe & 128) {
    {
    endp |= 128;
    }
  }
  {
  tmp = __create_pipe(dev, 0U);
  result = usb_control_msg(dev, (unsigned int )(2 << 30) | tmp, (unsigned char)1,
                           (unsigned char)2, (unsigned short)0, (unsigned short )endp,
                           (void *)0, (unsigned short)0, 5000);
  }
  if (result < 0) {
    return (result);
  }
  {
  usb_reset_endpoint(dev, (unsigned int )endp);
  }
  return (0);
}
}
static char const   __kstrtab_usb_clear_halt[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'a', 
        (char const   )'r',      (char const   )'_',      (char const   )'h',      (char const   )'a', 
        (char const   )'l',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_clear_halt  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_clear_halt), __kstrtab_usb_clear_halt};
static int create_intf_ep_devs(struct usb_interface *intf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  struct usb_host_interface *alt ;
  int i ;

  {
  {
  __mptr = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  alt = intf->cur_altsetting;
  }
  if (intf->ep_devs_created) {
    return (0);
  } else {
    if (intf->unregistering) {
      return (0);
    }
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_630_continue: /* CIL Label */ ;
    if (! (i < (int )alt->desc.bNumEndpoints)) {
      goto while_630_break;
    }
    {
    usb_create_ep_devs(& intf->dev, alt->endpoint + i, udev);
    i ++;
    }
  }
  while_630_break: /* CIL Label */ ;
  }
  {
  intf->ep_devs_created = 1U;
  }
  return (0);
}
}
static void remove_intf_ep_devs(struct usb_interface *intf ) 
{ struct usb_host_interface *alt ;
  int i ;

  {
  {
  alt = intf->cur_altsetting;
  }
  if (! intf->ep_devs_created) {
    return;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_631_continue: /* CIL Label */ ;
    if (! (i < (int )alt->desc.bNumEndpoints)) {
      goto while_631_break;
    }
    {
    usb_remove_ep_devs(alt->endpoint + i);
    i ++;
    }
  }
  while_631_break: /* CIL Label */ ;
  }
  {
  intf->ep_devs_created = 0U;
  }
  return;
}
}
void usb_disable_endpoint(struct usb_device *dev , unsigned int epaddr , bool reset_hardware ) 
{ unsigned int epnum ;
  struct usb_host_endpoint *ep ;

  {
  {
  epnum = epaddr & 15U;
  }
  if (! dev) {
    return;
  }
  if (! (epaddr & 128U)) {
    {
    ep = dev->ep_out[epnum];
    }
    if (reset_hardware) {
      {
      dev->ep_out[epnum] = (struct usb_host_endpoint *)((void *)0);
      }
    }
  } else {
    {
    ep = dev->ep_in[epnum];
    }
    if (reset_hardware) {
      {
      dev->ep_in[epnum] = (struct usb_host_endpoint *)((void *)0);
      }
    }
  }
  if (ep) {
    {
    ep->enabled = 0;
    usb_hcd_flush_endpoint(dev, ep);
    }
    if (reset_hardware) {
      {
      usb_hcd_disable_endpoint(dev, ep);
      }
    }
  }
  return;
}
}
void usb_reset_endpoint(struct usb_device *dev , unsigned int epaddr ) 
{ unsigned int epnum ;
  struct usb_host_endpoint *ep ;

  {
  {
  epnum = epaddr & 15U;
  }
  if (! (epaddr & 128U)) {
    {
    ep = dev->ep_out[epnum];
    }
  } else {
    {
    ep = dev->ep_in[epnum];
    }
  }
  if (ep) {
    {
    usb_hcd_reset_endpoint(dev, ep);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_reset_endpoint[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'_',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'p',      (char const   )'o',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_reset_endpoint  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_reset_endpoint), __kstrtab_usb_reset_endpoint};
void usb_disable_interface(struct usb_device *dev , struct usb_interface *intf , bool reset_hardware ) 
{ struct usb_host_interface *alt ;
  int i ;

  {
  {
  alt = intf->cur_altsetting;
  i = 0;
  }
  {
  while (1) {
    while_632_continue: /* CIL Label */ ;
    if (! (i < (int )alt->desc.bNumEndpoints)) {
      goto while_632_break;
    }
    {
    usb_disable_endpoint(dev, (unsigned int )(alt->endpoint + i)->desc.bEndpointAddress,
                         reset_hardware);
    i ++;
    }
  }
  while_632_break: /* CIL Label */ ;
  }
  return;
}
}
void usb_disable_device(struct usb_device *dev , int skip_ep0 ) 
{ int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_interface *interface ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
  i = skip_ep0;
  }
  {
  while (1) {
    while_633_continue: /* CIL Label */ ;
    if (! (i < 16)) {
      goto while_633_break;
    }
    {
    usb_disable_endpoint(dev, (unsigned int )i, (_Bool)1);
    usb_disable_endpoint(dev, (unsigned int )(i + 128), (_Bool)1);
    i ++;
    }
  }
  while_633_break: /* CIL Label */ ;
  }
  if (dev->actconfig) {
    {
    i = 0;
    }
    {
    while (1) {
      while_634_continue: /* CIL Label */ ;
      if (! (i < (int )(dev->actconfig)->desc.bNumInterfaces)) {
        goto while_634_break;
      }
      {
      interface = (dev->actconfig)->interface[i];
      tmp___2 = device_is_registered(& interface->dev);
      }
      if (! tmp___2) {
        goto __Cont;
      }
      {
      interface->unregistering = 1U;
      remove_intf_ep_devs(interface);
      device_del(& interface->dev);
      }
      __Cont: /* CIL Label */ 
      {
      i ++;
      }
    }
    while_634_break: /* CIL Label */ ;
    }
    {
    i = 0;
    }
    {
    while (1) {
      while_635_continue: /* CIL Label */ ;
      if (! (i < (int )(dev->actconfig)->desc.bNumInterfaces)) {
        goto while_635_break;
      }
      {
      put_device(& ((dev->actconfig)->interface[i])->dev);
      (dev->actconfig)->interface[i] = (struct usb_interface *)((void *)0);
      i ++;
      }
    }
    while_635_break: /* CIL Label */ ;
    }
    {
    dev->actconfig = (struct usb_host_config *)((void *)0);
    }
    if ((unsigned int )dev->state == 7U) {
      {
      usb_set_device_state(dev, (enum usb_device_state )6);
      }
    }
  }
  return;
}
}
void usb_enable_endpoint(struct usb_device *dev , struct usb_host_endpoint *ep , bool reset_ep ) 
{ int epnum ;
  int tmp ;
  int is_out ;
  int tmp___0 ;
  int is_control ;
  int tmp___1 ;

  {
  {
  tmp = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)(& ep->desc));
  epnum = tmp;
  tmp___0 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)(& ep->desc));
  is_out = tmp___0;
  tmp___1 = usb_endpoint_xfer_control((struct usb_endpoint_descriptor  const  *)(& ep->desc));
  is_control = tmp___1;
  }
  if (reset_ep) {
    {
    usb_hcd_reset_endpoint(dev, ep);
    }
  }
  if (is_out) {
    {
    dev->ep_out[epnum] = ep;
    }
  } else {
    if (is_control) {
      {
      dev->ep_out[epnum] = ep;
      }
    }
  }
  if (! is_out) {
    {
    dev->ep_in[epnum] = ep;
    }
  } else {
    if (is_control) {
      {
      dev->ep_in[epnum] = ep;
      }
    }
  }
  {
  ep->enabled = 1;
  }
  return;
}
}
void usb_enable_interface(struct usb_device *dev , struct usb_interface *intf , bool reset_eps ) 
{ struct usb_host_interface *alt ;
  int i ;

  {
  {
  alt = intf->cur_altsetting;
  i = 0;
  }
  {
  while (1) {
    while_636_continue: /* CIL Label */ ;
    if (! (i < (int )alt->desc.bNumEndpoints)) {
      goto while_636_break;
    }
    {
    usb_enable_endpoint(dev, alt->endpoint + i, reset_eps);
    i ++;
    }
  }
  while_636_break: /* CIL Label */ ;
  }
  return;
}
}
int usb_set_interface(struct usb_device *dev , int interface , int alternate ) 
{ struct usb_interface *iface ;
  struct usb_host_interface *alt ;
  int ret ;
  int manual ;
  unsigned int epaddr ;
  unsigned int pipe ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int i ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
  manual = 0;
  }
  if ((unsigned int )dev->state == 8U) {
    return (-113);
  }
  {
  iface = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )interface);
  }
  if (! iface) {
    return (-22);
  }
  {
  alt = usb_altnum_to_altsetting((struct usb_interface  const  *)iface, (unsigned int )alternate);
  }
  if (! alt) {
    {
    tmp___1 = dev_name((struct device  const  *)(& dev->dev));
    tmp___2 = dev_driver_string((struct device  const  *)(& dev->dev));
    printk("<4>%s %s: selecting invalid altsetting %d", tmp___2, tmp___1, alternate);
    }
    return (-22);
  }
  if (dev->quirks & 4U) {
    {
    ret = -32;
    }
  } else {
    {
    tmp___3 = __create_pipe(dev, 0U);
    ret = usb_control_msg(dev, (unsigned int )(2 << 30) | tmp___3, (unsigned char)11,
                          (unsigned char)1, (unsigned short )alternate, (unsigned short )interface,
                          (void *)0, (unsigned short)0, 5000);
    }
  }
  if (ret == -32) {
    if (iface->num_altsetting == 1U) {
      {
      manual = 1;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (ret < 0) {
      return (ret);
    }
  }
  if ((unsigned long )iface->cur_altsetting != (unsigned long )alt) {
    {
    remove_intf_ep_devs(iface);
    usb_remove_sysfs_intf_files(iface);
    }
  }
  {
  usb_disable_interface(dev, iface, (_Bool)1);
  iface->cur_altsetting = alt;
  }
  if (manual) {
    {
    i = 0;
    }
    {
    while (1) {
      while_637_continue: /* CIL Label */ ;
      if (! (i < (int )alt->desc.bNumEndpoints)) {
        goto while_637_break;
      }
      {
      epaddr = (unsigned int )(alt->endpoint + i)->desc.bEndpointAddress;
      tmp___6 = __create_pipe(dev, 15U & epaddr);
      }
      if (! (epaddr & 128U)) {
        {
        tmp___7 = 0;
        }
      } else {
        {
        tmp___7 = 128;
        }
      }
      {
      pipe = tmp___6 | (unsigned int )tmp___7;
      usb_clear_halt(dev, (int )pipe);
      i ++;
      }
    }
    while_637_break: /* CIL Label */ ;
    }
  }
  {
  usb_enable_interface(dev, iface, (_Bool)1);
  tmp___8 = device_is_registered(& iface->dev);
  }
  if (tmp___8) {
    {
    usb_create_sysfs_intf_files(iface);
    create_intf_ep_devs(iface);
    }
  }
  return (0);
}
}
static char const   __kstrtab_usb_set_interface[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'f',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_set_interface  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_set_interface), __kstrtab_usb_set_interface};
int usb_reset_configuration(struct usb_device *dev ) 
{ int i ;
  int retval ;
  struct usb_host_config *config ;
  unsigned int tmp ;
  struct usb_interface *intf ;
  struct usb_host_interface *alt ;
  int tmp___0 ;

  {
  if ((unsigned int )dev->state == 8U) {
    return (-113);
  }
  {
  i = 1;
  }
  {
  while (1) {
    while_638_continue: /* CIL Label */ ;
    if (! (i < 16)) {
      goto while_638_break;
    }
    {
    usb_disable_endpoint(dev, (unsigned int )i, (_Bool)1);
    usb_disable_endpoint(dev, (unsigned int )(i + 128), (_Bool)1);
    i ++;
    }
  }
  while_638_break: /* CIL Label */ ;
  }
  {
  config = dev->actconfig;
  tmp = __create_pipe(dev, 0U);
  retval = usb_control_msg(dev, (unsigned int )(2 << 30) | tmp, (unsigned char)9,
                           (unsigned char)0, (unsigned short )config->desc.bConfigurationValue,
                           (unsigned short)0, (void *)0, (unsigned short)0, 5000);
  }
  if (retval < 0) {
    return (retval);
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_639_continue: /* CIL Label */ ;
    if (! (i < (int )config->desc.bNumInterfaces)) {
      goto while_639_break;
    }
    {
    intf = config->interface[i];
    alt = usb_altnum_to_altsetting((struct usb_interface  const  *)intf, 0U);
    }
    if (! alt) {
      {
      alt = intf->altsetting + 0;
      }
    }
    if ((unsigned long )alt != (unsigned long )intf->cur_altsetting) {
      {
      remove_intf_ep_devs(intf);
      usb_remove_sysfs_intf_files(intf);
      }
    }
    {
    intf->cur_altsetting = alt;
    usb_enable_interface(dev, intf, (_Bool)1);
    tmp___0 = device_is_registered(& intf->dev);
    }
    if (tmp___0) {
      {
      usb_create_sysfs_intf_files(intf);
      create_intf_ep_devs(intf);
      }
    }
    {
    i ++;
    }
  }
  while_639_break: /* CIL Label */ ;
  }
  return (0);
}
}
static char const   __kstrtab_usb_reset_configuration[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'_',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'f',      (char const   )'i',      (char const   )'g', 
        (char const   )'u',      (char const   )'r',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_reset_configuration  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_reset_configuration), __kstrtab_usb_reset_configuration};
static void usb_release_interface(struct device *dev ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  struct usb_interface_cache *intfc ;
  struct usb_host_interface  const  *__mptr___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  __mptr___0 = (struct usb_host_interface  const  *)intf->altsetting;
  intfc = (struct usb_interface_cache *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_interface_cache *)0)->altsetting[0]));
  kref_put(& intfc->ref, & usb_release_interface_cache);
  kfree((void const   *)intf);
  }
  return;
}
}
static int usb_if_uevent(struct device *dev , struct kobj_uevent_env *env ) 
{ struct usb_device *usb_dev ;
  struct usb_interface *intf ;
  struct usb_host_interface *alt ;
  struct device  const  *__mptr ;
  struct device  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  __mptr___0 = (struct device  const  *)intf->dev.parent;
  usb_dev = (struct usb_device *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_device *)0)->dev));
  alt = intf->cur_altsetting;
  tmp = add_uevent_var(env, "INTERFACE=%d/%d/%d", alt->desc.bInterfaceClass, alt->desc.bInterfaceSubClass,
                       alt->desc.bInterfaceProtocol);
  }
  if (tmp) {
    return (-12);
  }
  {
  tmp___0 = add_uevent_var(env, "MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
                           usb_dev->descriptor.idVendor, usb_dev->descriptor.idProduct,
                           usb_dev->descriptor.bcdDevice, usb_dev->descriptor.bDeviceClass,
                           usb_dev->descriptor.bDeviceSubClass, usb_dev->descriptor.bDeviceProtocol,
                           alt->desc.bInterfaceClass, alt->desc.bInterfaceSubClass,
                           alt->desc.bInterfaceProtocol);
  }
  if (tmp___0) {
    return (-12);
  }
  return (0);
}
}
struct device_type usb_if_device_type  =    {"usb_interface", (struct attribute_group **)0, & usb_if_uevent, & usb_release_interface,
    (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
    (struct dev_pm_ops *)0};
static struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev , struct usb_host_config *config ,
                                                       u8 inum ) 
{ struct usb_interface_assoc_descriptor *retval ;
  struct usb_interface_assoc_descriptor *intf_assoc ;
  int first_intf ;
  int last_intf ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  retval = (struct usb_interface_assoc_descriptor *)((void *)0);
  i = 0;
  }
  {
  while (1) {
    while_640_continue: /* CIL Label */ ;
    if (i < 16) {
      if (! config->intf_assoc[i]) {
        goto while_640_break;
      }
    } else {
      goto while_640_break;
    }
    {
    intf_assoc = config->intf_assoc[i];
    }
    if ((int )intf_assoc->bInterfaceCount == 0) {
      goto __Cont;
    }
    {
    first_intf = (int )intf_assoc->bFirstInterface;
    last_intf = first_intf + ((int )intf_assoc->bInterfaceCount - 1);
    }
    if ((int )inum >= first_intf) {
      if ((int )inum <= last_intf) {
        if (! retval) {
          {
          retval = intf_assoc;
          }
        } else {
          {
          tmp = dev_name((struct device  const  *)(& dev->dev));
          tmp___0 = dev_driver_string((struct device  const  *)(& dev->dev));
          printk("<3>%s %s: Interface #%d referenced by multiple IADs\n", tmp___0,
                 tmp, inum);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_640_break: /* CIL Label */ ;
  }
  return (retval);
}
}
void __usb_queue_reset_device(struct work_struct *ws ) 
{ int rc ;
  struct usb_interface *iface ;
  struct work_struct  const  *__mptr ;
  struct usb_device *udev ;
  struct device  const  *__mptr___0 ;

  {
  {
  __mptr = (struct work_struct  const  *)ws;
  iface = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->reset_ws));
  __mptr___0 = (struct device  const  *)iface->dev.parent;
  udev = (struct usb_device *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_device *)0)->dev));
  rc = usb_lock_device_for_reset(udev, (struct usb_interface  const  *)iface);
  }
  if (rc >= 0) {
    {
    iface->reset_running = 1U;
    usb_reset_device(udev);
    iface->reset_running = 0U;
    up(& udev->dev.sem);
    }
  }
  return;
}
}
int usb_set_configuration(struct usb_device *dev , int configuration ) 
{ int i ;
  int ret ;
  struct usb_host_config *cp ;
  struct usb_interface **new_interfaces ;
  int n ;
  int nintf ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  unsigned int tmp___9 ;
  struct usb_interface_cache *intfc ;
  struct usb_interface *intf ;
  struct usb_host_interface *alt ;
  atomic_long_t __constr_expr_0 ;
  struct usb_interface *intf___0 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
  {
  cp = (struct usb_host_config *)((void *)0);
  new_interfaces = (struct usb_interface **)((void *)0);
  }
  if (dev->authorized == 0U) {
    {
    configuration = 0;
    }
  } else {
    if (configuration == -1) {
      {
      configuration = 0;
      }
    } else {
      {
      i = 0;
      }
      {
      while (1) {
        while_641_continue: /* CIL Label */ ;
        if (! (i < (int )dev->descriptor.bNumConfigurations)) {
          goto while_641_break;
        }
        if ((int )(dev->config + i)->desc.bConfigurationValue == configuration) {
          {
          cp = dev->config + i;
          }
          goto while_641_break;
        }
        {
        i ++;
        }
      }
      while_641_break: /* CIL Label */ ;
      }
    }
  }
  if (! cp) {
    if (configuration != 0) {
      return (-22);
    }
  }
  if (cp) {
    if (configuration == 0) {
      {
      tmp = dev_name((struct device  const  *)(& dev->dev));
      tmp___0 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<4>%s %s: config 0 descriptor??\n", tmp___0, tmp);
      }
    }
  }
  {
  nintf = 0;
  n = nintf;
  }
  if (cp) {
    {
    nintf = (int )cp->desc.bNumInterfaces;
    tmp___1 = kmalloc((unsigned int )((unsigned long )nintf * sizeof(*new_interfaces)),
                      208U);
    new_interfaces = (struct usb_interface **)tmp___1;
    }
    if (! new_interfaces) {
      {
      tmp___2 = dev_name((struct device  const  *)(& dev->dev));
      tmp___3 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<3>%s %s: Out of memory\n", tmp___3, tmp___2);
      }
      return (-12);
    }
    {
    while (1) {
      while_642_continue: /* CIL Label */ ;
      if (! (n < nintf)) {
        goto while_642_break;
      }
      {
      tmp___4 = kzalloc((unsigned int )sizeof(struct usb_interface ), 208U);
      *(new_interfaces + n) = (struct usb_interface *)tmp___4;
      }
      if (! *(new_interfaces + n)) {
        {
        tmp___5 = dev_name((struct device  const  *)(& dev->dev));
        tmp___6 = dev_driver_string((struct device  const  *)(& dev->dev));
        printk("<3>%s %s: Out of memory\n", tmp___6, tmp___5);
        ret = -12;
        }
        free_interfaces: 
        {
        while (1) {
          while_643_continue: /* CIL Label */ ;
          {
          n --;
          }
          if (! (n >= 0)) {
            goto while_643_break;
          }
          {
          kfree((void const   *)*(new_interfaces + n));
          }
        }
        while_643_break: /* CIL Label */ ;
        }
        {
        kfree((void const   *)new_interfaces);
        }
        return (ret);
      }
      {
      n ++;
      }
    }
    while_642_break: /* CIL Label */ ;
    }
    {
    i = (int )dev->bus_mA - (int )cp->desc.bMaxPower * 2;
    }
    if (i < 0) {
      {
      tmp___7 = dev_name((struct device  const  *)(& dev->dev));
      tmp___8 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<4>%s %s: new config #%d exceeds power limit by %dmA\n", tmp___8, tmp___7,
             configuration, - i);
      }
    }
  }
  {
  ret = usb_autoresume_device(dev);
  }
  if (ret) {
    goto free_interfaces;
  }
  if ((unsigned int )dev->state != 6U) {
    {
    usb_disable_device(dev, 1);
    }
  }
  {
  cancel_async_set_config(dev);
  tmp___9 = __create_pipe(dev, 0U);
  ret = usb_control_msg(dev, (unsigned int )(2 << 30) | tmp___9, (unsigned char)9,
                        (unsigned char)0, (unsigned short )configuration, (unsigned short)0,
                        (void *)0, (unsigned short)0, 5000);
  }
  if (ret < 0) {
    {
    cp = (struct usb_host_config *)((void *)0);
    }
  }
  {
  dev->actconfig = cp;
  }
  if (! cp) {
    {
    usb_set_device_state(dev, (enum usb_device_state )6);
    usb_autosuspend_device(dev);
    }
    goto free_interfaces;
  }
  {
  usb_set_device_state(dev, (enum usb_device_state )7);
  i = 0;
  }
  {
  while (1) {
    while_644_continue: /* CIL Label */ ;
    if (! (i < nintf)) {
      goto while_644_break;
    }
    {
    intf = *(new_interfaces + i);
    cp->interface[i] = intf;
    intfc = cp->intf_cache[i];
    intf->altsetting = intfc->altsetting;
    intf->num_altsetting = intfc->num_altsetting;
    intf->intf_assoc = find_iad(dev, cp, (unsigned char )i);
    kref_get(& intfc->ref);
    alt = usb_altnum_to_altsetting((struct usb_interface  const  *)intf, 0U);
    }
    if (! alt) {
      {
      alt = intf->altsetting + 0;
      }
    }
    {
    intf->cur_altsetting = alt;
    usb_enable_interface(dev, intf, (_Bool)1);
    intf->dev.parent = & dev->dev;
    intf->dev.driver = (struct device_driver *)((void *)0);
    intf->dev.bus = & usb_bus_type;
    intf->dev.type = & usb_if_device_type;
    intf->dev.groups = usb_interface_groups;
    intf->dev.dma_mask = dev->dev.dma_mask;
    }
    {
    while (1) {
      while_645_continue: /* CIL Label */ ;
      {
      __constr_expr_0.counter = (int volatile   )0;
      intf->reset_ws.data = __constr_expr_0;
      INIT_LIST_HEAD(& intf->reset_ws.entry);
      }
      {
      while (1) {
        while_646_continue: /* CIL Label */ ;
        {
        intf->reset_ws.func = & __usb_queue_reset_device;
        }
        goto while_646_break;
      }
      while_646_break: /* CIL Label */ ;
      }
      goto while_645_break;
    }
    while_645_break: /* CIL Label */ ;
    }
    {
    device_initialize(& intf->dev);
    mark_quiesced(intf);
    dev_set_name(& intf->dev, "%d-%s:%d.%d", (dev->bus)->busnum, dev->devpath, configuration,
                 alt->desc.bInterfaceNumber);
    i ++;
    }
  }
  while_644_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)new_interfaces);
  }
  if ((unsigned long )cp->string == (unsigned long )((void *)0)) {
    if (! (dev->quirks & 8U)) {
      {
      cp->string = usb_cache_string(dev, (int )cp->desc.iConfiguration);
      }
    }
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_647_continue: /* CIL Label */ ;
    if (! (i < nintf)) {
      goto while_647_break;
    }
    {
    intf___0 = cp->interface[i];
    ret = device_add(& intf___0->dev);
    }
    if (ret != 0) {
      {
      tmp___13 = dev_name((struct device  const  *)(& intf___0->dev));
      tmp___14 = dev_name((struct device  const  *)(& dev->dev));
      tmp___15 = dev_driver_string((struct device  const  *)(& dev->dev));
      printk("<3>%s %s: device_add(%s) --> %d\n", tmp___15, tmp___14, tmp___13, ret);
      }
      goto __Cont;
    }
    {
    create_intf_ep_devs(intf___0);
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_647_break: /* CIL Label */ ;
  }
  {
  usb_autosuspend_device(dev);
  }
  return (0);
}
}
static struct list_head set_config_list  =    {& set_config_list, & set_config_list};
static spinlock_t set_config_lock  =    {{0U}};
static void driver_set_config_work(struct work_struct *work ) 
{ struct set_config_request *req ;
  struct work_struct  const  *__mptr ;
  struct usb_device *udev ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  req = (struct set_config_request *)((char *)__mptr - (unsigned int )(& ((struct set_config_request *)0)->work));
  udev = req->udev;
  down(& udev->dev.sem);
  _spin_lock(& set_config_lock);
  list_del(& req->node);
  }
  {
  while (1) {
    while_648_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& set_config_lock.raw_lock);
    }
    goto while_648_break;
  }
  while_648_break: /* CIL Label */ ;
  }
  if (req->config >= -1) {
    {
    usb_set_configuration(udev, req->config);
    }
  }
  {
  up(& udev->dev.sem);
  usb_put_dev(udev);
  kfree((void const   *)req);
  }
  return;
}
}
static void cancel_async_set_config(struct usb_device *udev ) 
{ struct set_config_request *req ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  _spin_lock(& set_config_lock);
  __mptr = (struct list_head  const  *)set_config_list.next;
  req = (struct set_config_request *)((char *)__mptr - (unsigned int )(& ((struct set_config_request *)0)->node));
  }
  {
  while (1) {
    while_649_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)req->node.next);
    }
    if (! ((unsigned long )(& req->node) != (unsigned long )(& set_config_list))) {
      goto while_649_break;
    }
    if ((unsigned long )req->udev == (unsigned long )udev) {
      {
      req->config = -999;
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)req->node.next;
    req = (struct set_config_request *)((char *)__mptr___0 - (unsigned int )(& ((struct set_config_request *)0)->node));
    }
  }
  while_649_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_650_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& set_config_lock.raw_lock);
    }
    goto while_650_break;
  }
  while_650_break: /* CIL Label */ ;
  }
  return;
}
}
int usb_driver_set_configuration(struct usb_device *udev , int config ) 
{ struct set_config_request *req ;
  void *tmp ;
  atomic_long_t __constr_expr_0 ;

  {
  {
  tmp = kmalloc((unsigned int )sizeof(*req), 208U);
  req = (struct set_config_request *)tmp;
  }
  if (! req) {
    return (-12);
  }
  {
  req->udev = udev;
  req->config = config;
  }
  {
  while (1) {
    while_651_continue: /* CIL Label */ ;
    {
    __constr_expr_0.counter = (int volatile   )0;
    req->work.data = __constr_expr_0;
    INIT_LIST_HEAD(& req->work.entry);
    }
    {
    while (1) {
      while_652_continue: /* CIL Label */ ;
      {
      req->work.func = & driver_set_config_work;
      }
      goto while_652_break;
    }
    while_652_break: /* CIL Label */ ;
    }
    goto while_651_break;
  }
  while_651_break: /* CIL Label */ ;
  }
  {
  _spin_lock(& set_config_lock);
  list_add(& req->node, & set_config_list);
  }
  {
  while (1) {
    while_653_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& set_config_lock.raw_lock);
    }
    goto while_653_break;
  }
  while_653_break: /* CIL Label */ ;
  }
  {
  usb_get_dev(udev);
  schedule_work(& req->work);
  }
  return (0);
}
}
static char const   __kstrtab_usb_driver_set_configuration[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'d',      (char const   )'r',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'f',      (char const   )'i', 
        (char const   )'g',      (char const   )'u',      (char const   )'r',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_driver_set_configuration  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_driver_set_configuration), __kstrtab_usb_driver_set_configuration};
static unsigned long __force_order___12  ;
__inline static unsigned long native_read_cr0___12(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___12));
  }
  return (val);
}
}
__inline static void native_write_cr0___12(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___12));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___12(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___12));
  }
  return (val);
}
}
__inline static void native_write_cr2___12(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___12));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___12(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___12));
  }
  return (val);
}
}
__inline static void native_write_cr3___12(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___12));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___12(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___12));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___12(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___12): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___12(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___12));
  }
  return;
}
}
__inline static void load_cr3___12(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___12((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___12(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___12();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___12((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___12(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___12();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___12((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___12(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_39___2 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___12(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___12(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___12(u64 ns ) ;
static union ktime  const  ktime_zero___12  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___12(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___12.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___12(struct hrtimer *timer , ktime_t time ,
                                                       unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___12((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___16  ;
static struct blocking_notifier_head usb_notifier_list  =    {{0L, {{0U}}, {& usb_notifier_list.rwsem.wait_list, & usb_notifier_list.rwsem.wait_list}},
    (struct notifier_block *)((void *)0)};
void usb_register_notify(struct notifier_block *nb ) 
{ 

  {
  {
  blocking_notifier_chain_register(& usb_notifier_list, nb);
  }
  return;
}
}
static char const   __kstrtab_usb_register_notify[20]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'i', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'n',      (char const   )'o',      (char const   )'t', 
        (char const   )'i',      (char const   )'f',      (char const   )'y',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_register_notify  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_register_notify), __kstrtab_usb_register_notify};
void usb_unregister_notify(struct notifier_block *nb ) 
{ 

  {
  {
  blocking_notifier_chain_unregister(& usb_notifier_list, nb);
  }
  return;
}
}
static char const   __kstrtab_usb_unregister_notify[22]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_unregister_notify  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_unregister_notify), __kstrtab_usb_unregister_notify};
void usb_notify_add_device(struct usb_device *udev ) 
{ 

  {
  {
  blocking_notifier_call_chain(& usb_notifier_list, 1UL, (void *)udev);
  }
  return;
}
}
void usb_notify_remove_device(struct usb_device *udev ) 
{ 

  {
  {
  mutex_lock(& usbfs_mutex);
  blocking_notifier_call_chain(& usb_notifier_list, 2UL, (void *)udev);
  mutex_unlock(& usbfs_mutex);
  }
  return;
}
}
void usb_notify_add_bus(struct usb_bus *ubus ) 
{ 

  {
  {
  blocking_notifier_call_chain(& usb_notifier_list, 3UL, (void *)ubus);
  }
  return;
}
}
void usb_notify_remove_bus(struct usb_bus *ubus ) 
{ 

  {
  {
  blocking_notifier_call_chain(& usb_notifier_list, 4UL, (void *)ubus);
  }
  return;
}
}
static unsigned long __force_order___13  ;
__inline static unsigned long native_read_cr0___13(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___13));
  }
  return (val);
}
}
__inline static void native_write_cr0___13(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___13));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___13(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___13));
  }
  return (val);
}
}
__inline static void native_write_cr2___13(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___13));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___13(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___13));
  }
  return (val);
}
}
__inline static void native_write_cr3___13(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___13));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___13(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___13));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___13(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___13): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___13(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___13));
  }
  return;
}
}
__inline static void load_cr3___13(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___13((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___13(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___13();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___13((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___13(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___13();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___13((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___13(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_39___3 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___13(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___13(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___13(u64 ns ) ;
static union ktime  const  ktime_zero___13  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___13(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___13.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___13(struct hrtimer *timer , ktime_t time ,
                                                       unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___13((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___17  ;
static struct usb_device_id  const  usb_quirk_list[14]  = 
  {      {(__u16 )3, (__u16 )516, (__u16 )24613, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )1008, (__u16 )1793, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )1}, 
        {(__u16 )3, (__u16 )1054, (__u16 )12320, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )1137, (__u16 )341, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )1410, (__u16 )7, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )1410, (__u16 )39, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )1452, (__u16 )538, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )1592, (__u16 )2579, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )1}, 
        {(__u16 )3, (__u16 )1699, (__u16 )6, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (kernel_ulong_t )8}, 
        {(__u16 )3, (__u16 )2284, (__u16 )4096, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )2417, (__u16 )8192, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )4}, 
        {(__u16 )3, (__u16 )4310, (__u16 )8704, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )1}, 
        {(__u16 )3, (__u16 )5398, (__u16 )34344, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )2}, 
        {(__u16 )3, (__u16 )32902, (__u16 )61861, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (kernel_ulong_t )2}};
static struct usb_device_id  const  *find_id(struct usb_device *udev ) 
{ struct usb_device_id  const  *id ;
  int tmp ;

  {
  {
  id = usb_quirk_list;
  }
  {
  while (1) {
    while_654_continue: /* CIL Label */ ;
    if (! id->idVendor) {
      if (! id->bDeviceClass) {
        if (! id->bInterfaceClass) {
          if (! id->driver_info) {
            goto while_654_break;
          }
        }
      }
    }
    {
    tmp = usb_match_device(udev, id);
    }
    if (tmp) {
      return (id);
    }
    {
    id ++;
    }
  }
  while_654_break: /* CIL Label */ ;
  }
  return ((struct usb_device_id  const  *)((void *)0));
}
}
void usb_detect_quirks(struct usb_device *udev ) 
{ struct usb_device_id  const  *id ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
  id = usb_quirk_list;
  id = find_id(udev);
  }
  if (id) {
    {
    udev->quirks = (unsigned int )id->driver_info;
    }
  }
  if (udev->quirks) {

  }
  if ((int )udev->descriptor.bDeviceClass != 9) {
    {
    udev->autosuspend_disabled = 1U;
    }
  }
  {
  udev->persist_enabled = 1U;
  }
  return;
}
}
static unsigned long __force_order___14  ;
__inline static unsigned long native_read_cr0___14(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___14));
  }
  return (val);
}
}
__inline static void native_write_cr0___14(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___14));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___14(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___14));
  }
  return (val);
}
}
__inline static void native_write_cr2___14(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___14));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___14(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___14));
  }
  return (val);
}
}
__inline static void native_write_cr3___14(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___14));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___14(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___14));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___14(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___14): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___14(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___14));
  }
  return;
}
}
__inline static void load_cr3___14(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___14((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___14(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___14();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___14((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___14(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___14();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___14((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___14(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_39___4 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___14(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___14(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___14(u64 ns ) ;
static union ktime  const  ktime_zero___14  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___14(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___14.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___14(struct hrtimer *timer , ktime_t time ,
                                                       unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___14((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___18  ;
static ssize_t show_bNumInterfaces(struct device *dev , struct device_attribute *attr ,
                                   char *buf ) 
{ struct usb_device *udev ;
  struct usb_host_config *actconfig ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  actconfig = udev->actconfig;
  }
  if (actconfig) {
    {
    tmp = sprintf(buf, "%2d\n", (int )actconfig->desc.bNumInterfaces);
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static struct device_attribute dev_attr_bNumInterfaces  =    {{"bNumInterfaces", (struct module *)0, (mode_t )292}, & show_bNumInterfaces, (ssize_t (*)(struct device *dev ,
                                                                                              struct device_attribute *attr ,
                                                                                              char const   *buf ,
                                                                                              size_t count ))((void *)0)};
static ssize_t show_bmAttributes(struct device *dev ,
                                 struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct usb_host_config *actconfig ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  actconfig = udev->actconfig;
  }
  if (actconfig) {
    {
    tmp = sprintf(buf, "%2x\n", (int )actconfig->desc.bmAttributes);
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static struct device_attribute dev_attr_bmAttributes___0  =    {{"bmAttributes", (struct module *)0, (mode_t )292}, & show_bmAttributes, (ssize_t (*)(struct device *dev ,
                                                                                          struct device_attribute *attr ,
                                                                                          char const   *buf ,
                                                                                          size_t count ))((void *)0)};
static ssize_t show_bMaxPower(struct device *dev ,
                              struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct usb_host_config *actconfig ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  actconfig = udev->actconfig;
  }
  if (actconfig) {
    {
    tmp = sprintf(buf, "%3dmA\n", (int )actconfig->desc.bMaxPower * 2);
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static struct device_attribute dev_attr_bMaxPower  =    {{"bMaxPower", (struct module *)0, (mode_t )292}, & show_bMaxPower, (ssize_t (*)(struct device *dev ,
                                                                                    struct device_attribute *attr ,
                                                                                    char const   *buf ,
                                                                                    size_t count ))((void *)0)};
static ssize_t show_configuration_string(struct device *dev ,
                                         struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct usb_host_config *actconfig ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  actconfig = udev->actconfig;
  }
  if (! actconfig) {
    return (0);
  } else {
    if (! actconfig->string) {
      return (0);
    }
  }
  {
  tmp = sprintf(buf, "%s\n", actconfig->string);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_configuration  =    {{"configuration", (struct module *)0, (mode_t )292}, & show_configuration_string,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bConfigurationValue(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ struct usb_device *udev ;
  struct usb_host_config *actconfig ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  actconfig = udev->actconfig;
  }
  if (actconfig) {
    {
    tmp = sprintf(buf, "%u\n", (int )actconfig->desc.bConfigurationValue);
    }
    return (tmp);
  } else {
    return (0);
  }
}
}
static ssize_t set_bConfigurationValue(struct device *dev , struct device_attribute *attr ,
                                       char const   *buf , size_t count ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int config ;
  int value ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sscanf(buf, "%d", & config);
  }
  if (tmp != 1) {
    return (-22);
  } else {
    if (config < -1) {
      return (-22);
    } else {
      if (config > 255) {
        return (-22);
      }
    }
  }
  {
  down(& udev->dev.sem);
  value = usb_set_configuration(udev, config);
  up(& udev->dev.sem);
  }
  if (value < 0) {
    {
    tmp___0 = (unsigned int )value;
    }
  } else {
    {
    tmp___0 = count;
    }
  }
  return ((int )tmp___0);
}
}
static struct device_attribute dev_attr_bConfigurationValue  =    {{"bConfigurationValue", (struct module *)0, (mode_t )420}, & show_bConfigurationValue,
    & set_bConfigurationValue};
static ssize_t show_product(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%s\n", udev->product);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_product  =    {{"product", (struct module *)0, (mode_t )292}, & show_product, (ssize_t (*)(struct device *dev ,
                                                                                struct device_attribute *attr ,
                                                                                char const   *buf ,
                                                                                size_t count ))((void *)0)};
static ssize_t show_manufacturer(struct device *dev ,
                                 struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%s\n", udev->manufacturer);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_manufacturer  =    {{"manufacturer", (struct module *)0, (mode_t )292}, & show_manufacturer, (ssize_t (*)(struct device *dev ,
                                                                                          struct device_attribute *attr ,
                                                                                          char const   *buf ,
                                                                                          size_t count ))((void *)0)};
static ssize_t show_serial(struct device *dev ,
                           struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%s\n", udev->serial);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_serial  =    {{"serial", (struct module *)0, (mode_t )292}, & show_serial, (ssize_t (*)(struct device *dev ,
                                                                              struct device_attribute *attr ,
                                                                              char const   *buf ,
                                                                              size_t count ))((void *)0)};
static ssize_t show_speed(struct device *dev ,
                          struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  char *speed ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if ((int )udev->speed == 1) {
    goto switch_655_1;
  } else {
    if ((int )udev->speed == 0) {
      goto switch_655_0;
    } else {
      if ((int )udev->speed == 2) {
        goto switch_655_0;
      } else {
        if ((int )udev->speed == 3) {
          goto switch_655_3;
        } else {
          {
          goto switch_655_default;
          if (0) {
            switch_655_1: /* CIL Label */ 
            {
            speed = (char *)"1.5";
            }
            goto switch_655_break;
            switch_655_0: /* CIL Label */ 
            switch_655_2: /* CIL Label */ 
            {
            speed = (char *)"12";
            }
            goto switch_655_break;
            switch_655_3: /* CIL Label */ 
            {
            speed = (char *)"480";
            }
            goto switch_655_break;
            switch_655_default: /* CIL Label */ 
            {
            speed = (char *)"unknown";
            }
          } else {
            switch_655_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  tmp = sprintf(buf, "%s\n", speed);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_speed  =    {{"speed", (struct module *)0, (mode_t )292}, & show_speed, (ssize_t (*)(struct device *dev ,
                                                                            struct device_attribute *attr ,
                                                                            char const   *buf ,
                                                                            size_t count ))((void *)0)};
static ssize_t show_busnum(struct device *dev ,
                           struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", (udev->bus)->busnum);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_busnum  =    {{"busnum", (struct module *)0, (mode_t )292}, & show_busnum, (ssize_t (*)(struct device *dev ,
                                                                              struct device_attribute *attr ,
                                                                              char const   *buf ,
                                                                              size_t count ))((void *)0)};
static ssize_t show_devnum(struct device *dev ,
                           struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", udev->devnum);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_devnum  =    {{"devnum", (struct module *)0, (mode_t )292}, & show_devnum, (ssize_t (*)(struct device *dev ,
                                                                              struct device_attribute *attr ,
                                                                              char const   *buf ,
                                                                              size_t count ))((void *)0)};
static ssize_t show_version(struct device *dev ,
                            struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  u16 bcdUSB ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  bcdUSB = udev->descriptor.bcdUSB;
  tmp = sprintf(buf, "%2x.%02x\n", (int )bcdUSB >> 8, (int )bcdUSB & 255);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_version  =    {{"version", (struct module *)0, (mode_t )292}, & show_version, (ssize_t (*)(struct device *dev ,
                                                                                struct device_attribute *attr ,
                                                                                char const   *buf ,
                                                                                size_t count ))((void *)0)};
static ssize_t show_maxchild(struct device *dev ,
                             struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", udev->maxchild);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_maxchild  =    {{"maxchild", (struct module *)0, (mode_t )292}, & show_maxchild, (ssize_t (*)(struct device *dev ,
                                                                                  struct device_attribute *attr ,
                                                                                  char const   *buf ,
                                                                                  size_t count ))((void *)0)};
static ssize_t show_quirks(struct device *dev ,
                           struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "0x%x\n", udev->quirks);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_quirks  =    {{"quirks", (struct module *)0, (mode_t )292}, & show_quirks, (ssize_t (*)(struct device *dev ,
                                                                              struct device_attribute *attr ,
                                                                              char const   *buf ,
                                                                              size_t count ))((void *)0)};
static ssize_t show_urbnum(struct device *dev ,
                           struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", udev->urbnum.counter);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_urbnum  =    {{"urbnum", (struct module *)0, (mode_t )292}, & show_urbnum, (ssize_t (*)(struct device *dev ,
                                                                              struct device_attribute *attr ,
                                                                              char const   *buf ,
                                                                              size_t count ))((void *)0)};
static char const   power_group[6]  = {      (char const   )'p',      (char const   )'o',      (char const   )'w',      (char const   )'e', 
        (char const   )'r',      (char const   )'\000'};
static ssize_t show_persist(struct device *dev ,
                            struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", udev->persist_enabled);
  }
  return (tmp);
}
}
static ssize_t set_persist(struct device *dev , struct device_attribute *attr , char const   *buf ,
                           size_t count ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int value ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if ((int )udev->descriptor.bDeviceClass == 9) {
    return (-1);
  }
  {
  tmp = sscanf(buf, "%d", & value);
  }
  if (tmp != 1) {
    return (-22);
  }
  {
  usb_pm_lock(udev);
  udev->persist_enabled = (unsigned int )(! (! value));
  usb_pm_unlock(udev);
  }
  return ((int )count);
}
}
static struct device_attribute dev_attr_persist  =    {{"persist", (struct module *)0, (mode_t )420}, & show_persist, & set_persist};
static int add_persist_attributes(struct device *dev ) 
{ int rc ;
  struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  rc = 0;
  tmp = is_usb_device((struct device  const  *)dev);
  }
  if (tmp) {
    {
    __mptr = (struct device  const  *)dev;
    udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
    }
    if ((int )udev->descriptor.bDeviceClass != 9) {
      {
      rc = sysfs_add_file_to_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_persist.attr),
                                   power_group);
      }
    }
  }
  return (rc);
}
}
static void remove_persist_attributes(struct device *dev ) 
{ 

  {
  {
  sysfs_remove_file_from_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_persist.attr),
                               power_group);
  }
  return;
}
}
static ssize_t show_connected_duration(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = jiffies_to_msecs((unsigned long )(jiffies - (unsigned long volatile   )udev->connect_time));
  tmp___0 = sprintf(buf, "%u\n", tmp);
  }
  return (tmp___0);
}
}
static struct device_attribute dev_attr_connected_duration  =    {{"connected_duration", (struct module *)0, (mode_t )292}, & show_connected_duration,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_active_duration(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int duration ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if ((unsigned int )udev->state != 8U) {
    {
    tmp = jiffies_to_msecs((unsigned long )(jiffies + (unsigned long volatile   )udev->active_duration));
    duration = (int )tmp;
    }
  } else {
    {
    tmp___0 = jiffies_to_msecs(udev->active_duration);
    duration = (int )tmp___0;
    }
  }
  {
  tmp___1 = sprintf(buf, "%u\n", duration);
  }
  return (tmp___1);
}
}
static struct device_attribute dev_attr_active_duration  =    {{"active_duration", (struct module *)0, (mode_t )292}, & show_active_duration,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_autosuspend(struct device *dev , struct device_attribute *attr ,
                                char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", udev->autosuspend_delay / 1000);
  }
  return (tmp);
}
}
static ssize_t set_autosuspend(struct device *dev , struct device_attribute *attr ,
                               char const   *buf , size_t count ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int value ;
  int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sscanf(buf, "%d", & value);
  }
  if (tmp != 1) {
    return (-22);
  } else {
    if (value >= (int )(4294967295U >> 1) / 1000) {
      return (-22);
    } else {
      if (value <= - ((int )(4294967295U >> 1)) / 1000) {
        return (-22);
      }
    }
  }
  {
  value *= 1000;
  udev->autosuspend_delay = value;
  }
  if (value >= 0) {
    {
    usb_try_autosuspend_device(udev);
    }
  } else {
    {
    tmp___0 = usb_autoresume_device(udev);
    }
    if (tmp___0 == 0) {
      {
      usb_autosuspend_device(udev);
      }
    }
  }
  return ((int )count);
}
}
static struct device_attribute dev_attr_autosuspend  =    {{"autosuspend", (struct module *)0, (mode_t )420}, & show_autosuspend, & set_autosuspend};
static char const   on_string[3]  = {      (char const   )'o',      (char const   )'n',      (char const   )'\000'};
static char const   auto_string[5]  = {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'o', 
        (char const   )'\000'};
static char const   suspend_string[8]  = 
  {      (char const   )'s',      (char const   )'u',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'n',      (char const   )'d',      (char const   )'\000'};
static ssize_t show_level(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  char const   *p ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  p = auto_string;
  }
  if ((unsigned int )udev->state == 8U) {
    if (udev->autoresume_disabled) {
      {
      p = suspend_string;
      }
    }
  } else {
    if (udev->autosuspend_disabled) {
      {
      p = on_string;
      }
    }
  }
  {
  tmp = sprintf(buf, "%s\n", p);
  }
  return (tmp);
}
}
static ssize_t set_level(struct device *dev , struct device_attribute *attr , char const   *buf ,
                         size_t count ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int len ;
  char *cp ;
  int rc ;
  int old_autosuspend_disabled ;
  int old_autoresume_disabled ;
  void *tmp ;
  struct pm_message __constr_expr_0 ;
  struct pm_message __constr_expr_1 ;
  struct pm_message __constr_expr_2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  len = (int )count;
  rc = 0;
  tmp = memchr((void const   *)buf, '\n', count);
  cp = (char *)tmp;
  }
  if (cp) {
    {
    len = cp - (char *)buf;
    }
  }
  {
  down(& udev->dev.sem);
  old_autosuspend_disabled = (int )udev->autosuspend_disabled;
  old_autoresume_disabled = (int )udev->autoresume_disabled;
  }
  if ((unsigned long )len == sizeof(on_string) - 1UL) {
    {
    tmp___2 = strncmp(buf, on_string, (unsigned int )len);
    }
    if (tmp___2 == 0) {
      {
      udev->autosuspend_disabled = 1U;
      udev->autoresume_disabled = 0U;
      __constr_expr_0.event = 272;
      rc = usb_external_resume_device(udev, __constr_expr_0);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((unsigned long )len == sizeof(auto_string) - 1UL) {
      {
      tmp___1 = strncmp(buf, auto_string, (unsigned int )len);
      }
      if (tmp___1 == 0) {
        {
        udev->autosuspend_disabled = 0U;
        udev->autoresume_disabled = 0U;
        __constr_expr_1.event = 272;
        rc = usb_external_resume_device(udev, __constr_expr_1);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if ((unsigned long )len == sizeof(suspend_string) - 1UL) {
        {
        tmp___0 = strncmp(buf, suspend_string, (unsigned int )len);
        }
        if (tmp___0 == 0) {
          {
          udev->autosuspend_disabled = 0U;
          udev->autoresume_disabled = 1U;
          __constr_expr_2.event = 258;
          rc = usb_external_suspend_device(udev, __constr_expr_2);
          }
        } else {
          {
          rc = -22;
          }
        }
      } else {
        {
        rc = -22;
        }
      }
    }
  }
  if (rc) {
    {
    udev->autosuspend_disabled = (unsigned int )old_autosuspend_disabled;
    udev->autoresume_disabled = (unsigned int )old_autoresume_disabled;
    }
  }
  {
  up(& udev->dev.sem);
  }
  if (rc < 0) {
    {
    tmp___3 = (unsigned int )rc;
    }
  } else {
    {
    tmp___3 = count;
    }
  }
  return ((int )tmp___3);
}
}
static struct device_attribute dev_attr_level  =    {{"level", (struct module *)0, (mode_t )420}, & show_level, & set_level};
static int add_power_attributes(struct device *dev ) 
{ int rc ;
  int tmp ;

  {
  {
  rc = 0;
  tmp = is_usb_device((struct device  const  *)dev);
  }
  if (tmp) {
    {
    rc = sysfs_add_file_to_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_autosuspend.attr),
                                 power_group);
    }
    if (rc == 0) {
      {
      rc = sysfs_add_file_to_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_level.attr),
                                   power_group);
      }
    }
    if (rc == 0) {
      {
      rc = sysfs_add_file_to_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_connected_duration.attr),
                                   power_group);
      }
    }
    if (rc == 0) {
      {
      rc = sysfs_add_file_to_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_active_duration.attr),
                                   power_group);
      }
    }
  }
  return (rc);
}
}
static void remove_power_attributes(struct device *dev ) 
{ 

  {
  {
  sysfs_remove_file_from_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_active_duration.attr),
                               power_group);
  sysfs_remove_file_from_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_connected_duration.attr),
                               power_group);
  sysfs_remove_file_from_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_level.attr),
                               power_group);
  sysfs_remove_file_from_group(& dev->kobj, (struct attribute  const  *)(& dev_attr_autosuspend.attr),
                               power_group);
  }
  return;
}
}
static ssize_t show_idVendor(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%04x\n", udev->descriptor.idVendor);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_idVendor  =    {{"idVendor", (struct module *)0, (mode_t )292}, & show_idVendor, (ssize_t (*)(struct device *dev ,
                                                                                  struct device_attribute *attr ,
                                                                                  char const   *buf ,
                                                                                  size_t count ))((void *)0)};
static ssize_t show_idProduct(struct device *dev ,
                              struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%04x\n", udev->descriptor.idProduct);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_idProduct  =    {{"idProduct", (struct module *)0, (mode_t )292}, & show_idProduct, (ssize_t (*)(struct device *dev ,
                                                                                    struct device_attribute *attr ,
                                                                                    char const   *buf ,
                                                                                    size_t count ))((void *)0)};
static ssize_t show_bcdDevice(struct device *dev ,
                              struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%04x\n", udev->descriptor.bcdDevice);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bcdDevice  =    {{"bcdDevice", (struct module *)0, (mode_t )292}, & show_bcdDevice, (ssize_t (*)(struct device *dev ,
                                                                                    struct device_attribute *attr ,
                                                                                    char const   *buf ,
                                                                                    size_t count ))((void *)0)};
static ssize_t show_bDeviceClass(struct device *dev ,
                                 struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%02x\n", udev->descriptor.bDeviceClass);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bDeviceClass  =    {{"bDeviceClass", (struct module *)0, (mode_t )292}, & show_bDeviceClass, (ssize_t (*)(struct device *dev ,
                                                                                          struct device_attribute *attr ,
                                                                                          char const   *buf ,
                                                                                          size_t count ))((void *)0)};
static ssize_t show_bDeviceSubClass(struct device *dev ,
                                    struct device_attribute *attr , char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%02x\n", udev->descriptor.bDeviceSubClass);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bDeviceSubClass  =    {{"bDeviceSubClass", (struct module *)0, (mode_t )292}, & show_bDeviceSubClass,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bDeviceProtocol(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%02x\n", udev->descriptor.bDeviceProtocol);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bDeviceProtocol  =    {{"bDeviceProtocol", (struct module *)0, (mode_t )292}, & show_bDeviceProtocol,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bNumConfigurations(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", udev->descriptor.bNumConfigurations);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bNumConfigurations  =    {{"bNumConfigurations", (struct module *)0, (mode_t )292}, & show_bNumConfigurations,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bMaxPacketSize0(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = sprintf(buf, "%d\n", udev->descriptor.bMaxPacketSize0);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bMaxPacketSize0  =    {{"bMaxPacketSize0", (struct module *)0, (mode_t )292}, & show_bMaxPacketSize0,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t usb_dev_authorized_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ struct usb_device *usb_dev ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  usb_dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = snprintf(buf, (unsigned int )(1UL << 12), "%u\n", usb_dev->authorized);
  }
  return (tmp);
}
}
static ssize_t usb_dev_authorized_store(struct device *dev , struct device_attribute *attr ,
                                        char const   *buf , size_t size ) 
{ ssize_t result ;
  struct usb_device *usb_dev ;
  struct device  const  *__mptr ;
  unsigned int val ;
  size_t tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  usb_dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  result = sscanf(buf, "%u\n", & val);
  }
  if (result != 1) {
    {
    result = -22;
    }
  } else {
    if (val == 0U) {
      {
      result = usb_deauthorize_device(usb_dev);
      }
    } else {
      {
      result = usb_authorize_device(usb_dev);
      }
    }
  }
  if (result < 0) {
    {
    tmp = (unsigned int )result;
    }
  } else {
    {
    tmp = size;
    }
  }
  return ((int )tmp);
}
}
static struct device_attribute dev_attr_authorized  =    {{"authorized", (struct module *)0, (mode_t )420}, & usb_dev_authorized_show, & usb_dev_authorized_store};
static struct attribute *dev_attrs[22]  = 
  {      & dev_attr_configuration.attr,      & dev_attr_bNumInterfaces.attr,      & dev_attr_bConfigurationValue.attr,      & dev_attr_bmAttributes___0.attr, 
        & dev_attr_bMaxPower.attr,      & dev_attr_urbnum.attr,      & dev_attr_idVendor.attr,      & dev_attr_idProduct.attr, 
        & dev_attr_bcdDevice.attr,      & dev_attr_bDeviceClass.attr,      & dev_attr_bDeviceSubClass.attr,      & dev_attr_bDeviceProtocol.attr, 
        & dev_attr_bNumConfigurations.attr,      & dev_attr_bMaxPacketSize0.attr,      & dev_attr_speed.attr,      & dev_attr_busnum.attr, 
        & dev_attr_devnum.attr,      & dev_attr_version.attr,      & dev_attr_maxchild.attr,      & dev_attr_quirks.attr, 
        & dev_attr_authorized.attr,      (struct attribute *)((void *)0)};
static struct attribute_group dev_attr_grp  =    {(char const   *)0, (mode_t (*)(struct kobject * , struct attribute * , int  ))0,
    dev_attrs};
static struct attribute *dev_string_attrs[4]  = {      & dev_attr_manufacturer.attr,      & dev_attr_product.attr,      & dev_attr_serial.attr,      (struct attribute *)((void *)0)};
static mode_t dev_string_attrs_are_visible(struct kobject *kobj , struct attribute *a ,
                                           int n ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  struct kobject  const  *__mptr___0 ;

  {
  {
  __mptr___0 = (struct kobject  const  *)kobj;
  __mptr = (struct device  const  *)((struct device *)((char *)__mptr___0 - (unsigned int )(& ((struct device *)0)->kobj)));
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  }
  if ((unsigned long )a == (unsigned long )(& dev_attr_manufacturer.attr)) {
    if ((unsigned long )udev->manufacturer == (unsigned long )((void *)0)) {
      return ((unsigned short)0);
    }
  } else {
    if ((unsigned long )a == (unsigned long )(& dev_attr_product.attr)) {
      if ((unsigned long )udev->product == (unsigned long )((void *)0)) {
        return ((unsigned short)0);
      }
    } else {
      if ((unsigned long )a == (unsigned long )(& dev_attr_serial.attr)) {
        if ((unsigned long )udev->serial == (unsigned long )((void *)0)) {
          return ((unsigned short)0);
        }
      }
    }
  }
  return (a->mode);
}
}
static struct attribute_group dev_string_attr_grp  =    {(char const   *)0, & dev_string_attrs_are_visible, dev_string_attrs};
struct attribute_group *usb_device_groups[3]  = {      & dev_attr_grp,      & dev_string_attr_grp,      (struct attribute_group *)((void *)0)};
static ssize_t read_descriptors(struct kobject *kobj , struct bin_attribute *attr ,
                                char *buf , loff_t off , size_t count ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  struct kobject  const  *__mptr___0 ;
  size_t nleft ;
  size_t srclen ;
  size_t n ;
  int cfgno ;
  void *src ;
  size_t _min1 ;
  size_t _min2 ;
  size_t tmp ;

  {
  {
  __mptr___0 = (struct kobject  const  *)kobj;
  __mptr = (struct device  const  *)((struct device *)((char *)__mptr___0 - (unsigned int )(& ((struct device *)0)->kobj)));
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  nleft = count;
  cfgno = -1;
  }
  {
  while (1) {
    while_656_continue: /* CIL Label */ ;
    if (cfgno < (int )udev->descriptor.bNumConfigurations) {
      if (! (nleft > 0U)) {
        goto while_656_break;
      }
    } else {
      goto while_656_break;
    }
    if (cfgno < 0) {
      {
      src = (void *)(& udev->descriptor);
      srclen = (unsigned int )sizeof(struct usb_device_descriptor );
      }
    } else {
      {
      src = (void *)*(udev->rawdescriptors + cfgno);
      srclen = (unsigned int )(udev->config + cfgno)->desc.wTotalLength;
      }
    }
    if (off < (loff_t )srclen) {
      {
      _min1 = nleft;
      _min2 = srclen - (unsigned int )off;
      }
      if (_min1 < _min2) {
        {
        tmp = _min1;
        }
      } else {
        {
        tmp = _min2;
        }
      }
      {
      n = tmp;
      __memcpy((void *)buf, (void const   *)(src + off), n);
      nleft -= n;
      buf += n;
      off = 0LL;
      }
    } else {
      {
      off -= (loff_t )srclen;
      }
    }
    {
    cfgno ++;
    }
  }
  while_656_break: /* CIL Label */ ;
  }
  return ((int )(count - nleft));
}
}
static struct bin_attribute dev_bin_attr_descriptors  =    {{"descriptors", (struct module *)0, (mode_t )292}, (size_t )65553, (void *)0,
    & read_descriptors, (ssize_t (*)(struct kobject * , struct bin_attribute * , char * ,
                                     loff_t  , size_t  ))0, (int (*)(struct kobject * ,
                                                                     struct bin_attribute *attr ,
                                                                     struct vm_area_struct *vma ))0};
int usb_create_sysfs_dev_files(struct usb_device *udev ) 
{ struct device *dev ;
  int retval ;

  {
  {
  dev = & udev->dev;
  retval = device_create_bin_file(dev, & dev_bin_attr_descriptors);
  }
  if (retval) {
    goto error;
  }
  {
  retval = add_persist_attributes(dev);
  }
  if (retval) {
    goto error;
  }
  {
  retval = add_power_attributes(dev);
  }
  if (retval) {
    goto error;
  }
  return (retval);
  error: 
  {
  usb_remove_sysfs_dev_files(udev);
  }
  return (retval);
}
}
void usb_remove_sysfs_dev_files(struct usb_device *udev ) 
{ struct device *dev ;

  {
  {
  dev = & udev->dev;
  remove_power_attributes(dev);
  remove_persist_attributes(dev);
  device_remove_bin_file(dev, & dev_bin_attr_descriptors);
  }
  return;
}
}
static ssize_t show_iad_bFirstInterface(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->intf_assoc)->bFirstInterface);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_iad_bFirstInterface  =    {{"iad_bFirstInterface", (struct module *)0, (mode_t )292}, & show_iad_bFirstInterface,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_iad_bInterfaceCount(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02d\n", (intf->intf_assoc)->bInterfaceCount);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_iad_bInterfaceCount  =    {{"iad_bInterfaceCount", (struct module *)0, (mode_t )292}, & show_iad_bInterfaceCount,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_iad_bFunctionClass(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->intf_assoc)->bFunctionClass);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_iad_bFunctionClass  =    {{"iad_bFunctionClass", (struct module *)0, (mode_t )292}, & show_iad_bFunctionClass,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_iad_bFunctionSubClass(struct device *dev , struct device_attribute *attr ,
                                          char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->intf_assoc)->bFunctionSubClass);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_iad_bFunctionSubClass  =    {{"iad_bFunctionSubClass", (struct module *)0, (mode_t )292}, & show_iad_bFunctionSubClass,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_iad_bFunctionProtocol(struct device *dev , struct device_attribute *attr ,
                                          char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->intf_assoc)->bFunctionProtocol);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_iad_bFunctionProtocol  =    {{"iad_bFunctionProtocol", (struct module *)0, (mode_t )292}, & show_iad_bFunctionProtocol,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bInterfaceNumber(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->cur_altsetting)->desc.bInterfaceNumber);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bInterfaceNumber  =    {{"bInterfaceNumber", (struct module *)0, (mode_t )292}, & show_bInterfaceNumber,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bAlternateSetting(struct device *dev , struct device_attribute *attr ,
                                      char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%2d\n", (intf->cur_altsetting)->desc.bAlternateSetting);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bAlternateSetting  =    {{"bAlternateSetting", (struct module *)0, (mode_t )292}, & show_bAlternateSetting,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bNumEndpoints(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->cur_altsetting)->desc.bNumEndpoints);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bNumEndpoints  =    {{"bNumEndpoints", (struct module *)0, (mode_t )292}, & show_bNumEndpoints, (ssize_t (*)(struct device *dev ,
                                                                                            struct device_attribute *attr ,
                                                                                            char const   *buf ,
                                                                                            size_t count ))((void *)0)};
static ssize_t show_bInterfaceClass(struct device *dev ,
                                    struct device_attribute *attr , char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->cur_altsetting)->desc.bInterfaceClass);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bInterfaceClass  =    {{"bInterfaceClass", (struct module *)0, (mode_t )292}, & show_bInterfaceClass,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bInterfaceSubClass(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->cur_altsetting)->desc.bInterfaceSubClass);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bInterfaceSubClass  =    {{"bInterfaceSubClass", (struct module *)0, (mode_t )292}, & show_bInterfaceSubClass,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_bInterfaceProtocol(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  tmp = sprintf(buf, "%02x\n", (intf->cur_altsetting)->desc.bInterfaceProtocol);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_bInterfaceProtocol  =    {{"bInterfaceProtocol", (struct module *)0, (mode_t )292}, & show_bInterfaceProtocol,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static ssize_t show_interface_string(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ struct usb_interface *intf ;
  char *string ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  string = (intf->cur_altsetting)->string;
  __asm__  volatile   ("": : : "memory");
  }
  if (! string) {
    return (0);
  }
  {
  tmp = sprintf(buf, "%s\n", string);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_interface  =    {{"interface", (struct module *)0, (mode_t )292}, & show_interface_string, (ssize_t (*)(struct device *dev ,
                                                                                           struct device_attribute *attr ,
                                                                                           char const   *buf ,
                                                                                           size_t count ))((void *)0)};
static ssize_t show_modalias(struct device *dev ,
                             struct device_attribute *attr , char *buf ) 
{ struct usb_interface *intf ;
  struct usb_device *udev ;
  struct usb_host_interface *alt ;
  struct device  const  *__mptr ;
  struct device  const  *__mptr___0 ;
  int tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  __mptr___0 = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_device *)0)->dev));
  alt = intf->cur_altsetting;
  tmp = sprintf(buf, "usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X\n",
                udev->descriptor.idVendor, udev->descriptor.idProduct, udev->descriptor.bcdDevice,
                udev->descriptor.bDeviceClass, udev->descriptor.bDeviceSubClass, udev->descriptor.bDeviceProtocol,
                alt->desc.bInterfaceClass, alt->desc.bInterfaceSubClass, alt->desc.bInterfaceProtocol);
  }
  return (tmp);
}
}
static struct device_attribute dev_attr_modalias  =    {{"modalias", (struct module *)0, (mode_t )292}, & show_modalias, (ssize_t (*)(struct device *dev ,
                                                                                  struct device_attribute *attr ,
                                                                                  char const   *buf ,
                                                                                  size_t count ))((void *)0)};
static ssize_t show_supports_autosuspend(struct device *dev ,
                                         struct device_attribute *attr , char *buf ) 
{ struct usb_interface *intf ;
  struct usb_device *udev ;
  int ret ;
  struct device  const  *__mptr ;
  struct device  const  *__mptr___0 ;
  struct device_driver  const  *__mptr___1 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  __mptr___0 = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_device *)0)->dev));
  down(& udev->dev.sem);
  }
  if (! intf->dev.driver) {
    {
    ret = sprintf(buf, "%u\n", 1);
    }
  } else {
    {
    __mptr___1 = (struct device_driver  const  *)intf->dev.driver;
    }
    if (((struct usb_driver *)((char *)__mptr___1 - (unsigned int )(& ((struct usb_driver *)0)->drvwrap.driver)))->supports_autosuspend) {
      {
      ret = sprintf(buf, "%u\n", 1);
      }
    } else {
      {
      ret = sprintf(buf, "%u\n", 0);
      }
    }
  }
  {
  up(& udev->dev.sem);
  }
  return (ret);
}
}
static struct device_attribute dev_attr_supports_autosuspend  =    {{"supports_autosuspend", (struct module *)0, (mode_t )292}, & show_supports_autosuspend,
    (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                 size_t count ))((void *)0)};
static struct attribute *intf_attrs[9]  = 
  {      & dev_attr_bInterfaceNumber.attr,      & dev_attr_bAlternateSetting.attr,      & dev_attr_bNumEndpoints.attr,      & dev_attr_bInterfaceClass.attr, 
        & dev_attr_bInterfaceSubClass.attr,      & dev_attr_bInterfaceProtocol.attr,      & dev_attr_modalias.attr,      & dev_attr_supports_autosuspend.attr, 
        (struct attribute *)((void *)0)};
static struct attribute_group intf_attr_grp  =    {(char const   *)0, (mode_t (*)(struct kobject * , struct attribute * , int  ))0,
    intf_attrs};
static struct attribute *intf_assoc_attrs[6]  = {      & dev_attr_iad_bFirstInterface.attr,      & dev_attr_iad_bInterfaceCount.attr,      & dev_attr_iad_bFunctionClass.attr,      & dev_attr_iad_bFunctionSubClass.attr, 
        & dev_attr_iad_bFunctionProtocol.attr,      (struct attribute *)((void *)0)};
static mode_t intf_assoc_attrs_are_visible(struct kobject *kobj , struct attribute *a ,
                                           int n ) 
{ struct usb_interface *intf ;
  struct device  const  *__mptr ;
  struct kobject  const  *__mptr___0 ;

  {
  {
  __mptr___0 = (struct kobject  const  *)kobj;
  __mptr = (struct device  const  *)((struct device *)((char *)__mptr___0 - (unsigned int )(& ((struct device *)0)->kobj)));
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  }
  if ((unsigned long )intf->intf_assoc == (unsigned long )((void *)0)) {
    return ((unsigned short)0);
  }
  return (a->mode);
}
}
static struct attribute_group intf_assoc_attr_grp  =    {(char const   *)0, & intf_assoc_attrs_are_visible, intf_assoc_attrs};
struct attribute_group *usb_interface_groups[3]  = {      & intf_attr_grp,      & intf_assoc_attr_grp,      (struct attribute_group *)((void *)0)};
int usb_create_sysfs_intf_files(struct usb_interface *intf ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  struct usb_host_interface *alt ;
  int retval ;

  {
  {
  __mptr = (struct device  const  *)intf->dev.parent;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  alt = intf->cur_altsetting;
  }
  if (intf->sysfs_files_created) {
    return (0);
  } else {
    if (intf->unregistering) {
      return (0);
    }
  }
  if ((unsigned long )alt->string == (unsigned long )((void *)0)) {
    if (! (udev->quirks & 8U)) {
      {
      alt->string = usb_cache_string(udev, (int )alt->desc.iInterface);
      }
    }
  }
  if (alt->string) {
    {
    retval = device_create_file(& intf->dev, & dev_attr_interface);
    }
  }
  {
  intf->sysfs_files_created = 1U;
  }
  return (0);
}
}
void usb_remove_sysfs_intf_files(struct usb_interface *intf ) 
{ 

  {
  if (! intf->sysfs_files_created) {
    return;
  }
  {
  device_remove_file(& intf->dev, & dev_attr_interface);
  intf->sysfs_files_created = 0U;
  }
  return;
}
}
static unsigned long __force_order___15  ;
__inline static unsigned long native_read_cr0___15(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___15));
  }
  return (val);
}
}
__inline static void native_write_cr0___15(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___15));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___15(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___15));
  }
  return (val);
}
}
__inline static void native_write_cr2___15(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___15));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___15(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___15));
  }
  return (val);
}
}
__inline static void native_write_cr3___15(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___15));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___15(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___15));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___15(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___15): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___15(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___15));
  }
  return;
}
}
__inline static void load_cr3___15(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___15((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___15(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___15();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___15((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___15(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___15();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___15((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___15(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___6 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___15(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___15(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___15(u64 ns ) ;
static union ktime  const  ktime_zero___15  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___15(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___15.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___15(struct hrtimer *timer , ktime_t time ,
                                                       unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___15((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___19  ;
static void urb_destroy(struct kref *kref ) 
{ struct urb *urb ;
  struct kref  const  *__mptr ;

  {
  {
  __mptr = (struct kref  const  *)kref;
  urb = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->kref));
  }
  if (urb->transfer_flags & 256U) {
    {
    kfree((void const   *)urb->transfer_buffer);
    }
  }
  {
  kfree((void const   *)urb);
  }
  return;
}
}
void usb_init_urb(struct urb *urb ) 
{ 

  {
  if (urb) {
    {
    __constant_c_and_count_memset((void *)urb, 0UL, (unsigned int )sizeof(*urb));
    kref_init(& urb->kref);
    INIT_LIST_HEAD(& urb->anchor_list);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_init_urb[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'i',      (char const   )'t', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_init_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_init_urb), __kstrtab_usb_init_urb};
struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) 
{ struct urb *urb ;
  void *tmp ;

  {
  {
  tmp = kmalloc((unsigned int )(sizeof(struct urb ) + (unsigned long )iso_packets * sizeof(struct usb_iso_packet_descriptor )),
                mem_flags);
  urb = (struct urb *)tmp;
  }
  if (! urb) {
    {
    printk("<3>alloc_urb: kmalloc failed\n");
    }
    return ((struct urb *)((void *)0));
  }
  {
  usb_init_urb(urb);
  }
  return (urb);
}
}
static char const   __kstrtab_usb_alloc_urb[14]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'o', 
        (char const   )'c',      (char const   )'_',      (char const   )'u',      (char const   )'r', 
        (char const   )'b',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_alloc_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_alloc_urb), __kstrtab_usb_alloc_urb};
void usb_free_urb(struct urb *urb ) 
{ 

  {
  if (urb) {
    {
    kref_put(& urb->kref, & urb_destroy);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_free_urb[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'f',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_free_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_free_urb), __kstrtab_usb_free_urb};
struct urb *usb_get_urb(struct urb *urb ) 
{ 

  {
  if (urb) {
    {
    kref_get(& urb->kref);
    }
  }
  return (urb);
}
}
static char const   __kstrtab_usb_get_urb[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'u',      (char const   )'r',      (char const   )'b',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_urb), __kstrtab_usb_get_urb};
void usb_anchor_urb(struct urb *urb , struct usb_anchor *anchor ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  long tmp ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_657_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& anchor->lock);
    }
    goto while_657_break;
  }
  while_657_break: /* CIL Label */ ;
  }
  {
  usb_get_urb(urb);
  list_add_tail(& urb->anchor_list, & anchor->urb_list);
  urb->anchor = anchor;
  tmp = __builtin_expect((long )(! (! anchor->poisoned)), 0L);
  }
  if (tmp) {
    {
    atomic_inc(& urb->reject);
    }
  }
  {
  while (1) {
    while_658_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& anchor->lock, flags);
    }
    goto while_658_break;
  }
  while_658_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_anchor_urb[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'n',      (char const   )'c',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'_',      (char const   )'u', 
        (char const   )'r',      (char const   )'b',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_anchor_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_anchor_urb), __kstrtab_usb_anchor_urb};
void usb_unanchor_urb(struct urb *urb ) 
{ unsigned long flags ;
  struct usb_anchor *anchor ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  long tmp ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp___0 ;

  {
  if (! urb) {
    return;
  }
  {
  anchor = urb->anchor;
  }
  if (! anchor) {
    return;
  }
  {
  while (1) {
    while_659_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& anchor->lock);
    }
    goto while_659_break;
  }
  while_659_break: /* CIL Label */ ;
  }
  {
  tmp = __builtin_expect((long )(! (! ((unsigned long )anchor != (unsigned long )urb->anchor))),
                         0L);
  }
  if (tmp) {
    {
    while (1) {
      while_660_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& anchor->lock, flags);
      }
      goto while_660_break;
    }
    while_660_break: /* CIL Label */ ;
    }
    return;
  }
  {
  urb->anchor = (struct usb_anchor *)((void *)0);
  list_del(& urb->anchor_list);
  }
  {
  while (1) {
    while_661_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& anchor->lock, flags);
    }
    goto while_661_break;
  }
  while_661_break: /* CIL Label */ ;
  }
  {
  usb_free_urb(urb);
  tmp___0 = list_empty((struct list_head  const  *)(& anchor->urb_list));
  }
  if (tmp___0) {
    {
    __wake_up(& anchor->wait, 3U, 1, (void *)0);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_unanchor_urb[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'a',      (char const   )'n', 
        (char const   )'c',      (char const   )'h',      (char const   )'o',      (char const   )'r', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_unanchor_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_unanchor_urb), __kstrtab_usb_unanchor_urb};
int usb_submit_urb(struct urb *urb , gfp_t mem_flags ) 
{ int xfertype ;
  int max ;
  struct usb_device *dev ;
  struct usb_host_endpoint *ep ;
  int is_out ;
  struct usb_host_endpoint **tmp ;
  struct usb_ctrlrequest *setup ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int n ;
  int len ;
  int mult ;
  int _min1 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int _min2 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;

  {
  if (! urb) {
    return (-22);
  } else {
    if (urb->hcpriv) {
      return (-22);
    } else {
      if (! urb->complete) {
        return (-22);
      }
    }
  }
  {
  dev = urb->dev;
  }
  if (! dev) {
    return (-19);
  } else {
    if ((unsigned int )dev->state < 4U) {
      return (-19);
    }
  }
  if (urb->pipe & 128U) {
    {
    tmp = dev->ep_in;
    }
  } else {
    {
    tmp = dev->ep_out;
    }
  }
  {
  ep = *(tmp + ((urb->pipe >> 15) & 15U));
  }
  if (! ep) {
    return (-2);
  }
  {
  urb->ep = ep;
  urb->status = -115;
  urb->actual_length = 0U;
  xfertype = usb_endpoint_type((struct usb_endpoint_descriptor  const  *)(& ep->desc));
  }
  if (xfertype == 0) {
    {
    setup = (struct usb_ctrlrequest *)urb->setup_packet;
    }
    if (! setup) {
      return (-8);
    }
    if (! ((int )setup->bRequestType & 128)) {
      {
      tmp___0 = 1;
      }
    } else {
      if (! setup->wLength) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    }
    {
    is_out = tmp___0;
    }
  } else {
    {
    is_out = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)(& ep->desc));
    }
  }
  if (is_out) {
    {
    tmp___1 = 0;
    }
  } else {
    {
    tmp___1 = 512;
    }
  }
  {
  urb->transfer_flags = (urb->transfer_flags & 4294966783U) | (unsigned int )tmp___1;
  }
  if (xfertype != 0) {
    if ((unsigned int )dev->state < 7U) {
      return (-19);
    }
  }
  {
  max = (int )ep->desc.wMaxPacketSize;
  }
  if (max <= 0) {
    return (-90);
  }
  if (xfertype == 1) {
    if ((unsigned int )dev->speed == 3U) {
      {
      mult = 1 + ((max >> 11) & 3);
      max &= 2047;
      max *= mult;
      }
    }
    if (urb->number_of_packets <= 0) {
      return (-22);
    }
    {
    n = 0;
    }
    {
    while (1) {
      while_662_continue: /* CIL Label */ ;
      if (! (n < urb->number_of_packets)) {
        goto while_662_break;
      }
      {
      len = (int )urb->iso_frame_desc[n].length;
      }
      if (len < 0) {
        return (-90);
      } else {
        if (len > max) {
          return (-90);
        }
      }
      {
      urb->iso_frame_desc[n].status = -18;
      urb->iso_frame_desc[n].actual_length = 0U;
      n ++;
      }
    }
    while_662_break: /* CIL Label */ ;
    }
  }
  if (urb->transfer_buffer_length > (u32 )((int )(4294967295U >> 1))) {
    return (-90);
  }
  if (xfertype == 1) {
    goto switch_663_1;
  } else {
    if (xfertype == 3) {
      goto switch_663_1;
    } else {
      if (0) {
        switch_663_1: /* CIL Label */ 
        switch_663_3: /* CIL Label */ 
        if (urb->interval <= 0) {
          return (-22);
        }
        if ((int )dev->speed == 3) {
          goto switch_664_3;
        } else {
          if ((int )dev->speed == 2) {
            goto switch_664_2;
          } else {
            if ((int )dev->speed == 1) {
              goto switch_664_2;
            } else {
              {
              goto switch_664_default;
              if (0) {
                switch_664_3: /* CIL Label */ 
                if (urb->interval > 8192) {
                  {
                  urb->interval = 8192;
                  }
                }
                {
                max = 8192;
                }
                goto switch_664_break;
                switch_664_2: /* CIL Label */ 
                switch_664_1: /* CIL Label */ 
                if (xfertype == 3) {
                  if (urb->interval > 255) {
                    return (-22);
                  }
                  {
                  max = 128;
                  }
                } else {
                  if (urb->interval > 1024) {
                    {
                    urb->interval = 1024;
                    }
                  }
                  {
                  max = 1024;
                  }
                }
                goto switch_664_break;
                switch_664_default: /* CIL Label */ 
                {

                }
                return (-22);
              } else {
                switch_664_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
        {
        _min1 = max;
        }
        if (sizeof(urb->interval) <= 4UL) {
          {
          tmp___143 = __ilog2_u32((unsigned int )urb->interval);
          tmp___145 = tmp___143;
          }
        } else {
          {
          tmp___144 = __ilog2_u64((unsigned long long )urb->interval);
          tmp___145 = tmp___144;
          }
        }
        {
        _min2 = 1 << tmp___145;
        }
        if (_min1 < _min2) {
          {
          tmp___146 = _min1;
          }
        } else {
          {
          tmp___146 = _min2;
          }
        }
        {
        urb->interval = tmp___146;
        }
      } else {
        switch_663_break: /* CIL Label */ ;
      }
    }
  }
  {
  tmp___147 = usb_hcd_submit_urb(urb, mem_flags);
  }
  return (tmp___147);
}
}
static char const   __kstrtab_usb_submit_urb[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'u',      (char const   )'b',      (char const   )'m', 
        (char const   )'i',      (char const   )'t',      (char const   )'_',      (char const   )'u', 
        (char const   )'r',      (char const   )'b',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_submit_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_submit_urb), __kstrtab_usb_submit_urb};
int usb_unlink_urb(struct urb *urb ) 
{ int tmp ;

  {
  if (! urb) {
    return (-22);
  }
  if (! urb->dev) {
    return (-19);
  }
  if (! urb->ep) {
    return (-43);
  }
  {
  tmp = usb_hcd_unlink_urb(urb, -104);
  }
  return (tmp);
}
}
static char const   __kstrtab_usb_unlink_urb[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'k',      (char const   )'_',      (char const   )'u', 
        (char const   )'r',      (char const   )'b',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_unlink_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_unlink_urb), __kstrtab_usb_unlink_urb};
void usb_kill_urb(struct urb *urb ) 
{ wait_queue_t __wait ;
  struct task_struct *tmp ;

  {
  {
  while (1) {
    while_665_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_665_break;
  }
  while_665_break: /* CIL Label */ ;
  }
  if (urb) {
    if (urb->dev) {
      if (! urb->ep) {
        return;
      }
    } else {
      return;
    }
  } else {
    return;
  }
  {
  atomic_inc(& urb->reject);
  usb_hcd_unlink_urb(urb, -2);
  }
  {
  while (1) {
    while_666_continue: /* CIL Label */ ;
    if (urb->use_count.counter == (int volatile   )0) {
      goto while_666_break;
    }
    {
    while (1) {
      while_667_continue: /* CIL Label */ ;
      {
      tmp = get_current();
      __wait.flags = 0U;
      __wait.private = (void *)tmp;
      __wait.func = & autoremove_wake_function;
      __wait.task_list.next = & __wait.task_list;
      __wait.task_list.prev = & __wait.task_list;
      }
      {
      while (1) {
        while_668_continue: /* CIL Label */ ;
        {
        prepare_to_wait(& usb_kill_urb_queue, & __wait, 2);
        }
        if (urb->use_count.counter == (int volatile   )0) {
          goto while_668_break;
        }
        {
        schedule();
        }
      }
      while_668_break: /* CIL Label */ ;
      }
      {
      finish_wait(& usb_kill_urb_queue, & __wait);
      }
      goto while_667_break;
    }
    while_667_break: /* CIL Label */ ;
    }
    goto while_666_break;
  }
  while_666_break: /* CIL Label */ ;
  }
  {
  atomic_dec(& urb->reject);
  }
  return;
}
}
static char const   __kstrtab_usb_kill_urb[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'k',      (char const   )'i',      (char const   )'l',      (char const   )'l', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_kill_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_kill_urb), __kstrtab_usb_kill_urb};
void usb_poison_urb(struct urb *urb ) 
{ wait_queue_t __wait ;
  struct task_struct *tmp ;

  {
  {
  while (1) {
    while_669_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_669_break;
  }
  while_669_break: /* CIL Label */ ;
  }
  if (urb) {
    if (urb->dev) {
      if (! urb->ep) {
        return;
      }
    } else {
      return;
    }
  } else {
    return;
  }
  {
  atomic_inc(& urb->reject);
  usb_hcd_unlink_urb(urb, -2);
  }
  {
  while (1) {
    while_670_continue: /* CIL Label */ ;
    if (urb->use_count.counter == (int volatile   )0) {
      goto while_670_break;
    }
    {
    while (1) {
      while_671_continue: /* CIL Label */ ;
      {
      tmp = get_current();
      __wait.flags = 0U;
      __wait.private = (void *)tmp;
      __wait.func = & autoremove_wake_function;
      __wait.task_list.next = & __wait.task_list;
      __wait.task_list.prev = & __wait.task_list;
      }
      {
      while (1) {
        while_672_continue: /* CIL Label */ ;
        {
        prepare_to_wait(& usb_kill_urb_queue, & __wait, 2);
        }
        if (urb->use_count.counter == (int volatile   )0) {
          goto while_672_break;
        }
        {
        schedule();
        }
      }
      while_672_break: /* CIL Label */ ;
      }
      {
      finish_wait(& usb_kill_urb_queue, & __wait);
      }
      goto while_671_break;
    }
    while_671_break: /* CIL Label */ ;
    }
    goto while_670_break;
  }
  while_670_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_poison_urb[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'p',      (char const   )'o',      (char const   )'i',      (char const   )'s', 
        (char const   )'o',      (char const   )'n',      (char const   )'_',      (char const   )'u', 
        (char const   )'r',      (char const   )'b',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_poison_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_poison_urb), __kstrtab_usb_poison_urb};
void usb_unpoison_urb(struct urb *urb ) 
{ 

  {
  if (! urb) {
    return;
  }
  {
  atomic_dec(& urb->reject);
  }
  return;
}
}
static char const   __kstrtab_usb_unpoison_urb[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'p',      (char const   )'o', 
        (char const   )'i',      (char const   )'s',      (char const   )'o',      (char const   )'n', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_unpoison_urb  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_unpoison_urb), __kstrtab_usb_unpoison_urb};
void usb_kill_anchored_urbs(struct usb_anchor *anchor ) 
{ struct urb *victim ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  {
  _spin_lock_irq(& anchor->lock);
  }
  {
  while (1) {
    while_673_continue: /* CIL Label */ ;
    {
    tmp = list_empty((struct list_head  const  *)(& anchor->urb_list));
    }
    if (tmp) {
      goto while_673_break;
    }
    {
    __mptr = (struct list_head  const  *)anchor->urb_list.prev;
    victim = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->anchor_list));
    usb_get_urb(victim);
    }
    {
    while (1) {
      while_674_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& anchor->lock.raw_lock);
      }
      {
      while (1) {
        while_675_continue: /* CIL Label */ ;
        {
        while (1) {
          while_676_continue: /* CIL Label */ ;
          goto while_676_break;
        }
        while_676_break: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_675_break;
      }
      while_675_break: /* CIL Label */ ;
      }
      goto while_674_break;
    }
    while_674_break: /* CIL Label */ ;
    }
    {
    usb_kill_urb(victim);
    usb_free_urb(victim);
    _spin_lock_irq(& anchor->lock);
    }
  }
  while_673_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_677_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& anchor->lock.raw_lock);
    }
    {
    while (1) {
      while_678_continue: /* CIL Label */ ;
      {
      while (1) {
        while_679_continue: /* CIL Label */ ;
        goto while_679_break;
      }
      while_679_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_678_break;
    }
    while_678_break: /* CIL Label */ ;
    }
    goto while_677_break;
  }
  while_677_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_kill_anchored_urbs[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'k',      (char const   )'i',      (char const   )'l',      (char const   )'l', 
        (char const   )'_',      (char const   )'a',      (char const   )'n',      (char const   )'c', 
        (char const   )'h',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'d',      (char const   )'_',      (char const   )'u',      (char const   )'r', 
        (char const   )'b',      (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_kill_anchored_urbs  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_kill_anchored_urbs), __kstrtab_usb_kill_anchored_urbs};
void usb_poison_anchored_urbs(struct usb_anchor *anchor ) 
{ struct urb *victim ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  {
  _spin_lock_irq(& anchor->lock);
  anchor->poisoned = 1U;
  }
  {
  while (1) {
    while_680_continue: /* CIL Label */ ;
    {
    tmp = list_empty((struct list_head  const  *)(& anchor->urb_list));
    }
    if (tmp) {
      goto while_680_break;
    }
    {
    __mptr = (struct list_head  const  *)anchor->urb_list.prev;
    victim = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->anchor_list));
    usb_get_urb(victim);
    }
    {
    while (1) {
      while_681_continue: /* CIL Label */ ;
      {
      __raw_spin_unlock(& anchor->lock.raw_lock);
      }
      {
      while (1) {
        while_682_continue: /* CIL Label */ ;
        {
        while (1) {
          while_683_continue: /* CIL Label */ ;
          goto while_683_break;
        }
        while_683_break: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_682_break;
      }
      while_682_break: /* CIL Label */ ;
      }
      goto while_681_break;
    }
    while_681_break: /* CIL Label */ ;
    }
    {
    usb_poison_urb(victim);
    usb_free_urb(victim);
    _spin_lock_irq(& anchor->lock);
    }
  }
  while_680_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_684_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& anchor->lock.raw_lock);
    }
    {
    while (1) {
      while_685_continue: /* CIL Label */ ;
      {
      while (1) {
        while_686_continue: /* CIL Label */ ;
        goto while_686_break;
      }
      while_686_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_685_break;
    }
    while_685_break: /* CIL Label */ ;
    }
    goto while_684_break;
  }
  while_684_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_poison_anchored_urbs[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'p',      (char const   )'o',      (char const   )'i',      (char const   )'s', 
        (char const   )'o',      (char const   )'n',      (char const   )'_',      (char const   )'a', 
        (char const   )'n',      (char const   )'c',      (char const   )'h',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'r',      (char const   )'b',      (char const   )'s', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_poison_anchored_urbs  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_poison_anchored_urbs), __kstrtab_usb_poison_anchored_urbs};
void usb_unpoison_anchored_urbs(struct usb_anchor *anchor ) 
{ unsigned long flags ;
  struct urb *lazarus ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_687_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& anchor->lock);
    }
    goto while_687_break;
  }
  while_687_break: /* CIL Label */ ;
  }
  {
  __mptr = (struct list_head  const  *)anchor->urb_list.next;
  lazarus = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->anchor_list));
  }
  {
  while (1) {
    while_688_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)lazarus->anchor_list.next);
    }
    if (! ((unsigned long )(& lazarus->anchor_list) != (unsigned long )(& anchor->urb_list))) {
      goto while_688_break;
    }
    {
    usb_unpoison_urb(lazarus);
    __mptr___0 = (struct list_head  const  *)lazarus->anchor_list.next;
    lazarus = (struct urb *)((char *)__mptr___0 - (unsigned int )(& ((struct urb *)0)->anchor_list));
    }
  }
  while_688_break: /* CIL Label */ ;
  }
  {
  anchor->poisoned = 0U;
  }
  {
  while (1) {
    while_689_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& anchor->lock, flags);
    }
    goto while_689_break;
  }
  while_689_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_unpoison_anchored_urbs[27]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'p',      (char const   )'o', 
        (char const   )'i',      (char const   )'s',      (char const   )'o',      (char const   )'n', 
        (char const   )'_',      (char const   )'a',      (char const   )'n',      (char const   )'c', 
        (char const   )'h',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'d',      (char const   )'_',      (char const   )'u',      (char const   )'r', 
        (char const   )'b',      (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_unpoison_anchored_urbs  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_unpoison_anchored_urbs), __kstrtab_usb_unpoison_anchored_urbs};
void usb_unlink_anchored_urbs(struct usb_anchor *anchor ) 
{ struct urb *victim ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;

  {
  {
  while (1) {
    while_690_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& anchor->lock);
    }
    goto while_690_break;
  }
  while_690_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_691_continue: /* CIL Label */ ;
    {
    tmp = list_empty((struct list_head  const  *)(& anchor->urb_list));
    }
    if (tmp) {
      goto while_691_break;
    }
    {
    __mptr = (struct list_head  const  *)anchor->urb_list.prev;
    victim = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->anchor_list));
    usb_get_urb(victim);
    }
    {
    while (1) {
      while_692_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& anchor->lock, flags);
      }
      goto while_692_break;
    }
    while_692_break: /* CIL Label */ ;
    }
    {
    usb_unlink_urb(victim);
    usb_free_urb(victim);
    }
    {
    while (1) {
      while_693_continue: /* CIL Label */ ;
      {
      flags = _spin_lock_irqsave(& anchor->lock);
      }
      goto while_693_break;
    }
    while_693_break: /* CIL Label */ ;
    }
  }
  while_691_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_694_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& anchor->lock, flags);
    }
    goto while_694_break;
  }
  while_694_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_unlink_anchored_urbs[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'u',      (char const   )'n',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'k',      (char const   )'_',      (char const   )'a', 
        (char const   )'n',      (char const   )'c',      (char const   )'h',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'r',      (char const   )'b',      (char const   )'s', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_unlink_anchored_urbs  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_unlink_anchored_urbs), __kstrtab_usb_unlink_anchored_urbs};
int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor ,
                                  unsigned int timeout ) 
{ long __ret ;
  unsigned long tmp ;
  wait_queue_t __wait ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = msecs_to_jiffies(timeout);
  __ret = (long )tmp;
  tmp___2 = list_empty((struct list_head  const  *)(& anchor->urb_list));
  }
  if (! tmp___2) {
    {
    while (1) {
      while_695_continue: /* CIL Label */ ;
      {
      tmp___0 = get_current();
      __wait.flags = 0U;
      __wait.private = (void *)tmp___0;
      __wait.func = & autoremove_wake_function;
      __wait.task_list.next = & __wait.task_list;
      __wait.task_list.prev = & __wait.task_list;
      }
      {
      while (1) {
        while_696_continue: /* CIL Label */ ;
        {
        prepare_to_wait(& anchor->wait, & __wait, 2);
        tmp___1 = list_empty((struct list_head  const  *)(& anchor->urb_list));
        }
        if (tmp___1) {
          goto while_696_break;
        }
        {
        __ret = schedule_timeout(__ret);
        }
        if (! __ret) {
          goto while_696_break;
        }
      }
      while_696_break: /* CIL Label */ ;
      }
      {
      finish_wait(& anchor->wait, & __wait);
      }
      goto while_695_break;
    }
    while_695_break: /* CIL Label */ ;
    }
  }
  return ((int )__ret);
}
}
static char const   __kstrtab_usb_wait_anchor_empty_timeout[30]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'w',      (char const   )'a',      (char const   )'i',      (char const   )'t', 
        (char const   )'_',      (char const   )'a',      (char const   )'n',      (char const   )'c', 
        (char const   )'h',      (char const   )'o',      (char const   )'r',      (char const   )'_', 
        (char const   )'e',      (char const   )'m',      (char const   )'p',      (char const   )'t', 
        (char const   )'y',      (char const   )'_',      (char const   )'t',      (char const   )'i', 
        (char const   )'m',      (char const   )'e',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_wait_anchor_empty_timeout  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_wait_anchor_empty_timeout), __kstrtab_usb_wait_anchor_empty_timeout};
struct urb *usb_get_from_anchor(struct usb_anchor *anchor ) 
{ struct urb *victim ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp ;

  {
  {
  while (1) {
    while_697_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& anchor->lock);
    }
    goto while_697_break;
  }
  while_697_break: /* CIL Label */ ;
  }
  {
  tmp = list_empty((struct list_head  const  *)(& anchor->urb_list));
  }
  if (tmp) {
    {
    while (1) {
      while_698_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& anchor->lock, flags);
      }
      goto while_698_break;
    }
    while_698_break: /* CIL Label */ ;
    }
    {
    victim = (struct urb *)((void *)0);
    }
  } else {
    {
    __mptr = (struct list_head  const  *)anchor->urb_list.next;
    victim = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->anchor_list));
    usb_get_urb(victim);
    }
    {
    while (1) {
      while_699_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& anchor->lock, flags);
      }
      goto while_699_break;
    }
    while_699_break: /* CIL Label */ ;
    }
    {
    usb_unanchor_urb(victim);
    }
  }
  return (victim);
}
}
static char const   __kstrtab_usb_get_from_anchor[20]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'f',      (char const   )'r',      (char const   )'o',      (char const   )'m', 
        (char const   )'_',      (char const   )'a',      (char const   )'n',      (char const   )'c', 
        (char const   )'h',      (char const   )'o',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_from_anchor  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_from_anchor), __kstrtab_usb_get_from_anchor};
void usb_scuttle_anchored_urbs(struct usb_anchor *anchor ) 
{ struct urb *victim ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;

  {
  {
  while (1) {
    while_700_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& anchor->lock);
    }
    goto while_700_break;
  }
  while_700_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_701_continue: /* CIL Label */ ;
    {
    tmp = list_empty((struct list_head  const  *)(& anchor->urb_list));
    }
    if (tmp) {
      goto while_701_break;
    }
    {
    __mptr = (struct list_head  const  *)anchor->urb_list.prev;
    victim = (struct urb *)((char *)__mptr - (unsigned int )(& ((struct urb *)0)->anchor_list));
    usb_get_urb(victim);
    }
    {
    while (1) {
      while_702_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& anchor->lock, flags);
      }
      goto while_702_break;
    }
    while_702_break: /* CIL Label */ ;
    }
    {
    usb_unanchor_urb(victim);
    usb_free_urb(victim);
    }
    {
    while (1) {
      while_703_continue: /* CIL Label */ ;
      {
      flags = _spin_lock_irqsave(& anchor->lock);
      }
      goto while_703_break;
    }
    while_703_break: /* CIL Label */ ;
    }
  }
  while_701_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_704_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& anchor->lock, flags);
    }
    goto while_704_break;
  }
  while_704_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_usb_scuttle_anchored_urbs[26]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'s',      (char const   )'c',      (char const   )'u',      (char const   )'t', 
        (char const   )'t',      (char const   )'l',      (char const   )'e',      (char const   )'_', 
        (char const   )'a',      (char const   )'n',      (char const   )'c',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )'_',      (char const   )'u',      (char const   )'r',      (char const   )'b', 
        (char const   )'s',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_scuttle_anchored_urbs  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_scuttle_anchored_urbs), __kstrtab_usb_scuttle_anchored_urbs};
int usb_anchor_empty(struct usb_anchor *anchor ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)(& anchor->urb_list));
  }
  return (tmp);
}
}
static char const   __kstrtab_usb_anchor_empty[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'n',      (char const   )'c',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'_',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )'y', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_anchor_empty  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_anchor_empty), __kstrtab_usb_anchor_empty};
static unsigned long __force_order___16  ;
__inline static unsigned long native_read_cr0___16(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___16));
  }
  return (val);
}
}
__inline static void native_write_cr0___16(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___16));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___16(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___16));
  }
  return (val);
}
}
__inline static void native_write_cr2___16(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___16));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___16(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___16));
  }
  return (val);
}
}
__inline static void native_write_cr3___16(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___16));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___16(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___16));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___16(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___16): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___16(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___16));
  }
  return;
}
}
__inline static void load_cr3___16(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___16((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___16(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___16();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___16((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___16(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___16();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___16((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___16(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___7 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___16(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___16(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___16(u64 ns ) ;
static union ktime  const  ktime_zero___16  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___16(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___16.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void hrtimer_set_expires_range_ns___16(struct hrtimer *timer , ktime_t time ,
                                                       unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___16((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
static struct lock_class_key __key___20  ;
struct workqueue_struct *ksuspend_usb_wq  ;
char const   *usbcore_name  =    "usbcore";
static int nousb  ;
static int usb_autosuspend_delay  =    2;
__inline static int *__check_autosuspend(void) 
{ 

  {
  return (& usb_autosuspend_delay);
}
}
static int __param_perm_check_autosuspend  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
static char const   __param_str_autosuspend[23]  = 
  {      (char const   )'S',      (char const   )'o',      (char const   )'m',      (char const   )'e', 
        (char const   )'M',      (char const   )'o',      (char const   )'d',      (char const   )'u', 
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'a', 
        (char const   )'u',      (char const   )'t',      (char const   )'o',      (char const   )'s', 
        (char const   )'u',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000'};
static struct kernel_param  const  __param_autosuspend  __attribute__((__unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_autosuspend, 420U, & param_set_int, & param_get_int, {(void *)(& usb_autosuspend_delay)}};
struct usb_interface *usb_ifnum_to_if(struct usb_device  const  *dev ,
                                      unsigned int ifnum ) 
{ struct usb_host_config *config ;
  int i ;

  {
  {
  config = (struct usb_host_config *)dev->actconfig;
  }
  if (! config) {
    return ((struct usb_interface *)((void *)0));
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_705_continue: /* CIL Label */ ;
    if (! (i < (int )config->desc.bNumInterfaces)) {
      goto while_705_break;
    }
    if ((unsigned int )((config->interface[i])->altsetting + 0)->desc.bInterfaceNumber == ifnum) {
      return (config->interface[i]);
    }
    {
    i ++;
    }
  }
  while_705_break: /* CIL Label */ ;
  }
  return ((struct usb_interface *)((void *)0));
}
}
static char const   __kstrtab_usb_ifnum_to_if[16]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'i',      (char const   )'f',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )'_',      (char const   )'t',      (char const   )'o', 
        (char const   )'_',      (char const   )'i',      (char const   )'f',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_ifnum_to_if  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_ifnum_to_if), __kstrtab_usb_ifnum_to_if};
struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface  const  *intf ,
                                                    unsigned int altnum ) 
{ int i ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_706_continue: /* CIL Label */ ;
    if (! ((unsigned int const   )i < intf->num_altsetting)) {
      goto while_706_break;
    }
    if ((unsigned int )(intf->altsetting + i)->desc.bAlternateSetting == altnum) {
      return (intf->altsetting + i);
    }
    {
    i ++;
    }
  }
  while_706_break: /* CIL Label */ ;
  }
  return ((struct usb_host_interface *)((void *)0));
}
}
static char const   __kstrtab_usb_altnum_to_altsetting[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'a',      (char const   )'l',      (char const   )'t',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'_',      (char const   )'t', 
        (char const   )'o',      (char const   )'_',      (char const   )'a',      (char const   )'l', 
        (char const   )'t',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )'t',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_altnum_to_altsetting  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_altnum_to_altsetting), __kstrtab_usb_altnum_to_altsetting};
static int __find_interface(struct device *dev ,
                            void *data ) 
{ struct find_interface_arg *arg ;
  struct usb_interface *intf ;
  int tmp ;
  struct device  const  *__mptr ;

  {
  {
  arg = (struct find_interface_arg *)data;
  tmp = is_usb_device((struct device  const  *)dev);
  }
  if (tmp) {
    return (0);
  }
  {
  __mptr = (struct device  const  *)dev;
  intf = (struct usb_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_interface *)0)->dev));
  }
  if (intf->minor != -1) {
    if (intf->minor == arg->minor) {
      {
      arg->interface = intf;
      }
      return (1);
    }
  }
  return (0);
}
}
struct usb_interface *usb_find_interface(struct usb_driver *drv , int minor ) 
{ struct find_interface_arg argb ;
  int retval ;

  {
  {
  argb.minor = minor;
  argb.interface = (struct usb_interface *)((void *)0);
  retval = driver_for_each_device(& drv->drvwrap.driver, (struct device *)((void *)0),
                                  (void *)(& argb), & __find_interface);
  }
  return (argb.interface);
}
}
static char const   __kstrtab_usb_find_interface[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'f',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'_',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'f',      (char const   )'a', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_find_interface  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_find_interface), __kstrtab_usb_find_interface};
static void usb_release_dev(struct device *dev ) 
{ struct usb_device *udev ;
  struct device  const  *__mptr ;
  struct usb_hcd *tmp ;

  {
  {
  __mptr = (struct device  const  *)dev;
  udev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  usb_destroy_configuration(udev);
  tmp = bus_to_hcd(udev->bus);
  usb_put_hcd(tmp);
  kfree((void const   *)udev->product);
  kfree((void const   *)udev->manufacturer);
  kfree((void const   *)udev->serial);
  kfree((void const   *)udev);
  }
  return;
}
}
static int usb_dev_uevent(struct device *dev , struct kobj_uevent_env *env ) 
{ struct usb_device *usb_dev ;
  struct device  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
  {
  __mptr = (struct device  const  *)dev;
  usb_dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
  tmp = add_uevent_var(env, "BUSNUM=%03d", (usb_dev->bus)->busnum);
  }
  if (tmp) {
    return (-12);
  }
  {
  tmp___0 = add_uevent_var(env, "DEVNUM=%03d", usb_dev->devnum);
  }
  if (tmp___0) {
    return (-12);
  }
  return (0);
}
}
static int ksuspend_usb_init(void) 
{ 

  {
  {
  ksuspend_usb_wq = __create_workqueue_key("ksuspend_usbd", 1, 1, 0, (struct lock_class_key *)((void *)0),
                                           (char const   *)((void *)0));
  }
  if (! ksuspend_usb_wq) {
    return (-12);
  }
  return (0);
}
}
static void ksuspend_usb_cleanup(void) 
{ 

  {
  {
  destroy_workqueue(ksuspend_usb_wq);
  }
  return;
}
}
static int usb_dev_prepare(struct device *dev ) 
{ 

  {
  return (0);
}
}
static void usb_dev_complete(struct device *dev ) 
{ struct pm_message __constr_expr_0 ;

  {
  {
  __constr_expr_0.event = 16;
  usb_resume(dev, __constr_expr_0);
  }
  return;
}
}
static int usb_dev_suspend(struct device *dev ) 
{ struct pm_message __constr_expr_0 ;
  int tmp ;

  {
  {
  __constr_expr_0.event = 2;
  tmp = usb_suspend(dev, __constr_expr_0);
  }
  return (tmp);
}
}
static int usb_dev_resume(struct device *dev ) 
{ struct pm_message __constr_expr_0 ;
  int tmp ;

  {
  {
  __constr_expr_0.event = 16;
  tmp = usb_resume(dev, __constr_expr_0);
  }
  return (tmp);
}
}
static int usb_dev_freeze(struct device *dev ) 
{ struct pm_message __constr_expr_0 ;
  int tmp ;

  {
  {
  __constr_expr_0.event = 1;
  tmp = usb_suspend(dev, __constr_expr_0);
  }
  return (tmp);
}
}
static int usb_dev_thaw(struct device *dev ) 
{ struct pm_message __constr_expr_0 ;
  int tmp ;

  {
  {
  __constr_expr_0.event = 32;
  tmp = usb_resume(dev, __constr_expr_0);
  }
  return (tmp);
}
}
static int usb_dev_poweroff(struct device *dev ) 
{ struct pm_message __constr_expr_0 ;
  int tmp ;

  {
  {
  __constr_expr_0.event = 4;
  tmp = usb_suspend(dev, __constr_expr_0);
  }
  return (tmp);
}
}
static int usb_dev_restore(struct device *dev ) 
{ struct pm_message __constr_expr_0 ;
  int tmp ;

  {
  {
  __constr_expr_0.event = 64;
  tmp = usb_resume(dev, __constr_expr_0);
  }
  return (tmp);
}
}
static struct dev_pm_ops usb_device_pm_ops  = 
     {& usb_dev_prepare, & usb_dev_complete, & usb_dev_suspend, & usb_dev_resume, & usb_dev_freeze,
    & usb_dev_thaw, & usb_dev_poweroff, & usb_dev_restore, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0};
struct device_type usb_device_type  =    {"usb_device", (struct attribute_group **)0, & usb_dev_uevent, & usb_release_dev,
    (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
    & usb_device_pm_ops};
static unsigned int usb_bus_is_wusb(struct usb_bus *bus ) 
{ struct usb_hcd *hcd ;
  struct usb_bus  const  *__mptr ;

  {
  {
  __mptr = (struct usb_bus  const  *)bus;
  hcd = (struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->self));
  }
  return (hcd->wireless);
}
}
static struct lock_class_key __key___21  ;
struct usb_device *usb_alloc_dev(struct usb_device *parent , struct usb_bus *bus ,
                                 unsigned int port1 ) 
{ struct usb_device *dev ;
  struct usb_hcd *usb_hcd ;
  struct usb_bus  const  *__mptr ;
  unsigned int root_hub ;
  void *tmp ;
  struct usb_hcd *tmp___0 ;
  struct usb_hcd *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  atomic_long_t __constr_expr_0 ;
  atomic_long_t __constr_expr_1 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
  __mptr = (struct usb_bus  const  *)bus;
  usb_hcd = (struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->self));
  root_hub = 0U;
  tmp = kzalloc((unsigned int )sizeof(*dev), 208U);
  dev = (struct usb_device *)tmp;
  }
  if (! dev) {
    return ((struct usb_device *)((void *)0));
  }
  {
  tmp___0 = bus_to_hcd(bus);
  tmp___1 = usb_get_hcd(tmp___0);
  }
  if (! tmp___1) {
    {
    kfree((void const   *)dev);
    }
    return ((struct usb_device *)((void *)0));
  }
  {
  device_initialize(& dev->dev);
  dev->dev.bus = & usb_bus_type;
  dev->dev.type = & usb_device_type;
  dev->dev.groups = usb_device_groups;
  dev->dev.dma_mask = (bus->controller)->dma_mask;
  tmp___2 = dev_to_node(bus->controller);
  set_dev_node(& dev->dev, tmp___2);
  dev->state = (enum usb_device_state )1;
  dev->urbnum.counter = (int volatile   )0;
  INIT_LIST_HEAD(& dev->ep0.urb_list);
  dev->ep0.desc.bLength = (unsigned char)7;
  dev->ep0.desc.bDescriptorType = (unsigned char)5;
  usb_enable_endpoint(dev, & dev->ep0, (_Bool)0);
  dev->can_submit = 1U;
  tmp___3 = __builtin_expect((long )(! (! (! parent))), 0L);
  }
  if (tmp___3) {
    {
    dev->devpath[0] = (char )'0';
    dev->dev.parent = bus->controller;
    dev_set_name(& dev->dev, "usb%d", bus->busnum);
    root_hub = 1U;
    }
  } else {
    if ((int )parent->devpath[0] == 48) {
      {
      snprintf(dev->devpath, (unsigned int )sizeof(dev->devpath), "%d", port1);
      }
    } else {
      {
      snprintf(dev->devpath, (unsigned int )sizeof(dev->devpath), "%s.%d", parent->devpath,
               port1);
      }
    }
    {
    dev->dev.parent = & parent->dev;
    dev_set_name(& dev->dev, "%d-%s", bus->busnum, dev->devpath);
    }
  }
  {
  dev->portnum = (unsigned char )port1;
  dev->bus = bus;
  dev->parent = parent;
  INIT_LIST_HEAD(& dev->filelist);
  }
  {
  while (1) {
    while_707_continue: /* CIL Label */ ;
    {
    __mutex_init(& dev->pm_mutex, "&dev->pm_mutex", & __key___21);
    }
    goto while_707_break;
  }
  while_707_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_708_continue: /* CIL Label */ ;
    {
    while (1) {
      while_709_continue: /* CIL Label */ ;
      {
      __constr_expr_0.counter = (int volatile   )0;
      dev->autosuspend.work.data = __constr_expr_0;
      INIT_LIST_HEAD(& dev->autosuspend.work.entry);
      }
      {
      while (1) {
        while_710_continue: /* CIL Label */ ;
        {
        dev->autosuspend.work.func = & usb_autosuspend_work;
        }
        goto while_710_break;
      }
      while_710_break: /* CIL Label */ ;
      }
      goto while_709_break;
    }
    while_709_break: /* CIL Label */ ;
    }
    {
    init_timer_key(& dev->autosuspend.timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0));
    }
    goto while_708_break;
  }
  while_708_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_711_continue: /* CIL Label */ ;
    {
    __constr_expr_1.counter = (int volatile   )0;
    dev->autoresume.data = __constr_expr_1;
    INIT_LIST_HEAD(& dev->autoresume.entry);
    }
    {
    while (1) {
      while_712_continue: /* CIL Label */ ;
      {
      dev->autoresume.func = & usb_autoresume_work;
      }
      goto while_712_break;
    }
    while_712_break: /* CIL Label */ ;
    }
    goto while_711_break;
  }
  while_711_break: /* CIL Label */ ;
  }
  {
  dev->autosuspend_delay = usb_autosuspend_delay * 1000;
  dev->connect_time = (unsigned long )jiffies;
  dev->active_duration = (unsigned long )(- jiffies);
  }
  if (root_hub) {
    {
    dev->authorized = 1U;
    }
  } else {
    {
    dev->authorized = usb_hcd->authorized_default;
    tmp___5 = usb_bus_is_wusb(bus);
    }
    if (tmp___5) {
      {
      dev->wusb = 1U;
      }
    } else {
      {
      dev->wusb = 0U;
      }
    }
  }
  return (dev);
}
}
struct usb_device *usb_get_dev(struct usb_device *dev ) 
{ 

  {
  if (dev) {
    {
    get_device(& dev->dev);
    }
  }
  return (dev);
}
}
static char const   __kstrtab_usb_get_dev[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_dev  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_dev), __kstrtab_usb_get_dev};
void usb_put_dev(struct usb_device *dev ) 
{ 

  {
  if (dev) {
    {
    put_device(& dev->dev);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_put_dev[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'p',      (char const   )'u',      (char const   )'t',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_put_dev  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_put_dev), __kstrtab_usb_put_dev};
struct usb_interface *usb_get_intf(struct usb_interface *intf ) 
{ 

  {
  if (intf) {
    {
    get_device(& intf->dev);
    }
  }
  return (intf);
}
}
static char const   __kstrtab_usb_get_intf[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'f', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_intf  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_intf), __kstrtab_usb_get_intf};
void usb_put_intf(struct usb_interface *intf ) 
{ 

  {
  if (intf) {
    {
    put_device(& intf->dev);
    }
  }
  return;
}
}
static char const   __kstrtab_usb_put_intf[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'p',      (char const   )'u',      (char const   )'t',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'f', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_put_intf  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_put_intf), __kstrtab_usb_put_intf};
int usb_lock_device_for_reset(struct usb_device *udev , struct usb_interface  const  *iface ) 
{ unsigned long jiffies_expire ;
  unsigned long __dummy ;
  unsigned long volatile   __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
  jiffies_expire = (unsigned long )(jiffies + (unsigned long volatile   )1000);
  }
  if ((unsigned int )udev->state == 0U) {
    return (-19);
  }
  if ((unsigned int )udev->state == 8U) {
    return (-113);
  }
  if (iface) {
    if ((unsigned int const   )iface->condition == 3U) {
      return (-4);
    } else {
      if ((unsigned int const   )iface->condition == 0U) {
        return (-4);
      }
    }
  }
  {
  while (1) {
    while_713_continue: /* CIL Label */ ;
    {
    tmp = down_trylock(& udev->dev.sem);
    }
    if (! (tmp != 0)) {
      goto while_713_break;
    }
    if ((long )jiffies_expire - (long )jiffies < 0L) {
      return (-16);
    }
    {
    msleep(15U);
    }
    if ((unsigned int )udev->state == 0U) {
      return (-19);
    }
    if ((unsigned int )udev->state == 8U) {
      return (-113);
    }
    if (iface) {
      if ((unsigned int const   )iface->condition == 3U) {
        return (-4);
      } else {
        if ((unsigned int const   )iface->condition == 0U) {
          return (-4);
        }
      }
    }
  }
  while_713_break: /* CIL Label */ ;
  }
  return (0);
}
}
static char const   __kstrtab_usb_lock_device_for_reset[26]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'l',      (char const   )'o',      (char const   )'c',      (char const   )'k', 
        (char const   )'_',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_lock_device_for_reset  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_lock_device_for_reset), __kstrtab_usb_lock_device_for_reset};
static struct usb_device *match_device(struct usb_device *dev ,
                                       u16 vendor_id , u16 product_id ) 
{ struct usb_device *ret_dev ;
  int child ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
  ret_dev = (struct usb_device *)((void *)0);
  }
  if ((int )vendor_id == (int )dev->descriptor.idVendor) {
    if ((int )product_id == (int )dev->descriptor.idProduct) {
      {
      ret_dev = usb_get_dev(dev);
      }
      goto exit;
    }
  }
  {
  child = 0;
  }
  {
  while (1) {
    while_714_continue: /* CIL Label */ ;
    if (! (child < dev->maxchild)) {
      goto while_714_break;
    }
    if (dev->children[child]) {
      {
      down(& (dev->children[child])->dev.sem);
      ret_dev = match_device(dev->children[child], vendor_id, product_id);
      up(& (dev->children[child])->dev.sem);
      }
      if (ret_dev) {
        goto exit;
      }
    }
    {
    child ++;
    }
  }
  while_714_break: /* CIL Label */ ;
  }
  exit: 
  return (ret_dev);
}
}
struct usb_device *usb_find_device(u16 vendor_id , u16 product_id ) 
{ struct list_head *buslist ;
  struct usb_bus *bus ;
  struct usb_device *dev ;
  struct list_head  const  *__mptr ;

  {
  {
  dev = (struct usb_device *)((void *)0);
  mutex_lock(& usb_bus_list_lock);
  buslist = usb_bus_list.next;
  }
  {
  while (1) {
    while_715_continue: /* CIL Label */ ;
    if (! ((unsigned long )buslist != (unsigned long )(& usb_bus_list))) {
      goto while_715_break;
    }
    {
    __mptr = (struct list_head  const  *)buslist;
    bus = (struct usb_bus *)((char *)__mptr - (unsigned int )(& ((struct usb_bus *)0)->bus_list));
    }
    if (! bus->root_hub) {
      goto __Cont;
    }
    {
    down(& (bus->root_hub)->dev.sem);
    dev = match_device(bus->root_hub, vendor_id, product_id);
    up(& (bus->root_hub)->dev.sem);
    }
    if (dev) {
      goto exit;
    }
    __Cont: /* CIL Label */ 
    {
    buslist = buslist->next;
    }
  }
  while_715_break: /* CIL Label */ ;
  }
  exit: 
  {
  mutex_unlock(& usb_bus_list_lock);
  }
  return (dev);
}
}
int usb_get_current_frame_number(struct usb_device *dev ) 
{ int tmp ;

  {
  {
  tmp = usb_hcd_get_frame_number(dev);
  }
  return (tmp);
}
}
static char const   __kstrtab_usb_get_current_frame_number[29]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'g',      (char const   )'e',      (char const   )'t',      (char const   )'_', 
        (char const   )'c',      (char const   )'u',      (char const   )'r',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )'_', 
        (char const   )'f',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )'e',      (char const   )'_',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )'b',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_get_current_frame_number  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_get_current_frame_number), __kstrtab_usb_get_current_frame_number};
int __usb_get_extra_descriptor(char *buffer ,
                               unsigned int size , unsigned char type , void **ptr ) 
{ struct usb_descriptor_header *header ;

  {
  {
  while (1) {
    while_716_continue: /* CIL Label */ ;
    if (! ((unsigned long )size >= sizeof(struct usb_descriptor_header ))) {
      goto while_716_break;
    }
    {
    header = (struct usb_descriptor_header *)buffer;
    }
    if ((int )header->bLength < 2) {
      {
      printk("<3>%s: bogus descriptor, type %d length %d\n", usbcore_name, header->bDescriptorType,
             header->bLength);
      }
      return (-1);
    }
    if ((int )header->bDescriptorType == (int )type) {
      {
      *ptr = (void *)header;
      }
      return (0);
    }
    {
    buffer += (int )header->bLength;
    size -= (unsigned int )header->bLength;
    }
  }
  while_716_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static char const   __kstrtab___usb_get_extra_descriptor[27]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'_',      (char const   )'_',      (char const   )'u',      (char const   )'s', 
        (char const   )'b',      (char const   )'_',      (char const   )'g',      (char const   )'e', 
        (char const   )'t',      (char const   )'_',      (char const   )'e',      (char const   )'x', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'_', 
        (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab___usb_get_extra_descriptor  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& __usb_get_extra_descriptor), __kstrtab___usb_get_extra_descriptor};
void *usb_buffer_alloc(struct usb_device *dev ,
                       size_t size , gfp_t mem_flags , dma_addr_t *dma ) 
{ void *tmp ;

  {
  if (! dev) {
    return ((void *)0);
  } else {
    if (! dev->bus) {
      return ((void *)0);
    }
  }
  {
  tmp = hcd_buffer_alloc(dev->bus, size, mem_flags, dma);
  }
  return (tmp);
}
}
static char const   __kstrtab_usb_buffer_alloc[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'b',      (char const   )'u',      (char const   )'f',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'a', 
        (char const   )'l',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_buffer_alloc  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_buffer_alloc), __kstrtab_usb_buffer_alloc};
void usb_buffer_free(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) 
{ 

  {
  if (! dev) {
    return;
  } else {
    if (! dev->bus) {
      return;
    }
  }
  if (! addr) {
    return;
  }
  {
  hcd_buffer_free(dev->bus, size, addr, dma);
  }
  return;
}
}
static char const   __kstrtab_usb_buffer_free[16]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'b',      (char const   )'u',      (char const   )'f',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'f', 
        (char const   )'r',      (char const   )'e',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_buffer_free  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_buffer_free), __kstrtab_usb_buffer_free};
int usb_buffer_map_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                      int nents ) 
{ struct usb_bus *bus ;
  struct device *controller ;
  int tmp ;
  int tmp___0 ;

  {
  if (! dev) {
    return (-1);
  } else {
    {
    bus = (struct usb_bus *)dev->bus;
    }
    if (bus) {
      {
      controller = bus->controller;
      }
      if (controller) {
        if (! controller->dma_mask) {
          return (-1);
        }
      } else {
        return (-1);
      }
    } else {
      return (-1);
    }
  }
  if (is_in) {
    {
    tmp = 2;
    }
  } else {
    {
    tmp = 1;
    }
  }
  {
  tmp___0 = dma_map_sg(controller, sg, nents, (enum dma_data_direction )tmp);
  }
  return (tmp___0);
}
}
static char const   __kstrtab_usb_buffer_map_sg[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'b',      (char const   )'u',      (char const   )'f',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'m', 
        (char const   )'a',      (char const   )'p',      (char const   )'_',      (char const   )'s', 
        (char const   )'g',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_buffer_map_sg  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_buffer_map_sg), __kstrtab_usb_buffer_map_sg};
void usb_buffer_unmap_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                         int n_hw_ents ) 
{ struct usb_bus *bus ;
  struct device *controller ;
  int tmp ;

  {
  if (! dev) {
    return;
  } else {
    {
    bus = (struct usb_bus *)dev->bus;
    }
    if (bus) {
      {
      controller = bus->controller;
      }
      if (controller) {
        if (! controller->dma_mask) {
          return;
        }
      } else {
        return;
      }
    } else {
      return;
    }
  }
  if (is_in) {
    {
    tmp = 2;
    }
  } else {
    {
    tmp = 1;
    }
  }
  {
  dma_unmap_sg(controller, sg, n_hw_ents, (enum dma_data_direction )tmp);
  }
  return;
}
}
static char const   __kstrtab_usb_buffer_unmap_sg[20]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'b',      (char const   )'u',      (char const   )'f',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'_',      (char const   )'u', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'p', 
        (char const   )'_',      (char const   )'s',      (char const   )'g',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_buffer_unmap_sg  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_buffer_unmap_sg), __kstrtab_usb_buffer_unmap_sg};
__inline static int *__check_nousb(void) 
{ 

  {
  return (& nousb);
}
}
static int __param_perm_check_nousb  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
static char const   __param_str_nousb[6]  = {      (char const   )'n',      (char const   )'o',      (char const   )'u',      (char const   )'s', 
        (char const   )'b',      (char const   )'\000'};
static struct kernel_param  const  __param_nousb  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {__param_str_nousb, 292U, & param_set_bool, & param_get_bool, {(void *)(& nousb)}};
int usb_disabled(void) 
{ 

  {
  return (nousb);
}
}
static char const   __kstrtab_usb_disabled[13]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'d',      (char const   )'i',      (char const   )'s',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )'d', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_usb_disabled  __attribute__((__unused__,
__section__("__ksymtab_gpl")))  =    {(unsigned long )(& usb_disabled), __kstrtab_usb_disabled};
static int usb_bus_notify(struct notifier_block *nb , unsigned long action , void *data ) 
{ struct device *dev ;
  struct device  const  *__mptr ;
  struct device  const  *__mptr___0 ;
  struct device  const  *__mptr___1 ;
  struct device  const  *__mptr___2 ;

  {
  {
  dev = (struct device *)data;
  }
  if ((int )action == 1) {
    goto switch_717_1;
  } else {
    if ((int )action == 2) {
      goto switch_717_2;
    } else {
      if (0) {
        switch_717_1: /* CIL Label */ 
        if ((unsigned long )dev->type == (unsigned long )(& usb_device_type)) {
          {
          __mptr = (struct device  const  *)dev;
          usb_create_sysfs_dev_files((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)));
          }
        } else {
          if ((unsigned long )dev->type == (unsigned long )(& usb_if_device_type)) {
            {
            __mptr___0 = (struct device  const  *)dev;
            usb_create_sysfs_intf_files((struct usb_interface *)((char *)__mptr___0 - (unsigned int )(& ((struct usb_interface *)0)->dev)));
            }
          }
        }
        goto switch_717_break;
        switch_717_2: /* CIL Label */ 
        if ((unsigned long )dev->type == (unsigned long )(& usb_device_type)) {
          {
          __mptr___1 = (struct device  const  *)dev;
          usb_remove_sysfs_dev_files((struct usb_device *)((char *)__mptr___1 - (unsigned int )(& ((struct usb_device *)0)->dev)));
          }
        } else {
          if ((unsigned long )dev->type == (unsigned long )(& usb_if_device_type)) {
            {
            __mptr___2 = (struct device  const  *)dev;
            usb_remove_sysfs_intf_files((struct usb_interface *)((char *)__mptr___2 - (unsigned int )(& ((struct usb_interface *)0)->dev)));
            }
          }
        }
        goto switch_717_break;
      } else {
        switch_717_break: /* CIL Label */ ;
      }
    }
  }
  return (0);
}
}
static struct notifier_block usb_bus_nb  =    {& usb_bus_notify, (struct notifier_block *)0, 0};
static int usb_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
static int usb_init(void) 
{ int retval ;

  {
  if (nousb) {
    {
    printk("<6>%s: USB support disabled\n", usbcore_name);
    }
    return (0);
  }
  {
  retval = ksuspend_usb_init();
  }
  if (retval) {
    goto out;
  }
  {
  retval = bus_register(& usb_bus_type);
  }
  if (retval) {
    goto bus_register_failed;
  }
  {
  retval = bus_register_notifier(& usb_bus_type, & usb_bus_nb);
  }
  if (retval) {
    goto bus_notifier_failed;
  }
  {
  retval = usb_host_init();
  }
  if (retval) {
    goto host_init_failed;
  }
  {
  retval = usb_major_init();
  }
  if (retval) {
    goto major_init_failed;
  }
  {
  retval = usb_register(& usbfs_driver);
  }
  if (retval) {
    goto driver_register_failed;
  }
  {
  retval = usb_devio_init();
  }
  if (retval) {
    goto usb_devio_init_failed;
  }
  {
  retval = usbfs_init();
  }
  if (retval) {
    goto fs_init_failed;
  }
  {
  retval = usb_hub_init();
  }
  if (retval) {
    goto hub_init_failed;
  }
  {
  retval = usb_register_device_driver(& usb_generic_driver, (struct module *)0);
  }
  if (! retval) {
    goto out;
  }
  {
  usb_hub_cleanup();
  }
  hub_init_failed: 
  {
  usbfs_cleanup();
  }
  fs_init_failed: 
  {
  usb_devio_cleanup();
  }
  usb_devio_init_failed: 
  {
  usb_deregister(& usbfs_driver);
  }
  driver_register_failed: 
  {
  usb_major_cleanup();
  }
  major_init_failed: 
  {
  usb_host_cleanup();
  }
  host_init_failed: 
  {
  bus_unregister_notifier(& usb_bus_type, & usb_bus_nb);
  }
  bus_notifier_failed: 
  {
  bus_unregister(& usb_bus_type);
  }
  bus_register_failed: 
  {
  ksuspend_usb_cleanup();
  }
  out: 
  return (retval);
}
}
static void usb_exit(void)  __attribute__((__section__(".exit.text"))) ;
static void usb_exit(void) 
{ 

  {
  if (nousb) {
    return;
  }
  {
  usb_deregister_device_driver(& usb_generic_driver);
  usb_major_cleanup();
  usbfs_cleanup();
  usb_deregister(& usbfs_driver);
  usb_devio_cleanup();
  usb_hub_cleanup();
  usb_host_cleanup();
  bus_unregister_notifier(& usb_bus_type, & usb_bus_nb);
  bus_unregister(& usb_bus_type);
  ksuspend_usb_cleanup();
  }
  return;
}
}
static int (*__initcall_usb_init4)(void)  __attribute__((__section__(".initcall4.init")))  =    & usb_init;
static void (*__exitcall_usb_exit)(void)  __attribute__((__section__(".exitcall.exit")))  =    & usb_exit;
