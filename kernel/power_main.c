/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned short __kernel_mode_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef unsigned short __u16;
typedef unsigned int __u32;
typedef unsigned long long u64;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
struct device;
struct device;
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct module;
struct module;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct completion;
struct raw_spinlock;
struct raw_spinlock;
struct task_struct;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct __anonstruct_atomic_t_27 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_27 atomic_t;
typedef atomic_t atomic_long_t;
struct kobject;
struct kobject;
struct module;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct task_struct;
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct task_struct;
struct __anonstruct_spinlock_t_33 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_33 spinlock_t;
struct kref {
   atomic_t refcount ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct task_struct;
struct kset;
struct kobj_type;
struct sysfs_dirent;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct klist_node;
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
struct klist_node {
   struct klist *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
   struct completion n_removed ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct rw_semaphore;
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
struct device;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
};
struct pm_ext_ops {
   struct pm_ops base ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
struct task_struct;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Word;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct module;
struct module;
struct marker;
struct marker;
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
} __attribute__((__aligned__(8))) ;
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_98 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct module;
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
};
struct exception_table_entry;
struct exception_table_entry;
struct notifier_block;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_param_attrs;
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   void *unwind_info ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   struct module_ref ref[64] ;
};
struct device_driver;
struct device_driver;
struct module;
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device;
struct device_driver;
struct driver_private;
struct driver_private;
struct class;
struct class;
struct class_private;
struct class_private;
struct bus_type;
struct bus_type;
struct bus_type_private;
struct bus_type_private;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ext_ops *pm ;
   struct bus_type_private *p ;
};
struct notifier_block;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
   struct class_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   char const   *init_name ;
   struct device_type *type ;
   unsigned int uevent_suppress : 1 ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct list_head node ;
   struct class *class ;
   dev_t devt ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
struct device;
struct bus_type_private {
   struct kset subsys ;
   struct kset *drivers_kset ;
   struct kset *devices_kset ;
   struct klist klist_devices ;
   struct klist klist_drivers ;
   struct blocking_notifier_head bus_notifier ;
   unsigned int drivers_autoprobe : 1 ;
   struct bus_type *bus ;
};
struct driver_private {
   struct kobject kobj ;
   struct klist klist_devices ;
   struct klist_node knode_bus ;
   struct module_kobject *mkobj ;
   struct device_driver *driver ;
};
struct class_private {
   struct kset class_subsys ;
   struct list_head class_devices ;
   struct list_head class_interfaces ;
   struct kset class_dirs ;
   struct mutex class_mutex ;
   struct class *class ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
extern void warn_on_slowpath(char const   *file , int line ) ;
extern int _cond_resched(void) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...)  __attribute__((__cold__)) ;
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
  return;
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  {
  list->next = list;
  list->prev = list;
  }
  return;
}
}
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  }
  return;
}
}
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head, head->next);
  }
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = prev;
  prev->next = next;
  }
  return;
}
}
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  INIT_LIST_HEAD(entry);
  }
  return;
}
}
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
  __list_del(list->prev, list->next);
  list_add(list, head);
  }
  return;
}
}
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
  __list_del(list->prev, list->next);
  list_add_tail(list, head);
  }
  return;
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((unsigned int )head->next == (unsigned int )head);
}
}
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;

  {
  {
  first = (struct list_head *)list->next;
  last = (struct list_head *)list->prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
  }
  return;
}
}
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty(list);
  }
  if (! tmp) {
    {
    __list_splice(list, head, head->next);
    }
  }
  return;
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 

  {
  return ((char const   *)kobj->name);
}
}
extern void mutex_lock(struct mutex *lock ) ;
extern void mutex_unlock(struct mutex *lock ) ;
void device_pm_lock(void) ;
void device_power_up(pm_message_t state ) ;
void device_resume(pm_message_t state ) ;
void device_pm_unlock(void) ;
int device_power_down(pm_message_t state ) ;
int device_suspend(pm_message_t state ) ;
void __suspend_report_result(char const   *function , void *fn , int ret ) ;
extern void down(struct semaphore *sem ) ;
extern void up(struct semaphore *sem ) ;
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 

  {
  return ((char const   *)(dev->bus_id));
}
}
extern struct device *get_device(struct device *dev ) ;
extern void put_device(struct device *dev ) ;
extern char const   *dev_driver_string(struct device  const  *dev ) ;
extern void __print_symbol(char const   *fmt , unsigned long address ) ;
__inline static void ( /* format attribute */  __check_printsym_format)(char const   *fmt 
                                                                        , ...) ;
__inline static void ( /* format attribute */  __check_printsym_format)(char const   *fmt 
                                                                        , ...) 
{ 

  {
  return;
}
}
extern int ( /* missing proto */  __builtin_extract_return_addr)() ;
__inline static void print_symbol(char const   *fmt , unsigned long addr ) 
{ int tmp ;

  {
  {
  __check_printsym_format(fmt, "");
  tmp = __builtin_extract_return_addr((void *)addr);
  __print_symbol(fmt, (unsigned long )tmp);
  }
  return;
}
}
__inline static void print_fn_descriptor_symbol(char const   *fmt , void *addr ) 
{ 

  {
  {
  print_symbol(fmt, (unsigned long )addr);
  }
  return;
}
}
extern int pm_trace_enabled ;
extern void set_trace_device(struct device * ) ;
extern void generate_resume_trace(void const   *tracedata , unsigned int user ) ;
extern int sysdev_suspend(pm_message_t state ) ;
extern int sysdev_resume(void) ;
struct list_head dpm_list ;
__inline static struct device *to_device(struct list_head *entry ) 
{ struct list_head  const  *__mptr ;

  {
  {
  __mptr = (struct list_head  const  *)entry;
  }
  return ((struct device *)((char *)__mptr - (unsigned int )(& ((struct device *)0)->power.entry)));
}
}
void device_pm_add(struct device *dev ) ;
void device_pm_remove(struct device *dev ) ;
struct list_head dpm_list  =    {& dpm_list, & dpm_list};
static struct mutex dpm_list_mtx  =    {{1}, {{0U}}, {& dpm_list_mtx.wait_list, & dpm_list_mtx.wait_list}};
static int transition_started  ;
void device_pm_lock(void) 
{ 

  {
  {
  mutex_lock(& dpm_list_mtx);
  }
  return;
}
}
void device_pm_unlock(void) 
{ 

  {
  {
  mutex_unlock(& dpm_list_mtx);
  }
  return;
}
}
void device_pm_add(struct device *dev ) 
{ char const   *tmp___1 ;
  char const   *tmp___2 ;
  int __ret_warn_on ;
  long tmp___3 ;

  {
  {
  mutex_lock(& dpm_list_mtx);
  }
  if (dev->parent) {
    if ((int )(dev->parent)->power.status >= 4) {
      {
      tmp___1 = dev_name((struct device  const  *)dev);
      tmp___2 = dev_driver_string((struct device  const  *)dev);
      printk("<4>%s %s: parent %s should not be sleeping\n", tmp___2, tmp___1, (dev->parent)->bus_id);
      }
    }
  } else {
    if (transition_started) {
      {
      __ret_warn_on = 1;
      tmp___3 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
      }
      if (tmp___3) {
        {
        warn_on_slowpath("base/power/main.c", 86);
        }
      }
      {
      __builtin_expect((long )(! (! __ret_warn_on)), 0L);
      }
    }
  }
  {
  list_add_tail(& dev->power.entry, & dpm_list);
  mutex_unlock(& dpm_list_mtx);
  }
  return;
}
}
void device_pm_remove(struct device *dev ) 
{ 

  {
  {
  mutex_lock(& dpm_list_mtx);
  list_del_init(& dev->power.entry);
  mutex_unlock(& dpm_list_mtx);
  }
  return;
}
}
static int pm_op(struct device *dev , struct pm_ops *ops , pm_message_t state ) 
{ int error ;

  {
  {
  error = 0;
  }
  if (state.event == 2) {
    goto switch_0_2;
  } else {
    if (state.event == 16) {
      goto switch_0_16;
    } else {
      if (state.event == 1) {
        goto switch_0_1;
      } else {
        if (state.event == 8) {
          goto switch_0_1;
        } else {
          if (state.event == 4) {
            goto switch_0_4;
          } else {
            if (state.event == 32) {
              goto switch_0_32;
            } else {
              if (state.event == 128) {
                goto switch_0_32;
              } else {
                if (state.event == 64) {
                  goto switch_0_64;
                } else {
                  {
                  goto switch_0_default;
                  if (0) {
                    switch_0_2: /* CIL Label */ 
                    if (ops->suspend) {
                      {
                      error = (*(ops->suspend))(dev);
                      }
                      {
                      while (1) {
                        while_1_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_op", (void *)ops->suspend, error);
                        }
                        goto while_1_break;
                      }
                      while_1_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_0_break;
                    switch_0_16: /* CIL Label */ 
                    if (ops->resume) {
                      {
                      error = (*(ops->resume))(dev);
                      }
                      {
                      while (1) {
                        while_2_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_op", (void *)ops->resume, error);
                        }
                        goto while_2_break;
                      }
                      while_2_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_0_break;
                    switch_0_1: /* CIL Label */ 
                    switch_0_8: /* CIL Label */ 
                    if (ops->freeze) {
                      {
                      error = (*(ops->freeze))(dev);
                      }
                      {
                      while (1) {
                        while_3_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_op", (void *)ops->freeze, error);
                        }
                        goto while_3_break;
                      }
                      while_3_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_0_break;
                    switch_0_4: /* CIL Label */ 
                    if (ops->poweroff) {
                      {
                      error = (*(ops->poweroff))(dev);
                      }
                      {
                      while (1) {
                        while_4_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_op", (void *)ops->poweroff, error);
                        }
                        goto while_4_break;
                      }
                      while_4_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_0_break;
                    switch_0_32: /* CIL Label */ 
                    switch_0_128: /* CIL Label */ 
                    if (ops->thaw) {
                      {
                      error = (*(ops->thaw))(dev);
                      }
                      {
                      while (1) {
                        while_5_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_op", (void *)ops->thaw, error);
                        }
                        goto while_5_break;
                      }
                      while_5_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_0_break;
                    switch_0_64: /* CIL Label */ 
                    if (ops->restore) {
                      {
                      error = (*(ops->restore))(dev);
                      }
                      {
                      while (1) {
                        while_6_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_op", (void *)ops->restore, error);
                        }
                        goto while_6_break;
                      }
                      while_6_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_0_break;
                    switch_0_default: /* CIL Label */ 
                    {
                    error = -22;
                    }
                  } else {
                    switch_0_break: /* CIL Label */ ;
                  }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (error);
}
}
static int pm_noirq_op(struct device *dev , struct pm_ext_ops *ops , pm_message_t state ) 
{ int error ;

  {
  {
  error = 0;
  }
  if (state.event == 2) {
    goto switch_7_2;
  } else {
    if (state.event == 16) {
      goto switch_7_16;
    } else {
      if (state.event == 1) {
        goto switch_7_1;
      } else {
        if (state.event == 8) {
          goto switch_7_1;
        } else {
          if (state.event == 4) {
            goto switch_7_4;
          } else {
            if (state.event == 32) {
              goto switch_7_32;
            } else {
              if (state.event == 128) {
                goto switch_7_32;
              } else {
                if (state.event == 64) {
                  goto switch_7_64;
                } else {
                  {
                  goto switch_7_default;
                  if (0) {
                    switch_7_2: /* CIL Label */ 
                    if (ops->suspend_noirq) {
                      {
                      error = (*(ops->suspend_noirq))(dev);
                      }
                      {
                      while (1) {
                        while_8_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_noirq_op", (void *)ops->suspend_noirq,
                                                error);
                        }
                        goto while_8_break;
                      }
                      while_8_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_7_break;
                    switch_7_16: /* CIL Label */ 
                    if (ops->resume_noirq) {
                      {
                      error = (*(ops->resume_noirq))(dev);
                      }
                      {
                      while (1) {
                        while_9_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_noirq_op", (void *)ops->resume_noirq,
                                                error);
                        }
                        goto while_9_break;
                      }
                      while_9_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_7_break;
                    switch_7_1: /* CIL Label */ 
                    switch_7_8: /* CIL Label */ 
                    if (ops->freeze_noirq) {
                      {
                      error = (*(ops->freeze_noirq))(dev);
                      }
                      {
                      while (1) {
                        while_10_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_noirq_op", (void *)ops->freeze_noirq,
                                                error);
                        }
                        goto while_10_break;
                      }
                      while_10_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_7_break;
                    switch_7_4: /* CIL Label */ 
                    if (ops->poweroff_noirq) {
                      {
                      error = (*(ops->poweroff_noirq))(dev);
                      }
                      {
                      while (1) {
                        while_11_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_noirq_op", (void *)ops->poweroff_noirq,
                                                error);
                        }
                        goto while_11_break;
                      }
                      while_11_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_7_break;
                    switch_7_32: /* CIL Label */ 
                    switch_7_128: /* CIL Label */ 
                    if (ops->thaw_noirq) {
                      {
                      error = (*(ops->thaw_noirq))(dev);
                      }
                      {
                      while (1) {
                        while_12_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_noirq_op", (void *)ops->thaw_noirq,
                                                error);
                        }
                        goto while_12_break;
                      }
                      while_12_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_7_break;
                    switch_7_64: /* CIL Label */ 
                    if (ops->restore_noirq) {
                      {
                      error = (*(ops->restore_noirq))(dev);
                      }
                      {
                      while (1) {
                        while_13_continue: /* CIL Label */ ;
                        {
                        __suspend_report_result("pm_noirq_op", (void *)ops->restore_noirq,
                                                error);
                        }
                        goto while_13_break;
                      }
                      while_13_break: /* CIL Label */ ;
                      }
                    }
                    goto switch_7_break;
                    switch_7_default: /* CIL Label */ 
                    {
                    error = -22;
                    }
                  } else {
                    switch_7_break: /* CIL Label */ ;
                  }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (error);
}
}
static char *pm_verb(int event ) 
{ 

  {
  if (event == 2) {
    goto switch_14_2;
  } else {
    if (event == 16) {
      goto switch_14_16;
    } else {
      if (event == 1) {
        goto switch_14_1;
      } else {
        if (event == 8) {
          goto switch_14_8;
        } else {
          if (event == 4) {
            goto switch_14_4;
          } else {
            if (event == 32) {
              goto switch_14_32;
            } else {
              if (event == 64) {
                goto switch_14_64;
              } else {
                if (event == 128) {
                  goto switch_14_128;
                } else {
                  {
                  goto switch_14_default;
                  if (0) {
                    switch_14_2: /* CIL Label */ 
                    return ((char *)"suspend");
                    switch_14_16: /* CIL Label */ 
                    return ((char *)"resume");
                    switch_14_1: /* CIL Label */ 
                    return ((char *)"freeze");
                    switch_14_8: /* CIL Label */ 
                    return ((char *)"quiesce");
                    switch_14_4: /* CIL Label */ 
                    return ((char *)"hibernate");
                    switch_14_32: /* CIL Label */ 
                    return ((char *)"thaw");
                    switch_14_64: /* CIL Label */ 
                    return ((char *)"restore");
                    switch_14_128: /* CIL Label */ 
                    return ((char *)"recover");
                    switch_14_default: /* CIL Label */ 
                    {

                    }
                    return ((char *)"(unknown PM event)");
                  } else {
                    switch_14_break: /* CIL Label */ ;
                  }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
static void pm_dev_dbg(struct device *dev , pm_message_t state , char *info ) 
{ 

  {
  return;
}
}
static void pm_dev_err(struct device *dev , pm_message_t state , char *info , int error ) 
{ char *tmp ;
  char const   *tmp___0 ;

  {
  {
  tmp = pm_verb(state.event);
  tmp___0 = kobject_name((struct kobject  const  *)(& dev->kobj));
  printk("<3>PM: Device %s failed to %s%s: error %d\n", tmp___0, tmp, info, error);
  }
  return;
}
}
static int resume_device_noirq(struct device *dev , pm_message_t state ) 
{ int error ;
  void const   *tracedata ;
  void const   *tracedata___0 ;

  {
  {
  error = 0;
  }
  {
  while (1) {
    while_15_continue: /* CIL Label */ ;
    if (pm_trace_enabled) {
      {
      set_trace_device(dev);
      }
    }
    goto while_15_break;
  }
  while_15_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_16_continue: /* CIL Label */ ;
    if (pm_trace_enabled) {
      {
      __asm__  volatile   (" "
                           "movl"
                           " "
                           " $1f,%0\n"
                           ".section .tracedata,\"a\"\n"
                           "1:\t.word %c1\n\t"
                           " "
                           ".long"
                           " "
                           " %c2\n"
                           ".previous": "=r" (tracedata): "i" (283), "i" ("base/power/main.c"));
      generate_resume_trace(tracedata, 0U);
      }
    }
    goto while_16_break;
  }
  while_16_break: /* CIL Label */ ;
  }
  if (! dev->bus) {
    goto End;
  }
  if ((dev->bus)->pm) {
    {
    pm_dev_dbg(dev, state, (char *)"EARLY ");
    error = pm_noirq_op(dev, (dev->bus)->pm, state);
    }
  } else {
    if ((dev->bus)->resume_early) {
      {
      pm_dev_dbg(dev, state, (char *)"legacy EARLY ");
      error = (*((dev->bus)->resume_early))(dev);
      }
    }
  }
  End: 
  {
  while (1) {
    while_17_continue: /* CIL Label */ ;
    if (pm_trace_enabled) {
      {
      __asm__  volatile   (" "
                           "movl"
                           " "
                           " $1f,%0\n"
                           ".section .tracedata,\"a\"\n"
                           "1:\t.word %c1\n\t"
                           " "
                           ".long"
                           " "
                           " %c2\n"
                           ".previous": "=r" (tracedata___0): "i" (296), "i" ("base/power/main.c"));
      generate_resume_trace(tracedata___0, (unsigned int )error);
      }
    }
    goto while_17_break;
  }
  while_17_break: /* CIL Label */ ;
  }
  return (error);
}
}
static void dpm_power_up(pm_message_t state ) 
{ struct device *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int error ;

  {
  {
  __mptr = (struct list_head  const  *)dpm_list.next;
  dev = (struct device *)((char *)__mptr - (unsigned int )(& ((struct device *)0)->power.entry));
  }
  {
  while (1) {
    while_18_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)dev->power.entry.next);
    }
    if (! ((unsigned int )(& dev->power.entry) != (unsigned int )(& dpm_list))) {
      goto while_18_break;
    }
    if ((int )dev->power.status > 5) {
      {
      dev->power.status = 5;
      error = resume_device_noirq(dev, state);
      }
      if (error) {
        {
        pm_dev_err(dev, state, (char *)" early", error);
        }
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)dev->power.entry.next;
    dev = (struct device *)((char *)__mptr___0 - (unsigned int )(& ((struct device *)0)->power.entry));
    }
  }
  while_18_break: /* CIL Label */ ;
  }
  return;
}
}
void device_power_up(pm_message_t state ) 
{ 

  {
  {
  sysdev_resume();
  dpm_power_up(state);
  }
  return;
}
}
extern void *__crc_device_power_up  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_device_power_up  __attribute__((__used__, __unused__,
__section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_device_power_up));
static char const   __kstrtab_device_power_up[16]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'p', 
        (char const   )'o',      (char const   )'w',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'u',      (char const   )'p',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_device_power_up  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& device_power_up), __kstrtab_device_power_up};
static int resume_device(struct device *dev , pm_message_t state ) 
{ int error ;
  void const   *tracedata ;
  void const   *tracedata___0 ;

  {
  {
  error = 0;
  }
  {
  while (1) {
    while_19_continue: /* CIL Label */ ;
    if (pm_trace_enabled) {
      {
      set_trace_device(dev);
      }
    }
    goto while_19_break;
  }
  while_19_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_20_continue: /* CIL Label */ ;
    if (pm_trace_enabled) {
      {
      __asm__  volatile   (" "
                           "movl"
                           " "
                           " $1f,%0\n"
                           ".section .tracedata,\"a\"\n"
                           "1:\t.word %c1\n\t"
                           " "
                           ".long"
                           " "
                           " %c2\n"
                           ".previous": "=r" (tracedata): "i" (350), "i" ("base/power/main.c"));
      generate_resume_trace(tracedata, 0U);
      }
    }
    goto while_20_break;
  }
  while_20_break: /* CIL Label */ ;
  }
  {
  down(& dev->sem);
  }
  if (dev->bus) {
    if ((dev->bus)->pm) {
      {
      pm_dev_dbg(dev, state, (char *)"");
      error = pm_op(dev, & ((dev->bus)->pm)->base, state);
      }
    } else {
      if ((dev->bus)->resume) {
        {
        pm_dev_dbg(dev, state, (char *)"legacy ");
        error = (*((dev->bus)->resume))(dev);
        }
      }
    }
    if (error) {
      goto End;
    }
  }
  if (dev->type) {
    if ((dev->type)->pm) {
      {
      pm_dev_dbg(dev, state, (char *)"type ");
      error = pm_op(dev, (dev->type)->pm, state);
      }
    } else {
      if ((dev->type)->resume) {
        {
        pm_dev_dbg(dev, state, (char *)"legacy type ");
        error = (*((dev->type)->resume))(dev);
        }
      }
    }
    if (error) {
      goto End;
    }
  }
  if (dev->class) {
    if ((dev->class)->pm) {
      {
      pm_dev_dbg(dev, state, (char *)"class ");
      error = pm_op(dev, (dev->class)->pm, state);
      }
    } else {
      if ((dev->class)->resume) {
        {
        pm_dev_dbg(dev, state, (char *)"legacy class ");
        error = (*((dev->class)->resume))(dev);
        }
      }
    }
  }
  End: 
  {
  up(& dev->sem);
  }
  {
  while (1) {
    while_21_continue: /* CIL Label */ ;
    if (pm_trace_enabled) {
      {
      __asm__  volatile   (" "
                           "movl"
                           " "
                           " $1f,%0\n"
                           ".section .tracedata,\"a\"\n"
                           "1:\t.word %c1\n\t"
                           " "
                           ".long"
                           " "
                           " %c2\n"
                           ".previous": "=r" (tracedata___0): "i" (390), "i" ("base/power/main.c"));
      generate_resume_trace(tracedata___0, (unsigned int )error);
      }
    }
    goto while_21_break;
  }
  while_21_break: /* CIL Label */ ;
  }
  return (error);
}
}
static void dpm_resume(pm_message_t state ) 
{ struct list_head list ;
  struct device *dev ;
  struct device *tmp ;
  int error ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  INIT_LIST_HEAD(& list);
  mutex_lock(& dpm_list_mtx);
  transition_started = 0;
  }
  {
  while (1) {
    while_22_continue: /* CIL Label */ ;
    {
    tmp___1 = list_empty((struct list_head  const  *)(& dpm_list));
    }
    if (tmp___1) {
      goto while_22_break;
    }
    {
    tmp = to_device(dpm_list.next);
    dev = tmp;
    get_device(dev);
    }
    if ((int )dev->power.status >= 5) {
      {
      dev->power.status = 3;
      mutex_unlock(& dpm_list_mtx);
      error = resume_device(dev, state);
      mutex_lock(& dpm_list_mtx);
      }
      if (error) {
        {
        pm_dev_err(dev, state, (char *)"", error);
        }
      }
    } else {
      if ((int )dev->power.status == 4) {
        {
        dev->power.status = 3;
        }
      }
    }
    {
    tmp___0 = list_empty((struct list_head  const  *)(& dev->power.entry));
    }
    if (! tmp___0) {
      {
      list_move_tail(& dev->power.entry, & list);
      }
    }
    {
    put_device(dev);
    }
  }
  while_22_break: /* CIL Label */ ;
  }
  {
  list_splice((struct list_head  const  *)(& list), & dpm_list);
  mutex_unlock(& dpm_list_mtx);
  }
  return;
}
}
static void complete_device(struct device *dev , pm_message_t state ) 
{ 

  {
  {
  down(& dev->sem);
  }
  if (dev->class) {
    if ((dev->class)->pm) {
      if (((dev->class)->pm)->complete) {
        {
        pm_dev_dbg(dev, state, (char *)"completing class ");
        (*(((dev->class)->pm)->complete))(dev);
        }
      }
    }
  }
  if (dev->type) {
    if ((dev->type)->pm) {
      if (((dev->type)->pm)->complete) {
        {
        pm_dev_dbg(dev, state, (char *)"completing type ");
        (*(((dev->type)->pm)->complete))(dev);
        }
      }
    }
  }
  if (dev->bus) {
    if ((dev->bus)->pm) {
      if (((dev->bus)->pm)->base.complete) {
        {
        pm_dev_dbg(dev, state, (char *)"completing ");
        (*(((dev->bus)->pm)->base.complete))(dev);
        }
      }
    }
  }
  {
  up(& dev->sem);
  }
  return;
}
}
static void dpm_complete(pm_message_t state ) 
{ struct list_head list ;
  struct device *dev ;
  struct device *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  INIT_LIST_HEAD(& list);
  mutex_lock(& dpm_list_mtx);
  }
  {
  while (1) {
    while_23_continue: /* CIL Label */ ;
    {
    tmp___1 = list_empty((struct list_head  const  *)(& dpm_list));
    }
    if (tmp___1) {
      goto while_23_break;
    }
    {
    tmp = to_device(dpm_list.prev);
    dev = tmp;
    get_device(dev);
    }
    if ((int )dev->power.status > 1) {
      {
      dev->power.status = 1;
      mutex_unlock(& dpm_list_mtx);
      complete_device(dev, state);
      mutex_lock(& dpm_list_mtx);
      }
    }
    {
    tmp___0 = list_empty((struct list_head  const  *)(& dev->power.entry));
    }
    if (! tmp___0) {
      {
      list_move(& dev->power.entry, & list);
      }
    }
    {
    put_device(dev);
    }
  }
  while_23_break: /* CIL Label */ ;
  }
  {
  list_splice((struct list_head  const  *)(& list), & dpm_list);
  mutex_unlock(& dpm_list_mtx);
  }
  return;
}
}
void device_resume(pm_message_t state ) 
{ 

  {
  {
  while (1) {
    while_24_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_24_break;
  }
  while_24_break: /* CIL Label */ ;
  }
  {
  dpm_resume(state);
  dpm_complete(state);
  }
  return;
}
}
extern void *__crc_device_resume  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_device_resume  __attribute__((__used__, __unused__,
__section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_device_resume));
static char const   __kstrtab_device_resume[14]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'u',      (char const   )'m', 
        (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_device_resume  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& device_resume), __kstrtab_device_resume};
static pm_message_t resume_event(pm_message_t sleep_state ) 
{ struct pm_message __constr_expr_0 ;
  struct pm_message __constr_expr_1 ;
  struct pm_message __constr_expr_2 ;
  struct pm_message __constr_expr_3 ;

  {
  if (sleep_state.event == 2) {
    goto switch_25_2;
  } else {
    if (sleep_state.event == 1) {
      goto switch_25_1;
    } else {
      if (sleep_state.event == 8) {
        goto switch_25_1;
      } else {
        if (sleep_state.event == 4) {
          goto switch_25_4;
        } else {
          if (0) {
            switch_25_2: /* CIL Label */ 
            {
            __constr_expr_0.event = 16;
            }
            return (__constr_expr_0);
            switch_25_1: /* CIL Label */ 
            switch_25_8: /* CIL Label */ 
            {
            __constr_expr_1.event = 128;
            }
            return (__constr_expr_1);
            switch_25_4: /* CIL Label */ 
            {
            __constr_expr_2.event = 64;
            }
            return (__constr_expr_2);
          } else {
            switch_25_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  __constr_expr_3.event = 0;
  }
  return (__constr_expr_3);
}
}
static int suspend_device_noirq(struct device *dev , pm_message_t state ) 
{ int error ;

  {
  {
  error = 0;
  }
  if (! dev->bus) {
    return (0);
  }
  if ((dev->bus)->pm) {
    {
    pm_dev_dbg(dev, state, (char *)"LATE ");
    error = pm_noirq_op(dev, (dev->bus)->pm, state);
    }
  } else {
    if ((dev->bus)->suspend_late) {
      {
      pm_dev_dbg(dev, state, (char *)"legacy LATE ");
      error = (*((dev->bus)->suspend_late))(dev, state);
      }
      {
      while (1) {
        while_26_continue: /* CIL Label */ ;
        {
        __suspend_report_result("suspend_device_noirq", (void *)(dev->bus)->suspend_late,
                                error);
        }
        goto while_26_break;
      }
      while_26_break: /* CIL Label */ ;
      }
    }
  }
  return (error);
}
}
int device_power_down(pm_message_t state ) 
{ struct device *dev ;
  int error ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  pm_message_t tmp ;

  {
  {
  error = 0;
  __mptr = (struct list_head  const  *)dpm_list.prev;
  dev = (struct device *)((char *)__mptr - (unsigned int )(& ((struct device *)0)->power.entry));
  }
  {
  while (1) {
    while_27_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)dev->power.entry.prev);
    }
    if (! ((unsigned int )(& dev->power.entry) != (unsigned int )(& dpm_list))) {
      goto while_27_break;
    }
    {
    error = suspend_device_noirq(dev, state);
    }
    if (error) {
      {
      pm_dev_err(dev, state, (char *)" late", error);
      }
      goto while_27_break;
    }
    {
    dev->power.status = 6;
    __mptr___0 = (struct list_head  const  *)dev->power.entry.prev;
    dev = (struct device *)((char *)__mptr___0 - (unsigned int )(& ((struct device *)0)->power.entry));
    }
  }
  while_27_break: /* CIL Label */ ;
  }
  if (! error) {
    {
    error = sysdev_suspend(state);
    }
  }
  if (error) {
    {
    tmp = resume_event(state);
    dpm_power_up(tmp);
    }
  }
  return (error);
}
}
extern void *__crc_device_power_down  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_device_power_down  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_device_power_down));
static char const   __kstrtab_device_power_down[18]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'p', 
        (char const   )'o',      (char const   )'w',      (char const   )'e',      (char const   )'r', 
        (char const   )'_',      (char const   )'d',      (char const   )'o',      (char const   )'w', 
        (char const   )'n',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_device_power_down  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& device_power_down), __kstrtab_device_power_down};
static int suspend_device(struct device *dev , pm_message_t state ) 
{ int error ;

  {
  {
  error = 0;
  down(& dev->sem);
  }
  if (dev->class) {
    if ((dev->class)->pm) {
      {
      pm_dev_dbg(dev, state, (char *)"class ");
      error = pm_op(dev, (dev->class)->pm, state);
      }
    } else {
      if ((dev->class)->suspend) {
        {
        pm_dev_dbg(dev, state, (char *)"legacy class ");
        error = (*((dev->class)->suspend))(dev, state);
        }
        {
        while (1) {
          while_28_continue: /* CIL Label */ ;
          {
          __suspend_report_result("suspend_device", (void *)(dev->class)->suspend,
                                  error);
          }
          goto while_28_break;
        }
        while_28_break: /* CIL Label */ ;
        }
      }
    }
    if (error) {
      goto End;
    }
  }
  if (dev->type) {
    if ((dev->type)->pm) {
      {
      pm_dev_dbg(dev, state, (char *)"type ");
      error = pm_op(dev, (dev->type)->pm, state);
      }
    } else {
      if ((dev->type)->suspend) {
        {
        pm_dev_dbg(dev, state, (char *)"legacy type ");
        error = (*((dev->type)->suspend))(dev, state);
        }
        {
        while (1) {
          while_29_continue: /* CIL Label */ ;
          {
          __suspend_report_result("suspend_device", (void *)(dev->type)->suspend,
                                  error);
          }
          goto while_29_break;
        }
        while_29_break: /* CIL Label */ ;
        }
      }
    }
    if (error) {
      goto End;
    }
  }
  if (dev->bus) {
    if ((dev->bus)->pm) {
      {
      pm_dev_dbg(dev, state, (char *)"");
      error = pm_op(dev, & ((dev->bus)->pm)->base, state);
      }
    } else {
      if ((dev->bus)->suspend) {
        {
        pm_dev_dbg(dev, state, (char *)"legacy ");
        error = (*((dev->bus)->suspend))(dev, state);
        }
        {
        while (1) {
          while_30_continue: /* CIL Label */ ;
          {
          __suspend_report_result("suspend_device", (void *)(dev->bus)->suspend, error);
          }
          goto while_30_break;
        }
        while_30_break: /* CIL Label */ ;
        }
      }
    }
  }
  End: 
  {
  up(& dev->sem);
  }
  return (error);
}
}
static int dpm_suspend(pm_message_t state ) 
{ struct list_head list ;
  int error ;
  struct device *dev ;
  struct device *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  error = 0;
  INIT_LIST_HEAD(& list);
  mutex_lock(& dpm_list_mtx);
  }
  {
  while (1) {
    while_31_continue: /* CIL Label */ ;
    {
    tmp___1 = list_empty((struct list_head  const  *)(& dpm_list));
    }
    if (tmp___1) {
      goto while_31_break;
    }
    {
    tmp = to_device(dpm_list.prev);
    dev = tmp;
    get_device(dev);
    mutex_unlock(& dpm_list_mtx);
    error = suspend_device(dev, state);
    mutex_lock(& dpm_list_mtx);
    }
    if (error) {
      {
      pm_dev_err(dev, state, (char *)"", error);
      put_device(dev);
      }
      goto while_31_break;
    }
    {
    dev->power.status = 5;
    tmp___0 = list_empty((struct list_head  const  *)(& dev->power.entry));
    }
    if (! tmp___0) {
      {
      list_move(& dev->power.entry, & list);
      }
    }
    {
    put_device(dev);
    }
  }
  while_31_break: /* CIL Label */ ;
  }
  {
  list_splice((struct list_head  const  *)(& list), dpm_list.prev);
  mutex_unlock(& dpm_list_mtx);
  }
  return (error);
}
}
static int prepare_device(struct device *dev , pm_message_t state ) 
{ int error ;

  {
  {
  error = 0;
  down(& dev->sem);
  }
  if (dev->bus) {
    if ((dev->bus)->pm) {
      if (((dev->bus)->pm)->base.prepare) {
        {
        pm_dev_dbg(dev, state, (char *)"preparing ");
        error = (*(((dev->bus)->pm)->base.prepare))(dev);
        }
        {
        while (1) {
          while_32_continue: /* CIL Label */ ;
          {
          __suspend_report_result("prepare_device", (void *)((dev->bus)->pm)->base.prepare,
                                  error);
          }
          goto while_32_break;
        }
        while_32_break: /* CIL Label */ ;
        }
        if (error) {
          goto End;
        }
      }
    }
  }
  if (dev->type) {
    if ((dev->type)->pm) {
      if (((dev->type)->pm)->prepare) {
        {
        pm_dev_dbg(dev, state, (char *)"preparing type ");
        error = (*(((dev->type)->pm)->prepare))(dev);
        }
        {
        while (1) {
          while_33_continue: /* CIL Label */ ;
          {
          __suspend_report_result("prepare_device", (void *)((dev->type)->pm)->prepare,
                                  error);
          }
          goto while_33_break;
        }
        while_33_break: /* CIL Label */ ;
        }
        if (error) {
          goto End;
        }
      }
    }
  }
  if (dev->class) {
    if ((dev->class)->pm) {
      if (((dev->class)->pm)->prepare) {
        {
        pm_dev_dbg(dev, state, (char *)"preparing class ");
        error = (*(((dev->class)->pm)->prepare))(dev);
        }
        {
        while (1) {
          while_34_continue: /* CIL Label */ ;
          {
          __suspend_report_result("prepare_device", (void *)((dev->class)->pm)->prepare,
                                  error);
          }
          goto while_34_break;
        }
        while_34_break: /* CIL Label */ ;
        }
      }
    }
  }
  End: 
  {
  up(& dev->sem);
  }
  return (error);
}
}
static int dpm_prepare(pm_message_t state ) 
{ struct list_head list ;
  int error ;
  struct device *dev ;
  struct device *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  error = 0;
  INIT_LIST_HEAD(& list);
  mutex_lock(& dpm_list_mtx);
  transition_started = 1;
  }
  {
  while (1) {
    while_35_continue: /* CIL Label */ ;
    {
    tmp___2 = list_empty((struct list_head  const  *)(& dpm_list));
    }
    if (tmp___2) {
      goto while_35_break;
    }
    {
    tmp = to_device(dpm_list.next);
    dev = tmp;
    get_device(dev);
    dev->power.status = 2;
    mutex_unlock(& dpm_list_mtx);
    error = prepare_device(dev, state);
    mutex_lock(& dpm_list_mtx);
    }
    if (error) {
      {
      dev->power.status = 1;
      }
      if (error == -11) {
        {
        put_device(dev);
        }
        goto while_35_continue;
      }
      {
      tmp___0 = kobject_name((struct kobject  const  *)(& dev->kobj));
      printk("<3>PM: Failed to prepare device %s for power transition: error %d\n",
             tmp___0, error);
      put_device(dev);
      }
      goto while_35_break;
    }
    {
    dev->power.status = 4;
    tmp___1 = list_empty((struct list_head  const  *)(& dev->power.entry));
    }
    if (! tmp___1) {
      {
      list_move_tail(& dev->power.entry, & list);
      }
    }
    {
    put_device(dev);
    }
  }
  while_35_break: /* CIL Label */ ;
  }
  {
  list_splice((struct list_head  const  *)(& list), & dpm_list);
  mutex_unlock(& dpm_list_mtx);
  }
  return (error);
}
}
int device_suspend(pm_message_t state ) 
{ int error ;

  {
  {
  while (1) {
    while_36_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_36_break;
  }
  while_36_break: /* CIL Label */ ;
  }
  {
  error = dpm_prepare(state);
  }
  if (! error) {
    {
    error = dpm_suspend(state);
    }
  }
  return (error);
}
}
extern void *__crc_device_suspend  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab_device_suspend  __attribute__((__used__, __unused__,
__section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc_device_suspend));
static char const   __kstrtab_device_suspend[15]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'s', 
        (char const   )'u',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_device_suspend  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& device_suspend), __kstrtab_device_suspend};
void __suspend_report_result(char const   *function , void *fn , int ret ) 
{ 

  {
  if (ret) {
    {
    printk("<3>%s(): ", function);
    print_fn_descriptor_symbol("%s returns ", fn);
    printk("%d\n", ret);
    }
  }
  return;
}
}
extern void *__crc___suspend_report_result  __attribute__((__weak__)) ;
static unsigned long const   __kcrctab___suspend_report_result  __attribute__((__used__,
__unused__, __section__("__kcrctab_gpl")))  =    (unsigned long const   )((unsigned long )(& __crc___suspend_report_result));
static char const   __kstrtab___suspend_report_result[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'_',      (char const   )'_',      (char const   )'s',      (char const   )'u', 
        (char const   )'s',      (char const   )'p',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'_',      (char const   )'r',      (char const   )'e', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'_',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab___suspend_report_result  __attribute__((__used__,
__unused__, __section__("__ksymtab_gpl")))  =    {(unsigned long )(& __suspend_report_result), __kstrtab___suspend_report_result};
