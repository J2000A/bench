/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef long __kernel_time_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef long long __kernel_loff_t;
typedef unsigned short umode_t;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef __kernel_clock_t clock_t;
typedef __s32 int32_t;
typedef __u32 uint32_t;
typedef u64 sector_t;
typedef unsigned long blkcnt_t;
typedef unsigned int gfp_t;
typedef u32 resource_size_t;
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct revectored_struct {
   unsigned long __map[8] ;
};
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
struct pt_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   int xds ;
   int xes ;
   int xfs ;
   long orig_eax ;
   long eip ;
   int xcs ;
   long eflags ;
   long esp ;
   int xss ;
};
struct task_struct;
struct task_struct;
struct task_struct;
struct task_struct;
struct info {
   long ___orig_eip ;
   long ___ebx ;
   long ___ecx ;
   long ___edx ;
   long ___esi ;
   long ___edi ;
   long ___ebp ;
   long ___eax ;
   long ___ds ;
   long ___es ;
   long ___fs ;
   long ___orig_eax ;
   long ___eip ;
   long ___cs ;
   long ___eflags ;
   long ___esp ;
   long ___ss ;
   long ___vm86_es ;
   long ___vm86_ds ;
   long ___vm86_fs ;
   long ___vm86_gs ;
};
struct __anonstruct_pgd_t_5 {
   unsigned long pgd ;
};
typedef struct __anonstruct_pgd_t_5 pgd_t;
struct __anonstruct_pgprot_t_6 {
   unsigned long pgprot ;
};
typedef struct __anonstruct_pgprot_t_6 pgprot_t;
struct vm_area_struct;
struct vm_area_struct;
struct vm_area_struct;
struct module;
struct module;
struct module;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct completion;
struct completion;
struct pt_regs;
struct pid;
struct pid;
struct pid;
struct __anonstruct_cpumask_t_12 {
   unsigned long bits[1] ;
};
typedef struct __anonstruct_cpumask_t_12 cpumask_t;
struct page;
struct page;
struct page;
struct thread_struct;
struct thread_struct;
struct thread_struct;
struct mm_struct;
struct mm_struct;
struct mm_struct;
struct desc_struct;
struct desc_struct;
struct desc_struct;
struct __xchg_dummy {
   unsigned long a[100] ;
};
struct task_struct;
struct desc_struct {
   unsigned long a ;
   unsigned long b ;
};
struct i387_fsave_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
   long status ;
};
struct i387_fxsave_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long mxcsr_mask ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
} __attribute__((__aligned__(16))) ;
struct i387_soft_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
   unsigned char ftop ;
   unsigned char changed ;
   unsigned char lookahead ;
   unsigned char no_update ;
   unsigned char rm ;
   unsigned char alimit ;
   struct info *info ;
   unsigned long entry_eip ;
};
union i387_union {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
};
struct __anonstruct_mm_segment_t_13 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_13 mm_segment_t;
struct thread_struct;
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long esp0 ;
   unsigned long sysenter_cs ;
   unsigned long eip ;
   unsigned long esp ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg[8] ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union i387_union i387 ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_esp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned long io_bitmap_max ;
};
struct task_struct;
struct mm_struct;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct __anonstruct____missing_field_name_15 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u64 time ;
};
union __anonunion____missing_field_name_14 {
   struct __anonstruct____missing_field_name_15 __annonCompField1 ;
   struct __anonstruct_futex_16 futex ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_14 __annonCompField2 ;
};
struct exec_domain;
struct exec_domain;
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   unsigned long flags ;
   unsigned long status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   struct restart_block restart_block ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
};
struct __anonstruct_raw_spinlock_t_17 {
   unsigned int slock ;
};
typedef struct __anonstruct_raw_spinlock_t_17 raw_spinlock_t;
struct __anonstruct_raw_rwlock_t_18 {
   unsigned int lock ;
};
typedef struct __anonstruct_raw_rwlock_t_18 raw_rwlock_t;
struct task_struct;
struct lock_class_key {

};
struct __anonstruct_spinlock_t_19 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_19 spinlock_t;
struct __anonstruct_rwlock_t_20 {
   raw_rwlock_t raw_lock ;
};
typedef struct __anonstruct_rwlock_t_20 rwlock_t;
struct __anonstruct_atomic_t_21 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_21 atomic_t;
typedef atomic_t atomic_long_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct key;
struct key;
struct key;
struct file;
struct file;
struct file;
struct file;
struct device;
struct device;
struct device;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   struct list_head entry ;
};
struct task_struct;
struct __wait_queue;
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct task_struct;
struct __anonstruct_nodemask_t_77 {
   unsigned long bits[1] ;
};
typedef struct __anonstruct_nodemask_t_77 nodemask_t;
struct page;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct rw_semaphore;
struct rw_semaphore;
struct rw_semaphore;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
struct page;
struct file;
struct vm_area_struct;
struct kmem_cache;
struct kmem_cache;
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct tvec_t_base_s;
struct tvec_t_base_s;
struct tvec_t_base_s;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_t_base_s *base ;
   void *start_site ;
   char start_comm[16] ;
   int start_pid ;
};
struct hrtimer;
struct hrtimer;
struct hrtimer;
enum hrtimer_restart;
enum hrtimer_restart;
struct work_struct;
struct work_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
struct kobject;
struct kobject;
struct kobject;
struct module;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   struct attribute **attrs ;
};
struct vm_area_struct;
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kset;
struct kobj_type;
struct kobj_type;
struct sysfs_dirent;
struct sysfs_dirent;
struct kobject {
   char const   *k_name ;
   struct kref kref ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kset {
   struct kobj_type *ktype ;
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   atomic_long_t nr_slabs ;
   struct list_head partial ;
   struct list_head full ;
};
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   int order ;
   struct kmem_cache_node local_node ;
   int objects ;
   int refcount ;
   void (*ctor)(struct kmem_cache * , void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct kmem_cache_cpu *cpu_slab[8] ;
};
struct seq_operations;
struct seq_operations;
struct __anonstruct_mm_context_t_79 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_79 mm_context_t;
struct task_struct;
struct linux_binprm;
struct linux_binprm;
struct linux_binprm;
struct file;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Word;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct module;
struct module;
struct __anonstruct_local_t_85 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_85 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct module;
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
};
struct exception_table_entry;
struct exception_table_entry;
struct exception_table_entry;
struct notifier_block;
struct module_ref {
   local_t count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_sect_attr {
   struct module_attribute mattr ;
   char *name ;
   unsigned long address ;
};
struct module_sect_attrs {
   struct attribute_group grp ;
   int nsections ;
   struct module_sect_attr attrs[0] ;
};
struct module_param_attrs;
struct module_param_attrs;
struct module_param_attrs;
struct module_notes_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64U - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_param_attrs *param_attrs ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned int num_syms ;
   unsigned long const   *crcs ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned int num_gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned int num_unused_syms ;
   unsigned long const   *unused_crcs ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned int num_unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned int num_gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_exentries ;
   struct exception_table_entry  const  *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned long init_size ;
   unsigned long core_size ;
   unsigned long init_text_size ;
   unsigned long core_text_size ;
   void *unwind_info ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   unsigned int num_bugs ;
   struct module_ref ref[8] ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   Elf32_Sym *symtab ;
   unsigned long num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
};
struct device_driver;
struct device_driver;
struct device_driver;
struct module;
struct siginfo;
struct siginfo;
struct siginfo;
struct __anonstruct_sigset_t_86 {
   unsigned long sig[2] ;
};
typedef struct __anonstruct_sigset_t_86 sigset_t;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_88 {
   pid_t _pid ;
   uid_t _uid ;
};
struct __anonstruct__timer_89 {
   timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(uid_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_90 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_91 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
struct __anonstruct__sigfault_92 {
   void *_addr ;
};
struct __anonstruct__sigpoll_93 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_87 {
   int _pad[(128U - 3U * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_88 _kill ;
   struct __anonstruct__timer_89 _timer ;
   struct __anonstruct__rt_90 _rt ;
   struct __anonstruct__sigchld_91 _sigchld ;
   struct __anonstruct__sigfault_92 _sigfault ;
   struct __anonstruct__sigpoll_93 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_87 _sifields ;
};
typedef struct siginfo siginfo_t;
struct siginfo;
struct user_struct;
struct user_struct;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct pt_regs;
struct task_struct;
typedef __u32 kernel_cap_t;
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct rb_root {
   struct rb_node *rb_node ;
};
struct prio_tree_node;
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct address_space;
struct address_space;
struct address_space;
typedef atomic_long_t mm_counter_t;
union __anonunion____missing_field_name_96 {
   atomic_t _mapcount ;
   unsigned int inuse ;
};
struct __anonstruct____missing_field_name_98 {
   unsigned long private ;
   struct address_space *mapping ;
};
union __anonunion____missing_field_name_97 {
   struct __anonstruct____missing_field_name_98 __annonCompField5 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
union __anonunion____missing_field_name_99 {
   unsigned long index ;
   void *freelist ;
};
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_96 __annonCompField4 ;
   union __anonunion____missing_field_name_97 __annonCompField6 ;
   union __anonunion____missing_field_name_99 __annonCompField7 ;
   struct list_head lru ;
};
struct __anonstruct_vm_set_101 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_100 {
   struct __anonstruct_vm_set_101 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct anon_vma;
struct vm_operations_struct;
struct vm_operations_struct;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_100 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
struct kioctx;
struct kioctx;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[38] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   int core_waiters ;
   struct completion *core_startup_done ;
   struct completion core_done ;
   rwlock_t ioctx_list_lock ;
   struct kioctx *ioctx_list ;
};
struct semaphore {
   atomic_t count ;
   int sleepers ;
   wait_queue_head_t wait ;
};
typedef unsigned long cputime_t;
struct sem_undo;
struct sem_undo;
struct task_struct;
struct sem_undo {
   struct sem_undo *proc_next ;
   struct sem_undo *id_next ;
   int semid ;
   short *semadj ;
};
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct sem_undo *proc_list ;
};
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct dentry;
struct dentry;
struct dentry;
struct vfsmount;
struct vfsmount;
struct vfsmount;
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct dentry *root ;
   struct dentry *pwd ;
   struct dentry *altroot ;
   struct vfsmount *rootmnt ;
   struct vfsmount *pwdmnt ;
   struct vfsmount *altrootmnt ;
};
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   int level ;
   struct upid numbers[1] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct pid_namespace;
struct prop_local_single {
   unsigned long events ;
   int shift ;
   unsigned long period ;
   spinlock_t lock ;
};
struct __anonstruct_seccomp_t_102 {
   int mode ;
};
typedef struct __anonstruct_seccomp_t_102 seccomp_t;
union ktime;
struct robust_list {
   struct robust_list *next ;
};
struct robust_list_head {
   struct robust_list list ;
   long futex_offset ;
   struct robust_list *list_op_pending ;
};
struct inode;
struct inode;
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct rt_mutex_waiter;
struct rt_mutex_waiter;
struct rt_mutex_waiter;
struct task_struct;
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct hrtimer_clock_base;
struct hrtimer_clock_base;
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
struct hrtimer_cpu_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
enum hrtimer_cb_mode {
    HRTIMER_CB_SOFTIRQ = 0,
    HRTIMER_CB_IRQSAFE = 1,
    HRTIMER_CB_IRQSAFE_NO_RESTART = 2,
    HRTIMER_CB_IRQSAFE_NO_SOFTIRQ = 3
} ;
struct hrtimer {
   struct rb_node node ;
   ktime_t expires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   enum hrtimer_cb_mode cb_mode ;
   struct list_head cb_entry ;
   void *start_site ;
   char start_comm[16] ;
   int start_pid ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t (*get_softirq_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
   int (*reprogram)(struct hrtimer *t , struct hrtimer_clock_base *b , ktime_t n ) ;
};
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct lock_class_key lock_key ;
   struct hrtimer_clock_base clock_base[2] ;
   ktime_t expires_next ;
   int hres_active ;
   struct list_head cb_pending ;
   unsigned long nr_events ;
};
struct task_io_accounting {
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct exec_domain;
struct futex_pi_state;
struct futex_pi_state;
struct futex_pi_state;
struct bio;
struct bio;
struct bio;
struct seq_file;
struct seq_file;
struct seq_file;
struct cfs_rq;
struct cfs_rq;
struct cfs_rq;
struct task_struct;
struct nsproxy;
struct nsproxy;
struct nsproxy;
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kioctx;
union __anonunion_ki_obj_107 {
   void *user ;
   struct task_struct *tsk ;
};
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_107 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   atomic_t ki_bio_count ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct kioctx *next ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
};
struct mm_struct;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
union __anonunion____missing_field_name_108 {
   pid_t pgrp ;
   pid_t __pgrp ;
};
union __anonunion____missing_field_name_109 {
   pid_t session ;
   pid_t __session ;
};
struct tty_struct;
struct tty_struct;
struct taskstats;
struct taskstats;
struct tty_audit_buf;
struct tty_audit_buf;
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   struct task_struct *group_exit_task ;
   int notify_count ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct task_struct *tsk ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   union __anonunion____missing_field_name_108 __annonCompField8 ;
   struct pid *tty_old_pgrp ;
   union __anonunion____missing_field_name_109 __annonCompField9 ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[15] ;
   struct list_head cpu_timers[3] ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
};
struct backing_dev_info;
struct backing_dev_info;
struct backing_dev_info;
struct reclaim_state;
struct reclaim_state;
struct reclaim_state;
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
struct sched_group {
   struct sched_group *next ;
   cpumask_t cpumask ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
};
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   cpumask_t span ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
};
struct io_context;
struct io_context;
struct io_context;
struct group_info {
   int ngroups ;
   atomic_t usage ;
   gid_t small_block[32] ;
   int nblocks ;
   gid_t *blocks[0] ;
};
struct audit_context;
struct audit_context;
struct audit_context;
struct pipe_inode_info;
struct pipe_inode_info;
struct pipe_inode_info;
struct rq;
struct rq;
struct rq;
struct sched_domain;
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*moved_group)(struct task_struct *p ) ;
};
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
struct linux_binfmt;
struct linux_binfmt;
struct files_struct;
struct files_struct;
struct css_set;
struct css_set;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   struct list_head run_list ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct hlist_head preempt_notifiers ;
   unsigned short ioprio ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   unsigned int time_slice ;
   struct list_head tasks ;
   struct list_head ptrace_children ;
   struct list_head ptrace_list ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   unsigned int rt_priority ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   unsigned long long it_sched_expires ;
   struct list_head cpu_timers[3] ;
   uid_t uid ;
   uid_t euid ;
   uid_t suid ;
   uid_t fsuid ;
   gid_t gid ;
   gid_t egid ;
   gid_t sgid ;
   gid_t fsgid ;
   struct group_info *group_info ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   unsigned int keep_capabilities : 1 ;
   struct user_struct *user ;
   struct key *request_key_auth ;
   struct key *thread_keyring ;
   unsigned char jit_keyring ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   void *security ;
   struct audit_context *audit_context ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_stimexpd ;
   nodemask_t mems_allowed ;
   int cpuset_mems_generation ;
   int cpuset_mem_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct prop_local_single dirties ;
};
struct pid_namespace;
typedef int irqreturn_t;
struct proc_dir_entry;
struct proc_dir_entry;
struct proc_dir_entry;
struct proc_dir_entry;
struct pt_regs;
struct notifier_block;
struct task_struct;
struct mm_struct;
struct pt_regs;
struct task_struct;
struct device;
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct pci_dev;
struct device;
struct klist_node;
struct klist_node;
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
struct klist_node {
   struct klist *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
   struct completion n_removed ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device;
struct device_driver;
struct class;
struct class;
struct class;
struct class_device;
struct class_device;
struct class_device;
struct bus_type;
struct bus_type;
struct bus_type;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char *buf ) ;
   ssize_t (*store)(struct bus_type * , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct device_attribute;
struct driver_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct module *owner ;
   struct kset subsys ;
   struct kset drivers ;
   struct kset devices ;
   struct klist klist_devices ;
   struct klist klist_drivers ;
   struct blocking_notifier_head bus_notifier ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   unsigned int drivers_autoprobe : 1 ;
};
struct notifier_block;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct kobject kobj ;
   struct klist klist_devices ;
   struct klist_node knode_bus ;
   struct module *owner ;
   char const   *mod_name ;
   struct module_kobject *mkobj ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver * , char *buf ) ;
   ssize_t (*store)(struct device_driver * , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class_attribute;
struct class_device_attribute;
struct class_device_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct kset subsys ;
   struct list_head children ;
   struct list_head devices ;
   struct list_head interfaces ;
   struct kset class_dirs ;
   struct semaphore sem ;
   struct class_attribute *class_attrs ;
   struct class_device_attribute *class_dev_attrs ;
   struct device_attribute *dev_attrs ;
   int (*uevent)(struct class_device *dev , struct kobj_uevent_env *env ) ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct class_device *dev ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device * , pm_message_t state ) ;
   int (*resume)(struct device * ) ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , char *buf ) ;
   ssize_t (*store)(struct class * , char const   *buf , size_t count ) ;
};
struct class_device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class_device * , char *buf ) ;
   ssize_t (*store)(struct class_device * , char const   *buf , size_t count ) ;
};
struct class_device {
   struct list_head node ;
   struct kobject kobj ;
   struct class *class ;
   dev_t devt ;
   struct device *dev ;
   void *class_data ;
   struct class_device *parent ;
   struct attribute_group **groups ;
   void (*release)(struct class_device *dev ) ;
   int (*uevent)(struct class_device *dev , struct kobj_uevent_env *env ) ;
   char class_id[20] ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct dma_coherent_mem;
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   struct device_type *type ;
   unsigned int is_registered : 1 ;
   unsigned int uevent_suppress : 1 ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct list_head node ;
   struct class *class ;
   dev_t devt ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
typedef unsigned short pci_bus_flags_t;
struct pci_bus;
struct pci_bus;
struct pci_driver;
struct pci_driver;
struct pci_dev {
   struct list_head global_list ;
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   pci_power_t current_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   unsigned short vendor_compatible[4] ;
   unsigned short device_compatible[4] ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   struct list_head msi_list ;
};
struct pci_ops;
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct resource *resource[8] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct class_device class_dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
};
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
   unsigned int use_driver_data : 1 ;
};
typedef unsigned int pci_ers_result_t;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
struct module;
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct pci_dev;
struct vm_area_struct;
struct task_struct;
struct task_struct;
struct nameidata;
struct nameidata;
struct nameidata;
struct vfsmount;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
struct dcookie_struct;
struct dcookie_struct;
struct dcookie_struct;
union __anonunion_d_u_114 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry_operations;
struct dentry_operations;
struct super_block;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_114 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   struct dcookie_struct *d_cookie ;
   int d_mounted ;
   unsigned char d_iname[36] ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
struct vfsmount;
struct open_intent {
   int flags ;
   int create_mode ;
   struct file *file ;
};
union __anonunion_intent_116 {
   struct open_intent open ;
};
struct nameidata {
   struct dentry *dentry ;
   struct vfsmount *mnt ;
   struct qstr last ;
   unsigned int flags ;
   int last_type ;
   unsigned int depth ;
   char *saved_names[9] ;
   union __anonunion_intent_116 intent ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct radix_tree_node;
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct export_operations;
struct export_operations;
struct export_operations;
struct iovec;
struct nameidata;
struct kiocb;
struct pipe_inode_info;
struct poll_table_struct;
struct poll_table_struct;
struct poll_table_struct;
struct kstatfs;
struct kstatfs;
struct kstatfs;
struct vm_area_struct;
struct vfsmount;
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
};
typedef __kernel_uid32_t qid_t;
typedef __u64 qsize_t;
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
struct v1_mem_dqinfo {

};
struct v2_mem_dqinfo {
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
};
struct mem_dqblk {
   __u32 dqb_bhardlimit ;
   __u32 dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   __u32 dqb_ihardlimit ;
   __u32 dqb_isoftlimit ;
   __u32 dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct quota_format_type;
struct quota_format_type;
union __anonunion_u_120 {
   struct v1_mem_dqinfo v1_i ;
   struct v2_mem_dqinfo v2_i ;
};
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   union __anonunion_u_120 u ;
};
struct super_block;
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , unsigned long  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , unsigned long  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
struct page;
struct address_space;
struct writeback_control;
struct writeback_control;
struct writeback_control;
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*prepare_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   int (*commit_write)(struct file * , struct page * , unsigned int  , unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   struct page *(*get_xip_page)(struct address_space * , sector_t  , int  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
};
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   rwlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct hd_struct;
struct hd_struct;
struct gendisk;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
};
struct inode_operations;
struct inode_operations;
struct file_operations;
struct file_operations;
struct file_lock;
struct file_lock;
struct cdev;
struct cdev;
union __anonunion____missing_field_name_121 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct dnotify_struct;
struct dnotify_struct;
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   unsigned long i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_121 __annonCompField10 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_122 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_122 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   unsigned int f_uid ;
   unsigned int f_gid ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_insert)(struct file_lock * ) ;
   void (*fl_remove)(struct file_lock * ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
struct nlm_lockowner;
struct nlm_lockowner;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_state;
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct fasync_struct;
struct __anonstruct_afs_124 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_123 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_124 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_pid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_123 fl_u ;
};
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
struct file_system_type;
struct file_system_type;
struct super_operations;
struct super_operations;
struct xattr_handler;
struct xattr_handler;
struct mtd_info;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_syncing ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   int (*fgetattr)(struct file * , struct kstat * ) ;
   int (*fsetattr)(struct file * , struct iattr * ) ;
};
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  , struct nameidata * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
};
struct seq_file;
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*read_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*put_inode)(struct inode * ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   void (*write_super_lockfs)(struct super_block * ) ;
   void (*unlockfs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct vfsmount * , int  ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
struct bio;
struct pt_regs;
struct linux_binprm {
   char buf[128] ;
   struct vm_area_struct *vma ;
   struct mm_struct *mm ;
   unsigned long p ;
   int sh_bang ;
   struct file *file ;
   int e_uid ;
   int e_gid ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   int cap_effective ;
   void *security ;
   int argc ;
   int envc ;
   char *filename ;
   char *interp ;
   unsigned int interp_flags ;
   unsigned int interp_data ;
   unsigned long loader ;
   unsigned long exec ;
   unsigned long argv_len ;
};
struct linux_binfmt {
   struct list_head lh ;
   struct module *module ;
   int (*load_binary)(struct linux_binprm * , struct pt_regs *regs ) ;
   int (*load_shlib)(struct file * ) ;
   int (*core_dump)(long signr , struct pt_regs *regs , struct file *file , unsigned long limit ) ;
   unsigned long min_coredump ;
   int hasvdso ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct seq_file;
struct user_struct;
struct signal_struct;
struct key_type;
struct key_type;
struct key_type;
struct keyring_list;
struct keyring_list;
struct keyring_list;
struct key_user;
struct key_user;
union __anonunion_type_data_129 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
union __anonunion_payload_130 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_129 type_data ;
   union __anonunion_payload_130 payload ;
};
struct anon_vma;
struct file_ra_state;
struct user_struct;
struct writeback_control;
struct mm_struct;
struct vm_area_struct;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   struct page *(*nopage)(struct vm_area_struct *area , unsigned long address , int *type ) ;
   unsigned long (*nopfn)(struct vm_area_struct *area , unsigned long address ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct page *page ) ;
};
struct inode;
struct page;
struct pci_dev;
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct ktermios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct file_operations;
struct inode;
struct module;
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
struct tty_struct;
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   long (*compat_ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                        unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct ktermios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct ktermios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   struct tty_driver *other ;
   struct tty_struct **ttys ;
   struct ktermios **termios ;
   struct ktermios **termios_locked ;
   void *driver_state ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   long (*compat_ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                        unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct ktermios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
   struct list_head tty_drivers ;
};
struct tty_ldisc {
   int magic ;
   char *name ;
   int num ;
   int flags ;
   int (*open)(struct tty_struct * ) ;
   void (*close)(struct tty_struct * ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   ssize_t (*chars_in_buffer)(struct tty_struct *tty ) ;
   ssize_t (*read)(struct tty_struct *tty , struct file *file , unsigned char *buf ,
                   size_t nr ) ;
   ssize_t (*write)(struct tty_struct *tty , struct file *file , unsigned char const   *buf ,
                    size_t nr ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   long (*compat_ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                        unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct ktermios *old ) ;
   unsigned int (*poll)(struct tty_struct * , struct file * , struct poll_table_struct * ) ;
   int (*hangup)(struct tty_struct *tty ) ;
   void (*receive_buf)(struct tty_struct * , unsigned char const   *cp , char *fp ,
                       int count ) ;
   void (*write_wakeup)(struct tty_struct * ) ;
   struct module *owner ;
   int refcount ;
};
struct tty_buffer {
   struct tty_buffer *next ;
   char *char_buf_ptr ;
   unsigned char *flag_buf_ptr ;
   int used ;
   int size ;
   int commit ;
   int read ;
   unsigned long data[0] ;
};
struct tty_bufhead {
   struct delayed_work work ;
   struct semaphore pty_sem ;
   spinlock_t lock ;
   struct tty_buffer *head ;
   struct tty_buffer *tail ;
   struct tty_buffer *free ;
   int memory_used ;
};
struct device;
struct signal_struct;
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct tty_ldisc ldisc ;
   struct mutex termios_mutex ;
   struct ktermios *termios ;
   struct ktermios *termios_locked ;
   char name[64] ;
   struct pid *pgrp ;
   struct pid *session ;
   unsigned long flags ;
   int count ;
   struct winsize winsize ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned char low_latency : 1 ;
   unsigned char warned : 1 ;
   unsigned char ctrl_status ;
   unsigned int receive_room ;
   struct tty_struct *link ;
   struct fasync_struct *fasync ;
   struct tty_bufhead buf ;
   int alt_speed ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   struct work_struct hangup_work ;
   void *disc_data ;
   void *driver_data ;
   struct list_head tty_files ;
   unsigned int column ;
   unsigned char lnext : 1 ;
   unsigned char erasing : 1 ;
   unsigned char raw : 1 ;
   unsigned char real_raw : 1 ;
   unsigned char icanon : 1 ;
   unsigned char closing : 1 ;
   unsigned short minimum_to_wake ;
   unsigned long overrun_time ;
   int num_overrun ;
   unsigned long process_char_map[256U / (8U * sizeof(unsigned long ))] ;
   char *read_buf ;
   int read_head ;
   int read_tail ;
   int read_cnt ;
   unsigned long read_flags[4096U / (8U * sizeof(unsigned long ))] ;
   int canon_data ;
   unsigned long canon_head ;
   unsigned int canon_column ;
   struct mutex atomic_read_lock ;
   struct mutex atomic_write_lock ;
   unsigned char *write_buf ;
   int write_cnt ;
   spinlock_t read_lock ;
   struct work_struct SAK_work ;
};
struct async_icount {
   __u32 cts ;
   __u32 dsr ;
   __u32 rng ;
   __u32 dcd ;
   __u32 tx ;
   __u32 rx ;
   __u32 frame ;
   __u32 parity ;
   __u32 overrun ;
   __u32 brk ;
   __u32 buf_overrun ;
};
struct serial_struct {
   int type ;
   int line ;
   unsigned int port ;
   int irq ;
   int flags ;
   int xmit_fifo_size ;
   int custom_divisor ;
   int baud_base ;
   unsigned short close_delay ;
   char io_type ;
   char reserved_char[1] ;
   int hub6 ;
   unsigned short closing_wait ;
   unsigned short closing_wait2 ;
   unsigned char *iomem_base ;
   unsigned short iomem_reg_shift ;
   unsigned int port_high ;
   unsigned long iomap_base ;
};
struct serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9] ;
};
#pragma pack(2)
#pragma pack()
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
typedef struct tty_struct *PTTY;
typedef wait_queue_head_t PWAITQ;
typedef unsigned char UCHAR;
typedef unsigned int UINT;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
struct __anonstruct_ip2config_t_150 {
   short irq[4] ;
   unsigned short addr[4] ;
   int type[4] ;
   struct pci_dev *pci_dev[4] ;
};
typedef struct __anonstruct_ip2config_t_150 ip2config_t;
struct _cmdSyntax {
   UCHAR length ;
   UCHAR flags ;
   UCHAR cmd[2] ;
};
typedef struct _cmdSyntax *cmdSyntaxPtr;
struct __anonstruct_e_152 {
   unsigned char porMagic1 ;
   unsigned char porMagic2 ;
   unsigned char porVersion ;
   unsigned char porRevision ;
   unsigned char porSubRev ;
   unsigned char porID ;
   unsigned char porBus ;
   unsigned char porMemory ;
   unsigned char porPorts1 ;
   unsigned char porDiag1 ;
   unsigned char porDiag2 ;
   unsigned char porSpeed ;
   unsigned char porFlags ;
   unsigned char porPorts2 ;
   unsigned char porFifoSize ;
   unsigned char porNumBoxes ;
};
union _porStr {
   unsigned char c[16] ;
   struct __anonstruct_e_152 e ;
};
typedef union _porStr porStr;
struct __anonstruct_e_153 {
   unsigned char loadMagic ;
   unsigned char loadBlocksMore ;
   unsigned char loadCRC[2] ;
   unsigned char loadVersion ;
   unsigned char loadRevision ;
   unsigned char loadSubRevision ;
   unsigned char loadSpares[9] ;
   unsigned char loadDates[32] ;
};
union _loadHdrStr {
   unsigned char c[512] ;
   struct __anonstruct_e_153 e ;
};
typedef union _loadHdrStr *loadHdrStrPtr;
struct _bidStat {
   unsigned char bid_value[4] ;
};
typedef struct _bidStat bidStat;
struct _i2eBordStr {
   porStr i2ePom ;
   unsigned short i2ePomSize ;
   unsigned short i2eStartMail ;
   unsigned short i2eValid ;
   unsigned short i2eError ;
   unsigned short i2eFifoSize ;
   unsigned short volatile   i2eFifoRemains ;
   unsigned char i2eFifoStyle ;
   unsigned char i2eDataWidth16 ;
   unsigned char i2eMaxIrq ;
   int i2eBase ;
   int i2eData ;
   int i2eStatus ;
   int i2ePointer ;
   int i2eXMail ;
   int i2eXMask ;
   unsigned short i2eChannelMap[4] ;
   unsigned short i2eGoodMap[4] ;
   void (*i2eDelay)(unsigned int  ) ;
   int (*i2eWriteBuf)(struct _i2eBordStr * , unsigned char * , int  ) ;
   int (*i2eReadBuf)(struct _i2eBordStr * , unsigned char * , int  ) ;
   unsigned short (*i2eReadWord)(struct _i2eBordStr * ) ;
   void (*i2eWriteWord)(struct _i2eBordStr * , unsigned short  ) ;
   int (*i2eWaitForTxEmpty)(struct _i2eBordStr * , int  ) ;
   int (*i2eTxMailEmpty)(struct _i2eBordStr * ) ;
   int (*i2eTrySendMail)(struct _i2eBordStr * , unsigned char  ) ;
   unsigned short (*i2eGetMail)(struct _i2eBordStr * ) ;
   void (*i2eEnableMailIrq)(struct _i2eBordStr * ) ;
   void (*i2eWriteMask)(struct _i2eBordStr * , unsigned char  ) ;
   short i2eToLoad ;
   unsigned char i2eState ;
   unsigned char i2eLVersion ;
   unsigned char i2eLRevision ;
   unsigned char i2eLSub ;
   unsigned short i2eUsingIrq ;
   unsigned char i2eWaitingForEmptyFifo ;
   unsigned char i2eOutMailWaiting ;
   unsigned short i2eLeadoffWord[1] ;
   unsigned short i2eFifoInInts ;
   unsigned short i2eFifoOutInts ;
   void (*i2eFatalTrap)(struct _i2eBordStr * ) ;
   void *i2eChannelPtr ;
   unsigned short i2eFatal ;
   unsigned short i2eChannelCnt ;
   rwlock_t Fbuf_spinlock ;
   unsigned short volatile   i2Fbuf_strip ;
   unsigned short volatile   i2Fbuf_stuff ;
   void *i2Fbuf[66] ;
   rwlock_t Dbuf_spinlock ;
   unsigned short volatile   i2Dbuf_strip ;
   unsigned short volatile   i2Dbuf_stuff ;
   void *i2Dbuf[66] ;
   rwlock_t Bbuf_spinlock ;
   unsigned short volatile   i2Bbuf_strip ;
   unsigned short volatile   i2Bbuf_stuff ;
   void *i2Bbuf[66] ;
   int got_input ;
   int status_change ;
   bidStat channelBtypes ;
   unsigned long debugFlowQueued ;
   unsigned long debugInlineQueued ;
   unsigned long debugDataQueued ;
   unsigned long debugBypassQueued ;
   unsigned long debugFlowCount ;
   unsigned long debugInlineCount ;
   unsigned long debugBypassCount ;
   rwlock_t read_fifo_spinlock ;
   rwlock_t write_fifo_spinlock ;
   struct work_struct tqueue_interrupt ;
   struct timer_list SendPendingTimer ;
   unsigned int SendPendingRetry ;
};
typedef struct _i2eBordStr i2eBordStr;
typedef struct _i2eBordStr *i2eBordStrPtr;
#pragma pack(1)
struct _i2DataHeader {
   unsigned char i2sChannel ;
   unsigned int i2sId : 2  __attribute__((__packed__)) ;
   unsigned int i2sTag : 4 ;
   unsigned int i2sType : 2 ;
   unsigned short i2sCount ;
};
typedef struct _i2DataHeader i2DataHeader;
struct _i2CmdHeader {
   unsigned char i2sChannel ;
   unsigned int i2sCount : 6 ;
   unsigned int i2sType : 2 ;
};
typedef struct _i2CmdHeader i2CmdHeader;
struct _flowIn {
   i2CmdHeader hd ;
   unsigned char fcmd ;
   unsigned short asof ;
   unsigned short room ;
};
typedef struct _flowIn flowIn;
struct _flowStat {
   unsigned short asof ;
   unsigned short room ;
};
typedef struct _flowStat flowStat;
struct _debugStat {
   unsigned char d_ccsr ;
   unsigned char d_txinh ;
   unsigned char d_stat1 ;
   unsigned char d_stat2 ;
};
typedef struct _debugStat debugStat;
struct _cntStat {
   unsigned short cs_time ;
   unsigned short cs_count ;
};
typedef struct _cntStat cntStat;
struct _failStat {
   unsigned char fs_written ;
   unsigned char fs_read ;
   unsigned short fs_address ;
};
typedef struct _failStat failStat;
#pragma pack()
struct _i2ChanStr {
   int port_index ;
   PTTY pTTY ;
   USHORT validity ;
   i2eBordStrPtr pMyBord ;
   int wopen ;
   int throttled ;
   int flags ;
   PWAITQ open_wait ;
   PWAITQ close_wait ;
   PWAITQ delta_msr_wait ;
   PWAITQ dss_now_wait ;
   struct timer_list BookmarkTimer ;
   wait_queue_head_t pBookmarkWait ;
   int BaudBase ;
   int BaudDivisor ;
   USHORT ClosingDelay ;
   USHORT ClosingWaitTime ;
   flowIn volatile   infl ;
   USHORT sinceLastFlow ;
   USHORT whenSendFlow ;
   USHORT channelNeeds ;
   flowStat volatile   outfl ;
   UCHAR Ibuf[514] ;
   USHORT volatile   Ibuf_stuff ;
   USHORT volatile   Ibuf_strip ;
   UCHAR Obuf[1064] ;
   USHORT volatile   Obuf_stuff ;
   USHORT volatile   Obuf_strip ;
   int Obuf_char_count ;
   UCHAR Cbuf[18] ;
   USHORT volatile   Cbuf_stuff ;
   USHORT volatile   Cbuf_strip ;
   UCHAR Pbuf[36U - sizeof(i2DataHeader )] ;
   USHORT volatile   Pbuf_stuff ;
   USHORT dataSetIn ;
   USHORT dataSetOut ;
   USHORT hotKeyIn ;
   short bookMarks ;
   USHORT channelOptions ;
   debugStat channelStatus ;
   cntStat channelRcount ;
   cntStat channelTcount ;
   failStat channelFail ;
   int speed ;
   int flush_flags ;
   void (*trace)(unsigned short  , unsigned char  , unsigned char  , unsigned long  
                 , ...) ;
   struct async_icount icount ;
   struct work_struct tqueue_input ;
   struct work_struct tqueue_status ;
   struct work_struct tqueue_hangup ;
   rwlock_t Ibuf_spinlock ;
   rwlock_t Obuf_spinlock ;
   rwlock_t Cbuf_spinlock ;
   rwlock_t Pbuf_spinlock ;
};
typedef struct _i2ChanStr i2ChanStr;
typedef struct _i2ChanStr *i2ChanStrPtr;
struct completion;
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
typedef int write_proc_t(struct file *file , char const   *buffer , unsigned long count ,
                         void *data );
typedef int get_info_t(char * , char ** , off_t  , int  );
typedef struct proc_dir_entry *shadow_proc_t(struct task_struct *task , struct proc_dir_entry *pde );
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   get_info_t *get_info ;
   struct module *owner ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   shadow_proc_t *shadow_proc ;
};
struct mm_struct;
struct pid_namespace;
struct tty_driver;
struct seq_operations;
struct file;
struct vfsmount;
struct dentry;
struct inode;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   loff_t index ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file *m , loff_t *pos ) ;
   void (*stop)(struct seq_file *m , void *v ) ;
   void *(*next)(struct seq_file *m , void *v , loff_t *pos ) ;
   int (*show)(struct seq_file *m , void *v ) ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
__inline static void *( __attribute__((__always_inline__)) __memcpy)(void *to , void const   *from ,
                                                                     size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  {
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  }
  return (to);
}
}
extern void *memmove(void *dest , void const   *src , size_t n ) ;
__inline static void *( __attribute__((__always_inline__)) __constant_c_memset)(void *s ,
                                                                                unsigned long c ,
                                                                                size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
  __asm__  volatile   ("rep ; stosl\n\t"
                       "testb $2,%b3\n\t"
                       "je 1f\n\t"
                       "stosw\n"
                       "1:\ttestb $1,%b3\n\t"
                       "je 2f\n\t"
                       "stosb\n"
                       "2:": "=&c" (d0), "=&D" (d1): "a" (c), "q" (count), "0" (count / 4U),
                       "1" ((long )s): "memory");
  }
  return (s);
}
}
__inline static void *( __attribute__((__always_inline__)) __constant_c_and_count_memset)(void *s ,
                                                                                          unsigned long pattern ,
                                                                                          size_t count ) 
{ int d0 ;
  int d1 ;

  {
  if ((int )count == 0) {
    goto switch_0_0;
  } else {
    if ((int )count == 1) {
      goto switch_0_1;
    } else {
      if ((int )count == 2) {
        goto switch_0_2;
      } else {
        if ((int )count == 3) {
          goto switch_0_3;
        } else {
          if ((int )count == 4) {
            goto switch_0_4;
          } else {
            if (0) {
              switch_0_0: 
              return (s);
              switch_0_1: 
              {
              *((unsigned char *)s) = (unsigned char )pattern;
              }
              return (s);
              switch_0_2: 
              {
              *((unsigned short *)s) = (unsigned short )pattern;
              }
              return (s);
              switch_0_3: 
              {
              *((unsigned short *)s) = (unsigned short )pattern;
              *((unsigned char *)s + 2) = (unsigned char )pattern;
              }
              return (s);
              switch_0_4: 
              {
              *((unsigned long *)s) = pattern;
              }
              return (s);
            } else {
              {

              }
            }
          }
        }
      }
    }
  }
  if ((int )(count % 4U) == 0) {
    goto switch_1_0;
  } else {
    if ((int )(count % 4U) == 1) {
      goto switch_1_1;
    } else {
      if ((int )(count % 4U) == 2) {
        goto switch_1_2;
      } else {
        goto switch_1_default;
        if (0) {
          switch_1_0: 
          {
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (pattern), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_1_1: 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (pattern),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
          return (s);
          switch_1_2: 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (pattern),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
          return (s);
          switch_1_default: 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (pattern),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
          return (s);
        } else {
          {

          }
        }
      }
    }
  }
}
}
__inline static int ( __attribute__((__always_inline__)) variable_test_bit)(int nr ,
                                                                            unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   ("btl %2,%1\n\tsbbl %0,%0": "=r" (oldbit): "m" (*((long volatile   *)addr)),
                       "Ir" (nr));
  }
  return (oldbit);
}
}
extern int sprintf(char *buf , char const   *fmt  , ...) ;
extern int ( __attribute__((__regparm__(0))) printk)(char const   *fmt  , ...) ;
__inline static unsigned long ( __attribute__((__always_inline__)) __xchg)(unsigned long x ,
                                                                           void volatile   *ptr ,
                                                                           int size ) 
{ 

  {
  if (size == 1) {
    goto switch_2_1;
  } else {
    if (size == 2) {
      goto switch_2_2;
    } else {
      if (size == 4) {
        goto switch_2_4;
      } else {
        if (0) {
          switch_2_1: 
          {
          __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_2_break;
          switch_2_2: 
          {
          __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_2_break;
          switch_2_4: 
          {
          __asm__  volatile   ("xchgl %0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_2_break;
        } else {
          switch_2_break: 
          {

          }
        }
      }
    }
  }
  return (x);
}
}
extern void __bad_percpu_size(void) ;
__inline static void ( __attribute__((__always_inline__)) INIT_LIST_HEAD)(struct list_head *list ) 
{ 

  {
  {
  list->next = list;
  list->prev = list;
  }
  return;
}
}
register unsigned long current_stack_pointer  __asm__("esp") __attribute__((__used__))  ;
__inline static struct thread_info *( __attribute__((__always_inline__)) current_thread_info)(void) 
{ 

  {
  return ((struct thread_info *)(current_stack_pointer & 4294959104UL));
}
}
__inline static int ( __attribute__((__always_inline__)) test_ti_thread_flag)(struct thread_info *ti ,
                                                                              int flag ) 
{ int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)(& ti->flags));
  }
  return (tmp___0);
}
}
extern unsigned long ( __attribute__((__regparm__(3))) _read_lock_irqsave)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long ( __attribute__((__regparm__(3))) _write_lock_irqsave)(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _read_unlock_irqrestore)(rwlock_t *lock ,
                                                                       unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void ( __attribute__((__regparm__(3))) _write_unlock_irqrestore)(rwlock_t *lock ,
                                                                        unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long msleep_interruptible(unsigned int msecs ) ;
extern struct task_struct *per_cpu__current_task ;
__inline static struct task_struct *( __attribute__((__always_inline__)) get_current)(void) 
{ struct task_struct *ret__ ;

  {
  if ((int )sizeof(per_cpu__current_task) == 1) {
    goto switch_3_1;
  } else {
    if ((int )sizeof(per_cpu__current_task) == 2) {
      goto switch_3_2;
    } else {
      if ((int )sizeof(per_cpu__current_task) == 4) {
        goto switch_3_4;
      } else {
        goto switch_3_default;
        if (0) {
          switch_3_1: 
          {
          __asm__  ("mov"
                    "b "
                    "%%fs:"
                    "%1,%0": "=r" (ret__): "m" (per_cpu__current_task));
          }
          goto switch_3_break;
          switch_3_2: 
          {
          __asm__  ("mov"
                    "w "
                    "%%fs:"
                    "%1,%0": "=r" (ret__): "m" (per_cpu__current_task));
          }
          goto switch_3_break;
          switch_3_4: 
          {
          __asm__  ("mov"
                    "l "
                    "%%fs:"
                    "%1,%0": "=r" (ret__): "m" (per_cpu__current_task));
          }
          goto switch_3_break;
          switch_3_default: 
          {
          __bad_percpu_size();
          }
        } else {
          switch_3_break: 
          {

          }
        }
      }
    }
  }
  return (ret__);
}
}
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key ) ;
extern void init_waitqueue_head(wait_queue_head_t *q ) ;
__inline static void ( __attribute__((__always_inline__)) init_waitqueue_entry)(wait_queue_t *q ,
                                                                                struct task_struct *p ) 
{ 

  {
  {
  q->flags = 0U;
  q->private = (void *)p;
  q->func = & default_wake_function;
  }
  return;
}
}
extern void ( __attribute__((__regparm__(3))) add_wait_queue)(wait_queue_head_t *q ,
                                                              wait_queue_t *wait ) ;
extern void ( __attribute__((__regparm__(3))) remove_wait_queue)(wait_queue_head_t *q ,
                                                                 wait_queue_t *wait ) ;
extern void ( __attribute__((__regparm__(3))) __wake_up)(wait_queue_head_t *q , unsigned int mode ,
                                                         int nr , void *key ) ;
extern void kfree(void const   * ) ;
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
extern unsigned int jiffies_to_msecs(unsigned long j ) ;
extern struct tvec_t_base_s boot_tvec_bases ;
extern void ( __attribute__((__regparm__(3))) init_timer)(struct timer_list *timer ) ;
__inline static void ( __attribute__((__always_inline__)) setup_timer)(struct timer_list *timer ,
                                                                       void (*function)(unsigned long  ) ,
                                                                       unsigned long data ) 
{ 

  {
  {
  timer->function = function;
  timer->data = data;
  init_timer(timer);
  }
  return;
}
}
__inline static int ( __attribute__((__always_inline__)) timer_pending)(struct timer_list  const  *timer ) 
{ 

  {
  return ((unsigned int )timer->entry.next != (unsigned int )((void *)0));
}
}
extern int del_timer(struct timer_list *timer ) ;
extern int __mod_timer(struct timer_list *timer , unsigned long expires ) ;
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
__inline static void ( __attribute__((__always_inline__)) add_timer)(struct timer_list *timer ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  while (1) {
    while_0_continue: /* CIL Label */ ;
    {
    tmp = timer_pending((struct timer_list  const  *)timer);
    }
    if (tmp) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
    {
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
    if (tmp___1) {
      {
      while (1) {
        while_1_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/lib/modules/2.6.24-19-generic/build/include/linux/timer.h"),
                             "i" (145), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_2_continue: /* CIL Label */ ;
          {

          }
        }
        while_2_break: /* CIL Label */ ;
        }
        {

        }
        goto while_5_break;
      }
      while_1_break: /* CIL Label */ ;
      }
      while_5_break: 
      {

      }
    }
    goto while_4_break;
  }
  while_0_break: /* CIL Label */ ;
  }
  while_4_break: 
  {
  __mod_timer(timer, timer->expires);
  }
  return;
}
}
extern int ( __attribute__((__regparm__(3))) schedule_work)(struct work_struct *work ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp___3 ;

  {
  {
  tmp___3 = __kmalloc(size, flags);
  }
  return (tmp___3);
}
}
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
extern int capable(int cap ) ;
extern long schedule_timeout_interruptible(long timeout ) ;
extern void ( __attribute__((__regparm__(0))) schedule)(void) ;
extern int kill_pgrp(struct pid *pid , int sig , int priv ) ;
__inline static int ( __attribute__((__always_inline__)) test_tsk_thread_flag)(struct task_struct *tsk ,
                                                                               int flag ) 
{ int tmp ;

  {
  {
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static int ( __attribute__((__always_inline__)) signal_pending)(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = test_tsk_thread_flag(p, 1);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  return ((int )tmp___1);
}
}
extern int request_irq(unsigned int  , irqreturn_t (*handler)(int  , void * ) , unsigned long  ,
                       char const   * , void * ) ;
extern struct resource ioport_resource ;
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ) ;
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
extern struct class *class_create(struct module *owner , char const   *name ) ;
extern struct device *device_create(struct class *cls , struct device *parent , dev_t devt ,
                                    char const   *fmt  , ...) ;
extern struct pci_dev *pci_dev_get(struct pci_dev *dev ) ;
extern void pci_dev_put(struct pci_dev *dev ) ;
extern struct pci_dev *pci_get_device(unsigned int vendor , unsigned int device ,
                                      struct pci_dev *from ) ;
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
__inline static int ( __attribute__((__always_inline__)) pci_read_config_dword)(struct pci_dev *dev ,
                                                                                int where ,
                                                                                u32 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev *dev ) ;
__inline static void ( __attribute__((__always_inline__)) outb_local)(unsigned char value ,
                                                                      int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned char ( __attribute__((__always_inline__)) inb_local)(int port ) 
{ unsigned char value ;

  {
  {
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void ( __attribute__((__always_inline__)) outb)(unsigned char value ,
                                                                int port ) 
{ 

  {
  {
  outb_local(value, port);
  }
  return;
}
}
__inline static unsigned char ( __attribute__((__always_inline__)) inb)(int port ) 
{ unsigned char tmp ;

  {
  {
  tmp = inb_local(port);
  }
  return (tmp);
}
}
__inline static void ( __attribute__((__always_inline__)) outsb)(int port , void const   *addr ,
                                                                 unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "b": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) insb)(int port , void *addr ,
                                                                unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "b": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) outw_local)(unsigned short value ,
                                                                      int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned short ( __attribute__((__always_inline__)) inw_local)(int port ) 
{ unsigned short value ;

  {
  {
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void ( __attribute__((__always_inline__)) outw)(unsigned short value ,
                                                                int port ) 
{ 

  {
  {
  outw_local(value, port);
  }
  return;
}
}
__inline static unsigned short ( __attribute__((__always_inline__)) inw)(int port ) 
{ unsigned short tmp ;

  {
  {
  tmp = inw_local(port);
  }
  return (tmp);
}
}
__inline static void ( __attribute__((__always_inline__)) outsw)(int port , void const   *addr ,
                                                                 unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "w": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) insw)(int port , void *addr ,
                                                                unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "w": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static unsigned int ( __attribute__((__always_inline__)) iminor)(struct inode  const  *inode ) 
{ 

  {
  return ((unsigned int )(inode->i_rdev & (unsigned int const   )((1U << 20) - 1U)));
}
}
extern int register_chrdev(unsigned int  , char const   * , struct file_operations  const  * ) ;
extern void unregister_chrdev(unsigned int  , char const   * ) ;
__inline static long ( __attribute__((__always_inline__)) PTR_ERR)(void const   *ptr ) 
{ 

  {
  return ((long )ptr);
}
}
__inline static long ( __attribute__((__always_inline__)) IS_ERR)(void const   *ptr ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 4294963201UL))), 0L);
  }
  return (tmp);
}
}
__inline static char *( __attribute__((__always_inline__)) pci_name)(struct pci_dev *pdev ) 
{ 

  {
  return (pdev->dev.bus_id);
}
}
extern struct tty_driver *alloc_tty_driver(int lines ) ;
extern void put_tty_driver(struct tty_driver *driver ) ;
extern void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
extern struct ktermios tty_std_termios ;
extern void tty_wait_until_sent(struct tty_struct *tty , long timeout ) ;
extern int tty_check_change(struct tty_struct *tty ) ;
extern int tty_register_driver(struct tty_driver *driver ) ;
extern struct device *tty_register_device(struct tty_driver *driver , unsigned int index ,
                                          struct device *dev ) ;
extern void tty_hangup(struct tty_struct *tty ) ;
extern int tty_hung_up_p(struct file *filp ) ;
extern void tty_wakeup(struct tty_struct *tty ) ;
extern void tty_ldisc_flush(struct tty_struct *tty ) ;
extern unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
extern unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) ;
static UCHAR ct02[3] ;
static UCHAR ct03[3] ;
static UCHAR ct04[3] ;
static UCHAR ct05[3] ;
static UCHAR ct06[3] ;
static UCHAR ct07[4] ;
static UCHAR ct08[4] ;
static UCHAR ct09[4] ;
static UCHAR ct10[4] ;
static UCHAR ct11[4] ;
static UCHAR ct12[4] ;
static UCHAR ct13[3] ;
static UCHAR ct14[3] ;
static UCHAR ct16[4] ;
static UCHAR ct17[4] ;
static UCHAR ct18[3] ;
static UCHAR ct19[3] ;
static UCHAR ct20[3] ;
static UCHAR ct21[3] ;
static UCHAR ct22[3] ;
static UCHAR ct23[3] ;
static UCHAR ct24[3] ;
static UCHAR ct25[3] ;
static UCHAR ct26[4] ;
static UCHAR ct27[3] ;
static UCHAR ct30[3] ;
static UCHAR ct31[3] ;
static UCHAR ct32[3] ;
static UCHAR ct33[3] ;
static UCHAR ct34[4] ;
static UCHAR ct35[4] ;
static UCHAR ct36[4] ;
static UCHAR ct41[3] ;
static UCHAR ct56[4] ;
static UCHAR ct57[3] ;
static UCHAR ct58[3] ;
static UCHAR ct59[4] ;
static UCHAR ct60[3] ;
static UCHAR ct63[4] ;
static UCHAR ct64[4] ;
static UCHAR ct79[4] ;
static UCHAR ct87[3] ;
static ip2config_t ip2config  =    {{(short)0, (short)0, (short)0, (short)0}, {(unsigned short)0, (unsigned short)0,
                                               (unsigned short)0, (unsigned short)0},
    {0, 0, 0, 0}, {(struct pci_dev *)0, (struct pci_dev *)0, (struct pci_dev *)0,
                   (struct pci_dev *)0}};
static void iiEllisInit(void) ;
static int iiSetAddress(i2eBordStrPtr pB , int address , void (*delay)(unsigned int  ) ) ;
static int iiReset(i2eBordStrPtr pB ) ;
static int iiResetDelay(i2eBordStrPtr pB ) ;
static int iiInitialize(i2eBordStrPtr pB ) ;
static int iiDownloadBlock(i2eBordStrPtr pB , loadHdrStrPtr pSource , int isStandard ) ;
static int iiDownloadAll(i2eBordStrPtr pB , loadHdrStrPtr pSource , int isStandard ,
                         int size ) ;
static int i2InitChannels(i2eBordStrPtr pB , int nChannels , i2ChanStrPtr pCh ) ;
static int i2QueueCommands(int type , i2ChanStrPtr pCh , int timeout , int nCommands ,
                           cmdSyntaxPtr pCs0  , ...) ;
static int i2GetStatus(i2ChanStrPtr pCh , int resetBits ) ;
static int i2Input(i2ChanStrPtr pCh ) ;
static int i2InputFlush(i2ChanStrPtr pCh ) ;
static int i2Output(i2ChanStrPtr pCh , char const   *pSource , int count ) ;
static int i2OutputFree(i2ChanStrPtr pCh ) ;
__inline static int ( __attribute__((__always_inline__)) i2ServiceBoard)(i2eBordStrPtr pB ) ;
static void i2DrainOutput(i2ChanStrPtr pCh , int timeout ) ;
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
extern int single_release(struct inode * , struct file * ) ;
static struct file_operations  const  ip2mem_proc_fops ;
static int ip2_read_proc(char *page , char **start , off_t off , int count , int *eof ,
                         void *data ) ;
static char *pcName  =    (char *)"Computone IntelliPort Plus multiport driver";
static char *pcVersion  =    (char *)"1.2.14";
static char *pcDriver_name  =    (char *)"ip2";
static char *pcIpl  =    (char *)"ip2ipl";
int ip2_loadmain(int *iop , int *irqp , unsigned char *firmware , int firmsize ) ;
static unsigned char *Fip_firmware  ;
static int Fip_firmware_size  ;
static int ip2_open(PTTY tty , struct file *pFile ) ;
static void ip2_close(PTTY tty , struct file *pFile ) ;
static int ip2_write(PTTY tty , unsigned char const   *pData , int count ) ;
static int ip2_putchar(PTTY tty , unsigned char ch ) ;
static void ip2_flush_chars(PTTY tty ) ;
static int ip2_write_room(PTTY tty ) ;
static int ip2_chars_in_buf(PTTY tty ) ;
static void ip2_flush_buffer(PTTY tty ) ;
static int ip2_ioctl(PTTY tty , struct file *pFile , UINT cmd , ULONG arg ) ;
static void ip2_set_termios(PTTY tty , struct ktermios *old_termios ) ;
static void ip2_set_line_discipline(PTTY tty ) ;
static void ip2_throttle(PTTY tty ) ;
static void ip2_unthrottle(PTTY tty ) ;
static void ip2_stop(PTTY tty ) ;
static void ip2_start(PTTY tty ) ;
static void ip2_hangup(PTTY tty ) ;
static int ip2_tiocmget(struct tty_struct *tty , struct file *file ) ;
static int ip2_tiocmset(struct tty_struct *tty , struct file *file , unsigned int set ,
                        unsigned int clear ) ;
static void set_irq(int boardnum , int boardIrq ) ;
static void ip2_interrupt_bh(struct work_struct *work ) ;
static irqreturn_t ip2_interrupt(int irq , void *dev_id ) ;
static void ip2_poll(unsigned long arg ) ;
static void do_input(struct work_struct *work ) ;
static void do_status(struct work_struct *work ) ;
static void ip2_wait_until_sent(PTTY tty , int timeout ) ;
static void set_params(i2ChanStrPtr pCh , struct ktermios *o_tios ) ;
static int get_serial_info(i2ChanStrPtr pCh , struct serial_struct *retinfo ) ;
static int set_serial_info(i2ChanStrPtr pCh , struct serial_struct *new_info ) ;
static ssize_t ip2_ipl_read(struct file *pFile , char *pData , size_t count , loff_t *off ) ;
static ssize_t ip2_ipl_write(struct file *pFile , char const   *pData , size_t count ,
                             loff_t *off ) ;
static int ip2_ipl_ioctl(struct inode *pInode , struct file *pFile , UINT cmd , ULONG arg ) ;
static int ip2_ipl_open(struct inode *pInode , struct file *pFile ) ;
static int DumpTraceBuffer(char *pData , int count ) ;
static int DumpFifoBuffer(char *pData , int count ) ;
static void ip2_init_board(int boardnum ) ;
static unsigned short find_eisa_board(int start_slot ) ;
static struct tty_driver *ip2_tty_driver  ;
static unsigned short i2nBoards  ;
static i2eBordStrPtr i2BoardPtrTable[4]  ;
static i2ChanStrPtr DevTable[256]  ;
static void *DevTableMem[4]  ;
static struct file_operations  const  ip2_ipl  = 
     {(struct module *)0, (loff_t (*)(struct file * , loff_t  , int  ))0, & ip2_ipl_read,
    & ip2_ipl_write, (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                  loff_t  ))0, (ssize_t (*)(struct kiocb * , struct iovec  const  * ,
                                                            unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    & ip2_ipl_ioctl, (long (*)(struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (int (*)(struct file * ,
                                                                           struct vm_area_struct * ))0,
    & ip2_ipl_open, (int (*)(struct file * , fl_owner_t id ))0, (int (*)(struct inode * ,
                                                                         struct file * ))0,
    (int (*)(struct file * , struct dentry * , int datasync ))0, (int (*)(struct kiocb * ,
                                                                          int datasync ))0,
    (int (*)(int  , struct file * , int  ))0, (int (*)(struct file * , int  , struct file_lock * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file *filp ,
                                                                       unsigned long arg ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct pipe_inode_info * ,
                                                                         struct file * ,
                                                                         loff_t * ,
                                                                         size_t  ,
                                                                         unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0, (int (*)(struct file * ,
                                                                       struct kstat * ))0,
    (int (*)(struct file * , struct iattr * ))0};
static unsigned long irq_counter  =    0UL;
static unsigned long bh_counter  =    0UL;
static struct timer_list PollTimer  = 
     {{(struct list_head *)0, (struct list_head *)0}, 0UL, & ip2_poll, 0UL, & boot_tvec_bases,
    (void *)0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0},
    0};
static char TimerOn  ;
static int iiWriteBuf16(i2eBordStrPtr pB , unsigned char *address , int count ) ;
static int iiWriteBuf8(i2eBordStrPtr pB , unsigned char *address , int count ) ;
static int iiReadBuf16(i2eBordStrPtr pB , unsigned char *address , int count ) ;
static int iiReadBuf8(i2eBordStrPtr pB , unsigned char *address , int count ) ;
static unsigned short iiReadWord16(i2eBordStrPtr pB ) ;
static unsigned short iiReadWord8(i2eBordStrPtr pB ) ;
static void iiWriteWord16(i2eBordStrPtr pB , unsigned short value ) ;
static void iiWriteWord8(i2eBordStrPtr pB , unsigned short value ) ;
static int iiWaitForTxEmptyII(i2eBordStrPtr pB , int mSdelay ) ;
static int iiWaitForTxEmptyIIEX(i2eBordStrPtr pB , int mSdelay ) ;
static int iiTxMailEmptyII(i2eBordStrPtr pB ) ;
static int iiTxMailEmptyIIEX(i2eBordStrPtr pB ) ;
static int iiTrySendMailII(i2eBordStrPtr pB , unsigned char mail ) ;
static int iiTrySendMailIIEX(i2eBordStrPtr pB , unsigned char mail ) ;
static unsigned short iiGetMailII(i2eBordStrPtr pB ) ;
static unsigned short iiGetMailIIEX(i2eBordStrPtr pB ) ;
static void iiEnableMailIrqII(i2eBordStrPtr pB ) ;
static void iiEnableMailIrqIIEX(i2eBordStrPtr pB ) ;
static void iiWriteMaskII(i2eBordStrPtr pB , unsigned char value ) ;
static void iiWriteMaskIIEX(i2eBordStrPtr pB , unsigned char value ) ;
static void ii2Nop(void) ;
static int ii2Safe  ;
static int iiDelayed  ;
static rwlock_t Dl_spinlock  =    {{16777216U}};
static void iiEllisInit(void) 
{ 

  {
  return;
}
}
static int iiSetAddress(i2eBordStrPtr pB , int address , void (*delay)(unsigned int  ) ) 
{ 

  {
  {
  pB->i2eValid = (unsigned short)4386;
  }
  if ((unsigned int )address <= 256U) {
    goto _L;
  } else {
    if ((unsigned int )address >= 65528U) {
      goto _L;
    } else {
      if (address & 7) {
        _L: 
        {
        while (1) {
          while_3_continue: /* CIL Label */ ;
          {
          pB->i2eError = (unsigned short)1;
          }
          return (0);
          goto while_7_break;
        }
        while_3_break: /* CIL Label */ ;
        }
        while_7_break: 
        {

        }
      }
    }
  }
  {
  pB->i2eBase = address;
  pB->i2eData = address;
  pB->i2eStatus = address + 2;
  pB->i2ePointer = address + 2;
  pB->i2eXMail = address + 3;
  pB->i2eXMask = address + 2;
  ii2Safe = address + 7;
  }
  if ((unsigned int )delay != (unsigned int )((void (*)(unsigned int  ))((void *)0))) {
    {
    pB->i2eDelay = delay;
    }
  } else {
    {
    pB->i2eDelay = (void (*)(unsigned int  ))(& ii2Nop);
    }
  }
  {
  pB->i2eValid = (unsigned short)16977;
  pB->i2eState = (unsigned char)0;
  }
  {
  while (1) {
    while_4_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_8_break;
  }
  while_4_break: /* CIL Label */ ;
  }
  while_8_break: 
  {

  }
  return (0);
}
}
static int iiReset(i2eBordStrPtr pB ) 
{ 

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_5_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)3;
      }
      return (0);
      goto while_9_break;
    }
    while_5_break: /* CIL Label */ ;
    }
    while_9_break: 
    {

    }
  }
  {
  outb((unsigned char)0, pB->i2eBase + 7);
  (*(pB->i2eDelay))(50U);
  outb((unsigned char)0, pB->i2eBase + 7);
  pB->i2eState = (unsigned char)1;
  iiDelayed = 0;
  pB->i2eUsingIrq = (unsigned short)4946;
  pB->i2eWaitingForEmptyFifo = (unsigned char)0;
  pB->i2eOutMailWaiting = (unsigned char)0;
  pB->i2eChannelPtr = (void *)0;
  pB->i2eChannelCnt = (unsigned short)0;
  pB->i2eLeadoffWord[0] = (unsigned short)0;
  pB->i2eFifoInInts = (unsigned short)0;
  pB->i2eFifoOutInts = (unsigned short)0;
  pB->i2eFatalTrap = (void (*)(struct _i2eBordStr * ))((void *)0);
  pB->i2eFatal = (unsigned short)0;
  }
  {
  while (1) {
    while_6_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_10_break;
  }
  while_6_break: /* CIL Label */ ;
  }
  while_10_break: 
  {

  }
  return (0);
}
}
static int iiResetDelay(i2eBordStrPtr pB ) 
{ 

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_7_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)3;
      }
      return (0);
      goto while_11_break;
    }
    while_7_break: /* CIL Label */ ;
    }
    while_11_break: 
    {

    }
  }
  if ((int )pB->i2eState != 1) {
    {
    while (1) {
      while_8_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)2;
      }
      return (0);
      goto while_12_break;
    }
    while_8_break: /* CIL Label */ ;
    }
    while_12_break: 
    {

    }
  }
  {
  (*(pB->i2eDelay))(2000U);
  iiDelayed = 1;
  }
  {
  while (1) {
    while_9_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_13_break;
  }
  while_9_break: /* CIL Label */ ;
  }
  while_13_break: 
  {

  }
  return (0);
}
}
static int iiInitialize(i2eBordStrPtr pB ) 
{ int itemp ;
  unsigned char c ;
  unsigned short utemp ;
  unsigned int ilimit ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_10_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)3;
      }
      return (0);
      goto while_14_break;
    }
    while_10_break: /* CIL Label */ ;
    }
    while_14_break: 
    {

    }
  }
  if ((int )pB->i2eState != 1) {
    goto _L;
  } else {
    if (! iiDelayed) {
      _L: 
      {
      while (1) {
        while_11_continue: /* CIL Label */ ;
        {
        pB->i2eError = (unsigned short)2;
        }
        return (0);
        goto while_15_break;
      }
      while_11_break: /* CIL Label */ ;
      }
      while_15_break: 
      {

      }
    }
  }
  {
  pB->i2eValid = (unsigned short)4386;
  itemp = 0;
  }
  {
  while (1) {
    while_12_continue: /* CIL Label */ ;
    {

    }
    if (! ((unsigned int )itemp < sizeof(porStr ))) {
      goto while_16_break;
    }
    {
    tmp = inb(pB->i2eStatus);
    }
    if ((int )tmp & 32) {
      {
      pB->i2ePomSize = (unsigned short )itemp;
      }
      {
      while (1) {
        while_13_continue: /* CIL Label */ ;
        {
        pB->i2eError = (unsigned short)4;
        }
        return (0);
        goto while_17_break;
      }
      while_13_break: /* CIL Label */ ;
      }
      while_17_break: 
      {

      }
    }
    {
    c = inb(pB->i2eData);
    pB->i2ePom.c[itemp] = c;
    }
    if (itemp == 0) {
      if ((int )c != 150) {
        goto _L___0;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (itemp == 1) {
        if ((int )c != 53) {
          _L___0: 
          {
          pB->i2ePomSize = (unsigned short )(itemp + 1);
          }
          {
          while (1) {
            while_14_continue: /* CIL Label */ ;
            {
            pB->i2eError = (unsigned short)3;
            }
            return (0);
            goto while_18_break;
          }
          while_14_break: /* CIL Label */ ;
          }
          while_18_break: 
          {

          }
        }
      }
    }
    {
    itemp ++;
    }
  }
  while_12_break: /* CIL Label */ ;
  }
  while_16_break: 
  {
  pB->i2ePomSize = (unsigned short )itemp;
  tmp___0 = inb(pB->i2eStatus);
  }
  if (! ((int )tmp___0 & 32)) {
    {
    while (1) {
      while_15_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)5;
      }
      return (0);
      goto while_19_break;
    }
    while_15_break: /* CIL Label */ ;
    }
    while_19_break: 
    {

    }
  }
  if ((int )pB->i2ePom.e.porDiag1 & 128) {
    {
    while (1) {
      while_16_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)8;
      }
      return (0);
      goto while_20_break;
    }
    while_16_break: /* CIL Label */ ;
    }
    while_20_break: 
    {

    }
  }
  if (((int )pB->i2ePom.e.porID & 192) == 0) {
    goto switch_21_0;
  } else {
    if (((int )pB->i2ePom.e.porID & 192) == 64) {
      goto switch_21_64;
    } else {
      goto switch_21_default;
      if (0) {
        switch_21_0: 
        {
        pB->i2eFifoStyle = (unsigned char)0;
        pB->i2eFifoSize = (unsigned short)512;
        pB->i2eDataWidth16 = (unsigned char)0;
        pB->i2eMaxIrq = (unsigned char)15;
        tmp___5 = (unsigned short)0;
        pB->i2eChannelMap[3] = tmp___5;
        tmp___4 = tmp___5;
        pB->i2eChannelMap[2] = tmp___4;
        tmp___3 = tmp___4;
        pB->i2eChannelMap[1] = tmp___3;
        tmp___2 = tmp___3;
        pB->i2eGoodMap[3] = tmp___2;
        tmp___1 = tmp___2;
        pB->i2eGoodMap[2] = tmp___1;
        pB->i2eGoodMap[1] = tmp___1;
        }
        if (((int )pB->i2ePom.e.porID & 3) == 3) {
          goto switch_22_3;
        } else {
          if (((int )pB->i2ePom.e.porID & 3) == 0) {
            goto switch_22_0;
          } else {
            if (((int )pB->i2ePom.e.porID & 3) == 1) {
              goto switch_22_0;
            } else {
              if (((int )pB->i2ePom.e.porID & 3) == 2) {
                goto switch_22_2;
              } else {
                if (0) {
                  switch_22_3: 
                  {
                  tmp___6 = (unsigned short)15;
                  pB->i2eChannelMap[0] = tmp___6;
                  pB->i2eGoodMap[0] = tmp___6;
                  }
                  if ((int )pB->i2ePom.e.porPorts1 != 4) {
                    {
                    while (1) {
                      while_17_continue: /* CIL Label */ ;
                      {
                      pB->i2eError = (unsigned short)7;
                      }
                      return (0);
                      goto while_23_break;
                    }
                    while_17_break: /* CIL Label */ ;
                    }
                    while_23_break: 
                    {

                    }
                  }
                  goto switch_22_break;
                  switch_22_0: 
                  {
                  tmp___7 = (unsigned short)255;
                  pB->i2eChannelMap[0] = tmp___7;
                  pB->i2eGoodMap[0] = tmp___7;
                  }
                  if ((int )pB->i2ePom.e.porPorts1 != 8) {
                    {
                    while (1) {
                      while_18_continue: /* CIL Label */ ;
                      {
                      pB->i2eError = (unsigned short)7;
                      }
                      return (0);
                      goto while_24_break;
                    }
                    while_18_break: /* CIL Label */ ;
                    }
                    while_24_break: 
                    {

                    }
                  }
                  goto switch_22_break;
                  switch_22_2: 
                  {
                  tmp___8 = (unsigned short)63;
                  pB->i2eChannelMap[0] = tmp___8;
                  pB->i2eGoodMap[0] = tmp___8;
                  }
                  if ((int )pB->i2ePom.e.porPorts1 != 6) {
                    {
                    while (1) {
                      while_19_continue: /* CIL Label */ ;
                      {
                      pB->i2eError = (unsigned short)7;
                      }
                      return (0);
                      goto while_25_break;
                    }
                    while_19_break: /* CIL Label */ ;
                    }
                    while_25_break: 
                    {

                    }
                  }
                  goto switch_22_break;
                } else {
                  switch_22_break: 
                  {

                  }
                }
              }
            }
          }
        }
        if ((int )pB->i2ePom.e.porDiag1 & 1) {
          {
          pB->i2eGoodMap[0] = (unsigned short )((int )pB->i2eGoodMap[0] & -16);
          }
        }
        if ((int )pB->i2ePom.e.porDiag1 & 2) {
          {
          pB->i2eGoodMap[0] = (unsigned short )((int )pB->i2eGoodMap[0] & -241);
          }
        }
        goto switch_21_break;
        switch_21_64: 
        {
        pB->i2eFifoStyle = (unsigned char)1;
        itemp = (int )pB->i2ePom.e.porFifoSize;
        }
        if (itemp < 8) {
          goto _L___2;
        } else {
          if (itemp > 15) {
            _L___2: 
            {
            while (1) {
              while_20_continue: /* CIL Label */ ;
              {
              pB->i2eError = (unsigned short)7;
              }
              return (0);
              goto while_26_break;
            }
            while_20_break: /* CIL Label */ ;
            }
            while_26_break: 
            {

            }
          }
        }
        {
        pB->i2eFifoSize = (unsigned short )(1 << itemp);
        ilimit = (unsigned int )pB->i2ePom.e.porNumBoxes;
        }
        if (ilimit > 4U) {
          {
          ilimit = 4U;
          }
        }
        {
        utemp = (unsigned short )pB->i2ePom.e.porFlags;
        }
        if ((int )utemp & 4) {
          {
          pB->i2eChannelMap[0] = (unsigned short)15;
          }
        } else {
          {
          utemp = (unsigned short )((int )utemp & 240);
          itemp = 0;
          }
          {
          while (1) {
            while_21_continue: /* CIL Label */ ;
            {

            }
            if (! ((unsigned int )itemp < ilimit)) {
              goto while_27_break;
            }
            if ((int )utemp & 16) {
              {
              pB->i2eChannelMap[itemp] = (unsigned short)65535;
              }
            } else {
              {
              pB->i2eChannelMap[itemp] = (unsigned short)255;
              }
            }
            {
            utemp = (unsigned short )((int )utemp >> 1);
            itemp ++;
            }
          }
          while_21_break: /* CIL Label */ ;
          }
          while_27_break: 
          {

          }
        }
        {
        utemp = (unsigned short )(((int )pB->i2ePom.e.porPorts2 << 8) + (int )pB->i2ePom.e.porPorts1);
        itemp = 0;
        }
        {
        while (1) {
          while_22_continue: /* CIL Label */ ;
          {

          }
          if (! ((unsigned int )itemp < ilimit)) {
            goto while_28_break;
          }
          {
          pB->i2eGoodMap[itemp] = (unsigned short)0;
          }
          if ((int )utemp & 1) {
            {
            pB->i2eGoodMap[itemp] = (unsigned short )((int )pB->i2eGoodMap[itemp] | 15);
            }
          }
          if ((int )utemp & 2) {
            {
            pB->i2eGoodMap[itemp] = (unsigned short )((int )pB->i2eGoodMap[itemp] | 240);
            }
          }
          if ((int )utemp & 4) {
            {
            pB->i2eGoodMap[itemp] = (unsigned short )((int )pB->i2eGoodMap[itemp] | 3840);
            }
          }
          if ((int )utemp & 8) {
            {
            pB->i2eGoodMap[itemp] = (unsigned short )((int )pB->i2eGoodMap[itemp] | 61440);
            }
          }
          {
          utemp = (unsigned short )((int )utemp >> 4);
          itemp ++;
          }
        }
        while_22_break: /* CIL Label */ ;
        }
        while_28_break: 
        {

        }
        if (((int )pB->i2ePom.e.porBus & 48) == 48) {
          goto switch_29_48;
        } else {
          if (((int )pB->i2ePom.e.porBus & 48) == 32) {
            goto switch_29_32;
          } else {
            if (((int )pB->i2ePom.e.porBus & 48) == 0) {
              goto switch_29_0;
            } else {
              if (((int )pB->i2ePom.e.porBus & 48) == 16) {
                goto switch_29_0;
              } else {
                goto switch_29_0;
                if (0) {
                  switch_29_48: 
                  {
                  pB->i2eDataWidth16 = (unsigned char)1;
                  pB->i2eMaxIrq = (unsigned char)15;
                  }
                  goto switch_29_break;
                  switch_29_32: 
                  {
                  pB->i2eDataWidth16 = (unsigned char)0;
                  pB->i2eMaxIrq = (unsigned char)15;
                  }
                  goto switch_29_break;
                  switch_29_0: 
                  {
                  pB->i2eDataWidth16 = (unsigned char)0;
                  pB->i2eMaxIrq = (unsigned char)7;
                  }
                  goto switch_29_break;
                } else {
                  switch_29_break: 
                  {

                  }
                }
              }
            }
          }
        }
        goto switch_21_break;
        switch_21_default: 
        {

        }
        {
        while (1) {
          while_23_continue: /* CIL Label */ ;
          {
          pB->i2eError = (unsigned short)6;
          }
          return (0);
          goto while_30_break;
        }
        while_23_break: /* CIL Label */ ;
        }
        while_30_break: 
        {

        }
        goto switch_21_break;
      } else {
        switch_21_break: 
        {

        }
      }
    }
  }
  {
  pB->i2eFifoRemains = (unsigned short volatile   )0;
  }
  if (((int )pB->i2ePom.e.porBus & 7) == 3) {
    goto switch_31_3;
  } else {
    if (((int )pB->i2ePom.e.porBus & 7) == 0) {
      goto switch_31_3;
    } else {
      if (((int )pB->i2ePom.e.porBus & 7) == 1) {
        goto switch_31_3;
      } else {
        if (((int )pB->i2ePom.e.porBus & 7) == 2) {
          goto switch_31_3;
        } else {
          goto switch_31_default;
          if (0) {
            switch_31_3: 
            goto switch_31_break;
            switch_31_default: 
            {

            }
            {
            while (1) {
              while_24_continue: /* CIL Label */ ;
              {
              pB->i2eError = (unsigned short)9;
              }
              return (0);
              goto while_32_break;
            }
            while_24_break: /* CIL Label */ ;
            }
            while_32_break: 
            {

            }
          } else {
            switch_31_break: 
            {

            }
          }
        }
      }
    }
  }
  if (pB->i2eDataWidth16) {
    {
    pB->i2eWriteBuf = & iiWriteBuf16;
    pB->i2eReadBuf = & iiReadBuf16;
    pB->i2eWriteWord = & iiWriteWord16;
    pB->i2eReadWord = & iiReadWord16;
    }
  } else {
    {
    pB->i2eWriteBuf = & iiWriteBuf8;
    pB->i2eReadBuf = & iiReadBuf8;
    pB->i2eWriteWord = & iiWriteWord8;
    pB->i2eReadWord = & iiReadWord8;
    }
  }
  if ((int )pB->i2eFifoStyle == 0) {
    goto switch_33_0;
  } else {
    if ((int )pB->i2eFifoStyle == 1) {
      goto switch_33_1;
    } else {
      goto switch_33_default;
      if (0) {
        switch_33_0: 
        {
        pB->i2eWaitForTxEmpty = & iiWaitForTxEmptyII;
        pB->i2eTxMailEmpty = & iiTxMailEmptyII;
        pB->i2eTrySendMail = & iiTrySendMailII;
        pB->i2eGetMail = & iiGetMailII;
        pB->i2eEnableMailIrq = & iiEnableMailIrqII;
        pB->i2eWriteMask = & iiWriteMaskII;
        }
        goto switch_33_break;
        switch_33_1: 
        {
        pB->i2eWaitForTxEmpty = & iiWaitForTxEmptyIIEX;
        pB->i2eTxMailEmpty = & iiTxMailEmptyIIEX;
        pB->i2eTrySendMail = & iiTrySendMailIIEX;
        pB->i2eGetMail = & iiGetMailIIEX;
        pB->i2eEnableMailIrq = & iiEnableMailIrqIIEX;
        pB->i2eWriteMask = & iiWriteMaskIIEX;
        }
        goto switch_33_break;
        switch_33_default: 
        {

        }
        {
        while (1) {
          while_25_continue: /* CIL Label */ ;
          {
          pB->i2eError = (unsigned short)7;
          }
          return (0);
          goto while_34_break;
        }
        while_25_break: /* CIL Label */ ;
        }
        while_34_break: 
        {

        }
      } else {
        switch_33_break: 
        {

        }
      }
    }
  }
  {
  pB->i2eState = (unsigned char)2;
  pB->i2eStartMail = (*(pB->i2eGetMail))(pB);
  pB->i2eStartMail = (unsigned short)4369;
  pB->i2eValid = (unsigned short)16977;
  }
  {
  while (1) {
    while_26_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_35_break;
  }
  while_26_break: /* CIL Label */ ;
  }
  while_35_break: 
  {

  }
  return (0);
}
}
static void ii2DelayTimer(unsigned int mseconds ) 
{ 

  {
  {
  msleep_interruptible(mseconds);
  }
  return;
}
}
static void ii2Nop(void) 
{ 

  {
  return;
}
}
static int iiWriteBuf16(i2eBordStrPtr pB , unsigned char *address , int count ) 
{ 

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_27_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)11;
      }
      return (0);
      goto while_36_break;
    }
    while_27_break: /* CIL Label */ ;
    }
    while_36_break: 
    {

    }
  }
  {
  outsw(pB->i2eData, (void const   *)address, (unsigned long )((count + 1) / 2));
  }
  {
  while (1) {
    while_28_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_37_break;
  }
  while_28_break: /* CIL Label */ ;
  }
  while_37_break: 
  {

  }
  return (0);
}
}
static int iiWriteBuf8(i2eBordStrPtr pB , unsigned char *address , int count ) 
{ 

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_29_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)11;
      }
      return (0);
      goto while_38_break;
    }
    while_29_break: /* CIL Label */ ;
    }
    while_38_break: 
    {

    }
  }
  {
  outsb(pB->i2eData, (void const   *)address, (unsigned long )((count + 1) & -2));
  }
  {
  while (1) {
    while_30_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_39_break;
  }
  while_30_break: /* CIL Label */ ;
  }
  while_39_break: 
  {

  }
  return (0);
}
}
static int iiReadBuf16(i2eBordStrPtr pB , unsigned char *address , int count ) 
{ 

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_31_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)11;
      }
      return (0);
      goto while_40_break;
    }
    while_31_break: /* CIL Label */ ;
    }
    while_40_break: 
    {

    }
  }
  {
  insw(pB->i2eData, (void *)address, (unsigned long )((count + 1) / 2));
  }
  {
  while (1) {
    while_32_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_41_break;
  }
  while_32_break: /* CIL Label */ ;
  }
  while_41_break: 
  {

  }
  return (0);
}
}
static int iiReadBuf8(i2eBordStrPtr pB , unsigned char *address , int count ) 
{ 

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_33_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)11;
      }
      return (0);
      goto while_42_break;
    }
    while_33_break: /* CIL Label */ ;
    }
    while_42_break: 
    {

    }
  }
  {
  insb(pB->i2eData, (void *)address, (unsigned long )((count + 1) & -2));
  }
  {
  while (1) {
    while_34_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_43_break;
  }
  while_34_break: /* CIL Label */ ;
  }
  while_43_break: 
  {

  }
  return (0);
}
}
static unsigned short iiReadWord16(i2eBordStrPtr pB ) 
{ unsigned short tmp ;

  {
  {
  tmp = inw(pB->i2eData);
  }
  return (tmp);
}
}
static unsigned short iiReadWord8(i2eBordStrPtr pB ) 
{ unsigned short urs ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
  tmp = inb(pB->i2eData);
  urs = (unsigned short )tmp;
  tmp___0 = inb(pB->i2eData);
  }
  return ((unsigned short )(((int )tmp___0 << 8) | (int )urs));
}
}
static void iiWriteWord16(i2eBordStrPtr pB , unsigned short value ) 
{ 

  {
  {
  outw((unsigned short )((int )value), pB->i2eData);
  }
  return;
}
}
static void iiWriteWord8(i2eBordStrPtr pB , unsigned short value ) 
{ 

  {
  {
  outb((unsigned char )((char )value), pB->i2eData);
  outb((unsigned char )((char )((int )value >> 8)), pB->i2eData);
  }
  return;
}
}
static int iiWaitForTxEmptyII(i2eBordStrPtr pB , int mSdelay ) 
{ unsigned long flags ;
  int itemp ;
  unsigned char tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_35_continue: /* CIL Label */ ;
    {
    flags = _write_lock_irqsave(& Dl_spinlock);
    outb((unsigned char)1, pB->i2ePointer);
    outb((unsigned char)64, pB->i2ePointer);
    tmp = inb(pB->i2eStatus);
    itemp = (int )tmp;
    outb((unsigned char)1, pB->i2ePointer);
    outb((unsigned char)0, pB->i2ePointer);
    }
    if (itemp & 32) {
      {
      pB->i2eFifoRemains = (unsigned short volatile   )pB->i2eFifoSize;
      _write_unlock_irqrestore(& Dl_spinlock, flags);
      }
      {
      while (1) {
        while_36_continue: /* CIL Label */ ;
        {
        pB->i2eError = (unsigned short)0;
        }
        return (1);
        goto while_45_break;
      }
      while_36_break: /* CIL Label */ ;
      }
      while_45_break: 
      {

      }
    }
    {
    _write_unlock_irqrestore(& Dl_spinlock, flags);
    tmp___0 = mSdelay;
    mSdelay --;
    }
    if (tmp___0 == 0) {
      goto while_44_break;
    }
    {
    (*(pB->i2eDelay))(1U);
    }
  }
  while_35_break: /* CIL Label */ ;
  }
  while_44_break: 
  {

  }
  {
  while (1) {
    while_37_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)10;
    }
    return (0);
    goto while_46_break;
  }
  while_37_break: /* CIL Label */ ;
  }
  while_46_break: 
  {

  }
  return (0);
}
}
static int iiWaitForTxEmptyIIEX(i2eBordStrPtr pB , int mSdelay ) 
{ unsigned long flags ;
  unsigned char tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_38_continue: /* CIL Label */ ;
    {
    flags = _write_lock_irqsave(& Dl_spinlock);
    tmp = inb(pB->i2eStatus);
    }
    if ((int )tmp & 1) {
      {
      pB->i2eFifoRemains = (unsigned short volatile   )pB->i2eFifoSize;
      _write_unlock_irqrestore(& Dl_spinlock, flags);
      }
      {
      while (1) {
        while_39_continue: /* CIL Label */ ;
        {
        pB->i2eError = (unsigned short)0;
        }
        return (1);
        goto while_48_break;
      }
      while_39_break: /* CIL Label */ ;
      }
      while_48_break: 
      {

      }
    }
    {
    _write_unlock_irqrestore(& Dl_spinlock, flags);
    tmp___0 = mSdelay;
    mSdelay --;
    }
    if (tmp___0 == 0) {
      goto while_47_break;
    }
    {
    (*(pB->i2eDelay))(1U);
    }
  }
  while_38_break: /* CIL Label */ ;
  }
  while_47_break: 
  {

  }
  {
  while (1) {
    while_40_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)10;
    }
    return (0);
    goto while_49_break;
  }
  while_40_break: /* CIL Label */ ;
  }
  while_49_break: 
  {

  }
  return (0);
}
}
static int iiTxMailEmptyII(i2eBordStrPtr pB ) 
{ int port ;
  unsigned char tmp ;

  {
  {
  port = pB->i2ePointer;
  outb((unsigned char)4, port);
  tmp = inb(port);
  }
  return ((int )tmp == 0);
}
}
static int iiTxMailEmptyIIEX(i2eBordStrPtr pB ) 
{ unsigned char tmp ;
  int tmp___0 ;

  {
  {
  tmp = inb(pB->i2eStatus);
  }
  if ((int )tmp & 128) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  return (tmp___0);
}
}
static int iiTrySendMailII(i2eBordStrPtr pB , unsigned char mail ) 
{ int port ;
  unsigned char tmp ;

  {
  {
  port = pB->i2ePointer;
  outb((unsigned char)4, port);
  tmp = inb(port);
  }
  if ((int )tmp == 0) {
    {
    outb((unsigned char)4, port);
    outb(mail, port);
    }
    return (1);
  }
  return (0);
}
}
static int iiTrySendMailIIEX(i2eBordStrPtr pB , unsigned char mail ) 
{ unsigned char tmp ;

  {
  {
  tmp = inb(pB->i2eStatus);
  }
  if ((int )tmp & 128) {
    return (0);
  }
  {
  outb(mail, pB->i2eXMail);
  }
  return (1);
}
}
static unsigned short iiGetMailII(i2eBordStrPtr pB ) 
{ unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
  tmp___0 = inb(pB->i2eStatus);
  }
  if ((int )tmp___0 & 4) {
    {
    outb((unsigned char)6, pB->i2ePointer);
    tmp = inb(pB->i2ePointer);
    }
    return ((unsigned short )tmp);
  } else {
    return ((unsigned short)4369);
  }
}
}
static unsigned short iiGetMailIIEX(i2eBordStrPtr pB ) 
{ unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
  tmp___0 = inb(pB->i2eStatus);
  }
  if ((int )tmp___0 & 4) {
    {
    tmp = inb(pB->i2eXMail);
    }
    return ((unsigned short )tmp);
  } else {
    return ((unsigned short)4369);
  }
}
}
static void iiEnableMailIrqII(i2eBordStrPtr pB ) 
{ 

  {
  {
  outb((unsigned char)2, pB->i2ePointer);
  outb((unsigned char)4, pB->i2ePointer);
  }
  return;
}
}
static void iiEnableMailIrqIIEX(i2eBordStrPtr pB ) 
{ 

  {
  {
  outb((unsigned char)64, pB->i2eXMask);
  }
  return;
}
}
static void iiWriteMaskII(i2eBordStrPtr pB , unsigned char value ) 
{ 

  {
  {
  outb((unsigned char)2, pB->i2ePointer);
  outb(value, pB->i2ePointer);
  }
  return;
}
}
static void iiWriteMaskIIEX(i2eBordStrPtr pB , unsigned char value ) 
{ 

  {
  {
  outb(value, pB->i2eXMask);
  }
  return;
}
}
static int iiDownloadBlock(i2eBordStrPtr pB , loadHdrStrPtr pSource , int isStandard ) 
{ int itemp ;
  int loadedFirst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;

  {
  if ((int )pB->i2eValid != 16977) {
    return (0);
  }
  if ((int )pB->i2eState == 2) {
    goto switch_50_2;
  } else {
    if ((int )pB->i2eState == 3) {
      goto switch_50_3;
    } else {
      goto switch_50_default;
      if (0) {
        switch_50_2: 
        if ((int )pSource->e.loadMagic != 60) {
          return (4);
        }
        {
        pB->i2eToLoad = (short )(1 + (int )pSource->e.loadBlocksMore);
        pB->i2eState = (unsigned char)3;
        pB->i2eLVersion = pSource->e.loadVersion;
        pB->i2eLRevision = pSource->e.loadRevision;
        pB->i2eLSub = pSource->e.loadSubRevision;
        loadedFirst = 1;
        }
        goto switch_50_break;
        switch_50_3: 
        {
        loadedFirst = 0;
        }
        goto switch_50_break;
        switch_50_default: 
        {

        }
        return (5);
      } else {
        switch_50_break: 
        {

        }
      }
    }
  }
  {
  tmp = (*(pB->i2eWaitForTxEmpty))(pB, 100);
  }
  if (! tmp) {
    return (6);
  }
  {
  tmp___0 = (*(pB->i2eWriteBuf))(pB, pSource->c, 512);
  }
  if (! tmp___0) {
    return (0);
  }
  if (loadedFirst) {
    {
    tmp___1 = (*(pB->i2eWaitForTxEmpty))(pB, 1000);
    }
    if (! tmp___1) {
      return (6);
    }
  }
  {
  pB->i2eToLoad = (short )((int )pB->i2eToLoad - 1);
  }
  if (pB->i2eToLoad) {
    return (1);
  }
  {
  tmp___2 = (*(pB->i2eWaitForTxEmpty))(pB, 100);
  }
  if (! tmp___2) {
    return (6);
  }
  {
  itemp = 10;
  }
  {
  while (1) {
    while_41_continue: /* CIL Label */ ;
    {
    itemp --;
    }
    if (! itemp) {
      goto while_51_break;
    }
    {
    tmp___4 = inb(pB->i2eStatus);
    }
    if (! ((int )tmp___4 & 32)) {
      {
      tmp___3 = inb(pB->i2eData);
      }
      if ((int )tmp___3 == 195) {
        goto switch_52_195;
      } else {
        if ((int )tmp___3 == 90) {
          goto switch_52_90;
        } else {
          goto switch_52_90;
          if (0) {
            switch_52_195: 
            if (isStandard) {
              {
              pB->i2eState = (unsigned char)6;
              }
            } else {
              {
              pB->i2eState = (unsigned char)4;
              }
            }
            if ((int )pB->i2ePom.e.porDiag2 & 128) {
              {
              (*(pB->i2eDelay))(700U);
              }
            }
            return (2);
            switch_52_90: 
            {

            }
            return (3);
          } else {
            {

            }
          }
        }
      }
    }
    {
    (*(pB->i2eDelay))(10U);
    }
  }
  while_41_break: /* CIL Label */ ;
  }
  while_51_break: 
  {
  pB->i2eState = (unsigned char)5;
  }
  return (6);
}
}
static int iiDownloadAll(i2eBordStrPtr pB , loadHdrStrPtr pSource , int isStandard ,
                         int size ) 
{ int status ;
  loadHdrStrPtr tmp ;
  int tmp___0 ;

  {
  if ((int )pB->i2eState != 2) {
    return (5);
  }
  {
  while (1) {
    while_42_continue: /* CIL Label */ ;
    {

    }
    if (! (size > 0)) {
      goto while_53_break;
    }
    {
    size -= 512;
    tmp = pSource;
    pSource ++;
    status = iiDownloadBlock(pB, tmp, isStandard);
    }
    if (status == 2) {
      goto switch_54_2;
    } else {
      if (status == 1) {
        goto switch_54_1;
      } else {
        goto switch_54_default;
        if (0) {
          switch_54_2: 
          if (size > 0) {
            {
            tmp___0 = 7;
            }
          } else {
            {
            tmp___0 = 2;
            }
          }
          return (tmp___0);
          switch_54_1: 
          goto switch_54_break;
          switch_54_default: 
          {

          }
          return (status);
        } else {
          switch_54_break: 
          {

          }
        }
      }
    }
  }
  while_42_break: /* CIL Label */ ;
  }
  while_53_break: 
  {

  }
  return (8);
}
}
static UCHAR ct02[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)2};
static UCHAR ct03[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)3};
static UCHAR ct04[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)4};
static UCHAR ct05[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)5};
static UCHAR ct06[3]  = {      (unsigned char)1,      (unsigned char)2,      (unsigned char)6};
static UCHAR ct07[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)7,      (unsigned char)0};
static UCHAR ct08[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)8,      (unsigned char)0};
static UCHAR ct09[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)9,      (unsigned char)0};
static UCHAR ct10[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)10,      (unsigned char)0};
static UCHAR ct11[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)11,      (unsigned char)0};
static UCHAR ct12[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)12,      (unsigned char)0};
static UCHAR ct13[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)13};
static UCHAR ct14[3]  = {      (unsigned char)1,      (unsigned char)10,      (unsigned char)14};
static UCHAR ct16[4]  = {      (unsigned char)2,      (unsigned char)1,      (unsigned char)16,      (unsigned char)0};
static UCHAR ct17[4]  = {      (unsigned char)2,      (unsigned char)1,      (unsigned char)17,      (unsigned char)0};
static UCHAR ct18[3]  = {      (unsigned char)1,      (unsigned char)1,      (unsigned char)18};
static UCHAR ct19[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)19};
static UCHAR ct20[3]  = {      (unsigned char)1,      (unsigned char)1,      (unsigned char)20};
static UCHAR ct21[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)21};
static UCHAR ct22[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)22};
static UCHAR ct23[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)23};
static UCHAR ct24[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)24};
static UCHAR ct25[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)25};
static UCHAR ct26[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)26,      (unsigned char)0};
static UCHAR ct27[3]  = {      (unsigned char)1,      (unsigned char)3,      (unsigned char)27};
static UCHAR ct30[3]  = {      (unsigned char)1,      (unsigned char)1,      (unsigned char)30};
static UCHAR ct31[3]  = {      (unsigned char)1,      (unsigned char)1,      (unsigned char)31};
static UCHAR ct32[3]  = {      (unsigned char)1,      (unsigned char)1,      (unsigned char)32};
static UCHAR ct33[3]  = {      (unsigned char)1,      (unsigned char)1,      (unsigned char)33};
static UCHAR ct34[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)34,      (unsigned char)0};
static UCHAR ct35[4]  = {      (unsigned char)2,      (unsigned char)7,      (unsigned char)35,      (unsigned char)0};
static UCHAR ct36[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)36,      (unsigned char)0};
static UCHAR ct41[3]  = {      (unsigned char)1,      (unsigned char)2,      (unsigned char)41};
static UCHAR ct54[5]  = {      (unsigned char)3,      (unsigned char)3,      (unsigned char)54,      (unsigned char)0, 
        (unsigned char)0};
static UCHAR ct55[5]  = {      (unsigned char)3,      (unsigned char)3,      (unsigned char)55,      (unsigned char)0, 
        (unsigned char)0};
static UCHAR ct56[4]  = {      (unsigned char)2,      (unsigned char)7,      (unsigned char)56,      (unsigned char)0};
static UCHAR ct57[3]  = {      (unsigned char)1,      (unsigned char)2,      (unsigned char)57};
static UCHAR ct58[3]  = {      (unsigned char)1,      (unsigned char)2,      (unsigned char)58};
static UCHAR ct59[4]  = {      (unsigned char)2,      (unsigned char)3,      (unsigned char)59,      (unsigned char)0};
static UCHAR ct60[3]  = {      (unsigned char)1,      (unsigned char)9,      (unsigned char)60};
static UCHAR ct63[4]  = {      (unsigned char)2,      (unsigned char)1,      (unsigned char)63,      (unsigned char)0};
static UCHAR ct64[4]  = {      (unsigned char)2,      (unsigned char)1,      (unsigned char)64,      (unsigned char)0};
static UCHAR ct79[4]  = {      (unsigned char)2,      (unsigned char)2,      (unsigned char)79,      (unsigned char)0};
static UCHAR ct87[3]  = {      (unsigned char)1,      (unsigned char)2,      (unsigned char)87};
static cmdSyntaxPtr i2cmdBaudDef(int which , unsigned short rate ) 
{ cmdSyntaxPtr pCM ;

  {
  if (which == 1) {
    goto switch_55_1;
  } else {
    if (which == 2) {
      goto switch_55_2;
    } else {
      goto switch_55_default;
      if (0) {
        switch_55_1: 
        {
        pCM = (struct _cmdSyntax *)(ct54);
        }
        goto switch_55_break;
        switch_55_default: 
        {

        }
        switch_55_2: 
        {
        pCM = (struct _cmdSyntax *)(ct55);
        }
        goto switch_55_break;
      } else {
        switch_55_break: 
        {

        }
      }
    }
  }
  {
  pCM->cmd[1] = (unsigned char )rate;
  pCM->cmd[2] = (unsigned char )((int )rate >> 8);
  }
  return (pCM);
}
}
static void i2QueueNeeds(i2eBordStrPtr pB , i2ChanStrPtr pCh , int type ) ;
static i2ChanStrPtr i2DeQueueNeeds(i2eBordStrPtr pB , int type ) ;
__inline static void ( __attribute__((__always_inline__)) i2StripFifo)(i2eBordStrPtr pB ) ;
__inline static void ( __attribute__((__always_inline__)) i2StuffFifoBypass)(i2eBordStrPtr pB ) ;
__inline static void ( __attribute__((__always_inline__)) i2StuffFifoFlow)(i2eBordStrPtr pB ) ;
__inline static void ( __attribute__((__always_inline__)) i2StuffFifoInline)(i2eBordStrPtr pB ) ;
static int i2RetryFlushOutput(i2ChanStrPtr pCh ) ;
static void iiSendPendingMail(i2eBordStrPtr pB ) ;
static void serviceOutgoingFifo(i2eBordStrPtr pB ) ;
__inline static int ( __attribute__((__always_inline__)) i2Validate)(i2ChanStrPtr pCh ) 
{ 

  {
  return (((int )pCh->validity & 65281) == 21249);
}
}
static void iiSendPendingMail_t(unsigned long data ) 
{ i2eBordStrPtr pB ;

  {
  {
  pB = (struct _i2eBordStr *)data;
  iiSendPendingMail(pB);
  }
  return;
}
}
static void iiSendPendingMail(i2eBordStrPtr pB ) 
{ int tmp ;

  {
  if (pB->i2eOutMailWaiting) {
    if (! pB->i2eWaitingForEmptyFifo) {
      {
      tmp = (*(pB->i2eTrySendMail))(pB, pB->i2eOutMailWaiting);
      }
      if (tmp) {
        {
        pB->i2eWaitingForEmptyFifo = (unsigned char )((int )pB->i2eWaitingForEmptyFifo | ((int )pB->i2eOutMailWaiting & 128));
        pB->i2eOutMailWaiting = (unsigned char)0;
        pB->SendPendingRetry = 0U;
        }
      } else {
        {
        (pB->SendPendingRetry) ++;
        }
        if (pB->SendPendingRetry < 16U) {
          {
          setup_timer(& pB->SendPendingTimer, & iiSendPendingMail_t, (unsigned long )pB);
          mod_timer(& pB->SendPendingTimer, (unsigned long )(jiffies + (unsigned long volatile   )1));
          }
        } else {
          {
          printk("<3>IP2: iiSendPendingMail unable to queue outbound mail\n");
          }
        }
      }
    }
  }
  return;
}
}
static int i2InitChannels(i2eBordStrPtr pB , int nChannels , i2ChanStrPtr pCh ) 
{ int index ;
  int stuffIndex ;
  i2ChanStrPtr *ppCh ;
  rwlock_t __constr_expr_0 ;
  rwlock_t __constr_expr_1 ;
  rwlock_t __constr_expr_2 ;
  rwlock_t __constr_expr_3 ;
  rwlock_t __constr_expr_4 ;
  unsigned short volatile   tmp ;
  unsigned short volatile   tmp___0 ;
  unsigned short volatile   tmp___1 ;
  rwlock_t __constr_expr_5 ;
  rwlock_t __constr_expr_6 ;
  rwlock_t __constr_expr_7 ;
  rwlock_t __constr_expr_8 ;
  i2ChanStrPtr *tmp___2 ;
  USHORT volatile   tmp___3 ;
  USHORT volatile   tmp___4 ;
  USHORT volatile   tmp___5 ;
  atomic_long_t __constr_expr_9 ;
  atomic_long_t __constr_expr_10 ;

  {
  if ((int )pB->i2eValid != 16977) {
    {
    while (1) {
      while_43_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)3;
      }
      return (0);
      goto while_56_break;
    }
    while_43_break: /* CIL Label */ ;
    }
    while_56_break: 
    {

    }
  }
  if ((int )pB->i2eState != 6) {
    {
    while (1) {
      while_44_continue: /* CIL Label */ ;
      {
      pB->i2eError = (unsigned short)2;
      }
      return (0);
      goto while_57_break;
    }
    while_44_break: /* CIL Label */ ;
    }
    while_57_break: 
    {

    }
  }
  {
  while (1) {
    while_45_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.lock = 16777216U;
    pB->read_fifo_spinlock = __constr_expr_0;
    }
    goto while_58_break;
  }
  while_45_break: /* CIL Label */ ;
  }
  while_58_break: 
  {

  }
  {
  while (1) {
    while_46_continue: /* CIL Label */ ;
    {
    __constr_expr_1.raw_lock.lock = 16777216U;
    pB->write_fifo_spinlock = __constr_expr_1;
    }
    goto while_59_break;
  }
  while_46_break: /* CIL Label */ ;
  }
  while_59_break: 
  {

  }
  {
  while (1) {
    while_47_continue: /* CIL Label */ ;
    {
    __constr_expr_2.raw_lock.lock = 16777216U;
    pB->Dbuf_spinlock = __constr_expr_2;
    }
    goto while_60_break;
  }
  while_47_break: /* CIL Label */ ;
  }
  while_60_break: 
  {

  }
  {
  while (1) {
    while_48_continue: /* CIL Label */ ;
    {
    __constr_expr_3.raw_lock.lock = 16777216U;
    pB->Bbuf_spinlock = __constr_expr_3;
    }
    goto while_61_break;
  }
  while_48_break: /* CIL Label */ ;
  }
  while_61_break: 
  {

  }
  {
  while (1) {
    while_49_continue: /* CIL Label */ ;
    {
    __constr_expr_4.raw_lock.lock = 16777216U;
    pB->Fbuf_spinlock = __constr_expr_4;
    }
    goto while_62_break;
  }
  while_49_break: /* CIL Label */ ;
  }
  while_62_break: 
  {
  pB->i2eChannelPtr = (void *)pCh;
  pB->i2eChannelCnt = (unsigned short )nChannels;
  tmp = (unsigned short volatile   )0;
  pB->i2Fbuf_stuff = tmp;
  pB->i2Fbuf_strip = tmp;
  tmp___0 = (unsigned short volatile   )0;
  pB->i2Dbuf_stuff = tmp___0;
  pB->i2Dbuf_strip = tmp___0;
  tmp___1 = (unsigned short volatile   )0;
  pB->i2Bbuf_stuff = tmp___1;
  pB->i2Bbuf_strip = tmp___1;
  pB->SendPendingRetry = 0U;
  __constant_c_memset((void *)pCh, 0UL, sizeof(i2ChanStr ) * (unsigned int )nChannels);
  stuffIndex = 0;
  index = stuffIndex;
  ppCh = (i2ChanStrPtr *)(pB->i2Fbuf);
  }
  {
  while (1) {
    while_50_continue: /* CIL Label */ ;
    {

    }
    if (nChannels) {
      if (! (index < 64)) {
        goto while_63_break;
      }
    } else {
      goto while_63_break;
    }
    if (! ((int )pB->i2eChannelMap[index >> 4] & (1 << (index & 15)))) {
      goto __Cont;
    }
    {
    while (1) {
      while_51_continue: /* CIL Label */ ;
      {
      __constr_expr_5.raw_lock.lock = 16777216U;
      pCh->Ibuf_spinlock = __constr_expr_5;
      }
      goto while_64_break;
    }
    while_51_break: /* CIL Label */ ;
    }
    while_64_break: 
    {

    }
    {
    while (1) {
      while_52_continue: /* CIL Label */ ;
      {
      __constr_expr_6.raw_lock.lock = 16777216U;
      pCh->Obuf_spinlock = __constr_expr_6;
      }
      goto while_65_break;
    }
    while_52_break: /* CIL Label */ ;
    }
    while_65_break: 
    {

    }
    {
    while (1) {
      while_53_continue: /* CIL Label */ ;
      {
      __constr_expr_7.raw_lock.lock = 16777216U;
      pCh->Cbuf_spinlock = __constr_expr_7;
      }
      goto while_66_break;
    }
    while_53_break: /* CIL Label */ ;
    }
    while_66_break: 
    {

    }
    {
    while (1) {
      while_54_continue: /* CIL Label */ ;
      {
      __constr_expr_8.raw_lock.lock = 16777216U;
      pCh->Pbuf_spinlock = __constr_expr_8;
      }
      goto while_67_break;
    }
    while_54_break: /* CIL Label */ ;
    }
    while_67_break: 
    {

    }
    if ((int )pB->i2eGoodMap[index >> 4] & (1 << (index & 15))) {
      {
      pCh->validity = (unsigned short)21249;
      }
    } else {
      {
      pCh->validity = (unsigned short)21248;
      }
    }
    {
    pCh->pMyBord = pB;
    }
    if ((int )pCh->validity & 1) {
      {
      pCh->infl.hd.i2sChannel = (unsigned char volatile   )index;
      pCh->infl.hd.i2sCount = (unsigned int volatile   )5;
      pCh->infl.hd.i2sType = (unsigned int volatile   )1;
      pCh->infl.fcmd = (unsigned char volatile   )37;
      pCh->infl.asof = (unsigned short volatile   )0;
      pCh->infl.room = (unsigned short volatile   )511;
      pCh->whenSendFlow = (unsigned short)408;
      pCh->channelNeeds = (unsigned short)1;
      pCh->sinceLastFlow = (unsigned short)0;
      stuffIndex ++;
      tmp___2 = ppCh;
      ppCh ++;
      *tmp___2 = pCh;
      }
    }
    {
    pCh->outfl.asof = (unsigned short volatile   )0;
    pCh->outfl.room = (unsigned short volatile   )0;
    tmp___3 = (unsigned short volatile   )0;
    pCh->Ibuf_strip = tmp___3;
    pCh->Ibuf_stuff = tmp___3;
    tmp___4 = (unsigned short volatile   )0;
    pCh->Obuf_strip = tmp___4;
    pCh->Obuf_stuff = tmp___4;
    tmp___5 = (unsigned short volatile   )0;
    pCh->Cbuf_strip = tmp___5;
    pCh->Cbuf_stuff = tmp___5;
    __constant_c_and_count_memset((void *)(& pCh->icount), 0UL, sizeof(struct async_icount ));
    pCh->hotKeyIn = (unsigned short)4898;
    pCh->channelOptions = (unsigned short)0;
    pCh->bookMarks = (short)0;
    init_waitqueue_head(& pCh->pBookmarkWait);
    init_waitqueue_head(& pCh->open_wait);
    init_waitqueue_head(& pCh->close_wait);
    init_waitqueue_head(& pCh->delta_msr_wait);
    pCh->BaudBase = 921600;
    pCh->BaudDivisor = 96;
    pCh->dataSetIn = (unsigned short)0;
    pCh->dataSetOut = (unsigned short)0;
    pCh->wopen = 0;
    pCh->throttled = 0;
    pCh->speed = 13;
    pCh->flags = 0;
    pCh->ClosingDelay = (unsigned short)125;
    pCh->ClosingWaitTime = (unsigned short)7500;
    }
    {
    while (1) {
      while_55_continue: /* CIL Label */ ;
      {
      __constr_expr_9.counter = 0;
      pCh->tqueue_input.data = __constr_expr_9;
      INIT_LIST_HEAD(& pCh->tqueue_input.entry);
      }
      {
      while (1) {
        while_56_continue: /* CIL Label */ ;
        {
        pCh->tqueue_input.func = & do_input;
        }
        goto while_69_break;
      }
      while_56_break: /* CIL Label */ ;
      }
      while_69_break: 
      {

      }
      goto while_68_break;
    }
    while_55_break: /* CIL Label */ ;
    }
    while_68_break: 
    {

    }
    {
    while (1) {
      while_57_continue: /* CIL Label */ ;
      {
      __constr_expr_10.counter = 0;
      pCh->tqueue_status.data = __constr_expr_10;
      INIT_LIST_HEAD(& pCh->tqueue_status.entry);
      }
      {
      while (1) {
        while_58_continue: /* CIL Label */ ;
        {
        pCh->tqueue_status.func = & do_status;
        }
        goto while_71_break;
      }
      while_58_break: /* CIL Label */ ;
      }
      while_71_break: 
      {

      }
      goto while_70_break;
    }
    while_57_break: /* CIL Label */ ;
    }
    while_70_break: 
    {
    pCh ++;
    nChannels --;
    }
    __Cont: 
    {
    index ++;
    }
  }
  while_50_break: /* CIL Label */ ;
  }
  while_63_break: 
  {
  pB->i2Fbuf_stuff = (unsigned short volatile   )stuffIndex;
  }
  {
  while (1) {
    while_59_continue: /* CIL Label */ ;
    {
    pB->i2eError = (unsigned short)0;
    }
    return (1);
    goto while_72_break;
  }
  while_59_break: /* CIL Label */ ;
  }
  while_72_break: 
  {

  }
  return (0);
}
}
static i2ChanStrPtr i2DeQueueNeeds(i2eBordStrPtr pB , int type ) 
{ unsigned short queueIndex ;
  unsigned long flags ;
  i2ChanStrPtr pCh ;

  {
  {
  pCh = (struct _i2ChanStr *)((void *)0);
  }
  if (type == 2) {
    goto switch_73_2;
  } else {
    if (type == 4) {
      goto switch_73_4;
    } else {
      if (type == 1) {
        goto switch_73_1;
      } else {
        goto switch_73_default;
        if (0) {
          switch_73_2: 
          {
          flags = _write_lock_irqsave(& pB->Dbuf_spinlock);
          }
          if ((int volatile   )pB->i2Dbuf_stuff != (int volatile   )pB->i2Dbuf_strip) {
            {
            queueIndex = (unsigned short )pB->i2Dbuf_strip;
            pCh = (struct _i2ChanStr *)pB->i2Dbuf[queueIndex];
            queueIndex = (unsigned short )((int )queueIndex + 1);
            }
            if ((int )queueIndex >= 66) {
              {
              queueIndex = (unsigned short)0;
              }
            }
            {
            pB->i2Dbuf_strip = (unsigned short volatile   )queueIndex;
            pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds & -3);
            }
          }
          {
          _write_unlock_irqrestore(& pB->Dbuf_spinlock, flags);
          }
          goto switch_73_break;
          switch_73_4: 
          {
          flags = _write_lock_irqsave(& pB->Bbuf_spinlock);
          }
          if ((int volatile   )pB->i2Bbuf_stuff != (int volatile   )pB->i2Bbuf_strip) {
            {
            queueIndex = (unsigned short )pB->i2Bbuf_strip;
            pCh = (struct _i2ChanStr *)pB->i2Bbuf[queueIndex];
            queueIndex = (unsigned short )((int )queueIndex + 1);
            }
            if ((int )queueIndex >= 66) {
              {
              queueIndex = (unsigned short)0;
              }
            }
            {
            pB->i2Bbuf_strip = (unsigned short volatile   )queueIndex;
            pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds & -5);
            }
          }
          {
          _write_unlock_irqrestore(& pB->Bbuf_spinlock, flags);
          }
          goto switch_73_break;
          switch_73_1: 
          {
          flags = _write_lock_irqsave(& pB->Fbuf_spinlock);
          }
          if ((int volatile   )pB->i2Fbuf_stuff != (int volatile   )pB->i2Fbuf_strip) {
            {
            queueIndex = (unsigned short )pB->i2Fbuf_strip;
            pCh = (struct _i2ChanStr *)pB->i2Fbuf[queueIndex];
            queueIndex = (unsigned short )((int )queueIndex + 1);
            }
            if ((int )queueIndex >= 66) {
              {
              queueIndex = (unsigned short)0;
              }
            }
            {
            pB->i2Fbuf_strip = (unsigned short volatile   )queueIndex;
            pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds & -2);
            }
          }
          {
          _write_unlock_irqrestore(& pB->Fbuf_spinlock, flags);
          }
          goto switch_73_break;
          switch_73_default: 
          {
          printk("<3>i2DeQueueNeeds called with bad type:%x\n", type);
          }
          goto switch_73_break;
        } else {
          switch_73_break: 
          {

          }
        }
      }
    }
  }
  return (pCh);
}
}
static void i2QueueNeeds(i2eBordStrPtr pB , i2ChanStrPtr pCh , int type ) 
{ unsigned short queueIndex ;
  unsigned long flags ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;

  {
  if (type == 2) {
    goto switch_74_2;
  } else {
    if (type == 4) {
      goto switch_74_4;
    } else {
      if (type == 1) {
        goto switch_74_1;
      } else {
        if (type == 8) {
          goto switch_74_8;
        } else {
          goto switch_74_default;
          if (0) {
            switch_74_2: 
            {
            flags = _write_lock_irqsave(& pB->Dbuf_spinlock);
            }
            if (! ((int )pCh->channelNeeds & 2)) {
              {
              pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds | 2);
              queueIndex = (unsigned short )pB->i2Dbuf_stuff;
              tmp = queueIndex;
              queueIndex = (unsigned short )((int )queueIndex + 1);
              pB->i2Dbuf[tmp] = (void *)pCh;
              }
              if ((int )queueIndex >= 66) {
                {
                queueIndex = (unsigned short)0;
                }
              }
              {
              pB->i2Dbuf_stuff = (unsigned short volatile   )queueIndex;
              }
            }
            {
            _write_unlock_irqrestore(& pB->Dbuf_spinlock, flags);
            }
            goto switch_74_break;
            switch_74_4: 
            {
            flags = _write_lock_irqsave(& pB->Bbuf_spinlock);
            }
            if (type & 4) {
              if (! ((int )pCh->channelNeeds & 4)) {
                {
                pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds | 4);
                queueIndex = (unsigned short )pB->i2Bbuf_stuff;
                tmp___0 = queueIndex;
                queueIndex = (unsigned short )((int )queueIndex + 1);
                pB->i2Bbuf[tmp___0] = (void *)pCh;
                }
                if ((int )queueIndex >= 66) {
                  {
                  queueIndex = (unsigned short)0;
                  }
                }
                {
                pB->i2Bbuf_stuff = (unsigned short volatile   )queueIndex;
                }
              }
            }
            {
            _write_unlock_irqrestore(& pB->Bbuf_spinlock, flags);
            }
            goto switch_74_break;
            switch_74_1: 
            {
            flags = _write_lock_irqsave(& pB->Fbuf_spinlock);
            }
            if (type & 1) {
              if (! ((int )pCh->channelNeeds & 1)) {
                {
                pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds | 1);
                queueIndex = (unsigned short )pB->i2Fbuf_stuff;
                tmp___1 = queueIndex;
                queueIndex = (unsigned short )((int )queueIndex + 1);
                pB->i2Fbuf[tmp___1] = (void *)pCh;
                }
                if ((int )queueIndex >= 66) {
                  {
                  queueIndex = (unsigned short)0;
                  }
                }
                {
                pB->i2Fbuf_stuff = (unsigned short volatile   )queueIndex;
                }
              }
            }
            {
            _write_unlock_irqrestore(& pB->Fbuf_spinlock, flags);
            }
            goto switch_74_break;
            switch_74_8: 
            {
            pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds | 8);
            }
            goto switch_74_break;
            switch_74_default: 
            {
            printk("<3>i2QueueNeeds called with bad type:%x\n", type);
            }
            goto switch_74_break;
          } else {
            switch_74_break: 
            {

            }
          }
        }
      }
    }
  }
  return;
}
}
static int i2QueueCommands(int type , i2ChanStrPtr pCh , int timeout , int nCommands ,
                           cmdSyntaxPtr pCs0  , ...) 
{ int totalsize ;
  int blocksize ;
  int lastended ;
  cmdSyntaxPtr *ppCs ;
  cmdSyntaxPtr pCs ;
  int count ;
  int flag ;
  i2eBordStrPtr pB ;
  unsigned short maxBlock ;
  unsigned short maxBuff ;
  short bufroom ;
  unsigned short stuffIndex ;
  unsigned char *pBuf ;
  unsigned char *pInsert ;
  unsigned char *pDest ;
  unsigned char *pSource ;
  unsigned short channel ;
  int cnt ;
  unsigned long flags ;
  rwlock_t *lock_var_p ;
  int tmp ;
  int tmp___0 ;
  struct thread_info *tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;

  {
  {
  totalsize = 0;
  flags = 0UL;
  lock_var_p = (rwlock_t *)((void *)0);
  tmp = i2Validate(pCh);
  }
  if (! tmp) {
    return (-1);
  }
  {
  while (1) {
    while_60_continue: /* CIL Label */ ;
    {

    }
    goto while_75_break;
  }
  while_60_break: /* CIL Label */ ;
  }
  while_75_break: 
  {
  pB = pCh->pMyBord;
  }
  if ((int )pB->i2eValid != 16977) {
    return (-2);
  } else {
    if ((int )pB->i2eUsingIrq == 4946) {
      return (-2);
    }
  }
  if (pB->i2eFatal) {
    if (pB->i2eFatalTrap) {
      {
      (*(pB->i2eFatalTrap))(pB);
      }
    }
    return (-3);
  }
  if (type == 2) {
    goto switch_76_2;
  } else {
    if (type == 1) {
      goto switch_76_1;
    } else {
      goto switch_76_default;
      if (0) {
        switch_76_2: 
        {
        flag = 1;
        maxBlock = (unsigned short)36;
        maxBuff = (unsigned short)1024;
        pBuf = pCh->Obuf;
        }
        goto switch_76_break;
        switch_76_1: 
        {
        flag = 2;
        maxBlock = (unsigned short)6;
        maxBuff = (unsigned short)10;
        pBuf = pCh->Cbuf;
        }
        goto switch_76_break;
        switch_76_default: 
        {

        }
        return (-4);
      } else {
        switch_76_break: 
        {

        }
      }
    }
  }
  {
  blocksize = (int )sizeof(i2CmdHeader );
  totalsize = blocksize;
  lastended = 0;
  ppCs = & pCs0;
  count = nCommands;
  }
  {
  while (1) {
    while_61_continue: /* CIL Label */ ;
    {

    }
    if (! count) {
      goto while_77_break;
    }
    {
    pCs = *ppCs;
    cnt = (int )pCs->length;
    }
    if (blocksize + cnt > (int )maxBlock) {
      {
      blocksize = (int )sizeof(i2CmdHeader );
      totalsize = (int )((unsigned int )totalsize + sizeof(i2CmdHeader ));
      }
    } else {
      if (lastended) {
        {
        blocksize = (int )sizeof(i2CmdHeader );
        totalsize = (int )((unsigned int )totalsize + sizeof(i2CmdHeader ));
        }
      }
    }
    {
    totalsize += cnt;
    blocksize += cnt;
    lastended = (int )pCs->flags & 4;
    count --;
    ppCs ++;
    }
  }
  while_61_break: /* CIL Label */ ;
  }
  while_77_break: 
  {

  }
  {
  while (1) {
    while_62_continue: /* CIL Label */ ;
    {

    }
    if (pCh->flush_flags) {
      {
      tmp___0 = i2RetryFlushOutput(pCh);
      }
      if (tmp___0) {
        {
        while (1) {
          while_63_continue: /* CIL Label */ ;
          {

          }
          goto while_79_break;
        }
        while_63_break: /* CIL Label */ ;
        }
        while_79_break: 
        {

        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (type == 2) {
        goto switch_80_2;
      } else {
        if (type == 1) {
          goto switch_80_1;
        } else {
          goto switch_80_default;
          if (0) {
            switch_80_2: 
            {
            lock_var_p = & pCh->Obuf_spinlock;
            flags = _write_lock_irqsave(lock_var_p);
            stuffIndex = (unsigned short )pCh->Obuf_stuff;
            bufroom = (short )((int volatile   )pCh->Obuf_strip - (int volatile   )stuffIndex);
            }
            goto switch_80_break;
            switch_80_1: 
            {
            lock_var_p = & pCh->Cbuf_spinlock;
            flags = _write_lock_irqsave(lock_var_p);
            stuffIndex = (unsigned short )pCh->Cbuf_stuff;
            bufroom = (short )((int volatile   )pCh->Cbuf_strip - (int volatile   )stuffIndex);
            }
            goto switch_80_break;
            switch_80_default: 
            {

            }
            return (-5);
          } else {
            switch_80_break: 
            {

            }
          }
        }
      }
      {
      bufroom = (short )((int )bufroom - 1);
      }
      if ((int )bufroom < 0) {
        {
        bufroom = (short )((int )bufroom + (int )maxBuff);
        }
      }
      {
      while (1) {
        while_64_continue: /* CIL Label */ ;
        {

        }
        goto while_81_break;
      }
      while_64_break: /* CIL Label */ ;
      }
      while_81_break: 
      {

      }
      if (totalsize <= (int )bufroom) {
        goto while_78_break;
      }
      {
      while (1) {
        while_65_continue: /* CIL Label */ ;
        {

        }
        goto while_82_break;
      }
      while_65_break: /* CIL Label */ ;
      }
      while_82_break: 
      {
      _write_unlock_irqrestore(lock_var_p, flags);
      }
    }
    {
    serviceOutgoingFifo(pB);
    }
    if (timeout == 0) {
      return (0);
    }
    if (timeout > 0) {
      {
      timeout --;
      }
    }
    {
    tmp___1 = current_thread_info();
    }
    if ((unsigned long )tmp___1->preempt_count & ((((1UL << 12) - 1UL) << 16) | (((1UL << 8) - 1UL) << 8))) {
      return (0);
    } else {
      {
      schedule_timeout_interruptible(1L);
      }
    }
    {
    tmp___2 = get_current();
    tmp___3 = signal_pending(tmp___2);
    }
    if (tmp___3) {
      return (0);
    }
    {
    while (1) {
      while_66_continue: /* CIL Label */ ;
      {

      }
      goto while_83_break;
    }
    while_66_break: /* CIL Label */ ;
    }
    while_83_break: 
    {

    }
  }
  while_62_break: /* CIL Label */ ;
  }
  while_78_break: 
  {
  channel = (unsigned short )pCh->infl.hd.i2sChannel;
  pInsert = pBuf + (int )stuffIndex;
  pDest = pInsert + 2;
  blocksize = (int )sizeof(i2CmdHeader );
  count = nCommands;
  lastended = 0;
  ppCs = & pCs0;
  }
  {
  while (1) {
    while_67_continue: /* CIL Label */ ;
    {

    }
    if (! count) {
      goto while_84_break;
    }
    {
    pCs = *ppCs;
    }
    if ((unsigned int )pCs == (unsigned int )((struct _cmdSyntax *)(ct60))) {
      {
      pCh->bookMarks = (short )((int )pCh->bookMarks + 1);
      }
      {
      while (1) {
        while_68_continue: /* CIL Label */ ;
        {

        }
        goto while_85_break;
      }
      while_68_break: /* CIL Label */ ;
      }
      while_85_break: 
      {

      }
    }
    {
    cnt = (int )pCs->length;
    }
    if (blocksize + cnt > (int )maxBlock) {
      goto _L___0;
    } else {
      if (lastended) {
        _L___0: 
        {
        while (1) {
          while_69_continue: /* CIL Label */ ;
          {

          }
          goto while_86_break;
        }
        while_69_break: /* CIL Label */ ;
        }
        while_86_break: 
        {
        ((struct _i2DataHeader *)pInsert)->i2sType = (unsigned int )type;
        ((struct _i2DataHeader *)pInsert)->i2sChannel = (unsigned char )channel;
        ((struct _i2CmdHeader *)pInsert)->i2sCount = (unsigned int )blocksize - sizeof(i2CmdHeader );
        stuffIndex = (unsigned short )((int )stuffIndex + blocksize);
        }
        if ((int )stuffIndex >= (int )maxBuff) {
          {
          stuffIndex = (unsigned short)0;
          pInsert = pBuf;
          }
        }
        {
        pInsert = pBuf + (int )stuffIndex;
        pDest = pInsert + 2;
        blocksize = (int )sizeof(i2CmdHeader );
        }
      }
    }
    {
    blocksize += cnt;
    pSource = pCs->cmd;
    }
    {
    while (1) {
      while_70_continue: /* CIL Label */ ;
      {
      tmp___6 = cnt;
      cnt --;
      }
      if (! tmp___6) {
        goto while_87_break;
      }
      {
      tmp___4 = pDest;
      pDest ++;
      tmp___5 = pSource;
      pSource ++;
      *tmp___4 = *tmp___5;
      }
    }
    while_70_break: /* CIL Label */ ;
    }
    while_87_break: 
    {
    lastended = (int )pCs->flags & 4;
    count --;
    ppCs ++;
    }
  }
  while_67_break: /* CIL Label */ ;
  }
  while_84_break: 
  {
  ((struct _i2DataHeader *)pInsert)->i2sType = (unsigned int )type;
  ((struct _i2DataHeader *)pInsert)->i2sChannel = (unsigned char )channel;
  ((struct _i2CmdHeader *)pInsert)->i2sCount = (unsigned int )blocksize - sizeof(i2CmdHeader );
  stuffIndex = (unsigned short )((int )stuffIndex + blocksize);
  }
  if ((int )stuffIndex >= (int )maxBuff) {
    {
    stuffIndex = (unsigned short)0;
    pInsert = pBuf;
    }
  }
  if (type == 2) {
    goto switch_88_2;
  } else {
    if (type == 1) {
      goto switch_88_1;
    } else {
      if (0) {
        switch_88_2: 
        {
        pCh->Obuf_stuff = (unsigned short volatile   )stuffIndex;
        _write_unlock_irqrestore(& pCh->Obuf_spinlock, flags);
        (pB->debugInlineQueued) ++;
        i2QueueNeeds(pB, pCh, 2);
        }
        goto switch_88_break;
        switch_88_1: 
        {
        pCh->Cbuf_stuff = (unsigned short volatile   )stuffIndex;
        _write_unlock_irqrestore(& pCh->Cbuf_spinlock, flags);
        (pB->debugBypassQueued) ++;
        i2QueueNeeds(pB, pCh, 4);
        }
        goto switch_88_break;
      } else {
        switch_88_break: 
        {

        }
      }
    }
  }
  {
  while (1) {
    while_71_continue: /* CIL Label */ ;
    {

    }
    goto while_89_break;
  }
  while_71_break: /* CIL Label */ ;
  }
  while_89_break: 
  {

  }
  return (nCommands);
}
}
static int i2GetStatus(i2ChanStrPtr pCh , int resetBits ) 
{ unsigned short status ;
  i2eBordStrPtr pB ;
  int tmp ;

  {
  {
  while (1) {
    while_72_continue: /* CIL Label */ ;
    {

    }
    goto while_90_break;
  }
  while_72_break: /* CIL Label */ ;
  }
  while_90_break: 
  {
  tmp = i2Validate(pCh);
  }
  if (! tmp) {
    return (-1);
  }
  {
  pB = pCh->pMyBord;
  status = pCh->dataSetIn;
  }
  if (resetBits) {
    {
    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn & ~ (resetBits & 240));
    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn & -3841);
    }
  }
  {
  while (1) {
    while_73_continue: /* CIL Label */ ;
    {

    }
    goto while_91_break;
  }
  while_73_break: /* CIL Label */ ;
  }
  while_91_break: 
  {

  }
  return ((int )status);
}
}
static int i2Input(i2ChanStrPtr pCh ) 
{ int amountToMove ;
  unsigned short stripIndex ;
  int count ;
  unsigned long flags ;
  int tmp ;

  {
  {
  flags = 0UL;
  }
  {
  while (1) {
    while_74_continue: /* CIL Label */ ;
    {

    }
    goto while_92_break;
  }
  while_74_break: /* CIL Label */ ;
  }
  while_92_break: 
  {
  tmp = i2Validate(pCh);
  }
  if (! tmp) {
    {
    count = -1;
    }
    goto i2Input_exit;
  }
  {
  flags = _write_lock_irqsave(& pCh->Ibuf_spinlock);
  stripIndex = (unsigned short )pCh->Ibuf_strip;
  count = (int )((int volatile   )pCh->Ibuf_stuff - (int volatile   )stripIndex);
  }
  if (count == 0) {
    {
    _write_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
    }
    goto i2Input_exit;
  }
  if (count < 0) {
    {
    count += 512;
    }
  }
  {
  amountToMove = (int )(pCh->pTTY)->receive_room;
  }
  if (count > amountToMove) {
    {
    count = amountToMove;
    }
  }
  {
  amountToMove = 512 - (int )stripIndex;
  }
  if (amountToMove > count) {
    {
    amountToMove = count;
    }
  }
  {
  (*((pCh->pTTY)->ldisc.receive_buf))(pCh->pTTY, (unsigned char const   *)(& pCh->Ibuf[stripIndex]),
                                      (char *)((void *)0), amountToMove);
  }
  if (count > amountToMove) {
    {
    (*((pCh->pTTY)->ldisc.receive_buf))(pCh->pTTY, (unsigned char const   *)(pCh->Ibuf),
                                        (char *)((void *)0), count - amountToMove);
    }
  }
  {
  stripIndex = (unsigned short )((int )stripIndex + count);
  }
  if ((int )stripIndex >= 512) {
    {
    stripIndex = (unsigned short )((int )stripIndex - 512);
    }
  }
  {
  pCh->Ibuf_strip = (unsigned short volatile   )stripIndex;
  pCh->infl.asof = (unsigned short volatile   )((int volatile   )pCh->infl.asof + (int volatile   )count);
  pCh->sinceLastFlow = (unsigned short )((int )pCh->sinceLastFlow + count);
  }
  if ((int )pCh->sinceLastFlow >= (int )pCh->whenSendFlow) {
    {
    pCh->sinceLastFlow = (unsigned short )((int )pCh->sinceLastFlow - (int )pCh->whenSendFlow);
    _write_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
    i2QueueNeeds(pCh->pMyBord, pCh, 1);
    }
  } else {
    {
    _write_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
    }
  }
  i2Input_exit: 
  {
  while (1) {
    while_75_continue: /* CIL Label */ ;
    {

    }
    goto while_93_break;
  }
  while_75_break: /* CIL Label */ ;
  }
  while_93_break: 
  {

  }
  return (count);
}
}
static int i2InputFlush(i2ChanStrPtr pCh ) 
{ int count ;
  unsigned long flags ;
  int tmp ;

  {
  {
  tmp = i2Validate(pCh);
  }
  if (! tmp) {
    return (-1);
  }
  {
  while (1) {
    while_76_continue: /* CIL Label */ ;
    {

    }
    goto while_94_break;
  }
  while_76_break: /* CIL Label */ ;
  }
  while_94_break: 
  {
  flags = _write_lock_irqsave(& pCh->Ibuf_spinlock);
  count = (int )((int volatile   )pCh->Ibuf_stuff - (int volatile   )pCh->Ibuf_strip);
  }
  if (count < 0) {
    {
    count += 512;
    }
  }
  {
  pCh->Ibuf_strip = pCh->Ibuf_stuff;
  pCh->infl.asof = (unsigned short volatile   )((int volatile   )pCh->infl.asof + (int volatile   )count);
  pCh->sinceLastFlow = (unsigned short )((int )pCh->sinceLastFlow + count);
  }
  if ((int )pCh->sinceLastFlow >= (int )pCh->whenSendFlow) {
    {
    pCh->sinceLastFlow = (unsigned short )((int )pCh->sinceLastFlow - (int )pCh->whenSendFlow);
    _write_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
    i2QueueNeeds(pCh->pMyBord, pCh, 1);
    }
  } else {
    {
    _write_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
    }
  }
  {
  while (1) {
    while_77_continue: /* CIL Label */ ;
    {

    }
    goto while_95_break;
  }
  while_77_break: /* CIL Label */ ;
  }
  while_95_break: 
  {

  }
  return (count);
}
}
static int i2Output(i2ChanStrPtr pCh , char const   *pSource , int count ) 
{ i2eBordStrPtr pB ;
  unsigned char *pInsert ;
  int amountToMove ;
  int countOriginal ;
  unsigned short channel ;
  unsigned short stuffIndex ;
  unsigned long flags ;
  int bailout ;
  int tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  struct thread_info *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  countOriginal = count;
  bailout = 10;
  }
  {
  while (1) {
    while_78_continue: /* CIL Label */ ;
    {

    }
    goto while_96_break;
  }
  while_78_break: /* CIL Label */ ;
  }
  while_96_break: 
  {
  tmp = i2Validate(pCh);
  }
  if (! tmp) {
    return (-1);
  }
  {
  pB = pCh->pMyBord;
  channel = (unsigned short )pCh->infl.hd.i2sChannel;
  }
  if (pB->i2eFatal) {
    if (pB->i2eFatalTrap) {
      {
      (*(pB->i2eFatalTrap))(pB);
      }
    }
    return (-1);
  }
  {
  while (1) {
    while_79_continue: /* CIL Label */ ;
    while_97_continue: 
    {

    }
    if (! (count > 0)) {
      goto while_97_break;
    }
    {
    flags = _read_lock_irqsave(& pCh->Obuf_spinlock);
    amountToMove = (int )(((int volatile   )pCh->Obuf_strip - (int volatile   )pCh->Obuf_stuff) - (int volatile   )1);
    _read_unlock_irqrestore(& pCh->Obuf_spinlock, flags);
    }
    if (amountToMove < 0) {
      {
      amountToMove += 1024;
      }
    }
    {
    amountToMove = (int )((unsigned int )amountToMove - sizeof(i2DataHeader ));
    }
    if (amountToMove > (int )(36U - sizeof(i2DataHeader ))) {
      {
      amountToMove = (int )(36U - sizeof(i2DataHeader ));
      }
    }
    if (amountToMove > count) {
      {
      amountToMove = count;
      }
    }
    {
    while (1) {
      while_80_continue: /* CIL Label */ ;
      {

      }
      goto while_98_break;
    }
    while_80_break: /* CIL Label */ ;
    }
    while_98_break: 
    {

    }
    if (pCh->flush_flags) {
      {
      tmp___4 = i2RetryFlushOutput(pCh);
      }
      if (tmp___4) {
        _L___0: 
        {
        while (1) {
          while_81_continue: /* CIL Label */ ;
          {

          }
          goto while_99_break;
        }
        while_81_break: /* CIL Label */ ;
        }
        while_99_break: 
        {
        i2QueueNeeds(pB, pCh, 2);
        }
        if (pB->i2eWaitingForEmptyFifo) {
          {
          while (1) {
            while_82_continue: /* CIL Label */ ;
            {

            }
            goto while_100_break;
          }
          while_82_break: /* CIL Label */ ;
          }
          while_100_break: 
          {
          tmp___2 = current_thread_info();
          }
          if ((unsigned long )tmp___2->preempt_count & ((((1UL << 12) - 1UL) << 16) | (((1UL << 8) - 1UL) << 8))) {
            {
            while (1) {
              while_83_continue: /* CIL Label */ ;
              {

              }
              goto while_101_break;
            }
            while_83_break: /* CIL Label */ ;
            }
            while_101_break: 
            {

            }
            goto while_97_break;
          } else {
            {
            while (1) {
              while_84_continue: /* CIL Label */ ;
              {

              }
              goto while_102_break;
            }
            while_84_break: /* CIL Label */ ;
            }
            while_102_break: 
            {
            schedule_timeout_interruptible(2L);
            tmp___0 = get_current();
            tmp___1 = signal_pending(tmp___0);
            }
            if (tmp___1) {
              goto while_97_break;
            }
            goto while_97_continue;
          }
          goto while_97_break;
        } else {
          if ((int volatile   )pB->i2eFifoRemains < (int volatile   )32) {
            {
            tmp___3 = (*(pB->i2eTxMailEmpty))(pB);
            }
            if (tmp___3) {
              goto _L;
            } else {
              {
              while (1) {
                while_85_continue: /* CIL Label */ ;
                {

                }
                goto while_103_break;
              }
              while_85_break: /* CIL Label */ ;
              }
              while_103_break: 
              {

              }
              goto while_97_break;
            }
          } else {
            _L: 
            if ((int )pCh->channelNeeds & 8) {
              {
              while (1) {
                while_86_continue: /* CIL Label */ ;
                {

                }
                goto while_104_break;
              }
              while_86_break: /* CIL Label */ ;
              }
              while_104_break: 
              {

              }
              goto while_97_break;
            } else {
              {
              bailout --;
              }
              if (bailout) {
                {
                while (1) {
                  while_87_continue: /* CIL Label */ ;
                  {

                  }
                  goto while_105_break;
                }
                while_87_break: /* CIL Label */ ;
                }
                while_105_break: 
                {
                serviceOutgoingFifo(pB);
                }
              } else {
                {
                while (1) {
                  while_88_continue: /* CIL Label */ ;
                  {

                  }
                  goto while_106_break;
                }
                while_88_break: /* CIL Label */ ;
                }
                while_106_break: 
                {

                }
                goto while_97_break;
              }
            }
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (amountToMove > 0) {
        {
        flags = _write_lock_irqsave(& pCh->Obuf_spinlock);
        stuffIndex = (unsigned short )pCh->Obuf_stuff;
        pInsert = & pCh->Obuf[stuffIndex];
        ((struct _i2DataHeader *)pInsert)->i2sChannel = (unsigned char )channel;
        ((struct _i2DataHeader *)pInsert)->i2sType = 0U;
        ((struct _i2DataHeader *)pInsert)->i2sTag = 0U;
        ((struct _i2DataHeader *)pInsert)->i2sId = 0U;
        ((struct _i2DataHeader *)pInsert)->i2sCount = (unsigned short )amountToMove;
        __memcpy((void *)((char *)(pInsert + 4)), (void const   *)pSource, (unsigned int )amountToMove);
        pSource += amountToMove;
        pCh->Obuf_char_count += amountToMove;
        stuffIndex = (unsigned short )((unsigned int )stuffIndex + ((unsigned int )amountToMove + sizeof(i2DataHeader )));
        count -= amountToMove;
        }
        if ((int )stuffIndex >= 1024) {
          {
          stuffIndex = (unsigned short)0;
          }
        }
        {
        pCh->Obuf_stuff = (unsigned short volatile   )stuffIndex;
        _write_unlock_irqrestore(& pCh->Obuf_spinlock, flags);
        }
        {
        while (1) {
          while_89_continue: /* CIL Label */ ;
          {

          }
          goto while_107_break;
        }
        while_89_break: /* CIL Label */ ;
        }
        while_107_break: 
        {

        }
      } else {
        goto _L___0;
      }
    }
  }
  while_79_break: /* CIL Label */ ;
  }
  while_97_break: 
  {
  i2QueueNeeds(pB, pCh, 2);
  }
  if (countOriginal > count) {
    {
    while (1) {
      while_90_continue: /* CIL Label */ ;
      {

      }
      goto while_108_break;
    }
    while_90_break: /* CIL Label */ ;
    }
    while_108_break: 
    {
    serviceOutgoingFifo(pB);
    }
  }
  {
  while (1) {
    while_91_continue: /* CIL Label */ ;
    {

    }
    goto while_109_break;
  }
  while_91_break: /* CIL Label */ ;
  }
  while_109_break: 
  {

  }
  return (countOriginal - count);
}
}
__inline static void ( __attribute__((__always_inline__)) i2FlushOutput)(i2ChanStrPtr pCh ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_92_continue: /* CIL Label */ ;
    {

    }
    goto while_110_break;
  }
  while_92_break: /* CIL Label */ ;
  }
  while_110_break: 
  {

  }
  if (pCh->flush_flags) {
    return;
  }
  {
  tmp___0 = i2QueueCommands(1, pCh, 0, 1, (struct _cmdSyntax *)(ct06));
  }
  if (1 != tmp___0) {
    {
    pCh->flush_flags = 1;
    }
    {
    while (1) {
      while_93_continue: /* CIL Label */ ;
      {

      }
      goto while_111_break;
    }
    while_93_break: /* CIL Label */ ;
    }
    while_111_break: 
    {

    }
  } else {
    {
    tmp = i2QueueCommands(2, pCh, 0, 1, (struct _cmdSyntax *)(ct13));
    }
    if (1 != tmp) {
      {
      pCh->flush_flags = 2;
      }
      {
      while (1) {
        while_94_continue: /* CIL Label */ ;
        {

        }
        goto while_112_break;
      }
      while_94_break: /* CIL Label */ ;
      }
      while_112_break: 
      {

      }
    }
  }
  return;
}
}
static int i2RetryFlushOutput(i2ChanStrPtr pCh ) 
{ int old_flags ;
  int tmp ;
  int tmp___0 ;

  {
  {
  old_flags = pCh->flush_flags;
  }
  {
  while (1) {
    while_95_continue: /* CIL Label */ ;
    {

    }
    goto while_113_break;
  }
  while_95_break: /* CIL Label */ ;
  }
  while_113_break: 
  {
  pCh->flush_flags = 0;
  }
  if (old_flags & 1) {
    {
    tmp = i2QueueCommands(1, pCh, 0, 1, (struct _cmdSyntax *)(ct06));
    }
    if (1 == tmp) {
      {
      old_flags = 2;
      }
    } else {
      {
      old_flags = 1;
      }
    }
    {
    while (1) {
      while_96_continue: /* CIL Label */ ;
      {

      }
      goto while_114_break;
    }
    while_96_break: /* CIL Label */ ;
    }
    while_114_break: 
    {

    }
  }
  if (old_flags & 2) {
    {
    tmp___0 = i2QueueCommands(2, pCh, 0, 1, (struct _cmdSyntax *)(ct13));
    }
    if (1 == tmp___0) {
      {
      old_flags = 0;
      }
    }
    {
    while (1) {
      while_97_continue: /* CIL Label */ ;
      {

      }
      goto while_115_break;
    }
    while_97_break: /* CIL Label */ ;
    }
    while_115_break: 
    {

    }
  }
  {
  pCh->flush_flags = old_flags;
  }
  {
  while (1) {
    while_98_continue: /* CIL Label */ ;
    {

    }
    goto while_116_break;
  }
  while_98_break: /* CIL Label */ ;
  }
  while_116_break: 
  {

  }
  return (old_flags);
}
}
static void i2DrainWakeup(unsigned long d ) 
{ i2ChanStrPtr pCh ;

  {
  {
  pCh = (struct _i2ChanStr *)d;
  }
  {
  while (1) {
    while_99_continue: /* CIL Label */ ;
    {

    }
    goto while_117_break;
  }
  while_99_break: /* CIL Label */ ;
  }
  while_117_break: 
  {
  pCh->BookmarkTimer.expires = 0UL;
  __wake_up(& pCh->pBookmarkWait, 1U, 1, (void *)0);
  }
  return;
}
}
static void i2DrainOutput(i2ChanStrPtr pCh , int timeout ) 
{ wait_queue_t wait ;
  i2eBordStrPtr pB ;
  struct task_struct *tmp ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;

  {
  {
  while (1) {
    while_100_continue: /* CIL Label */ ;
    {

    }
    goto while_118_break;
  }
  while_100_break: /* CIL Label */ ;
  }
  while_118_break: 
  {
  pB = pCh->pMyBord;
  }
  if (pB->i2eFatal) {
    if (pB->i2eFatalTrap) {
      {
      (*(pB->i2eFatalTrap))(pB);
      }
    }
    return;
  }
  if (timeout > 0) {
    if (pCh->BookmarkTimer.expires == 0UL) {
      {
      setup_timer(& pCh->BookmarkTimer, & i2DrainWakeup, (unsigned long )pCh);
      }
      {
      while (1) {
        while_101_continue: /* CIL Label */ ;
        {

        }
        goto while_119_break;
      }
      while_101_break: /* CIL Label */ ;
      }
      while_119_break: 
      {
      mod_timer(& pCh->BookmarkTimer, (unsigned long )(jiffies + (unsigned long volatile   )timeout));
      }
    }
  }
  {
  i2QueueCommands(2, pCh, -1, 1, (struct _cmdSyntax *)(ct60));
  tmp = get_current();
  init_waitqueue_entry(& wait, tmp);
  add_wait_queue(& pCh->pBookmarkWait, & wait);
  }
  {
  while (1) {
    while_102_continue: /* CIL Label */ ;
    {
    tmp___3 = get_current();
    __xchg(1UL, (void volatile   *)(& tmp___3->state), (int )sizeof(tmp___2->state));
    }
    goto while_120_break;
  }
  while_102_break: /* CIL Label */ ;
  }
  while_120_break: 
  {
  serviceOutgoingFifo(pB);
  schedule();
  }
  {
  while (1) {
    while_103_continue: /* CIL Label */ ;
    {
    tmp___7 = get_current();
    __xchg(0UL, (void volatile   *)(& tmp___7->state), (int )sizeof(tmp___6->state));
    }
    goto while_121_break;
  }
  while_103_break: /* CIL Label */ ;
  }
  while_121_break: 
  {
  remove_wait_queue(& pCh->pBookmarkWait, & wait);
  }
  if (timeout > 0) {
    if (pCh->BookmarkTimer.expires) {
      if ((long )jiffies - (long )pCh->BookmarkTimer.expires < 0L) {
        {
        del_timer(& pCh->BookmarkTimer);
        pCh->BookmarkTimer.expires = 0UL;
        }
        {
        while (1) {
          while_104_continue: /* CIL Label */ ;
          {

          }
          goto while_122_break;
        }
        while_104_break: /* CIL Label */ ;
        }
        while_122_break: 
        {

        }
      }
    }
  }
  {
  while (1) {
    while_105_continue: /* CIL Label */ ;
    {

    }
    goto while_123_break;
  }
  while_105_break: /* CIL Label */ ;
  }
  while_123_break: 
  {

  }
  return;
}
}
static int i2OutputFree(i2ChanStrPtr pCh ) 
{ int amountToMove ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = i2Validate(pCh);
  }
  if (! tmp) {
    return (-1);
  }
  {
  flags = _read_lock_irqsave(& pCh->Obuf_spinlock);
  amountToMove = (int )(((int volatile   )pCh->Obuf_strip - (int volatile   )pCh->Obuf_stuff) - (int volatile   )1);
  _read_unlock_irqrestore(& pCh->Obuf_spinlock, flags);
  }
  if (amountToMove < 0) {
    {
    amountToMove += 1024;
    }
  }
  {
  amountToMove = (int )((unsigned int )amountToMove - sizeof(i2DataHeader ));
  }
  if (amountToMove < 0) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = amountToMove;
    }
  }
  return (tmp___0);
}
}
static void ip2_owake(PTTY tp ) 
{ i2ChanStrPtr pCh ;

  {
  if ((unsigned int )tp == (unsigned int )((void *)0)) {
    return;
  }
  {
  pCh = (struct _i2ChanStr *)tp->driver_data;
  }
  {
  while (1) {
    while_106_continue: /* CIL Label */ ;
    {

    }
    goto while_124_break;
  }
  while_106_break: /* CIL Label */ ;
  }
  while_124_break: 
  {
  tty_wakeup(tp);
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) set_baud_params)(i2eBordStrPtr pB ) 
{ int i ;
  int j ;
  i2ChanStrPtr *pCh ;

  {
  {
  pCh = (i2ChanStrPtr *)pB->i2eChannelPtr;
  i = 0;
  }
  {
  while (1) {
    while_107_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_125_break;
    }
    if (pB->channelBtypes.bid_value[i]) {
      if (((int )pB->channelBtypes.bid_value[i] & 7) == 4) {
        {
        j = 0;
        }
        {
        while (1) {
          while_108_continue: /* CIL Label */ ;
          {

          }
          if (! (j < 16)) {
            goto while_126_break;
          }
          if ((unsigned int )*(pCh + (i * 16 + j)) == (unsigned int )((void *)0)) {
            goto while_126_break;
          }
          {
          (*(pCh + (i * 16 + j)))->BaudBase = 921600;
          (*(pCh + (i * 16 + j)))->BaudDivisor = 96;
          j ++;
          }
        }
        while_108_break: /* CIL Label */ ;
        }
        while_126_break: 
        {

        }
      } else {
        {
        j = 0;
        }
        {
        while (1) {
          while_109_continue: /* CIL Label */ ;
          {

          }
          if (! (j < 16)) {
            goto while_127_break;
          }
          if ((unsigned int )*(pCh + (i * 16 + j)) == (unsigned int )((void *)0)) {
            goto while_127_break;
          }
          {
          (*(pCh + (i * 16 + j)))->BaudBase = 115200;
          (*(pCh + (i * 16 + j)))->BaudDivisor = 12;
          j ++;
          }
        }
        while_109_break: /* CIL Label */ ;
        }
        while_127_break: 
        {

        }
      }
    }
    {
    i ++;
    }
  }
  while_107_break: /* CIL Label */ ;
  }
  while_125_break: 
  {

  }
  return;
}
}
static unsigned char junkBuffer[512]  ;
static unsigned char cmdBuffer[66]  ;
static char xlatDss[16]  = 
  {      (char)0,      (char)2,      (char)4,      (char)6, 
        (char)8,      (char)10,      (char)12,      (char)14, 
        (char)1,      (char)3,      (char)5,      (char)7, 
        (char)9,      (char)11,      (char)13,      (char)15};
__inline static void ( __attribute__((__always_inline__)) i2StripFifo)(i2eBordStrPtr pB ) 
{ i2ChanStrPtr pCh ;
  int channel ;
  int count ;
  unsigned short stuffIndex ;
  int amountToRead ;
  unsigned char *pc ;
  unsigned char *pcLimit ;
  unsigned char uc ;
  unsigned char dss_change ;
  unsigned long bflags ;
  unsigned long cflags ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char tmp___4 ;

  {
  {
  while (1) {
    while_110_continue: /* CIL Label */ ;
    {
    tmp___4 = inb(pB->i2eStatus);
    }
    if ((int )tmp___4 & 32) {
      goto while_128_break;
    }
    {
    bflags = _write_lock_irqsave(& pB->read_fifo_spinlock);
    pB->i2eLeadoffWord[0] = (*(pB->i2eReadWord))(pB);
    }
    if ((int )((struct _i2DataHeader *)(pB->i2eLeadoffWord))->i2sType == 0) {
      goto switch_129_0;
    } else {
      if ((int )((struct _i2DataHeader *)(pB->i2eLeadoffWord))->i2sType == 2) {
        goto switch_129_2;
      } else {
        goto switch_129_default;
        if (0) {
          switch_129_0: 
          {
          pB->got_input = 1;
          channel = (int )((struct _i2DataHeader *)(pB->i2eLeadoffWord))->i2sChannel;
          tmp = (*(pB->i2eReadWord))(pB);
          count = (int )tmp;
          }
          if ((unsigned int )count > 512U) {
            {
            pB->i2eFatal = (unsigned short)2;
            _write_unlock_irqrestore(& pB->read_fifo_spinlock, bflags);
            }
            return;
          }
          if (channel >= (int )pB->i2eChannelCnt) {
            {
            (*(pB->i2eReadBuf))(pB, junkBuffer, count);
            _write_unlock_irqrestore(& pB->read_fifo_spinlock, bflags);
            }
            goto switch_129_break;
          } else {
            {
            pCh = *((i2ChanStrPtr *)pB->i2eChannelPtr + channel);
            }
            if ((unsigned int )((void *)0) == (unsigned int )pCh) {
              {
              (*(pB->i2eReadBuf))(pB, junkBuffer, count);
              _write_unlock_irqrestore(& pB->read_fifo_spinlock, bflags);
              }
              goto switch_129_break;
            }
          }
          if (((struct _i2DataHeader *)(pB->i2eLeadoffWord))->i2sId == 1U) {
            {
            tmp___0 = (*(pB->i2eReadWord))(pB);
            pCh->hotKeyIn = (unsigned short )((int )tmp___0 & 255);
            _write_unlock_irqrestore(& pB->read_fifo_spinlock, bflags);
            i2QueueCommands(1, pCh, 0, 1, (struct _cmdSyntax *)(ct14));
            }
            goto switch_129_break;
          }
          {
          cflags = _write_lock_irqsave(& pCh->Ibuf_spinlock);
          stuffIndex = (unsigned short )pCh->Ibuf_stuff;
          amountToRead = 512 - (int )stuffIndex;
          }
          if (amountToRead > count) {
            {
            amountToRead = count;
            }
          }
          {
          (*(pB->i2eReadBuf))(pB, & pCh->Ibuf[stuffIndex], amountToRead);
          pCh->icount.rx += (unsigned int )amountToRead;
          stuffIndex = (unsigned short )((int )stuffIndex + amountToRead);
          }
          if ((int )stuffIndex >= 512) {
            if (amountToRead & 1) {
              if (count > amountToRead) {
                {
                pCh->Ibuf[0] = pCh->Ibuf[512];
                amountToRead ++;
                stuffIndex = (unsigned short)1;
                }
              } else {
                {
                stuffIndex = (unsigned short)0;
                }
              }
            } else {
              {
              stuffIndex = (unsigned short)0;
              }
            }
          }
          if (count > amountToRead) {
            {
            amountToRead = count - amountToRead;
            (*(pB->i2eReadBuf))(pB, & pCh->Ibuf[stuffIndex], amountToRead);
            pCh->icount.rx += (unsigned int )amountToRead;
            stuffIndex = (unsigned short )((int )stuffIndex + amountToRead);
            }
          }
          {
          pCh->Ibuf_stuff = (unsigned short volatile   )stuffIndex;
          _write_unlock_irqrestore(& pCh->Ibuf_spinlock, cflags);
          _write_unlock_irqrestore(& pB->read_fifo_spinlock, bflags);
          do_input(& pCh->tqueue_input);
          }
          goto switch_129_break;
          switch_129_2: 
          {
          while (1) {
            while_111_continue: /* CIL Label */ ;
            {

            }
            goto while_130_break;
          }
          while_111_break: /* CIL Label */ ;
          }
          while_130_break: 
          {
          count = (int )((struct _i2CmdHeader *)(pB->i2eLeadoffWord))->i2sCount;
          (*(pB->i2eReadBuf))(pB, cmdBuffer, count);
          _write_unlock_irqrestore(& pB->read_fifo_spinlock, bflags);
          pc = cmdBuffer;
          pcLimit = & cmdBuffer[count];
          }
          {
          while (1) {
            while_112_continue: /* CIL Label */ ;
            {

            }
            if (! ((unsigned int )pc < (unsigned int )pcLimit)) {
              goto while_131_break;
            }
            {
            tmp___1 = pc;
            pc ++;
            channel = (int )*tmp___1;
            }
            {
            while (1) {
              while_113_continue: /* CIL Label */ ;
              {

              }
              goto while_132_break;
            }
            while_113_break: /* CIL Label */ ;
            }
            while_132_break: 
            {

            }
            if (channel < (int )pB->i2eChannelCnt) {
              {
              pCh = *((i2ChanStrPtr *)pB->i2eChannelPtr + channel);
              }
              if ((unsigned int )pCh != (unsigned int )((void *)0)) {
                {
                dss_change = (unsigned char)0;
                tmp___2 = pc;
                pc ++;
                uc = *tmp___2;
                }
                if ((int )uc == 0) {
                  goto switch_133_0;
                } else {
                  if ((int )uc == 1) {
                    goto switch_133_1;
                  } else {
                    if ((int )uc == 2) {
                      goto switch_133_2;
                    } else {
                      if ((int )uc == 3) {
                        goto switch_133_3;
                      } else {
                        if ((int )uc == 4) {
                          goto switch_133_4;
                        } else {
                          if ((int )uc == 5) {
                            goto switch_133_5;
                          } else {
                            if ((int )uc == 6) {
                              goto switch_133_6;
                            } else {
                              if ((int )uc == 7) {
                                goto switch_133_7;
                              } else {
                                if ((int )uc == 8) {
                                  goto switch_133_8;
                                } else {
                                  if ((int )uc == 10) {
                                    goto switch_133_10;
                                  } else {
                                    if ((int )uc == 9) {
                                      goto switch_133_9;
                                    } else {
                                      if ((int )uc == 11) {
                                        goto switch_133_11;
                                      } else {
                                        if ((int )uc == 12) {
                                          goto switch_133_12;
                                        } else {
                                          if ((int )uc == 13) {
                                            goto switch_133_13;
                                          } else {
                                            if ((int )uc == 14) {
                                              goto switch_133_14;
                                            } else {
                                              if ((int )uc == 15) {
                                                goto switch_133_15;
                                              } else {
                                                goto switch_133_default;
                                                if (0) {
                                                  switch_133_0: 
                                                  if (! ((int )pCh->dataSetIn & 2)) {
                                                    {
                                                    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 512);
                                                    (pCh->icount.cts) ++;
                                                    dss_change = (unsigned char)1;
                                                    }
                                                  }
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 2);
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_1: 
                                                  if ((int )pCh->dataSetIn & 2) {
                                                    {
                                                    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 512);
                                                    (pCh->icount.cts) ++;
                                                    dss_change = (unsigned char)1;
                                                    }
                                                  }
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn & -3);
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_2: 
                                                  {
                                                  while (1) {
                                                    while_114_continue: /* CIL Label */ ;
                                                    {

                                                    }
                                                    goto while_134_break;
                                                  }
                                                  while_114_break: /* CIL Label */ ;
                                                  }
                                                  while_134_break: 
                                                  {

                                                  }
                                                  if (! ((int )pCh->dataSetIn & 1)) {
                                                    {
                                                    while (1) {
                                                      while_115_continue: /* CIL Label */ ;
                                                      {

                                                      }
                                                      goto while_135_break;
                                                    }
                                                    while_115_break: /* CIL Label */ ;
                                                    }
                                                    while_135_break: 
                                                    {
                                                    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 256);
                                                    (pCh->icount.dcd) ++;
                                                    dss_change = (unsigned char)1;
                                                    }
                                                  }
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 1);
                                                  }
                                                  {
                                                  while (1) {
                                                    while_116_continue: /* CIL Label */ ;
                                                    {

                                                    }
                                                    goto while_136_break;
                                                  }
                                                  while_116_break: /* CIL Label */ ;
                                                  }
                                                  while_136_break: 
                                                  {

                                                  }
                                                  goto switch_133_break;
                                                  switch_133_3: 
                                                  {
                                                  while (1) {
                                                    while_117_continue: /* CIL Label */ ;
                                                    {

                                                    }
                                                    goto while_137_break;
                                                  }
                                                  while_117_break: /* CIL Label */ ;
                                                  }
                                                  while_137_break: 
                                                  {

                                                  }
                                                  if ((int )pCh->dataSetIn & 1) {
                                                    {
                                                    while (1) {
                                                      while_118_continue: /* CIL Label */ ;
                                                      {

                                                      }
                                                      goto while_138_break;
                                                    }
                                                    while_118_break: /* CIL Label */ ;
                                                    }
                                                    while_138_break: 
                                                    {
                                                    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 256);
                                                    (pCh->icount.dcd) ++;
                                                    dss_change = (unsigned char)1;
                                                    }
                                                  }
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn & -2);
                                                  }
                                                  {
                                                  while (1) {
                                                    while_119_continue: /* CIL Label */ ;
                                                    {

                                                    }
                                                    goto while_139_break;
                                                  }
                                                  while_119_break: /* CIL Label */ ;
                                                  }
                                                  while_139_break: 
                                                  {

                                                  }
                                                  goto switch_133_break;
                                                  switch_133_4: 
                                                  if (! ((int )pCh->dataSetIn & 4)) {
                                                    {
                                                    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 1024);
                                                    (pCh->icount.dsr) ++;
                                                    dss_change = (unsigned char)1;
                                                    }
                                                  }
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 4);
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_5: 
                                                  if ((int )pCh->dataSetIn & 4) {
                                                    {
                                                    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 1024);
                                                    (pCh->icount.dsr) ++;
                                                    dss_change = (unsigned char)1;
                                                    }
                                                  }
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn & -5);
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_6: 
                                                  if (! ((int )pCh->dataSetIn & 8)) {
                                                    {
                                                    pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 2048);
                                                    (pCh->icount.rng) ++;
                                                    dss_change = (unsigned char)1;
                                                    }
                                                  }
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 8);
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_7: 
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn & -9);
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_8: 
                                                  {
                                                  pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 16);
                                                  (pCh->icount.brk) ++;
                                                  dss_change = (unsigned char)1;
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_10: 
                                                  {
                                                  pCh->bookMarks = (short )((int )pCh->bookMarks - 1);
                                                  }
                                                  if ((int )pCh->bookMarks <= 0) {
                                                    {
                                                    pCh->bookMarks = (short)0;
                                                    __wake_up(& pCh->pBookmarkWait,
                                                              1U, 1, (void *)0);
                                                    }
                                                    {
                                                    while (1) {
                                                      while_120_continue: /* CIL Label */ ;
                                                      {

                                                      }
                                                      goto while_140_break;
                                                    }
                                                    while_120_break: /* CIL Label */ ;
                                                    }
                                                    while_140_break: 
                                                    {

                                                    }
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_9: 
                                                  {
                                                  pCh->outfl.room = (unsigned short volatile   )((int )((struct _flowStat *)pc)->room - (int )((int volatile   )pCh->outfl.asof - (int volatile   )((struct _flowStat *)pc)->asof));
                                                  }
                                                  {
                                                  while (1) {
                                                    while_121_continue: /* CIL Label */ ;
                                                    {

                                                    }
                                                    goto while_141_break;
                                                  }
                                                  while_121_break: /* CIL Label */ ;
                                                  }
                                                  while_141_break: 
                                                  {

                                                  }
                                                  if ((int )pCh->channelNeeds & 8) {
                                                    {
                                                    while (1) {
                                                      while_122_continue: /* CIL Label */ ;
                                                      {

                                                      }
                                                      goto while_142_break;
                                                    }
                                                    while_122_break: /* CIL Label */ ;
                                                    }
                                                    while_142_break: 
                                                    {
                                                    pCh->channelNeeds = (unsigned short )((int )pCh->channelNeeds & -9);
                                                    i2QueueNeeds(pB, pCh, 2);
                                                    }
                                                    if (pCh->pTTY) {
                                                      {
                                                      ip2_owake(pCh->pTTY);
                                                      }
                                                    }
                                                  }
                                                  {
                                                  while (1) {
                                                    while_123_continue: /* CIL Label */ ;
                                                    {

                                                    }
                                                    goto while_143_break;
                                                  }
                                                  while_123_break: /* CIL Label */ ;
                                                  }
                                                  while_143_break: 
                                                  {
                                                  pc += sizeof(flowStat );
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_11: 
                                                  {
                                                  pCh->channelStatus = *((struct _debugStat *)pc);
                                                  pc += sizeof(debugStat );
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_12: 
                                                  {
                                                  pCh->channelTcount = *((struct _cntStat *)pc);
                                                  pc += sizeof(cntStat );
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_13: 
                                                  {
                                                  pCh->channelRcount = *((struct _cntStat *)pc);
                                                  pc += sizeof(cntStat );
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_14: 
                                                  {
                                                  pB->channelBtypes = *((struct _bidStat *)pc);
                                                  pc += sizeof(bidStat );
                                                  set_baud_params(pB);
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_15: 
                                                  {
                                                  i2QueueCommands(2, pCh, 0, 1, (struct _cmdSyntax *)(ct87));
                                                  pCh->channelFail = *((struct _failStat *)pc);
                                                  pc += sizeof(failStat );
                                                  }
                                                  goto switch_133_break;
                                                  switch_133_default: 
                                                  {

                                                  }
                                                  if (((int )uc & 192) == 128) {
                                                    goto switch_144_128;
                                                  } else {
                                                    if (((int )uc & 192) == 192) {
                                                      goto switch_144_192;
                                                    } else {
                                                      goto switch_144_default;
                                                      if (0) {
                                                        switch_144_128: 
                                                        if ((int )uc & 4) {
                                                          {
                                                          pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 32);
                                                          (pCh->icount.parity) ++;
                                                          }
                                                        }
                                                        if ((int )uc & 2) {
                                                          {
                                                          pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 64);
                                                          (pCh->icount.frame) ++;
                                                          }
                                                        }
                                                        if ((int )uc & 1) {
                                                          {
                                                          pCh->dataSetIn = (unsigned short )((int )pCh->dataSetIn | 128);
                                                          (pCh->icount.overrun) ++;
                                                          }
                                                        }
                                                        goto switch_144_break;
                                                        switch_144_192: 
                                                        {
                                                        pCh->dataSetIn = (unsigned short )(((int )pCh->dataSetIn & -16) | (int )xlatDss[(int )uc & 15]);
                                                        __wake_up(& pCh->dss_now_wait,
                                                                  1U, 1, (void *)0);
                                                        }
                                                        switch_144_default: 
                                                        {

                                                        }
                                                        goto switch_144_break;
                                                      } else {
                                                        switch_144_break: 
                                                        {

                                                        }
                                                      }
                                                    }
                                                  }
                                                } else {
                                                  switch_133_break: 
                                                  {

                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (dss_change) {
                  {
                  do_status(& pCh->tqueue_status);
                  }
                }
              } else {
                goto _L;
              }
            } else {
              _L: 
              {
              tmp___3 = pc;
              pc ++;
              }
              if ((int )*tmp___3 == 9) {
                goto switch_145_9;
              } else {
                goto switch_145_default;
                if (0) {
                  switch_145_9: 
                  {
                  pc += 4;
                  }
                  goto switch_145_break;
                  switch_145_default: 
                  {

                  }
                  goto switch_145_break;
                } else {
                  switch_145_break: 
                  {

                  }
                }
              }
            }
          }
          while_112_break: /* CIL Label */ ;
          }
          while_131_break: 
          {

          }
          goto switch_129_break;
          switch_129_default: 
          {

          }
          {
          while (1) {
            while_124_continue: /* CIL Label */ ;
            {

            }
            goto while_146_break;
          }
          while_124_break: /* CIL Label */ ;
          }
          while_146_break: 
          {
          _write_unlock_irqrestore(& pB->read_fifo_spinlock, bflags);
          }
          goto switch_129_break;
        } else {
          switch_129_break: 
          {

          }
        }
      }
    }
  }
  while_110_break: /* CIL Label */ ;
  }
  while_128_break: 
  {

  }
  {
  while (1) {
    while_125_continue: /* CIL Label */ ;
    {

    }
    goto while_147_break;
  }
  while_125_break: /* CIL Label */ ;
  }
  while_147_break: 
  {
  pB->i2eOutMailWaiting = (unsigned char )((int )pB->i2eOutMailWaiting | 64);
  }
  return;
}
}
static int i2Write2Fifo(i2eBordStrPtr pB , unsigned char *source , int count , int reserve ) 
{ int rc ;
  unsigned long flags ;

  {
  {
  rc = 0;
  flags = _write_lock_irqsave(& pB->write_fifo_spinlock);
  }
  if (! pB->i2eWaitingForEmptyFifo) {
    if ((int volatile   )pB->i2eFifoRemains > (int volatile   )(count + reserve)) {
      {
      pB->i2eFifoRemains = (unsigned short volatile   )((int volatile   )pB->i2eFifoRemains - (int volatile   )count);
      (*(pB->i2eWriteBuf))(pB, source, count);
      pB->i2eOutMailWaiting = (unsigned char )((int )pB->i2eOutMailWaiting | 128);
      rc = count;
      }
    }
  }
  {
  _write_unlock_irqrestore(& pB->write_fifo_spinlock, flags);
  }
  return (rc);
}
}
__inline static void ( __attribute__((__always_inline__)) i2StuffFifoBypass)(i2eBordStrPtr pB ) 
{ i2ChanStrPtr pCh ;
  unsigned char *pRemove ;
  unsigned short stripIndex ;
  unsigned short packetSize ;
  unsigned short paddedSize ;
  unsigned short notClogged ;
  unsigned long flags ;
  int bailout ;
  int tmp ;

  {
  {
  notClogged = (unsigned short)1;
  bailout = 1000;
  }
  {
  while (1) {
    while_126_continue: /* CIL Label */ ;
    {
    bailout --;
    }
    if (bailout) {
      if (notClogged) {
        {
        pCh = i2DeQueueNeeds(pB, 4);
        }
        if (! ((unsigned int )((void *)0) != (unsigned int )pCh)) {
          goto while_148_break;
        }
      } else {
        goto while_148_break;
      }
    } else {
      goto while_148_break;
    }
    {
    flags = _write_lock_irqsave(& pCh->Cbuf_spinlock);
    stripIndex = (unsigned short )pCh->Cbuf_strip;
    }
    {
    while (1) {
      while_127_continue: /* CIL Label */ ;
      {

      }
      if (! ((int )stripIndex != (int )pCh->Cbuf_stuff)) {
        goto while_149_break;
      }
      {
      pRemove = & pCh->Cbuf[stripIndex];
      packetSize = (unsigned short )(((struct _i2CmdHeader *)pRemove)->i2sCount + sizeof(i2CmdHeader ));
      paddedSize = (unsigned short )((((int )packetSize + 1) / 2) * 2);
      }
      if ((int )paddedSize > 0) {
        {
        tmp = i2Write2Fifo(pB, pRemove, (int )paddedSize, 0);
        }
        if (0 == tmp) {
          {
          notClogged = (unsigned short)0;
          i2QueueNeeds(pB, pCh, 4);
          }
          goto while_149_break;
        }
      }
      {
      (pB->debugBypassCount) ++;
      pRemove += (int )packetSize;
      stripIndex = (unsigned short )((int )stripIndex + (int )packetSize);
      }
      if ((int )stripIndex >= 10) {
        {
        stripIndex = (unsigned short)0;
        pRemove = pCh->Cbuf;
        }
      }
    }
    while_127_break: /* CIL Label */ ;
    }
    while_149_break: 
    {
    pCh->Cbuf_strip = (unsigned short volatile   )stripIndex;
    _write_unlock_irqrestore(& pCh->Cbuf_spinlock, flags);
    }
  }
  while_126_break: /* CIL Label */ ;
  }
  while_148_break: 
  {

  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) i2StuffFifoFlow)(i2eBordStrPtr pB ) 
{ i2ChanStrPtr pCh ;
  unsigned short paddedSize ;
  int tmp ;

  {
  {
  paddedSize = (unsigned short )(((sizeof(flowIn ) + 1U) / 2U) * 2U);
  }
  {
  while (1) {
    while_128_continue: /* CIL Label */ ;
    {

    }
    goto while_150_break;
  }
  while_128_break: /* CIL Label */ ;
  }
  while_150_break: 
  {

  }
  {
  while (1) {
    while_129_continue: /* CIL Label */ ;
    {
    pCh = i2DeQueueNeeds(pB, 1);
    }
    if (! ((unsigned int )((void *)0) != (unsigned int )pCh)) {
      goto while_151_break;
    }
    {
    (pB->debugFlowCount) ++;
    tmp = i2Write2Fifo(pB, (unsigned char *)(& pCh->infl), (int )paddedSize, 0);
    }
    if (0 == tmp) {
      goto while_151_break;
    }
  }
  while_129_break: /* CIL Label */ ;
  }
  while_151_break: 
  {

  }
  {
  while (1) {
    while_130_continue: /* CIL Label */ ;
    {

    }
    goto while_152_break;
  }
  while_130_break: /* CIL Label */ ;
  }
  while_152_break: 
  {

  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) i2StuffFifoInline)(i2eBordStrPtr pB ) 
{ i2ChanStrPtr pCh ;
  unsigned char *pRemove ;
  unsigned short stripIndex ;
  unsigned short packetSize ;
  unsigned short paddedSize ;
  unsigned short notClogged ;
  unsigned short flowsize ;
  unsigned long flags ;
  int bailout ;
  int bailout2 ;
  int tmp ;

  {
  {
  notClogged = (unsigned short)1;
  bailout = 1000;
  }
  {
  while (1) {
    while_131_continue: /* CIL Label */ ;
    {

    }
    goto while_153_break;
  }
  while_131_break: /* CIL Label */ ;
  }
  while_153_break: 
  {

  }
  {
  while (1) {
    while_132_continue: /* CIL Label */ ;
    {
    bailout --;
    }
    if (bailout) {
      if (notClogged) {
        {
        pCh = i2DeQueueNeeds(pB, 2);
        }
        if (! ((unsigned int )((void *)0) != (unsigned int )pCh)) {
          goto while_154_break;
        }
      } else {
        goto while_154_break;
      }
    } else {
      goto while_154_break;
    }
    {
    flags = _write_lock_irqsave(& pCh->Obuf_spinlock);
    stripIndex = (unsigned short )pCh->Obuf_strip;
    }
    {
    while (1) {
      while_133_continue: /* CIL Label */ ;
      {

      }
      goto while_155_break;
    }
    while_133_break: /* CIL Label */ ;
    }
    while_155_break: 
    {
    bailout2 = 1000;
    }
    {
    while (1) {
      while_134_continue: /* CIL Label */ ;
      {
      bailout2 --;
      }
      if (bailout2) {
        if (! ((int )stripIndex != (int )pCh->Obuf_stuff)) {
          goto while_156_break;
        }
      } else {
        goto while_156_break;
      }
      {
      pRemove = & pCh->Obuf[stripIndex];
      }
      if (((struct _i2DataHeader *)pRemove)->i2sType == 0U) {
        {
        flowsize = ((struct _i2DataHeader *)pRemove)->i2sCount;
        packetSize = (unsigned short )((unsigned int )flowsize + sizeof(i2DataHeader ));
        }
      } else {
        {
        flowsize = (unsigned short )((struct _i2CmdHeader *)pRemove)->i2sCount;
        packetSize = (unsigned short )((unsigned int )flowsize + sizeof(i2CmdHeader ));
        }
      }
      {
      flowsize = (unsigned short )(((int )flowsize + 3) & -2);
      paddedSize = (unsigned short )((((int )packetSize + 1) / 2) * 2);
      }
      {
      while (1) {
        while_135_continue: /* CIL Label */ ;
        {

        }
        goto while_157_break;
      }
      while_135_break: /* CIL Label */ ;
      }
      while_157_break: 
      {

      }
      {
      while (1) {
        while_136_continue: /* CIL Label */ ;
        {

        }
        goto while_158_break;
      }
      while_136_break: /* CIL Label */ ;
      }
      while_158_break: 
      {

      }
      if ((int volatile   )pCh->outfl.room <= (int volatile   )flowsize) {
        {
        i2QueueNeeds(pB, pCh, 8);
        notClogged = (unsigned short)0;
        }
        goto while_156_break;
      }
      if ((int )paddedSize > 0) {
        {
        tmp = i2Write2Fifo(pB, pRemove, (int )paddedSize, 128);
        }
        if (0 == tmp) {
          {
          notClogged = (unsigned short)0;
          i2QueueNeeds(pB, pCh, 2);
          }
          goto while_156_break;
        }
      }
      {
      (pB->debugInlineCount) ++;
      pCh->icount.tx += (unsigned int )flowsize;
      pCh->outfl.room = (unsigned short volatile   )((int volatile   )pCh->outfl.room - (int volatile   )flowsize);
      pCh->outfl.asof = (unsigned short volatile   )((int volatile   )pCh->outfl.asof + (int volatile   )flowsize);
      }
      if (((struct _i2DataHeader *)pRemove)->i2sType == 0U) {
        {
        pCh->Obuf_char_count -= (int )((struct _i2DataHeader *)pRemove)->i2sCount;
        }
      }
      {
      pRemove += (int )packetSize;
      stripIndex = (unsigned short )((int )stripIndex + (int )packetSize);
      }
      {
      while (1) {
        while_137_continue: /* CIL Label */ ;
        {

        }
        goto while_159_break;
      }
      while_137_break: /* CIL Label */ ;
      }
      while_159_break: 
      {

      }
      if ((int )stripIndex >= 1024) {
        {
        stripIndex = (unsigned short)0;
        pRemove = pCh->Obuf;
        }
        {
        while (1) {
          while_138_continue: /* CIL Label */ ;
          {

          }
          goto while_160_break;
        }
        while_138_break: /* CIL Label */ ;
        }
        while_160_break: 
        {

        }
      }
    }
    while_134_break: /* CIL Label */ ;
    }
    while_156_break: 
    {

    }
    if (! bailout2) {
      {
      while (1) {
        while_139_continue: /* CIL Label */ ;
        {

        }
        goto while_161_break;
      }
      while_139_break: /* CIL Label */ ;
      }
      while_161_break: 
      {

      }
    }
    {
    pCh->Obuf_strip = (unsigned short volatile   )stripIndex;
    _write_unlock_irqrestore(& pCh->Obuf_spinlock, flags);
    }
    if (notClogged) {
      {
      while (1) {
        while_140_continue: /* CIL Label */ ;
        {

        }
        goto while_162_break;
      }
      while_140_break: /* CIL Label */ ;
      }
      while_162_break: 
      {

      }
      if (pCh->pTTY) {
        {
        ip2_owake(pCh->pTTY);
        }
      }
    }
  }
  while_132_break: /* CIL Label */ ;
  }
  while_154_break: 
  {

  }
  if (! bailout) {
    {
    while (1) {
      while_141_continue: /* CIL Label */ ;
      {

      }
      goto while_163_break;
    }
    while_141_break: /* CIL Label */ ;
    }
    while_163_break: 
    {

    }
  }
  {
  while (1) {
    while_142_continue: /* CIL Label */ ;
    {

    }
    goto while_164_break;
  }
  while_142_break: /* CIL Label */ ;
  }
  while_164_break: 
  {

  }
  return;
}
}
static void serviceOutgoingFifo(i2eBordStrPtr pB ) 
{ 

  {
  if (! pB->i2eWaitingForEmptyFifo) {
    {
    i2StuffFifoFlow(pB);
    i2StuffFifoBypass(pB);
    i2StuffFifoInline(pB);
    iiSendPendingMail(pB);
    }
  }
  return;
}
}
__inline static int ( __attribute__((__always_inline__)) i2ServiceBoard)(i2eBordStrPtr pB ) 
{ unsigned int inmail ;
  unsigned long flags ;
  unsigned short tmp ;

  {
  {
  inmail = (unsigned int )pB->i2eStartMail;
  }
  if (4369U == inmail) {
    {
    tmp = (*(pB->i2eGetMail))(pB);
    inmail = (unsigned int )tmp;
    }
  }
  {
  pB->i2eStartMail = (unsigned short)4369;
  }
  {
  while (1) {
    while_143_continue: /* CIL Label */ ;
    {

    }
    goto while_165_break;
  }
  while_143_break: /* CIL Label */ ;
  }
  while_165_break: 
  {

  }
  if (inmail != 4369U) {
    if (inmail & 32U) {
      {
      pB->i2eFatal = (unsigned short)1;
      }
      goto exit_i2ServiceBoard;
    }
    if (inmail & 128U) {
      {
      pB->i2eFifoInInts = (unsigned short )((int )pB->i2eFifoInInts + 1);
      i2StripFifo(pB);
      }
    }
    if (inmail & 64U) {
      {
      pB->i2eFifoOutInts = (unsigned short )((int )pB->i2eFifoOutInts + 1);
      flags = _write_lock_irqsave(& pB->write_fifo_spinlock);
      pB->i2eFifoRemains = (unsigned short volatile   )pB->i2eFifoSize;
      pB->i2eWaitingForEmptyFifo = (unsigned char)0;
      _write_unlock_irqrestore(& pB->write_fifo_spinlock, flags);
      }
      {
      while (1) {
        while_144_continue: /* CIL Label */ ;
        {

        }
        goto while_166_break;
      }
      while_144_break: /* CIL Label */ ;
      }
      while_166_break: 
      {

      }
    }
    {
    serviceOutgoingFifo(pB);
    }
  }
  {
  while (1) {
    while_145_continue: /* CIL Label */ ;
    {

    }
    goto while_167_break;
  }
  while_145_break: /* CIL Label */ ;
  }
  while_167_break: 
  {

  }
  exit_i2ServiceBoard: 
  return (0);
}
}
static int poll_only  =    0;
static int Eisa_irq  ;
static int Eisa_slot  ;
static int iindx  ;
static char rirqs[4]  ;
static int Valid_Irqs[9]  = 
  {      3,      4,      5,      7, 
        10,      11,      12,      15, 
        0};
static struct class *ip2_class  ;
static int is_valid_irq(int irq ) 
{ int *i ;

  {
  {
  i = Valid_Irqs;
  }
  {
  while (1) {
    while_146_continue: /* CIL Label */ ;
    {

    }
    if (*i != 0) {
      if (! (*i != irq)) {
        goto while_168_break;
      }
    } else {
      goto while_168_break;
    }
    {
    i ++;
    }
  }
  while_146_break: /* CIL Label */ ;
  }
  while_168_break: 
  {

  }
  return (*i);
}
}
static void mark_requested_irq(char irq ) 
{ int tmp ;

  {
  {
  tmp = iindx;
  iindx ++;
  rirqs[tmp] = irq;
  }
  return;
}
}
static int have_requested_irq(char irq ) 
{ int i ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_147_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_169_break;
    }
    if ((int )rirqs[i] == (int )irq) {
      return (1);
    }
    {
    i ++;
    }
  }
  while_147_break: /* CIL Label */ ;
  }
  while_169_break: 
  {

  }
  return (0);
}
}
static struct tty_operations  const  ip2_ops  = 
     {& ip2_open, & ip2_close, & ip2_write, (void (*)(struct tty_struct *tty , unsigned char ch ))(& ip2_putchar),
    & ip2_flush_chars, & ip2_write_room, & ip2_chars_in_buf, & ip2_ioctl, (long (*)(struct tty_struct *tty ,
                                                                                    struct file *file ,
                                                                                    unsigned int cmd ,
                                                                                    unsigned long arg ))0,
    & ip2_set_termios, & ip2_throttle, & ip2_unthrottle, & ip2_stop, & ip2_start,
    & ip2_hangup, (void (*)(struct tty_struct *tty , int state ))0, & ip2_flush_buffer,
    & ip2_set_line_discipline, (void (*)(struct tty_struct *tty , int timeout ))0,
    (void (*)(struct tty_struct *tty , char ch ))0, & ip2_read_proc, (int (*)(struct file *file ,
                                                                              char const   *buffer ,
                                                                              unsigned long count ,
                                                                              void *data ))0,
    & ip2_tiocmget, & ip2_tiocmset};
static int loaded  ;
static struct pci_dev *pci_dev_i  =    (struct pci_dev *)((void *)0);
extern int proc_create() ;
int ip2_loadmain(int *iop , int *irqp , unsigned char *firmware , int firmsize ) 
{ int i ;
  int j ;
  int box ;
  int err ;
  i2eBordStrPtr pB ;
  int rc ;
  int tmp ;
  int status ;
  unsigned int addr ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
  err = 0;
  pB = (struct _i2eBordStr *)((void *)0);
  rc = -1;
  }
  {
  while (1) {
    while_148_continue: /* CIL Label */ ;
    {

    }
    goto while_170_break;
  }
  while_148_break: /* CIL Label */ ;
  }
  while_170_break: 
  {
  i = 0;
  }
  {
  while (1) {
    while_149_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_171_break;
    }
    if (iop) {
      {
      ip2config.addr[i] = (unsigned short )*(iop + i);
      }
      if (irqp) {
        if (*(irqp + i) >= 0) {
          {
          ip2config.irq[i] = (short )*(irqp + i);
          }
        } else {
          {
          ip2config.irq[i] = (short)0;
          }
        }
        {
        poll_only |= *(irqp + i);
        }
      }
    }
    {
    i ++;
    }
  }
  while_149_break: /* CIL Label */ ;
  }
  while_171_break: 
  {
  poll_only = ! poll_only;
  Fip_firmware = firmware;
  Fip_firmware_size = firmsize;
  printk("<6>%s version %s\n", pcName, pcVersion);
  }
  if (loaded) {
    {
    printk("<6>Still loaded\n");
    }
    return (0);
  }
  {
  loaded ++;
  ip2_tty_driver = alloc_tty_driver(256);
  }
  if (! ip2_tty_driver) {
    return (-12);
  }
  {
  iiEllisInit();
  __constant_c_and_count_memset((void *)(i2BoardPtrTable), 0UL, sizeof(i2BoardPtrTable));
  __constant_c_and_count_memset((void *)(DevTable), 0UL, sizeof(DevTable));
  i = 0;
  }
  {
  while (1) {
    while_150_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_172_break;
    }
    if ((int )ip2config.addr[i] == 0) {
      goto switch_173_0;
    } else {
      if ((int )ip2config.addr[i] == 1) {
        goto switch_173_1;
      } else {
        if ((int )ip2config.addr[i] == 2) {
          goto switch_173_2;
        } else {
          goto switch_173_default;
          if (0) {
            switch_173_0: 
            goto switch_173_break;
            switch_173_default: 
            {

            }
            if ((int )ip2config.addr[i] < 256) {
              {
              printk("<3>IP2: Bad ISA board %d address %x\n", i, ip2config.addr[i]);
              ip2config.addr[i] = (unsigned short)0;
              }
            } else {
              if ((int )ip2config.addr[i] > 1016) {
                {
                printk("<3>IP2: Bad ISA board %d address %x\n", i, ip2config.addr[i]);
                ip2config.addr[i] = (unsigned short)0;
                }
              } else {
                {
                ip2config.type[i] = 0;
                }
                if (ip2config.irq[i]) {
                  {
                  tmp = is_valid_irq((int )ip2config.irq[i]);
                  }
                  if (! tmp) {
                    {
                    printk("<3>IP2: Bad IRQ(%d) specified\n", ip2config.irq[i]);
                    ip2config.irq[i] = (short)0;
                    }
                  }
                }
              }
            }
            goto switch_173_break;
            switch_173_1: 
            {
            pci_dev_i = pci_get_device(36366U, 657U, pci_dev_i);
            }
            if ((unsigned int )pci_dev_i != (unsigned int )((void *)0)) {
              {
              tmp___1 = pci_enable_device(pci_dev_i);
              }
              if (tmp___1) {
                {
                tmp___0 = pci_name(pci_dev_i);
                printk("<3>IP2: can\'t enable PCI device at %s\n", tmp___0);
                }
                goto switch_173_break;
              }
              {
              ip2config.type[i] = 1;
              ip2config.pci_dev[i] = pci_dev_get(pci_dev_i);
              status = pci_read_config_dword(pci_dev_i, 20, & addr);
              }
              if (addr & 1U) {
                {
                ip2config.addr[i] = (unsigned short )(addr & 65534U);
                }
              } else {
                {
                printk("<3>IP2: PCI I/O address error\n");
                }
              }
              {
              ip2config.irq[i] = (short )pci_dev_i->irq;
              }
            } else {
              {
              ip2config.addr[i] = (unsigned short)0;
              printk("<3>IP2: PCI board %d not found\n", i);
              }
            }
            goto switch_173_break;
            switch_173_2: 
            {
            tmp___2 = find_eisa_board(Eisa_slot + 1);
            ip2config.addr[i] = tmp___2;
            }
            if ((int )tmp___2 != 0) {
              {
              ip2config.type[i] = 2;
              }
            }
            {
            ip2config.irq[i] = (short )Eisa_irq;
            }
            goto switch_173_break;
          } else {
            switch_173_break: 
            {

            }
          }
        }
      }
    }
    {
    i ++;
    }
  }
  while_150_break: /* CIL Label */ ;
  }
  while_172_break: 
  {

  }
  if (pci_dev_i) {
    {
    pci_dev_put(pci_dev_i);
    }
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_151_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_174_break;
    }
    if (ip2config.addr[i]) {
      {
      tmp___3 = kzalloc(sizeof(i2eBordStr ), 208U);
      pB = (struct _i2eBordStr *)tmp___3;
      }
      if (pB) {
        {
        i2BoardPtrTable[i] = pB;
        iiSetAddress(pB, (int )ip2config.addr[i], & ii2DelayTimer);
        iiReset(pB);
        }
      } else {
        {
        printk("<3>IP2: board memory allocation error\n");
        }
      }
    }
    {
    i ++;
    }
  }
  while_151_break: /* CIL Label */ ;
  }
  while_174_break: 
  {
  i = 0;
  }
  {
  while (1) {
    while_152_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_175_break;
    }
    {
    pB = i2BoardPtrTable[i];
    }
    if ((unsigned int )pB != (unsigned int )((void *)0)) {
      {
      iiResetDelay(pB);
      }
      goto while_175_break;
    }
    {
    i ++;
    }
  }
  while_152_break: /* CIL Label */ ;
  }
  while_175_break: 
  {
  i = 0;
  }
  {
  while (1) {
    while_153_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_176_break;
    }
    if ((unsigned int )i2BoardPtrTable[i] != (unsigned int )((void *)0)) {
      {
      ip2_init_board(i);
      }
    }
    {
    i ++;
    }
  }
  while_153_break: /* CIL Label */ ;
  }
  while_176_break: 
  {

  }
  {
  while (1) {
    while_154_continue: /* CIL Label */ ;
    {

    }
    goto while_177_break;
  }
  while_154_break: /* CIL Label */ ;
  }
  while_177_break: 
  {
  ip2_tty_driver->owner = (struct module *)0;
  ip2_tty_driver->name = "ttyF";
  ip2_tty_driver->driver_name = (char const   *)pcDriver_name;
  ip2_tty_driver->major = 71;
  ip2_tty_driver->minor_start = 0;
  ip2_tty_driver->type = (short)3;
  ip2_tty_driver->subtype = (short)1;
  ip2_tty_driver->init_termios = tty_std_termios;
  ip2_tty_driver->init_termios.c_cflag = 3261U;
  ip2_tty_driver->flags = 12;
  tty_set_operations(ip2_tty_driver, & ip2_ops);
  }
  {
  while (1) {
    while_155_continue: /* CIL Label */ ;
    {

    }
    goto while_178_break;
  }
  while_155_break: /* CIL Label */ ;
  }
  while_178_break: 
  {
  err = tty_register_driver(ip2_tty_driver);
  }
  if (err) {
    {
    printk("<3>IP2: failed to register tty driver (%d)\n", err);
    put_tty_driver(ip2_tty_driver);
    }
    return (-22);
  } else {
    {
    err = register_chrdev(73U, (char const   *)pcIpl, & ip2_ipl);
    }
    if (err) {
      {
      printk("<3>IP2: failed to register IPL device (%d)\n", err);
      }
    } else {
      {
      ip2_class = class_create((struct module *)0, "ip2");
      tmp___5 = IS_ERR((void const   *)ip2_class);
      }
      if (tmp___5) {
        {
        tmp___4 = PTR_ERR((void const   *)ip2_class);
        err = (int )tmp___4;
        }
        goto out_chrdev;
      }
    }
  }
  {
  tmp___8 = proc_create("ip2mem", 0, (void *)0, & ip2mem_proc_fops);
  }
  if (tmp___8) {
    {
    while (1) {
      while_156_continue: /* CIL Label */ ;
      {

      }
      goto while_179_break;
    }
    while_156_break: /* CIL Label */ ;
    }
    while_179_break: 
    {
    i = 0;
    }
    {
    while (1) {
      while_157_continue: /* CIL Label */ ;
      {

      }
      if (! (i < 4)) {
        goto while_180_break;
      }
      if (0 == (int )ip2config.addr[i]) {
        goto __Cont;
      }
      {
      pB = i2BoardPtrTable[i];
      }
      if ((unsigned int )((void *)0) != (unsigned int )pB) {
        {
        device_create(ip2_class, (struct device *)((void *)0), (unsigned int )((73 << 20) | 4 * i),
                      "ipl%d", i);
        device_create(ip2_class, (struct device *)((void *)0), (unsigned int )((73 << 20) | (4 * i + 1)),
                      "stat%d", i);
        box = 0;
        }
        {
        while (1) {
          while_158_continue: /* CIL Label */ ;
          {

          }
          if (! (box < 4)) {
            goto while_181_break;
          }
          {
          j = 0;
          }
          {
          while (1) {
            while_159_continue: /* CIL Label */ ;
            {

            }
            if (! (j < 16)) {
              goto while_182_break;
            }
            if ((int )pB->i2eChannelMap[box] & (1 << j)) {
              {
              tty_register_device(ip2_tty_driver, (unsigned int )(j + 16 * (box + i * 4)),
                                  (struct device *)((void *)0));
              }
            }
            {
            j ++;
            }
          }
          while_159_break: /* CIL Label */ ;
          }
          while_182_break: 
          {
          box ++;
          }
        }
        while_158_break: /* CIL Label */ ;
        }
        while_181_break: 
        {

        }
      }
      if (poll_only) {
        {
        ip2config.irq[i] = (short)0;
        }
      }
      if ((int )ip2config.irq[i] == 0) {
        retry: 
        if (! TimerOn) {
          {
          PollTimer.expires = (unsigned long )(jiffies + (unsigned long volatile   )1);
          add_timer(& PollTimer);
          TimerOn = (char)1;
          printk("<6>IP2: polling\n");
          }
        }
      } else {
        {
        tmp___6 = have_requested_irq((char )ip2config.irq[i]);
        }
        if (tmp___6) {
          goto __Cont;
        }
        if (ip2config.type[i] == 1) {
          {
          tmp___7 = 128;
          }
        } else {
          {
          tmp___7 = 0;
          }
        }
        {
        rc = request_irq((unsigned int )ip2config.irq[i], & ip2_interrupt, (unsigned long )tmp___7,
                         (char const   *)pcName, (void *)i2BoardPtrTable[i]);
        }
        if (rc) {
          {
          printk("<3>IP2: an request_irq failed: error %d\n", rc);
          ip2config.irq[i] = (short)0;
          printk("<6>IP2: Polling %ld/sec.\n", (jiffies + (unsigned long volatile   )1) - jiffies);
          }
          goto retry;
        }
        {
        mark_requested_irq((char )ip2config.irq[i]);
        }
      }
      __Cont: 
      {
      i ++;
      }
    }
    while_157_break: /* CIL Label */ ;
    }
    while_180_break: 
    {
    i = 0;
    }
    {
    while (1) {
      while_160_continue: /* CIL Label */ ;
      {

      }
      if (! (i < 4)) {
        goto while_183_break;
      }
      if (i2BoardPtrTable[i]) {
        {
        set_irq(i, (int )ip2config.irq[i]);
        }
      }
      {
      i ++;
      }
    }
    while_160_break: /* CIL Label */ ;
    }
    while_183_break: 
    {

    }
  } else {
    {
    printk("<3>IP2: failed to register read_procmem\n");
    }
  }
  {
  while (1) {
    while_161_continue: /* CIL Label */ ;
    {

    }
    goto while_184_break;
  }
  while_161_break: /* CIL Label */ ;
  }
  while_184_break: 
  {

  }
  goto out;
  out_chrdev: 
  {
  unregister_chrdev(73U, "ip2");
  }
  out: 
  return (err);
}
}
static void ip2_init_board(int boardnum ) 
{ int i ;
  int nports ;
  int nboxes ;
  i2ChanStrPtr pCh ;
  i2eBordStrPtr pB ;
  int tmp ;
  struct resource *tmp___0 ;
  int tmp___1 ;
  int portnum ;
  int box ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  atomic_long_t __constr_expr_0 ;

  {
  {
  nports = 0;
  nboxes = 0;
  pB = i2BoardPtrTable[boardnum];
  tmp = iiInitialize(pB);
  }
  if (! tmp) {
    {
    printk("<3>IP2: Failed to initialize board at 0x%x, error %d\n", pB->i2eBase,
           pB->i2eError);
    }
    goto err_initialize;
  }
  {
  printk("<6>IP2: Board %d: addr=0x%x irq=%d\n", boardnum + 1, ip2config.addr[boardnum],
         ip2config.irq[boardnum]);
  tmp___0 = __request_region(& ioport_resource, (unsigned int )ip2config.addr[boardnum],
                             8U, (char const   *)pcName);
  }
  if (! tmp___0) {
    {
    printk("<3>IP2: bad addr=0x%x\n", ip2config.addr[boardnum]);
    }
    goto err_initialize;
  }
  {
  tmp___1 = iiDownloadAll(pB, (union _loadHdrStr *)Fip_firmware, 1, Fip_firmware_size);
  }
  if (tmp___1 != 2) {
    {
    printk("<3>IP2: failed to download loadware\n");
    }
    goto err_release_region;
  } else {
    {
    printk("<6>IP2: fv=%d.%d.%d lv=%d.%d.%d\n", pB->i2ePom.e.porVersion, pB->i2ePom.e.porRevision,
           pB->i2ePom.e.porSubRev, pB->i2eLVersion, pB->i2eLRevision, pB->i2eLSub);
    }
  }
  if (((int )pB->i2ePom.e.porID & -61) == 3) {
    goto switch_185_3;
  } else {
    if (((int )pB->i2ePom.e.porID & -61) == 0) {
      goto switch_185_0;
    } else {
      if (((int )pB->i2ePom.e.porID & -61) == 1) {
        goto switch_185_1;
      } else {
        if (((int )pB->i2ePom.e.porID & -61) == 64) {
          goto switch_185_64;
        } else {
          goto switch_185_default;
          if (0) {
            switch_185_default: 
            {
            printk("<3>IP2: Unknown board type, ID = %x\n", pB->i2ePom.e.porID);
            nports = 0;
            }
            goto err_release_region;
            goto switch_185_break;
            switch_185_3: 
            {
            printk("<6>IP2: ISA-4\n");
            nports = 4;
            }
            goto switch_185_break;
            switch_185_0: 
            {
            printk("<6>IP2: ISA-8 std\n");
            nports = 8;
            }
            goto switch_185_break;
            switch_185_1: 
            {
            printk("<6>IP2: ISA-8 RJ11\n");
            nports = 8;
            }
            goto switch_185_break;
            switch_185_64: 
            {
            portnum = 64 * boardnum;
            box = 0;
            }
            {
            while (1) {
              while_162_continue: /* CIL Label */ ;
              {

              }
              if (! (box < 4)) {
                goto while_186_break;
              }
              if ((int )pB->i2eChannelMap[box] != 0) {
                {
                nboxes ++;
                }
              }
              {
              i = 0;
              }
              {
              while (1) {
                while_163_continue: /* CIL Label */ ;
                {

                }
                if (! (i < 16)) {
                  goto while_187_break;
                }
                if ((int )pB->i2eChannelMap[box] & (1 << i)) {
                  {
                  nports ++;
                  }
                }
                {
                i ++;
                }
              }
              while_163_break: /* CIL Label */ ;
              }
              while_187_break: 
              {
              box ++;
              }
            }
            while_162_break: /* CIL Label */ ;
            }
            while_186_break: 
            {
            tmp___2 = kmalloc(sizeof(i2ChanStr ) * (unsigned int )nports, 208U);
            pCh = (struct _i2ChanStr *)tmp___2;
            DevTableMem[boardnum] = (void *)pCh;
            }
            if (! pCh) {
              {
              printk("<3>IP2: (i2_init_channel:) Out of memory.\n");
              }
              goto err_release_region;
            }
            {
            tmp___3 = i2InitChannels(pB, nports, pCh);
            }
            if (! tmp___3) {
              {
              printk("<3>IP2: i2InitChannels failed: %d\n", pB->i2eError);
              kfree((void const   *)pCh);
              }
              goto err_release_region;
            }
            {
            pB->i2eChannelPtr = (void *)(& DevTable[portnum]);
            pB->i2eChannelCnt = (unsigned short)64;
            box = 0;
            }
            {
            while (1) {
              while_164_continue: /* CIL Label */ ;
              {

              }
              if (! (box < 4)) {
                goto while_188_break;
              }
              {
              i = 0;
              }
              {
              while (1) {
                while_165_continue: /* CIL Label */ ;
                {

                }
                if (! (i < 16)) {
                  goto while_189_break;
                }
                if ((int )pB->i2eChannelMap[box] & (1 << i)) {
                  {
                  DevTable[portnum + i] = pCh;
                  pCh->port_index = portnum + i;
                  pCh ++;
                  }
                }
                {
                i ++;
                }
              }
              while_165_break: /* CIL Label */ ;
              }
              while_189_break: 
              {
              box ++;
              portnum += 16;
              }
            }
            while_164_break: /* CIL Label */ ;
            }
            while_188_break: 
            {

            }
            if (pB->i2eDataWidth16) {
              {
              tmp___4 = 16;
              }
            } else {
              {
              tmp___4 = 8;
              }
            }
            {
            printk("<6>IP2: EX box=%d ports=%d %d bit\n", nboxes, nports, tmp___4);
            }
            goto ex_exit;
          } else {
            switch_185_break: 
            {

            }
          }
        }
      }
    }
  }
  {
  tmp___5 = kmalloc(sizeof(i2ChanStr ) * (unsigned int )nports, 208U);
  pCh = (struct _i2ChanStr *)tmp___5;
  DevTableMem[boardnum] = (void *)pCh;
  }
  if (! pCh) {
    {
    printk("<3>IP2: (i2_init_channel:) Out of memory.\n");
    }
    goto err_release_region;
  }
  {
  pB->i2eChannelPtr = (void *)pCh;
  pB->i2eChannelCnt = (unsigned short )nports;
  tmp___6 = i2InitChannels(pB, nports, pCh);
  }
  if (! tmp___6) {
    {
    printk("<3>IP2: i2InitChannels failed: %d\n", pB->i2eError);
    kfree((void const   *)pCh);
    }
    goto err_release_region;
  }
  {
  pB->i2eChannelPtr = (void *)(& DevTable[64 * boardnum]);
  i = 0;
  }
  {
  while (1) {
    while_166_continue: /* CIL Label */ ;
    {

    }
    if (! (i < (int )pB->i2eChannelCnt)) {
      goto while_190_break;
    }
    {
    DevTable[64 * boardnum + i] = pCh;
    pCh->port_index = 64 * boardnum + i;
    pCh ++;
    i ++;
    }
  }
  while_166_break: /* CIL Label */ ;
  }
  while_190_break: 
  {

  }
  ex_exit: 
  {
  while (1) {
    while_167_continue: /* CIL Label */ ;
    {
    __constr_expr_0.counter = 0;
    pB->tqueue_interrupt.data = __constr_expr_0;
    INIT_LIST_HEAD(& pB->tqueue_interrupt.entry);
    }
    {
    while (1) {
      while_168_continue: /* CIL Label */ ;
      {
      pB->tqueue_interrupt.func = & ip2_interrupt_bh;
      }
      goto while_192_break;
    }
    while_168_break: /* CIL Label */ ;
    }
    while_192_break: 
    {

    }
    goto while_191_break;
  }
  while_167_break: /* CIL Label */ ;
  }
  while_191_break: 
  {

  }
  return;
  err_release_region: 
  {
  __release_region(& ioport_resource, (unsigned int )ip2config.addr[boardnum], 8U);
  }
  err_initialize: 
  {
  kfree((void const   *)pB);
  i2BoardPtrTable[boardnum] = (struct _i2eBordStr *)((void *)0);
  }
  return;
}
}
static unsigned short find_eisa_board(int start_slot ) 
{ int i ;
  int j ;
  unsigned int idm ;
  unsigned int idp ;
  unsigned int base ;
  unsigned int value ;
  int setup_address ;
  int setup_irq___0 ;
  int ismine ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
  {
  idm = 0U;
  idp = 0U;
  base = 0U;
  ismine = 0;
  i = 3200;
  tmp = inb(i);
  tmp___0 = inb(i + 1);
  tmp___1 = inb(i + 2);
  tmp___2 = inb(i + 3);
  value = (unsigned int )(((((int )tmp << 24) + ((int )tmp___0 << 16)) + ((int )tmp___1 << 8)) + (int )tmp___2);
  i = 7296;
  }
  {
  while (1) {
    while_169_continue: /* CIL Label */ ;
    {

    }
    if (! (i <= 19584)) {
      goto while_193_break;
    }
    {
    tmp___3 = inb(i);
    tmp___4 = inb(i + 1);
    tmp___5 = inb(i + 2);
    tmp___6 = inb(i + 3);
    j = ((((int )tmp___3 << 24) + ((int )tmp___4 << 16)) + ((int )tmp___5 << 8)) + (int )tmp___6;
    }
    if (value == (unsigned int )j) {
      return ((unsigned short)0);
    }
    {
    i += 4096;
    }
  }
  while_169_break: /* CIL Label */ ;
  }
  while_193_break: 
  {
  i = start_slot;
  }
  {
  while (1) {
    while_170_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 16)) {
      goto while_194_break;
    }
    {
    base = (unsigned int )(i << 12);
    tmp___7 = inb((int )(base + 3200U));
    tmp___8 = inb((int )(base + 3201U));
    idm = (unsigned int )(((int )tmp___7 << 8) | ((int )tmp___8 & 255));
    tmp___9 = inb((int )(base + 3202U));
    tmp___10 = inb((int )(base + 3203U));
    idp = (unsigned int )(((int )tmp___9 << 8) | ((int )tmp___10 & 255));
    ismine = 0;
    }
    if (idm == 3726U) {
      if (idp == 641U) {
        {
        ismine = 1;
        }
      } else {
        if (idp == 536U) {
          {
          ismine = 1;
          }
        } else {
          if (idp == 642U) {
            {
            ismine = 3;
            }
          } else {
            if (idp == 643U) {
              {
              ismine = 3;
              }
            }
          }
        }
      }
      if (ismine) {
        {
        Eisa_slot = i;
        }
        goto while_194_break;
      }
    }
    {
    i ++;
    }
  }
  while_170_break: /* CIL Label */ ;
  }
  while_194_break: 
  {

  }
  if (! ismine) {
    return ((unsigned short)0);
  }
  {
  setup_address = (int )(base + 3208U);
  tmp___11 = inb((int )(base + 3206U));
  value = (unsigned int )tmp___11;
  }
  if (value & 8U) {
    {
    setup_irq___0 = Valid_Irqs[value & 7U];
    }
  } else {
    {
    setup_irq___0 = 0;
    }
  }
  if (ismine & 2) {
    if (! (value & 16U)) {
      {
      ismine = 1;
      }
    }
  }
  if (Eisa_irq == 0) {
    {
    Eisa_irq = setup_irq___0;
    }
  } else {
    if (Eisa_irq != setup_irq___0) {
      {
      printk("<3>IP2: EISA irq mismatch between EISA controllers\n");
      }
    }
  }
  return ((unsigned short )setup_address);
}
}
static void set_irq(int boardnum , int boardIrq ) 
{ unsigned char tempCommand[16] ;
  i2eBordStrPtr pB ;
  unsigned long flags ;

  {
  {
  pB = i2BoardPtrTable[boardnum];
  (*(pB->i2eWriteMask))(pB, (unsigned char)0);
  ((struct _i2DataHeader *)(tempCommand))->i2sChannel = (unsigned char)0;
  ((struct _i2DataHeader *)(tempCommand))->i2sType = 2U;
  ((struct _i2CmdHeader *)(tempCommand))->i2sCount = 2U;
  *(& tempCommand[2] + 0) = (unsigned char)15;
  *(& tempCommand[2] + 1) = (unsigned char )boardIrq;
  flags = _write_lock_irqsave(& pB->write_fifo_spinlock);
  (*(pB->i2eWriteBuf))(pB, tempCommand, 4);
  _write_unlock_irqrestore(& pB->write_fifo_spinlock, flags);
  pB->i2eUsingIrq = (unsigned short )boardIrq;
  pB->i2eOutMailWaiting = (unsigned char )((int )pB->i2eOutMailWaiting | 128);
  i2nBoards = (unsigned short )((int )i2nBoards + 1);
  ((struct _i2DataHeader *)(tempCommand))->i2sChannel = (unsigned char)0;
  ((struct _i2DataHeader *)(tempCommand))->i2sType = 1U;
  ((struct _i2CmdHeader *)(tempCommand))->i2sCount = 6U;
  *(& tempCommand[2] + 0) = (unsigned char)88;
  *(& tempCommand[2] + 1) = (unsigned char)64;
  *(& tempCommand[2] + 2) = (unsigned char)32;
  *(& tempCommand[2] + 3) = (unsigned char)28;
  *(& tempCommand[2] + 4) = (unsigned char)64;
  *(& tempCommand[2] + 5) = (unsigned char)87;
  flags = _write_lock_irqsave(& pB->write_fifo_spinlock);
  (*(pB->i2eWriteBuf))(pB, tempCommand, 8);
  _write_unlock_irqrestore(& pB->write_fifo_spinlock, flags);
  ((struct _i2DataHeader *)(tempCommand))->i2sChannel = (unsigned char)0;
  ((struct _i2DataHeader *)(tempCommand))->i2sType = 1U;
  ((struct _i2CmdHeader *)(tempCommand))->i2sCount = 1U;
  *(& tempCommand[2] + 0) = (unsigned char)84;
  (*(pB->i2eWriteBuf))(pB, tempCommand, 3);
  (*(pB->i2eEnableMailIrq))(pB);
  iiSendPendingMail(pB);
  }
  return;
}
}
static void ip2_interrupt_bh(struct work_struct *work ) 
{ i2eBordStrPtr pB ;
  struct work_struct  const  *__mptr ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  pB = (i2eBordStr *)((char *)__mptr - (unsigned int )(& ((i2eBordStr *)0)->tqueue_interrupt));
  bh_counter ++;
  }
  if (pB) {
    {
    i2ServiceBoard(pB);
    }
    if (pB->i2eUsingIrq) {
      {
      (*(pB->i2eEnableMailIrq))(pB);
      }
    }
  }
  return;
}
}
static void ip2_irq_work(i2eBordStrPtr pB ) 
{ unsigned short tmp ;

  {
  {
  tmp = (*(pB->i2eGetMail))(pB);
  pB->i2eStartMail = tmp;
  }
  if (4369 != (int )tmp) {
    {
    (*(pB->i2eWriteMask))(pB, (unsigned char)0);
    schedule_work(& pB->tqueue_interrupt);
    }
  }
  return;
}
}
static void ip2_polled_interrupt(void) 
{ int i ;
  i2eBordStrPtr pB ;
  int irq ;

  {
  {
  irq = 0;
  }
  {
  while (1) {
    while_171_continue: /* CIL Label */ ;
    {

    }
    goto while_195_break;
  }
  while_171_break: /* CIL Label */ ;
  }
  while_195_break: 
  {
  i = 0;
  }
  {
  while (1) {
    while_172_continue: /* CIL Label */ ;
    {

    }
    if (! (i < (int )i2nBoards)) {
      goto while_196_break;
    }
    {
    pB = i2BoardPtrTable[i];
    }
    if (pB) {
      if ((int )pB->i2eUsingIrq == irq) {
        {
        ip2_irq_work(pB);
        }
      }
    }
    {
    i ++;
    }
  }
  while_172_break: /* CIL Label */ ;
  }
  while_196_break: 
  {
  irq_counter ++;
  }
  {
  while (1) {
    while_173_continue: /* CIL Label */ ;
    {

    }
    goto while_197_break;
  }
  while_173_break: /* CIL Label */ ;
  }
  while_197_break: 
  {

  }
  return;
}
}
static irqreturn_t ip2_interrupt(int irq , void *dev_id ) 
{ i2eBordStrPtr pB ;

  {
  {
  pB = (struct _i2eBordStr *)dev_id;
  }
  {
  while (1) {
    while_174_continue: /* CIL Label */ ;
    {

    }
    goto while_198_break;
  }
  while_174_break: /* CIL Label */ ;
  }
  while_198_break: 
  {
  ip2_irq_work(pB);
  irq_counter ++;
  }
  {
  while (1) {
    while_175_continue: /* CIL Label */ ;
    {

    }
    goto while_199_break;
  }
  while_175_break: /* CIL Label */ ;
  }
  while_199_break: 
  {

  }
  return (1);
}
}
static void ip2_poll(unsigned long arg ) 
{ 

  {
  {
  while (1) {
    while_176_continue: /* CIL Label */ ;
    {

    }
    goto while_200_break;
  }
  while_176_break: /* CIL Label */ ;
  }
  while_200_break: 
  {
  TimerOn = (char)0;
  ip2_polled_interrupt();
  PollTimer.expires = (unsigned long )(jiffies + (unsigned long volatile   )1);
  add_timer(& PollTimer);
  TimerOn = (char)1;
  }
  {
  while (1) {
    while_177_continue: /* CIL Label */ ;
    {

    }
    goto while_201_break;
  }
  while_177_break: /* CIL Label */ ;
  }
  while_201_break: 
  {

  }
  return;
}
}
static void do_input(struct work_struct *work ) 
{ i2ChanStrPtr pCh ;
  struct work_struct  const  *__mptr ;
  unsigned long flags ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  pCh = (i2ChanStr *)((char *)__mptr - (unsigned int )(& ((i2ChanStr *)0)->tqueue_input));
  }
  {
  while (1) {
    while_178_continue: /* CIL Label */ ;
    {

    }
    goto while_202_break;
  }
  while_178_break: /* CIL Label */ ;
  }
  while_202_break: 
  {

  }
  if ((unsigned int )pCh->pTTY != (unsigned int )((void *)0)) {
    {
    flags = _read_lock_irqsave(& pCh->Ibuf_spinlock);
    }
    if (! pCh->throttled) {
      if ((int volatile   )pCh->Ibuf_stuff != (int volatile   )pCh->Ibuf_strip) {
        {
        _read_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
        i2Input(pCh);
        }
      } else {
        {
        _read_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
        }
      }
    } else {
      {
      _read_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
      }
    }
  } else {
    {
    while (1) {
      while_179_continue: /* CIL Label */ ;
      {

      }
      goto while_203_break;
    }
    while_179_break: /* CIL Label */ ;
    }
    while_203_break: 
    {
    i2InputFlush(pCh);
    }
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) isig)(int sig , struct tty_struct *tty ,
                                                                int flush ) 
{ 

  {
  if (tty->pgrp) {
    {
    kill_pgrp(tty->pgrp, sig, 1);
    }
  }
  if (flush) {
    goto _L;
  } else {
    if (! ((tty->termios)->c_lflag & 128U)) {
      _L: 
      if (tty->ldisc.flush_buffer) {
        {
        (*(tty->ldisc.flush_buffer))(tty);
        }
      }
      {
      i2InputFlush((struct _i2ChanStr *)tty->driver_data);
      }
    }
  }
  return;
}
}
static void do_status(struct work_struct *work ) 
{ i2ChanStrPtr pCh ;
  struct work_struct  const  *__mptr ;
  int status ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  pCh = (i2ChanStr *)((char *)__mptr - (unsigned int )(& ((i2ChanStr *)0)->tqueue_status));
  status = i2GetStatus(pCh, 240);
  }
  {
  while (1) {
    while_180_continue: /* CIL Label */ ;
    {

    }
    goto while_204_break;
  }
  while_180_break: /* CIL Label */ ;
  }
  while_204_break: 
  {

  }
  if (pCh->pTTY) {
    if (status & 240) {
      if (status & 16) {
        if (((pCh->pTTY)->termios)->c_iflag & 1U) {
          goto skip_this;
        }
        if (((pCh->pTTY)->termios)->c_iflag & 2U) {
          {
          isig(2, pCh->pTTY, 1);
          }
          goto skip_this;
        }
        {
        __wake_up(& (pCh->pTTY)->read_wait, 1U, 1, (void *)0);
        }
      }
    }
  }
  skip_this: 
  if (status & 3840) {
    {
    __wake_up(& pCh->delta_msr_wait, 1U, 1, (void *)0);
    }
    if (pCh->flags & 33554432) {
      if (status & 256) {
        if (status & 1) {
          if (pCh->wopen) {
            {
            __wake_up(& pCh->open_wait, 1U, 1, (void *)0);
            }
          }
        } else {
          if (pCh->pTTY) {
            if (! (((pCh->pTTY)->termios)->c_cflag & 2048U)) {
              {
              tty_hangup(pCh->pTTY);
              }
            }
          }
        }
      }
    }
  }
  {
  while (1) {
    while_181_continue: /* CIL Label */ ;
    {

    }
    goto while_205_break;
  }
  while_181_break: /* CIL Label */ ;
  }
  while_205_break: 
  {

  }
  return;
}
}
static int ip2_open(PTTY tty , struct file *pFile ) 
{ wait_queue_t wait ;
  int rc ;
  int do_clocal ;
  i2ChanStrPtr pCh ;
  struct task_struct *tmp ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct task_struct *tmp___13 ;
  struct task_struct *tmp___14 ;
  struct task_struct *tmp___15 ;
  struct task_struct *tmp___18 ;
  struct task_struct *tmp___19 ;
  struct task_struct *tmp___22 ;
  struct task_struct *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  struct task_struct *tmp___26 ;
  int tmp___27 ;
  struct task_struct *tmp___30 ;
  struct task_struct *tmp___31 ;

  {
  {
  rc = 0;
  do_clocal = 0;
  pCh = DevTable[tty->index];
  }
  {
  while (1) {
    while_182_continue: /* CIL Label */ ;
    {

    }
    goto while_206_break;
  }
  while_182_break: /* CIL Label */ ;
  }
  while_206_break: 
  {

  }
  if ((unsigned int )pCh == (unsigned int )((void *)0)) {
    return (-19);
  }
  {
  pCh->pTTY = tty;
  tty->driver_data = (void *)pCh;
  i2QueueCommands(2, pCh, 100, 3, (struct _cmdSyntax *)(ct02), (struct _cmdSyntax *)(ct04),
                  (struct _cmdSyntax *)(ct20));
  pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut | 3);
  serviceOutgoingFifo(pCh->pMyBord);
  tmp = get_current();
  init_waitqueue_entry(& wait, tmp);
  add_wait_queue(& pCh->close_wait, & wait);
  }
  {
  while (1) {
    while_183_continue: /* CIL Label */ ;
    {
    tmp___3 = get_current();
    __xchg(1UL, (void volatile   *)(& tmp___3->state), (int )sizeof(tmp___2->state));
    }
    goto while_207_break;
  }
  while_183_break: /* CIL Label */ ;
  }
  while_207_break: 
  {
  tmp___10 = tty_hung_up_p(pFile);
  }
  if (tmp___10) {
    goto _L;
  } else {
    if (pCh->flags & 134217728) {
      _L: 
      if (pCh->flags & 134217728) {
        {
        schedule();
        }
      }
      {
      tmp___9 = tty_hung_up_p(pFile);
      }
      if (tmp___9) {
        {
        while (1) {
          while_184_continue: /* CIL Label */ ;
          {
          tmp___7 = get_current();
          __xchg(0UL, (void volatile   *)(& tmp___7->state), (int )sizeof(tmp___6->state));
          }
          goto while_208_break;
        }
        while_184_break: /* CIL Label */ ;
        }
        while_208_break: 
        {
        remove_wait_queue(& pCh->close_wait, & wait);
        }
        if (pCh->flags & 1) {
          {
          tmp___8 = -11;
          }
        } else {
          {
          tmp___8 = -512;
          }
        }
        return (tmp___8);
      }
    }
  }
  {
  while (1) {
    while_185_continue: /* CIL Label */ ;
    {
    tmp___14 = get_current();
    __xchg(0UL, (void volatile   *)(& tmp___14->state), (int )sizeof(tmp___13->state));
    }
    goto while_209_break;
  }
  while_185_break: /* CIL Label */ ;
  }
  while_209_break: 
  {
  remove_wait_queue(& pCh->close_wait, & wait);
  }
  if (pFile->f_flags & 2048U) {
    {
    pCh->flags |= 536870912;
    }
    goto noblock;
  } else {
    if (tty->flags & (unsigned long )(1 << 1)) {
      {
      pCh->flags |= 536870912;
      }
      goto noblock;
    }
  }
  if ((tty->termios)->c_cflag & 2048U) {
    {
    do_clocal = 1;
    }
  }
  {
  (pCh->wopen) ++;
  tmp___15 = get_current();
  init_waitqueue_entry(& wait, tmp___15);
  add_wait_queue(& pCh->open_wait, & wait);
  }
  {
  while (1) {
    while_186_continue: /* CIL Label */ ;
    {
    i2QueueCommands(2, pCh, 100, 2, (struct _cmdSyntax *)(ct02), (struct _cmdSyntax *)(ct04));
    pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut | 3);
    }
    {
    while (1) {
      while_187_continue: /* CIL Label */ ;
      {
      tmp___19 = get_current();
      __xchg(1UL, (void volatile   *)(& tmp___19->state), (int )sizeof(tmp___18->state));
      }
      goto while_211_break;
    }
    while_187_break: /* CIL Label */ ;
    }
    while_211_break: 
    {
    serviceOutgoingFifo(pCh->pMyBord);
    tmp___25 = tty_hung_up_p(pFile);
    }
    if (tmp___25) {
      {
      while (1) {
        while_188_continue: /* CIL Label */ ;
        {
        tmp___23 = get_current();
        __xchg(0UL, (void volatile   *)(& tmp___23->state), (int )sizeof(tmp___22->state));
        }
        goto while_212_break;
      }
      while_188_break: /* CIL Label */ ;
      }
      while_212_break: 
      {
      remove_wait_queue(& pCh->open_wait, & wait);
      }
      if (pCh->flags & 1) {
        {
        tmp___24 = -16;
        }
      } else {
        {
        tmp___24 = -512;
        }
      }
      return (tmp___24);
    }
    if (! (pCh->flags & 134217728)) {
      if (do_clocal) {
        {
        rc = 0;
        }
        goto while_210_break;
      } else {
        if ((int )pCh->dataSetIn & 1) {
          {
          rc = 0;
          }
          goto while_210_break;
        }
      }
    }
    {
    while (1) {
      while_189_continue: /* CIL Label */ ;
      {

      }
      goto while_213_break;
    }
    while_189_break: /* CIL Label */ ;
    }
    while_213_break: 
    {
    tmp___26 = get_current();
    tmp___27 = signal_pending(tmp___26);
    }
    if (tmp___27) {
      if (pCh->flags & 1) {
        {
        rc = -11;
        }
      } else {
        {
        rc = -512;
        }
      }
      goto while_210_break;
    }
    {
    schedule();
    }
  }
  while_186_break: /* CIL Label */ ;
  }
  while_210_break: 
  {

  }
  {
  while (1) {
    while_190_continue: /* CIL Label */ ;
    {
    tmp___31 = get_current();
    __xchg(0UL, (void volatile   *)(& tmp___31->state), (int )sizeof(tmp___30->state));
    }
    goto while_214_break;
  }
  while_190_break: /* CIL Label */ ;
  }
  while_214_break: 
  {
  remove_wait_queue(& pCh->open_wait, & wait);
  (pCh->wopen) --;
  }
  {
  while (1) {
    while_191_continue: /* CIL Label */ ;
    {

    }
    goto while_215_break;
  }
  while_191_break: /* CIL Label */ ;
  }
  while_215_break: 
  {

  }
  if (rc != 0) {
    return (rc);
  }
  {
  pCh->flags |= 536870912;
  }
  noblock: 
  if (tty->count == 1) {
    {
    i2QueueCommands(2, pCh, 0, 2, (struct _cmdSyntax *)(ct31), (struct _cmdSyntax *)(ct33));
    set_params(pCh, (struct ktermios *)((void *)0));
    }
  }
  {
  pCh->channelOptions = (unsigned short )((int )pCh->channelOptions | 1);
  serviceOutgoingFifo(pCh->pMyBord);
  }
  {
  while (1) {
    while_192_continue: /* CIL Label */ ;
    {

    }
    goto while_216_break;
  }
  while_192_break: /* CIL Label */ ;
  }
  while_216_break: 
  {

  }
  return (0);
}
}
extern int tty_driver_flush_buffer() ;
static void ip2_close(PTTY tty , struct file *pFile ) 
{ i2ChanStrPtr pCh ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  }
  if (! pCh) {
    return;
  }
  {
  while (1) {
    while_193_continue: /* CIL Label */ ;
    {

    }
    goto while_217_break;
  }
  while_193_break: /* CIL Label */ ;
  }
  while_217_break: 
  {
  tmp = tty_hung_up_p(pFile);
  }
  if (tmp) {
    {
    while (1) {
      while_194_continue: /* CIL Label */ ;
      {

      }
      goto while_218_break;
    }
    while_194_break: /* CIL Label */ ;
    }
    while_218_break: 
    {

    }
    return;
  }
  if (tty->count > 1) {
    {
    while (1) {
      while_195_continue: /* CIL Label */ ;
      {

      }
      goto while_219_break;
    }
    while_195_break: /* CIL Label */ ;
    }
    while_219_break: 
    {

    }
    return;
  }
  {
  pCh->flags |= 134217728;
  tty->closing = (unsigned char)1;
  }
  if ((int )pCh->ClosingWaitTime != 65535) {
    {
    ip2_wait_until_sent(tty, (int )pCh->ClosingWaitTime);
    }
  }
  {
  i2InputFlush(pCh);
  i2QueueCommands(2, pCh, 100, 4, (struct _cmdSyntax *)(ct21), (struct _cmdSyntax *)(ct19),
                  (struct _cmdSyntax *)(ct23), (struct _cmdSyntax *)(ct25));
  }
  if (! tty) {
    {
    i2QueueCommands(2, pCh, 100, 2, (struct _cmdSyntax *)(ct05), (struct _cmdSyntax *)(ct03));
    pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut & -4);
    ((struct _cmdSyntax *)(ct56))->cmd[1] = (unsigned char)25;
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct56));
    }
  } else {
    if ((tty->termios)->c_cflag & 1024U) {
      {
      i2QueueCommands(2, pCh, 100, 2, (struct _cmdSyntax *)(ct05), (struct _cmdSyntax *)(ct03));
      pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut & -4);
      ((struct _cmdSyntax *)(ct56))->cmd[1] = (unsigned char)25;
      i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct56));
      }
    }
  }
  {
  serviceOutgoingFifo(pCh->pMyBord);
  tty_ldisc_flush(tty);
  tty_driver_flush_buffer(tty);
  tty->closing = (unsigned char)0;
  pCh->pTTY = (struct tty_struct *)((void *)0);
  }
  if (pCh->wopen) {
    if (pCh->ClosingDelay) {
      {
      tmp___0 = jiffies_to_msecs((unsigned long )pCh->ClosingDelay);
      msleep_interruptible(tmp___0);
      }
    }
    {
    __wake_up(& pCh->open_wait, 1U, 1, (void *)0);
    }
  }
  {
  pCh->flags &= -671088641;
  __wake_up(& pCh->close_wait, 1U, 1, (void *)0);
  }
  {
  while (1) {
    while_196_continue: /* CIL Label */ ;
    {

    }
    goto while_220_break;
  }
  while_196_break: /* CIL Label */ ;
  }
  while_220_break: 
  {

  }
  return;
}
}
static void ip2_hangup(PTTY tty ) 
{ i2ChanStrPtr pCh ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  }
  if (! pCh) {
    return;
  }
  {
  while (1) {
    while_197_continue: /* CIL Label */ ;
    {

    }
    goto while_221_break;
  }
  while_197_break: /* CIL Label */ ;
  }
  while_221_break: 
  {
  ip2_flush_buffer(tty);
  i2QueueCommands(1, pCh, 0, 1, (struct _cmdSyntax *)(ct21));
  i2QueueCommands(2, pCh, 0, 2, (struct _cmdSyntax *)(ct31), (struct _cmdSyntax *)(ct33));
  }
  if ((tty->termios)->c_cflag & 1024U) {
    {
    i2QueueCommands(1, pCh, 0, 2, (struct _cmdSyntax *)(ct05), (struct _cmdSyntax *)(ct03));
    pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut & -4);
    ((struct _cmdSyntax *)(ct56))->cmd[1] = (unsigned char)25;
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct56));
    }
  }
  {
  i2QueueCommands(2, pCh, 1, 3, (struct _cmdSyntax *)(ct19), (struct _cmdSyntax *)(ct23),
                  (struct _cmdSyntax *)(ct25));
  serviceOutgoingFifo(pCh->pMyBord);
  __wake_up(& pCh->delta_msr_wait, 1U, 1, (void *)0);
  pCh->flags &= -536870913;
  pCh->pTTY = (struct tty_struct *)((void *)0);
  __wake_up(& pCh->open_wait, 1U, 1, (void *)0);
  }
  {
  while (1) {
    while_198_continue: /* CIL Label */ ;
    {

    }
    goto while_222_break;
  }
  while_198_break: /* CIL Label */ ;
  }
  while_222_break: 
  {

  }
  return;
}
}
static int ip2_write(PTTY tty , unsigned char const   *pData , int count ) 
{ i2ChanStrPtr pCh ;
  int bytesSent ;
  unsigned long flags ;
  int tmp ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  bytesSent = 0;
  }
  {
  while (1) {
    while_199_continue: /* CIL Label */ ;
    {

    }
    goto while_223_break;
  }
  while_199_break: /* CIL Label */ ;
  }
  while_223_break: 
  {
  ip2_flush_chars(tty);
  flags = _write_lock_irqsave(& pCh->Pbuf_spinlock);
  bytesSent = i2Output(pCh, (char const   *)pData, count);
  _write_unlock_irqrestore(& pCh->Pbuf_spinlock, flags);
  }
  {
  while (1) {
    while_200_continue: /* CIL Label */ ;
    {

    }
    goto while_224_break;
  }
  while_200_break: /* CIL Label */ ;
  }
  while_224_break: 
  {

  }
  if (bytesSent > 0) {
    {
    tmp = bytesSent;
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
static int ip2_putchar(PTTY tty , unsigned char ch ) 
{ i2ChanStrPtr pCh ;
  unsigned long flags ;
  USHORT volatile   tmp ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  flags = _write_lock_irqsave(& pCh->Pbuf_spinlock);
  tmp = pCh->Pbuf_stuff;
  pCh->Pbuf_stuff = (unsigned short volatile   )((int volatile   )pCh->Pbuf_stuff + (int volatile   )1);
  pCh->Pbuf[tmp] = ch;
  }
  if ((unsigned int )pCh->Pbuf_stuff == sizeof(pCh->Pbuf)) {
    {
    _write_unlock_irqrestore(& pCh->Pbuf_spinlock, flags);
    ip2_flush_chars(tty);
    }
  } else {
    {
    _write_unlock_irqrestore(& pCh->Pbuf_spinlock, flags);
    }
  }
  return (1);
}
}
static void ip2_flush_chars(PTTY tty ) 
{ int strip ;
  i2ChanStrPtr pCh ;
  unsigned long flags ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  flags = _write_lock_irqsave(& pCh->Pbuf_spinlock);
  }
  if (pCh->Pbuf_stuff) {
    {
    strip = i2Output(pCh, (char const   *)(pCh->Pbuf), (int )pCh->Pbuf_stuff);
    }
    if (strip != (int )pCh->Pbuf_stuff) {
      {
      memmove((void *)(pCh->Pbuf), (void const   *)(& pCh->Pbuf[strip]), (unsigned int )((int volatile   )pCh->Pbuf_stuff - (int volatile   )strip));
      }
    }
    {
    pCh->Pbuf_stuff = (unsigned short volatile   )((int volatile   )pCh->Pbuf_stuff - (int volatile   )strip);
    }
  }
  {
  _write_unlock_irqrestore(& pCh->Pbuf_spinlock, flags);
  }
  return;
}
}
static int ip2_write_room(PTTY tty ) 
{ int bytesFree ;
  i2ChanStrPtr pCh ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  flags = _read_lock_irqsave(& pCh->Pbuf_spinlock);
  tmp = i2OutputFree(pCh);
  bytesFree = tmp - (int )pCh->Pbuf_stuff;
  _read_unlock_irqrestore(& pCh->Pbuf_spinlock, flags);
  }
  {
  while (1) {
    while_201_continue: /* CIL Label */ ;
    {

    }
    goto while_225_break;
  }
  while_201_break: /* CIL Label */ ;
  }
  while_225_break: 
  {

  }
  if (bytesFree > 0) {
    {
    tmp___0 = bytesFree;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
static int ip2_chars_in_buf(PTTY tty ) 
{ i2ChanStrPtr pCh ;
  int rc ;
  unsigned long flags ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  }
  {
  while (1) {
    while_202_continue: /* CIL Label */ ;
    {

    }
    goto while_226_break;
  }
  while_202_break: /* CIL Label */ ;
  }
  while_226_break: 
  {
  flags = _read_lock_irqsave(& pCh->Obuf_spinlock);
  rc = pCh->Obuf_char_count;
  _read_unlock_irqrestore(& pCh->Obuf_spinlock, flags);
  flags = _read_lock_irqsave(& pCh->Pbuf_spinlock);
  rc += (int )pCh->Pbuf_stuff;
  _read_unlock_irqrestore(& pCh->Pbuf_spinlock, flags);
  }
  return (rc);
}
}
static void ip2_flush_buffer(PTTY tty ) 
{ i2ChanStrPtr pCh ;
  unsigned long flags ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  }
  {
  while (1) {
    while_203_continue: /* CIL Label */ ;
    {

    }
    goto while_227_break;
  }
  while_203_break: /* CIL Label */ ;
  }
  while_227_break: 
  {
  flags = _write_lock_irqsave(& pCh->Pbuf_spinlock);
  pCh->Pbuf_stuff = (unsigned short volatile   )0;
  _write_unlock_irqrestore(& pCh->Pbuf_spinlock, flags);
  i2FlushOutput(pCh);
  ip2_owake(tty);
  }
  {
  while (1) {
    while_204_continue: /* CIL Label */ ;
    {

    }
    goto while_228_break;
  }
  while_204_break: /* CIL Label */ ;
  }
  while_228_break: 
  {

  }
  return;
}
}
static void ip2_wait_until_sent(PTTY tty , int timeout ) 
{ int i ;
  i2ChanStrPtr pCh ;

  {
  {
  i = (int )jiffies;
  pCh = (struct _i2ChanStr *)tty->driver_data;
  tty_wait_until_sent(tty, (long )timeout);
  i = (int )((unsigned long volatile   )timeout - (jiffies - (unsigned long volatile   )i));
  }
  if (i > 0) {
    {
    i2DrainOutput(pCh, i);
    }
  }
  return;
}
}
static void ip2_throttle(PTTY tty ) 
{ i2ChanStrPtr pCh ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  pCh->throttled = 1;
  }
  return;
}
}
static void ip2_unthrottle(PTTY tty ) 
{ i2ChanStrPtr pCh ;
  unsigned long flags ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  pCh->throttled = 0;
  i2QueueCommands(1, pCh, 0, 1, (struct _cmdSyntax *)(ct41));
  serviceOutgoingFifo(pCh->pMyBord);
  flags = _read_lock_irqsave(& pCh->Ibuf_spinlock);
  }
  if ((int volatile   )pCh->Ibuf_stuff != (int volatile   )pCh->Ibuf_strip) {
    {
    _read_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
    i2Input(pCh);
    }
  } else {
    {
    _read_unlock_irqrestore(& pCh->Ibuf_spinlock, flags);
    }
  }
  return;
}
}
static void ip2_start(PTTY tty ) 
{ i2ChanStrPtr pCh ;

  {
  {
  pCh = DevTable[tty->index];
  i2QueueCommands(1, pCh, 0, 1, (struct _cmdSyntax *)(ct41));
  i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct58));
  i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct41));
  }
  return;
}
}
static void ip2_stop(PTTY tty ) 
{ i2ChanStrPtr pCh ;

  {
  {
  pCh = DevTable[tty->index];
  i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct57));
  }
  return;
}
}
static int ip2_tiocmget(struct tty_struct *tty , struct file *file ) 
{ i2ChanStrPtr pCh ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  pCh = DevTable[tty->index];
  }
  if ((unsigned int )pCh == (unsigned int )((void *)0)) {
    return (-19);
  }
  if ((int )pCh->dataSetOut & 2) {
    {
    tmp = 4;
    }
  } else {
    {
    tmp = 0;
    }
  }
  if ((int )pCh->dataSetOut & 1) {
    {
    tmp___0 = 2;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  if ((int )pCh->dataSetIn & 1) {
    {
    tmp___1 = 64;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  if ((int )pCh->dataSetIn & 8) {
    {
    tmp___2 = 128;
    }
  } else {
    {
    tmp___2 = 0;
    }
  }
  if ((int )pCh->dataSetIn & 4) {
    {
    tmp___3 = 256;
    }
  } else {
    {
    tmp___3 = 0;
    }
  }
  if ((int )pCh->dataSetIn & 2) {
    {
    tmp___4 = 32;
    }
  } else {
    {
    tmp___4 = 0;
    }
  }
  return (((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4);
}
}
static int ip2_tiocmset(struct tty_struct *tty , struct file *file , unsigned int set ,
                        unsigned int clear ) 
{ i2ChanStrPtr pCh ;

  {
  {
  pCh = DevTable[tty->index];
  }
  if ((unsigned int )pCh == (unsigned int )((void *)0)) {
    return (-19);
  }
  if (set & 4U) {
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct04));
    pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut | 2);
    }
  }
  if (set & 2U) {
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct02));
    pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut | 1);
    }
  }
  if (clear & 4U) {
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct05));
    pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut & -3);
    }
  }
  if (clear & 2U) {
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct03));
    pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut & -2);
    }
  }
  {
  serviceOutgoingFifo(pCh->pMyBord);
  }
  return (0);
}
}
static int ip2_ioctl(PTTY tty , struct file *pFile , UINT cmd , ULONG arg ) 
{ wait_queue_t wait ;
  i2ChanStrPtr pCh ;
  i2eBordStrPtr pB ;
  struct async_icount cprev ;
  struct async_icount cnow ;
  struct serial_icounter_struct *p_cuser ;
  int rc ;
  unsigned long flags ;
  void *argp ;
  int __ret_pu ;
  unsigned long __pu_val ;
  int __ret_gu ;
  unsigned long __val_gu ;
  int tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;
  struct task_struct *tmp___9 ;
  struct task_struct *tmp___10 ;
  int __ret_pu___0 ;
  int __pu_val___0 ;
  int __ret_pu___1 ;
  int __pu_val___1 ;
  int __ret_pu___2 ;
  int __pu_val___2 ;
  int __ret_pu___3 ;
  int __pu_val___3 ;
  int __ret_pu___4 ;
  int __pu_val___4 ;
  int __ret_pu___5 ;
  int __pu_val___5 ;
  int __ret_pu___6 ;
  int __pu_val___6 ;
  int __ret_pu___7 ;
  int __pu_val___7 ;
  int __ret_pu___8 ;
  int __pu_val___8 ;
  int __ret_pu___9 ;
  int __pu_val___9 ;
  int __ret_pu___10 ;
  int __pu_val___10 ;

  {
  {
  pCh = DevTable[tty->index];
  rc = 0;
  argp = (void *)arg;
  }
  if ((unsigned int )pCh == (unsigned int )((void *)0)) {
    return (-19);
  }
  {
  pB = pCh->pMyBord;
  }
  {
  while (1) {
    while_205_continue: /* CIL Label */ ;
    {

    }
    goto while_229_break;
  }
  while_205_break: /* CIL Label */ ;
  }
  while_229_break: 
  {

  }
  if ((int )cmd == 21534) {
    goto switch_230_21534;
  } else {
    if ((int )cmd == 21535) {
      goto switch_230_21535;
    } else {
      if ((int )cmd == 21514) {
        goto switch_230_21514;
      } else {
        if ((int )cmd == 21513) {
          goto switch_230_21513;
        } else {
          if ((int )cmd == 21541) {
            goto switch_230_21541;
          } else {
            if ((int )cmd == 21529) {
              goto switch_230_21529;
            } else {
              if ((int )cmd == 21530) {
                goto switch_230_21530;
              } else {
                if ((int )cmd == 21596) {
                  goto switch_230_21596;
                } else {
                  if ((int )cmd == 21597) {
                    goto switch_230_21597;
                  } else {
                    if ((int )cmd == 21587) {
                      goto switch_230_21587;
                    } else {
                      if ((int )cmd == 21588) {
                        goto switch_230_21587;
                      } else {
                        if ((int )cmd == 21593) {
                          goto switch_230_21587;
                        } else {
                          if ((int )cmd == 21589) {
                            goto switch_230_21587;
                          } else {
                            if ((int )cmd == 21592) {
                              goto switch_230_21587;
                            } else {
                              if ((int )cmd == 21594) {
                                goto switch_230_21587;
                              } else {
                                if ((int )cmd == 21595) {
                                  goto switch_230_21587;
                                } else {
                                  goto switch_230_21587;
                                  if (0) {
                                    switch_230_21534: 
                                    {
                                    while (1) {
                                      while_206_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_231_break;
                                    }
                                    while_206_break: /* CIL Label */ ;
                                    }
                                    while_231_break: 
                                    {
                                    rc = get_serial_info(pCh, (struct serial_struct *)argp);
                                    }
                                    if (rc) {
                                      return (rc);
                                    }
                                    goto switch_230_break;
                                    switch_230_21535: 
                                    {
                                    while (1) {
                                      while_207_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_232_break;
                                    }
                                    while_207_break: /* CIL Label */ ;
                                    }
                                    while_232_break: 
                                    {
                                    rc = set_serial_info(pCh, (struct serial_struct *)argp);
                                    }
                                    if (rc) {
                                      return (rc);
                                    }
                                    goto switch_230_break;
                                    switch_230_21514: 
                                    {
                                    rc = tty_check_change(tty);
                                    }
                                    if (rc) {
                                      return (rc);
                                    }
                                    if ((int )arg == 0) {
                                      goto switch_233_0;
                                    } else {
                                      if ((int )arg == 1) {
                                        goto switch_233_1;
                                      } else {
                                        if ((int )arg == 2) {
                                          goto switch_233_2;
                                        } else {
                                          if ((int )arg == 3) {
                                            goto switch_233_3;
                                          } else {
                                            goto switch_233_default;
                                            if (0) {
                                              switch_233_0: 
                                              goto switch_233_break;
                                              switch_233_1: 
                                              goto switch_233_break;
                                              switch_233_2: 
                                              if ((int )(tty->termios)->c_cc[9] != 0) {
                                                {
                                                ((struct _cmdSyntax *)(ct79))->cmd[1] = (tty->termios)->c_cc[9];
                                                i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct79));
                                                }
                                              }
                                              goto switch_233_break;
                                              switch_233_3: 
                                              if ((int )(tty->termios)->c_cc[8] != 0) {
                                                {
                                                ((struct _cmdSyntax *)(ct79))->cmd[1] = (tty->termios)->c_cc[8];
                                                i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct79));
                                                }
                                              }
                                              goto switch_233_break;
                                              switch_233_default: 
                                              {

                                              }
                                              return (-22);
                                            } else {
                                              switch_233_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    return (0);
                                    switch_230_21513: 
                                    {
                                    rc = tty_check_change(tty);
                                    }
                                    {
                                    while (1) {
                                      while_208_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_234_break;
                                    }
                                    while_208_break: /* CIL Label */ ;
                                    }
                                    while_234_break: 
                                    {

                                    }
                                    if (! rc) {
                                      {
                                      ip2_wait_until_sent(tty, 0);
                                      }
                                      if (! arg) {
                                        {
                                        ((struct _cmdSyntax *)(ct35))->cmd[1] = (unsigned char)250;
                                        i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct35));
                                        serviceOutgoingFifo(pCh->pMyBord);
                                        }
                                      }
                                    }
                                    goto switch_230_break;
                                    switch_230_21541: 
                                    {
                                    rc = tty_check_change(tty);
                                    }
                                    {
                                    while (1) {
                                      while_209_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_235_break;
                                    }
                                    while_209_break: /* CIL Label */ ;
                                    }
                                    while_235_break: 
                                    {

                                    }
                                    if (! rc) {
                                      {
                                      ip2_wait_until_sent(tty, 0);
                                      }
                                      if (arg) {
                                        {
                                        ((struct _cmdSyntax *)(ct35))->cmd[1] = (unsigned char )(arg * 100UL);
                                        }
                                      } else {
                                        {
                                        ((struct _cmdSyntax *)(ct35))->cmd[1] = (unsigned char)250;
                                        }
                                      }
                                      {
                                      i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct35));
                                      serviceOutgoingFifo(pCh->pMyBord);
                                      }
                                    }
                                    goto switch_230_break;
                                    switch_230_21529: 
                                    {
                                    while (1) {
                                      while_210_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_236_break;
                                    }
                                    while_210_break: /* CIL Label */ ;
                                    }
                                    while_236_break: 
                                    {

                                    }
                                    if ((tty->termios)->c_cflag & 2048U) {
                                      {
                                      __pu_val = 1UL;
                                      }
                                    } else {
                                      {
                                      __pu_val = 0UL;
                                      }
                                    }
                                    if ((int )sizeof(*((unsigned long *)argp)) == 1) {
                                      goto switch_237_1;
                                    } else {
                                      if ((int )sizeof(*((unsigned long *)argp)) == 2) {
                                        goto switch_237_2;
                                      } else {
                                        if ((int )sizeof(*((unsigned long *)argp)) == 4) {
                                          goto switch_237_4;
                                        } else {
                                          if ((int )sizeof(*((unsigned long *)argp)) == 8) {
                                            goto switch_237_8;
                                          } else {
                                            goto switch_237_default;
                                            if (0) {
                                              switch_237_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val),
                                                                   "c" ((unsigned long *)argp));
                                              }
                                              goto switch_237_break;
                                              switch_237_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val),
                                                                   "c" ((unsigned long *)argp));
                                              }
                                              goto switch_237_break;
                                              switch_237_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val),
                                                                   "c" ((unsigned long *)argp));
                                              }
                                              goto switch_237_break;
                                              switch_237_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "A" (__pu_val),
                                                                   "c" ((unsigned long *)argp));
                                              }
                                              goto switch_237_break;
                                              switch_237_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "c" ((unsigned long *)argp));
                                              }
                                              goto switch_237_break;
                                            } else {
                                              switch_237_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu;
                                    }
                                    if (rc) {
                                      return (rc);
                                    }
                                    goto switch_230_break;
                                    switch_230_21530: 
                                    {
                                    while (1) {
                                      while_211_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_238_break;
                                    }
                                    while_211_break: /* CIL Label */ ;
                                    }
                                    while_238_break: 
                                    {

                                    }
                                    if ((int )sizeof(*((unsigned long *)argp)) == 1) {
                                      goto switch_239_1;
                                    } else {
                                      if ((int )sizeof(*((unsigned long *)argp)) == 2) {
                                        goto switch_239_2;
                                      } else {
                                        if ((int )sizeof(*((unsigned long *)argp)) == 4) {
                                          goto switch_239_4;
                                        } else {
                                          goto switch_239_default;
                                          if (0) {
                                            switch_239_1: 
                                            {
                                            __asm__  volatile   ("call __get_user_"
                                                                 "1": "=a" (__ret_gu),
                                                                 "=d" (__val_gu): "0" ((unsigned long *)argp));
                                            }
                                            goto switch_239_break;
                                            switch_239_2: 
                                            {
                                            __asm__  volatile   ("call __get_user_"
                                                                 "2": "=a" (__ret_gu),
                                                                 "=d" (__val_gu): "0" ((unsigned long *)argp));
                                            }
                                            goto switch_239_break;
                                            switch_239_4: 
                                            {
                                            __asm__  volatile   ("call __get_user_"
                                                                 "4": "=a" (__ret_gu),
                                                                 "=d" (__val_gu): "0" ((unsigned long *)argp));
                                            }
                                            goto switch_239_break;
                                            switch_239_default: 
                                            {
                                            __asm__  volatile   ("call __get_user_"
                                                                 "X": "=a" (__ret_gu),
                                                                 "=d" (__val_gu): "0" ((unsigned long *)argp));
                                            }
                                            goto switch_239_break;
                                          } else {
                                            switch_239_break: 
                                            {

                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    arg = __val_gu;
                                    rc = __ret_gu;
                                    }
                                    if (rc) {
                                      return (rc);
                                    }
                                    if (arg) {
                                      {
                                      tmp = 2048;
                                      }
                                    } else {
                                      {
                                      tmp = 0;
                                      }
                                    }
                                    {
                                    (tty->termios)->c_cflag = ((tty->termios)->c_cflag & 4294965247U) | (unsigned int )tmp;
                                    }
                                    goto switch_230_break;
                                    switch_230_21596: 
                                    {
                                    flags = _write_lock_irqsave(& pB->read_fifo_spinlock);
                                    cprev = pCh->icount;
                                    _write_unlock_irqrestore(& pB->read_fifo_spinlock,
                                                             flags);
                                    i2QueueCommands(1, pCh, 100, 4, (struct _cmdSyntax *)(ct20),
                                                    (struct _cmdSyntax *)(ct18), (struct _cmdSyntax *)(ct22),
                                                    (struct _cmdSyntax *)(ct24));
                                    tmp___0 = get_current();
                                    init_waitqueue_entry(& wait, tmp___0);
                                    add_wait_queue(& pCh->delta_msr_wait, & wait);
                                    }
                                    {
                                    while (1) {
                                      while_212_continue: /* CIL Label */ ;
                                      {
                                      tmp___4 = get_current();
                                      __xchg(1UL, (void volatile   *)(& tmp___4->state),
                                             (int )sizeof(tmp___3->state));
                                      }
                                      goto while_240_break;
                                    }
                                    while_212_break: /* CIL Label */ ;
                                    }
                                    while_240_break: 
                                    {
                                    serviceOutgoingFifo(pCh->pMyBord);
                                    }
                                    {
                                    while (1) {
                                      while_213_continue: /* CIL Label */ ;
                                      {

                                      }
                                      {
                                      while (1) {
                                        while_214_continue: /* CIL Label */ ;
                                        {

                                        }
                                        goto while_242_break;
                                      }
                                      while_214_break: /* CIL Label */ ;
                                      }
                                      while_242_break: 
                                      {
                                      schedule();
                                      }
                                      {
                                      while (1) {
                                        while_215_continue: /* CIL Label */ ;
                                        {

                                        }
                                        goto while_243_break;
                                      }
                                      while_215_break: /* CIL Label */ ;
                                      }
                                      while_243_break: 
                                      {
                                      tmp___5 = get_current();
                                      tmp___6 = signal_pending(tmp___5);
                                      }
                                      if (tmp___6) {
                                        {
                                        rc = -512;
                                        }
                                        goto while_241_break;
                                      }
                                      {
                                      flags = _write_lock_irqsave(& pB->read_fifo_spinlock);
                                      cnow = pCh->icount;
                                      _write_unlock_irqrestore(& pB->read_fifo_spinlock,
                                                               flags);
                                      }
                                      if (cnow.rng == cprev.rng) {
                                        if (cnow.dsr == cprev.dsr) {
                                          if (cnow.dcd == cprev.dcd) {
                                            if (cnow.cts == cprev.cts) {
                                              {
                                              rc = -5;
                                              }
                                              goto while_241_break;
                                            }
                                          }
                                        }
                                      }
                                      if (arg & 128UL) {
                                        if (cnow.rng != cprev.rng) {
                                          {
                                          rc = 0;
                                          }
                                          goto while_241_break;
                                        } else {
                                          goto _L___1;
                                        }
                                      } else {
                                        _L___1: 
                                        if (arg & 256UL) {
                                          if (cnow.dsr != cprev.dsr) {
                                            {
                                            rc = 0;
                                            }
                                            goto while_241_break;
                                          } else {
                                            goto _L___0;
                                          }
                                        } else {
                                          _L___0: 
                                          if (arg & 64UL) {
                                            if (cnow.dcd != cprev.dcd) {
                                              {
                                              rc = 0;
                                              }
                                              goto while_241_break;
                                            } else {
                                              goto _L;
                                            }
                                          } else {
                                            _L: 
                                            if (arg & 32UL) {
                                              if (cnow.cts != cprev.cts) {
                                                {
                                                rc = 0;
                                                }
                                                goto while_241_break;
                                              }
                                            }
                                          }
                                        }
                                      }
                                      {
                                      cprev = cnow;
                                      }
                                    }
                                    while_213_break: /* CIL Label */ ;
                                    }
                                    while_241_break: 
                                    {

                                    }
                                    {
                                    while (1) {
                                      while_216_continue: /* CIL Label */ ;
                                      {
                                      tmp___10 = get_current();
                                      __xchg(0UL, (void volatile   *)(& tmp___10->state),
                                             (int )sizeof(tmp___9->state));
                                      }
                                      goto while_244_break;
                                    }
                                    while_216_break: /* CIL Label */ ;
                                    }
                                    while_244_break: 
                                    {
                                    remove_wait_queue(& pCh->delta_msr_wait, & wait);
                                    i2QueueCommands(1, pCh, 100, 3, (struct _cmdSyntax *)(ct19),
                                                    (struct _cmdSyntax *)(ct23), (struct _cmdSyntax *)(ct25));
                                    }
                                    if (! (pCh->flags & 33554432)) {
                                      {
                                      i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct21));
                                      }
                                    }
                                    {
                                    serviceOutgoingFifo(pCh->pMyBord);
                                    }
                                    return (rc);
                                    goto switch_230_break;
                                    switch_230_21597: 
                                    {
                                    while (1) {
                                      while_217_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_245_break;
                                    }
                                    while_217_break: /* CIL Label */ ;
                                    }
                                    while_245_break: 
                                    {
                                    flags = _write_lock_irqsave(& pB->read_fifo_spinlock);
                                    cnow = pCh->icount;
                                    _write_unlock_irqrestore(& pB->read_fifo_spinlock,
                                                             flags);
                                    p_cuser = (struct serial_icounter_struct *)argp;
                                    __pu_val___0 = (int )cnow.cts;
                                    }
                                    if ((int )sizeof(p_cuser->cts) == 1) {
                                      goto switch_246_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->cts) == 2) {
                                        goto switch_246_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->cts) == 4) {
                                          goto switch_246_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->cts) == 8) {
                                            goto switch_246_8;
                                          } else {
                                            goto switch_246_default;
                                            if (0) {
                                              switch_246_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___0): "0" (__pu_val___0),
                                                                   "c" (& p_cuser->cts));
                                              }
                                              goto switch_246_break;
                                              switch_246_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___0): "0" (__pu_val___0),
                                                                   "c" (& p_cuser->cts));
                                              }
                                              goto switch_246_break;
                                              switch_246_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___0): "0" (__pu_val___0),
                                                                   "c" (& p_cuser->cts));
                                              }
                                              goto switch_246_break;
                                              switch_246_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "A" (__pu_val___0),
                                                                   "c" (& p_cuser->cts));
                                              }
                                              goto switch_246_break;
                                              switch_246_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___0): "c" (& p_cuser->cts));
                                              }
                                              goto switch_246_break;
                                            } else {
                                              switch_246_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___0;
                                    __pu_val___1 = (int )cnow.dsr;
                                    }
                                    if ((int )sizeof(p_cuser->dsr) == 1) {
                                      goto switch_247_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->dsr) == 2) {
                                        goto switch_247_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->dsr) == 4) {
                                          goto switch_247_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->dsr) == 8) {
                                            goto switch_247_8;
                                          } else {
                                            goto switch_247_default;
                                            if (0) {
                                              switch_247_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___1): "0" (__pu_val___1),
                                                                   "c" (& p_cuser->dsr));
                                              }
                                              goto switch_247_break;
                                              switch_247_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___1): "0" (__pu_val___1),
                                                                   "c" (& p_cuser->dsr));
                                              }
                                              goto switch_247_break;
                                              switch_247_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___1): "0" (__pu_val___1),
                                                                   "c" (& p_cuser->dsr));
                                              }
                                              goto switch_247_break;
                                              switch_247_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___1): "A" (__pu_val___1),
                                                                   "c" (& p_cuser->dsr));
                                              }
                                              goto switch_247_break;
                                              switch_247_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___1): "c" (& p_cuser->dsr));
                                              }
                                              goto switch_247_break;
                                            } else {
                                              switch_247_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___1;
                                    __pu_val___2 = (int )cnow.rng;
                                    }
                                    if ((int )sizeof(p_cuser->rng) == 1) {
                                      goto switch_248_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->rng) == 2) {
                                        goto switch_248_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->rng) == 4) {
                                          goto switch_248_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->rng) == 8) {
                                            goto switch_248_8;
                                          } else {
                                            goto switch_248_default;
                                            if (0) {
                                              switch_248_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                                                   "c" (& p_cuser->rng));
                                              }
                                              goto switch_248_break;
                                              switch_248_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                                                   "c" (& p_cuser->rng));
                                              }
                                              goto switch_248_break;
                                              switch_248_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                                                   "c" (& p_cuser->rng));
                                              }
                                              goto switch_248_break;
                                              switch_248_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___2): "A" (__pu_val___2),
                                                                   "c" (& p_cuser->rng));
                                              }
                                              goto switch_248_break;
                                              switch_248_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___2): "c" (& p_cuser->rng));
                                              }
                                              goto switch_248_break;
                                            } else {
                                              switch_248_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___2;
                                    __pu_val___3 = (int )cnow.dcd;
                                    }
                                    if ((int )sizeof(p_cuser->dcd) == 1) {
                                      goto switch_249_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->dcd) == 2) {
                                        goto switch_249_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->dcd) == 4) {
                                          goto switch_249_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->dcd) == 8) {
                                            goto switch_249_8;
                                          } else {
                                            goto switch_249_default;
                                            if (0) {
                                              switch_249_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___3): "0" (__pu_val___3),
                                                                   "c" (& p_cuser->dcd));
                                              }
                                              goto switch_249_break;
                                              switch_249_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___3): "0" (__pu_val___3),
                                                                   "c" (& p_cuser->dcd));
                                              }
                                              goto switch_249_break;
                                              switch_249_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___3): "0" (__pu_val___3),
                                                                   "c" (& p_cuser->dcd));
                                              }
                                              goto switch_249_break;
                                              switch_249_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___3): "A" (__pu_val___3),
                                                                   "c" (& p_cuser->dcd));
                                              }
                                              goto switch_249_break;
                                              switch_249_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___3): "c" (& p_cuser->dcd));
                                              }
                                              goto switch_249_break;
                                            } else {
                                              switch_249_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___3;
                                    __pu_val___4 = (int )cnow.rx;
                                    }
                                    if ((int )sizeof(p_cuser->rx) == 1) {
                                      goto switch_250_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->rx) == 2) {
                                        goto switch_250_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->rx) == 4) {
                                          goto switch_250_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->rx) == 8) {
                                            goto switch_250_8;
                                          } else {
                                            goto switch_250_default;
                                            if (0) {
                                              switch_250_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___4): "0" (__pu_val___4),
                                                                   "c" (& p_cuser->rx));
                                              }
                                              goto switch_250_break;
                                              switch_250_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___4): "0" (__pu_val___4),
                                                                   "c" (& p_cuser->rx));
                                              }
                                              goto switch_250_break;
                                              switch_250_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___4): "0" (__pu_val___4),
                                                                   "c" (& p_cuser->rx));
                                              }
                                              goto switch_250_break;
                                              switch_250_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___4): "A" (__pu_val___4),
                                                                   "c" (& p_cuser->rx));
                                              }
                                              goto switch_250_break;
                                              switch_250_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___4): "c" (& p_cuser->rx));
                                              }
                                              goto switch_250_break;
                                            } else {
                                              switch_250_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___4;
                                    __pu_val___5 = (int )cnow.tx;
                                    }
                                    if ((int )sizeof(p_cuser->tx) == 1) {
                                      goto switch_251_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->tx) == 2) {
                                        goto switch_251_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->tx) == 4) {
                                          goto switch_251_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->tx) == 8) {
                                            goto switch_251_8;
                                          } else {
                                            goto switch_251_default;
                                            if (0) {
                                              switch_251_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___5): "0" (__pu_val___5),
                                                                   "c" (& p_cuser->tx));
                                              }
                                              goto switch_251_break;
                                              switch_251_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___5): "0" (__pu_val___5),
                                                                   "c" (& p_cuser->tx));
                                              }
                                              goto switch_251_break;
                                              switch_251_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___5): "0" (__pu_val___5),
                                                                   "c" (& p_cuser->tx));
                                              }
                                              goto switch_251_break;
                                              switch_251_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___5): "A" (__pu_val___5),
                                                                   "c" (& p_cuser->tx));
                                              }
                                              goto switch_251_break;
                                              switch_251_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___5): "c" (& p_cuser->tx));
                                              }
                                              goto switch_251_break;
                                            } else {
                                              switch_251_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___5;
                                    __pu_val___6 = (int )cnow.frame;
                                    }
                                    if ((int )sizeof(p_cuser->frame) == 1) {
                                      goto switch_252_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->frame) == 2) {
                                        goto switch_252_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->frame) == 4) {
                                          goto switch_252_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->frame) == 8) {
                                            goto switch_252_8;
                                          } else {
                                            goto switch_252_default;
                                            if (0) {
                                              switch_252_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___6): "0" (__pu_val___6),
                                                                   "c" (& p_cuser->frame));
                                              }
                                              goto switch_252_break;
                                              switch_252_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___6): "0" (__pu_val___6),
                                                                   "c" (& p_cuser->frame));
                                              }
                                              goto switch_252_break;
                                              switch_252_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___6): "0" (__pu_val___6),
                                                                   "c" (& p_cuser->frame));
                                              }
                                              goto switch_252_break;
                                              switch_252_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___6): "A" (__pu_val___6),
                                                                   "c" (& p_cuser->frame));
                                              }
                                              goto switch_252_break;
                                              switch_252_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___6): "c" (& p_cuser->frame));
                                              }
                                              goto switch_252_break;
                                            } else {
                                              switch_252_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___6;
                                    __pu_val___7 = (int )cnow.overrun;
                                    }
                                    if ((int )sizeof(p_cuser->overrun) == 1) {
                                      goto switch_253_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->overrun) == 2) {
                                        goto switch_253_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->overrun) == 4) {
                                          goto switch_253_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->overrun) == 8) {
                                            goto switch_253_8;
                                          } else {
                                            goto switch_253_default;
                                            if (0) {
                                              switch_253_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___7): "0" (__pu_val___7),
                                                                   "c" (& p_cuser->overrun));
                                              }
                                              goto switch_253_break;
                                              switch_253_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___7): "0" (__pu_val___7),
                                                                   "c" (& p_cuser->overrun));
                                              }
                                              goto switch_253_break;
                                              switch_253_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___7): "0" (__pu_val___7),
                                                                   "c" (& p_cuser->overrun));
                                              }
                                              goto switch_253_break;
                                              switch_253_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___7): "A" (__pu_val___7),
                                                                   "c" (& p_cuser->overrun));
                                              }
                                              goto switch_253_break;
                                              switch_253_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___7): "c" (& p_cuser->overrun));
                                              }
                                              goto switch_253_break;
                                            } else {
                                              switch_253_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___7;
                                    __pu_val___8 = (int )cnow.parity;
                                    }
                                    if ((int )sizeof(p_cuser->parity) == 1) {
                                      goto switch_254_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->parity) == 2) {
                                        goto switch_254_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->parity) == 4) {
                                          goto switch_254_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->parity) == 8) {
                                            goto switch_254_8;
                                          } else {
                                            goto switch_254_default;
                                            if (0) {
                                              switch_254_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___8): "0" (__pu_val___8),
                                                                   "c" (& p_cuser->parity));
                                              }
                                              goto switch_254_break;
                                              switch_254_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___8): "0" (__pu_val___8),
                                                                   "c" (& p_cuser->parity));
                                              }
                                              goto switch_254_break;
                                              switch_254_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___8): "0" (__pu_val___8),
                                                                   "c" (& p_cuser->parity));
                                              }
                                              goto switch_254_break;
                                              switch_254_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___8): "A" (__pu_val___8),
                                                                   "c" (& p_cuser->parity));
                                              }
                                              goto switch_254_break;
                                              switch_254_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___8): "c" (& p_cuser->parity));
                                              }
                                              goto switch_254_break;
                                            } else {
                                              switch_254_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___8;
                                    __pu_val___9 = (int )cnow.brk;
                                    }
                                    if ((int )sizeof(p_cuser->brk) == 1) {
                                      goto switch_255_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->brk) == 2) {
                                        goto switch_255_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->brk) == 4) {
                                          goto switch_255_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->brk) == 8) {
                                            goto switch_255_8;
                                          } else {
                                            goto switch_255_default;
                                            if (0) {
                                              switch_255_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___9): "0" (__pu_val___9),
                                                                   "c" (& p_cuser->brk));
                                              }
                                              goto switch_255_break;
                                              switch_255_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___9): "0" (__pu_val___9),
                                                                   "c" (& p_cuser->brk));
                                              }
                                              goto switch_255_break;
                                              switch_255_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___9): "0" (__pu_val___9),
                                                                   "c" (& p_cuser->brk));
                                              }
                                              goto switch_255_break;
                                              switch_255_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___9): "A" (__pu_val___9),
                                                                   "c" (& p_cuser->brk));
                                              }
                                              goto switch_255_break;
                                              switch_255_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___9): "c" (& p_cuser->brk));
                                              }
                                              goto switch_255_break;
                                            } else {
                                              switch_255_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___9;
                                    __pu_val___10 = (int )cnow.buf_overrun;
                                    }
                                    if ((int )sizeof(p_cuser->buf_overrun) == 1) {
                                      goto switch_256_1;
                                    } else {
                                      if ((int )sizeof(p_cuser->buf_overrun) == 2) {
                                        goto switch_256_2;
                                      } else {
                                        if ((int )sizeof(p_cuser->buf_overrun) == 4) {
                                          goto switch_256_4;
                                        } else {
                                          if ((int )sizeof(p_cuser->buf_overrun) == 8) {
                                            goto switch_256_8;
                                          } else {
                                            goto switch_256_default;
                                            if (0) {
                                              switch_256_1: 
                                              {
                                              __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___10): "0" (__pu_val___10),
                                                                   "c" (& p_cuser->buf_overrun));
                                              }
                                              goto switch_256_break;
                                              switch_256_2: 
                                              {
                                              __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___10): "0" (__pu_val___10),
                                                                   "c" (& p_cuser->buf_overrun));
                                              }
                                              goto switch_256_break;
                                              switch_256_4: 
                                              {
                                              __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___10): "0" (__pu_val___10),
                                                                   "c" (& p_cuser->buf_overrun));
                                              }
                                              goto switch_256_break;
                                              switch_256_8: 
                                              {
                                              __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___10): "A" (__pu_val___10),
                                                                   "c" (& p_cuser->buf_overrun));
                                              }
                                              goto switch_256_break;
                                              switch_256_default: 
                                              {
                                              __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___10): "c" (& p_cuser->buf_overrun));
                                              }
                                              goto switch_256_break;
                                            } else {
                                              switch_256_break: 
                                              {

                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                    {
                                    rc = __ret_pu___10;
                                    }
                                    goto switch_230_break;
                                    switch_230_21587: 
                                    {

                                    }
                                    {
                                    while (1) {
                                      while_218_continue: /* CIL Label */ ;
                                      {

                                      }
                                      goto while_257_break;
                                    }
                                    while_218_break: /* CIL Label */ ;
                                    }
                                    while_257_break: 
                                    {
                                    rc = -515;
                                    }
                                    goto switch_230_break;
                                  } else {
                                    switch_230_break: 
                                    {

                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
  while (1) {
    while_219_continue: /* CIL Label */ ;
    {

    }
    goto while_258_break;
  }
  while_219_break: /* CIL Label */ ;
  }
  while_258_break: 
  {

  }
  return (rc);
}
}
static int get_serial_info(i2ChanStrPtr pCh , struct serial_struct *retinfo ) 
{ struct serial_struct tmp ;
  unsigned long tmp___0 ;

  {
  {
  __constant_c_and_count_memset((void *)(& tmp), 0UL, sizeof(tmp));
  tmp.type = (int )(pCh->pMyBord)->channelBtypes.bid_value[(pCh->port_index & 63) / 16];
  }
  if ((tmp.type & 7) == 4) {
    {
    tmp.type = 6;
    }
  } else {
    {
    tmp.type = 5;
    }
  }
  {
  tmp.line = pCh->port_index;
  tmp.port = (unsigned int )(pCh->pMyBord)->i2eBase;
  tmp.irq = (int )ip2config.irq[pCh->port_index / 64];
  tmp.flags = pCh->flags;
  tmp.baud_base = pCh->BaudBase;
  tmp.close_delay = pCh->ClosingDelay;
  tmp.closing_wait = pCh->ClosingWaitTime;
  tmp.custom_divisor = pCh->BaudDivisor;
  tmp___0 = copy_to_user((void *)retinfo, (void const   *)(& tmp), (unsigned long )sizeof(*retinfo));
  }
  return ((int )tmp___0);
}
}
static int set_serial_info(i2ChanStrPtr pCh , struct serial_struct *new_info ) 
{ struct serial_struct ns ;
  int old_flags ;
  int old_baud_divisor ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp = copy_from_user((void *)(& ns), (void const   *)new_info, (unsigned long )sizeof(ns));
  }
  if (tmp) {
    return (-14);
  }
  if (ns.irq != (int )ip2config.irq[pCh->port_index]) {
    return (-22);
  } else {
    if ((int )ns.port != (pCh->pMyBord)->i2eBase) {
      return (-22);
    } else {
      if (ns.baud_base != pCh->BaudBase) {
        return (-22);
      } else {
        if (ns.line != pCh->port_index) {
          return (-22);
        }
      }
    }
  }
  {
  old_flags = pCh->flags;
  old_baud_divisor = pCh->BaudDivisor;
  tmp___0 = capable(21);
  }
  if (tmp___0) {
    {
    pCh->flags = (pCh->flags & -32768) | (ns.flags & 32767);
    pCh->BaudDivisor = ns.custom_divisor;
    pCh->ClosingDelay = (unsigned short )(((int )ns.close_delay * 250) / 100);
    pCh->ClosingWaitTime = (unsigned short )(((int )ns.closing_wait * 250) / 100);
    }
  } else {
    if ((int )ns.close_delay != (int )pCh->ClosingDelay) {
      return (-1);
    } else {
      if ((ns.flags & -13361) != (pCh->flags & -13361)) {
        return (-1);
      }
    }
    {
    pCh->flags = (pCh->flags & -13361) | (ns.flags & 13360);
    pCh->BaudDivisor = ns.custom_divisor;
    }
  }
  if ((old_flags & 4144) != (pCh->flags & 4144)) {
    {
    set_params(pCh, (struct ktermios *)((void *)0));
    }
  } else {
    if (old_baud_divisor != pCh->BaudDivisor) {
      {
      set_params(pCh, (struct ktermios *)((void *)0));
      }
    }
  }
  return (0);
}
}
static void ip2_set_termios(PTTY tty , struct ktermios *old_termios ) 
{ i2ChanStrPtr pCh ;

  {
  {
  pCh = (struct _i2ChanStr *)tty->driver_data;
  set_params(pCh, old_termios);
  }
  return;
}
}
static void ip2_set_line_discipline(PTTY tty ) 
{ 

  {
  {
  while (1) {
    while_220_continue: /* CIL Label */ ;
    {

    }
    goto while_259_break;
  }
  while_220_break: /* CIL Label */ ;
  }
  while_259_break: 
  {

  }
  return;
}
}
static void set_params(i2ChanStrPtr pCh , struct ktermios *o_tios ) 
{ tcflag_t cflag ;
  tcflag_t iflag ;
  tcflag_t lflag ;
  char stop_char ;
  char start_char ;
  struct ktermios dummy ;
  int bps ;
  cmdSyntaxPtr tmp ;
  int tmp___0 ;
  int datasize ;
  char brkrpt ;
  char parrpt ;

  {
  {
  lflag = ((pCh->pTTY)->termios)->c_lflag;
  cflag = ((pCh->pTTY)->termios)->c_cflag;
  iflag = ((pCh->pTTY)->termios)->c_iflag;
  }
  if ((unsigned int )o_tios == (unsigned int )((void *)0)) {
    {
    dummy.c_lflag = ~ lflag;
    dummy.c_cflag = ~ cflag;
    dummy.c_iflag = ~ iflag;
    o_tios = & dummy;
    }
  }
  if ((int )(cflag & 4111U) == 0) {
    goto switch_260_0;
  } else {
    if ((int )(cflag & 4111U) == 15) {
      goto switch_260_15;
    } else {
      if ((int )(cflag & 4111U) == 1) {
        goto switch_260_1;
      } else {
        if ((int )(cflag & 4111U) == 2) {
          goto switch_260_2;
        } else {
          if ((int )(cflag & 4111U) == 3) {
            goto switch_260_3;
          } else {
            if ((int )(cflag & 4111U) == 4) {
              goto switch_260_4;
            } else {
              if ((int )(cflag & 4111U) == 5) {
                goto switch_260_5;
              } else {
                if ((int )(cflag & 4111U) == 6) {
                  goto switch_260_6;
                } else {
                  if ((int )(cflag & 4111U) == 7) {
                    goto switch_260_7;
                  } else {
                    if ((int )(cflag & 4111U) == 8) {
                      goto switch_260_8;
                    } else {
                      if ((int )(cflag & 4111U) == 9) {
                        goto switch_260_9;
                      } else {
                        if ((int )(cflag & 4111U) == 10) {
                          goto switch_260_10;
                        } else {
                          if ((int )(cflag & 4111U) == 11) {
                            goto switch_260_11;
                          } else {
                            if ((int )(cflag & 4111U) == 12) {
                              goto switch_260_12;
                            } else {
                              if ((int )(cflag & 4111U) == 13) {
                                goto switch_260_13;
                              } else {
                                if ((int )(cflag & 4111U) == 14) {
                                  goto switch_260_14;
                                } else {
                                  if ((int )(cflag & 4111U) == 4097) {
                                    goto switch_260_4097;
                                  } else {
                                    if ((int )(cflag & 4111U) == 4098) {
                                      goto switch_260_4098;
                                    } else {
                                      if ((int )(cflag & 4111U) == 4101) {
                                        goto switch_260_4101;
                                      } else {
                                        if ((int )(cflag & 4111U) == 4099) {
                                          goto switch_260_4099;
                                        } else {
                                          if ((int )(cflag & 4111U) == 4102) {
                                            goto switch_260_4102;
                                          } else {
                                            if ((int )(cflag & 4111U) == 4100) {
                                              goto switch_260_4100;
                                            } else {
                                              if ((int )(cflag & 4111U) == 4103) {
                                                goto switch_260_4103;
                                              } else {
                                                goto switch_260_default;
                                                if (0) {
                                                  switch_260_0: 
                                                  {
                                                  i2QueueCommands(1, pCh, 100, 2,
                                                                  (struct _cmdSyntax *)(ct05),
                                                                  (struct _cmdSyntax *)(ct03));
                                                  pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut & -4);
                                                  ((struct _cmdSyntax *)(ct56))->cmd[1] = (unsigned char)25;
                                                  i2QueueCommands(2, pCh, 100, 1,
                                                                  (struct _cmdSyntax *)(ct56));
                                                  ((pCh->pTTY)->termios)->c_cflag |= 4111U & o_tios->c_cflag;
                                                  }
                                                  goto service_it;
                                                  goto switch_260_break;
                                                  switch_260_15: 
                                                  if ((pCh->flags & 4144) == 16) {
                                                    {
                                                    pCh->speed = 20;
                                                    }
                                                  } else {
                                                    if ((pCh->flags & 4144) == 32) {
                                                      {
                                                      pCh->speed = 23;
                                                      }
                                                    } else {
                                                      if ((pCh->flags & 4144) == 48) {
                                                        {
                                                        pCh->speed = 24;
                                                        }
                                                      } else {
                                                        {
                                                        pCh->speed = 15;
                                                        }
                                                      }
                                                    }
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_1: 
                                                  {
                                                  pCh->speed = 1;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_2: 
                                                  {
                                                  pCh->speed = 2;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_3: 
                                                  {
                                                  pCh->speed = 3;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4: 
                                                  {
                                                  pCh->speed = 4;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_5: 
                                                  {
                                                  pCh->speed = 5;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_6: 
                                                  {
                                                  pCh->speed = 6;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_7: 
                                                  {
                                                  pCh->speed = 7;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_8: 
                                                  {
                                                  pCh->speed = 8;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_9: 
                                                  {
                                                  pCh->speed = 9;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_10: 
                                                  {
                                                  pCh->speed = 10;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_11: 
                                                  {
                                                  pCh->speed = 11;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_12: 
                                                  {
                                                  pCh->speed = 12;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_13: 
                                                  {
                                                  pCh->speed = 13;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_14: 
                                                  {
                                                  pCh->speed = 14;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4097: 
                                                  {
                                                  pCh->speed = 20;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4098: 
                                                  {
                                                  pCh->speed = 23;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4101: 
                                                  {
                                                  pCh->speed = 26;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4099: 
                                                  {
                                                  pCh->speed = 27;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4102: 
                                                  {
                                                  pCh->speed = 28;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4100: 
                                                  {
                                                  pCh->speed = 29;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_4103: 
                                                  {
                                                  pCh->speed = 30;
                                                  }
                                                  goto switch_260_break;
                                                  switch_260_default: 
                                                  {
                                                  pCh->speed = 13;
                                                  }
                                                  goto switch_260_break;
                                                } else {
                                                  switch_260_break: 
                                                  {

                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (pCh->speed == 24) {
    {
    bps = pCh->BaudBase / pCh->BaudDivisor;
    }
    if (bps == 921600) {
      {
      pCh->speed = 30;
      }
    } else {
      {
      bps /= 10;
      tmp = i2cmdBaudDef(1, (unsigned short )bps);
      i2QueueCommands(2, pCh, 100, 1, tmp);
      }
    }
  }
  {
  ((struct _cmdSyntax *)(ct07))->cmd[1] = (unsigned char )pCh->speed;
  i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct07));
  i2QueueCommands(2, pCh, 100, 2, (struct _cmdSyntax *)(ct02), (struct _cmdSyntax *)(ct04));
  pCh->dataSetOut = (unsigned short )((int )pCh->dataSetOut | 3);
  }
  if ((64U & cflag) ^ (64U & o_tios->c_cflag)) {
    if (cflag & 64U) {
      {
      ((struct _cmdSyntax *)(ct09))->cmd[1] = (unsigned char)2;
      }
    } else {
      {
      ((struct _cmdSyntax *)(ct09))->cmd[1] = (unsigned char)0;
      }
    }
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct09));
    }
  }
  if ((768U & cflag) ^ (768U & o_tios->c_cflag)) {
    if (cflag & 256U) {
      if (cflag & 512U) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 2;
        }
      }
      {
      ((struct _cmdSyntax *)(ct10))->cmd[1] = (unsigned char )tmp___0;
      }
    } else {
      {
      ((struct _cmdSyntax *)(ct10))->cmd[1] = (unsigned char)0;
      }
    }
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct10));
    }
  }
  if ((48U & cflag) ^ (48U & o_tios->c_cflag)) {
    if ((int )(cflag & 48U) == 0) {
      goto switch_261_0;
    } else {
      if ((int )(cflag & 48U) == 16) {
        goto switch_261_16;
      } else {
        if ((int )(cflag & 48U) == 32) {
          goto switch_261_32;
        } else {
          if ((int )(cflag & 48U) == 48) {
            goto switch_261_48;
          } else {
            goto switch_261_default;
            if (0) {
              switch_261_0: 
              {
              datasize = 0;
              }
              goto switch_261_break;
              switch_261_16: 
              {
              datasize = 1;
              }
              goto switch_261_break;
              switch_261_32: 
              {
              datasize = 2;
              }
              goto switch_261_break;
              switch_261_48: 
              {
              datasize = 3;
              }
              goto switch_261_break;
              switch_261_default: 
              {
              datasize = 0;
              }
              goto switch_261_break;
            } else {
              switch_261_break: 
              {

              }
            }
          }
        }
      }
    }
    {
    ((struct _cmdSyntax *)(ct08))->cmd[1] = (unsigned char )datasize;
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct08));
    }
  }
  if (cflag & 2147483648U) {
    {
    i2QueueCommands(2, pCh, 100, 2, (struct _cmdSyntax *)(ct30), (struct _cmdSyntax *)(ct32));
    }
  } else {
    {
    i2QueueCommands(2, pCh, 100, 2, (struct _cmdSyntax *)(ct31), (struct _cmdSyntax *)(ct33));
    }
  }
  {
  stop_char = (char )((pCh->pTTY)->termios)->c_cc[9];
  start_char = (char )((pCh->pTTY)->termios)->c_cc[8];
  }
  if ((int )stop_char == 0) {
    {
    stop_char = (char )(~ '\000');
    }
  }
  if ((int )start_char == 0) {
    {
    start_char = (char )(~ '\000');
    }
  }
  if ((int )o_tios->c_cc[8] != (int )start_char) {
    {
    ((struct _cmdSyntax *)(ct11))->cmd[1] = (unsigned char )start_char;
    i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct11));
    ((struct _cmdSyntax *)(ct63))->cmd[1] = (unsigned char )start_char;
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct63));
    }
  }
  if ((int )o_tios->c_cc[9] != (int )stop_char) {
    {
    ((struct _cmdSyntax *)(ct12))->cmd[1] = (unsigned char )stop_char;
    i2QueueCommands(1, pCh, 100, 1, (struct _cmdSyntax *)(ct12));
    ((struct _cmdSyntax *)(ct64))->cmd[1] = (unsigned char )stop_char;
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct64));
    }
  }
  if ((int )stop_char == 0) {
    {
    stop_char = (char )(~ '\000');
    }
    goto no_xoff;
  }
  if ((iflag & 4096U) ^ (o_tios->c_iflag & 4096U)) {
    if (iflag & 4096U) {
      {
      ((struct _cmdSyntax *)(ct17))->cmd[1] = (unsigned char)1;
      i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct17));
      }
    } else {
      no_xoff: 
      {
      ((struct _cmdSyntax *)(ct17))->cmd[1] = (unsigned char)0;
      i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct17));
      }
    }
  }
  if ((int )start_char == 0) {
    goto no_xon;
  }
  if ((iflag & 3072U) ^ (o_tios->c_iflag & 3072U)) {
    if (iflag & 1024U) {
      if (iflag & 2048U) {
        {
        ((struct _cmdSyntax *)(ct16))->cmd[1] = (unsigned char)2;
        i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct16));
        }
      } else {
        {
        ((struct _cmdSyntax *)(ct16))->cmd[1] = (unsigned char)1;
        i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct16));
        }
      }
    } else {
      no_xon: 
      {
      ((struct _cmdSyntax *)(ct16))->cmd[1] = (unsigned char)0;
      i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct16));
      }
    }
  }
  if ((iflag & 32U) ^ (o_tios->c_iflag & 32U)) {
    if (iflag & 32U) {
      {
      ((struct _cmdSyntax *)(ct34))->cmd[1] = (unsigned char)1;
      }
    } else {
      {
      ((struct _cmdSyntax *)(ct34))->cmd[1] = (unsigned char)0;
      }
    }
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct34));
    }
  }
  if ((iflag & 16U) ^ (o_tios->c_iflag & 16U)) {
    if (iflag & 16U) {
      {
      ((struct _cmdSyntax *)(ct59))->cmd[1] = (unsigned char)0;
      }
    } else {
      {
      ((struct _cmdSyntax *)(ct59))->cmd[1] = (unsigned char)1;
      }
    }
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct59));
    }
  }
  if ((iflag & 15U) ^ (o_tios->c_iflag & 15U)) {
    {
    brkrpt = (char)0;
    parrpt = (char)0;
    }
    if (iflag & 1U) {
      {
      i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct27));
      }
    } else {
      if (iflag & 2U) {
        if (iflag & 8U) {
          {
          brkrpt = (char)10;
          }
        } else {
          {
          brkrpt = (char)26;
          }
        }
        {
        brkrpt = (char )((int )brkrpt | 4);
        }
      } else {
        if (iflag & 8U) {
          {
          brkrpt = (char)11;
          }
        } else {
          {
          brkrpt = (char)1;
          }
        }
      }
      {
      ((struct _cmdSyntax *)(ct26))->cmd[1] = (unsigned char )brkrpt;
      i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct26));
      }
    }
    if (iflag & 4U) {
      {
      parrpt = (char)32;
      }
    } else {
      if (iflag & 8U) {
        {
        parrpt = (char)4;
        ((struct _cmdSyntax *)(ct34))->cmd[1] = (unsigned char)0;
        i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct34));
        }
      } else {
        {
        parrpt = (char)3;
        }
      }
    }
    {
    ((struct _cmdSyntax *)(ct36))->cmd[1] = (unsigned char )parrpt;
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct36));
    }
  }
  if (cflag & 2048U) {
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct21));
    pCh->flags &= -33554433;
    }
  } else {
    {
    i2QueueCommands(2, pCh, 100, 1, (struct _cmdSyntax *)(ct20));
    pCh->flags |= 33554432;
    }
  }
  service_it: 
  {
  i2DrainOutput(pCh, 100);
  }
  return;
}
}
static ssize_t ip2_ipl_read(struct file *pFile , char *pData , size_t count , loff_t *off ) 
{ unsigned int minor ;
  unsigned int tmp ;
  int rc ;

  {
  {
  tmp = iminor((struct inode  const  *)(pFile->f_path.dentry)->d_inode);
  minor = tmp;
  rc = 0;
  }
  if ((int )minor == 0) {
    goto switch_262_0;
  } else {
    if ((int )minor == 1) {
      goto switch_262_1;
    } else {
      if ((int )minor == 2) {
        goto switch_262_2;
      } else {
        if ((int )minor == 3) {
          goto switch_262_3;
        } else {
          if ((int )minor == 4) {
            goto switch_262_4;
          } else {
            goto switch_262_default;
            if (0) {
              switch_262_0: 
              {
              rc = -22;
              }
              goto switch_262_break;
              switch_262_1: 
              {
              rc = -22;
              }
              goto switch_262_break;
              switch_262_2: 
              {
              rc = -22;
              }
              goto switch_262_break;
              switch_262_3: 
              {
              rc = DumpTraceBuffer(pData, (int )count);
              }
              goto switch_262_break;
              switch_262_4: 
              {
              rc = DumpFifoBuffer(pData, (int )count);
              }
              goto switch_262_break;
              switch_262_default: 
              {
              rc = -19;
              }
              goto switch_262_break;
            } else {
              switch_262_break: 
              {

              }
            }
          }
        }
      }
    }
  }
  return (rc);
}
}
static int DumpFifoBuffer(char *pData , int count ) 
{ 

  {
  return (0);
}
}
static int DumpTraceBuffer(char *pData , int count ) 
{ 

  {
  return (0);
}
}
static ssize_t ip2_ipl_write(struct file *pFile , char const   *pData , size_t count ,
                             loff_t *off ) 
{ 

  {
  return (0);
}
}
static int ip2_ipl_ioctl(struct inode *pInode , struct file *pFile , UINT cmd , ULONG arg ) 
{ unsigned int iplminor ;
  unsigned int tmp ;
  int rc ;
  void *argp ;
  ULONG *pIndex ;
  i2eBordStrPtr pB ;
  i2ChanStrPtr pCh ;
  int __ret_pu ;
  ULONG __pu_val ;
  ULONG *tmp___1 ;
  ULONG *tmp___4 ;
  ULONG *tmp___7 ;
  ULONG *tmp___10 ;
  ULONG *tmp___13 ;
  ULONG *tmp___14 ;
  int __ret_pu___0 ;
  ULONG __pu_val___0 ;
  ULONG *tmp___16 ;
  ULONG *tmp___19 ;
  ULONG *tmp___22 ;
  ULONG *tmp___25 ;
  ULONG *tmp___28 ;
  ULONG *tmp___29 ;
  int __ret_pu___1 ;
  ULONG __pu_val___1 ;
  ULONG *tmp___31 ;
  ULONG *tmp___34 ;
  ULONG *tmp___37 ;
  ULONG *tmp___40 ;
  ULONG *tmp___43 ;
  ULONG *tmp___44 ;
  unsigned long tmp___45 ;
  int __ret_pu___2 ;
  ULONG __pu_val___2 ;
  unsigned char tmp___46 ;
  unsigned long tmp___47 ;

  {
  {
  tmp = iminor((struct inode  const  *)pInode);
  iplminor = tmp;
  rc = 0;
  argp = (void *)arg;
  pIndex = (ULONG *)argp;
  pB = i2BoardPtrTable[iplminor / 4U];
  }
  if ((int )iplminor == 0) {
    goto switch_263_0;
  } else {
    if ((int )iplminor == 1) {
      goto switch_263_1;
    } else {
      if ((int )iplminor == 5) {
        goto switch_263_1;
      } else {
        if ((int )iplminor == 9) {
          goto switch_263_1;
        } else {
          if ((int )iplminor == 13) {
            goto switch_263_1;
          } else {
            if ((int )iplminor == 2) {
              goto switch_263_2;
            } else {
              if ((int )iplminor == 3) {
                goto switch_263_3;
              } else {
                goto switch_263_default;
                if (0) {
                  switch_263_0: 
                  {
                  rc = -22;
                  }
                  goto switch_263_break;
                  switch_263_1: 
                  if ((int )cmd == 64) {
                    goto switch_264_64;
                  } else {
                    if ((int )cmd == 65) {
                      goto switch_264_65;
                    } else {
                      goto switch_264_default;
                      if (0) {
                        switch_264_64: 
                        {
                        __pu_val = (unsigned long )ip2_tty_driver->refcount;
                        }
                        if ((int )sizeof(*tmp___1) == 1) {
                          goto switch_265_1;
                        } else {
                          if ((int )sizeof(*tmp___1) == 2) {
                            goto switch_265_2;
                          } else {
                            if ((int )sizeof(*tmp___1) == 4) {
                              goto switch_265_4;
                            } else {
                              if ((int )sizeof(*tmp___1) == 8) {
                                goto switch_265_8;
                              } else {
                                goto switch_265_default;
                                if (0) {
                                  switch_265_1: 
                                  {
                                  tmp___4 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val),
                                                       "c" (tmp___4));
                                  }
                                  goto switch_265_break;
                                  switch_265_2: 
                                  {
                                  tmp___7 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val),
                                                       "c" (tmp___7));
                                  }
                                  goto switch_265_break;
                                  switch_265_4: 
                                  {
                                  tmp___10 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val),
                                                       "c" (tmp___10));
                                  }
                                  goto switch_265_break;
                                  switch_265_8: 
                                  {
                                  tmp___13 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "A" (__pu_val),
                                                       "c" (tmp___13));
                                  }
                                  goto switch_265_break;
                                  switch_265_default: 
                                  {
                                  tmp___14 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "c" (tmp___14));
                                  }
                                  goto switch_265_break;
                                } else {
                                  switch_265_break: 
                                  {

                                  }
                                }
                              }
                            }
                          }
                        }
                        {
                        rc = __ret_pu;
                        __pu_val___0 = irq_counter;
                        }
                        if ((int )sizeof(*tmp___16) == 1) {
                          goto switch_266_1;
                        } else {
                          if ((int )sizeof(*tmp___16) == 2) {
                            goto switch_266_2;
                          } else {
                            if ((int )sizeof(*tmp___16) == 4) {
                              goto switch_266_4;
                            } else {
                              if ((int )sizeof(*tmp___16) == 8) {
                                goto switch_266_8;
                              } else {
                                goto switch_266_default;
                                if (0) {
                                  switch_266_1: 
                                  {
                                  tmp___19 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___0): "0" (__pu_val___0),
                                                       "c" (tmp___19));
                                  }
                                  goto switch_266_break;
                                  switch_266_2: 
                                  {
                                  tmp___22 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___0): "0" (__pu_val___0),
                                                       "c" (tmp___22));
                                  }
                                  goto switch_266_break;
                                  switch_266_4: 
                                  {
                                  tmp___25 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___0): "0" (__pu_val___0),
                                                       "c" (tmp___25));
                                  }
                                  goto switch_266_break;
                                  switch_266_8: 
                                  {
                                  tmp___28 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___0): "A" (__pu_val___0),
                                                       "c" (tmp___28));
                                  }
                                  goto switch_266_break;
                                  switch_266_default: 
                                  {
                                  tmp___29 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___0): "c" (tmp___29));
                                  }
                                  goto switch_266_break;
                                } else {
                                  switch_266_break: 
                                  {

                                  }
                                }
                              }
                            }
                          }
                        }
                        {
                        rc = __ret_pu___0;
                        __pu_val___1 = bh_counter;
                        }
                        if ((int )sizeof(*tmp___31) == 1) {
                          goto switch_267_1;
                        } else {
                          if ((int )sizeof(*tmp___31) == 2) {
                            goto switch_267_2;
                          } else {
                            if ((int )sizeof(*tmp___31) == 4) {
                              goto switch_267_4;
                            } else {
                              if ((int )sizeof(*tmp___31) == 8) {
                                goto switch_267_8;
                              } else {
                                goto switch_267_default;
                                if (0) {
                                  switch_267_1: 
                                  {
                                  tmp___34 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___1): "0" (__pu_val___1),
                                                       "c" (tmp___34));
                                  }
                                  goto switch_267_break;
                                  switch_267_2: 
                                  {
                                  tmp___37 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___1): "0" (__pu_val___1),
                                                       "c" (tmp___37));
                                  }
                                  goto switch_267_break;
                                  switch_267_4: 
                                  {
                                  tmp___40 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___1): "0" (__pu_val___1),
                                                       "c" (tmp___40));
                                  }
                                  goto switch_267_break;
                                  switch_267_8: 
                                  {
                                  tmp___43 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___1): "A" (__pu_val___1),
                                                       "c" (tmp___43));
                                  }
                                  goto switch_267_break;
                                  switch_267_default: 
                                  {
                                  tmp___44 = pIndex;
                                  pIndex ++;
                                  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___1): "c" (tmp___44));
                                  }
                                  goto switch_267_break;
                                } else {
                                  switch_267_break: 
                                  {

                                  }
                                }
                              }
                            }
                          }
                        }
                        {
                        rc = __ret_pu___1;
                        }
                        goto switch_264_break;
                        switch_264_65: 
                        if (pB) {
                          {
                          tmp___45 = copy_to_user(argp, (void const   *)pB, (unsigned long )sizeof(i2eBordStr ));
                          rc = (int )tmp___45;
                          tmp___46 = inb(pB->i2eStatus);
                          __pu_val___2 = (unsigned long )tmp___46;
                          }
                          if ((int )sizeof(*((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB))) == 1) {
                            goto switch_268_1;
                          } else {
                            if ((int )sizeof(*((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB))) == 2) {
                              goto switch_268_2;
                            } else {
                              if ((int )sizeof(*((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB))) == 4) {
                                goto switch_268_4;
                              } else {
                                if ((int )sizeof(*((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB))) == 8) {
                                  goto switch_268_8;
                                } else {
                                  goto switch_268_default;
                                  if (0) {
                                    switch_268_1: 
                                    {
                                    __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                                         "c" ((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB)));
                                    }
                                    goto switch_268_break;
                                    switch_268_2: 
                                    {
                                    __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                                         "c" ((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB)));
                                    }
                                    goto switch_268_break;
                                    switch_268_4: 
                                    {
                                    __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu___2): "0" (__pu_val___2),
                                                         "c" ((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB)));
                                    }
                                    goto switch_268_break;
                                    switch_268_8: 
                                    {
                                    __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu___2): "A" (__pu_val___2),
                                                         "c" ((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB)));
                                    }
                                    goto switch_268_break;
                                    switch_268_default: 
                                    {
                                    __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu___2): "c" ((ULONG *)((arg + (unsigned long )(& pB->i2eStatus)) - (unsigned long )pB)));
                                    }
                                    goto switch_268_break;
                                  } else {
                                    switch_268_break: 
                                    {

                                    }
                                  }
                                }
                              }
                            }
                          }
                          {
                          rc = __ret_pu___2;
                          }
                        } else {
                          {
                          rc = -19;
                          }
                        }
                        goto switch_264_break;
                        switch_264_default: 
                        {

                        }
                        if (cmd < 256U) {
                          {
                          pCh = DevTable[cmd];
                          }
                          if (pCh) {
                            {
                            tmp___47 = copy_to_user(argp, (void const   *)pCh, (unsigned long )sizeof(i2ChanStr ));
                            rc = (int )tmp___47;
                            }
                          } else {
                            {
                            rc = -19;
                            }
                          }
                        } else {
                          {
                          rc = -22;
                          }
                        }
                      } else {
                        switch_264_break: 
                        {

                        }
                      }
                    }
                  }
                  goto switch_263_break;
                  switch_263_2: 
                  {
                  rc = -22;
                  }
                  goto switch_263_break;
                  switch_263_3: 
                  if (cmd == 1U) {
                    {
                    rc = 0;
                    }
                  } else {
                    {
                    rc = -22;
                    }
                  }
                  goto switch_263_break;
                  switch_263_default: 
                  {
                  rc = -19;
                  }
                  goto switch_263_break;
                } else {
                  switch_263_break: 
                  {

                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (rc);
}
}
static int ip2_ipl_open(struct inode *pInode , struct file *pFile ) 
{ unsigned int iplminor ;
  unsigned int tmp ;
  i2eBordStrPtr pB ;
  i2ChanStrPtr pCh ;

  {
  {
  tmp = iminor((struct inode  const  *)pInode);
  iplminor = tmp;
  }
  if ((int )iplminor == 0) {
    goto switch_269_0;
  } else {
    if ((int )iplminor == 4) {
      goto switch_269_0;
    } else {
      if ((int )iplminor == 8) {
        goto switch_269_0;
      } else {
        if ((int )iplminor == 12) {
          goto switch_269_0;
        } else {
          if ((int )iplminor == 1) {
            goto switch_269_1;
          } else {
            if ((int )iplminor == 5) {
              goto switch_269_1;
            } else {
              if ((int )iplminor == 9) {
                goto switch_269_1;
              } else {
                if ((int )iplminor == 13) {
                  goto switch_269_1;
                } else {
                  if ((int )iplminor == 2) {
                    goto switch_269_2;
                  } else {
                    if ((int )iplminor == 6) {
                      goto switch_269_2;
                    } else {
                      if ((int )iplminor == 10) {
                        goto switch_269_2;
                      } else {
                        if ((int )iplminor == 14) {
                          goto switch_269_2;
                        } else {
                          if ((int )iplminor == 3) {
                            goto switch_269_3;
                          } else {
                            if (0) {
                              switch_269_0: 
                              goto switch_269_break;
                              switch_269_1: 
                              goto switch_269_break;
                              switch_269_2: 
                              {
                              pB = i2BoardPtrTable[iplminor / 4U];
                              pCh = (struct _i2ChanStr *)pB->i2eChannelPtr;
                              }
                              goto switch_269_break;
                              switch_269_3: 
                              goto switch_269_break;
                            } else {
                              switch_269_break: 
                              {

                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (0);
}
}
static int proc_ip2mem_show(struct seq_file *m , void *v ) 
{ i2eBordStrPtr pB ;
  i2ChanStrPtr pCh ;
  PTTY tty ;
  int i ;

  {
  {
  seq_printf(m, "\n");
  i = 0;
  }
  {
  while (1) {
    while_221_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_270_break;
    }
    {
    pB = i2BoardPtrTable[i];
    }
    if (pB) {
      {
      seq_printf(m, "board %d:\n", i);
      seq_printf(m, "\tFifo rem: %d mty: %x outM %x\n", pB->i2eFifoRemains, pB->i2eWaitingForEmptyFifo,
                 pB->i2eOutMailWaiting);
      }
    }
    {
    i ++;
    }
  }
  while_221_break: /* CIL Label */ ;
  }
  while_270_break: 
  {
  seq_printf(m, "#: tty flags, port flags,     cflags,     iflags\n");
  i = 0;
  }
  {
  while (1) {
    while_222_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 256)) {
      goto while_271_break;
    }
    {
    pCh = DevTable[i];
    }
    if (pCh) {
      {
      tty = pCh->pTTY;
      }
      if (tty) {
        if (tty->count) {
          {
          seq_printf(m, "%3d: 0x%08x 0x%08x 0%011o 0%011o\n", i, (int )tty->flags,
                     pCh->flags, (tty->termios)->c_cflag, (tty->termios)->c_iflag);
          seq_printf(m, "     0x%04x 0x%04x tx flow 0x%x\n", pCh->outfl.asof, pCh->outfl.room,
                     pCh->channelNeeds);
          seq_printf(m, "     0x%04x 0x%04x rc flow\n", pCh->infl.asof, pCh->infl.room);
          }
        }
      }
    }
    {
    i ++;
    }
  }
  while_222_break: /* CIL Label */ ;
  }
  while_271_break: 
  {

  }
  return (0);
}
}
static int proc_ip2mem_open(struct inode *inode , struct file *file ) 
{ int tmp ;

  {
  {
  tmp = single_open(file, & proc_ip2mem_show, (void *)0);
  }
  return (tmp);
}
}
static struct file_operations  const  ip2mem_proc_fops  = 
     {(struct module *)0, & seq_lseek, & seq_read, (ssize_t (*)(struct file * , char const   * ,
                                                              size_t  , loff_t * ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    (int (*)(struct inode * , struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & proc_ip2mem_open, (int (*)(struct file * ,
                                                                                       fl_owner_t id ))0,
    & single_release, (int (*)(struct file * , struct dentry * , int datasync ))0,
    (int (*)(struct kiocb * , int datasync ))0, (int (*)(int  , struct file * , int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct page * ,
                                                                         int  , size_t  ,
                                                                         loff_t * ,
                                                                         int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file *filp ,
                                                                       unsigned long arg ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct pipe_inode_info * ,
                                                                         struct file * ,
                                                                         loff_t * ,
                                                                         size_t  ,
                                                                         unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0, (int (*)(struct file * ,
                                                                       struct kstat * ))0,
    (int (*)(struct file * , struct iattr * ))0};
static int ip2_read_proc(char *page , char **start , off_t off , int count , int *eof ,
                         void *data ) 
{ int i ;
  int j ;
  int box ;
  int len ;
  int boxes ;
  int ports ;
  int tports ;
  off_t begin ;
  i2eBordStrPtr pB ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  off_t tmp___13 ;

  {
  {
  len = 0;
  boxes = 0;
  ports = 0;
  tports = 0;
  begin = 0L;
  tmp = sprintf(page, "ip2info: 1.0 driver: %s\n", pcVersion);
  len += tmp;
  tmp___0 = sprintf(page + len, "Driver: SMajor=%d CMajor=%d IMajor=%d MaxBoards=%d MaxBoxes=%d MaxPorts=%d\n",
                    71, 72, 73, 4, 4, 16);
  len += tmp___0;
  i = 0;
  }
  {
  while (1) {
    while_223_continue: /* CIL Label */ ;
    {

    }
    if (! (i < 4)) {
      goto while_272_break;
    }
    {
    boxes = 0;
    pB = i2BoardPtrTable[i];
    }
    if (pB) {
      if (((int )pB->i2ePom.e.porID & -61) == 64) {
        goto switch_273_64;
      } else {
        if (((int )pB->i2ePom.e.porID & -61) == 3) {
          goto switch_273_3;
        } else {
          if (((int )pB->i2ePom.e.porID & -61) == 0) {
            goto switch_273_0;
          } else {
            if (((int )pB->i2ePom.e.porID & -61) == 1) {
              goto switch_273_1;
            } else {
              goto switch_273_default;
              if (0) {
                switch_273_64: 
                {
                tmp___1 = sprintf(page + len, "Board %d: EX ports=", i);
                len += tmp___1;
                box = 0;
                }
                {
                while (1) {
                  while_224_continue: /* CIL Label */ ;
                  {

                  }
                  if (! (box < 4)) {
                    goto while_274_break;
                  }
                  {
                  ports = 0;
                  }
                  if ((int )pB->i2eChannelMap[box] != 0) {
                    {
                    boxes ++;
                    }
                  }
                  {
                  j = 0;
                  }
                  {
                  while (1) {
                    while_225_continue: /* CIL Label */ ;
                    {

                    }
                    if (! (j < 16)) {
                      goto while_275_break;
                    }
                    if ((int )pB->i2eChannelMap[box] & (1 << j)) {
                      {
                      ports ++;
                      }
                    }
                    {
                    j ++;
                    }
                  }
                  while_225_break: /* CIL Label */ ;
                  }
                  while_275_break: 
                  {
                  tmp___2 = sprintf(page + len, "%d,", ports);
                  len += tmp___2;
                  tports += ports;
                  box ++;
                  }
                }
                while_224_break: /* CIL Label */ ;
                }
                while_274_break: 
                {
                len --;
                }
                if (pB->i2eDataWidth16) {
                  {
                  tmp___3 = 16;
                  }
                } else {
                  {
                  tmp___3 = 8;
                  }
                }
                {
                tmp___4 = sprintf(page + len, " boxes=%d width=%d", boxes, tmp___3);
                len += tmp___4;
                }
                goto switch_273_break;
                switch_273_3: 
                {
                tmp___5 = sprintf(page + len, "Board %d: ISA-4 ports=4 boxes=1", i);
                len += tmp___5;
                ports = 4;
                tports = ports;
                }
                goto switch_273_break;
                switch_273_0: 
                {
                tmp___6 = sprintf(page + len, "Board %d: ISA-8-std ports=8 boxes=1",
                                  i);
                len += tmp___6;
                ports = 8;
                tports = ports;
                }
                goto switch_273_break;
                switch_273_1: 
                {
                tmp___7 = sprintf(page + len, "Board %d: ISA-8-RJ11 ports=8 boxes=1",
                                  i);
                len += tmp___7;
                ports = 8;
                tports = ports;
                }
                goto switch_273_break;
                switch_273_default: 
                {
                tmp___8 = sprintf(page + len, "Board %d: unknown", i);
                len += tmp___8;
                ports = 0;
                tports = ports;
                }
              } else {
                switch_273_break: 
                {

                }
              }
            }
          }
        }
      }
    } else {
      {
      tmp___9 = sprintf(page + len, "Board %d: vacant", i);
      len += tmp___9;
      ports = 0;
      tports = ports;
      }
    }
    if (tports) {
      {
      tmp___10 = sprintf(page + len, " minors=");
      len += tmp___10;
      box = 0;
      }
      {
      while (1) {
        while_226_continue: /* CIL Label */ ;
        {

        }
        if (! (box < 4)) {
          goto while_276_break;
        }
        {
        j = 0;
        }
        {
        while (1) {
          while_227_continue: /* CIL Label */ ;
          {

          }
          if (! (j < 16)) {
            goto while_277_break;
          }
          if ((int )pB->i2eChannelMap[box] & (1 << j)) {
            {
            tmp___11 = sprintf(page + len, "%d,", j + 16 * (box + i * 4));
            len += tmp___11;
            }
          }
          {
          j ++;
          }
        }
        while_227_break: /* CIL Label */ ;
        }
        while_277_break: 
        {
        box ++;
        }
      }
      while_226_break: /* CIL Label */ ;
      }
      while_276_break: 
      {
      *(page + (len - 1)) = (char )'\n';
      }
    } else {
      {
      tmp___12 = sprintf(page + len, "\n");
      len += tmp___12;
      }
    }
    if ((long )len + begin > off + (long )count) {
      goto while_272_break;
    }
    if ((long )len + begin < off) {
      {
      begin += (long )len;
      len = 0;
      }
    }
    {
    i ++;
    }
  }
  while_223_break: /* CIL Label */ ;
  }
  while_272_break: 
  {

  }
  if (i >= 4) {
    {
    *eof = 1;
    }
  }
  if (off >= (long )len + begin) {
    return (0);
  }
  {
  *start = page + (off - begin);
  }
  if ((long )count < (begin + (long )len) - off) {
    {
    tmp___13 = (long )count;
    }
  } else {
    {
    tmp___13 = (begin + (long )len) - off;
    }
  }
  return ((int )tmp___13);
}
}
