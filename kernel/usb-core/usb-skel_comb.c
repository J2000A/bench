/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
struct __anonstruct____missing_field_name_2 {
   unsigned long miss ;
   unsigned long hit ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
struct __anonstruct____missing_field_name_3 {
   unsigned long correct ;
   unsigned long incorrect ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
union __anonunion____missing_field_name_1 {
   struct __anonstruct____missing_field_name_3 __annonCompField2 ;
   struct __anonstruct____missing_field_name_2 __annonCompField1 ;
   unsigned long miss_hit[2] ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
struct ftrace_branch_data {
   char const   *func ;
   char const   *file ;
   unsigned int line ;
   union __anonunion____missing_field_name_1 __annonCompField3 ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/stddef.h"
enum __anonenum_4 {
    false = 0,
    true = 1
} ;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef short s16;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef int s32;
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/types.h"
typedef unsigned short umode_t;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/types.h"
typedef u64 dma64_addr_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/types.h"
typedef u32 dma_addr_t;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
struct __anonstruct___kernel_fd_set_5 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef struct __anonstruct___kernel_fd_set_5 __kernel_fd_set;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned long __kernel_ino_t;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_nlink_t;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_off_t;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_pid_t;
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_ipc_pid_t;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_uid_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_gid_t;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_size_t;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_ssize_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_ptrdiff_t;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_time_t;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_suseconds_t;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_clock_t;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_timer_t;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_clockid_t;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_daddr_t;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef char *__kernel_caddr_t;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_uid16_t;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_gid16_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_uid32_t;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_gid32_t;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_old_uid_t;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_old_gid_t;
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_old_dev_t;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long long __kernel_loff_t;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
struct __anonstruct___kernel_fsid_t_6 {
   int val[2] ;
};
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef struct __anonstruct___kernel_fsid_t_6 __kernel_fsid_t;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_fd_set fd_set;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_daddr_t daddr_t;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_key_t key_t;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_suseconds_t suseconds_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_timer_t timer_t;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_mqd_t mqd_t;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef _Bool bool;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_uid16_t uid16_t;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_gid16_t gid16_t;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long uintptr_t;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_old_uid_t old_uid_t;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_old_gid_t old_gid_t;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_ptrdiff_t ptrdiff_t;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_clock_t clock_t;
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_caddr_t caddr_t;
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned char u_char;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned short u_short;
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int u_int;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long u_long;
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned char unchar;
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned short ushort;
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int uint;
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long ulong;
#line 102 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u8 u_int8_t;
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s8 int8_t;
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 u_int16_t;
#line 105 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s16 int16_t;
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 u_int32_t;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s32 int32_t;
#line 111 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u8 uint8_t;
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 uint16_t;
#line 113 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 uint32_t;
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 uint64_t;
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 u_int64_t;
#line 118 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s64 int64_t;
#line 138 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long sector_t;
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 __le16;
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 __be16;
#line 170 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __le32;
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __be32;
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 __le64;
#line 173 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 __be64;
#line 175 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 __sum16;
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __wsum;
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int gfp_t;
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int fmode_t;
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef u32 phys_addr_t;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
struct ustat {
   __kernel_daddr_t f_tfree ;
   __kernel_ino_t f_tinode ;
   char f_fname[6] ;
   char f_fpack[6] ;
};
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/alternative.h"
struct alt_instr {
   u8 *instr ;
   u8 *replacement ;
   u8 cpuid ;
   u8 instrlen ;
   u8 replacementlen ;
   u8 pad1 ;
};
#line 59
struct module;
#line 59
struct module;
#line 148
struct paravirt_patch_site;
#line 148
struct paravirt_patch_site;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ratelimit.h"
struct ratelimit_state {
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dynamic_debug.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   char primary_hash ;
   char secondary_hash ;
   unsigned int lineno : 24 ;
   unsigned int flags : 8 ;
} __attribute__((__aligned__(8))) ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bug.h"
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
struct completion;
#line 114
struct completion;
#line 115
struct pt_regs;
#line 115
struct pt_regs;
#line 116
struct user;
#line 116
struct user;
#line 159
struct atomic_notifier_head;
#line 208
struct pid;
#line 208
struct pid;
#line 311
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4,
    SYSTEM_SUSPEND_DISK = 5
} ;
#line 334
enum __anonenum_8 {
    DUMP_PREFIX_NONE = 0,
    DUMP_PREFIX_ADDRESS = 1,
    DUMP_PREFIX_OFFSET = 2
} ;
#line 651
struct sysinfo;
#line 651
struct sysinfo;
#line 657 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
struct sysinfo {
   long uptime ;
   unsigned long loads[3] ;
   unsigned long totalram ;
   unsigned long freeram ;
   unsigned long sharedram ;
   unsigned long bufferram ;
   unsigned long totalswap ;
   unsigned long freeswap ;
   unsigned short procs ;
   unsigned short pad ;
   unsigned long totalhigh ;
   unsigned long freehigh ;
   unsigned int mem_unit ;
   char _f[(20UL - 2UL * sizeof(long )) - sizeof(int )] ;
};
#line 133 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
typedef int (*initcall_t)(void);
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
typedef void (*exitcall_t)(void);
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
struct obs_kernel_param {
   char const   *str ;
   int (*setup_func)(char * ) ;
   int early ;
};
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct timespec;
#line 12
struct timespec;
#line 13
struct compat_timespec;
#line 13
struct compat_timespec;
#line 18
struct pollfd;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct_poll_10 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct_nanosleep_11 {
   clockid_t index ;
   struct timespec *rmtp ;
   u64 expires ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct_futex_12 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct____missing_field_name_13 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_13 __annonCompField4 ;
   struct __anonstruct_futex_12 futex ;
   struct __anonstruct_nanosleep_11 nanosleep ;
   struct __anonstruct_poll_10 poll ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_9 __annonCompField5 ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page.h"
struct page;
#line 18
struct page;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
struct task_struct;
#line 20
struct task_struct;
#line 21
struct exec_domain;
#line 21
struct exec_domain;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct task_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct revectored_struct {
   unsigned long __map[8] ;
};
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
#line 110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
#line 118 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86plus_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
};
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace-abi.h"
struct ptrace_bts_config {
   __u32 size ;
   __u32 flags ;
   __u32 signal ;
   __u32 bts_size ;
};
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 134
struct cpuinfo_x86;
#line 134
struct cpuinfo_x86;
#line 135
struct task_struct;
#line 233
struct user_desc;
#line 233
struct user_desc;
#line 141 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct kernel_vm86_struct {
   struct kernel_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
   struct pt_regs *regs32 ;
};
#line 191
struct task_struct;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_14 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_14 __annonCompField6 ;
};
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _fpx_sw_bytes {
   __u32 magic1 ;
   __u32 extended_size ;
   __u64 xstate_bv ;
   __u32 xstate_size ;
   __u32 padding[7] ;
};
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
union __anonunion____missing_field_name_15 {
   __u32 reserved3[12] ;
   struct _fpx_sw_bytes sw_reserved ;
};
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _fpstate {
   __u16 cwd ;
   __u16 swd ;
   __u16 twd ;
   __u16 fop ;
   __u64 rip ;
   __u64 rdp ;
   __u32 mxcsr ;
   __u32 mxcsr_mask ;
   __u32 st_space[32] ;
   __u32 xmm_space[64] ;
   __u32 reserved2[12] ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct sigcontext {
   unsigned long r8 ;
   unsigned long r9 ;
   unsigned long r10 ;
   unsigned long r11 ;
   unsigned long r12 ;
   unsigned long r13 ;
   unsigned long r14 ;
   unsigned long r15 ;
   unsigned long di ;
   unsigned long si ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long dx ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long sp ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   unsigned long err ;
   unsigned long trapno ;
   unsigned long oldmask ;
   unsigned long cr2 ;
   void *fpstate ;
   unsigned long reserved1[8] ;
};
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _xsave_hdr {
   __u64 xstate_bv ;
   __u64 reserved1[2] ;
   __u64 reserved2[5] ;
};
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _ymmh_state {
   __u32 ymmh_space[64] ;
};
#line 283 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/current.h"
struct task_struct;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
struct __xchg_dummy {
   unsigned long a[100] ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
struct task_struct;
#line 23
struct tss_struct;
#line 23
struct tss_struct;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pteval_t;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pmdval_t;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pudval_t;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pgdval_t;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pgprotval_t;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
union __anonunion_pte_t_16 {
   pteval_t pte ;
   pteval_t pte_low ;
};
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef union __anonunion_pte_t_16 pte_t;
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_17 {
   pgdval_t pgd ;
};
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_17 pgd_t;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
struct __anonstruct_pud_t_18 {
   pgd_t pgd ;
};
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
typedef struct __anonstruct_pud_t_18 pud_t;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
struct mm_struct;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
struct __anonstruct_pmd_t_19 {
   pud_t pud ;
};
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
typedef struct __anonstruct_pmd_t_19 pmd_t;
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 285
struct file;
#line 285
struct file;
#line 302
struct seq_file;
#line 302
struct seq_file;
#line 305
enum __anonenum_20 {
    PG_LEVEL_NONE = 0,
    PG_LEVEL_4K = 1,
    PG_LEVEL_2M = 2,
    PG_LEVEL_1G = 3,
    PG_LEVEL_NUM = 4
} ;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_22 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_23 {
   unsigned int a ;
   unsigned int b ;
};
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
union __anonunion____missing_field_name_21 {
   struct __anonstruct____missing_field_name_23 __annonCompField9 ;
   struct __anonstruct____missing_field_name_22 __annonCompField8 ;
};
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   union __anonunion____missing_field_name_21 __annonCompField10 ;
} __attribute__((__packed__)) ;
#line 37
enum __anonenum_24 {
    GATE_INTERRUPT = 14,
    GATE_TRAP = 15,
    GATE_CALL = 12,
    GATE_TASK = 5
} ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned int ist : 3 ;
   unsigned int zero0 : 5 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
#line 58
enum __anonenum_25 {
    DESC_TSS = 9,
    DESC_LDT = 2,
    DESCTYPE_S = 16
} ;
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct ldttss_desc64 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit1 : 4 ;
   unsigned int zero0 : 3 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
   u32 base3 ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct desc_struct gate_desc;
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct desc_struct ldt_desc;
#line 83 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct desc_struct tss_desc;
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
} __attribute__((__packed__)) ;
#line 263 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
struct cpuinfo_x86;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
struct exec_domain;
#line 11
struct pt_regs;
#line 24
enum __anonenum_26 {
    ADDR_NO_RANDOMIZE = 262144,
    FDPIC_FUNCPTRS = 524288,
    MMAP_PAGE_ZERO = 1048576,
    ADDR_COMPAT_LAYOUT = 2097152,
    READ_IMPLIES_EXEC = 4194304,
    ADDR_LIMIT_32BIT = 8388608,
    SHORT_INODE = 16777216,
    WHOLE_SECONDS = 33554432,
    STICKY_TIMEOUTS = 67108864,
    ADDR_LIMIT_3GB = 134217728
} ;
#line 54
enum __anonenum_27 {
    PER_LINUX = 0,
    PER_LINUX_32BIT = 8388608,
    PER_LINUX_FDPIC = 524288,
    PER_SVR4 = 68157441,
    PER_SVR3 = 83886082,
    PER_SCOSVR3 = 117440515,
    PER_OSR5 = 100663299,
    PER_WYSEV386 = 83886084,
    PER_ISCR4 = 67108869,
    PER_BSD = 6,
    PER_SUNOS = 67108870,
    PER_XENIX = 83886087,
    PER_LINUX32 = 8,
    PER_LINUX32_3GB = 134217736,
    PER_IRIX32 = 67108873,
    PER_IRIXN32 = 67108874,
    PER_IRIX64 = 67108875,
    PER_RISCOS = 12,
    PER_SOLARIS = 67108877,
    PER_UW7 = 68157454,
    PER_OSF4 = 15,
    PER_HPUX = 16,
    PER_MASK = 255
} ;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
typedef void (*handler_t)(int  , struct pt_regs * );
#line 91
struct map_segment;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 1032 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
typedef struct cpumask cpumask_var_t[1];
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   char wp_works_ok ;
   char hlt_works_ok ;
   char hard_math ;
   char rfu ;
   char fdiv_bug ;
   char f00f_bug ;
   char coma_bug ;
   char pad0 ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[9] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   cpumask_var_t llc_shared_map ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u16 cpu_index ;
   unsigned int x86_hyper_vendor ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 149
struct seq_operations;
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   unsigned short back_link ;
   unsigned short __blh ;
   unsigned long sp0 ;
   unsigned short ss0 ;
   unsigned short __ss0h ;
   unsigned long sp1 ;
   unsigned short ss1 ;
   unsigned short __ss1h ;
   unsigned long sp2 ;
   unsigned short ss2 ;
   unsigned short __ss2h ;
   unsigned long __cr3 ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long bx ;
   unsigned long sp ;
   unsigned long bp ;
   unsigned long si ;
   unsigned long di ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short ldt ;
   unsigned short __ldth ;
   unsigned short trace ;
   unsigned short io_bitmap_base ;
} __attribute__((__packed__)) ;
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[8192UL / sizeof(long ) + 1UL] ;
   unsigned long stack[64] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct orig_ist {
   unsigned long ist[7] ;
};
#line 284 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_28 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_31 {
   u64 rip ;
   u64 rdp ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_29 {
   struct __anonstruct____missing_field_name_31 __annonCompField13 ;
   struct __anonstruct____missing_field_name_30 __annonCompField12 ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_29 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_28 __annonCompField11 ;
} __attribute__((__aligned__(16))) ;
#line 335 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
#line 360 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
#line 366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
} __attribute__((__packed__, __aligned__(64))) ;
#line 373 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 421
struct kmem_cache;
#line 426 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long sysenter_cs ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_sp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
};
#line 628 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_32 {
   unsigned long seg ;
};
#line 628 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_32 mm_segment_t;
#line 141 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
typedef atomic_t atomic_long_t;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
   int uaccess_err ;
};
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 540
struct hlist_node;
#line 540 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 544 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
struct raw_spinlock {
   unsigned int slock ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_raw_rwlock_t_33 {
   unsigned int lock ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
typedef struct __anonstruct_raw_rwlock_t_33 raw_rwlock_t;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
struct task_struct;
#line 13
struct lockdep_map;
#line 13
struct lockdep_map;
#line 337 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
struct lock_class_key {

};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_34 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_34 spinlock_t;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_35 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_35 rwlock_t;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct __wait_queue;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
typedef int (*wait_queue_func_t)(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key );
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct wait_bit_key {
   void *flags ;
   int bit_nr ;
};
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct wait_bit_queue {
   struct wait_bit_key key ;
   wait_queue_t wait ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 54 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 56
struct task_struct;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_36 {
   unsigned int sequence ;
   spinlock_t lock ;
};
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_36 seqlock_t;
#line 121 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_37 {
   unsigned long bits[((1UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_37 nodemask_t;
#line 363
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
} ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pageblock-flags.h"
enum pageblock_bits {
    PB_migrate = 0,
    PB_migrate_end = 2,
    NR_PAGEBLOCK_BITS = 3
} ;
#line 60
struct page;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[5] ;
   unsigned long nr_free ;
};
#line 64
struct pglist_data;
#line 64
struct pglist_data;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zone_padding {
   char x[0] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 81
enum zone_stat_item {
    NR_FREE_PAGES = 0,
    NR_LRU_BASE = 1,
    NR_INACTIVE_ANON = 1,
    NR_ACTIVE_ANON = 2,
    NR_INACTIVE_FILE = 3,
    NR_ACTIVE_FILE = 4,
    NR_UNEVICTABLE = 5,
    NR_MLOCK = 6,
    NR_ANON_PAGES = 7,
    NR_FILE_MAPPED = 8,
    NR_FILE_PAGES = 9,
    NR_FILE_DIRTY = 10,
    NR_WRITEBACK = 11,
    NR_SLAB_RECLAIMABLE = 12,
    NR_SLAB_UNRECLAIMABLE = 13,
    NR_PAGETABLE = 14,
    NR_UNSTABLE_NFS = 15,
    NR_BOUNCE = 16,
    NR_VMSCAN_WRITE = 17,
    NR_WRITEBACK_TEMP = 18,
    NR_VM_ZONE_STAT_ITEMS = 19
} ;
#line 133
enum lru_list {
    LRU_INACTIVE_ANON = 0,
    LRU_ACTIVE_ANON = 1,
    LRU_INACTIVE_FILE = 2,
    LRU_ACTIVE_FILE = 3,
    LRU_UNEVICTABLE = 4,
    NR_LRU_LISTS = 5
} ;
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head list ;
};
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 stat_threshold ;
   s8 vm_stat_diff[19] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 195
enum zone_type {
    ZONE_DMA = 0,
    ZONE_NORMAL = 1,
    ZONE_HIGHMEM = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2] ;
   unsigned long recent_scanned[2] ;
};
#line 279 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct __anonstruct_lru_38 {
   struct list_head list ;
   unsigned long nr_scan ;
};
#line 279 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zone {
   unsigned long pages_min ;
   unsigned long pages_low ;
   unsigned long pages_high ;
   unsigned long lowmem_reserve[4] ;
   struct per_cpu_pageset pageset[8] ;
   spinlock_t lock ;
   struct free_area free_area[11] ;
   unsigned long *pageblock_flags ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   struct __anonstruct_lru_38 lru[5] ;
   struct zone_reclaim_stat reclaim_stat ;
   unsigned long pages_scanned ;
   unsigned long flags ;
   atomic_long_t vm_stat[19] ;
   int prev_priority ;
   unsigned int inactive_ratio ;
   struct zone_padding _pad2_ ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct pglist_data *zone_pgdat ;
   unsigned long zone_start_pfn ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 418
enum __anonenum_zone_flags_t_39 {
    ZONE_ALL_UNRECLAIMABLE = 0,
    ZONE_RECLAIM_LOCKED = 1,
    ZONE_OOM_LOCKED = 2
} ;
#line 418 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
typedef enum __anonenum_zone_flags_t_39 zone_flags_t;
#line 542
struct zonelist_cache;
#line 542
struct zonelist_cache;
#line 549 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 571 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[5] ;
};
#line 580 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct node_active_region {
   unsigned long start_pfn ;
   unsigned long end_pfn ;
   int nid ;
};
#line 603
struct bootmem_data;
#line 603
struct bootmem_data;
#line 604 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4] ;
   struct zonelist node_zonelists[1] ;
   int nr_zones ;
   struct page *node_mem_map ;
   struct bootmem_data *bdata ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
};
#line 604 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
};
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
};
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rwsem.h"
struct rw_semaphore;
#line 17
struct rw_semaphore;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
struct rwsem_waiter;
#line 45
struct rwsem_waiter;
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/srcu.h"
struct srcu_struct_array {
   int c[2] ;
};
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/srcu.h"
struct srcu_struct {
   int completed ;
   struct srcu_struct_array *per_cpu_ref ;
   struct mutex mutex ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct atomic_notifier_head {
   spinlock_t lock ;
   struct notifier_block *head ;
};
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct raw_notifier_head {
   struct notifier_block *head ;
};
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct srcu_notifier_head {
   struct mutex mutex ;
   struct srcu_struct srcu ;
   struct notifier_block *head ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
struct page;
#line 9
struct zone;
#line 10
struct pglist_data;
#line 11
struct mem_section;
#line 11
struct mem_section;
#line 652 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
enum memmap_context {
    MEMMAP_EARLY = 0,
    MEMMAP_HOTPLUG = 1
} ;
#line 748
struct ctl_table;
#line 748
struct ctl_table;
#line 749
struct file;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
struct call_single_data {
   struct list_head list ;
   void (*func)(void *info ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpf_intel {
   char signature[4] ;
   unsigned int physptr ;
   unsigned char length ;
   unsigned char specification ;
   unsigned char checksum ;
   unsigned char feature1 ;
   unsigned char feature2 ;
   unsigned char feature3 ;
   unsigned char feature4 ;
   unsigned char feature5 ;
};
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_table {
   char signature[4] ;
   unsigned short length ;
   char spec ;
   char checksum ;
   char oem[8] ;
   char productid[12] ;
   unsigned int oemptr ;
   unsigned short oemsize ;
   unsigned short oemcount ;
   unsigned int lapic ;
   unsigned int reserved ;
};
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_cpu {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char cpuflag ;
   unsigned int cpufeature ;
   unsigned int featureflag ;
   unsigned int reserved[2] ;
};
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_bus {
   unsigned char type ;
   unsigned char busid ;
   unsigned char bustype[6] ;
};
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_ioapic {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char flags ;
   unsigned int apicaddr ;
};
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_intsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbus ;
   unsigned char srcbusirq ;
   unsigned char dstapic ;
   unsigned char dstirq ;
};
#line 130
enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3
} ;
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_lintsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbusid ;
   unsigned char srcbusirq ;
   unsigned char destapic ;
   unsigned char destapiclint ;
};
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_oemtable {
   char signature[4] ;
   unsigned short length ;
   char rev ;
   char checksum ;
   char mpc[8] ;
};
#line 175
enum mp_bustype {
    MP_BUS_ISA = 1,
    MP_BUS_EISA = 2,
    MP_BUS_PCI = 3,
    MP_BUS_MCA = 4
} ;
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
struct physid_mask {
   unsigned long mask[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
typedef struct physid_mask physid_mask_t;
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct device;
#line 37
struct device;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 170 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
#line 308
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
#line 318 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
#line 416
enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3
} ;
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_20_40 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_dcr_41 {
   unsigned int divisor : 4 ;
   unsigned int __reserved_1 : 28 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_19_42 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_18_43 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_17_44 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_16_45 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_ccr_46 {
   unsigned int curr_count ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_icr_47 {
   unsigned int initial_count ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_error_48 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_lint1_49 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_lint0_50 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_pc_51 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_thermal_52 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_timer_53 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int timer_mode : 1 ;
   unsigned int __reserved_3 : 14 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
union __anonunion_dest_55 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_dest : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved_3 : 24 ;
   unsigned int logical_dest : 8 ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_icr2_54 {
   union __anonunion_dest_55 dest ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_icr1_56 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int destination_mode : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int level : 1 ;
   unsigned int trigger : 1 ;
   unsigned int __reserved_2 : 2 ;
   unsigned int shorthand : 2 ;
   unsigned int __reserved_3 : 12 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_14_57 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_13_58 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_12_59 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_11_60 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_10_61 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_09_62 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_08_63 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_all_errors_65 {
   unsigned int errors ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_error_bits_66 {
   unsigned int send_cs_error : 1 ;
   unsigned int receive_cs_error : 1 ;
   unsigned int send_accept_error : 1 ;
   unsigned int receive_accept_error : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int send_illegal_vector : 1 ;
   unsigned int receive_illegal_vector : 1 ;
   unsigned int illegal_register_address : 1 ;
   unsigned int __reserved_2 : 24 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
union __anonunion_esr_64 {
   struct __anonstruct_error_bits_66 error_bits ;
   struct __anonstruct_all_errors_65 all_errors ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_irr_67 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_tmr_68 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_isr_69 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_svr_70 {
   unsigned int spurious_vector : 8 ;
   unsigned int apic_enabled : 1 ;
   unsigned int focus_cpu : 1 ;
   unsigned int __reserved_2 : 22 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_dfr_71 {
   unsigned int __reserved_1 : 28 ;
   unsigned int model : 4 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_ldr_72 {
   unsigned int __reserved_1 : 24 ;
   unsigned int logical_dest : 8 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_07_73 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_eoi_74 {
   unsigned int eoi ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_ppr_75 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_apr_76 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_tpr_77 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_06_78 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_05_79 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_04_80 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_03_81 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_version_82 {
   unsigned int version : 8 ;
   unsigned int __reserved_1 : 8 ;
   unsigned int max_lvt : 8 ;
   unsigned int __reserved_2 : 8 ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_id_83 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_apic_id : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_02_84 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_01_85 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct local_apic {
   struct __anonstruct___reserved_01_85 __reserved_01 ;
   struct __anonstruct___reserved_02_84 __reserved_02 ;
   struct __anonstruct_id_83 id ;
   struct __anonstruct_version_82  const  version ;
   struct __anonstruct___reserved_03_81 __reserved_03 ;
   struct __anonstruct___reserved_04_80 __reserved_04 ;
   struct __anonstruct___reserved_05_79 __reserved_05 ;
   struct __anonstruct___reserved_06_78 __reserved_06 ;
   struct __anonstruct_tpr_77 tpr ;
   struct __anonstruct_apr_76  const  apr ;
   struct __anonstruct_ppr_75  const  ppr ;
   struct __anonstruct_eoi_74 eoi ;
   struct __anonstruct___reserved_07_73 __reserved_07 ;
   struct __anonstruct_ldr_72 ldr ;
   struct __anonstruct_dfr_71 dfr ;
   struct __anonstruct_svr_70 svr ;
   struct __anonstruct_isr_69 isr[8] ;
   struct __anonstruct_tmr_68 tmr[8] ;
   struct __anonstruct_irr_67 irr[8] ;
   union __anonunion_esr_64 esr ;
   struct __anonstruct___reserved_08_63 __reserved_08 ;
   struct __anonstruct___reserved_09_62 __reserved_09 ;
   struct __anonstruct___reserved_10_61 __reserved_10 ;
   struct __anonstruct___reserved_11_60 __reserved_11 ;
   struct __anonstruct___reserved_12_59 __reserved_12 ;
   struct __anonstruct___reserved_13_58 __reserved_13 ;
   struct __anonstruct___reserved_14_57 __reserved_14 ;
   struct __anonstruct_icr1_56 icr1 ;
   struct __anonstruct_icr2_54 icr2 ;
   struct __anonstruct_lvt_timer_53 lvt_timer ;
   struct __anonstruct_lvt_thermal_52 lvt_thermal ;
   struct __anonstruct_lvt_pc_51 lvt_pc ;
   struct __anonstruct_lvt_lint0_50 lvt_lint0 ;
   struct __anonstruct_lvt_lint1_49 lvt_lint1 ;
   struct __anonstruct_lvt_error_48 lvt_error ;
   struct __anonstruct_timer_icr_47 timer_icr ;
   struct __anonstruct_timer_ccr_46  const  timer_ccr ;
   struct __anonstruct___reserved_16_45 __reserved_16 ;
   struct __anonstruct___reserved_17_44 __reserved_17 ;
   struct __anonstruct___reserved_18_43 __reserved_18 ;
   struct __anonstruct___reserved_19_42 __reserved_19 ;
   struct __anonstruct_timer_dcr_41 timer_dcr ;
   struct __anonstruct___reserved_20_40 __reserved_20 ;
} __attribute__((__packed__)) ;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_86 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_86 mm_context_t;
#line 157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
struct bootnode;
#line 157
struct bootnode;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/kmap_types.h"
enum km_type {
    KM_BOUNCE_READ = 0,
    KM_SKB_SUNRPC_DATA = 1,
    KM_SKB_DATA_SOFTIRQ = 2,
    KM_USER0 = 3,
    KM_USER1 = 4,
    KM_BIO_SRC_IRQ = 5,
    KM_BIO_DST_IRQ = 6,
    KM_PTE0 = 7,
    KM_PTE1 = 8,
    KM_IRQ0 = 9,
    KM_IRQ1 = 10,
    KM_SOFTIRQ0 = 11,
    KM_SOFTIRQ1 = 12,
    KM_TYPE_NR = 13
} ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
enum fixed_addresses {
    FIX_HOLE = 0,
    FIX_VDSO = 1,
    FIX_DBGP_BASE = 2,
    FIX_EARLYCON_MEM_BASE = 3,
    FIX_APIC_BASE = 4,
    FIX_IO_APIC_BASE_0 = 5,
    FIX_IO_APIC_BASE_END = 68,
    FIX_KMAP_BEGIN = 69,
    FIX_KMAP_END = 172,
    FIX_PCIE_MCFG = 173,
    FIX_TEXT_POKE1 = 174,
    FIX_TEXT_POKE0 = 175,
    __end_of_permanent_fixed_addresses = 176,
    FIX_BTMAP_END = 256,
    FIX_BTMAP_BEGIN = 511,
    FIX_OHCI1394_BASE = 512,
    FIX_WP_TEST = 513,
    __end_of_fixed_addresses = 514
} ;
#line 274 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
struct apic {
   char *name ;
   int (*probe)(void) ;
   int (*acpi_madt_oem_check)(char *oem_id , char *oem_table_id ) ;
   int (*apic_id_registered)(void) ;
   u32 irq_delivery_mode ;
   u32 irq_dest_mode ;
   struct cpumask  const  *(*target_cpus)(void) ;
   int disable_esr ;
   int dest_logical ;
   unsigned long (*check_apicid_used)(physid_mask_t bitmap , int apicid ) ;
   unsigned long (*check_apicid_present)(int apicid ) ;
   void (*vector_allocation_domain)(int cpu , struct cpumask *retmask ) ;
   void (*init_apic_ldr)(void) ;
   physid_mask_t (*ioapic_phys_id_map)(physid_mask_t map ) ;
   void (*setup_apic_routing)(void) ;
   int (*multi_timer_check)(int apic , int irq ) ;
   int (*apicid_to_node)(int logical_apicid ) ;
   int (*cpu_to_logical_apicid)(int cpu ) ;
   int (*cpu_present_to_apicid)(int mps_cpu ) ;
   physid_mask_t (*apicid_to_cpu_present)(int phys_apicid ) ;
   void (*setup_portio_remap)(void) ;
   int (*check_phys_apicid_present)(int boot_cpu_physical_apicid ) ;
   void (*enable_apic_mode)(void) ;
   int (*phys_pkg_id)(int cpuid_apic , int index_msb ) ;
   int (*mps_oem_check)(struct mpc_table *mpc , char *oem , char *productid ) ;
   unsigned int (*get_apic_id)(unsigned long x ) ;
   unsigned long (*set_apic_id)(unsigned int id ) ;
   unsigned long apic_id_mask ;
   unsigned int (*cpu_mask_to_apicid)(struct cpumask  const  *cpumask ) ;
   unsigned int (*cpu_mask_to_apicid_and)(struct cpumask  const  *cpumask , struct cpumask  const  *andmask ) ;
   void (*send_IPI_mask)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_mask_allbutself)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_allbutself)(int vector ) ;
   void (*send_IPI_all)(int vector ) ;
   void (*send_IPI_self)(int vector ) ;
   int (*wakeup_secondary_cpu)(int apicid , unsigned long start_eip ) ;
   int trampoline_phys_low ;
   int trampoline_phys_high ;
   void (*wait_for_init_deassert)(atomic_t *deassert ) ;
   void (*smp_callin_clear_local_apic)(void) ;
   void (*inquire_remote_apic)(int apicid ) ;
   u32 (*read)(u32 reg ) ;
   void (*write)(u32 reg , u32 v ) ;
   u64 (*icr_read)(void) ;
   void (*icr_write)(u32 low , u32 high ) ;
   void (*wait_icr_idle)(void) ;
   u32 (*safe_wait_icr_idle)(void) ;
};
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_87 {
   u32 __reserved_2 : 14 ;
   u32 LTS : 1 ;
   u32 delivery_type : 1 ;
   u32 __reserved_1 : 8 ;
   u32 ID : 8 ;
} __attribute__((__packed__)) ;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_00 {
   u32 raw ;
   struct __anonstruct_bits_87 bits ;
};
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_88 {
   u32 version : 8 ;
   u32 __reserved_2 : 7 ;
   u32 PRQ : 1 ;
   u32 entries : 8 ;
   u32 __reserved_1 : 8 ;
} __attribute__((__packed__)) ;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_01 {
   u32 raw ;
   struct __anonstruct_bits_88 bits ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_89 {
   u32 __reserved_2 : 24 ;
   u32 arbitration : 4 ;
   u32 __reserved_1 : 4 ;
} __attribute__((__packed__)) ;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_02 {
   u32 raw ;
   struct __anonstruct_bits_89 bits ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_90 {
   u32 boot_DT : 1 ;
   u32 __reserved_1 : 31 ;
} __attribute__((__packed__)) ;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_03 {
   u32 raw ;
   struct __anonstruct_bits_90 bits ;
};
#line 66
enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7
} ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct IO_APIC_route_entry {
   __u32 vector : 8 ;
   __u32 delivery_mode : 3 ;
   __u32 dest_mode : 1 ;
   __u32 delivery_status : 1 ;
   __u32 polarity : 1 ;
   __u32 irr : 1 ;
   __u32 trigger : 1 ;
   __u32 mask : 1 ;
   __u32 __reserved_2 : 15 ;
   __u32 __reserved_3 : 24 ;
   __u32 dest : 8 ;
} __attribute__((__packed__)) ;
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct IR_IO_APIC_route_entry {
   __u64 vector : 8 ;
   __u64 zero : 3 ;
   __u64 index2 : 1 ;
   __u64 delivery_status : 1 ;
   __u64 polarity : 1 ;
   __u64 irr : 1 ;
   __u64 trigger : 1 ;
   __u64 mask : 1 ;
   __u64 reserved : 31 ;
   __u64 format : 1 ;
   __u64 index : 15 ;
} __attribute__((__packed__)) ;
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
struct __anonstruct_stack_start_91 {
   void *sp ;
   unsigned short ss ;
};
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
struct smp_ops {
   void (*smp_prepare_boot_cpu)(void) ;
   void (*smp_prepare_cpus)(unsigned int max_cpus ) ;
   void (*smp_cpus_done)(unsigned int max_cpus ) ;
   void (*smp_send_stop)(void) ;
   void (*smp_send_reschedule)(int cpu ) ;
   int (*cpu_up)(unsigned int cpu ) ;
   int (*cpu_disable)(void) ;
   void (*cpu_die)(unsigned int cpu ) ;
   void (*play_dead)(void) ;
   void (*send_call_func_ipi)(struct cpumask  const  *mask ) ;
   void (*send_call_func_single_ipi)(int cpu ) ;
};
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 202
struct pci_bus;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
struct vm_area_struct;
#line 9
struct vm_area_struct;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/div64.h"
union __anonunion_d_92 {
   u64 v64 ;
   u32 v32[2] ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 121
struct itimerval;
#line 121
struct itimerval;
#line 136
struct tms;
#line 136
struct tms;
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 216 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timex.h"
struct timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
enum debug_obj_state {
    ODEBUG_STATE_NONE = 0,
    ODEBUG_STATE_INIT = 1,
    ODEBUG_STATE_INACTIVE = 2,
    ODEBUG_STATE_ACTIVE = 3,
    ODEBUG_STATE_DESTROYED = 4,
    ODEBUG_STATE_NOTAVAILABLE = 5,
    ODEBUG_STATE_MAX = 6
} ;
#line 17
struct debug_obj_descr;
#line 17
struct debug_obj_descr;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
struct debug_obj {
   struct hlist_node node ;
   enum debug_obj_state state ;
   void *object ;
   struct debug_obj_descr *descr ;
};
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
struct debug_obj_descr {
   char const   *name ;
   int (*fixup_init)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_activate)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_destroy)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_free)(void *addr , enum debug_obj_state state ) ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
struct tvec_base;
#line 10
struct tvec_base;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
   void *start_site ;
   char start_comm[16] ;
   int start_pid ;
};
#line 238
struct hrtimer;
#line 238
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct workqueue_struct;
#line 14
struct workqueue_struct;
#line 16
struct work_struct;
#line 16
struct work_struct;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
typedef void (*work_func_t)(struct work_struct *work );
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct kobject;
#line 20
struct kobject;
#line 21
struct module;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63
struct vm_area_struct;
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 82
struct sysfs_dirent;
#line 82
struct sysfs_dirent;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
#line 59
struct kobj_type;
#line 59
struct kset;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
#line 113 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobj_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct kobject *kobj , struct kobj_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct kobject *kobj , struct kobj_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
#line 78 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_dynticks {
   int dynticks_nesting ;
   int dynticks ;
   int dynticks_nmi ;
};
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_node {
   spinlock_t lock ;
   unsigned long qsmask ;
   unsigned long qsmaskinit ;
   unsigned long grpmask ;
   int grplo ;
   int grphi ;
   u8 grpnum ;
   u8 level ;
   struct rcu_node *parent ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 111 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_data {
   long completed ;
   long gpnum ;
   long passed_quiesc_completed ;
   bool passed_quiesc ;
   bool qs_pending ;
   bool beenonline ;
   struct rcu_node *mynode ;
   unsigned long grpmask ;
   struct rcu_head *nxtlist ;
   struct rcu_head **nxttail[4] ;
   long qlen ;
   long blimit ;
   struct rcu_dynticks *dynticks ;
   int dynticks_snap ;
   int dynticks_nmi_snap ;
   unsigned long dynticks_fqs ;
   unsigned long offline_fqs ;
   unsigned long resched_ipi ;
   long n_rcu_pending ;
   int cpu ;
};
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_state {
   struct rcu_node node[1] ;
   struct rcu_node *level[1] ;
   u32 levelcnt[4] ;
   u8 levelspread[1] ;
   struct rcu_data *rda[8] ;
   u8 signaled  __attribute__((__aligned__((1) <<  (5) ))) ;
   long gpnum ;
   long completed ;
   spinlock_t onofflock ;
   spinlock_t fqslock ;
   unsigned long jiffies_force_qs ;
   unsigned long n_force_qs ;
   unsigned long n_force_qs_lh ;
   unsigned long n_force_qs_ngp ;
   long dynticks_completed ;
};
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
struct rcu_synchronize {
   struct rcu_head head ;
   struct completion completion ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
struct module;
#line 21
struct tracepoint;
#line 21
struct tracepoint;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
struct tracepoint_iter {
   struct module *module ;
   struct tracepoint *tracepoint ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
enum stat_item {
    ALLOC_FASTPATH = 0,
    ALLOC_SLOWPATH = 1,
    FREE_FASTPATH = 2,
    FREE_SLOWPATH = 3,
    FREE_FROZEN = 4,
    FREE_ADD_PARTIAL = 5,
    FREE_REMOVE_PARTIAL = 6,
    ALLOC_FROM_PARTIAL = 7,
    ALLOC_SLAB = 8,
    ALLOC_REFILL = 9,
    FREE_SLAB = 10,
    CPUSLAB_FLUSH = 11,
    DEACTIVATE_FULL = 12,
    DEACTIVATE_EMPTY = 13,
    DEACTIVATE_TO_HEAD = 14,
    DEACTIVATE_TO_TAIL = 15,
    DEACTIVATE_REMOTE_FREES = 16,
    ORDER_FALLBACK = 17,
    NR_SLUB_STAT_ITEMS = 18
} ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   unsigned long min_partial ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct kmem_cache_cpu *cpu_slab[8] ;
};
#line 68 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/stat.h"
struct stat {
   unsigned long st_dev ;
   unsigned long st_ino ;
   unsigned long st_nlink ;
   unsigned int st_mode ;
   unsigned int st_uid ;
   unsigned int st_gid ;
   unsigned int __pad0 ;
   unsigned long st_rdev ;
   long st_size ;
   long st_blksize ;
   long st_blocks ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned long st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   long __unused[3] ;
};
#line 93 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/stat.h"
struct __old_kernel_stat {
   unsigned short st_dev ;
   unsigned short st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned short st_rdev ;
   unsigned int st_size ;
   unsigned int st_atime ;
   unsigned int st_mtime ;
   unsigned int st_ctime ;
};
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
struct key;
#line 45
struct key;
#line 46
struct file;
#line 47
struct subprocess_info;
#line 47
struct subprocess_info;
#line 61
enum umh_wait {
    UMH_NO_WAIT = -1,
    UMH_WAIT_EXEC = 0,
    UMH_WAIT_PROC = 1
} ;
#line 103
struct file;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user_i387_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
};
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user_fxsr_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long reserved ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
};
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user_regs_struct {
   unsigned long bx ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long bp ;
   unsigned long ax ;
   unsigned long ds ;
   unsigned long es ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   struct user_i387_struct i387 ;
   unsigned long u_tsize ;
   unsigned long u_dsize ;
   unsigned long u_ssize ;
   unsigned long start_code ;
   unsigned long start_stack ;
   long signal ;
   int reserved ;
   unsigned long u_ar0 ;
   struct user_i387_struct *u_fpstate ;
   unsigned long magic ;
   char u_comm[32] ;
   int u_debugreg[8] ;
};
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
typedef unsigned long elf_greg_t;
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
typedef elf_greg_t elf_gregset_t[sizeof(struct user_regs_struct ) / sizeof(elf_greg_t )];
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
typedef struct user_i387_struct elf_fpregset_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ldt.h"
struct user_desc {
   unsigned int entry_number ;
   unsigned int base_addr ;
   unsigned int limit ;
   unsigned int seg_32bit : 1 ;
   unsigned int contents : 2 ;
   unsigned int read_exec_only : 1 ;
   unsigned int limit_in_pages : 1 ;
   unsigned int seg_not_present : 1 ;
   unsigned int useable : 1 ;
   unsigned int lm : 1 ;
};
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
struct gdt_page {
   struct desc_struct gdt[32] ;
} __attribute__((__aligned__((1) <<  (12) ))) ;
#line 290 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
struct task_struct;
#line 335
struct linux_binprm;
#line 335
struct linux_binprm;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct file;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf32_Addr;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u16 Elf32_Half;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf32_Off;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s32 Elf32_Sword;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf32_Word;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s16 Elf64_SHalf;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u64 Elf64_Off;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s32 Elf64_Sword;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s64 Elf64_Sxword;
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
union __anonunion_d_un_93 {
   Elf32_Sword d_val ;
   Elf32_Addr d_ptr ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct dynamic {
   Elf32_Sword d_tag ;
   union __anonunion_d_un_93 d_un ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct dynamic Elf32_Dyn;
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
union __anonunion_d_un_95 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct __anonstruct_Elf64_Dyn_94 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_95 d_un ;
};
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct __anonstruct_Elf64_Dyn_94 Elf64_Dyn;
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_rel {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_rel Elf32_Rel;
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_rel {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
};
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_rel Elf64_Rel;
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_rela {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
   Elf32_Sword r_addend ;
};
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_rela Elf32_Rela;
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_rela {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_rela Elf64_Rela;
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_sym Elf32_Sym;
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_hdr Elf32_Ehdr;
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_hdr {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_hdr Elf64_Ehdr;
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_phdr Elf32_Phdr;
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_phdr {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_phdr Elf64_Phdr;
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct __anonstruct_Elf32_Shdr_96 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct __anonstruct_Elf32_Shdr_96 Elf32_Shdr;
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_shdr Elf64_Shdr;
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_note {
   Elf32_Word n_namesz ;
   Elf32_Word n_descsz ;
   Elf32_Word n_type ;
};
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_note Elf32_Nhdr;
#line 374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_note {
   Elf64_Word n_namesz ;
   Elf64_Word n_descsz ;
   Elf64_Word n_type ;
};
#line 374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_note Elf64_Nhdr;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kernel_param;
#line 32
struct kernel_param;
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
typedef int (*param_set_fn)(char const   *val , struct kernel_param *kp );
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
typedef int (*param_get_fn)(char *buffer , struct kernel_param *kp );
#line 39
struct kparam_array;
#line 39
struct kparam_string;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
union __anonunion____missing_field_name_97 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_97 __annonCompField15 ;
};
#line 52 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
#line 217
struct module;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
struct module;
#line 19
struct marker;
#line 19
struct marker;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu.h"
typedef struct page *(*pcpu_get_page_fn_t)(unsigned int cpu , int pageno );
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu.h"
typedef void (*pcpu_populate_pte_fn_t)(unsigned long addr );
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
typedef struct __anonstruct_local_t_98 local_t;
#line 5 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/module.h"
struct mod_arch_specific {

};
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct modversion_info {
   unsigned long crc ;
   char name[64UL - sizeof(unsigned long )] ;
};
#line 46
struct module;
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 58
struct module_param_attrs;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 71
struct exception_table_entry;
#line 71
struct exception_table_entry;
#line 167
struct notifier_block;
#line 222
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 229
struct module_notes_attrs;
#line 229
struct module_sect_attrs;
#line 229 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   char const   **trace_bprintk_fmt_start ;
   unsigned int num_trace_bprintk_fmt ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
#line 392
enum __anonenum_licence_99 {
    NOT_GPL_ONLY = 0,
    GPL_ONLY = 1,
    WILL_BE_GPL_ONLY = 2
} ;
#line 392 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct symsearch {
   struct kernel_symbol  const  *start ;
   struct kernel_symbol  const  *stop ;
   unsigned long const   *crcs ;
   enum __anonenum_licence_99 licence ;
   bool unused ;
};
#line 646
struct device_driver;
#line 646
struct device_driver;
#line 648
struct module;
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 432 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
struct __large_struct {
   unsigned long buf[100] ;
};
#line 563 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
struct movsl_mask {
   int mask ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ieee1394_device_id {
   __u32 match_flags ;
   __u32 vendor_id ;
   __u32 model_id ;
   __u32 specifier_id ;
   __u32 version ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   kernel_ulong_t driver_info ;
};
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct hid_device_id {
   __u16 bus ;
   __u16 pad1 ;
   __u32 vendor ;
   __u32 product ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ccw_device_id {
   __u16 match_flags ;
   __u16 cu_type ;
   __u16 dev_type ;
   __u8 cu_model ;
   __u8 dev_model ;
   kernel_ulong_t driver_info ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ap_device_id {
   __u16 match_flags ;
   __u8 dev_type ;
   __u8 pad1 ;
   __u32 pad2 ;
   kernel_ulong_t driver_info ;
};
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct css_device_id {
   __u8 match_flags ;
   __u8 type ;
   __u16 pad2 ;
   __u32 pad3 ;
   kernel_ulong_t driver_data ;
};
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[16] ;
   kernel_ulong_t driver_data ;
};
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pnp_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
};
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct __anonstruct_devs_100 {
   __u8 id[8] ;
};
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pnp_card_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
   struct __anonstruct_devs_100 devs[8] ;
};
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct serio_device_id {
   __u8 type ;
   __u8 extra ;
   __u8 id ;
   __u8 proto ;
};
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void *data ;
};
#line 232 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct vio_device_id {
   char type[32] ;
   char compat[32] ;
};
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pcmcia_device_id {
   __u16 match_flags ;
   __u16 manf_id ;
   __u16 card_id ;
   __u8 func_id ;
   __u8 function ;
   __u8 device_no ;
   __u32 prod_id_hash[4]  __attribute__((__aligned__(sizeof(__u32 )))) ;
   char const   *prod_id[4] ;
   kernel_ulong_t driver_info ;
   char *cisfile ;
};
#line 312 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1] ;
   kernel_ulong_t keybit[24] ;
   kernel_ulong_t relbit[1] ;
   kernel_ulong_t absbit[2] ;
   kernel_ulong_t mscbit[1] ;
   kernel_ulong_t ledbit[1] ;
   kernel_ulong_t sndbit[1] ;
   kernel_ulong_t ffbit[4] ;
   kernel_ulong_t swbit[1] ;
   kernel_ulong_t driver_info ;
};
#line 339 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct eisa_device_id {
   char sig[8] ;
   kernel_ulong_t driver_data ;
};
#line 346 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct parisc_device_id {
   __u8 hw_type ;
   __u8 hversion_rev ;
   __u16 hversion ;
   __u32 sversion ;
};
#line 362 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct sdio_device_id {
   __u8 class ;
   __u16 vendor ;
   __u16 device ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 371 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ssb_device_id {
   __u16 vendor ;
   __u16 coreid ;
   __u8 revision ;
};
#line 385 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct virtio_device_id {
   __u32 device ;
   __u32 vendor ;
};
#line 396 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct i2c_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 403
enum dmi_field {
    DMI_NONE = 0,
    DMI_BIOS_VENDOR = 1,
    DMI_BIOS_VERSION = 2,
    DMI_BIOS_DATE = 3,
    DMI_SYS_VENDOR = 4,
    DMI_PRODUCT_NAME = 5,
    DMI_PRODUCT_VERSION = 6,
    DMI_PRODUCT_SERIAL = 7,
    DMI_PRODUCT_UUID = 8,
    DMI_BOARD_VENDOR = 9,
    DMI_BOARD_NAME = 10,
    DMI_BOARD_VERSION = 11,
    DMI_BOARD_SERIAL = 12,
    DMI_BOARD_ASSET_TAG = 13,
    DMI_CHASSIS_VENDOR = 14,
    DMI_CHASSIS_TYPE = 15,
    DMI_CHASSIS_VERSION = 16,
    DMI_CHASSIS_SERIAL = 17,
    DMI_CHASSIS_ASSET_TAG = 18,
    DMI_STRING_MAX = 19
} ;
#line 426 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct dmi_strmatch {
   unsigned char slot ;
   char substr[79] ;
};
#line 440 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct dmi_system_id {
   int (*callback)(struct dmi_system_id  const  * ) ;
   char const   *ident ;
   struct dmi_strmatch matches[4] ;
   void *driver_data ;
};
#line 460 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_ctrlrequest {
   __u8 bRequestType ;
   __u8 bRequest ;
   __le16 wValue ;
   __le16 wIndex ;
   __le16 wLength ;
} __attribute__((__packed__)) ;
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_descriptor_header {
   __u8 bLength ;
   __u8 bDescriptorType ;
} __attribute__((__packed__)) ;
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
} __attribute__((__packed__)) ;
#line 269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
} __attribute__((__packed__)) ;
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_string_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wData[1] ;
} __attribute__((__packed__)) ;
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
} __attribute__((__packed__)) ;
#line 324 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
} __attribute__((__packed__)) ;
#line 539 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_qualifier_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __u8 bNumConfigurations ;
   __u8 bRESERVED ;
} __attribute__((__packed__)) ;
#line 556 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_otg_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bmAttributes ;
} __attribute__((__packed__)) ;
#line 570 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_debug_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDebugInEndpoint ;
   __u8 bDebugOutEndpoint ;
} __attribute__((__packed__)) ;
#line 582 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
} __attribute__((__packed__)) ;
#line 600 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_security_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumEncryptionTypes ;
} __attribute__((__packed__)) ;
#line 613 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_key_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 tTKID[3] ;
   __u8 bReserved ;
   __u8 bKeyData[0] ;
} __attribute__((__packed__)) ;
#line 625 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_encryption_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEncryptionType ;
   __u8 bEncryptionValue ;
   __u8 bAuthKeyIndex ;
} __attribute__((__packed__)) ;
#line 642 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
} __attribute__((__packed__)) ;
#line 653 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_dev_cap_header {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
} __attribute__((__packed__)) ;
#line 661 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_wireless_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wPHYRates ;
   __u8 bmTFITXPowerInfo ;
   __u8 bmFFITXPowerInfo ;
   __le16 bmBandGroup ;
   __u8 bReserved ;
} __attribute__((__packed__)) ;
#line 689 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
} __attribute__((__packed__)) ;
#line 702 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_wireless_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bMaxSequence ;
   __le16 wMaxStreamDelay ;
   __le16 wOverTheAirPacketSize ;
   __u8 bOverTheAirInterval ;
   __u8 bmCompAttributes ;
} __attribute__((__packed__)) ;
#line 724 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_handshake {
   __u8 bMessageNumber ;
   __u8 bStatus ;
   __u8 tTKID[3] ;
   __u8 bReserved ;
   __u8 CDID[16] ;
   __u8 nonce[16] ;
   __u8 MIC[8] ;
} __attribute__((__packed__)) ;
#line 740 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_connection_context {
   __u8 CHID[16] ;
   __u8 CDID[16] ;
   __u8 CK[16] ;
} __attribute__((__packed__)) ;
#line 750
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_VARIABLE = 4
} ;
#line 757
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqreturn.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqnr.h"
struct irq_desc;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_param {
   int sched_priority ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct task_struct;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
typedef struct __user_cap_header_struct *cap_user_header_t;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
typedef struct __user_cap_data_struct *cap_user_data_t;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct __anonstruct_data_101 {
   __le32 permitted ;
   __le32 inheritable ;
};
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct vfs_cap_data {
   __le32 magic_etc ;
   struct __anonstruct_data_101 data[2] ;
};
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct cpu_vfs_cap_data {
   __u32 magic_etc ;
   kernel_cap_t permitted ;
   kernel_cap_t inheritable ;
};
#line 568
struct dentry;
#line 568
struct dentry;
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_node;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_iter {
   struct prio_tree_node *cur ;
   unsigned long mask ;
   unsigned long value ;
   int size_level ;
   struct prio_tree_root *root ;
   unsigned long r_index ;
   unsigned long h_index ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-debug-flags.h"
enum page_debug_flags {
    PAGE_DEBUG_FLAG_POISON = 0
} ;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct address_space;
#line 23
struct address_space;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
typedef atomic_long_t mm_counter_t;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_102 {
   unsigned long index ;
   void *freelist ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_104 {
   unsigned long private ;
   struct address_space *mapping ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_103 {
   struct __anonstruct____missing_field_name_104 __annonCompField17 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_106 {
   u16 inuse ;
   u16 objects ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_105 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_106 __annonCompField19 ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_105 __annonCompField20 ;
   union __anonunion____missing_field_name_103 __annonCompField18 ;
   union __anonunion____missing_field_name_102 __annonCompField16 ;
   struct list_head lru ;
};
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct vm_region {
   struct rb_node vm_rb ;
   unsigned long vm_flags ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   unsigned long vm_top ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   atomic_t vm_usage ;
};
#line 126
struct vm_operations_struct;
#line 126
struct anon_vma;
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct __anonstruct_vm_set_108 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion_shared_107 {
   struct __anonstruct_vm_set_108 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_107 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
#line 183 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[42] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/cputime.h"
typedef u64 cputime64_t;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct ipc_perm {
   __kernel_key_t key ;
   __kernel_uid_t uid ;
   __kernel_gid_t gid ;
   __kernel_uid_t cuid ;
   __kernel_gid_t cgid ;
   __kernel_mode_t mode ;
   unsigned short seq ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ipcbuf.h"
struct ipc64_perm {
   __kernel_key_t key ;
   __kernel_uid32_t uid ;
   __kernel_gid32_t gid ;
   __kernel_uid32_t cuid ;
   __kernel_gid32_t cgid ;
   __kernel_mode_t mode ;
   unsigned short __pad1 ;
   unsigned short seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct msgbuf;
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct ipc_kludge {
   struct msgbuf *msgp ;
   long msgtyp ;
};
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct kern_ipc_perm {
   spinlock_t lock ;
   int deleted ;
   int id ;
   key_t key ;
   uid_t uid ;
   gid_t gid ;
   uid_t cuid ;
   gid_t cgid ;
   mode_t mode ;
   unsigned long seq ;
   void *security ;
};
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_undo;
#line 23
struct sem_queue;
#line 23
struct sem;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned short sem_nsems ;
};
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sembuf.h"
struct semid64_ds {
   struct ipc64_perm sem_perm ;
   __kernel_time_t sem_otime ;
   unsigned long __unused1 ;
   __kernel_time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 45
struct seminfo;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
   void *__pad ;
};
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 83
struct task_struct;
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem {
   int semval ;
   int sempid ;
};
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_array {
   struct kern_ipc_perm sem_perm ;
   time_t sem_otime ;
   time_t sem_ctime ;
   struct sem *sem_base ;
   struct list_head sem_pending ;
   struct list_head list_id ;
   unsigned long sem_nsems ;
};
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_queue {
   struct list_head list ;
   struct task_struct *sleeper ;
   struct sem_undo *undo ;
   int pid ;
   int status ;
   struct sembuf *sops ;
   int nsops ;
   int alter ;
};
#line 117
struct sem_undo_list;
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_undo {
   struct list_head list_proc ;
   struct rcu_head rcu ;
   struct sem_undo_list *ulp ;
   struct list_head list_id ;
   int semid ;
   short *semadj ;
};
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct siginfo;
#line 10
struct siginfo;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
typedef unsigned long old_sigset_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_109 {
   unsigned long sig[1] ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_109 sigset_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef void __signalfn_t(int  );
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef void __restorefn_t(void);
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef __restorefn_t *__sigrestore_t;
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
typedef struct sigaltstack stack_t;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_111 {
   long _band ;
   int _fd ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_112 {
   void *_addr ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_113 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__rt_114 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__timer_115 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__kill_116 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
union __anonunion__sifields_110 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_116 _kill ;
   struct __anonstruct__timer_115 _timer ;
   struct __anonstruct__rt_114 _rt ;
   struct __anonstruct__sigchld_113 _sigchld ;
   struct __anonstruct__sigfault_112 _sigfault ;
   struct __anonstruct__sigpoll_111 _sigpoll ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_110 _sifields ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigev_thread_118 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
union __anonunion__sigev_un_117 {
   int _pad[(64UL - (sizeof(int ) * 2UL + sizeof(sigval_t ))) / sizeof(int )] ;
   int _tid ;
   struct __anonstruct__sigev_thread_118 _sigev_thread ;
};
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_117 _sigev_un ;
};
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
typedef struct sigevent sigevent_t;
#line 274
struct siginfo;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
struct user_struct;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
struct sigqueue {
   struct list_head list ;
   int flags ;
   siginfo_t info ;
   struct user_struct *user ;
};
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 242
struct pt_regs;
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/path.h"
struct dentry;
#line 5
struct vfsmount;
#line 5
struct vfsmount;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 50
struct pid_namespace;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 100
struct pid_namespace;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
struct percpu_counter {
   spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_global {
   int shift ;
   struct percpu_counter events ;
};
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_descriptor {
   int index ;
   struct prop_global pg[2] ;
   struct mutex mutex ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_local_percpu {
   struct percpu_counter events ;
   int shift ;
   unsigned long period ;
   spinlock_t lock ;
};
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
struct __anonstruct_seccomp_t_119 {
   int mode ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_119 seccomp_t;
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct plist_head plist ;
};
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rtmutex.h"
struct rt_mutex {
   spinlock_t wait_lock ;
   struct plist_head wait_list ;
   struct task_struct *owner ;
};
#line 38
struct rt_mutex_waiter;
#line 38
struct rt_mutex_waiter;
#line 39
struct hrtimer_sleeper;
#line 39
struct hrtimer_sleeper;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
struct task_struct;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_clock_base;
#line 26
struct hrtimer_clock_base;
#line 27
struct hrtimer_cpu_base;
#line 27
struct hrtimer_cpu_base;
#line 32
enum hrtimer_mode {
    HRTIMER_MODE_ABS = 0,
    HRTIMER_MODE_REL = 1
} ;
#line 40
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_sleeper {
   struct hrtimer timer ;
   struct task_struct *task ;
};
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
   ktime_t expires_next ;
   int hres_active ;
   unsigned long nr_events ;
};
#line 244
struct clock_event_device;
#line 244
struct clock_event_device;
#line 310
struct tick_device;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct file;
#line 33
struct completion;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct __sysctl_args {
   int *name ;
   int nlen ;
   void *oldval ;
   size_t *oldlenp ;
   void *newval ;
   size_t newlen ;
   unsigned long __unused[4] ;
};
#line 60
enum __anonenum_120 {
    CTL_KERN = 1,
    CTL_VM = 2,
    CTL_NET = 3,
    CTL_PROC = 4,
    CTL_FS = 5,
    CTL_DEBUG = 6,
    CTL_DEV = 7,
    CTL_BUS = 8,
    CTL_ABI = 9,
    CTL_CPU = 10,
    CTL_ARLAN = 254,
    CTL_S390DBF = 5677,
    CTL_SUNRPC = 7249,
    CTL_PM = 9899,
    CTL_FRV = 9898
} ;
#line 80
enum __anonenum_121 {
    CTL_BUS_ISA = 1
} ;
#line 86
enum __anonenum_122 {
    INOTIFY_MAX_USER_INSTANCES = 1,
    INOTIFY_MAX_USER_WATCHES = 2,
    INOTIFY_MAX_QUEUED_EVENTS = 3
} ;
#line 94
enum __anonenum_123 {
    KERN_OSTYPE = 1,
    KERN_OSRELEASE = 2,
    KERN_OSREV = 3,
    KERN_VERSION = 4,
    KERN_SECUREMASK = 5,
    KERN_PROF = 6,
    KERN_NODENAME = 7,
    KERN_DOMAINNAME = 8,
    KERN_PANIC = 15,
    KERN_REALROOTDEV = 16,
    KERN_SPARC_REBOOT = 21,
    KERN_CTLALTDEL = 22,
    KERN_PRINTK = 23,
    KERN_NAMETRANS = 24,
    KERN_PPC_HTABRECLAIM = 25,
    KERN_PPC_ZEROPAGED = 26,
    KERN_PPC_POWERSAVE_NAP = 27,
    KERN_MODPROBE = 28,
    KERN_SG_BIG_BUFF = 29,
    KERN_ACCT = 30,
    KERN_PPC_L2CR = 31,
    KERN_RTSIGNR = 32,
    KERN_RTSIGMAX = 33,
    KERN_SHMMAX = 34,
    KERN_MSGMAX = 35,
    KERN_MSGMNB = 36,
    KERN_MSGPOOL = 37,
    KERN_SYSRQ = 38,
    KERN_MAX_THREADS = 39,
    KERN_RANDOM = 40,
    KERN_SHMALL = 41,
    KERN_MSGMNI = 42,
    KERN_SEM = 43,
    KERN_SPARC_STOP_A = 44,
    KERN_SHMMNI = 45,
    KERN_OVERFLOWUID = 46,
    KERN_OVERFLOWGID = 47,
    KERN_SHMPATH = 48,
    KERN_HOTPLUG = 49,
    KERN_IEEE_EMULATION_WARNINGS = 50,
    KERN_S390_USER_DEBUG_LOGGING = 51,
    KERN_CORE_USES_PID = 52,
    KERN_TAINTED = 53,
    KERN_CADPID = 54,
    KERN_PIDMAX = 55,
    KERN_CORE_PATTERN = 56,
    KERN_PANIC_ON_OOPS = 57,
    KERN_HPPA_PWRSW = 58,
    KERN_HPPA_UNALIGNED = 59,
    KERN_PRINTK_RATELIMIT = 60,
    KERN_PRINTK_RATELIMIT_BURST = 61,
    KERN_PTY = 62,
    KERN_NGROUPS_MAX = 63,
    KERN_SPARC_SCONS_PWROFF = 64,
    KERN_HZ_TIMER = 65,
    KERN_UNKNOWN_NMI_PANIC = 66,
    KERN_BOOTLOADER_TYPE = 67,
    KERN_RANDOMIZE = 68,
    KERN_SETUID_DUMPABLE = 69,
    KERN_SPIN_RETRY = 70,
    KERN_ACPI_VIDEO_FLAGS = 71,
    KERN_IA64_UNALIGNED = 72,
    KERN_COMPAT_LOG = 73,
    KERN_MAX_LOCK_DEPTH = 74,
    KERN_NMI_WATCHDOG = 75,
    KERN_PANIC_ON_NMI = 76
} ;
#line 171
enum __anonenum_124 {
    VM_UNUSED1 = 1,
    VM_UNUSED2 = 2,
    VM_UNUSED3 = 3,
    VM_UNUSED4 = 4,
    VM_OVERCOMMIT_MEMORY = 5,
    VM_UNUSED5 = 6,
    VM_UNUSED7 = 7,
    VM_UNUSED8 = 8,
    VM_UNUSED9 = 9,
    VM_PAGE_CLUSTER = 10,
    VM_DIRTY_BACKGROUND = 11,
    VM_DIRTY_RATIO = 12,
    VM_DIRTY_WB_CS = 13,
    VM_DIRTY_EXPIRE_CS = 14,
    VM_NR_PDFLUSH_THREADS = 15,
    VM_OVERCOMMIT_RATIO = 16,
    VM_PAGEBUF = 17,
    VM_HUGETLB_PAGES = 18,
    VM_SWAPPINESS = 19,
    VM_LOWMEM_RESERVE_RATIO = 20,
    VM_MIN_FREE_KBYTES = 21,
    VM_MAX_MAP_COUNT = 22,
    VM_LAPTOP_MODE = 23,
    VM_BLOCK_DUMP = 24,
    VM_HUGETLB_GROUP = 25,
    VM_VFS_CACHE_PRESSURE = 26,
    VM_LEGACY_VA_LAYOUT = 27,
    VM_SWAP_TOKEN_TIMEOUT = 28,
    VM_DROP_PAGECACHE = 29,
    VM_PERCPU_PAGELIST_FRACTION = 30,
    VM_ZONE_RECLAIM_MODE = 31,
    VM_MIN_UNMAPPED = 32,
    VM_PANIC_ON_OOM = 33,
    VM_VDSO_ENABLED = 34,
    VM_MIN_SLAB = 35
} ;
#line 212
enum __anonenum_125 {
    NET_CORE = 1,
    NET_ETHER = 2,
    NET_802 = 3,
    NET_UNIX = 4,
    NET_IPV4 = 5,
    NET_IPX = 6,
    NET_ATALK = 7,
    NET_NETROM = 8,
    NET_AX25 = 9,
    NET_BRIDGE = 10,
    NET_ROSE = 11,
    NET_IPV6 = 12,
    NET_X25 = 13,
    NET_TR = 14,
    NET_DECNET = 15,
    NET_ECONET = 16,
    NET_SCTP = 17,
    NET_LLC = 18,
    NET_NETFILTER = 19,
    NET_DCCP = 20,
    NET_IRDA = 412
} ;
#line 238
enum __anonenum_126 {
    RANDOM_POOLSIZE = 1,
    RANDOM_ENTROPY_COUNT = 2,
    RANDOM_READ_THRESH = 3,
    RANDOM_WRITE_THRESH = 4,
    RANDOM_BOOT_ID = 5,
    RANDOM_UUID = 6
} ;
#line 249
enum __anonenum_127 {
    PTY_MAX = 1,
    PTY_NR = 2
} ;
#line 256
enum __anonenum_128 {
    BUS_ISA_MEM_BASE = 1,
    BUS_ISA_PORT_BASE = 2,
    BUS_ISA_PORT_SHIFT = 3
} ;
#line 264
enum __anonenum_129 {
    NET_CORE_WMEM_MAX = 1,
    NET_CORE_RMEM_MAX = 2,
    NET_CORE_WMEM_DEFAULT = 3,
    NET_CORE_RMEM_DEFAULT = 4,
    NET_CORE_MAX_BACKLOG = 6,
    NET_CORE_FASTROUTE = 7,
    NET_CORE_MSG_COST = 8,
    NET_CORE_MSG_BURST = 9,
    NET_CORE_OPTMEM_MAX = 10,
    NET_CORE_HOT_LIST_LENGTH = 11,
    NET_CORE_DIVERT_VERSION = 12,
    NET_CORE_NO_CONG_THRESH = 13,
    NET_CORE_NO_CONG = 14,
    NET_CORE_LO_CONG = 15,
    NET_CORE_MOD_CONG = 16,
    NET_CORE_DEV_WEIGHT = 17,
    NET_CORE_SOMAXCONN = 18,
    NET_CORE_BUDGET = 19,
    NET_CORE_AEVENT_ETIME = 20,
    NET_CORE_AEVENT_RSEQTH = 21,
    NET_CORE_WARNINGS = 22
} ;
#line 296
enum __anonenum_130 {
    NET_UNIX_DESTROY_DELAY = 1,
    NET_UNIX_DELETE_DELAY = 2,
    NET_UNIX_MAX_DGRAM_QLEN = 3
} ;
#line 304
enum __anonenum_131 {
    NET_NF_CONNTRACK_MAX = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_NF_CONNTRACK_BUCKETS = 14,
    NET_NF_CONNTRACK_LOG_INVALID = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_NF_CONNTRACK_COUNT = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
    NET_NF_CONNTRACK_CHECKSUM = 32
} ;
#line 341
enum __anonenum_132 {
    NET_IPV4_FORWARD = 8,
    NET_IPV4_DYNADDR = 9,
    NET_IPV4_CONF = 16,
    NET_IPV4_NEIGH = 17,
    NET_IPV4_ROUTE = 18,
    NET_IPV4_FIB_HASH = 19,
    NET_IPV4_NETFILTER = 20,
    NET_IPV4_TCP_TIMESTAMPS = 33,
    NET_IPV4_TCP_WINDOW_SCALING = 34,
    NET_IPV4_TCP_SACK = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
    NET_IPV4_DEFAULT_TTL = 37,
    NET_IPV4_AUTOCONFIG = 38,
    NET_IPV4_NO_PMTU_DISC = 39,
    NET_IPV4_TCP_SYN_RETRIES = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH = 41,
    NET_IPV4_IPFRAG_LOW_THRESH = 42,
    NET_IPV4_IPFRAG_TIME = 43,
    NET_IPV4_TCP_MAX_KA_PROBES = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
    NET_IPV4_TCP_RETRIES1 = 47,
    NET_IPV4_TCP_RETRIES2 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT = 49,
    NET_IPV4_IP_MASQ_DEBUG = 50,
    NET_TCP_SYNCOOKIES = 51,
    NET_TCP_STDURG = 52,
    NET_TCP_RFC1337 = 53,
    NET_TCP_SYN_TAILDROP = 54,
    NET_TCP_MAX_SYN_BACKLOG = 55,
    NET_IPV4_LOCAL_PORT_RANGE = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
    NET_TCP_TW_RECYCLE = 66,
    NET_IPV4_ALWAYS_DEFRAG = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
    NET_IPV4_INET_PEER_THRESHOLD = 69,
    NET_IPV4_INET_PEER_MINTTL = 70,
    NET_IPV4_INET_PEER_MAXTTL = 71,
    NET_IPV4_INET_PEER_GC_MINTIME = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME = 73,
    NET_TCP_ORPHAN_RETRIES = 74,
    NET_TCP_ABORT_ON_OVERFLOW = 75,
    NET_TCP_SYNACK_RETRIES = 76,
    NET_TCP_MAX_ORPHANS = 77,
    NET_TCP_MAX_TW_BUCKETS = 78,
    NET_TCP_FACK = 79,
    NET_TCP_REORDERING = 80,
    NET_TCP_ECN = 81,
    NET_TCP_DSACK = 82,
    NET_TCP_MEM = 83,
    NET_TCP_WMEM = 84,
    NET_TCP_RMEM = 85,
    NET_TCP_APP_WIN = 86,
    NET_TCP_ADV_WIN_SCALE = 87,
    NET_IPV4_NONLOCAL_BIND = 88,
    NET_IPV4_ICMP_RATELIMIT = 89,
    NET_IPV4_ICMP_RATEMASK = 90,
    NET_TCP_TW_REUSE = 91,
    NET_TCP_FRTO = 92,
    NET_TCP_LOW_LATENCY = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
    NET_IPV4_IGMP_MAX_MSF = 96,
    NET_TCP_NO_METRICS_SAVE = 97,
    NET_TCP_DEFAULT_WIN_SCALE = 105,
    NET_TCP_MODERATE_RCVBUF = 106,
    NET_TCP_TSO_WIN_DIVISOR = 107,
    NET_TCP_BIC_BETA = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
    NET_TCP_CONG_CONTROL = 110,
    NET_TCP_ABC = 111,
    NET_IPV4_IPFRAG_MAX_DIST = 112,
    NET_TCP_MTU_PROBING = 113,
    NET_TCP_BASE_MSS = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
    NET_TCP_DMA_COPYBREAK = 116,
    NET_TCP_SLOW_START_AFTER_IDLE = 117,
    NET_CIPSOV4_CACHE_ENABLE = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
    NET_CIPSOV4_RBM_OPTFMT = 120,
    NET_CIPSOV4_RBM_STRICTVALID = 121,
    NET_TCP_AVAIL_CONG_CONTROL = 122,
    NET_TCP_ALLOWED_CONG_CONTROL = 123,
    NET_TCP_MAX_SSTHRESH = 124,
    NET_TCP_FRTO_RESPONSE = 125
} ;
#line 440
enum __anonenum_133 {
    NET_IPV4_ROUTE_FLUSH = 1,
    NET_IPV4_ROUTE_MIN_DELAY = 2,
    NET_IPV4_ROUTE_MAX_DELAY = 3,
    NET_IPV4_ROUTE_GC_THRESH = 4,
    NET_IPV4_ROUTE_MAX_SIZE = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT = 7,
    NET_IPV4_ROUTE_GC_INTERVAL = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
    NET_IPV4_ROUTE_ERROR_COST = 12,
    NET_IPV4_ROUTE_ERROR_BURST = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES = 15,
    NET_IPV4_ROUTE_MIN_PMTU = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19
} ;
#line 462
enum __anonenum_134 {
    NET_PROTO_CONF_ALL = -2,
    NET_PROTO_CONF_DEFAULT = -3
} ;
#line 470
enum __anonenum_135 {
    NET_IPV4_CONF_FORWARDING = 1,
    NET_IPV4_CONF_MC_FORWARDING = 2,
    NET_IPV4_CONF_PROXY_ARP = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS = 5,
    NET_IPV4_CONF_SEND_REDIRECTS = 6,
    NET_IPV4_CONF_SHARED_MEDIA = 7,
    NET_IPV4_CONF_RP_FILTER = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
    NET_IPV4_CONF_BOOTP_RELAY = 10,
    NET_IPV4_CONF_LOG_MARTIANS = 11,
    NET_IPV4_CONF_TAG = 12,
    NET_IPV4_CONF_ARPFILTER = 13,
    NET_IPV4_CONF_MEDIUM_ID = 14,
    NET_IPV4_CONF_NOXFRM = 15,
    NET_IPV4_CONF_NOPOLICY = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE = 18,
    NET_IPV4_CONF_ARP_IGNORE = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
    NET_IPV4_CONF_ARP_ACCEPT = 21,
    NET_IPV4_CONF_ARP_NOTIFY = 22,
    __NET_IPV4_CONF_MAX = 23
} ;
#line 498
enum __anonenum_136 {
    NET_IPV4_NF_CONNTRACK_MAX = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_IPV4_NF_CONNTRACK_COUNT = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM = 28
} ;
#line 531
enum __anonenum_137 {
    NET_IPV6_CONF = 16,
    NET_IPV6_NEIGH = 17,
    NET_IPV6_ROUTE = 18,
    NET_IPV6_ICMP = 19,
    NET_IPV6_BINDV6ONLY = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH = 22,
    NET_IPV6_IP6FRAG_TIME = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
    NET_IPV6_MLD_MAX_MSF = 25
} ;
#line 544
enum __anonenum_138 {
    NET_IPV6_ROUTE_FLUSH = 1,
    NET_IPV6_ROUTE_GC_THRESH = 2,
    NET_IPV6_ROUTE_MAX_SIZE = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT = 5,
    NET_IPV6_ROUTE_GC_INTERVAL = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10
} ;
#line 557
enum __anonenum_139 {
    NET_IPV6_FORWARDING = 1,
    NET_IPV6_HOP_LIMIT = 2,
    NET_IPV6_MTU = 3,
    NET_IPV6_ACCEPT_RA = 4,
    NET_IPV6_ACCEPT_REDIRECTS = 5,
    NET_IPV6_AUTOCONF = 6,
    NET_IPV6_DAD_TRANSMITS = 7,
    NET_IPV6_RTR_SOLICITS = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
    NET_IPV6_RTR_SOLICIT_DELAY = 10,
    NET_IPV6_USE_TEMPADDR = 11,
    NET_IPV6_TEMP_VALID_LFT = 12,
    NET_IPV6_TEMP_PREFERED_LFT = 13,
    NET_IPV6_REGEN_MAX_RETRY = 14,
    NET_IPV6_MAX_DESYNC_FACTOR = 15,
    NET_IPV6_MAX_ADDRESSES = 16,
    NET_IPV6_FORCE_MLD_VERSION = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR = 18,
    NET_IPV6_ACCEPT_RA_PINFO = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
    NET_IPV6_RTR_PROBE_INTERVAL = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
    NET_IPV6_PROXY_NDP = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
    __NET_IPV6_MAX = 26
} ;
#line 586
enum __anonenum_140 {
    NET_IPV6_ICMP_RATELIMIT = 1
} ;
#line 591
enum __anonenum_141 {
    NET_NEIGH_MCAST_SOLICIT = 1,
    NET_NEIGH_UCAST_SOLICIT = 2,
    NET_NEIGH_APP_SOLICIT = 3,
    NET_NEIGH_RETRANS_TIME = 4,
    NET_NEIGH_REACHABLE_TIME = 5,
    NET_NEIGH_DELAY_PROBE_TIME = 6,
    NET_NEIGH_GC_STALE_TIME = 7,
    NET_NEIGH_UNRES_QLEN = 8,
    NET_NEIGH_PROXY_QLEN = 9,
    NET_NEIGH_ANYCAST_DELAY = 10,
    NET_NEIGH_PROXY_DELAY = 11,
    NET_NEIGH_LOCKTIME = 12,
    NET_NEIGH_GC_INTERVAL = 13,
    NET_NEIGH_GC_THRESH1 = 14,
    NET_NEIGH_GC_THRESH2 = 15,
    NET_NEIGH_GC_THRESH3 = 16,
    NET_NEIGH_RETRANS_TIME_MS = 17,
    NET_NEIGH_REACHABLE_TIME_MS = 18,
    __NET_NEIGH_MAX = 19
} ;
#line 614
enum __anonenum_142 {
    NET_DCCP_DEFAULT = 1
} ;
#line 619
enum __anonenum_143 {
    NET_IPX_PPROP_BROADCASTING = 1,
    NET_IPX_FORWARDING = 2
} ;
#line 625
enum __anonenum_144 {
    NET_LLC2 = 1,
    NET_LLC_STATION = 2
} ;
#line 631
enum __anonenum_145 {
    NET_LLC2_TIMEOUT = 1
} ;
#line 636
enum __anonenum_146 {
    NET_LLC_STATION_ACK_TIMEOUT = 1
} ;
#line 641
enum __anonenum_147 {
    NET_LLC2_ACK_TIMEOUT = 1,
    NET_LLC2_P_TIMEOUT = 2,
    NET_LLC2_REJ_TIMEOUT = 3,
    NET_LLC2_BUSY_TIMEOUT = 4
} ;
#line 649
enum __anonenum_148 {
    NET_ATALK_AARP_EXPIRY_TIME = 1,
    NET_ATALK_AARP_TICK_TIME = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
    NET_ATALK_AARP_RESOLVE_TIME = 4
} ;
#line 658
enum __anonenum_149 {
    NET_NETROM_DEFAULT_PATH_QUALITY = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER = 3,
    NET_NETROM_TRANSPORT_TIMEOUT = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
    NET_NETROM_ROUTING_CONTROL = 10,
    NET_NETROM_LINK_FAILS_COUNT = 11,
    NET_NETROM_RESET = 12
} ;
#line 674
enum __anonenum_150 {
    NET_AX25_IP_DEFAULT_MODE = 1,
    NET_AX25_DEFAULT_MODE = 2,
    NET_AX25_BACKOFF_TYPE = 3,
    NET_AX25_CONNECT_MODE = 4,
    NET_AX25_STANDARD_WINDOW = 5,
    NET_AX25_EXTENDED_WINDOW = 6,
    NET_AX25_T1_TIMEOUT = 7,
    NET_AX25_T2_TIMEOUT = 8,
    NET_AX25_T3_TIMEOUT = 9,
    NET_AX25_IDLE_TIMEOUT = 10,
    NET_AX25_N2 = 11,
    NET_AX25_PACLEN = 12,
    NET_AX25_PROTOCOL = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT = 14
} ;
#line 692
enum __anonenum_151 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_ROSE_ROUTING_CONTROL = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT = 7,
    NET_ROSE_MAX_VCS = 8,
    NET_ROSE_WINDOW_SIZE = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT = 10
} ;
#line 706
enum __anonenum_152 {
    NET_X25_RESTART_REQUEST_TIMEOUT = 1,
    NET_X25_CALL_REQUEST_TIMEOUT = 2,
    NET_X25_RESET_REQUEST_TIMEOUT = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_X25_FORWARD = 6
} ;
#line 716
enum __anonenum_153 {
    NET_TR_RIF_TIMEOUT = 1
} ;
#line 722
enum __anonenum_154 {
    NET_DECNET_NODE_TYPE = 1,
    NET_DECNET_NODE_ADDRESS = 2,
    NET_DECNET_NODE_NAME = 3,
    NET_DECNET_DEFAULT_DEVICE = 4,
    NET_DECNET_TIME_WAIT = 5,
    NET_DECNET_DN_COUNT = 6,
    NET_DECNET_DI_COUNT = 7,
    NET_DECNET_DR_COUNT = 8,
    NET_DECNET_DST_GC_INTERVAL = 9,
    NET_DECNET_CONF = 10,
    NET_DECNET_NO_FC_MAX_CWND = 11,
    NET_DECNET_MEM = 12,
    NET_DECNET_RMEM = 13,
    NET_DECNET_WMEM = 14,
    NET_DECNET_DEBUG_LEVEL = 255
} ;
#line 741
enum __anonenum_155 {
    NET_DECNET_CONF_LOOPBACK = -2,
    NET_DECNET_CONF_DDCMP = -3,
    NET_DECNET_CONF_PPP = -4,
    NET_DECNET_CONF_X25 = -5,
    NET_DECNET_CONF_GRE = -6,
    NET_DECNET_CONF_ETHER = -7
} ;
#line 753
enum __anonenum_156 {
    NET_DECNET_CONF_DEV_PRIORITY = 1,
    NET_DECNET_CONF_DEV_T1 = 2,
    NET_DECNET_CONF_DEV_T2 = 3,
    NET_DECNET_CONF_DEV_T3 = 4,
    NET_DECNET_CONF_DEV_FORWARDING = 5,
    NET_DECNET_CONF_DEV_BLKSIZE = 6,
    NET_DECNET_CONF_DEV_STATE = 7
} ;
#line 764
enum __anonenum_157 {
    NET_SCTP_RTO_INITIAL = 1,
    NET_SCTP_RTO_MIN = 2,
    NET_SCTP_RTO_MAX = 3,
    NET_SCTP_RTO_ALPHA = 4,
    NET_SCTP_RTO_BETA = 5,
    NET_SCTP_VALID_COOKIE_LIFE = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
    NET_SCTP_PATH_MAX_RETRANS = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS = 9,
    NET_SCTP_HB_INTERVAL = 10,
    NET_SCTP_PRESERVE_ENABLE = 11,
    NET_SCTP_MAX_BURST = 12,
    NET_SCTP_ADDIP_ENABLE = 13,
    NET_SCTP_PRSCTP_ENABLE = 14,
    NET_SCTP_SNDBUF_POLICY = 15,
    NET_SCTP_SACK_TIMEOUT = 16,
    NET_SCTP_RCVBUF_POLICY = 17
} ;
#line 785
enum __anonenum_158 {
    NET_BRIDGE_NF_CALL_ARPTABLES = 1,
    NET_BRIDGE_NF_CALL_IPTABLES = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5
} ;
#line 794
enum __anonenum_159 {
    NET_IRDA_DISCOVERY = 1,
    NET_IRDA_DEVNAME = 2,
    NET_IRDA_DEBUG = 3,
    NET_IRDA_FAST_POLL = 4,
    NET_IRDA_DISCOVERY_SLOTS = 5,
    NET_IRDA_DISCOVERY_TIMEOUT = 6,
    NET_IRDA_SLOT_TIMEOUT = 7,
    NET_IRDA_MAX_BAUD_RATE = 8,
    NET_IRDA_MIN_TX_TURN_TIME = 9,
    NET_IRDA_MAX_TX_DATA_SIZE = 10,
    NET_IRDA_MAX_TX_WINDOW = 11,
    NET_IRDA_MAX_NOREPLY_TIME = 12,
    NET_IRDA_WARN_NOREPLY_TIME = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME = 14
} ;
#line 813
enum __anonenum_160 {
    FS_NRINODE = 1,
    FS_STATINODE = 2,
    FS_MAXINODE = 3,
    FS_NRDQUOT = 4,
    FS_MAXDQUOT = 5,
    FS_NRFILE = 6,
    FS_MAXFILE = 7,
    FS_DENTRY = 8,
    FS_NRSUPER = 9,
    FS_MAXSUPER = 10,
    FS_OVERFLOWUID = 11,
    FS_OVERFLOWGID = 12,
    FS_LEASES = 13,
    FS_DIR_NOTIFY = 14,
    FS_LEASE_TIME = 15,
    FS_DQSTATS = 16,
    FS_XFS = 17,
    FS_AIO_NR = 18,
    FS_AIO_MAX_NR = 19,
    FS_INOTIFY = 20,
    FS_OCFS2 = 988
} ;
#line 839
enum __anonenum_161 {
    FS_DQ_LOOKUPS = 1,
    FS_DQ_DROPS = 2,
    FS_DQ_READS = 3,
    FS_DQ_WRITES = 4,
    FS_DQ_CACHE_HITS = 5,
    FS_DQ_ALLOCATED = 6,
    FS_DQ_FREE = 7,
    FS_DQ_SYNCS = 8,
    FS_DQ_WARNINGS = 9
} ;
#line 854
enum __anonenum_162 {
    DEV_CDROM = 1,
    DEV_HWMON = 2,
    DEV_PARPORT = 3,
    DEV_RAID = 4,
    DEV_MAC_HID = 5,
    DEV_SCSI = 6,
    DEV_IPMI = 7
} ;
#line 865
enum __anonenum_163 {
    DEV_CDROM_INFO = 1,
    DEV_CDROM_AUTOCLOSE = 2,
    DEV_CDROM_AUTOEJECT = 3,
    DEV_CDROM_DEBUG = 4,
    DEV_CDROM_LOCK = 5,
    DEV_CDROM_CHECK_MEDIA = 6
} ;
#line 875
enum __anonenum_164 {
    DEV_PARPORT_DEFAULT = -3
} ;
#line 880
enum __anonenum_165 {
    DEV_RAID_SPEED_LIMIT_MIN = 1,
    DEV_RAID_SPEED_LIMIT_MAX = 2
} ;
#line 886
enum __anonenum_166 {
    DEV_PARPORT_DEFAULT_TIMESLICE = 1,
    DEV_PARPORT_DEFAULT_SPINTIME = 2
} ;
#line 892
enum __anonenum_167 {
    DEV_PARPORT_SPINTIME = 1,
    DEV_PARPORT_BASE_ADDR = 2,
    DEV_PARPORT_IRQ = 3,
    DEV_PARPORT_DMA = 4,
    DEV_PARPORT_MODES = 5,
    DEV_PARPORT_DEVICES = 6,
    DEV_PARPORT_AUTOPROBE = 16
} ;
#line 903
enum __anonenum_168 {
    DEV_PARPORT_DEVICES_ACTIVE = -3
} ;
#line 908
enum __anonenum_169 {
    DEV_PARPORT_DEVICE_TIMESLICE = 1
} ;
#line 913
enum __anonenum_170 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6
} ;
#line 923
enum __anonenum_171 {
    DEV_SCSI_LOGGING_LEVEL = 1
} ;
#line 928
enum __anonenum_172 {
    DEV_IPMI_POWEROFF_POWERCYCLE = 1
} ;
#line 933
enum __anonenum_173 {
    ABI_DEFHANDLER_COFF = 1,
    ABI_DEFHANDLER_ELF = 2,
    ABI_DEFHANDLER_LCALL7 = 3,
    ABI_DEFHANDLER_LIBCSO = 4,
    ABI_TRACE = 5,
    ABI_FAKE_UTSNAME = 6
} ;
#line 947
struct ctl_table;
#line 948
struct nsproxy;
#line 948
struct nsproxy;
#line 949
struct ctl_table_root;
#line 949
struct ctl_table_root;
#line 951 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table_set {
   struct list_head list ;
   struct ctl_table_set *parent ;
   int (*is_seen)(struct ctl_table_set * ) ;
};
#line 961
struct ctl_table_header;
#line 961
struct ctl_table_header;
#line 974 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
typedef struct ctl_table ctl_table;
#line 976 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
typedef int ctl_handler(struct ctl_table *table , void *oldval , size_t *oldlenp ,
                        void *newval , size_t newlen );
#line 980 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *ctl , int write , struct file *filp , void *buffer ,
                         size_t *lenp , loff_t *ppos );
#line 1052 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table {
   int ctl_name ;
   char const   *procname ;
   void *data ;
   int maxlen ;
   mode_t mode ;
   struct ctl_table *child ;
   struct ctl_table *parent ;
   proc_handler *proc_handler ;
   ctl_handler *strategy ;
   void *extra1 ;
   void *extra2 ;
};
#line 1067 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table_root {
   struct list_head root_list ;
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *root , struct nsproxy *namespaces ) ;
   int (*permissions)(struct ctl_table_root *root , struct nsproxy *namespaces , struct ctl_table *table ) ;
};
#line 1078 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table_header {
   struct ctl_table *ctl_table ;
   struct list_head ctl_entry ;
   int used ;
   int count ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_table *attached_by ;
   struct ctl_table *attached_to ;
   struct ctl_table_header *parent ;
};
#line 1094 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_path {
   char const   *procname ;
   int ctl_name ;
};
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 74
struct seq_file;
#line 75
struct user_struct;
#line 76
struct signal_struct;
#line 76
struct signal_struct;
#line 77
struct cred;
#line 77
struct cred;
#line 79
struct key_type;
#line 79
struct key_type;
#line 80
struct key_owner;
#line 80
struct key_owner;
#line 81
struct keyring_list;
#line 81
struct keyring_list;
#line 82
struct keyring_name;
#line 82
struct keyring_name;
#line 98
struct __key_reference_with_attributes;
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
typedef struct __key_reference_with_attributes *key_ref_t;
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
union __anonunion_payload_174 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
union __anonunion_type_data_175 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
#line 124
struct key_user;
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_175 type_data ;
   union __anonunion_payload_174 payload ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct user_struct;
#line 21
struct cred;
#line 22
struct inode;
#line 22
struct inode;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct mem_cgroup;
#line 94
struct mem_cgroup;
#line 95
struct exec_domain;
#line 96
struct futex_pi_state;
#line 96
struct futex_pi_state;
#line 97
struct robust_list_head;
#line 97
struct robust_list_head;
#line 98
struct bio;
#line 98
struct bio;
#line 99
struct bts_tracer;
#line 99
struct bts_tracer;
#line 100
struct fs_struct;
#line 100
struct fs_struct;
#line 143
struct seq_file;
#line 144
struct cfs_rq;
#line 144
struct cfs_rq;
#line 145
struct task_group;
#line 145
struct task_group;
#line 246
struct task_struct;
#line 345
struct nsproxy;
#line 346
struct user_namespace;
#line 346
struct user_namespace;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio_abi.h"
typedef unsigned long aio_context_t;
#line 35
enum __anonenum_176 {
    IOCB_CMD_PREAD = 0,
    IOCB_CMD_PWRITE = 1,
    IOCB_CMD_FSYNC = 2,
    IOCB_CMD_FDSYNC = 3,
    IOCB_CMD_NOOP = 6,
    IOCB_CMD_PREADV = 7,
    IOCB_CMD_PWRITEV = 8
} ;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio_abi.h"
struct iocb {
   __u64 aio_data ;
   __u32 aio_key ;
   __u32 aio_reserved1 ;
   __u16 aio_lio_opcode ;
   __s16 aio_reqprio ;
   __u32 aio_fildes ;
   __u64 aio_buf ;
   __u64 aio_nbytes ;
   __s64 aio_offset ;
   __u64 aio_reserved2 ;
   __u32 aio_flags ;
   __u32 aio_resfd ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct kioctx;
#line 15
struct kioctx;
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
union __anonunion_ki_obj_177 {
   void *user ;
   struct task_struct *tsk ;
};
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_177 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct aio_ring {
   unsigned int id ;
   unsigned int nr ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int magic ;
   unsigned int compat_features ;
   unsigned int incompat_features ;
   unsigned int header_length ;
   struct io_event io_events[0] ;
};
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 215
struct mm_struct;
#line 442 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 449 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 468 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 495 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
#line 508
struct tty_audit_buf;
#line 508
struct taskstats;
#line 508
struct tty_struct;
#line 508 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
#line 640 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
#line 685
struct backing_dev_info;
#line 685
struct backing_dev_info;
#line 686
struct reclaim_state;
#line 686
struct reclaim_state;
#line 689 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
#line 705 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 750
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
#line 783
enum powersavings_balance_level {
    POWERSAVINGS_BALANCE_NONE = 0,
    POWERSAVINGS_BALANCE_BASIC = 1,
    POWERSAVINGS_BALANCE_WAKEUP = 2,
    MAX_POWERSAVINGS_BALANCE_LEVELS = 3
} ;
#line 826 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
#line 849
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
#line 859 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_domain_attr {
   int relax_domain_level ;
};
#line 867 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   unsigned long span[] ;
};
#line 959
struct io_context;
#line 959
struct io_context;
#line 968
struct audit_context;
#line 968
struct audit_context;
#line 969
struct mempolicy;
#line 969
struct mempolicy;
#line 970
struct pipe_inode_info;
#line 970
struct pipe_inode_info;
#line 971
struct uts_namespace;
#line 971
struct uts_namespace;
#line 973
struct rq;
#line 973
struct rq;
#line 974
struct sched_domain;
#line 976 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   int (*needs_post_schedule)(struct rq *this_rq ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
   void (*moved_group)(struct task_struct *p ) ;
};
#line 1027 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1041 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 start_runtime ;
   u64 avg_wakeup ;
   u64 nr_migrations ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1101 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
#line 1117
struct css_set;
#line 1117
struct irqaction;
#line 1117
struct files_struct;
#line 1117
struct linux_binfmt;
#line 1117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   int cpuset_mems_generation ;
   int cpuset_mem_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   struct prop_local_single dirties ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
#line 1493
struct pid_namespace;
#line 1816 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
union thread_union {
   struct thread_info thread_info ;
   unsigned long stack[((1UL << 12) << 1) / sizeof(long )] ;
};
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
typedef struct pt_regs *T__;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
struct irq_desc;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
typedef void (*irq_flow_handler_t)(unsigned int irq , struct irq_desc *desc );
#line 81
struct proc_dir_entry;
#line 81
struct proc_dir_entry;
#line 82
struct msi_desc;
#line 82
struct msi_desc;
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
struct irq_chip {
   char const   *name ;
   unsigned int (*startup)(unsigned int irq ) ;
   void (*shutdown)(unsigned int irq ) ;
   void (*enable)(unsigned int irq ) ;
   void (*disable)(unsigned int irq ) ;
   void (*ack)(unsigned int irq ) ;
   void (*mask)(unsigned int irq ) ;
   void (*mask_ack)(unsigned int irq ) ;
   void (*unmask)(unsigned int irq ) ;
   void (*eoi)(unsigned int irq ) ;
   void (*end)(unsigned int irq ) ;
   void (*set_affinity)(unsigned int irq , struct cpumask  const  *dest ) ;
   int (*retrigger)(unsigned int irq ) ;
   int (*set_type)(unsigned int irq , unsigned int flow_type ) ;
   int (*set_wake)(unsigned int irq , unsigned int on ) ;
   char const   *typename ;
};
#line 137
struct timer_rand_state;
#line 137
struct timer_rand_state;
#line 138
struct irq_2_iommu;
#line 138
struct irq_2_iommu;
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
struct irq_desc {
   unsigned int irq ;
   struct timer_rand_state *timer_rand_state ;
   unsigned int *kstat_irqs ;
   void (*handle_irq)(unsigned int irq , struct irq_desc *desc ) ;
   struct irq_chip *chip ;
   struct msi_desc *msi_desc ;
   void *handler_data ;
   void *chip_data ;
   struct irqaction *action ;
   unsigned int status ;
   unsigned int depth ;
   unsigned int wake_depth ;
   unsigned int irq_count ;
   unsigned long last_unhandled ;
   unsigned int irqs_unhandled ;
   spinlock_t lock ;
   cpumask_var_t affinity ;
   unsigned int cpu ;
   cpumask_var_t pending_mask ;
   atomic_t threads_active ;
   wait_queue_head_t wait_for_threads ;
   struct proc_dir_entry *dir ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
typedef struct irq_desc irq_desc_t;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/profile.h"
struct proc_dir_entry;
#line 17
struct pt_regs;
#line 18
struct notifier_block;
#line 34
enum profile_type {
    PROFILE_TASK_EXIT = 0,
    PROFILE_MUNMAP = 1
} ;
#line 65
struct task_struct;
#line 66
struct mm_struct;
#line 88
struct pt_regs;
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hw_irq.h"
typedef int vector_irq_t[256];
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hardirq.h"
struct __anonstruct_irq_cpustat_t_178 {
   unsigned int __softirq_pending ;
   unsigned int __nmi_count ;
   unsigned int irq0_irqs ;
   unsigned int apic_timer_irqs ;
   unsigned int irq_spurious_count ;
   unsigned int generic_irqs ;
   unsigned int irq_resched_count ;
   unsigned int irq_call_count ;
   unsigned int irq_tlb_count ;
   unsigned int irq_thermal_count ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hardirq.h"
typedef struct __anonstruct_irq_cpustat_t_178 irq_cpustat_t;
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hardirq.h"
struct task_struct;
#line 68 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
enum __anonenum_179 {
    IRQTF_RUNTHREAD = 0,
    IRQTF_DIED = 1,
    IRQTF_WARNED = 2
} ;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
typedef irqreturn_t (*irq_handler_t)(int  , void * );
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   unsigned long flags ;
   cpumask_t mask ;
   char const   *name ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   struct proc_dir_entry *dir ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
};
#line 145
struct device;
#line 331
enum __anonenum_180 {
    HI_SOFTIRQ = 0,
    TIMER_SOFTIRQ = 1,
    NET_TX_SOFTIRQ = 2,
    NET_RX_SOFTIRQ = 3,
    BLOCK_SOFTIRQ = 4,
    TASKLET_SOFTIRQ = 5,
    SCHED_SOFTIRQ = 6,
    HRTIMER_SOFTIRQ = 7,
    RCU_SOFTIRQ = 8,
    NR_SOFTIRQS = 9
} ;
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
struct softirq_action {
   void (*action)(struct softirq_action * ) ;
};
#line 409 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 425
enum __anonenum_181 {
    TASKLET_STATE_SCHED = 0,
    TASKLET_STATE_RUN = 1
} ;
#line 564
struct irq_desc;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 26
struct pci_dev;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
struct resource_list {
   struct resource_list *next ;
   struct resource *res ;
   struct pci_dev *dev ;
};
#line 165
struct device;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist_node;
#line 19
struct klist_node;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist_iter {
   struct klist *i_klist ;
   struct klist_node *i_cur ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/semaphore.h"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *acpi_handle ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device;
#line 31
struct device_private;
#line 31
struct device_private;
#line 32
struct device_driver;
#line 33
struct driver_private;
#line 33
struct driver_private;
#line 34
struct class;
#line 34
struct class;
#line 35
struct class_private;
#line 35
struct class_private;
#line 36
struct bus_type;
#line 36
struct bus_type;
#line 37
struct bus_type_private;
#line 37
struct bus_type_private;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
#line 52
struct driver_attribute;
#line 52
struct device_attribute;
#line 52 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
#line 103
struct notifier_block;
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
#line 156 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
#line 188
struct class_attribute;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
#line 208
struct device_type;
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class_dev_iter {
   struct klist_iter ki ;
   struct device_type  const  *type ;
};
#line 241 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
#line 255 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class_interface {
   struct list_head node ;
   struct class *class ;
   int (*add_dev)(struct device * , struct class_interface * ) ;
   void (*remove_dev)(struct device * , struct class_interface * ) ;
};
#line 288 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
#line 301 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 328 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
typedef void (*dr_release_t)(struct device *dev , void *res );
#line 329 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
typedef int (*dr_match_t)(struct device *dev , void *res , void *match_data );
#line 361 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 370
struct dma_coherent_mem;
#line 370 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct files_stat_struct {
   int nr_files ;
   int nr_free_files ;
   int max_files ;
};
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct inodes_stat_t {
   int nr_inodes ;
   int nr_unused ;
   int dummy[5] ;
};
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct nameidata;
#line 11
struct nameidata;
#line 12
struct path;
#line 13
struct vfsmount;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct dentry_stat_t {
   int nr_dentry ;
   int nr_unused ;
   int age_limit ;
   int want_pages ;
   int dummy[2] ;
};
#line 89
struct super_block;
#line 89
struct dentry_operations;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
union __anonunion_d_u_182 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_182 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[40] ;
};
#line 128
enum dentry_d_lock_class {
    DENTRY_D_LOCK_NORMAL = 0,
    DENTRY_D_LOCK_NESTED = 1
} ;
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
struct radix_tree_node;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fiemap.h"
struct fiemap {
   __u64 fm_start ;
   __u64 fm_length ;
   __u32 fm_flags ;
   __u32 fm_mapped_extents ;
   __u32 fm_extent_count ;
   __u32 fm_reserved ;
   struct fiemap_extent fm_extents[0] ;
};
#line 380 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct export_operations;
#line 380
struct export_operations;
#line 381
struct hd_geometry;
#line 381
struct hd_geometry;
#line 382
struct iovec;
#line 383
struct nameidata;
#line 384
struct kiocb;
#line 385
struct pipe_inode_info;
#line 386
struct poll_table_struct;
#line 386
struct poll_table_struct;
#line 387
struct kstatfs;
#line 387
struct kstatfs;
#line 388
struct vm_area_struct;
#line 389
struct vfsmount;
#line 390
struct cred;
#line 405
struct buffer_head;
#line 405
struct buffer_head;
#line 406 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef int get_block_t(struct inode *inode , sector_t iblock , struct buffer_head *bh_result ,
                        int create );
#line 408 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef void dio_iodone_t(struct kiocb *iocb , loff_t offset , ssize_t bytes , void *private );
#line 442 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
enum __anonenum_183 {
    QIF_BLIMITS_B = 0,
    QIF_SPACE_B = 1,
    QIF_ILIMITS_B = 2,
    QIF_INODES_B = 3,
    QIF_BTIME_B = 4,
    QIF_ITIME_B = 5
} ;
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 149
enum __anonenum_184 {
    QUOTA_NL_C_UNSPEC = 0,
    QUOTA_NL_C_WARNING = 1,
    __QUOTA_NL_C_MAX = 2
} ;
#line 156
enum __anonenum_185 {
    QUOTA_NL_A_UNSPEC = 0,
    QUOTA_NL_A_QTYPE = 1,
    QUOTA_NL_A_EXCESS_ID = 2,
    QUOTA_NL_A_WARNING = 3,
    QUOTA_NL_A_DEV_MAJOR = 4,
    QUOTA_NL_A_DEV_MINOR = 5,
    QUOTA_NL_A_CAUSED_ID = 6,
    __QUOTA_NL_A_MAX = 7
} ;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
typedef struct fs_disk_quota fs_disk_quota_t;
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
typedef struct fs_quota_stat fs_quota_stat_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
struct dquot;
#line 17
struct dquot;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
struct qtree_fmt_operations {
   void (*mem2disk_dqblk)(void *disk , struct dquot *dquot ) ;
   void (*disk2mem_dqblk)(struct dquot *dquot , void *disk ) ;
   int (*is_id)(void *disk , struct dquot *dquot ) ;
};
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
struct qtree_mem_dqinfo {
   struct super_block *dqi_sb ;
   int dqi_type ;
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
   unsigned int dqi_blocksize_bits ;
   unsigned int dqi_entry_size ;
   unsigned int dqi_usable_bs ;
   unsigned int dqi_qtree_depth ;
   struct qtree_fmt_operations *dqi_ops ;
};
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 183 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
typedef long long qsize_t;
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 212
struct quota_format_type;
#line 212
struct quota_format_type;
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 227
struct super_block;
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct dqstats {
   int lookups ;
   int drops ;
   int reads ;
   int writes ;
   int cache_hits ;
   int allocated_dquots ;
   int free_dquots ;
   int syncs ;
};
#line 264 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 284 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
#line 295 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   int (*reserve_space)(struct inode * , qsize_t  , int  ) ;
   int (*claim_space)(struct inode * , qsize_t  ) ;
   void (*release_rsv)(struct inode * , qsize_t  ) ;
   qsize_t (*get_reserved_space)(struct inode * ) ;
};
#line 321 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
#line 335 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 343
enum __anonenum_186 {
    _DQUOT_USAGE_ENABLED = 0,
    _DQUOT_LIMITS_ENABLED = 1,
    _DQUOT_SUSPENDED = 2,
    _DQUOT_STATE_FLAGS = 3
} ;
#line 379 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
#line 392 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_module_name {
   int qm_fmt_id ;
   char *qm_mod_name ;
};
#line 491 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
enum positive_aop_returns {
    AOP_WRITEPAGE_ACTIVATE = 524288,
    AOP_TRUNCATED_PAGE = 524289
} ;
#line 505
struct page;
#line 506
struct address_space;
#line 507
struct writeback_control;
#line 507
struct writeback_control;
#line 509 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct iov_iter {
   struct iovec  const  *iov ;
   unsigned long nr_segs ;
   size_t iov_offset ;
   size_t count ;
};
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion_arg_188 {
   char *buf ;
   void *data ;
};
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_187 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_188 arg ;
   int error ;
};
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_187 read_descriptor_t;
#line 560 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef int (*read_actor_t)(read_descriptor_t * , struct page * , unsigned long  ,
                            unsigned long  );
#line 563 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
#line 612
struct backing_dev_info;
#line 613 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 637
struct gendisk;
#line 637
struct hd_struct;
#line 637 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 713
struct dnotify_struct;
#line 713
struct cdev;
#line 713 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion____missing_field_name_189 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 713
struct file_lock;
#line 713
struct file_operations;
#line 713
struct inode_operations;
#line 713 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_189 __annonCompField21 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
#line 791
enum inode_i_mutex_lock_class {
    I_MUTEX_NORMAL = 0,
    I_MUTEX_PARENT = 1,
    I_MUTEX_CHILD = 2,
    I_MUTEX_XATTR = 3,
    I_MUTEX_QUOTA = 4
} ;
#line 865 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 876 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
#line 899 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion_f_u_190 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 899 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file {
   union __anonunion_f_u_190 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
};
#line 1018 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1020 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1025 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
#line 1036 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct lock_manager {
   struct list_head list ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
enum nfs_stat {
    NFS_OK = 0,
    NFSERR_PERM = 1,
    NFSERR_NOENT = 2,
    NFSERR_IO = 5,
    NFSERR_NXIO = 6,
    NFSERR_EAGAIN = 11,
    NFSERR_ACCES = 13,
    NFSERR_EXIST = 17,
    NFSERR_XDEV = 18,
    NFSERR_NODEV = 19,
    NFSERR_NOTDIR = 20,
    NFSERR_ISDIR = 21,
    NFSERR_INVAL = 22,
    NFSERR_FBIG = 27,
    NFSERR_NOSPC = 28,
    NFSERR_ROFS = 30,
    NFSERR_MLINK = 31,
    NFSERR_OPNOTSUPP = 45,
    NFSERR_NAMETOOLONG = 63,
    NFSERR_NOTEMPTY = 66,
    NFSERR_DQUOT = 69,
    NFSERR_STALE = 70,
    NFSERR_REMOTE = 71,
    NFSERR_WFLUSH = 99,
    NFSERR_BADHANDLE = 10001,
    NFSERR_NOT_SYNC = 10002,
    NFSERR_BAD_COOKIE = 10003,
    NFSERR_NOTSUPP = 10004,
    NFSERR_TOOSMALL = 10005,
    NFSERR_SERVERFAULT = 10006,
    NFSERR_BADTYPE = 10007,
    NFSERR_JUKEBOX = 10008,
    NFSERR_SAME = 10009,
    NFSERR_DENIED = 10010,
    NFSERR_EXPIRED = 10011,
    NFSERR_LOCKED = 10012,
    NFSERR_GRACE = 10013,
    NFSERR_FHEXPIRED = 10014,
    NFSERR_SHARE_DENIED = 10015,
    NFSERR_WRONGSEC = 10016,
    NFSERR_CLID_INUSE = 10017,
    NFSERR_RESOURCE = 10018,
    NFSERR_MOVED = 10019,
    NFSERR_NOFILEHANDLE = 10020,
    NFSERR_MINOR_VERS_MISMATCH = 10021,
    NFSERR_STALE_CLIENTID = 10022,
    NFSERR_STALE_STATEID = 10023,
    NFSERR_OLD_STATEID = 10024,
    NFSERR_BAD_STATEID = 10025,
    NFSERR_BAD_SEQID = 10026,
    NFSERR_NOT_SAME = 10027,
    NFSERR_LOCK_RANGE = 10028,
    NFSERR_SYMLINK = 10029,
    NFSERR_RESTOREFH = 10030,
    NFSERR_LEASE_MOVED = 10031,
    NFSERR_ATTRNOTSUPP = 10032,
    NFSERR_NO_GRACE = 10033,
    NFSERR_RECLAIM_BAD = 10034,
    NFSERR_RECLAIM_CONFLICT = 10035,
    NFSERR_BAD_XDR = 10036,
    NFSERR_LOCKS_HELD = 10037,
    NFSERR_OPENMODE = 10038,
    NFSERR_BADOWNER = 10039,
    NFSERR_BADCHAR = 10040,
    NFSERR_BADNAME = 10041,
    NFSERR_BAD_RANGE = 10042,
    NFSERR_LOCK_NOTSUPP = 10043,
    NFSERR_OP_ILLEGAL = 10044,
    NFSERR_DEADLOCK = 10045,
    NFSERR_FILE_OPEN = 10046,
    NFSERR_ADMIN_REVOKED = 10047,
    NFSERR_CB_PATH_DOWN = 10048
} ;
#line 116
enum nfs_ftype {
    NFNON = 0,
    NFREG = 1,
    NFDIR = 2,
    NFBLK = 3,
    NFCHR = 4,
    NFLNK = 5,
    NFSOCK = 6,
    NFBAD = 7,
    NFFIFO = 8
} ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sunrpc/msg_prot.h"
typedef u32 rpc_authflavor_t;
#line 20
enum rpc_auth_flavors {
    RPC_AUTH_NULL = 0,
    RPC_AUTH_UNIX = 1,
    RPC_AUTH_SHORT = 2,
    RPC_AUTH_DES = 3,
    RPC_AUTH_KRB = 4,
    RPC_AUTH_GSS = 6,
    RPC_AUTH_MAXFLAVOR = 8,
    RPC_AUTH_GSS_KRB5 = 390003,
    RPC_AUTH_GSS_KRB5I = 390004,
    RPC_AUTH_GSS_KRB5P = 390005,
    RPC_AUTH_GSS_LKEY = 390006,
    RPC_AUTH_GSS_LKEYI = 390007,
    RPC_AUTH_GSS_LKEYP = 390008,
    RPC_AUTH_GSS_SPKM = 390009,
    RPC_AUTH_GSS_SPKMI = 390010,
    RPC_AUTH_GSS_SPKMP = 390011
} ;
#line 43
enum rpc_msg_type {
    RPC_CALL = 0,
    RPC_REPLY = 1
} ;
#line 48
enum rpc_reply_stat {
    RPC_MSG_ACCEPTED = 0,
    RPC_MSG_DENIED = 1
} ;
#line 53
enum rpc_accept_stat {
    RPC_SUCCESS = 0,
    RPC_PROG_UNAVAIL = 1,
    RPC_PROG_MISMATCH = 2,
    RPC_PROC_UNAVAIL = 3,
    RPC_GARBAGE_ARGS = 4,
    RPC_SYSTEM_ERR = 5,
    RPC_DROP_REPLY = 60000
} ;
#line 64
enum rpc_reject_stat {
    RPC_MISMATCH = 0,
    RPC_AUTH_ERROR = 1
} ;
#line 69
enum rpc_auth_stat {
    RPC_AUTH_OK = 0,
    RPC_AUTH_BADCRED = 1,
    RPC_AUTH_REJECTEDCRED = 2,
    RPC_AUTH_BADVERF = 3,
    RPC_AUTH_REJECTEDVERF = 4,
    RPC_AUTH_TOOWEAK = 5,
    RPCSEC_GSS_CREDPROBLEM = 13,
    RPCSEC_GSS_CTXPROBLEM = 14
} ;
#line 102 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sunrpc/msg_prot.h"
typedef __be32 rpc_fraghdr;
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
struct nfs_fh {
   unsigned short size ;
   unsigned char data[128] ;
};
#line 164
enum nfs3_stable_how {
    NFS_UNSTABLE = 0,
    NFS_DATA_SYNC = 1,
    NFS_FILE_SYNC = 2
} ;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs_fs_i.h"
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1047 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct __anonstruct_afs_192 {
   struct list_head link ;
   int state ;
};
#line 1047 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion_fl_u_191 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_192 afs ;
};
#line 1047
struct fasync_struct;
#line 1047 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_191 fl_u ;
};
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __kernel_off_t l_start ;
   __kernel_off_t l_len ;
   __kernel_pid_t l_pid ;
};
#line 140 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __kernel_loff_t l_start ;
   __kernel_loff_t l_len ;
   __kernel_pid_t l_pid ;
};
#line 1271 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
#line 1306
struct mtd_info;
#line 1306
struct xattr_handler;
#line 1306
struct super_operations;
#line 1306
struct file_system_type;
#line 1306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
#line 1387
enum __anonenum_193 {
    SB_UNFROZEN = 0,
    SB_FREEZE_WRITE = 1,
    SB_FREEZE_TRANS = 2
} ;
#line 1432 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1470 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef int (*filldir_t)(void * , char const   * , int  , loff_t  , u64  , unsigned int  );
#line 1471
struct block_device_operations;
#line 1471
struct block_device_operations;
#line 1484 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
#line 1513 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
#line 1542
struct seq_file;
#line 1556 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
#line 1739 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
#line 2180
struct bio;
#line 2245
enum __anonenum_194 {
    DIO_LOCKING = 1,
    DIO_NO_LOCKING = 2,
    DIO_OWN_LOCKING = 3
} ;
#line 2349 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct tree_descr {
   char *name ;
   struct file_operations  const  *ops ;
   int mode ;
};
#line 2390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct simple_transaction_argresp {
   ssize_t size ;
   char data[0] ;
};
#line 2450
struct ctl_table;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_device;
#line 24
struct usb_device;
#line 25
struct usb_driver;
#line 25
struct usb_driver;
#line 26
struct wusb_dev;
#line 26
struct wusb_dev;
#line 45
struct ep_device;
#line 45
struct ep_device;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
};
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
   unsigned char *extra ;
   int extralen ;
};
#line 86
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned int is_active : 1 ;
   unsigned int sysfs_files_created : 1 ;
   unsigned int ep_devs_created : 1 ;
   unsigned int unregistering : 1 ;
   unsigned int needs_remote_wakeup : 1 ;
   unsigned int needs_altsetting0 : 1 ;
   unsigned int needs_binding : 1 ;
   unsigned int reset_running : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   int pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 220 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0] ;
};
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16] ;
   struct usb_interface *interface[32] ;
   struct usb_interface_cache *intf_cache[32] ;
   unsigned char *extra ;
   int extralen ;
};
#line 303 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[128UL / (8UL * sizeof(unsigned long ))] ;
};
#line 310
struct mon_bus;
#line 310 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 otg_port ;
   unsigned int is_b_host : 1 ;
   unsigned int b_hnp_enable : 1 ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   struct dentry *usbfs_dentry ;
   struct device *dev ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 360
struct usb_tt;
#line 360
struct usb_tt;
#line 428 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16] ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16] ;
   struct usb_host_endpoint *ep_out[16] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned int can_submit : 1 ;
   unsigned int discon_suspended : 1 ;
   unsigned int persist_enabled : 1 ;
   unsigned int have_langid : 1 ;
   unsigned int authorized : 1 ;
   unsigned int authenticated : 1 ;
   unsigned int wusb : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   struct dentry *usbfs_dentry ;
   int maxchild ;
   struct usb_device *children[31] ;
   int pm_usage_cnt ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   struct delayed_work autosuspend ;
   struct work_struct autoresume ;
   struct mutex pm_mutex ;
   unsigned long last_busy ;
   int autosuspend_delay ;
   unsigned long connect_time ;
   unsigned int auto_pm : 1 ;
   unsigned int do_remote_wakeup : 1 ;
   unsigned int reset_resume : 1 ;
   unsigned int autosuspend_disabled : 1 ;
   unsigned int autoresume_disabled : 1 ;
   unsigned int skip_sys_resume : 1 ;
   struct wusb_dev *wusb_dev ;
};
#line 762 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 767 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_dynid {
   struct list_head node ;
   struct usb_device_id id ;
};
#line 781 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 840 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface *intf , struct usb_device_id  const  *id ) ;
   void (*disconnect)(struct usb_interface *intf ) ;
   int (*ioctl)(struct usb_interface *intf , unsigned int code , void *buf ) ;
   int (*suspend)(struct usb_interface *intf , pm_message_t message ) ;
   int (*resume)(struct usb_interface *intf ) ;
   int (*reset_resume)(struct usb_interface *intf ) ;
   int (*pre_reset)(struct usb_interface *intf ) ;
   int (*post_reset)(struct usb_interface *intf ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned int no_dynamic_id : 1 ;
   unsigned int supports_autosuspend : 1 ;
   unsigned int soft_unbind : 1 ;
};
#line 887 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_device_driver {
   char const   *name ;
   int (*probe)(struct usb_device *udev ) ;
   void (*disconnect)(struct usb_device *udev ) ;
   int (*suspend)(struct usb_device *udev , pm_message_t message ) ;
   int (*resume)(struct usb_device *udev , pm_message_t message ) ;
   struct usbdrv_wrap drvwrap ;
   unsigned int supports_autosuspend : 1 ;
};
#line 913 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_class_driver {
   char *name ;
   struct file_operations  const  *fops ;
   int minor_base ;
};
#line 968 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 975
struct urb;
#line 975
struct urb;
#line 977 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned int poisoned : 1 ;
};
#line 991 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
typedef void (*usb_complete_t)(struct urb * );
#line 1160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0] ;
};
#line 1355
struct scatterlist;
#line 1355
struct scatterlist;
#line 1421 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_sg_request {
   int status ;
   size_t bytes ;
   spinlock_t lock ;
   struct usb_device *dev ;
   int pipe ;
   struct scatterlist *sg ;
   int nents ;
   int entries ;
   struct urb **urbs ;
   int count ;
   struct completion complete ;
};
#line 50 "usb-skeleton.c"
struct usb_skel {
   struct usb_device *udev ;
   struct usb_interface *interface ;
   struct semaphore limit_sem ;
   struct usb_anchor submitted ;
   unsigned char *bulk_in_buffer ;
   size_t bulk_in_size ;
   __u8 bulk_in_endpointAddr ;
   __u8 bulk_out_endpointAddr ;
   int errors ;
   int open_count ;
   spinlock_t err_lock ;
   struct kref kref ;
   struct mutex io_mutex ;
};
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cpufeature.h"
extern char const   * const  x86_cap_flags[288] ;
#line 172
extern char const   * const  x86_power_flags[32] ;
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/alternative.h"
extern void alternative_instructions(void) ;
#line 57
extern void apply_alternatives(struct alt_instr *start , struct alt_instr *end ) ;
#line 62
extern void alternatives_smp_module_add(struct module *mod , char *name , void *locks ,
                                        void *locks_end , void *text , void *text_end ) ;
#line 65
extern void alternatives_smp_module_del(struct module *mod ) ;
#line 66
extern void alternatives_smp_switch(int smp ) ;
#line 75
extern unsigned char const   * const  *find_nop_table(void) ;
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/alternative.h"
__inline static void apply_paravirt(struct paravirt_patch_site *start , struct paravirt_patch_site *end ) 
{ 

  {
#line 155
  return;
}
}
#line 160
extern void add_nops(void *insns , unsigned int len ) ;
#line 180
extern void *text_poke(void *addr , void const   *opcode , size_t len ) ;
#line 181
extern void *text_poke_early(void *addr , void const   *opcode , size_t len ) ;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 68
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 71
  return;
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 84
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 85
  return;
}
}
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 105
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 109
  return;
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 121
  __asm__  volatile   ("": : : "memory");
#line 122
  clear_bit((int )nr, addr);
  }
#line 123
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 127
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 128
  return;
}
}
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 144
  __asm__  volatile   ("": : : "memory");
#line 145
  __clear_bit((int )nr, addr);
  }
#line 146
  return;
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 162
  __asm__  volatile   ("btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 163
  return;
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 181
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 185
  return;
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 199
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 202
  return (oldbit);
}
}
#line 212 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit_lock(int nr , unsigned long volatile   *addr ) 
{ int tmp ;

  {
  {
#line 215
  tmp = test_and_set_bit(nr, addr);
  }
#line 215
  return (tmp);
}
}
#line 227 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 231
  __asm__  ("bts %2,%1\n\t"
            "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 235
  return (oldbit);
}
}
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 250
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 254
  return (oldbit);
}
}
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 270
  __asm__  volatile   ("btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 274
  return (oldbit);
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 282
  __asm__  volatile   ("btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 287
  return (oldbit);
}
}
#line 298 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 302
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 306
  return (oldbit);
}
}
#line 309 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 

  {
#line 311
  return (((1UL << nr % 32U) & *((unsigned long *)addr + nr / 32U)) != 0UL);
}
}
#line 315 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 319
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  }
#line 324
  return (oldbit);
}
}
#line 347 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long __ffs(unsigned long word ) 
{ 

  {
  {
#line 349
  __asm__  ("bsf %1,%0": "=r" (word): "rm" (word));
  }
#line 352
  return (word);
}
}
#line 361 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long ffz(unsigned long word ) 
{ 

  {
  {
#line 363
  __asm__  ("bsf %1,%0": "=r" (word): "r" (~ word));
  }
#line 366
  return (word);
}
}
#line 375 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long __fls(unsigned long word ) 
{ 

  {
  {
#line 377
  __asm__  ("bsr %1,%0": "=r" (word): "rm" (word));
  }
#line 380
  return (word);
}
}
#line 395 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ int r ;

  {
  {
#line 399
  __asm__  ("bsfl %1,%0\n\t"
            "cmovzl %2,%0": "=r" (r): "rm" (x), "r" (-1));
  }
#line 408
  return (r + 1);
}
}
#line 422 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ int r ;

  {
  {
#line 426
  __asm__  ("bsrl %1,%0\n\t"
            "cmovzl %2,%0": "=&r" (r): "rm" (x), "rm" (-1));
  }
#line 435
  return (r + 1);
}
}
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bitops/sched.h"
__inline static int sched_find_first_bit(unsigned long const   *b ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 19
  if (*(b + 0)) {
    {
#line 20
    tmp = __ffs((unsigned long )*(b + 0));
    }
#line 20
    return ((int )tmp);
  }
#line 21
  if (*(b + 1)) {
    {
#line 22
    tmp___0 = __ffs((unsigned long )*(b + 1));
    }
#line 22
    return ((int )(tmp___0 + 32UL));
  }
#line 23
  if (*(b + 2)) {
    {
#line 24
    tmp___1 = __ffs((unsigned long )*(b + 2));
    }
#line 24
    return ((int )(tmp___1 + 64UL));
  }
  {
#line 25
  tmp___2 = __ffs((unsigned long )*(b + 3));
  }
#line 25
  return ((int )(tmp___2 + 96UL));
}
}
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bitops/hweight.h"
extern unsigned int hweight32(unsigned int w ) ;
#line 7
extern unsigned int hweight16(unsigned int w ) ;
#line 8
extern unsigned int hweight8(unsigned int w ) ;
#line 9
extern unsigned long hweight64(__u64 w ) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bitops/fls64.h"
__inline static int fls64(__u64 x ) 
{ __u32 h ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 20
  h = (__u32 )(x >> 32);
  }
#line 21
  if (h) {
    {
#line 22
    tmp = fls((int )h);
    }
#line 22
    return (tmp + 32);
  }
  {
#line 23
  tmp___0 = fls((int )x);
  }
#line 23
  return (tmp___0);
}
}
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val )  __attribute__((__const__)) ;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 

  {
  {
#line 21
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
  }
#line 25
  return (val);
}
}
#line 29
__inline static __u64 __arch_swab64(__u64 val )  __attribute__((__const__)) ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 

  {
  {
#line 53
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
  }
#line 56
  return (val);
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u16 __fswab16(__u16 val )  __attribute__((__const__)) ;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 

  {
#line 51
  return ((unsigned short )((((int )val & 255) << 8) | (((int )val & 65280) >> 8)));
}
}
#line 55
__inline static __u32 __fswab32(__u32 val )  __attribute__((__const__)) ;
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ __u32 tmp ;

  {
  {
#line 58
  tmp = __arch_swab32(val);
  }
#line 58
  return (tmp);
}
}
#line 64
__inline static __u64 __fswab64(__u64 val )  __attribute__((__const__)) ;
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ __u64 tmp ;

  {
  {
#line 67
  tmp = __arch_swab64(val);
  }
#line 67
  return (tmp);
}
}
#line 77
__inline static __u32 __fswahw32(__u32 val )  __attribute__((__const__)) ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __fswahw32(__u32 val ) 
{ 

  {
#line 82
  return (((val & 65535U) << 16) | ((val & 4294901760U) >> 16));
}
}
#line 86
__inline static __u32 __fswahb32(__u32 val )  __attribute__((__const__)) ;
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __fswahb32(__u32 val ) 
{ 

  {
#line 91
  return (((val & 16711935U) << 8) | ((val & 4278255360U) >> 8));
}
}
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
#line 153
  tmp = __fswab16((unsigned short )*p);
  }
#line 153
  return ((unsigned short )((int )tmp));
}
}
#line 161 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 166
  tmp = __fswab32((unsigned int )*p);
  }
#line 166
  return (tmp);
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
#line 179
  tmp = __fswab64((unsigned long long )*p);
  }
#line 179
  return (tmp);
}
}
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __swahw32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 194
  tmp = __fswahw32((unsigned int )*p);
  }
#line 194
  return (tmp);
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __swahb32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 209
  tmp = __fswahb32((unsigned int )*p);
  }
#line 209
  return (tmp);
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swab16s(__u16 *p ) 
{ 

  {
  {
#line 222
  *p = __swab16p((__u16 const   *)p);
  }
#line 224
  return;
}
}
#line 229 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swab32s(__u32 *p ) 
{ 

  {
  {
#line 234
  *p = __swab32p((__u32 const   *)p);
  }
#line 236
  return;
}
}
#line 242 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swab64s(__u64 *p ) 
{ 

  {
  {
#line 247
  *p = __swab64p((__u64 const   *)p);
  }
#line 249
  return;
}
}
#line 257 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swahw32s(__u32 *p ) 
{ 

  {
  {
#line 262
  *p = __swahw32p((__u32 const   *)p);
  }
#line 264
  return;
}
}
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swahb32s(__u32 *p ) 
{ 

  {
  {
#line 277
  *p = __swahb32p((__u32 const   *)p);
  }
#line 279
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __le64 __cpu_to_le64p(__u64 const   *p ) 
{ 

  {
#line 45
  return ((unsigned long long )*p);
}
}
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 

  {
#line 49
  return ((unsigned long long )*p);
}
}
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __le32 __cpu_to_le32p(__u32 const   *p ) 
{ 

  {
#line 53
  return ((unsigned int )*p);
}
}
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 

  {
#line 57
  return ((unsigned int )*p);
}
}
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __le16 __cpu_to_le16p(__u16 const   *p ) 
{ 

  {
#line 61
  return ((unsigned short )*p);
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 

  {
#line 65
  return ((unsigned short )*p);
}
}
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __be64 __cpu_to_be64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
#line 69
  tmp = __swab64p(p);
  }
#line 69
  return (tmp);
}
}
#line 71 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ __u64 tmp ;

  {
  {
#line 73
  tmp = __swab64p((__u64 const   *)((__u64 *)p));
  }
#line 73
  return (tmp);
}
}
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __be32 __cpu_to_be32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 77
  tmp = __swab32p(p);
  }
#line 77
  return (tmp);
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 81
  tmp = __swab32p((__u32 const   *)((__u32 *)p));
  }
#line 81
  return (tmp);
}
}
#line 83 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __be16 __cpu_to_be16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
#line 85
  tmp = __swab16p(p);
  }
#line 85
  return (tmp);
}
}
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ __u16 tmp ;

  {
  {
#line 89
  tmp = __swab16p((__u16 const   *)((__u16 *)p));
  }
#line 89
  return (tmp);
}
}
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void le16_add_cpu(__le16 *var , u16 val ) 
{ 

  {
  {
#line 145
  *var = (unsigned short )((int )*var + (int )val);
  }
#line 146
  return;
}
}
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void le32_add_cpu(__le32 *var , u32 val ) 
{ 

  {
  {
#line 150
  *var += val;
  }
#line 151
  return;
}
}
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void le64_add_cpu(__le64 *var , u64 val ) 
{ 

  {
  {
#line 155
  *var += val;
  }
#line 156
  return;
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void be16_add_cpu(__be16 *var , u16 val ) 
{ __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;

  {
  {
#line 160
  tmp___2 = __fswab16(*var);
#line 160
  tmp___3 = __fswab16((unsigned short )((int )tmp___2 + (int )val));
#line 160
  *var = (unsigned short )((int )tmp___3);
  }
#line 161
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void be32_add_cpu(__be32 *var , u32 val ) 
{ __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
  {
#line 165
  tmp___4 = __fswab32(*var);
#line 165
  tmp___5 = __fswab32(tmp___4 + val);
#line 165
  *var = tmp___5;
  }
#line 166
  return;
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void be64_add_cpu(__be64 *var , u64 val ) 
{ __u64 tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;
  __u64 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;
  __u64 tmp___7 ;
  __u64 tmp___8 ;
  __u64 tmp___9 ;

  {
  {
#line 170
  tmp___8 = __fswab64(*var);
#line 170
  tmp___9 = __fswab64(tmp___8 + val);
#line 170
  *var = tmp___9;
  }
#line 171
  return;
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static int get_bitmask_order(unsigned int count ) 
{ int order ;

  {
  {
#line 29
  order = fls((int )count);
  }
#line 30
  return (order);
}
}
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static int get_count_order(unsigned int count ) 
{ int order ;
  int tmp ;

  {
  {
#line 37
  tmp = fls((int )count);
#line 37
  order = tmp - 1;
  }
#line 38
  if (count & (count - 1U)) {
    {
#line 39
    order ++;
    }
  }
#line 40
  return (order);
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w ) 
{ unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 45
  if (sizeof(w) == 4UL) {
    {
#line 45
    tmp = hweight32((unsigned int )w);
#line 45
    tmp___1 = (unsigned long )tmp;
    }
  } else {
    {
#line 45
    tmp___0 = hweight64((unsigned long long )w);
#line 45
    tmp___1 = tmp___0;
    }
  }
#line 45
  return (tmp___1);
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 

  {
#line 55
  return ((word << shift) | (word >> (32U - shift)));
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u32 ror32(__u32 word , unsigned int shift ) 
{ 

  {
#line 65
  return ((word >> shift) | (word << (32U - shift)));
}
}
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u16 rol16(__u16 word , unsigned int shift ) 
{ 

  {
#line 75
  return ((unsigned short )(((int )word << shift) | ((int )word >> (16U - shift))));
}
}
#line 83 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u16 ror16(__u16 word , unsigned int shift ) 
{ 

  {
#line 85
  return ((unsigned short )(((int )word >> shift) | ((int )word << (16U - shift))));
}
}
#line 93 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u8 rol8(__u8 word , unsigned int shift ) 
{ 

  {
#line 95
  return ((unsigned char )(((int )word << shift) | ((int )word >> (8U - shift))));
}
}
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u8 ror8(__u8 word , unsigned int shift ) 
{ 

  {
#line 105
  return ((unsigned char )(((int )word >> shift) | ((int )word << (8U - shift))));
}
}
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 110
  if (sizeof(l) == 4UL) {
    {
#line 111
    tmp = fls((int )l);
    }
#line 111
    return ((unsigned int )tmp);
  }
  {
#line 112
  tmp___0 = fls64((unsigned long long )l);
  }
#line 112
  return ((unsigned int )tmp___0);
}
}
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static unsigned long __ffs64(u64 word ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 126
  if ((unsigned long )((unsigned int )word) == 0UL) {
    {
#line 127
    tmp = __ffs((unsigned long )((unsigned int )(word >> 32)));
    }
#line 127
    return (tmp + 32UL);
  }
  {
#line 131
  tmp___0 = __ffs((unsigned long )word);
  }
#line 131
  return (tmp___0);
}
}
#line 144
extern unsigned long find_first_bit(unsigned long const   *addr , unsigned long size ) ;
#line 154
extern unsigned long find_first_zero_bit(unsigned long const   *addr , unsigned long size ) ;
#line 166
extern unsigned long find_last_bit(unsigned long const   *addr , unsigned long size ) ;
#line 178
extern unsigned long find_next_bit(unsigned long const   *addr , unsigned long size ,
                                   unsigned long offset ) ;
#line 188
extern unsigned long find_next_zero_bit(unsigned long const   *addr , unsigned long size ,
                                        unsigned long offset ) ;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
extern  __attribute__((__noreturn__)) int ____ilog2_NaN(void)  __attribute__((__const__)) ;
#line 31
__inline static int __ilog2_u32(u32 n )  __attribute__((__const__)) ;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ int tmp ;

  {
  {
#line 34
  tmp = fls((int )n);
  }
#line 34
  return (tmp - 1);
}
}
#line 39
__inline static int __ilog2_u64(u64 n )  __attribute__((__const__)) ;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static int __ilog2_u64(u64 n ) 
{ int tmp ;

  {
  {
#line 42
  tmp = fls64(n);
  }
#line 42
  return (tmp - 1);
}
}
#line 51
__inline static bool is_power_of_2(unsigned long n )  __attribute__((__const__)) ;
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static bool is_power_of_2(unsigned long n ) 
{ int tmp ;

  {
#line 54
  if (n != 0UL) {
#line 54
    if ((n & (n - 1UL)) == 0UL) {
      {
#line 54
      tmp = 1;
      }
    } else {
      {
#line 54
      tmp = 0;
      }
    }
  } else {
    {
#line 54
    tmp = 0;
    }
  }
#line 54
  return ((_Bool )tmp);
}
}
#line 60
__inline static unsigned long __roundup_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
#line 63
  tmp = fls_long(n - 1UL);
  }
#line 63
  return (1UL << tmp);
}
}
#line 69
__inline static unsigned long __rounddown_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static unsigned long __rounddown_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
#line 72
  tmp = fls_long(n);
  }
#line 72
  return (1UL << (tmp - 1U));
}
}
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ratelimit.h"
extern int __ratelimit(struct ratelimit_state *rs ) ;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dynamic_debug.h"
extern long long dynamic_debug_enabled ;
#line 9
extern long long dynamic_debug_enabled2 ;
#line 39
extern int ddebug_add_module(struct _ddebug *tab , unsigned int n , char const   *modname ) ;
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dynamic_debug.h"
__inline static int ddebug_remove_module(char *mod ) 
{ 

  {
#line 81
  return (0);
}
}
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bug.h"
extern void ( /* format attribute */  warn_slowpath_fmt)(char const   *file , int line ,
                                                         char const   *fmt  , ...) ;
#line 63
extern void warn_slowpath_null(char const   *file , int line ) ;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
extern char const   linux_banner[] ;
#line 24
extern char const   linux_proc_banner[] ;
#line 107
extern int console_printk[] ;
#line 119
extern int _cond_resched(void) ;
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void might_fault(void) 
{ 

  {
  {
#line 155
  while (1) {
    while_0_continue: /* CIL Label */ ;
    {
#line 155
    _cond_resched();
    }
    goto while_0_break;
  }
  while_0_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 159
extern struct atomic_notifier_head panic_notifier_list ;
#line 160
extern long (*panic_blink)(long time ) ;
#line 161
extern  __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *fmt 
                                                                            , ...) ;
#line 163
extern void oops_enter(void) ;
#line 164
extern void oops_exit(void) ;
#line 165
extern int oops_may_print(void) ;
#line 166
extern  __attribute__((__noreturn__)) void do_exit(long error_code ) ;
#line 168
extern  __attribute__((__noreturn__)) void complete_and_exit(struct completion * ,
                                                             long  ) ;
#line 170
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
#line 171
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 172
extern unsigned long long simple_strtoull(char const   * , char ** , unsigned int  ) ;
#line 173
extern long long simple_strtoll(char const   * , char ** , unsigned int  ) ;
#line 174
extern int strict_strtoul(char const   * , unsigned int  , unsigned long * ) ;
#line 175
extern int strict_strtol(char const   * , unsigned int  , long * ) ;
#line 176
extern int strict_strtoull(char const   * , unsigned int  , unsigned long long * ) ;
#line 177
extern int strict_strtoll(char const   * , unsigned int  , long long * ) ;
#line 178
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
#line 180
extern int ( /* format attribute */  vsprintf)(char *buf , char const   * , va_list  ) ;
#line 182
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
#line 184
extern int ( /* format attribute */  vsnprintf)(char *buf , size_t size , char const   *fmt ,
                                                va_list args ) ;
#line 186
extern int ( /* format attribute */  scnprintf)(char *buf , size_t size , char const   *fmt 
                                                , ...) ;
#line 188
extern int ( /* format attribute */  vscnprintf)(char *buf , size_t size , char const   *fmt ,
                                                 va_list args ) ;
#line 190
extern char *( /* format attribute */  kasprintf)(gfp_t gfp , char const   *fmt  , ...) ;
#line 192
extern char *kvasprintf(gfp_t gfp , char const   *fmt , va_list args ) ;
#line 194
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
#line 196
extern int ( /* format attribute */  vsscanf)(char const   * , char const   * , va_list  ) ;
#line 199
extern int get_option(char **str , int *pint ) ;
#line 200
extern char *get_options(char const   *str , int nints , int *ints ) ;
#line 201
extern unsigned long long memparse(char const   *ptr , char **retptr ) ;
#line 203
extern int core_kernel_text(unsigned long addr ) ;
#line 204
extern int __kernel_text_address(unsigned long addr ) ;
#line 205
extern int kernel_text_address(unsigned long addr ) ;
#line 206
extern int func_ptr_is_kernel_text(void *ptr ) ;
#line 209
extern struct pid *session_of_pgrp(struct pid *pgrp ) ;
#line 236
extern int ( /* format attribute */ __attribute__((__regparm__(0))) vprintk)(char const   *fmt ,
                                                                             va_list args ) ;
#line 238
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...) ;
#line 241
extern struct ratelimit_state printk_ratelimit_state ;
#line 242
extern int printk_ratelimit(void) ;
#line 243
extern bool printk_timed_ratelimit(unsigned long *caller_jiffies , unsigned int interval_msec ) ;
#line 258
extern void log_buf_kexec_setup(void) ;
#line 279
extern int printk_needs_cpu(int cpu ) ;
#line 280
extern void printk_tick(void) ;
#line 282
extern void ( /* format attribute */ __attribute__((__regparm__(0))) early_printk)(char const   *fmt 
                                                                                   , ...) ;
#line 285
extern unsigned long int_sqrt(unsigned long  ) ;
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void console_silent(void) 
{ 

  {
  {
#line 289
  console_printk[0] = 0;
  }
#line 290
  return;
}
}
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void console_verbose(void) 
{ 

  {
#line 294
  if (console_printk[0]) {
    {
#line 295
    console_printk[0] = 15;
    }
  }
#line 296
  return;
}
}
#line 298
extern void bust_spinlocks(int yes ) ;
#line 299
extern void wake_up_klogd(void) ;
#line 300
extern int oops_in_progress ;
#line 301
extern int panic_timeout ;
#line 302
extern int panic_on_oops ;
#line 303
extern int panic_on_unrecovered_nmi ;
#line 304
extern char const   *print_tainted(void) ;
#line 305
extern void add_taint(unsigned int flag ) ;
#line 306
extern int test_taint(unsigned int flag ) ;
#line 307
extern unsigned long get_taint(void) ;
#line 308
extern int root_mountflags ;
#line 311
extern enum system_states system_state ;
#line 332
extern void dump_stack(void) ;
#line 339
extern void hex_dump_to_buffer(void const   *buf , size_t len , int rowsize , int groupsize ,
                               char *linebuf , size_t linebuflen , bool ascii ) ;
#line 342
extern void print_hex_dump(char const   *level , char const   *prefix_str , int prefix_type ,
                           int rowsize , int groupsize , void const   *buf , size_t len ,
                           bool ascii ) ;
#line 345
extern void print_hex_dump_bytes(char const   *prefix_str , int prefix_type , void const   *buf ,
                                 size_t len ) ;
#line 348
extern char const   hex_asc[] ;
#line 352 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static char *pack_hex_byte(char *buf , u8 byte ) 
{ char *tmp ;
  char *tmp___0 ;

  {
  {
#line 354
  tmp = buf;
#line 354
  buf ++;
#line 354
  *tmp = (char )hex_asc[((int )byte & 240) >> 4];
#line 355
  tmp___0 = buf;
#line 355
  buf ++;
#line 355
  *tmp___0 = (char )hex_asc[(int )byte & 15];
  }
#line 356
  return (buf);
}
}
#line 423
extern void tracing_on(void) ;
#line 424
extern void tracing_off(void) ;
#line 426
extern void tracing_off_permanent(void) ;
#line 427
extern int tracing_is_on(void) ;
#line 435
extern void tracing_start(void) ;
#line 436
extern void tracing_stop(void) ;
#line 437
extern void ftrace_off_permanent(void) ;
#line 439
extern void ftrace_special(unsigned long arg1 , unsigned long arg2 , unsigned long arg3 ) ;
#line 442 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void ( /* format attribute */  ____trace_printk_check_format)(char const   *fmt 
                                                                              , ...) 
{ 

  {
#line 445
  return;
}
}
#line 482
extern int ( /* format attribute */  __trace_bprintk)(unsigned long ip , char const   *fmt 
                                                      , ...) ;
#line 486
extern int ( /* format attribute */  __trace_printk)(unsigned long ip , char const   *fmt 
                                                     , ...) ;
#line 507
extern int __ftrace_vbprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
#line 510
extern int __ftrace_vprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
#line 513
extern void ftrace_dump(void) ;
#line 652
extern int do_sysinfo(struct sysinfo *info ) ;
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
extern initcall_t __con_initcall_start[] ;
#line 136
extern initcall_t __con_initcall_end[] ;
#line 137
extern initcall_t __security_initcall_start[] ;
#line 137
extern initcall_t __security_initcall_end[] ;
#line 140
extern int do_one_initcall(int (*fn)(void) ) ;
#line 141
extern char boot_command_line[]  __attribute__((__section__(".init.data"))) ;
#line 142
extern char *saved_command_line ;
#line 143
extern unsigned int reset_devices ;
#line 146
extern void setup_arch(char ** ) ;
#line 147
extern void prepare_namespace(void) ;
#line 149
extern void (*late_time_init)(void) ;
#line 243
extern void parse_early_param(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 244
extern void parse_early_options(char *cmdline )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 52 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
extern long do_no_restart_syscall(struct restart_block *parm ) ;
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_32_types.h"
extern unsigned int __VMALLOC_RESERVE ;
#line 54
extern int sysctl_legacy_va_layout ;
#line 56
extern void find_low_pfn_range(void) ;
#line 57
extern unsigned long init_memory_mapping(unsigned long start , unsigned long end ) ;
#line 59
extern void initmem_init(unsigned long  , unsigned long  ) ;
#line 60
extern void free_initmem(void) ;
#line 61
extern void setup_bootmem_allocator(void) ;
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_types.h"
extern int page_is_ram(unsigned long pagenr ) ;
#line 44
extern int devmem_is_allowed(unsigned long pagenr ) ;
#line 46
extern unsigned long max_low_pfn_mapped ;
#line 47
extern unsigned long max_pfn_mapped ;
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/string.h"
extern char *strndup_user(char const   * , long  ) ;
#line 16
extern void *memdup_user(void const   * , size_t  ) ;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
extern char *strcpy(char *dest , char const   *src ) ;
#line 12
extern char *strncpy(char *dest , char const   *src , size_t count ) ;
#line 15
extern char *strcat(char *dest , char const   *src ) ;
#line 18
extern char *strncat(char *dest , char const   *src , size_t count ) ;
#line 21
extern int strcmp(char const   *cs , char const   *ct ) ;
#line 24
extern int strncmp(char const   *cs , char const   *ct , size_t count ) ;
#line 27
extern char *strchr(char const   *s , int c ) ;
#line 30
extern size_t strlen(char const   *s ) ;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__memcpy(void *to , void const   *from , size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  {
#line 35
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  }
#line 44
  return (to);
}
}
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__constant_memcpy(void *to , void const   *from , size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;

  {
#line 55
  if (! n) {
#line 56
    return (to);
  }
#line 59
  if ((int )n == 1) {
    goto switch_1_1;
  } else {
#line 62
    if ((int )n == 2) {
      goto switch_1_2;
    } else {
#line 65
      if ((int )n == 4) {
        goto switch_1_4;
      } else {
#line 69
        if ((int )n == 3) {
          goto switch_1_3;
        } else {
#line 73
          if ((int )n == 5) {
            goto switch_1_5;
          } else {
#line 77
            if ((int )n == 6) {
              goto switch_1_6;
            } else {
#line 81
              if ((int )n == 8) {
                goto switch_1_8;
              } else {
#line 58
                if (0) {
                  switch_1_1: /* CIL Label */ 
                  {
#line 60
                  *((char *)to) = *((char *)from);
                  }
#line 61
                  return (to);
                  switch_1_2: /* CIL Label */ 
                  {
#line 63
                  *((short *)to) = *((short *)from);
                  }
#line 64
                  return (to);
                  switch_1_4: /* CIL Label */ 
                  {
#line 66
                  *((int *)to) = *((int *)from);
                  }
#line 67
                  return (to);
                  switch_1_3: /* CIL Label */ 
                  {
#line 70
                  *((short *)to) = *((short *)from);
#line 71
                  *((char *)to + 2) = *((char *)from + 2);
                  }
#line 72
                  return (to);
                  switch_1_5: /* CIL Label */ 
                  {
#line 74
                  *((int *)to) = *((int *)from);
#line 75
                  *((char *)to + 4) = *((char *)from + 4);
                  }
#line 76
                  return (to);
                  switch_1_6: /* CIL Label */ 
                  {
#line 78
                  *((int *)to) = *((int *)from);
#line 79
                  *((short *)to + 2) = *((short *)from + 2);
                  }
#line 80
                  return (to);
                  switch_1_8: /* CIL Label */ 
                  {
#line 82
                  *((int *)to) = *((int *)from);
#line 83
                  *((int *)to + 1) = *((int *)from + 1);
                  }
#line 84
                  return (to);
                } else {
                  switch_1_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 87
  esi = (long )from;
#line 88
  edi = (long )to;
  }
#line 89
  if (n >= 20U) {
    {
#line 92
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n / 4U),
                         "1" (edi), "2" (esi): "memory");
    }
  } else {
#line 99
    if (n >= 16U) {
      {
#line 100
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
#line 104
    if (n >= 12U) {
      {
#line 105
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
#line 109
    if (n >= 8U) {
      {
#line 110
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
#line 114
    if (n >= 4U) {
      {
#line 115
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
  }
#line 122
  if ((int )(n % 4U) == 0) {
    goto switch_2_0;
  } else {
#line 124
    if ((int )(n % 4U) == 1) {
      goto switch_2_1;
    } else {
#line 130
      if ((int )(n % 4U) == 2) {
        goto switch_2_2;
      } else {
        {
        goto switch_2_default;
#line 120
        if (0) {
          switch_2_0: /* CIL Label */ 
#line 123
          return (to);
          switch_2_1: /* CIL Label */ 
          {
#line 125
          __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
#line 129
          return (to);
          switch_2_2: /* CIL Label */ 
          {
#line 131
          __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
#line 135
          return (to);
          switch_2_default: /* CIL Label */ 
          {
#line 137
          __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi),
                               "1" (esi): "memory");
          }
#line 141
          return (to);
        } else {
          switch_2_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 188
extern void *memmove(void *dest , void const   *src , size_t n ) ;
#line 193
extern void *memchr(void const   *cs , int c , size_t count ) ;
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__memset_generic(void *s , char c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
#line 198
  __asm__  volatile   ("rep\n\t"
                       "stosb": "=&c" (d0), "=&D" (d1): "a" (c), "1" (s), "0" (count): "memory");
  }
#line 203
  return (s);
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__constant_c_memset(void *s , unsigned long c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
#line 218
  __asm__  volatile   ("rep ; stosl\n\t"
                       "testb $2,%b3\n\t"
                       "je 1f\n\t"
                       "stosw\n"
                       "1:\ttestb $1,%b3\n\t"
                       "je 2f\n\t"
                       "stosb\n"
                       "2:": "=&c" (d0), "=&D" (d1): "a" (c), "q" (count), "0" (count / 4U),
                       "1" ((long )s): "memory");
  }
#line 229
  return (s);
}
}
#line 234
extern size_t strnlen(char const   *s , size_t count ) ;
#line 238
extern char *strstr(char const   *cs , char const   *ct ) ;
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__constant_c_and_count_memset(void *s , unsigned long pattern ,
                                                    size_t count ) 
{ int d0 ;
  int d1 ;
  unsigned long eax ;

  {
#line 249
  if ((int )count == 0) {
    goto switch_3_0;
  } else {
#line 251
    if ((int )count == 1) {
      goto switch_3_1;
    } else {
#line 254
      if ((int )count == 2) {
        goto switch_3_2;
      } else {
#line 257
        if ((int )count == 3) {
          goto switch_3_3;
        } else {
#line 261
          if ((int )count == 4) {
            goto switch_3_4;
          } else {
#line 248
            if (0) {
              switch_3_0: /* CIL Label */ 
#line 250
              return (s);
              switch_3_1: /* CIL Label */ 
              {
#line 252
              *((unsigned char *)s) = (unsigned char )(pattern & 255UL);
              }
#line 253
              return (s);
              switch_3_2: /* CIL Label */ 
              {
#line 255
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              }
#line 256
              return (s);
              switch_3_3: /* CIL Label */ 
              {
#line 258
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
#line 259
              *((unsigned char *)s + 2) = (unsigned char )(pattern & 255UL);
              }
#line 260
              return (s);
              switch_3_4: /* CIL Label */ 
              {
#line 262
              *((unsigned long *)s) = pattern;
              }
#line 263
              return (s);
            } else {
              switch_3_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 279
  eax = pattern;
  }
#line 283
  if ((int )(count % 4U) == 0) {
    goto switch_4_0;
  } else {
#line 286
    if ((int )(count % 4U) == 1) {
      goto switch_4_1;
    } else {
#line 289
      if ((int )(count % 4U) == 2) {
        goto switch_4_2;
      } else {
        {
        goto switch_4_default;
#line 282
        if (0) {
          switch_4_0: /* CIL Label */ 
          {
#line 284
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
#line 285
          return (s);
          switch_4_1: /* CIL Label */ 
          {
#line 287
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
#line 288
          return (s);
          switch_4_2: /* CIL Label */ 
          {
#line 290
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
#line 291
          return (s);
          switch_4_default: /* CIL Label */ 
          {
#line 293
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
#line 294
          return (s);
        } else {
          switch_4_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 322
extern void *memscan(void *addr , int c , size_t size ) ;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 39
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
#line 48
extern int strnicmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 51
extern int strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 54
extern int strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 60
extern char *strnchr(char const   * , size_t  , int  ) ;
#line 63
extern char *strrchr(char const   * , int  ) ;
#line 65
extern char *strstrip(char * ) ;
#line 76
extern char *strpbrk(char const   * , char const   * ) ;
#line 79
extern char *strsep(char ** , char const   * ) ;
#line 82
extern __kernel_size_t strspn(char const   * , char const   * ) ;
#line 85
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
#line 101
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
#line 107
extern char *kstrdup(char const   *s , gfp_t gfp ) ;
#line 108
extern char *kstrndup(char const   *s , size_t len , gfp_t gfp ) ;
#line 109
extern void *kmemdup(void const   *src , size_t len , gfp_t gfp ) ;
#line 111
extern char **argv_split(gfp_t gfp , char const   *str , int *argcp ) ;
#line 112
extern void argv_free(char **argv ) ;
#line 114
extern bool sysfs_streq(char const   *s1 , char const   *s2 ) ;
#line 117
extern int vbin_printf(u32 *bin_buf , size_t size , char const   *fmt , va_list args ) ;
#line 118
extern int bstr_printf(char *buf , size_t size , char const   *fmt , u32 const   *bin_buf ) ;
#line 119
extern int ( /* format attribute */  bprintf)(u32 *bin_buf , size_t size , char const   *fmt 
                                              , ...) ;
#line 122
extern ssize_t memory_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/string.h"
__inline static bool strstarts(char const   *str , char const   *prefix ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  {
#line 132
  tmp = strlen(prefix);
#line 132
  tmp___0 = strncmp(str, prefix, tmp);
  }
#line 132
  return ((_Bool )(tmp___0 == 0));
}
}
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_32.h"
__inline static void clear_page(void *page ) 
{ 

  {
  {
#line 41
  __constant_c_and_count_memset(page, 0UL, (unsigned int )(1UL << 12));
  }
#line 42
  return;
}
}
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_32.h"
__inline static void copy_page(void *to , void *from ) 
{ 

  {
  {
#line 46
  __constant_memcpy(to, (void const   *)from, (unsigned int )(1UL << 12));
  }
#line 47
  return;
}
}
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page.h"
__inline static void clear_user_page(void *page , unsigned long vaddr , struct page *pg ) 
{ 

  {
  {
#line 23
  clear_page(page);
  }
#line 24
  return;
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page.h"
__inline static void copy_user_page(void *to , void *from , unsigned long vaddr ,
                                    struct page *topage ) 
{ 

  {
  {
#line 29
  copy_page(to, from);
  }
#line 30
  return;
}
}
#line 53
extern bool __virt_addr_valid(unsigned long kaddr ) ;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/page.h"
__inline static int get_order(unsigned long size )  __attribute__((__const__)) ;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/page.h"
__inline static int get_order(unsigned long size ) 
{ int order ;

  {
  {
#line 13
  size = (size - 1UL) >> 11;
#line 14
  order = -1;
  }
  {
#line 15
  while (1) {
    while_5_continue: /* CIL Label */ ;
    {
#line 16
    size >>= 1;
#line 17
    order ++;
    }
#line 15
    if (! size) {
      goto while_5_break;
    }
  }
  while_5_break: /* CIL Label */ ;
  }
#line 19
  return (order);
}
}
#line 212 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/segment.h"
extern char const   early_idt_handlers[32][10] ;
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
extern unsigned long profile_pc(struct pt_regs *regs ) ;
#line 139
extern unsigned long convert_ip_to_linear(struct task_struct *child , struct pt_regs *regs ) ;
#line 141
extern void send_sigtrap(struct task_struct *tsk , struct pt_regs *regs , int error_code ,
                         int si_code ) ;
#line 143
extern void signal_fault(struct pt_regs *regs , void *frame , char *where ) ;
#line 145
extern long syscall_trace_enter(struct pt_regs * ) ;
#line 146
extern void syscall_trace_leave(struct pt_regs * ) ;
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long regs_return_value(struct pt_regs *regs ) 
{ 

  {
#line 150
  return (regs->ax);
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int user_mode(struct pt_regs *regs ) 
{ 

  {
#line 163
  return ((regs->cs & 3UL) == 3UL);
}
}
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int user_mode_vm(struct pt_regs *regs ) 
{ 

  {
#line 172
  return (((regs->cs & 3UL) | (regs->flags & 131072UL)) >= 3UL);
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int v8086_mode(struct pt_regs *regs ) 
{ 

  {
#line 182
  return ((int )(regs->flags & 131072UL));
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long kernel_stack_pointer(struct pt_regs *regs ) 
{ 

  {
#line 198
  return ((unsigned long )(& regs->sp));
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long instruction_pointer(struct pt_regs *regs ) 
{ 

  {
#line 206
  return (regs->ip);
}
}
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long frame_pointer(struct pt_regs *regs ) 
{ 

  {
#line 211
  return (regs->bp);
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long user_stack_pointer(struct pt_regs *regs ) 
{ 

  {
#line 216
  return (regs->sp);
}
}
#line 223
extern void user_enable_single_step(struct task_struct * ) ;
#line 224
extern void user_disable_single_step(struct task_struct * ) ;
#line 226
extern void user_enable_block_step(struct task_struct * ) ;
#line 234
extern int do_get_thread_area(struct task_struct *p , int idx , struct user_desc *info ) ;
#line 236
extern int do_set_thread_area(struct task_struct *p , int idx , struct user_desc *info ,
                              int can_allocate ) ;
#line 239
extern void x86_ptrace_untrace(struct task_struct * ) ;
#line 240
extern void x86_ptrace_fork(struct task_struct *child , unsigned long clone_flags ) ;
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
extern void handle_vm86_fault(struct kernel_vm86_regs * , long  ) ;
#line 188
extern int handle_vm86_trap(struct kernel_vm86_regs * , long  , int  ) ;
#line 189
extern struct pt_regs *save_v86_state(struct kernel_vm86_regs * ) ;
#line 192
extern void release_vm86_irqs(struct task_struct * ) ;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8] ;
#line 61
extern void setup_per_cpu_areas(void) ;
#line 156 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/percpu.h"
extern unsigned long per_cpu__this_cpu_off  __attribute__((__section__(".data.percpu"))) ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/current.h"
extern struct task_struct *per_cpu__current_task  __attribute__((__section__(".data.percpu"))) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ struct task_struct *ret__ ;

  {
#line 14
  if ((int )sizeof(per_cpu__current_task) == 1) {
    goto switch_6_1;
  } else {
#line 14
    if ((int )sizeof(per_cpu__current_task) == 2) {
      goto switch_6_2;
    } else {
#line 14
      if ((int )sizeof(per_cpu__current_task) == 4) {
        goto switch_6_4;
      } else {
#line 14
        if ((int )sizeof(per_cpu__current_task) == 8) {
          goto switch_6_8;
        } else {
          {
          goto switch_6_default;
#line 14
          if (0) {
            switch_6_1: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_6_break;
            switch_6_2: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_6_break;
            switch_6_4: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_6_break;
            switch_6_8: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_6_break;
            switch_6_default: /* CIL Label */ 
            {
#line 14
            __bad_percpu_size();
            }
          } else {
            switch_6_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
#line 14
  return (ret__);
}
}
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static void __set_64bit(unsigned long long *ptr , unsigned int low , unsigned int high ) 
{ 

  {
  {
#line 36
  __asm__  volatile   ("\n1:\t"
                       "movl (%0), %%eax\n\t"
                       "movl 4(%0), %%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b (%0)\n\t"
                       "jnz 1b": : "D" (ptr), "b" (low), "c" (high): "ax", "dx", "memory");
  }
#line 46
  return;
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static void __set_64bit_constant(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
#line 51
  __set_64bit(ptr, (unsigned int )value, (unsigned int )(value >> 32));
  }
#line 52
  return;
}
}
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static void __set_64bit_var(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
#line 60
  __set_64bit(ptr, *((unsigned int *)(& value) + 0), *((unsigned int *)(& value) + 1));
  }
#line 61
  return;
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __xchg(unsigned long x , void volatile   *ptr , int size ) 
{ 

  {
#line 83
  if (size == 1) {
    goto switch_7_1;
  } else {
#line 89
    if (size == 2) {
      goto switch_7_2;
    } else {
#line 95
      if (size == 4) {
        goto switch_7_4;
      } else {
#line 82
        if (0) {
          switch_7_1: /* CIL Label */ 
          {
#line 84
          __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_7_break;
          switch_7_2: /* CIL Label */ 
          {
#line 90
          __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_7_break;
          switch_7_4: /* CIL Label */ 
          {
#line 96
          __asm__  volatile   ("xchgl %0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_7_break;
        } else {
          switch_7_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 102
  return (x);
}
}
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __cmpxchg(void volatile   *ptr , unsigned long old ,
                                        unsigned long new , int size ) 
{ unsigned long prev ;

  {
#line 141
  if (size == 1) {
    goto switch_8_1;
  } else {
#line 147
    if (size == 2) {
      goto switch_8_2;
    } else {
#line 153
      if (size == 4) {
        goto switch_8_4;
      } else {
#line 140
        if (0) {
          switch_8_1: /* CIL Label */ 
          {
#line 142
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 146
          return (prev);
          switch_8_2: /* CIL Label */ 
          {
#line 148
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 152
          return (prev);
          switch_8_4: /* CIL Label */ 
          {
#line 154
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 158
          return (prev);
        } else {
          switch_8_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 160
  return (old);
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __sync_cmpxchg(void volatile   *ptr , unsigned long old ,
                                             unsigned long new , int size ) 
{ unsigned long prev ;

  {
#line 174
  if (size == 1) {
    goto switch_9_1;
  } else {
#line 180
    if (size == 2) {
      goto switch_9_2;
    } else {
#line 186
      if (size == 4) {
        goto switch_9_4;
      } else {
#line 173
        if (0) {
          switch_9_1: /* CIL Label */ 
          {
#line 175
          __asm__  volatile   ("lock; cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 179
          return (prev);
          switch_9_2: /* CIL Label */ 
          {
#line 181
          __asm__  volatile   ("lock; cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 185
          return (prev);
          switch_9_4: /* CIL Label */ 
          {
#line 187
          __asm__  volatile   ("lock; cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 191
          return (prev);
        } else {
          switch_9_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 193
  return (old);
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __cmpxchg_local(void volatile   *ptr , unsigned long old ,
                                              unsigned long new , int size ) 
{ unsigned long prev ;

  {
#line 202
  if (size == 1) {
    goto switch_10_1;
  } else {
#line 208
    if (size == 2) {
      goto switch_10_2;
    } else {
#line 214
      if (size == 4) {
        goto switch_10_4;
      } else {
#line 201
        if (0) {
          switch_10_1: /* CIL Label */ 
          {
#line 203
          __asm__  volatile   ("cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 207
          return (prev);
          switch_10_2: /* CIL Label */ 
          {
#line 209
          __asm__  volatile   ("cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 213
          return (prev);
          switch_10_4: /* CIL Label */ 
          {
#line 215
          __asm__  volatile   ("cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 219
          return (prev);
        } else {
          switch_10_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 221
  return (old);
}
}
#line 224 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long long __cmpxchg64(void volatile   *ptr , unsigned long long old ,
                                               unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
#line 229
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
#line 236
  return (prev);
}
}
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long long __cmpxchg64_local(void volatile   *ptr , unsigned long long old ,
                                                     unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
#line 244
  __asm__  volatile   ("cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
#line 251
  return (prev);
}
}
#line 313
extern unsigned long long cmpxchg_486_u64(void volatile   * , u64  , u64  ) ;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long native_save_fl(void) 
{ unsigned long flags ;

  {
  {
#line 21
  __asm__  volatile   ("# __raw_save_flags\n\t"
                       "pushf ; pop %0": "=r" (flags): : "memory");
  }
#line 27
  return (flags);
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_restore_fl(unsigned long flags ) 
{ 

  {
  {
#line 32
  __asm__  volatile   ("push %0 ; popf": : "g" (flags): "memory", "cc");
  }
#line 36
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_irq_disable(void) 
{ 

  {
  {
#line 40
  __asm__  volatile   ("cli": : : "memory");
  }
#line 41
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_irq_enable(void) 
{ 

  {
  {
#line 45
  __asm__  volatile   ("sti": : : "memory");
  }
#line 46
  return;
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_safe_halt(void) 
{ 

  {
  {
#line 50
  __asm__  volatile   ("sti; hlt": : : "memory");
  }
#line 51
  return;
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_halt(void) 
{ 

  {
  {
#line 55
  __asm__  volatile   ("hlt": : : "memory");
  }
#line 56
  return;
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long __raw_local_save_flags(void) 
{ unsigned long tmp ;

  {
  {
#line 67
  tmp = native_save_fl();
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_local_irq_restore(unsigned long flags ) 
{ 

  {
  {
#line 72
  native_restore_fl(flags);
  }
#line 73
  return;
}
}
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_local_irq_disable(void) 
{ 

  {
  {
#line 77
  native_irq_disable();
  }
#line 78
  return;
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_local_irq_enable(void) 
{ 

  {
  {
#line 82
  native_irq_enable();
  }
#line 83
  return;
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_safe_halt(void) 
{ 

  {
  {
#line 91
  native_safe_halt();
  }
#line 92
  return;
}
}
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void halt(void) 
{ 

  {
  {
#line 100
  native_halt();
  }
#line 101
  return;
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long __raw_local_irq_save(void) 
{ unsigned long flags ;
  unsigned long tmp ;

  {
  {
#line 108
  tmp = __raw_local_save_flags();
#line 108
  flags = tmp;
#line 110
  raw_local_irq_disable();
  }
#line 112
  return (flags);
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static int raw_irqs_disabled_flags(unsigned long flags ) 
{ 

  {
#line 165
  return (! (flags & 512UL));
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static int raw_irqs_disabled(void) 
{ unsigned long flags ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 170
  tmp = __raw_local_save_flags();
#line 170
  flags = tmp;
#line 172
  tmp___0 = raw_irqs_disabled_flags(flags);
  }
#line 172
  return (tmp___0);
}
}
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
extern struct task_struct *__switch_to(struct task_struct *prev , struct task_struct *next ) ;
#line 24
extern void __switch_to_xtra(struct task_struct *prev_p , struct task_struct *next_p ,
                             struct tss_struct *tss ) ;
#line 181
extern void native_load_gs_index(unsigned int  ) ;
#line 226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long get_limit(unsigned long segment ) 
{ unsigned long __limit ;

  {
  {
#line 229
  __asm__  ("lsll %1,%0": "=r" (__limit): "r" (segment));
  }
#line 230
  return (__limit + 1UL);
}
}
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_clts(void) 
{ 

  {
  {
#line 235
  __asm__  volatile   ("clts":);
  }
#line 236
  return;
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
static unsigned long __force_order  ;
#line 247 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr0(void) 
{ unsigned long val ;

  {
  {
#line 250
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 251
  return (val);
}
}
#line 254 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr0(unsigned long val ) 
{ 

  {
  {
#line 256
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order));
  }
#line 257
  return;
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr2(void) 
{ unsigned long val ;

  {
  {
#line 262
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 263
  return (val);
}
}
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr2(unsigned long val ) 
{ 

  {
  {
#line 268
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order));
  }
#line 269
  return;
}
}
#line 271 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr3(void) 
{ unsigned long val ;

  {
  {
#line 274
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 275
  return (val);
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr3(unsigned long val ) 
{ 

  {
  {
#line 280
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order));
  }
#line 281
  return;
}
}
#line 283 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr4(void) 
{ unsigned long val ;

  {
  {
#line 286
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 287
  return (val);
}
}
#line 290 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr4_safe(void) 
{ unsigned long val ;

  {
  {
#line 296
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order): "0" (0));
  }
#line 303
  return (val);
}
}
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr4(unsigned long val ) 
{ 

  {
  {
#line 308
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order));
  }
#line 309
  return;
}
}
#line 325 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_wbinvd(void) 
{ 

  {
  {
#line 327
  __asm__  volatile   ("wbinvd": : : "memory");
  }
#line 328
  return;
}
}
#line 358 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void clflush(void volatile   *__p ) 
{ 

  {
  {
#line 360
  __asm__  volatile   ("clflush %0": "+m" (*((char volatile   *)__p)));
  }
#line 361
  return;
}
}
#line 365
extern void disable_hlt(void) ;
#line 366
extern void enable_hlt(void) ;
#line 368
extern void cpu_idle_wait(void) ;
#line 370
extern unsigned long arch_align_stack(unsigned long sp ) ;
#line 371
extern void free_init_pages(char *what , unsigned long begin , unsigned long end ) ;
#line 373
extern void default_idle(void) ;
#line 375
extern void stop_this_cpu(void *dummy ) ;
#line 479 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void rdtsc_barrier(void) 
{ 

  {
  {
#line 481
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (113): "memory");
#line 482
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (114): "memory");
  }
#line 483
  return;
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_32_types.h"
extern bool __vmalloc_start_set ;
#line 186 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgd_t native_make_pgd(pgdval_t val ) 
{ pgd_t __constr_expr_0 ;

  {
  {
#line 188
  __constr_expr_0.pgd = val;
  }
#line 188
  return (__constr_expr_0);
}
}
#line 191 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t native_pgd_val(pgd_t pgd ) 
{ 

  {
#line 193
  return (pgd.pgd);
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t pgd_flags(pgd_t pgd ) 
{ pgdval_t tmp ;

  {
  {
#line 198
  tmp = native_pgd_val(pgd);
  }
#line 198
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static int pgd_none(pgd_t pgd ) 
{ 

  {
#line 25
  return (0);
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static int pgd_bad(pgd_t pgd ) 
{ 

  {
#line 26
  return (0);
}
}
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static int pgd_present(pgd_t pgd ) 
{ 

  {
#line 27
  return (1);
}
}
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static void pgd_clear(pgd_t *pgd ) 
{ 

  {
#line 28
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address ) 
{ 

  {
#line 40
  return ((pud_t *)pgd);
}
}
#line 216 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t native_pud_val(pud_t pud ) 
{ pgdval_t tmp ;

  {
  {
#line 218
  tmp = native_pgd_val(pud.pgd);
  }
#line 218
  return (tmp);
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static int pud_none(pud_t pud ) 
{ 

  {
#line 29
  return (0);
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static int pud_bad(pud_t pud ) 
{ 

  {
#line 30
  return (0);
}
}
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static int pud_present(pud_t pud ) 
{ 

  {
#line 31
  return (1);
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static void pud_clear(pud_t *pud ) 
{ 

  {
#line 32
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address ) 
{ 

  {
#line 45
  return ((pmd_t *)pud);
}
}
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static void pmd_free(struct mm_struct *mm , pmd_t *pmd ) 
{ 

  {
#line 61
  return;
}
}
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t native_pmd_val(pmd_t pmd ) 
{ pgdval_t tmp ;

  {
  {
#line 239
  tmp = native_pgd_val(pmd.pud.pgd);
  }
#line 239
  return (tmp);
}
}
#line 243 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t pud_flags(pud_t pud ) 
{ pudval_t tmp ;

  {
  {
#line 245
  tmp = native_pud_val(pud);
  }
#line 245
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 248 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t pmd_flags(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
#line 250
  tmp = native_pmd_val(pmd);
  }
#line 250
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pte_t native_make_pte(pteval_t val ) 
{ pte_t __constr_expr_0 ;

  {
  {
#line 255
  __constr_expr_0.pte = val;
  }
#line 255
  return (__constr_expr_0);
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t native_pte_val(pte_t pte ) 
{ 

  {
#line 260
  return (pte.pte);
}
}
#line 263 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t pte_flags(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 265
  tmp = native_pte_val(pte);
  }
#line 265
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 274
extern pteval_t __supported_pte_mask ;
#line 275
extern int nx_enabled ;
#line 276
extern void set_nx(void) ;
#line 279
extern pgprot_t pgprot_writecombine(pgprot_t prot ) ;
#line 286
extern pgprot_t phys_mem_access_prot(struct file *file , unsigned long pfn , unsigned long size ,
                                     pgprot_t vma_prot ) ;
#line 288
extern int phys_mem_access_prot_allowed(struct file *file , unsigned long pfn , unsigned long size ,
                                        pgprot_t *vma_prot ) ;
#line 292
extern void set_pte_vaddr(unsigned long vaddr , pte_t pte ) ;
#line 295
extern void native_pagetable_setup_start(pgd_t *base ) ;
#line 296
extern void native_pagetable_setup_done(pgd_t *base ) ;
#line 303
extern void arch_report_meminfo(struct seq_file *m ) ;
#line 314
extern void update_page_count(int level , unsigned long pages ) ;
#line 325
extern pte_t *lookup_address(unsigned long address , unsigned int *level ) ;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_tscp(unsigned int *aux ) 
{ unsigned long low ;
  unsigned long high ;

  {
  {
#line 19
  __asm__  volatile   (".byte 0x0f,0x01,0xf9": "=a" (low), "=d" (high), "=c" (*aux));
  }
#line 21
  return ((unsigned long long )low | ((unsigned long long )high << 32));
}
}
#line 42 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr(unsigned int msr ) 
{ unsigned long long val ;

  {
  {
#line 46
  __asm__  volatile   ("rdmsr": "=A" (val): "c" (msr));
  }
#line 47
  return (val);
}
}
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
#line 55
  __asm__  volatile   ("2: rdmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=r" (*err), "=A" (val): "c" (msr), [fault] "i" (-14));
  }
#line 63
  return (val);
}
}
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr_amd_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
#line 71
  __asm__  volatile   ("2: rdmsr ; xor %0,%0\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %3,%0 ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": "=r" (*err), "=A" (val): "c" (msr), "D" (2623152186U),
                       "i" (-14));
  }
#line 79
  return (val);
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static void native_write_msr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
#line 85
  __asm__  volatile   ("wrmsr": : "c" (msr), "a" (low), "d" (high): "memory");
  }
#line 86
  return;
}
}
#line 89
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int err ;

  {
  {
#line 93
  __asm__  volatile   ("2: wrmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=a" (err): "c" (msr), "0" (low), "d" (high),
                       [fault] "i" (-14): "memory");
  }
#line 103
  return (err);
}
}
#line 106
extern unsigned long long native_read_tsc(void) ;
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long __native_read_tsc(void) 
{ unsigned long long val ;

  {
  {
#line 112
  __asm__  volatile   ("rdtsc": "=A" (val));
  }
#line 114
  return (val);
}
}
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_pmc(int counter ) 
{ unsigned long long val ;

  {
  {
#line 121
  __asm__  volatile   ("rdpmc": "=A" (val): "c" (counter));
  }
#line 122
  return (val);
}
}
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static void wrmsr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
#line 144
  native_write_msr(msr, low, high);
  }
#line 145
  return;
}
}
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int wrmsr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int tmp ;

  {
  {
#line 156
  tmp = native_write_msr_safe(msr, low, high);
  }
#line 156
  return (tmp);
}
}
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int rdmsrl_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
#line 173
  *p = native_read_msr_safe(msr, & err);
  }
#line 174
  return (err);
}
}
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int rdmsrl_amd_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
#line 180
  *p = native_read_msr_amd_safe(msr, & err);
  }
#line 181
  return (err);
}
}
#line 217
extern int rdmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
#line 218
extern int wrmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
#line 219
extern int rdmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
#line 220
extern int wrmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 

  {
#line 24
  return ((void *)error);
}
}
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
#line 29
  return ((long )ptr);
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
  {
#line 34
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 0xfffff001UL))), 0L);
  }
#line 34
  return (tmp);
}
}
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static void *ERR_CAST(void const   *ptr ) 
{ 

  {
#line 47
  return ((void *)ptr);
}
}
#line 264 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored )  __attribute__((__section__(".cpuinit.text"))) ;
#line 264 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored ) 
{ 

  {
#line 264
  return;
}
}
#line 265 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_switch_to(struct task_struct *prev , struct task_struct *next ) 
{ 

  {
#line 266
  return;
}
}
#line 267 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_copy_thread(struct task_struct *tsk , struct task_struct *father ) 
{ 

  {
#line 268
  return;
}
}
#line 269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_exit_thread(struct task_struct *tsk ) 
{ 

  {
#line 269
  return;
}
}
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
extern int register_exec_domain(struct exec_domain * ) ;
#line 14
extern int unregister_exec_domain(struct exec_domain * ) ;
#line 15
extern int __set_personality(unsigned long  ) ;
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
extern int __bitmap_empty(unsigned long const   *bitmap , int bits ) ;
#line 88
extern int __bitmap_full(unsigned long const   *bitmap , int bits ) ;
#line 89
extern int __bitmap_equal(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                          int bits ) ;
#line 91
extern void __bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                int bits ) ;
#line 93
extern void __bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                 int shift , int bits ) ;
#line 95
extern void __bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                int shift , int bits ) ;
#line 97
extern int __bitmap_and(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
#line 99
extern void __bitmap_or(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
#line 101
extern void __bitmap_xor(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
#line 103
extern int __bitmap_andnot(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
#line 105
extern int __bitmap_intersects(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                               int bits ) ;
#line 107
extern int __bitmap_subset(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
#line 109
extern int __bitmap_weight(unsigned long const   *bitmap , int bits ) ;
#line 111
extern int bitmap_scnprintf(char *buf , unsigned int len , unsigned long const   *src ,
                            int nbits ) ;
#line 113
extern int __bitmap_parse(char const   *buf , unsigned int buflen , int is_user ,
                          unsigned long *dst , int nbits ) ;
#line 115
extern int bitmap_parse_user(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                             int nbits ) ;
#line 117
extern int bitmap_scnlistprintf(char *buf , unsigned int len , unsigned long const   *src ,
                                int nbits ) ;
#line 119
extern int bitmap_parselist(char const   *buf , unsigned long *maskp , int nmaskbits ) ;
#line 121
extern void bitmap_remap(unsigned long *dst , unsigned long const   *src , unsigned long const   *old ,
                         unsigned long const   *new , int bits ) ;
#line 123
extern int bitmap_bitremap(int oldbit , unsigned long const   *old , unsigned long const   *new ,
                           int bits ) ;
#line 125
extern void bitmap_onto(unsigned long *dst , unsigned long const   *orig , unsigned long const   *relmap ,
                        int bits ) ;
#line 127
extern void bitmap_fold(unsigned long *dst , unsigned long const   *orig , int sz ,
                        int bits ) ;
#line 129
extern int bitmap_find_free_region(unsigned long *bitmap , int bits , int order ) ;
#line 130
extern void bitmap_release_region(unsigned long *bitmap , int pos , int order ) ;
#line 131
extern int bitmap_allocate_region(unsigned long *bitmap , int pos , int order ) ;
#line 132
extern void bitmap_copy_le(void *dst , unsigned long const   *src , int nbits ) ;
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ int len ;

  {
  {
#line 148
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
#line 149
  __constant_c_memset((void *)dst, 0UL, (unsigned int )len);
  }
#line 151
  return;
}
}
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_fill(unsigned long *dst , int nbits ) 
{ size_t nlongs ;
  int len ;

  {
  {
#line 155
  nlongs = (size_t )((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long )));
#line 157
  len = (int )((unsigned long )(nlongs - 1U) * sizeof(unsigned long ));
#line 158
  __constant_c_memset((void *)dst, 4294967295UL, (unsigned int )len);
  }
#line 160
  if (nbits % 32) {
    {
#line 160
    *(dst + (nlongs - 1U)) = (1UL << nbits % 32) - 1UL;
    }
  } else {
    {
#line 160
    *(dst + (nlongs - 1U)) = ~ 0UL;
    }
  }
#line 161
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
                                 int nbits ) 
{ int len ;

  {
  {
#line 169
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
#line 170
  __memcpy((void *)dst, (void const   *)src, (unsigned int )len);
  }
#line 172
  return;
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_and(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 179
  tmp___0 = __bitmap_and(dst, src1, src2, nbits);
  }
#line 179
  return (tmp___0);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_or(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
#line 188
  __bitmap_or(dst, src1, src2, nbits);
  }
#line 189
  return;
}
}
#line 191 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_xor(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
#line 197
  __bitmap_xor(dst, src1, src2, nbits);
  }
#line 198
  return;
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_andnot(unsigned long *dst , unsigned long const   *src1 ,
                                  unsigned long const   *src2 , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 205
  tmp___0 = __bitmap_andnot(dst, src1, src2, nbits);
  }
#line 205
  return (tmp___0);
}
}
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                       int nbits ) 
{ unsigned long tmp ;

  {
  {
#line 214
  __bitmap_complement(dst, src, nbits);
  }
#line 215
  return;
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
                                 int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 223
  tmp___1 = __bitmap_equal(src1, src2, nbits);
  }
#line 223
  return (tmp___1);
}
}
#line 226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_intersects(unsigned long const   *src1 , unsigned long const   *src2 ,
                                      int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 232
  tmp___0 = __bitmap_intersects(src1, src2, nbits);
  }
#line 232
  return (tmp___0);
}
}
#line 235 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_subset(unsigned long const   *src1 , unsigned long const   *src2 ,
                                  int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 241
  tmp___1 = __bitmap_subset(src1, src2, nbits);
  }
#line 241
  return (tmp___1);
}
}
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_empty(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 249
  tmp___1 = __bitmap_empty(src, nbits);
  }
#line 249
  return (tmp___1);
}
}
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_full(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 257
  tmp___1 = __bitmap_full(src, nbits);
  }
#line 257
  return (tmp___1);
}
}
#line 260 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 264
  tmp___1 = __bitmap_weight(src, nbits);
  }
#line 264
  return (tmp___1);
}
}
#line 267 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                        int n , int nbits ) 
{ 

  {
  {
#line 273
  __bitmap_shift_right(dst, src, n, nbits);
  }
#line 274
  return;
}
}
#line 276 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                       int n , int nbits ) 
{ unsigned long tmp ;

  {
  {
#line 282
  __bitmap_shift_left(dst, src, n, nbits);
  }
#line 283
  return;
}
}
#line 285 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
                                 int nmaskbits ) 
{ int tmp ;

  {
  {
#line 288
  tmp = __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
  }
#line 288
  return (tmp);
}
}
#line 145 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
extern cpumask_t _unused_cpumask_arg_ ;
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpu_set(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
#line 151
  set_bit((unsigned int )cpu, (unsigned long volatile   *)(dstp->bits));
  }
#line 152
  return;
}
}
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpu_clear(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
#line 157
  clear_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  }
#line 158
  return;
}
}
#line 161 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_setall(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
#line 163
  bitmap_fill(dstp->bits, nbits);
  }
#line 164
  return;
}
}
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_clear(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
#line 169
  bitmap_zero(dstp->bits, nbits);
  }
#line 170
  return;
}
}
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpu_test_and_set(int cpu , cpumask_t *addr ) 
{ int tmp ;

  {
  {
#line 178
  tmp = test_and_set_bit(cpu, (unsigned long volatile   *)(addr->bits));
  }
#line 178
  return (tmp);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_and(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ int tmp ;

  {
  {
#line 185
  tmp = bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                   nbits);
  }
#line 185
  return (tmp);
}
}
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_or(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ 

  {
  {
#line 192
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
#line 193
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_xor(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
#line 199
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
#line 200
  return;
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_andnot(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
#line 207
  tmp = bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
#line 207
  return (tmp);
}
}
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_complement(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int nbits ) 
{ 

  {
  {
#line 214
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
#line 215
  return;
}
}
#line 218 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_equal(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                 int nbits ) 
{ int tmp ;

  {
  {
#line 221
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
#line 221
  return (tmp);
}
}
#line 225 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_intersects(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                      int nbits ) 
{ int tmp ;

  {
  {
#line 228
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
#line 228
  return (tmp);
}
}
#line 232 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_subset(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
#line 235
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
#line 235
  return (tmp);
}
}
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_empty(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 241
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
#line 241
  return (tmp);
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_full(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 247
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
#line 247
  return (tmp);
}
}
#line 251 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_weight(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 253
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
#line 253
  return (tmp);
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_shift_right(cpumask_t *dstp , cpumask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
#line 261
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 262
  return;
}
}
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_shift_left(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int n , int nbits ) 
{ 

  {
  {
#line 269
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 270
  return;
}
}
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __check_is_bitmap(unsigned long const   *bitmap ) 
{ 

  {
#line 289
  return (1);
}
}
#line 299
extern unsigned long const   cpu_bit_bitmap[33][((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static struct cpumask  const  *get_cpu_mask(unsigned int cpu ) 
{ unsigned long const   *p ;
  int tmp ;

  {
  {
#line 304
  p = cpu_bit_bitmap[1U + cpu % 32U];
#line 305
  p -= cpu / 32U;
  }
#line 306
  return ((struct cpumask  const  *)((struct cpumask *)p));
}
}
#line 366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpu_remap(int oldbit , cpumask_t const   *oldp , cpumask_t const   *newp ,
                                int nbits ) 
{ int tmp ;

  {
  {
#line 369
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
#line 369
  return (tmp);
}
}
#line 374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_remap(cpumask_t *dstp , cpumask_t const   *srcp , cpumask_t const   *oldp ,
                                  cpumask_t const   *newp , int nbits ) 
{ 

  {
  {
#line 377
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
#line 378
  return;
}
}
#line 382 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_onto(cpumask_t *dstp , cpumask_t const   *origp , cpumask_t const   *relmapp ,
                                 int nbits ) 
{ 

  {
  {
#line 385
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
#line 386
  return;
}
}
#line 390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_fold(cpumask_t *dstp , cpumask_t const   *origp , int sz ,
                                 int nbits ) 
{ 

  {
  {
#line 393
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
#line 394
  return;
}
}
#line 409
extern int nr_cpu_ids ;
#line 411
extern int __first_cpu(cpumask_t const   *srcp ) ;
#line 412
extern int __next_cpu(int n , cpumask_t const   *srcp ) ;
#line 413
extern int __any_online_cpu(cpumask_t const   *mask ) ;
#line 485
extern struct cpumask  const  * const  cpu_possible_mask ;
#line 486
extern struct cpumask  const  * const  cpu_online_mask ;
#line 487
extern struct cpumask  const  * const  cpu_present_mask ;
#line 488
extern struct cpumask  const  * const  cpu_active_mask ;
#line 544 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 

  {
#line 549
  return (cpu);
}
}
#line 595 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_first(struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  {
#line 597
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 8UL);
  }
#line 597
  return ((unsigned int )tmp);
}
}
#line 607 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
#line 610
  if (n != -1) {
    {
#line 611
    cpumask_check((unsigned int )n);
    }
  }
  {
#line 612
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
#line 612
  return ((unsigned int )tmp);
}
}
#line 622 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_next_zero(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
#line 625
  if (n != -1) {
    {
#line 626
    cpumask_check((unsigned int )n);
    }
  }
  {
#line 627
  tmp = find_next_zero_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
#line 627
  return ((unsigned int )tmp);
}
}
#line 630
extern int cpumask_next_and(int n , struct cpumask  const  * , struct cpumask  const  * ) ;
#line 631
extern int cpumask_any_but(struct cpumask  const  *mask , unsigned int cpu ) ;
#line 680 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
#line 682
  tmp = cpumask_check(cpu);
#line 682
  set_bit(tmp, (unsigned long volatile   *)(dstp->bits));
  }
#line 683
  return;
}
}
#line 690 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_clear_cpu(int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
#line 692
  tmp = cpumask_check((unsigned int )cpu);
#line 692
  clear_bit((int )tmp, (unsigned long volatile   *)(dstp->bits));
  }
#line 693
  return;
}
}
#line 712 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_test_and_set_cpu(int cpu , struct cpumask *cpumask ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 714
  tmp = cpumask_check((unsigned int )cpu);
#line 714
  tmp___0 = test_and_set_bit((int )tmp, (unsigned long volatile   *)(cpumask->bits));
  }
#line 714
  return (tmp___0);
}
}
#line 721 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_setall(struct cpumask *dstp ) 
{ 

  {
  {
#line 723
  bitmap_fill(dstp->bits, 8);
  }
#line 724
  return;
}
}
#line 730 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_clear(struct cpumask *dstp ) 
{ 

  {
  {
#line 732
  bitmap_zero(dstp->bits, 8);
  }
#line 733
  return;
}
}
#line 741 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_and(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 745
  tmp = bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                   8);
  }
#line 745
  return (tmp);
}
}
#line 755 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_or(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ 

  {
  {
#line 758
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            8);
  }
#line 760
  return;
}
}
#line 768 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_xor(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p ) 
{ 

  {
  {
#line 772
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             8);
  }
#line 774
  return;
}
}
#line 782 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_andnot(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                   struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 786
  tmp = bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      8);
  }
#line 786
  return (tmp);
}
}
#line 795 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_complement(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
#line 798
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
#line 800
  return;
}
}
#line 807 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 810
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     8);
  }
#line 810
  return ((_Bool )tmp);
}
}
#line 819 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_intersects(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 822
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          8);
  }
#line 822
  return ((_Bool )tmp);
}
}
#line 831 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_subset(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 834
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      8);
  }
#line 834
  return (tmp);
}
}
#line 842 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_empty(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 844
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), 8);
  }
#line 844
  return ((_Bool )tmp);
}
}
#line 851 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_full(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 853
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), 8);
  }
#line 853
  return ((_Bool )tmp);
}
}
#line 860 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 862
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), 8);
  }
#line 862
  return ((unsigned int )tmp);
}
}
#line 871 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_shift_right(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                         int n ) 
{ 

  {
  {
#line 874
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
#line 876
  return;
}
}
#line 884 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_shift_left(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                        int n ) 
{ 

  {
  {
#line 887
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
#line 889
  return;
}
}
#line 896 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
#line 899
  bitmap_copy(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
#line 900
  return;
}
}
#line 943 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 946
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         8);
  }
#line 946
  return (tmp);
}
}
#line 957 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_parse_user(char const   *buf , int len , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
#line 960
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, 8);
  }
#line 960
  return (tmp);
}
}
#line 972 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpulist_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 975
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             8);
  }
#line 975
  return (tmp);
}
}
#line 987 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpulist_parse(char const   *buf , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
#line 989
  tmp = bitmap_parselist(buf, dstp->bits, 8);
  }
#line 989
  return (tmp);
}
}
#line 997 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static size_t cpumask_size(void) 
{ 

  {
#line 1001
  return ((unsigned int )((((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long )));
}
}
#line 1034 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool alloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
#line 1036
  return ((_Bool)1);
}
}
#line 1039 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool alloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
#line 1042
  return ((_Bool)1);
}
}
#line 1045 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool zalloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
  {
#line 1047
  cpumask_clear(*mask);
  }
#line 1048
  return ((_Bool)1);
}
}
#line 1051 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool zalloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
  {
#line 1054
  cpumask_clear(*mask);
  }
#line 1055
  return ((_Bool)1);
}
}
#line 1058 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void alloc_bootmem_cpumask_var(cpumask_var_t *mask ) 
{ 

  {
#line 1060
  return;
}
}
#line 1062 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void free_cpumask_var(struct cpumask *mask ) 
{ 

  {
#line 1064
  return;
}
}
#line 1066 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void free_bootmem_cpumask_var(struct cpumask *mask ) 
{ 

  {
#line 1068
  return;
}
}
#line 1073
extern unsigned long const   cpu_all_bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 1084
extern void set_cpu_possible(unsigned int cpu , bool possible ) ;
#line 1085
extern void set_cpu_present(unsigned int cpu , bool present ) ;
#line 1086
extern void set_cpu_online(unsigned int cpu , bool online ) ;
#line 1087
extern void set_cpu_active(unsigned int cpu , bool active ) ;
#line 1088
extern void init_cpu_present(struct cpumask  const  *src ) ;
#line 1089
extern void init_cpu_possible(struct cpumask  const  *src ) ;
#line 1090
extern void init_cpu_online(struct cpumask  const  *src ) ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void *current_text_addr(void) 
{ void *pc ;

  {
  {
#line 40
  __asm__  volatile   ("mov $1f, %0; 1:": "=r" (pc));
  }
#line 42
  return (pc);
}
}
#line 134
extern struct cpuinfo_x86 boot_cpu_data ;
#line 135
extern struct cpuinfo_x86 new_cpu_data ;
#line 137
extern struct tss_struct doublefault_tss ;
#line 138
extern __u32 cleared_cpu_caps[9] ;
#line 141
extern struct cpuinfo_x86 per_cpu__cpu_info  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
#line 149
extern struct seq_operations  const  cpuinfo_op ;
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static int hlt_works(int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 154
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_info));
  }
#line 154
  return ((int )((struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[cpu]))->hlt_works_ok);
}
}
#line 162
extern void cpu_detect(struct cpuinfo_x86 *c ) ;
#line 164
extern struct pt_regs *idle_regs(struct pt_regs * ) ;
#line 166
extern void early_cpu_init(void) ;
#line 167
extern void identify_boot_cpu(void) ;
#line 168
extern void identify_secondary_cpu(struct cpuinfo_x86 * ) ;
#line 169
extern void print_cpu_info(struct cpuinfo_x86 * ) ;
#line 170
extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c ) ;
#line 171
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c ) ;
#line 172
extern unsigned short num_cache_leaves ;
#line 174
extern void detect_extended_topology(struct cpuinfo_x86 *c ) ;
#line 175
extern void detect_ht(struct cpuinfo_x86 *c ) ;
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                                  unsigned int *edx ) 
{ 

  {
  {
#line 181
  __asm__  ("cpuid": "=a" (*eax), "=b" (*ebx), "=c" (*ecx), "=d" (*edx): "0" (*eax),
            "2" (*ecx));
  }
#line 187
  return;
}
}
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void load_cr3(pgd_t *pgdir ) 
{ 

  {
  {
#line 191
  native_write_cr3((unsigned long )pgdir - 3221225472UL);
  }
#line 192
  return;
}
}
#line 273
extern struct tss_struct per_cpu__init_tss  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
#line 419
extern unsigned int xstate_size ;
#line 420
extern void free_thread_xstate(struct task_struct * ) ;
#line 421
extern struct kmem_cache *task_xstate_cachep ;
#line 483 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned long native_get_debugreg(int regno ) 
{ unsigned long val ;

  {
  {
#line 485
  val = 0UL;
  }
#line 488
  if (regno == 0) {
    goto switch_11_0;
  } else {
#line 491
    if (regno == 1) {
      goto switch_11_1;
    } else {
#line 494
      if (regno == 2) {
        goto switch_11_2;
      } else {
#line 497
        if (regno == 3) {
          goto switch_11_3;
        } else {
#line 500
          if (regno == 6) {
            goto switch_11_6;
          } else {
#line 503
            if (regno == 7) {
              goto switch_11_7;
            } else {
              {
              goto switch_11_default;
#line 487
              if (0) {
                switch_11_0: /* CIL Label */ 
                {
#line 489
                __asm__  ("mov %%db0, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_1: /* CIL Label */ 
                {
#line 492
                __asm__  ("mov %%db1, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_2: /* CIL Label */ 
                {
#line 495
                __asm__  ("mov %%db2, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_3: /* CIL Label */ 
                {
#line 498
                __asm__  ("mov %%db3, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_6: /* CIL Label */ 
                {
#line 501
                __asm__  ("mov %%db6, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_7: /* CIL Label */ 
                {
#line 504
                __asm__  ("mov %%db7, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_default: /* CIL Label */ 
                {

                }
                {
#line 507
                while (1) {
                  while_12_continue: /* CIL Label */ ;
                  {
#line 507
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (507), "i" (sizeof(struct bug_entry )));
                  }
                  {
#line 507
                  while (1) {
                    while_13_continue: /* CIL Label */ ;
                  }
                  while_13_break: /* CIL Label */ ;
                  }
                  goto while_12_break;
                }
                while_12_break: /* CIL Label */ ;
                }
              } else {
                switch_11_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
#line 509
  return (val);
}
}
#line 512 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_set_debugreg(int regno , unsigned long value ) 
{ 

  {
#line 515
  if (regno == 0) {
    goto switch_14_0;
  } else {
#line 518
    if (regno == 1) {
      goto switch_14_1;
    } else {
#line 521
      if (regno == 2) {
        goto switch_14_2;
      } else {
#line 524
        if (regno == 3) {
          goto switch_14_3;
        } else {
#line 527
          if (regno == 6) {
            goto switch_14_6;
          } else {
#line 530
            if (regno == 7) {
              goto switch_14_7;
            } else {
              {
              goto switch_14_default;
#line 514
              if (0) {
                switch_14_0: /* CIL Label */ 
                {
#line 516
                __asm__  ("mov %0, %%db0": : "r" (value));
                }
                goto switch_14_break;
                switch_14_1: /* CIL Label */ 
                {
#line 519
                __asm__  ("mov %0, %%db1": : "r" (value));
                }
                goto switch_14_break;
                switch_14_2: /* CIL Label */ 
                {
#line 522
                __asm__  ("mov %0, %%db2": : "r" (value));
                }
                goto switch_14_break;
                switch_14_3: /* CIL Label */ 
                {
#line 525
                __asm__  ("mov %0, %%db3": : "r" (value));
                }
                goto switch_14_break;
                switch_14_6: /* CIL Label */ 
                {
#line 528
                __asm__  ("mov %0, %%db6": : "r" (value));
                }
                goto switch_14_break;
                switch_14_7: /* CIL Label */ 
                {
#line 531
                __asm__  ("mov %0, %%db7": : "r" (value));
                }
                goto switch_14_break;
                switch_14_default: /* CIL Label */ 
                {

                }
                {
#line 534
                while (1) {
                  while_15_continue: /* CIL Label */ ;
                  {
#line 534
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (534), "i" (sizeof(struct bug_entry )));
                  }
                  {
#line 534
                  while (1) {
                    while_16_continue: /* CIL Label */ ;
                  }
                  while_16_break: /* CIL Label */ ;
                  }
                  goto while_15_break;
                }
                while_15_break: /* CIL Label */ ;
                }
              } else {
                switch_14_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
#line 536
  return;
}
}
#line 541 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_set_iopl_mask(unsigned int mask ) 
{ unsigned int reg ;

  {
  {
#line 546
  __asm__  volatile   ("pushfl;"
                       "popl %0;"
                       "andl %1, %0;"
                       "orl %2, %0;"
                       "pushl %0;"
                       "popfl": "=&r" (reg): "i" (~ 12288), "r" (mask));
  }
#line 555
  return;
}
}
#line 557 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ long tmp ;

  {
  {
#line 560
  tss->x86_tss.sp0 = thread->sp0;
#line 563
  tmp = __builtin_expect((long )(! (! ((unsigned long )tss->x86_tss.ss1 != thread->sysenter_cs))),
                         0L);
  }
#line 563
  if (tmp) {
    {
#line 564
    tss->x86_tss.ss1 = (unsigned short )thread->sysenter_cs;
#line 565
    wrmsr(372U, (unsigned int )thread->sysenter_cs, 0U);
    }
  }
#line 568
  return;
}
}
#line 570 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_swapgs(void) 
{ 

  {
#line 575
  return;
}
}
#line 591 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ 

  {
  {
#line 594
  native_load_sp0(tss, thread);
  }
#line 595
  return;
}
}
#line 606
extern unsigned long mmu_cr4_features ;
#line 608 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void set_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
#line 612
  mmu_cr4_features |= mask;
#line 613
  tmp = native_read_cr4();
#line 613
  cr4 = (unsigned int )tmp;
#line 614
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
#line 615
  native_write_cr4((unsigned long )cr4);
  }
#line 616
  return;
}
}
#line 618 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void clear_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
#line 622
  mmu_cr4_features &= ~ mask;
#line 623
  tmp = native_read_cr4();
#line 623
  cr4 = (unsigned int )tmp;
#line 624
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
#line 625
  native_write_cr4((unsigned long )cr4);
  }
#line 626
  return;
}
}
#line 636
extern int kernel_thread(int (*fn)(void * ) , void *arg , unsigned long flags ) ;
#line 639
extern void release_thread(struct task_struct * ) ;
#line 642
extern void prepare_to_copy(struct task_struct *tsk ) ;
#line 644
extern unsigned long get_wchan(struct task_struct *p ) ;
#line 651 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
#line 655
  *eax = op;
#line 656
  *ecx = 0U;
#line 657
  native_cpuid(eax, ebx, ecx, edx);
  }
#line 658
  return;
}
}
#line 661 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpuid_count(unsigned int op , int count , unsigned int *eax ,
                                 unsigned int *ebx , unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
#line 665
  *eax = op;
#line 666
  *ecx = (unsigned int )count;
#line 667
  native_cpuid(eax, ebx, ecx, edx);
  }
#line 668
  return;
}
}
#line 673 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_eax(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 677
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 679
  return (eax);
}
}
#line 682 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_ebx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 686
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 688
  return (ebx);
}
}
#line 691 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_ecx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 695
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 697
  return (ecx);
}
}
#line 700 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_edx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 704
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 706
  return (edx);
}
}
#line 710 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 

  {
  {
#line 712
  __asm__  volatile   ("rep; nop": : : "memory");
  }
#line 713
  return;
}
}
#line 715 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 

  {
  {
#line 717
  rep_nop();
  }
#line 718
  return;
}
}
#line 721 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void sync_core(void) 
{ int tmp ;

  {
  {
#line 725
  __asm__  volatile   ("cpuid": "=a" (tmp): "0" (1): "ebx", "ecx", "edx", "memory");
  }
#line 727
  return;
}
}
#line 729 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void __monitor(void const   *eax , unsigned long ecx , unsigned long edx ) 
{ 

  {
  {
#line 733
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc8;": : "a" (eax), "c" (ecx), "d" (edx));
  }
#line 735
  return;
}
}
#line 737 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void __mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
#line 740
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
#line 742
  return;
}
}
#line 744 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void __sti_mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
#line 746
  while (1) {
    while_17_continue: /* CIL Label */ ;
    goto while_17_break;
  }
  while_17_break: /* CIL Label */ ;
  }
  {
#line 748
  __asm__  volatile   ("sti; .byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
#line 750
  return;
}
}
#line 752
extern void mwait_idle_with_hints(unsigned long eax , unsigned long ecx ) ;
#line 754
extern void select_idle_routine(struct cpuinfo_x86  const  *c ) ;
#line 755
extern void init_c1e_mask(void) ;
#line 757
extern unsigned long boot_option_idle_override ;
#line 758
extern unsigned long idle_halt ;
#line 759
extern unsigned long idle_nomwait ;
#line 773 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void wbinvd_halt(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 775
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
#line 777
  if (19 >> 5 == 0) {
#line 777
    if ((1UL << 19) & (unsigned long )(1 | (1 << 15))) {
      {
#line 777
      tmp___1 = 1;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 777
    if (19 >> 5 == 1) {
      goto _L___4;
    } else {
      _L___4: /* CIL Label */ 
#line 777
      if (19 >> 5 == 2) {
        goto _L___3;
      } else {
        _L___3: /* CIL Label */ 
#line 777
        if (19 >> 5 == 3) {
          goto _L___2;
        } else {
          _L___2: /* CIL Label */ 
#line 777
          if (19 >> 5 == 4) {
            goto _L___1;
          } else {
            _L___1: /* CIL Label */ 
#line 777
            if (19 >> 5 == 5) {
              goto _L___0;
            } else {
              _L___0: /* CIL Label */ 
#line 777
              if (19 >> 5 == 6) {
                goto _L;
              } else {
                _L: /* CIL Label */ 
#line 777
                if (19 >> 5 == 7) {
                  {
#line 777
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 777
                  tmp___1 = tmp;
                  }
                } else {
                  {
#line 777
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 777
                  tmp___1 = tmp;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 777
  if (tmp___1) {
    {
#line 778
    __asm__  volatile   ("cli; wbinvd; 1: hlt; jmp 1b": : : "memory");
    }
  } else {
    {
#line 780
    while (1) {
      while_18_continue: /* CIL Label */ ;
      {
#line 781
      halt();
      }
    }
    while_18_break: /* CIL Label */ ;
    }
  }
#line 782
  return;
}
}
#line 784
extern void enable_sep_cpu(void) ;
#line 785
extern int sysenter_setup(void) ;
#line 788
extern struct desc_ptr early_gdt_descr ;
#line 790
extern void cpu_set_gdt(int  ) ;
#line 791
extern void switch_to_new_gdt(int  ) ;
#line 792
extern void load_percpu_segment(int  ) ;
#line 793
extern void cpu_init(void) ;
#line 795 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned long get_debugctlmsr(void) 
{ unsigned long debugctlmsr ;
  unsigned long long tmp ;

  {
  {
#line 797
  debugctlmsr = 0UL;
#line 803
  tmp = native_read_msr(473U);
#line 803
  debugctlmsr = (unsigned long )tmp;
  }
#line 805
  return (debugctlmsr);
}
}
#line 808 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void update_debugctlmsr(unsigned long debugctlmsr ) 
{ 

  {
  {
#line 814
  native_write_msr(473U, (unsigned int )((unsigned long long )debugctlmsr), (unsigned int )((unsigned long long )debugctlmsr >> 32));
  }
#line 815
  return;
}
}
#line 821
extern unsigned int machine_id ;
#line 822
extern unsigned int machine_submodel_id ;
#line 823
extern unsigned int BIOS_revision ;
#line 826
extern int bootloader_type ;
#line 828
extern char ignore_fpu_irq ;
#line 847 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
#line 849
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
#line 853
  return;
}
}
#line 860 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const   *x ) 
{ 

  {
  {
#line 862
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchw (%1)"
                       "\n664:\n"
                       ".previous": : "i" (63), "r" (x));
  }
#line 866
  return;
}
}
#line 868 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void spin_lock_prefetch(void const   *x ) 
{ 

  {
  {
#line 870
  prefetchw(x);
  }
#line 871
  return;
}
}
#line 906
extern unsigned long thread_saved_pc(struct task_struct *tsk ) ;
#line 972
extern void start_thread(struct pt_regs *regs , unsigned long new_ip , unsigned long new_sp ) ;
#line 987
extern int get_tsc_mode(unsigned long adr ) ;
#line 988
extern int set_tsc_mode(unsigned int val ) ;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 

  {
  {
#line 42
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (v->counter): "ir" (i));
  }
#line 45
  return;
}
}
#line 54 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 

  {
  {
#line 56
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %1,%0": "+m" (v->counter): "ir" (i));
  }
#line 59
  return;
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 74
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %2,%0; sete %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
#line 77
  return ((int )c);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 

  {
  {
#line 88
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (v->counter));
  }
#line 90
  return;
}
}
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 

  {
  {
#line 100
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0": "+m" (v->counter));
  }
#line 102
  return;
}
}
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 116
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
#line 119
  return ((int )c != 0);
}
}
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_inc_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 134
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
#line 137
  return ((int )c != 0);
}
}
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_add_negative(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 153
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %2,%0; sets %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
#line 156
  return ((int )c);
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ int __i ;

  {
  {
#line 175
  __i = i;
#line 176
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddl %0, %1": "+r" (i), "+m" (v->counter): : "memory");
  }
#line 179
  return (i + __i);
}
}
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ int tmp ;

  {
  {
#line 200
  tmp = atomic_add_return(- i, v);
  }
#line 200
  return (tmp);
}
}
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ int c ;
  int old ;
  long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 218
  c = (int )v->counter;
  }
  {
#line 219
  while (1) {
    while_19_continue: /* CIL Label */ ;
    {
#line 220
    tmp = __builtin_expect((long )(! (! (c == u))), 0L);
    }
#line 220
    if (tmp) {
      goto while_19_break;
    }
    {
#line 222
    tmp___0 = __cmpxchg((void volatile   *)(& v->counter), (unsigned long )c, (unsigned long )(c + a),
                        (int )sizeof(v->counter));
#line 222
    old = (int )((int volatile   )tmp___0);
#line 223
    tmp___1 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
#line 223
    if (tmp___1) {
      goto while_19_break;
    }
    {
#line 225
    c = old;
    }
  }
  while_19_break: /* CIL Label */ ;
  }
#line 227
  return (c != u);
}
}
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_read(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 146
  v = l;
  }
#line 148
  return ((long )v->counter);
}
}
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_set(atomic_long_t *l , long i ) 
{ atomic_t *v ;

  {
  {
#line 153
  v = l;
#line 155
  v->counter = (int volatile   )i;
  }
#line 156
  return;
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_inc(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 160
  v = l;
#line 162
  atomic_inc(v);
  }
#line 163
  return;
}
}
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_dec(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 167
  v = l;
#line 169
  atomic_dec(v);
  }
#line 170
  return;
}
}
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_add(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 174
  v = l;
#line 176
  atomic_add((int )i, v);
  }
#line 177
  return;
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_sub(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 181
  v = l;
#line 183
  atomic_sub((int )i, v);
  }
#line 184
  return;
}
}
#line 186 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_sub_and_test(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 188
  v = l;
#line 190
  tmp = atomic_sub_and_test((int )i, v);
  }
#line 190
  return (tmp);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_dec_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 195
  v = l;
#line 197
  tmp = atomic_dec_and_test(v);
  }
#line 197
  return (tmp);
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_inc_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 202
  v = l;
#line 204
  tmp = atomic_inc_and_test(v);
  }
#line 204
  return (tmp);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_add_negative(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 209
  v = l;
#line 211
  tmp = atomic_add_negative((int )i, v);
  }
#line 211
  return (tmp);
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_add_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 216
  v = l;
#line 218
  tmp = atomic_add_return((int )i, v);
  }
#line 218
  return ((long )tmp);
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_sub_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 223
  v = l;
#line 225
  tmp = atomic_sub_return((int )i, v);
  }
#line 225
  return ((long )tmp);
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_inc_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 230
  v = l;
#line 232
  tmp = atomic_add_return(1, v);
  }
#line 232
  return ((long )tmp);
}
}
#line 235 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_dec_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 237
  v = l;
#line 239
  tmp = atomic_sub_return(1, v);
  }
#line 239
  return ((long )tmp);
}
}
#line 242 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_add_unless(atomic_long_t *l , long a , long u ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 244
  v = l;
#line 246
  tmp = atomic_add_unless(v, (int )a, (int )u);
  }
#line 246
  return ((long )tmp);
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
register unsigned long current_stack_pointer  __asm__("esp")   ;
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 

  {
#line 182
  return ((struct thread_info *)(current_stack_pointer & ~ (((1UL << 12) << 1) - 1UL)));
}
}
#line 249 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
__inline static void set_restore_sigmask(void) 
{ struct thread_info *ti ;
  struct thread_info *tmp ;

  {
  {
#line 251
  tmp = current_thread_info();
#line 251
  ti = tmp;
#line 252
  ti->status |= 8U;
#line 253
  set_bit(2U, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 254
  return;
}
}
#line 258
extern void arch_task_cache_init(void) ;
#line 259
extern void free_thread_info(struct thread_info *ti ) ;
#line 260
extern int arch_dup_task_struct(struct task_struct *dst , struct task_struct *src ) ;
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
#line 66
  set_bit((unsigned int )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 67
  return;
}
}
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static void clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
#line 71
  clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 72
  return;
}
}
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static int test_and_set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
#line 76
  tmp = test_and_set_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 76
  return (tmp);
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static int test_and_clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
#line 81
  tmp = test_and_clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 81
  return (tmp);
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 86
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 86
  return (tmp___0);
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prefetch.h"
__inline static void prefetch_range(void *addr , size_t len ) 
{ char *cp ;
  char *end ;

  {
  {
#line 57
  end = (char *)(addr + len);
#line 59
  cp = (char *)addr;
  }
  {
#line 59
  while (1) {
    while_20_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )cp < (unsigned long )end)) {
      goto while_20_break;
    }
    {
#line 60
    prefetch((void const   *)cp);
#line 59
    cp += 4 * (1 << 5);
    }
  }
  while_20_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  {
#line 30
  list->next = list;
#line 31
  list->prev = list;
  }
#line 32
  return;
}
}
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
#line 45
  next->prev = new;
#line 46
  new->next = next;
#line 47
  new->prev = prev;
#line 48
  prev->next = new;
  }
#line 49
  return;
}
}
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 66
  __list_add(new, head, head->next);
  }
#line 67
  return;
}
}
#line 78 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 80
  __list_add(new, head->prev, head);
  }
#line 81
  return;
}
}
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
#line 92
  next->prev = prev;
#line 93
  prev->next = next;
  }
#line 94
  return;
}
}
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
#line 105
  __list_del(entry->prev, entry->next);
#line 106
  entry->next = (struct list_head *)((void *)1048832);
#line 107
  entry->prev = (struct list_head *)((void *)2097664);
  }
#line 108
  return;
}
}
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_replace(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
#line 123
  new->next = old->next;
#line 124
  (new->next)->prev = new;
#line 125
  new->prev = old->prev;
#line 126
  (new->prev)->next = new;
  }
#line 127
  return;
}
}
#line 129 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_replace_init(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
#line 132
  list_replace(old, new);
#line 133
  INIT_LIST_HEAD(old);
  }
#line 134
  return;
}
}
#line 140 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
  {
#line 142
  __list_del(entry->prev, entry->next);
#line 143
  INIT_LIST_HEAD(entry);
  }
#line 144
  return;
}
}
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
#line 153
  __list_del(list->prev, list->next);
#line 154
  list_add(list, head);
  }
#line 155
  return;
}
}
#line 162 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
#line 165
  __list_del(list->prev, list->next);
#line 166
  list_add_tail(list, head);
  }
#line 167
  return;
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_is_last(struct list_head  const  *list , struct list_head  const  *head ) 
{ 

  {
#line 177
  return ((unsigned long )list->next == (unsigned long )head);
}
}
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
#line 186
  return ((unsigned long )head->next == (unsigned long )head);
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_empty_careful(struct list_head  const  *head ) 
{ struct list_head *next ;
  int tmp ;

  {
  {
#line 204
  next = (struct list_head *)head->next;
  }
#line 205
  if ((unsigned long )next == (unsigned long )head) {
#line 205
    if ((unsigned long )next == (unsigned long )head->prev) {
      {
#line 205
      tmp = 1;
      }
    } else {
      {
#line 205
      tmp = 0;
      }
    }
  } else {
    {
#line 205
    tmp = 0;
    }
  }
#line 205
  return (tmp);
}
}
#line 212 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_is_singular(struct list_head  const  *head ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 214
  tmp = list_empty(head);
  }
#line 214
  if (tmp) {
    {
#line 214
    tmp___0 = 0;
    }
  } else {
#line 214
    if ((unsigned long )head->next == (unsigned long )head->prev) {
      {
#line 214
      tmp___0 = 1;
      }
    } else {
      {
#line 214
      tmp___0 = 0;
      }
    }
  }
#line 214
  return (tmp___0);
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_cut_position(struct list_head *list , struct list_head *head ,
                                         struct list_head *entry ) 
{ struct list_head *new_first ;

  {
  {
#line 220
  new_first = entry->next;
#line 221
  list->next = head->next;
#line 222
  (list->next)->prev = list;
#line 223
  list->prev = entry;
#line 224
  entry->next = list;
#line 225
  head->next = new_first;
#line 226
  new_first->prev = head;
  }
#line 227
  return;
}
}
#line 243 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_cut_position(struct list_head *list , struct list_head *head ,
                                       struct list_head *entry ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 246
  tmp = list_empty((struct list_head  const  *)head);
  }
#line 246
  if (tmp) {
#line 247
    return;
  }
  {
#line 248
  tmp___0 = list_is_singular((struct list_head  const  *)head);
  }
#line 248
  if (tmp___0) {
#line 248
    if ((unsigned long )head->next != (unsigned long )entry) {
#line 248
      if ((unsigned long )head != (unsigned long )entry) {
#line 250
        return;
      }
    }
  }
#line 251
  if ((unsigned long )entry == (unsigned long )head) {
    {
#line 252
    INIT_LIST_HEAD(list);
    }
  } else {
    {
#line 254
    __list_cut_position(list, head, entry);
    }
  }
#line 255
  return;
}
}
#line 257 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;

  {
  {
#line 261
  first = (struct list_head *)list->next;
#line 262
  last = (struct list_head *)list->prev;
#line 264
  first->prev = prev;
#line 265
  prev->next = first;
#line 267
  last->next = next;
#line 268
  next->prev = last;
  }
#line 269
  return;
}
}
#line 276 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 279
  tmp = list_empty(list);
  }
#line 279
  if (! tmp) {
    {
#line 280
    __list_splice(list, head, head->next);
    }
  }
#line 281
  return;
}
}
#line 288 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice_tail(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 291
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 291
  if (! tmp) {
    {
#line 292
    __list_splice((struct list_head  const  *)list, head->prev, head);
    }
  }
#line 293
  return;
}
}
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 305
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 305
  if (! tmp) {
    {
#line 306
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 307
    INIT_LIST_HEAD(list);
    }
  }
#line 309
  return;
}
}
#line 319 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 322
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 322
  if (! tmp) {
    {
#line 323
    __list_splice((struct list_head  const  *)list, head->prev, head);
#line 324
    INIT_LIST_HEAD(list);
    }
  }
#line 326
  return;
}
}
#line 551 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
{ 

  {
  {
#line 553
  h->next = (struct hlist_node *)((void *)0);
#line 554
  h->pprev = (struct hlist_node **)((void *)0);
  }
#line 555
  return;
}
}
#line 557 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int hlist_unhashed(struct hlist_node  const  *h ) 
{ 

  {
#line 559
  return (! h->pprev);
}
}
#line 562 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int hlist_empty(struct hlist_head  const  *h ) 
{ 

  {
#line 564
  return (! h->first);
}
}
#line 567 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n ) 
{ struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
  {
#line 569
  next = n->next;
#line 570
  pprev = n->pprev;
#line 571
  *pprev = next;
  }
#line 572
  if (next) {
    {
#line 573
    next->pprev = pprev;
    }
  }
#line 574
  return;
}
}
#line 576 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n ) 
{ 

  {
  {
#line 578
  __hlist_del(n);
#line 579
  n->next = (struct hlist_node *)((void *)1048832);
#line 580
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
#line 581
  return;
}
}
#line 583 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_del_init(struct hlist_node *n ) 
{ int tmp ;

  {
  {
#line 585
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
#line 585
  if (! tmp) {
    {
#line 586
    __hlist_del(n);
#line 587
    INIT_HLIST_NODE(n);
    }
  }
#line 589
  return;
}
}
#line 591 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
#line 593
  first = h->first;
#line 594
  n->next = first;
  }
#line 595
  if (first) {
    {
#line 596
    first->pprev = & n->next;
    }
  }
  {
#line 597
  h->first = n;
#line 598
  n->pprev = & h->first;
  }
#line 599
  return;
}
}
#line 602 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_add_before(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
#line 605
  n->pprev = next->pprev;
#line 606
  n->next = next;
#line 607
  next->pprev = & n->next;
#line 608
  *(n->pprev) = n;
  }
#line 609
  return;
}
}
#line 611 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_add_after(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
#line 614
  next->next = n->next;
#line 615
  n->next = next;
#line 616
  next->pprev = & n->next;
  }
#line 618
  if (next->next) {
    {
#line 619
    (next->next)->pprev = & next->next;
    }
  }
#line 620
  return;
}
}
#line 626 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_move_list(struct hlist_head *old , struct hlist_head *new ) 
{ 

  {
  {
#line 629
  new->first = old->first;
  }
#line 630
  if (new->first) {
    {
#line 631
    (new->first)->pprev = & new->first;
    }
  }
  {
#line 632
  old->first = (struct hlist_node *)((void *)0);
  }
#line 633
  return;
}
}
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bottom_half.h"
extern void local_bh_disable(void) ;
#line 5
extern void _local_bh_enable(void) ;
#line 6
extern void local_bh_enable(void) ;
#line 7
extern void local_bh_enable_ip(unsigned long ip ) ;
#line 304 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void lockdep_off(void) 
{ 

  {
#line 306
  return;
}
}
#line 308 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void lockdep_on(void) 
{ 

  {
#line 310
  return;
}
}
#line 385
extern void early_init_irq_lock_class(void) ;
#line 397 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void early_boot_irqs_off(void) 
{ 

  {
#line 399
  return;
}
}
#line 400 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void early_boot_irqs_on(void) 
{ 

  {
#line 402
  return;
}
}
#line 403 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void print_irqtrace_events(struct task_struct *curr ) 
{ 

  {
#line 405
  return;
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock.h"
extern int generic__raw_read_trylock(raw_rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __ticket_spin_lock(raw_spinlock_t *lock ) 
{ short inc ;

  {
  {
#line 63
  inc = (short)256;
#line 65
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddw %w0, %1\n"
                       "1:\t"
                       "cmpb %h0, %b0\n\t"
                       "je 2f\n\t"
                       "rep ; nop\n\t"
                       "movb %1, %b0\n\t"
                       "jmp 1b\n"
                       "2:": "+Q" (inc), "+m" (lock->slock): : "memory", "cc");
  }
#line 78
  return;
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __ticket_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;
  int new ;

  {
  {
#line 84
  __asm__  volatile   ("movzwl %2, %0\n\t"
                       "cmpb %h0,%b0\n\t"
                       "leal 0x100(%"
                       "k"
                       "0), %1\n\t"
                       "jne 1f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchgw %w1,%2\n\t"
                       "1:"
                       "sete %b1\n\t"
                       "movzbl %b1,%0\n\t": "=&a" (tmp), "=&q" (new), "+m" (lock->slock): : "memory",
                       "cc");
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __ticket_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
#line 101
  __asm__  volatile   ("incb %0": "+m" (lock->slock): : "memory", "cc");
  }
#line 105
  return;
}
}
#line 161 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __ticket_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 163
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
#line 165
  return (! (! (((tmp >> 8) ^ tmp) & ((1 << 8) - 1))));
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __ticket_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 170
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
#line 172
  return ((((tmp >> 8) - tmp) & ((1 << 8) - 1)) > 1);
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 179
  tmp = __ticket_spin_is_locked(lock);
  }
#line 179
  return (tmp);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 184
  tmp = __ticket_spin_is_contended(lock);
  }
#line 184
  return (tmp);
}
}
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_lock(raw_spinlock_t *lock ) 
{ 

  {
  {
#line 190
  __ticket_spin_lock(lock);
  }
#line 191
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 195
  tmp = __ticket_spin_trylock(lock);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
#line 200
  __ticket_spin_unlock(lock);
  }
#line 201
  return;
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_lock_flags(raw_spinlock_t *lock , unsigned long flags ) 
{ 

  {
  {
#line 206
  __raw_spin_lock(lock);
  }
#line 207
  return;
}
}
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_unlock_wait(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 213
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
#line 213
    tmp = __raw_spin_is_locked(lock);
    }
#line 213
    if (! tmp) {
      goto while_21_break;
    }
    {
#line 214
    cpu_relax();
    }
  }
  while_21_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 235 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_read_can_lock(raw_rwlock_t *lock ) 
{ 

  {
#line 237
  return ((int )lock->lock > 0);
}
}
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_write_can_lock(raw_rwlock_t *lock ) 
{ 

  {
#line 246
  return (lock->lock == 16777216U);
}
}
#line 249 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_read_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 251
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl $1,(%0)\n\t"
                       "jns 1f\n"
                       "call __read_lock_failed\n\t"
                       "1:\n": : "a" (rw): "memory");
  }
#line 256
  return;
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_write_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 260
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl %1,(%0)\n\t"
                       "jz 1f\n"
                       "call __write_lock_failed\n\t"
                       "1:\n": : "a" (rw), "i" (16777216): "memory");
  }
#line 265
  return;
}
}
#line 267 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_read_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
#line 269
  count = (atomic_t *)lock;
#line 271
  tmp = atomic_sub_return(1, count);
  }
#line 271
  if (tmp >= 0) {
#line 272
    return (1);
  }
  {
#line 273
  atomic_inc(count);
  }
#line 274
  return (0);
}
}
#line 277 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_write_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
#line 279
  count = (atomic_t *)lock;
#line 281
  tmp = atomic_sub_and_test(16777216, count);
  }
#line 281
  if (tmp) {
#line 282
    return (1);
  }
  {
#line 283
  atomic_add(16777216, count);
  }
#line 284
  return (0);
}
}
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_read_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 289
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (rw->lock): : "memory");
  }
#line 290
  return;
}
}
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_write_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 294
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1, %0": "+m" (rw->lock): "i" (16777216): "memory");
  }
#line 296
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock.h"
extern void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 109
extern void __rwlock_init(rwlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_api_smp.h"
extern int in_lock_functions(unsigned long addr ) ;
#line 22
extern void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 23
extern void _spin_lock_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
#line 25
extern void _spin_lock_nest_lock(spinlock_t *lock , struct lockdep_map *map )  __attribute__((__section__(".spinlock.text"))) ;
#line 27
extern void _read_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 28
extern void _write_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 29
extern void _spin_lock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 30
extern void _read_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 31
extern void _write_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 32
extern void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 33
extern void _read_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 34
extern void _write_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 35
extern unsigned long _spin_lock_irqsave(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 37
extern unsigned long _spin_lock_irqsave_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
#line 39
extern unsigned long _read_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 41
extern unsigned long _write_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 43
extern int _spin_trylock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 44
extern int _read_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 45
extern int _write_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 46
extern int _spin_trylock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 47
extern void _spin_unlock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 48
extern void _read_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 49
extern void _write_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 50
extern void _spin_unlock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 51
extern void _read_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 52
extern void _write_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 53
extern void _spin_unlock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 54
extern void _read_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 55
extern void _write_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 56
extern void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 58
extern void _read_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 60
extern void _write_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock.h"
extern void _raw_spin_lock(spinlock_t *lock ) ;
#line 153
extern int _raw_spin_trylock(spinlock_t *lock ) ;
#line 154
extern void _raw_spin_unlock(spinlock_t *lock ) ;
#line 155
extern void _raw_read_lock(rwlock_t *lock ) ;
#line 157
extern int _raw_read_trylock(rwlock_t *lock ) ;
#line 158
extern void _raw_read_unlock(rwlock_t *lock ) ;
#line 159
extern void _raw_write_lock(rwlock_t *lock ) ;
#line 161
extern int _raw_write_trylock(rwlock_t *lock ) ;
#line 162
extern void _raw_write_unlock(rwlock_t *lock ) ;
#line 368
extern int _atomic_dec_and_lock(atomic_t *atomic , spinlock_t *lock ) ;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key ) ;
#line 80
extern void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void init_waitqueue_entry(wait_queue_t *q , struct task_struct *p ) 
{ 

  {
  {
#line 93
  q->flags = 0U;
#line 94
  q->private = (void *)p;
#line 95
  q->func = & default_wake_function;
  }
#line 96
  return;
}
}
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void init_waitqueue_func_entry(wait_queue_t *q , int (*func)(wait_queue_t *wait ,
                                                                             unsigned int mode ,
                                                                             int sync ,
                                                                             void *key ) ) 
{ 

  {
  {
#line 101
  q->flags = 0U;
#line 102
  q->private = (void *)0;
#line 103
  q->func = func;
  }
#line 104
  return;
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static int waitqueue_active(wait_queue_head_t *q ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 108
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
  }
#line 108
  if (tmp) {
    {
#line 108
    tmp___0 = 0;
    }
  } else {
    {
#line 108
    tmp___0 = 1;
    }
  }
#line 108
  return (tmp___0);
}
}
#line 111
extern void add_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 112
extern void add_wait_queue_exclusive(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 113
extern void remove_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
#line 117
  list_add(& new->task_list, & head->task_list);
  }
#line 118
  return;
}
}
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue_tail(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
#line 126
  list_add_tail(& new->task_list, & head->task_list);
  }
#line 127
  return;
}
}
#line 129 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void __remove_wait_queue(wait_queue_head_t *head , wait_queue_t *old ) 
{ 

  {
  {
#line 132
  list_del(& old->task_list);
  }
#line 133
  return;
}
}
#line 135
extern void __wake_up_common(wait_queue_head_t *q , unsigned int mode , int nr_exclusive ,
                             int sync , void *key ) ;
#line 137
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
#line 138
extern void __wake_up_locked_key(wait_queue_head_t *q , unsigned int mode , void *key ) ;
#line 139
extern void __wake_up_sync_key(wait_queue_head_t *q , unsigned int mode , int nr ,
                               void *key ) ;
#line 141
extern void __wake_up_locked(wait_queue_head_t *q , unsigned int mode ) ;
#line 142
extern void __wake_up_sync(wait_queue_head_t *q , unsigned int mode , int nr ) ;
#line 143
extern void __wake_up_bit(wait_queue_head_t * , void * , int  ) ;
#line 144
extern int __wait_on_bit(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                         unsigned int  ) ;
#line 145
extern int __wait_on_bit_lock(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                              unsigned int  ) ;
#line 146
extern void wake_up_bit(void * , int  ) ;
#line 147
extern int out_of_line_wait_on_bit(void * , int  , int (*)(void * ) , unsigned int  ) ;
#line 148
extern int out_of_line_wait_on_bit_lock(void * , int  , int (*)(void * ) , unsigned int  ) ;
#line 149
extern wait_queue_head_t *bit_waitqueue(void * , int  ) ;
#line 404 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void add_wait_queue_exclusive_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
#line 407
  wait->flags |= 1U;
#line 408
  __add_wait_queue_tail(q, wait);
  }
#line 409
  return;
}
}
#line 414 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void remove_wait_queue_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
#line 417
  __remove_wait_queue(q, wait);
  }
#line 418
  return;
}
}
#line 425
extern void sleep_on(wait_queue_head_t *q ) ;
#line 426
extern long sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
#line 428
extern void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 429
extern long interruptible_sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
#line 435
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
#line 436
extern void prepare_to_wait_exclusive(wait_queue_head_t *q , wait_queue_t *wait ,
                                      int state ) ;
#line 437
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 438
extern void abort_exclusive_wait(wait_queue_head_t *q , wait_queue_t *wait , unsigned int mode ,
                                 void *key ) ;
#line 440
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
#line 441
extern int wake_bit_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
#line 484 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static int wait_on_bit(void *word , int bit , int (*action)(void * ) , unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 487
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)word);
  }
#line 487
  if (! tmp___0) {
#line 488
    return (0);
  }
  {
#line 489
  tmp___1 = out_of_line_wait_on_bit(word, bit, action, mode);
  }
#line 489
  return (tmp___1);
}
}
#line 508 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static int wait_on_bit_lock(void *word , int bit , int (*action)(void * ) ,
                                     unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 511
  tmp = test_and_set_bit(bit, (unsigned long volatile   *)word);
  }
#line 511
  if (! tmp) {
#line 512
    return (0);
  }
  {
#line 513
  tmp___0 = out_of_line_wait_on_bit_lock(word, bit, action, mode);
  }
#line 513
  return (tmp___0);
}
}
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_seqlock(seqlock_t *sl ) 
{ 

  {
  {
#line 62
  _spin_lock(& sl->lock);
#line 63
  (sl->sequence) ++;
#line 64
  __asm__  volatile   ("": : : "memory");
  }
#line 65
  return;
}
}
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_sequnlock(seqlock_t *sl ) 
{ 

  {
  {
#line 69
  __asm__  volatile   ("": : : "memory");
#line 70
  (sl->sequence) ++;
#line 71
  _spin_unlock(& sl->lock);
  }
#line 72
  return;
}
}
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static int write_tryseqlock(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  {
#line 76
  tmp = _spin_trylock(& sl->lock);
#line 76
  ret = tmp;
  }
#line 78
  if (ret) {
    {
#line 79
    (sl->sequence) ++;
#line 80
    __asm__  volatile   ("": : : "memory");
    }
  }
#line 82
  return (ret);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static unsigned int read_seqbegin(seqlock_t const   *sl ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
#line 91
  ret = (unsigned int )sl->sequence;
#line 92
  __asm__  volatile   ("": : : "memory");
#line 93
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
#line 93
  if (tmp) {
    {
#line 94
    cpu_relax();
    }
    goto repeat;
  }
#line 98
  return (ret);
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static int read_seqretry(seqlock_t const   *sl , unsigned int start ) 
{ 

  {
  {
#line 108
  __asm__  volatile   ("": : : "memory");
  }
#line 110
  return (sl->sequence != (unsigned int const   )start);
}
}
#line 129 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static unsigned int read_seqcount_begin(seqcount_t const   *s ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
#line 134
  ret = (unsigned int )s->sequence;
#line 135
  __asm__  volatile   ("": : : "memory");
#line 136
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
#line 136
  if (tmp) {
    {
#line 137
    cpu_relax();
    }
    goto repeat;
  }
#line 140
  return (ret);
}
}
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static int read_seqcount_retry(seqcount_t const   *s , unsigned int start ) 
{ 

  {
  {
#line 148
  __asm__  volatile   ("": : : "memory");
  }
#line 150
  return (s->sequence != (unsigned int const   )start);
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_begin(seqcount_t *s ) 
{ 

  {
  {
#line 160
  (s->sequence) ++;
#line 161
  __asm__  volatile   ("": : : "memory");
  }
#line 162
  return;
}
}
#line 164 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_end(seqcount_t *s ) 
{ 

  {
  {
#line 166
  __asm__  volatile   ("": : : "memory");
#line 167
  (s->sequence) ++;
  }
#line 168
  return;
}
}
#line 93 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
extern nodemask_t _unused_nodemask_arg_ ;
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __node_set(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
#line 98
  set_bit((unsigned int )node, (unsigned long volatile   *)(dstp->bits));
  }
#line 99
  return;
}
}
#line 102 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __node_clear(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
#line 104
  clear_bit(node, (unsigned long volatile   *)(dstp->bits));
  }
#line 105
  return;
}
}
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_setall(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
#line 110
  bitmap_fill(dstp->bits, nbits);
  }
#line 111
  return;
}
}
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_clear(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
#line 116
  bitmap_zero(dstp->bits, nbits);
  }
#line 117
  return;
}
}
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __node_test_and_set(int node , nodemask_t *addr ) 
{ int tmp ;

  {
  {
#line 126
  tmp = test_and_set_bit(node, (unsigned long volatile   *)(addr->bits));
  }
#line 126
  return (tmp);
}
}
#line 131 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_and(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
#line 134
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
#line 135
  return;
}
}
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_or(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
#line 142
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
#line 143
  return;
}
}
#line 147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_xor(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
#line 150
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
#line 151
  return;
}
}
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_andnot(nodemask_t *dstp , nodemask_t const   *src1p ,
                                    nodemask_t const   *src2p , int nbits ) 
{ 

  {
  {
#line 158
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  }
#line 159
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_complement(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int nbits ) 
{ 

  {
  {
#line 166
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
#line 167
  return;
}
}
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_equal(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
#line 174
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
#line 174
  return (tmp);
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_intersects(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                       int nbits ) 
{ int tmp ;

  {
  {
#line 182
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
#line 182
  return (tmp);
}
}
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_subset(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                   int nbits ) 
{ int tmp ;

  {
  {
#line 190
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
#line 190
  return (tmp);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_empty(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 196
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
#line 196
  return (tmp);
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_full(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 202
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
#line 202
  return (tmp);
}
}
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_weight(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 208
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
#line 208
  return (tmp);
}
}
#line 213 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_shift_right(nodemask_t *dstp , nodemask_t const   *srcp ,
                                         int n , int nbits ) 
{ 

  {
  {
#line 216
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 217
  return;
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_shift_left(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
#line 224
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 225
  return;
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __first_node(nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 233
  __min1 = 1;
#line 233
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 1UL);
#line 233
  __min2 = (int )tmp;
  }
#line 233
  if (__min1 < __min2) {
    {
#line 233
    tmp___0 = __min1;
    }
  } else {
    {
#line 233
    tmp___0 = __min2;
    }
  }
#line 233
  return (tmp___0);
}
}
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __next_node(int n , nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 239
  __min1 = 1;
#line 239
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 1UL, (unsigned long )(n + 1));
#line 239
  __min2 = (int )tmp;
  }
#line 239
  if (__min1 < __min2) {
    {
#line 239
    tmp___0 = __min1;
    }
  } else {
    {
#line 239
    tmp___0 = __min2;
    }
  }
#line 239
  return (tmp___0);
}
}
#line 255 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __first_unset_node(nodemask_t const   *maskp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 257
  __min1 = 1;
#line 257
  tmp = find_first_zero_bit((unsigned long const   *)(maskp->bits), 1UL);
#line 257
  __min2 = (int )tmp;
  }
#line 257
  if (__min1 < __min2) {
    {
#line 257
    tmp___0 = __min1;
    }
  } else {
    {
#line 257
    tmp___0 = __min2;
    }
  }
#line 257
  return (tmp___0);
}
}
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodemask_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
#line 292
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         nbits);
  }
#line 292
  return (tmp);
}
}
#line 297 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodemask_parse_user(char const   *buf , int len , nodemask_t *dstp ,
                                          int nbits ) 
{ int tmp ;

  {
  {
#line 300
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, nbits);
  }
#line 300
  return (tmp);
}
}
#line 305 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodelist_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
#line 308
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             nbits);
  }
#line 308
  return (tmp);
}
}
#line 312 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodelist_parse(char const   *buf , nodemask_t *dstp , int nbits ) 
{ int tmp ;

  {
  {
#line 314
  tmp = bitmap_parselist(buf, dstp->bits, nbits);
  }
#line 314
  return (tmp);
}
}
#line 319 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __node_remap(int oldbit , nodemask_t const   *oldp , nodemask_t const   *newp ,
                                 int nbits ) 
{ int tmp ;

  {
  {
#line 322
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
#line 322
  return (tmp);
}
}
#line 327 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_remap(nodemask_t *dstp , nodemask_t const   *srcp , nodemask_t const   *oldp ,
                                   nodemask_t const   *newp , int nbits ) 
{ 

  {
  {
#line 330
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
#line 331
  return;
}
}
#line 335 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_onto(nodemask_t *dstp , nodemask_t const   *origp , nodemask_t const   *relmapp ,
                                  int nbits ) 
{ 

  {
  {
#line 338
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
#line 339
  return;
}
}
#line 343 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_fold(nodemask_t *dstp , nodemask_t const   *origp , int sz ,
                                  int nbits ) 
{ 

  {
  {
#line 346
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
#line 347
  return;
}
}
#line 381
extern nodemask_t node_states[5] ;
#line 413 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int node_state(int node , enum node_states state ) 
{ 

  {
#line 415
  return (node == 0);
}
}
#line 418 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void node_set_state(int node , enum node_states state ) 
{ 

  {
#line 420
  return;
}
}
#line 422 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void node_clear_state(int node , enum node_states state ) 
{ 

  {
#line 424
  return;
}
}
#line 426 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int num_node_state(enum node_states state ) 
{ 

  {
#line 428
  return (1);
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pageblock-flags.h"
extern unsigned long get_pageblock_flags_group(struct page *page , int start_bitidx ,
                                               int end_bitidx ) ;
#line 65
extern void set_pageblock_flags_group(struct page *page , unsigned long flags , int start_bitidx ,
                                      int end_bitidx ) ;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
extern int page_group_by_mobility_disabled ;
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int get_pageblock_migratetype(struct page *page ) 
{ long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 53
  tmp = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
#line 53
  if (tmp) {
#line 54
    return (0);
  }
  {
#line 56
  tmp___0 = get_pageblock_flags_group(page, 0, 2);
  }
#line 56
  return ((int )tmp___0);
}
}
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_file_lru(enum lru_list l ) 
{ int tmp ;

  {
#line 152
  if ((unsigned int )l == 2U) {
    {
#line 152
    tmp = 1;
    }
  } else {
#line 152
    if ((unsigned int )l == 3U) {
      {
#line 152
      tmp = 1;
      }
    } else {
      {
#line 152
      tmp = 0;
      }
    }
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_active_lru(enum lru_list l ) 
{ int tmp ;

  {
#line 157
  if ((unsigned int )l == 1U) {
    {
#line 157
    tmp = 1;
    }
  } else {
#line 157
    if ((unsigned int )l == 3U) {
      {
#line 157
      tmp = 1;
      }
    } else {
      {
#line 157
      tmp = 0;
      }
    }
  }
#line 157
  return (tmp);
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_unevictable_lru(enum lru_list l ) 
{ 

  {
#line 163
  return ((unsigned int )l == 4U);
}
}
#line 424 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static void zone_set_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
#line 426
  set_bit((unsigned int )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 427
  return;
}
}
#line 429 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_test_and_set_flag(struct zone *zone , zone_flags_t flag ) 
{ int tmp ;

  {
  {
#line 431
  tmp = test_and_set_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 431
  return (tmp);
}
}
#line 434 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static void zone_clear_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
#line 436
  clear_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 437
  return;
}
}
#line 439 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_is_all_unreclaimable(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 441
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& zone->flags));
  }
#line 441
  return (tmp);
}
}
#line 444 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_is_reclaim_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 446
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& zone->flags));
  }
#line 446
  return (tmp);
}
}
#line 449 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_is_oom_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 451
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& zone->flags));
  }
#line 451
  return (tmp);
}
}
#line 589
extern struct page *mem_map ;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
__inline static int mutex_is_locked(struct mutex *lock ) 
{ 

  {
#line 118
  return (lock->count.counter != (int volatile   )1);
}
}
#line 136
extern void mutex_lock(struct mutex *lock ) ;
#line 137
extern int mutex_lock_interruptible(struct mutex *lock ) ;
#line 138
extern int mutex_lock_killable(struct mutex *lock ) ;
#line 151
extern int mutex_trylock(struct mutex *lock ) ;
#line 152
extern void mutex_unlock(struct mutex *lock ) ;
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_read_failed)(struct rw_semaphore *sem ) ;
#line 49
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_write_failed)(struct rw_semaphore *sem ) ;
#line 51
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_wake)(struct rw_semaphore * ) ;
#line 53
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_downgrade_wake)(struct rw_semaphore *sem ) ;
#line 92
extern void __init_rwsem(struct rw_semaphore *sem , char const   *name , struct lock_class_key *key ) ;
#line 105 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_read(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 107
  __asm__  volatile   ("# beginning down_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  incl      (%%eax)\n\t"
                       "  jns        1f\n"
                       "  call call_rwsem_down_read_failed\n"
                       "1:\n\t"
                       "# ending down_read\n\t": "+m" (sem->count): "a" (sem): "memory",
                       "cc");
  }
#line 117
  return;
}
}
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int __down_read_trylock(struct rw_semaphore *sem ) 
{ __s32 result ;
  __s32 tmp ;
  int tmp___0 ;

  {
  {
#line 125
  __asm__  volatile   ("# beginning __down_read_trylock\n\t"
                       "  movl      %0,%1\n\t"
                       "1:\n\t"
                       "  movl\t     %1,%2\n\t"
                       "  addl      %3,%2\n\t"
                       "  jle\t     2f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  cmpxchgl  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "# ending __down_read_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "i" (1): "memory", "cc");
  }
#line 138
  if (result >= 0) {
    {
#line 138
    tmp___0 = 1;
    }
  } else {
    {
#line 138
    tmp___0 = 0;
    }
  }
#line 138
  return (tmp___0);
}
}
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_write_nested(struct rw_semaphore *sem , int subclass ) 
{ int tmp ;

  {
  {
#line 148
  tmp = -65535;
#line 149
  __asm__  volatile   ("# beginning down_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  testl     %%edx,%%edx\n\t"
                       "  jz        1f\n"
                       "  call call_rwsem_down_write_failed\n"
                       "1:\n"
                       "# ending down_write": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
#line 161
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_write(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 165
  __down_write_nested(sem, 0);
  }
#line 166
  return;
}
}
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int __down_write_trylock(struct rw_semaphore *sem ) 
{ long ret ;
  unsigned long tmp ;

  {
  {
#line 173
  tmp = __cmpxchg((void volatile   *)(& sem->count), 0UL, 0xffff0001UL, (int )sizeof(sem->count));
#line 173
  ret = (long )tmp;
  }
#line 176
  if (ret == 0L) {
#line 177
    return (1);
  }
#line 178
  return (0);
}
}
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __up_read(struct rw_semaphore *sem ) 
{ __s32 tmp ;

  {
  {
#line 186
  tmp = -1;
#line 187
  __asm__  volatile   ("# beginning __up_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  jns        1f\n\t"
                       "  call call_rwsem_wake\n"
                       "1:\n"
                       "# ending __up_read\n": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
#line 197
  return;
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __up_write(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 204
  __asm__  volatile   ("# beginning __up_write\n\t"
                       "  movl      %2,%%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xaddl     %%edx,(%%eax)\n\t"
                       "  jz       1f\n"
                       "  call call_rwsem_wake\n"
                       "1:\n\t"
                       "# ending __up_write\n": "+m" (sem->count): "a" (sem), "i" (65535): "memory",
                       "cc", "edx");
  }
#line 216
  return;
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 223
  __asm__  volatile   ("# beginning __downgrade_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  addl      %2,(%%eax)\n\t"
                       "  jns       1f\n\t"
                       "  call call_rwsem_downgrade_wake\n"
                       "1:\n\t"
                       "# ending __downgrade_write\n": "+m" (sem->count): "a" (sem),
                       "i" (65536): "memory", "cc");
  }
#line 233
  return;
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void rwsem_atomic_add(int delta , struct rw_semaphore *sem ) 
{ 

  {
  {
#line 240
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (sem->count): "ir" (delta));
  }
#line 243
  return;
}
}
#line 248 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int rwsem_atomic_update(int delta , struct rw_semaphore *sem ) 
{ int tmp ;

  {
  {
#line 250
  tmp = delta;
#line 252
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xadd %0,%1": "+r" (tmp), "+m" (sem->count): : "memory");
  }
#line 256
  return (tmp + delta);
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int rwsem_is_locked(struct rw_semaphore *sem ) 
{ 

  {
#line 261
  return (sem->count != 0L);
}
}
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rwsem.h"
extern void down_read(struct rw_semaphore *sem ) ;
#line 33
extern int down_read_trylock(struct rw_semaphore *sem ) ;
#line 38
extern void down_write(struct rw_semaphore *sem ) ;
#line 43
extern int down_write_trylock(struct rw_semaphore *sem ) ;
#line 48
extern void up_read(struct rw_semaphore *sem ) ;
#line 53
extern void up_write(struct rw_semaphore *sem ) ;
#line 58
extern void downgrade_write(struct rw_semaphore *sem ) ;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/srcu.h"
extern int init_srcu_struct(struct srcu_struct *sp ) ;
#line 47
extern void cleanup_srcu_struct(struct srcu_struct *sp ) ;
#line 48
extern int srcu_read_lock(struct srcu_struct *sp ) ;
#line 49
extern void srcu_read_unlock(struct srcu_struct *sp , int idx ) ;
#line 50
extern void synchronize_srcu(struct srcu_struct *sp ) ;
#line 51
extern long srcu_batches_completed(struct srcu_struct *sp ) ;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh ) ;
#line 115
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
#line 117
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh , struct notifier_block *nb ) ;
#line 119
extern int raw_notifier_chain_register(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
#line 121
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
#line 124
extern int blocking_notifier_chain_cond_register(struct blocking_notifier_head *nh ,
                                                 struct notifier_block *nb ) ;
#line 128
extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
#line 130
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh ,
                                              struct notifier_block *nb ) ;
#line 132
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
#line 134
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
#line 137
extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                      void *v ) ;
#line 139
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                        void *v , int nr_to_call , int *nr_calls ) ;
#line 141
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                        void *v ) ;
#line 143
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                          void *v , int nr_to_call , int *nr_calls ) ;
#line 145
extern int raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                   void *v ) ;
#line 147
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                     void *v , int nr_to_call , int *nr_calls ) ;
#line 149
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                    void *v ) ;
#line 151
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                      void *v , int nr_to_call , int *nr_calls ) ;
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
__inline static int notifier_from_errno(int err ) 
{ 

  {
#line 167
  return (32768 | (1 - err));
}
}
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
__inline static int notifier_to_errno(int ret ) 
{ int tmp ;

  {
  {
#line 173
  ret &= -32769;
  }
#line 174
  if (ret > 1) {
    {
#line 174
    tmp = 1 - ret;
    }
  } else {
    {
#line 174
    tmp = 0;
    }
  }
#line 174
  return (tmp);
}
}
#line 258
extern struct blocking_notifier_head reboot_notifier_list ;
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_lock(struct pglist_data *p , unsigned long *f ) 
{ 

  {
#line 165
  return;
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_unlock(struct pglist_data *p , unsigned long *f ) 
{ 

  {
#line 166
  return;
}
}
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_init(struct pglist_data *pgdat ) 
{ 

  {
#line 167
  return;
}
}
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static unsigned int zone_span_seqbegin(struct zone *zone ) 
{ 

  {
#line 171
  return (0U);
}
}
#line 173 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static int zone_span_seqretry(struct zone *zone , unsigned int iv ) 
{ 

  {
#line 175
  return (0);
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_span_writelock(struct zone *zone ) 
{ 

  {
#line 177
  return;
}
}
#line 178 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_span_writeunlock(struct zone *zone ) 
{ 

  {
#line 178
  return;
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_seqlock_init(struct zone *zone ) 
{ 

  {
#line 179
  return;
}
}
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static int mhp_notimplemented(char const   *func ) 
{ 

  {
  {
#line 183
  printk("<4>%s() called, with CONFIG_MEMORY_HOTPLUG disabled\n", func);
#line 184
  dump_stack();
  }
#line 185
  return (-38);
}
}
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void register_page_bootmem_info_node(struct pglist_data *pgdat ) 
{ 

  {
#line 190
  return;
}
}
#line 198
extern int walk_memory_resource(unsigned long start_pfn , unsigned long nr_pages ,
                                void *arg , int (*func)(unsigned long  , unsigned long  ,
                                                        void * ) ) ;
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static int is_mem_section_removable(unsigned long pfn , unsigned long nr_pages ) 
{ 

  {
#line 210
  return (0);
}
}
#line 214
extern int add_memory(int nid , u64 start , u64 size ) ;
#line 215
extern int arch_add_memory(int nid , u64 start , u64 size ) ;
#line 216
extern int remove_memory(u64 start , u64 size ) ;
#line 217
extern int sparse_add_one_section(struct zone *zone , unsigned long start_pfn , int nr_pages ) ;
#line 219
extern void sparse_remove_one_section(struct zone *zone , struct mem_section *ms ) ;
#line 220
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map , unsigned long pnum ) ;
#line 646 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
extern void get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ) ;
#line 648
extern void build_all_zonelists(void) ;
#line 649
extern void wakeup_kswapd(struct zone *zone , int order ) ;
#line 650
extern int zone_watermark_ok(struct zone *z , int order , unsigned long mark , int classzone_idx ,
                             int alloc_flags ) ;
#line 656
extern int init_currently_empty_zone(struct zone *zone , unsigned long start_pfn ,
                                     unsigned long size , enum memmap_context context ) ;
#line 663 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static void memory_present(int nid , unsigned long start , unsigned long end ) 
{ 

  {
#line 663
  return;
}
}
#line 675 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int populated_zone(struct zone *zone ) 
{ 

  {
#line 677
  return (! (! zone->present_pages));
}
}
#line 680
extern int movable_zone ;
#line 682 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_movable_is_highmem(void) 
{ 

  {
#line 685
  return (movable_zone == 2);
}
}
#line 691 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_highmem_idx(enum zone_type idx ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 694
  if ((unsigned int )idx == 2U) {
    {
#line 694
    tmp___0 = 1;
    }
  } else {
#line 694
    if ((unsigned int )idx == 3U) {
      {
#line 694
      tmp = zone_movable_is_highmem();
      }
#line 694
      if (tmp) {
        {
#line 694
        tmp___0 = 1;
        }
      } else {
        {
#line 694
        tmp___0 = 0;
        }
      }
    } else {
      {
#line 694
      tmp___0 = 0;
      }
    }
  }
#line 694
  return (tmp___0);
}
}
#line 701 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_normal_idx(enum zone_type idx ) 
{ 

  {
#line 703
  return ((unsigned int )idx == 1U);
}
}
#line 712 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_highmem(struct zone *zone ) 
{ int zone_off ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 715
  zone_off = (char *)zone - (char *)((zone->zone_pgdat)->node_zones);
  }
#line 716
  if ((unsigned long )zone_off == 2UL * sizeof(*zone)) {
    {
#line 716
    tmp___0 = 1;
    }
  } else {
#line 716
    if ((unsigned long )zone_off == 3UL * sizeof(*zone)) {
      {
#line 716
      tmp = zone_movable_is_highmem();
      }
#line 716
      if (tmp) {
        {
#line 716
        tmp___0 = 1;
        }
      } else {
        {
#line 716
        tmp___0 = 0;
        }
      }
    } else {
      {
#line 716
      tmp___0 = 0;
      }
    }
  }
#line 716
  return (tmp___0);
}
}
#line 724 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_normal(struct zone *zone ) 
{ 

  {
#line 726
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 1));
}
}
#line 729 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_dma32(struct zone *zone ) 
{ 

  {
#line 734
  return (0);
}
}
#line 738 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_dma(struct zone *zone ) 
{ 

  {
#line 741
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 0));
}
}
#line 750
extern int min_free_kbytes_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                          void * , size_t * , loff_t * ) ;
#line 752
extern int sysctl_lowmem_reserve_ratio[3] ;
#line 753
extern int lowmem_reserve_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                               void * , size_t * , loff_t * ) ;
#line 755
extern int percpu_pagelist_fraction_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                   void * , size_t * , loff_t * ) ;
#line 757
extern int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                    void * , size_t * , loff_t * ) ;
#line 759
extern int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                void * , size_t * , loff_t * ) ;
#line 762
extern int numa_zonelist_order_handler(struct ctl_table * , int  , struct file * ,
                                       void * , size_t * , loff_t * ) ;
#line 764
extern char numa_zonelist_order[] ;
#line 769
extern struct pglist_data contig_page_data ;
#line 779
extern struct pglist_data *first_online_pgdat(void) ;
#line 780
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat ) ;
#line 781
extern struct zone *next_zone(struct zone *zone ) ;
#line 811 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static struct zone *zonelist_zone(struct zoneref *zoneref ) 
{ 

  {
#line 813
  return (zoneref->zone);
}
}
#line 816 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zonelist_zone_idx(struct zoneref *zoneref ) 
{ 

  {
#line 818
  return (zoneref->zone_idx);
}
}
#line 821 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zonelist_node_idx(struct zoneref *zoneref ) 
{ 

  {
#line 827
  return (0);
}
}
#line 844
extern struct zoneref *next_zones_zonelist(struct zoneref *z , enum zone_type highest_zoneidx ,
                                           nodemask_t *nodes , struct zone **zone ) ;
#line 861 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static struct zoneref *first_zones_zonelist(struct zonelist *zonelist , enum zone_type highest_zoneidx ,
                                                     nodemask_t *nodes , struct zone **zone ) 
{ struct zoneref *tmp ;

  {
  {
#line 866
  tmp = next_zones_zonelist(zonelist->_zonerefs, highest_zoneidx, nodes, zone);
  }
#line 866
  return (tmp);
}
}
#line 1086
extern unsigned long node_memmap_size_bytes(int  , unsigned long  , unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int memmap_valid_within(unsigned long pfn , struct page *page , struct zone *zone ) 
{ 

  {
#line 1122
  return (1);
}
}
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
extern void cpu_idle(void) ;
#line 25
extern unsigned int total_cpus ;
#line 27
extern int smp_call_function_single(int cpuid , void (*func)(void *info ) , void *info ,
                                    int wait ) ;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
extern int apic_version[256] ;
#line 9
extern int pic_mode ;
#line 25
extern unsigned int def_to_bigsmp ;
#line 26
extern u8 apicid_2_node[] ;
#line 44
extern void early_find_smp_config(void) ;
#line 45
extern void early_get_smp_config(void) ;
#line 51
extern unsigned long mp_bus_not_pci[((260UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 53
extern unsigned int boot_cpu_physical_apicid ;
#line 54
extern unsigned int max_physical_apicid ;
#line 55
extern int smp_found_config ;
#line 56
extern int mpc_default_type ;
#line 57
extern unsigned long mp_lapic_addr ;
#line 59
extern void get_smp_config(void) ;
#line 62
extern void find_smp_config(void) ;
#line 63
extern void early_reserve_e820_mpc_new(void) ;
#line 69
extern void generic_processor_info(int apicid , int version )  __attribute__((__section__(".cpuinit.text"))) ;
#line 71
extern void mp_register_ioapic(int id , u32 address , u32 gsi_base ) ;
#line 72
extern void mp_override_legacy_irq(u8 bus_irq , u8 polarity , u8 trigger , u32 gsi ) ;
#line 74
extern void mp_config_acpi_legacy_irqs(void) ;
#line 75
extern int mp_register_gsi(u32 gsi , int edge_level , int active_high_low ) ;
#line 76
extern int acpi_probe_gsi(void) ;
#line 78
extern int mp_config_acpi_gsi(unsigned char number , unsigned int devfn , u8 pin ,
                              u32 gsi , int triggering , int polarity ) ;
#line 80
extern int mp_find_ioapic(int gsi ) ;
#line 81
extern int mp_find_ioapic_pin(int ioapic , int gsi ) ;
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
__inline static void physid_set_mask_of_physid(int physid , physid_mask_t *map ) 
{ 

  {
  {
#line 157
  bitmap_zero(map->mask, 256);
#line 158
  set_bit((unsigned int )physid, (unsigned long volatile   *)(map->mask));
  }
#line 159
  return;
}
}
#line 164
extern physid_mask_t phys_cpu_present_map ;
#line 166
extern int generic_mps_oem_check(struct mpc_table * , char * , char * ) ;
#line 168
extern int default_acpi_madt_oem_check(char * , char * ) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/delay.h"
extern unsigned long loops_per_jiffy ;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/delay.h"
extern void __bad_udelay(void) ;
#line 12
extern void __bad_ndelay(void) ;
#line 14
extern void __udelay(unsigned long usecs ) ;
#line 15
extern void __ndelay(unsigned long nsecs ) ;
#line 16
extern void __const_udelay(unsigned long xloops ) ;
#line 17
extern void __delay(unsigned long loops ) ;
#line 29
extern void use_tsc_delay(void) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/delay.h"
extern unsigned long lpj_fine ;
#line 45
extern void calibrate_delay(void) ;
#line 46
extern void msleep(unsigned int msecs ) ;
#line 47
extern unsigned long msleep_interruptible(unsigned int msecs ) ;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 

  {
  {
#line 51
  msleep(seconds * 1000U);
  }
#line 52
  return;
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
extern void (*pm_idle)(void) ;
#line 30
extern void (*pm_power_off)(void) ;
#line 31
extern void (*pm_power_off_prepare)(void) ;
#line 383
extern void device_pm_lock(void) ;
#line 384
extern int sysdev_resume(void) ;
#line 385
extern void device_power_up(pm_message_t state ) ;
#line 386
extern void device_resume(pm_message_t state ) ;
#line 388
extern void device_pm_unlock(void) ;
#line 389
extern int sysdev_suspend(pm_message_t state ) ;
#line 390
extern int device_power_down(pm_message_t state ) ;
#line 391
extern int device_suspend(pm_message_t state ) ;
#line 392
extern int device_prepare_suspend(pm_message_t state ) ;
#line 394
extern void __suspend_report_result(char const   *function , void *fn , int ret ) ;
#line 427
extern unsigned int pm_flags ;
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/numa_32.h"
extern int pxm_to_nid(int pxm ) ;
#line 5
extern void numa_remove_cpu(int cpu ) ;
#line 8
extern void set_highmem_pages_init(void) ;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mmu.h"
extern void leave_mm(int cpu ) ;
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
extern int __acpi_acquire_global_lock(unsigned int *lock ) ;
#line 58
extern int __acpi_release_global_lock(unsigned int *lock ) ;
#line 83
extern int acpi_lapic ;
#line 84
extern int acpi_ioapic ;
#line 85
extern int acpi_noirq ;
#line 86
extern int acpi_strict ;
#line 87
extern int acpi_disabled ;
#line 88
extern int acpi_ht ;
#line 89
extern int acpi_pci_disabled ;
#line 90
extern int acpi_skip_timer_override ;
#line 91
extern int acpi_use_timer_override ;
#line 93
extern u8 acpi_sci_flags ;
#line 94
extern int acpi_sci_override_gsi ;
#line 95
extern void acpi_pic_sci_set_trigger(unsigned int  , u16  ) ;
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void disable_acpi(void) 
{ 

  {
  {
#line 99
  acpi_disabled = 1;
#line 100
  acpi_ht = 0;
#line 101
  acpi_pci_disabled = 1;
#line 102
  acpi_noirq = 1;
  }
#line 103
  return;
}
}
#line 105
extern int acpi_gsi_to_irq(u32 gsi , unsigned int *irq ) ;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_noirq_set(void) 
{ 

  {
  {
#line 107
  acpi_noirq = 1;
  }
#line 107
  return;
}
}
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_disable_pci(void) 
{ 

  {
  {
#line 110
  acpi_pci_disabled = 1;
#line 111
  acpi_noirq_set();
  }
#line 112
  return;
}
}
#line 115
extern int acpi_save_state_mem(void) ;
#line 116
extern void acpi_restore_state_mem(void) ;
#line 118
extern unsigned long acpi_wakeup_address ;
#line 121
extern void acpi_reserve_bootmem(void) ;
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static unsigned int acpi_processor_cstate_check(unsigned int max_cstate ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 134
  if ((int )boot_cpu_data.x86 == 15) {
#line 134
    if ((int )boot_cpu_data.x86_vendor == 2) {
#line 134
      if ((int )boot_cpu_data.x86_model <= 5) {
#line 134
        if ((int )boot_cpu_data.x86_mask < 10) {
#line 138
          return (1U);
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    _L___7: /* CIL Label */ 
    _L___6: /* CIL Label */ 
#line 139
    if (117 >> 5 == 0) {
#line 139
      if ((1UL << 21) & (unsigned long )(1 | (1 << 15))) {
        {
#line 139
        tmp___1 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 139
      if (117 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
#line 139
        if (117 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
#line 139
          if (117 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
#line 139
            if (117 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
#line 139
              if (117 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
#line 139
                if (117 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
#line 139
                  if (117 >> 5 == 7) {
                    {
#line 139
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 139
                    tmp___1 = tmp;
                    }
                  } else {
                    {
#line 139
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 139
                    tmp___1 = tmp;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 139
    if (tmp___1) {
#line 140
      return (1U);
    } else {
#line 142
      return (max_cstate);
    }
  }
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_fake_nodes(struct bootnode  const  *fake_nodes , int num_nodes ) 
{ 

  {
#line 169
  return;
}
}
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
extern unsigned long __FIXADDR_TOP ;
#line 139
extern void reserve_top_address(unsigned long reserve ) ;
#line 146
extern int fixmaps_set ;
#line 148
extern pte_t *kmap_pte ;
#line 149
extern pgprot_t kmap_prot ;
#line 150
extern pte_t *pkmap_page_table ;
#line 152
extern void __native_set_fixmap(enum fixed_addresses idx , pte_t pte ) ;
#line 153
extern void native_set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) ;
#line 157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
__inline static void __set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) 
{ 

  {
  {
#line 160
  native_set_fixmap(idx, phys, flags);
  }
#line 161
  return;
}
}
#line 179
extern void __this_fixmap_does_not_exist(void) ;
#line 186 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
__inline static unsigned long fix_to_virt(unsigned int idx ) 
{ 

  {
#line 197
  if (idx >= 514U) {
    {
#line 198
    __this_fixmap_does_not_exist();
    }
  }
#line 200
  return (__FIXADDR_TOP - (unsigned long )(idx << 12));
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
__inline static unsigned long virt_to_fix(unsigned long vaddr ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
#line 205
  while (1) {
    while_22_continue: /* CIL Label */ ;
#line 205
    if (vaddr >= __FIXADDR_TOP) {
      {
#line 205
      tmp = 1;
      }
    } else {
#line 205
      if (vaddr < __FIXADDR_TOP - (unsigned long )(176 << 12)) {
        {
#line 205
        tmp = 1;
        }
      } else {
        {
#line 205
        tmp = 0;
        }
      }
    }
    {
#line 205
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
#line 205
    if (tmp___0) {
      {
#line 205
      while (1) {
        while_23_continue: /* CIL Label */ ;
        {
#line 205
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"),
                             "i" (205), "i" (sizeof(struct bug_entry )));
        }
        {
#line 205
        while (1) {
          while_24_continue: /* CIL Label */ ;
        }
        while_24_break: /* CIL Label */ ;
        }
        goto while_23_break;
      }
      while_23_break: /* CIL Label */ ;
      }
    }
    goto while_22_break;
  }
  while_22_break: /* CIL Label */ ;
  }
#line 206
  return ((__FIXADDR_TOP - (vaddr & ~ ((1UL << 12) - 1UL))) >> 12);
}
}
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
extern void generic_apic_probe(void) ;
#line 49
extern unsigned int apic_verbosity ;
#line 50
extern int local_apic_timer_c2_ok ;
#line 52
extern int disable_apic ;
#line 55
extern void __inquire_remote_apic(int apicid ) ;
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void default_inquire_remote_apic(int apicid ) 
{ 

  {
#line 64
  if (apic_verbosity >= 2U) {
    {
#line 65
    __inquire_remote_apic(apicid);
    }
  }
#line 66
  return;
}
}
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int is_vsmp_box(void) 
{ 

  {
#line 83
  return (0);
}
}
#line 86
extern void xapic_wait_icr_idle(void) ;
#line 87
extern u32 safe_xapic_wait_icr_idle(void) ;
#line 88
extern void xapic_icr_write(u32  , u32  ) ;
#line 89
extern int setup_profiling_timer(unsigned int  ) ;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void native_apic_mem_write(u32 reg , u32 v ) 
{ u32 volatile   *addr ;
  unsigned long tmp ;

  {
  {
#line 93
  tmp = fix_to_virt(4U);
#line 93
  addr = (u32 volatile   *)(tmp + (unsigned long )reg);
#line 95
  __asm__  volatile   ("661:\n\t"
                       "movl %0, %1"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c[feat]\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "xchgl %0, %1"
                       "\n664:\n"
                       ".previous": "=r" (v), "=m" (*addr): [feat] "i" (115), "0" (v),
                       "m" (*addr));
  }
#line 98
  return;
}
}
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 native_apic_mem_read(u32 reg ) 
{ unsigned long tmp ;

  {
  {
#line 102
  tmp = fix_to_virt(4U);
  }
#line 102
  return ((unsigned int )*((u32 volatile   *)(tmp + (unsigned long )reg)));
}
}
#line 105
extern void native_apic_wait_icr_idle(void) ;
#line 106
extern u32 native_safe_apic_wait_icr_idle(void) ;
#line 107
extern void native_apic_icr_write(u32 low , u32 id ) ;
#line 108
extern u64 native_apic_icr_read(void) ;
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void check_x2apic(void) 
{ 

  {
#line 189
  return;
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void enable_x2apic(void) 
{ 

  {
#line 192
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void enable_IR_x2apic(void) 
{ 

  {
#line 195
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int x2apic_enabled(void) 
{ 

  {
#line 198
  return (0);
}
}
#line 205
extern int get_physical_broadcast(void) ;
#line 215
extern int lapic_get_maxlvt(void) ;
#line 216
extern void clear_local_APIC(void) ;
#line 217
extern void connect_bsp_APIC(void) ;
#line 218
extern void disconnect_bsp_APIC(int virt_wire_setup ) ;
#line 219
extern void disable_local_APIC(void) ;
#line 220
extern void lapic_shutdown(void) ;
#line 221
extern int verify_local_APIC(void) ;
#line 222
extern void cache_APIC_registers(void) ;
#line 223
extern void sync_Arb_IDs(void) ;
#line 224
extern void init_bsp_APIC(void) ;
#line 225
extern void setup_local_APIC(void) ;
#line 226
extern void end_local_APIC_setup(void) ;
#line 227
extern void init_apic_mappings(void) ;
#line 228
extern void setup_boot_APIC_clock(void) ;
#line 229
extern void setup_secondary_APIC_clock(void) ;
#line 230
extern int APIC_init_uniprocessor(void) ;
#line 231
extern void enable_NMI_through_LVT0(void) ;
#line 240 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int apic_is_clustered_box(void) 
{ 

  {
#line 242
  return (0);
}
}
#line 246
extern u8 setup_APIC_eilvt_mce(u8 vector , u8 msg_type , u8 mask ) ;
#line 247
extern u8 setup_APIC_eilvt_ibs(u8 vector , u8 msg_type , u8 mask ) ;
#line 355
extern struct apic *apic ;
#line 361
extern atomic_t init_deasserted ;
#line 362
extern int wakeup_secondary_cpu_via_nmi(int apicid , unsigned long start_eip ) ;
#line 365 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 apic_read(u32 reg ) 
{ u32 tmp ;

  {
  {
#line 367
  tmp = (*(apic->read))(reg);
  }
#line 367
  return (tmp);
}
}
#line 370 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_write(u32 reg , u32 val ) 
{ 

  {
  {
#line 372
  (*(apic->write))(reg, val);
  }
#line 373
  return;
}
}
#line 375 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u64 apic_icr_read(void) 
{ u64 tmp ;

  {
  {
#line 377
  tmp = (*(apic->icr_read))();
  }
#line 377
  return (tmp);
}
}
#line 380 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_icr_write(u32 low , u32 high ) 
{ 

  {
  {
#line 382
  (*(apic->icr_write))(low, high);
  }
#line 383
  return;
}
}
#line 385 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_wait_icr_idle(void) 
{ 

  {
  {
#line 387
  (*(apic->wait_icr_idle))();
  }
#line 388
  return;
}
}
#line 390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 safe_apic_wait_icr_idle(void) 
{ u32 tmp ;

  {
  {
#line 392
  tmp = (*(apic->safe_wait_icr_idle))();
  }
#line 392
  return (tmp);
}
}
#line 396 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void ack_APIC_irq(void) 
{ 

  {
  {
#line 405
  apic_write(176U, 0U);
  }
#line 407
  return;
}
}
#line 409 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int default_get_apic_id(unsigned long x ) 
{ unsigned int ver ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 411
  tmp = apic_read(48U);
#line 411
  ver = tmp & 255U;
  }
#line 413
  if (ver >= 20U) {
#line 414
    return ((unsigned int )((x >> 24) & 255UL));
  } else {
#line 413
    if (122 >> 5 == 0) {
#line 413
      if ((1UL << 26) & (unsigned long )(1 | (1 << 15))) {
        {
#line 413
        tmp___2 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 413
      if (122 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
#line 413
        if (122 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
#line 413
          if (122 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
#line 413
            if (122 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
#line 413
              if (122 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
#line 413
                if (122 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
#line 413
                  if (122 >> 5 == 7) {
                    {
#line 413
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 413
                    tmp___2 = tmp___0;
                    }
                  } else {
                    {
#line 413
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 413
                    tmp___2 = tmp___0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 413
    if (tmp___2) {
#line 414
      return ((unsigned int )((x >> 24) & 255UL));
    } else {
#line 416
      return ((unsigned int )((x >> 24) & 15UL));
    }
  }
}
}
#line 441 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void default_wait_for_init_deassert(atomic_t *deassert ) 
{ 

  {
  {
#line 443
  while (1) {
    while_25_continue: /* CIL Label */ ;
#line 443
    if (! (! deassert->counter)) {
      goto while_25_break;
    }
    {
#line 444
    cpu_relax();
    }
  }
  while_25_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 448
extern void generic_bigsmp_probe(void) ;
#line 457 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static struct cpumask  const  *default_target_cpus(void) 
{ 

  {
#line 460
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
#line 466
extern u16 per_cpu__x86_bios_cpu_apicid  __attribute__((__section__(".data.percpu"))) ;
#line 466
extern u16 *x86_bios_cpu_apicid_early_ptr ;
#line 466
extern u16 x86_bios_cpu_apicid_early_map[] ;
#line 469 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int read_apic_id(void) 
{ unsigned int reg ;
  unsigned int tmp ;

  {
  {
#line 473
  reg = apic_read(32U);
#line 475
  tmp = (*(apic->get_apic_id))((unsigned long )reg);
  }
#line 475
  return (tmp);
}
}
#line 478
extern void default_setup_apic_routing(void) ;
#line 488
extern void default_init_apic_ldr(void) ;
#line 490 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_apic_id_registered(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 492
  tmp___2 = read_apic_id();
#line 492
  tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
#line 492
  return (tmp___3);
}
}
#line 495 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_phys_pkg_id(int cpuid_apic , int index_msb ) 
{ 

  {
#line 497
  return (cpuid_apic >> index_msb);
}
}
#line 500
extern int default_apicid_to_node(int logical_apicid ) ;
#line 504 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int default_cpu_mask_to_apicid(struct cpumask  const  *cpumask ) 
{ 

  {
#line 507
  return ((unsigned int )(cpumask->bits[0] & 255UL));
}
}
#line 510 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int default_cpu_mask_to_apicid_and(struct cpumask  const  *cpumask ,
                                                            struct cpumask  const  *andmask ) 
{ unsigned long mask1 ;
  unsigned long mask2 ;
  unsigned long mask3 ;

  {
  {
#line 514
  mask1 = cpumask->bits[0];
#line 515
  mask2 = andmask->bits[0];
#line 516
  mask3 = cpu_online_mask->bits[0];
  }
#line 518
  return ((unsigned int )((mask1 & mask2) & mask3));
}
}
#line 521 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned long default_check_apicid_used(physid_mask_t bitmap , int apicid ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 523
  tmp___0 = variable_test_bit(apicid, (unsigned long const volatile   *)(bitmap.mask));
  }
#line 523
  return ((unsigned long )tmp___0);
}
}
#line 526 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned long default_check_apicid_present(int bit ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 528
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
#line 528
  return ((unsigned long )tmp___0);
}
}
#line 531 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static physid_mask_t default_ioapic_phys_id_map(physid_mask_t phys_map ) 
{ 

  {
#line 533
  return (phys_map);
}
}
#line 537 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_cpu_to_logical_apicid(int cpu ) 
{ 

  {
#line 539
  return (1 << cpu);
}
}
#line 542 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int __default_cpu_present_to_apicid(int mps_cpu ) 
{ unsigned long __ptr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 544
  if (mps_cpu < nr_cpu_ids) {
    {
#line 544
    tmp___2 = cpumask_check((unsigned int )mps_cpu);
#line 544
    tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(cpu_present_mask->bits));
    }
#line 544
    if (tmp___3) {
      {
#line 545
      __asm__  ("": "=r" (__ptr): "0" (& per_cpu__x86_bios_cpu_apicid));
      }
#line 545
      return ((int )*((u16 *)(__ptr + __per_cpu_offset[mps_cpu])));
    } else {
#line 547
      return (255);
    }
  } else {
#line 547
    return (255);
  }
}
}
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int __default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 553
  tmp___0 = variable_test_bit(boot_cpu_physical_apicid___0, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
#line 553
  return (tmp___0);
}
}
#line 557 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_cpu_present_to_apicid(int mps_cpu ) 
{ int tmp ;

  {
  {
#line 559
  tmp = __default_cpu_present_to_apicid(mps_cpu);
  }
#line 559
  return (tmp);
}
}
#line 562 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;

  {
  {
#line 565
  tmp = __default_check_phys_apicid_present(boot_cpu_physical_apicid___0);
  }
#line 565
  return (tmp);
}
}
#line 572 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static physid_mask_t default_apicid_to_cpu_present(int phys_apicid ) 
{ physid_mask_t __physid_mask ;

  {
  {
#line 574
  __physid_mask.mask[0] = 0UL;
#line 574
  __physid_mask.mask[1] = 0UL;
#line 574
  __physid_mask.mask[2] = 0UL;
#line 574
  __physid_mask.mask[3] = 0UL;
#line 574
  set_bit((unsigned int )phys_apicid, (unsigned long volatile   *)(__physid_mask.mask));
  }
#line 574
  return (__physid_mask);
}
}
#line 580
extern u8 cpu_2_logical_apicid[8] ;
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_vectors.h"
__inline static int invalid_vm86_irq(int irq ) 
{ int tmp ;

  {
#line 136
  if (irq < 3) {
    {
#line 136
    tmp = 1;
    }
  } else {
#line 136
    if (irq > 15) {
      {
#line 136
      tmp = 1;
      }
    } else {
      {
#line 136
      tmp = 0;
      }
    }
  }
#line 136
  return (tmp);
}
}
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
extern int nr_ioapics ;
#line 115
extern int nr_ioapic_registers[64] ;
#line 120
extern struct mpc_ioapic mp_ioapics[64] ;
#line 123
extern int mp_irq_entries ;
#line 126
extern struct mpc_intsrc mp_irqs[256] ;
#line 132
extern int sis_apic_bug ;
#line 135
extern int skip_ioapic_setup ;
#line 138
extern int noioapicquirk ;
#line 141
extern int noioapicreroute ;
#line 144
extern int timer_through_8259 ;
#line 154
extern int io_apic_get_unique_id(int ioapic , int apic_id ) ;
#line 155
extern int io_apic_get_version(int ioapic ) ;
#line 156
extern int io_apic_get_redir_entries(int ioapic ) ;
#line 157
extern int io_apic_set_pci_routing(int ioapic , int pin , int irq , int edge_level ,
                                   int active_high_low ) ;
#line 161
extern int (*ioapic_renumber_irq)(int ioapic , int irq ) ;
#line 162
extern void ioapic_init_mappings(void) ;
#line 163
extern void ioapic_insert_resources(void) ;
#line 175
extern void probe_nr_irqs_gsi(void) ;
#line 177
extern int setup_ioapic_entry(int apic , int irq , struct IO_APIC_route_entry *entry ,
                              unsigned int destination , int trigger , int polarity ,
                              int vector , int pin ) ;
#line 181
extern void ioapic_write_entry(int apic , int pin , struct IO_APIC_route_entry e ) ;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cpumask.h"
extern cpumask_var_t cpu_callin_mask ;
#line 7
extern cpumask_var_t cpu_callout_mask ;
#line 8
extern cpumask_var_t cpu_initialized_mask ;
#line 9
extern cpumask_var_t cpu_sibling_setup_mask ;
#line 11
extern void setup_cpu_local_masks(void) ;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
extern int smp_num_siblings ;
#line 22
extern unsigned int num_processors ;
#line 24
extern cpumask_var_t per_cpu__cpu_sibling_map  __attribute__((__section__(".data.percpu"))) ;
#line 25
extern cpumask_var_t per_cpu__cpu_core_map  __attribute__((__section__(".data.percpu"))) ;
#line 26
extern u16 per_cpu__cpu_llc_id  __attribute__((__section__(".data.percpu"))) ;
#line 27
extern int per_cpu__cpu_number  __attribute__((__section__(".data.percpu"))) ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static struct cpumask *cpu_sibling_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 31
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_sibling_map));
  }
#line 31
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static struct cpumask *cpu_core_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 36
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_core_map));
  }
#line 36
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 39
extern u16 per_cpu__x86_cpu_to_apicid  __attribute__((__section__(".data.percpu"))) ;
#line 39
extern u16 *x86_cpu_to_apicid_early_ptr ;
#line 39
extern u16 x86_cpu_to_apicid_early_map[] ;
#line 43
extern struct __anonstruct_stack_start_91 stack_start ;
#line 66
extern void set_cpu_sibling_map(int cpu ) ;
#line 72
extern struct smp_ops smp_ops ;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_send_stop(void) 
{ 

  {
  {
#line 76
  (*(smp_ops.smp_send_stop))();
  }
#line 77
  return;
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_prepare_boot_cpu(void) 
{ 

  {
  {
#line 81
  (*(smp_ops.smp_prepare_boot_cpu))();
  }
#line 82
  return;
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_prepare_cpus(unsigned int max_cpus ) 
{ 

  {
  {
#line 86
  (*(smp_ops.smp_prepare_cpus))(max_cpus);
  }
#line 87
  return;
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_cpus_done(unsigned int max_cpus ) 
{ 

  {
  {
#line 91
  (*(smp_ops.smp_cpus_done))(max_cpus);
  }
#line 92
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int __cpu_up(unsigned int cpu ) 
{ int tmp ;

  {
  {
#line 96
  tmp = (*(smp_ops.cpu_up))(cpu);
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int __cpu_disable(void) 
{ int tmp ;

  {
  {
#line 101
  tmp = (*(smp_ops.cpu_disable))();
  }
#line 101
  return (tmp);
}
}
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void __cpu_die(unsigned int cpu ) 
{ 

  {
  {
#line 106
  (*(smp_ops.cpu_die))(cpu);
  }
#line 107
  return;
}
}
#line 109 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void play_dead(void) 
{ 

  {
  {
#line 111
  (*(smp_ops.play_dead))();
  }
#line 112
  return;
}
}
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_send_reschedule(int cpu ) 
{ 

  {
  {
#line 116
  (*(smp_ops.smp_send_reschedule))(cpu);
  }
#line 117
  return;
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void arch_send_call_function_single_ipi(int cpu ) 
{ 

  {
  {
#line 121
  (*(smp_ops.send_call_func_single_ipi))(cpu);
  }
#line 122
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void arch_send_call_function_ipi_mask(struct cpumask  const  *mask ) 
{ 

  {
  {
#line 127
  (*(smp_ops.send_call_func_ipi))(mask);
  }
#line 128
  return;
}
}
#line 130
extern void cpu_disable_common(void) ;
#line 131
extern void native_smp_prepare_boot_cpu(void) ;
#line 132
extern void native_smp_prepare_cpus(unsigned int max_cpus ) ;
#line 133
extern void native_smp_cpus_done(unsigned int max_cpus ) ;
#line 134
extern int native_cpu_up(unsigned int cpunum ) ;
#line 135
extern int native_cpu_disable(void) ;
#line 136
extern void native_cpu_die(unsigned int cpu ) ;
#line 137
extern void native_play_dead(void) ;
#line 138
extern void play_dead_common(void) ;
#line 140
extern void native_send_call_func_ipi(struct cpumask  const  *mask ) ;
#line 141
extern void native_send_call_func_single_ipi(int cpu ) ;
#line 143
extern void smp_store_cpu_info(int id ) ;
#line 147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int num_booting_cpus(void) 
{ unsigned int tmp ;

  {
  {
#line 149
  tmp = cpumask_weight((struct cpumask  const  *)(cpu_callout_mask));
  }
#line 149
  return ((int )tmp);
}
}
#line 153
extern unsigned int disabled_cpus  __attribute__((__section__(".cpuinit.data"))) ;
#line 162
extern int safe_smp_processor_id(void) ;
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int logical_smp_processor_id(void) 
{ unsigned long tmp ;

  {
  {
#line 183
  tmp = fix_to_virt(4U);
  }
#line 183
  return ((int )((*((u32 *)(tmp + 208UL)) >> 24) & 255U));
}
}
#line 188
extern int hard_smp_processor_id(void) ;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
extern int smp_call_function(void (*func)(void *info ) , void *info , int wait ) ;
#line 73
extern void smp_call_function_many(struct cpumask  const  *mask , void (*func)(void *info ) ,
                                   void *info , bool wait ) ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
__inline static int smp_call_function_mask(cpumask_t mask , void (*func)(void *info ) ,
                                           void *info , int wait ) 
{ 

  {
  {
#line 81
  smp_call_function_many((struct cpumask  const  *)(& mask), func, info, (_Bool )wait);
  }
#line 82
  return (0);
}
}
#line 85
extern void __smp_call_function_single(int cpuid , struct call_single_data *data ,
                                       int wait ) ;
#line 92
extern void generic_smp_call_function_single_interrupt(void) ;
#line 93
extern void generic_smp_call_function_interrupt(void) ;
#line 94
extern void ipi_call_lock(void) ;
#line 95
extern void ipi_call_unlock(void) ;
#line 96
extern void ipi_call_lock_irq(void) ;
#line 97
extern void ipi_call_unlock_irq(void) ;
#line 103
extern int on_each_cpu(void (*func)(void *info ) , void *info , int wait ) ;
#line 121
extern unsigned int setup_max_cpus ;
#line 186
extern void arch_disable_smp_support(void) ;
#line 188
extern void smp_setup_processor_id(void) ;
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int numa_node_id(void) 
{ 

  {
#line 162
  return (0);
}
}
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int cpu_to_node(int cpu ) 
{ 

  {
#line 167
  return (0);
}
}
#line 170 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int early_cpu_to_node(int cpu ) 
{ 

  {
#line 172
  return (0);
}
}
#line 175 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static struct cpumask  const  *cpumask_of_node(int node ) 
{ 

  {
#line 177
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static void setup_node_to_cpumask_map(void) 
{ 

  {
#line 180
  return;
}
}
#line 186
extern struct cpumask  const  *cpu_coregroup_mask(int cpu ) ;
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static void arch_fix_phys_package_id(int num , u32 slot ) 
{ 

  {
#line 200
  return;
}
}
#line 203
extern void x86_pci_root_bus_res_quirks(struct pci_bus *b ) ;
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int get_mp_bus_to_node(int busnum ) 
{ 

  {
#line 216
  return (0);
}
}
#line 218 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static void set_mp_bus_to_node(int busnum , int node ) 
{ 

  {
#line 220
  return;
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/topology.h"
extern int arch_update_cpu_topology(void) ;
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static int allocflags_to_migratetype(gfp_t gfp_flags ) 
{ int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 105
  __ret_warn_on = ! (! ((gfp_flags & 1572864U) == 1572864U));
#line 105
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 105
  if (tmp) {
    {
#line 105
    warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h",
                       105);
    }
  }
  {
#line 105
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 107
  tmp___0 = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
#line 107
  if (tmp___0) {
#line 108
    return (0);
  }
#line 111
  return ((((gfp_flags & 1048576U) != 0U) << 1) | ((gfp_flags & 524288U) != 0U));
}
}
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static enum zone_type gfp_zone(gfp_t flags ) 
{ 

  {
#line 118
  if (flags & 1U) {
#line 119
    return ((enum zone_type )0);
  }
#line 125
  if ((flags & 1048578U) == 1048578U) {
#line 127
    return ((enum zone_type )3);
  }
#line 129
  if (flags & 2U) {
#line 130
    return ((enum zone_type )2);
  }
#line 132
  return ((enum zone_type )1);
}
}
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ long tmp ;

  {
#line 147
  return (0);
}
}
#line 159 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ int tmp ;

  {
  {
#line 161
  tmp = gfp_zonelist(flags);
  }
#line 161
  return (contig_page_data.node_zonelists + tmp);
}
}
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static void arch_free_page(struct page *page , int order ) 
{ 

  {
#line 165
  return;
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static void arch_alloc_page(struct page *page , int order ) 
{ 

  {
#line 168
  return;
}
}
#line 171
extern struct page *__alloc_pages_internal(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ,
                                           nodemask_t *nodemask ) ;
#line 175 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ struct page *tmp ;

  {
  {
#line 179
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, (nodemask_t *)((void *)0));
  }
#line 179
  return (tmp);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct page *__alloc_pages_nodemask(gfp_t gfp_mask , unsigned int order ,
                                                    struct zonelist *zonelist , nodemask_t *nodemask ) 
{ struct page *tmp ;

  {
  {
#line 186
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, nodemask);
  }
#line 186
  return (tmp);
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ long tmp ;
  int ret__ ;
  struct zonelist *tmp___0 ;
  struct page *tmp___1 ;

  {
  {
#line 193
  tmp = __builtin_expect((long )(! (! (order >= 11U))), 0L);
  }
#line 193
  if (tmp) {
#line 194
    return ((struct page *)((void *)0));
  }
#line 197
  if (nid < 0) {
#line 198
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_26_1;
    } else {
#line 198
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_26_2;
      } else {
#line 198
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_26_4;
        } else {
#line 198
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_26_8;
          } else {
            {
            goto switch_26_default;
#line 198
            if (0) {
              switch_26_1: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_26_break;
              switch_26_2: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_26_break;
              switch_26_4: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_26_break;
              switch_26_8: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_26_break;
              switch_26_default: /* CIL Label */ 
              {
#line 198
              __bad_percpu_size();
              }
            } else {
              switch_26_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 198
    nid = 0;
    }
  }
  {
#line 200
  tmp___0 = node_zonelist(nid, gfp_mask);
#line 200
  tmp___1 = __alloc_pages(gfp_mask, order, tmp___0);
  }
#line 200
  return (tmp___1);
}
}
#line 223
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 224
extern unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 226
extern void *alloc_pages_exact(size_t size , gfp_t gfp_mask ) ;
#line 227
extern void free_pages_exact(void *virt , size_t size ) ;
#line 235
extern void __free_pages(struct page *page , unsigned int order ) ;
#line 236
extern void free_pages(unsigned long addr , unsigned int order ) ;
#line 237
extern void free_hot_page(struct page *page ) ;
#line 238
extern void free_cold_page(struct page *page ) ;
#line 243
extern void page_alloc_init(void) ;
#line 244
extern void drain_zone_pages(struct zone *zone , struct per_cpu_pages *pcp ) ;
#line 245
extern void drain_all_pages(void) ;
#line 246
extern void drain_local_pages(void *dummy ) ;
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
extern void kmem_cache_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 85
extern int slab_is_available(void) ;
#line 87
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 90
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 91
extern int kmem_cache_shrink(struct kmem_cache * ) ;
#line 92
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
#line 93
extern unsigned int kmem_cache_size(struct kmem_cache * ) ;
#line 94
extern char const   *kmem_cache_name(struct kmem_cache * ) ;
#line 95
extern int kmem_ptr_validate(struct kmem_cache *cachep , void const   *ptr ) ;
#line 127
extern void *__krealloc(void const   * , size_t  , gfp_t  ) ;
#line 128
extern void *krealloc(void const   * , size_t  , gfp_t  ) ;
#line 129
extern void kfree(void const   * ) ;
#line 130
extern void kzfree(void const   * ) ;
#line 131
extern size_t ksize(void const   * ) ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/div64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_92 d ;
  u32 upper ;

  {
  {
#line 38
  d.v64 = dividend;
#line 44
  upper = d.v32[1];
#line 45
  d.v32[1] = 0U;
  }
#line 46
  if (upper >= divisor) {
    {
#line 47
    d.v32[1] = upper / divisor;
#line 48
    upper %= divisor;
    }
  }
  {
#line 50
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
#line 52
  return (d.v64);
}
}
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
extern s64 div_s64_rem(s64 dividend , s32 divisor , s32 *remainder ) ;
#line 53
extern u64 div64_u64(u64 dividend , u64 divisor ) ;
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
#line 69
  tmp = div_u64_rem(dividend, divisor, & remainder);
  }
#line 69
  return (tmp);
}
}
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
__inline static s64 div_s64(s64 dividend , s32 divisor ) 
{ s32 remainder ;
  s64 tmp ;

  {
  {
#line 80
  tmp = div_s64_rem(dividend, divisor, & remainder);
  }
#line 80
  return (tmp);
}
}
#line 84
extern u32 iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) ;
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
__inline static u32 __iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) 
{ u32 ret ;

  {
  {
#line 89
  ret = (u32 )0;
  }
  {
#line 91
  while (1) {
    while_27_continue: /* CIL Label */ ;
#line 91
    if (! (dividend >= (u64 )divisor)) {
      goto while_27_break;
    }
    {
#line 94
    __asm__  ("": "+rm" (dividend));
#line 96
    dividend -= (u64 )divisor;
#line 97
    ret ++;
    }
  }
  while_27_break: /* CIL Label */ ;
  }
  {
#line 100
  *remainder = dividend;
  }
#line 102
  return (ret);
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
extern struct timezone sys_tz ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static int timespec_equal(struct timespec  const  *a , struct timespec  const  *b ) 
{ int tmp ;

  {
#line 48
  if (a->tv_sec == b->tv_sec) {
#line 48
    if (a->tv_nsec == b->tv_nsec) {
      {
#line 48
      tmp = 1;
      }
    } else {
      {
#line 48
      tmp = 0;
      }
    }
  } else {
    {
#line 48
    tmp = 0;
    }
  }
#line 48
  return (tmp);
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 

  {
#line 58
  if (lhs->tv_sec < rhs->tv_sec) {
#line 59
    return (-1);
  }
#line 60
  if (lhs->tv_sec > rhs->tv_sec) {
#line 61
    return (1);
  }
#line 62
  return ((int )(lhs->tv_nsec - rhs->tv_nsec));
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static int timeval_compare(struct timeval  const  *lhs , struct timeval  const  *rhs ) 
{ 

  {
#line 67
  if (lhs->tv_sec < rhs->tv_sec) {
#line 68
    return (-1);
  }
#line 69
  if (lhs->tv_sec > rhs->tv_sec) {
#line 70
    return (1);
  }
#line 71
  return ((int )(lhs->tv_usec - rhs->tv_usec));
}
}
#line 74
extern unsigned long mktime(unsigned int year , unsigned int mon , unsigned int day ,
                            unsigned int hour , unsigned int min , unsigned int sec ) ;
#line 78
extern void set_normalized_timespec(struct timespec *ts , time_t sec , long nsec ) ;
#line 79
extern struct timespec timespec_add_safe(struct timespec lhs , struct timespec rhs ) ;
#line 85 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ struct timespec ts_delta ;

  {
  {
#line 89
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, lhs.tv_nsec - rhs.tv_nsec);
  }
#line 91
  return (ts_delta);
}
}
#line 100
extern struct timespec xtime ;
#line 101
extern struct timespec wall_to_monotonic ;
#line 102
extern seqlock_t xtime_lock ;
#line 104
extern unsigned long read_persistent_clock(void) ;
#line 105
extern int update_persistent_clock(struct timespec now ) ;
#line 106
extern int no_sync_cmos_clock  __attribute__((__section__(".data.read_mostly"))) ;
#line 107
extern void timekeeping_init(void) ;
#line 108
extern int timekeeping_suspended ;
#line 110
extern unsigned long get_seconds(void) ;
#line 111
extern struct timespec current_kernel_time(void) ;
#line 116
extern void do_gettimeofday(struct timeval *tv ) ;
#line 117
extern int do_settimeofday(struct timespec *tv ) ;
#line 118
extern int do_sys_settimeofday(struct timespec *tv , struct timezone *tz ) ;
#line 120
extern long do_utimes(int dfd , char *filename , struct timespec *times , int flags ) ;
#line 122
extern int do_setitimer(int which , struct itimerval *value , struct itimerval *ovalue ) ;
#line 124
extern unsigned int alarm_setitimer(unsigned int seconds ) ;
#line 125
extern int do_getitimer(int which , struct itimerval *value ) ;
#line 126
extern void getnstimeofday(struct timespec *tv ) ;
#line 127
extern void getrawmonotonic(struct timespec *ts ) ;
#line 128
extern void getboottime(struct timespec *ts ) ;
#line 129
extern void monotonic_to_bootbased(struct timespec *ts ) ;
#line 131
extern struct timespec timespec_trunc(struct timespec t , unsigned int gran ) ;
#line 132
extern int timekeeping_valid_for_hres(void) ;
#line 133
extern void update_wall_time(void) ;
#line 134
extern void update_xtime_cache(u64 nsec ) ;
#line 137
extern void do_sys_times(struct tms * ) ;
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec  const  *ts ) 
{ 

  {
#line 148
  return ((long long )ts->tv_sec * 1000000000LL + (long long )ts->tv_nsec);
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static s64 timeval_to_ns(struct timeval  const  *tv ) 
{ 

  {
#line 160
  return ((long long )tv->tv_sec * 1000000000LL + (long long )(tv->tv_usec * 1000L));
}
}
#line 170
extern struct timespec ns_to_timespec(s64 nsec ) ;
#line 178
extern struct timeval ns_to_timeval(s64 nsec ) ;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static void timespec_add_ns(struct timespec *a , u64 ns ) 
{ u32 tmp ;

  {
  {
#line 190
  tmp = __iter_div_u64_rem((u64 )a->tv_nsec + ns, 1000000000U, & ns);
#line 190
  a->tv_sec += (__kernel_time_t )tmp;
#line 191
  a->tv_nsec = (long )ns;
  }
#line 192
  return;
}
}
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
extern unsigned int cpu_khz ;
#line 18
extern unsigned int tsc_khz ;
#line 20
extern void disable_TSC(void) ;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles(void) 
{ unsigned long long ret ;

  {
  {
#line 24
  ret = 0ULL;
#line 30
  ret = __native_read_tsc();
  }
#line 32
  return (ret);
}
}
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
__inline static cycles_t vget_cycles(void) 
{ unsigned long long tmp ;

  {
  {
#line 45
  tmp = __native_read_tsc();
  }
#line 45
  return (tmp);
}
}
#line 48
extern void tsc_init(void) ;
#line 49
extern void mark_tsc_unstable(char *reason ) ;
#line 50
extern int unsynchronized_tsc(void) ;
#line 51
extern int check_tsc_unstable(void) ;
#line 57
extern void check_tsc_sync_source(int cpu ) ;
#line 58
extern void check_tsc_sync_target(void) ;
#line 60
extern int notsc_setup(char * ) ;
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timex.h"
extern unsigned long tick_usec ;
#line 211
extern unsigned long tick_nsec ;
#line 212
extern int tickadj ;
#line 217
extern int time_status ;
#line 218
extern long time_maxerror ;
#line 219
extern long time_esterror ;
#line 221
extern long time_adjust ;
#line 223
extern void ntp_init(void) ;
#line 224
extern void ntp_clear(void) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timex.h"
__inline static int ntp_synced(void) 
{ 

  {
#line 232
  return (! (time_status & 64));
}
}
#line 252
extern u64 tick_length ;
#line 254
extern void second_overflow(void) ;
#line 255
extern void update_ntp_one_tick(void) ;
#line 256
extern int do_adjtimex(struct timex * ) ;
#line 261
extern int read_current_timer(unsigned long *timer_val ) ;
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/jiffies.h"
extern u64 jiffies_64  __attribute__((__section__(".data"))) ;
#line 82
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
#line 85
extern u64 get_jiffies_64(void) ;
#line 183
extern unsigned long preset_lpj ;
#line 296
extern unsigned int jiffies_to_msecs(unsigned long j ) ;
#line 297
extern unsigned int jiffies_to_usecs(unsigned long j ) ;
#line 298
extern unsigned long msecs_to_jiffies(unsigned int m ) ;
#line 299
extern unsigned long usecs_to_jiffies(unsigned int u ) ;
#line 300
extern unsigned long timespec_to_jiffies(struct timespec  const  *value ) ;
#line 301
extern void jiffies_to_timespec(unsigned long jiffies , struct timespec *value ) ;
#line 303
extern unsigned long timeval_to_jiffies(struct timeval  const  *value ) ;
#line 304
extern void jiffies_to_timeval(unsigned long jiffies , struct timeval *value ) ;
#line 306
extern clock_t jiffies_to_clock_t(long x ) ;
#line 307
extern unsigned long clock_t_to_jiffies(unsigned long x ) ;
#line 308
extern u64 jiffies_64_to_clock_t(u64 x ) ;
#line 309
extern u64 nsec_to_clock_t(u64 x ) ;
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_set(long secs , unsigned long nsecs ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 87
  __constr_expr_0.tv64 = (long long )secs * 1000000000LL + (long long )nsecs;
  }
#line 87
  return (__constr_expr_0);
}
}
#line 113 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t timespec_to_ktime(struct timespec ts ) 
{ ktime_t tmp ;

  {
  {
#line 115
  tmp = ktime_set(ts.tv_sec, (unsigned long )ts.tv_nsec);
  }
#line 115
  return (tmp);
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t timeval_to_ktime(struct timeval tv ) 
{ ktime_t tmp ;

  {
  {
#line 121
  tmp = ktime_set(tv.tv_sec, (unsigned long )(tv.tv_usec * 1000L));
  }
#line 121
  return (tmp);
}
}
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static int ktime_equal(ktime_t cmp1 , ktime_t cmp2 ) 
{ 

  {
#line 289
  return (cmp1.tv64 == cmp2.tv64);
}
}
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static s64 ktime_to_us(ktime_t kt ) 
{ struct timeval tv ;
  struct timeval tmp ;

  {
  {
#line 294
  tmp = ns_to_timeval(kt.tv64);
#line 294
  tv = tmp;
  }
#line 295
  return ((long long )tv.tv_sec * 1000000LL + (long long )tv.tv_usec);
}
}
#line 298 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static s64 ktime_us_delta(ktime_t later , ktime_t earlier ) 
{ ktime_t __constr_expr_0 ;
  s64 tmp ;

  {
  {
#line 300
  __constr_expr_0.tv64 = later.tv64 - earlier.tv64;
#line 300
  tmp = ktime_to_us(__constr_expr_0);
  }
#line 300
  return (tmp);
}
}
#line 303 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_add_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 305
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 + usec * 1000ULL);
  }
#line 305
  return (__constr_expr_0);
}
}
#line 308 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_sub_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 310
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 - usec * 1000ULL);
  }
#line 310
  return (__constr_expr_0);
}
}
#line 313
extern ktime_t ktime_add_safe(ktime_t lhs , ktime_t rhs ) ;
#line 325
extern void ktime_get_ts(struct timespec *ts ) ;
#line 332
__inline static ktime_t ns_to_ktime(u64 ns ) ;
#line 332 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
static union ktime  const  ktime_zero  =    {(s64 )0};
#line 330 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 333
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero.tv64 + ns);
  }
#line 333
  return (__constr_expr_0);
}
}
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_init(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 67
  return;
}
}
#line 68 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_init_on_stack(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 69
  return;
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_activate(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 71
  return;
}
}
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_deactivate(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 73
  return;
}
}
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_destroy(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 75
  return;
}
}
#line 76 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_free(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 77
  return;
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_objects_early_init(void) 
{ 

  {
#line 79
  return;
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_objects_mem_init(void) 
{ 

  {
#line 80
  return;
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_check_no_obj_freed(void const   *address , unsigned long size ) 
{ 

  {
#line 87
  return;
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
extern struct tvec_base boot_tvec_bases ;
#line 59
extern void init_timer_key(struct timer_list *timer , char const   *name , struct lock_class_key *key ) ;
#line 62
extern void init_timer_deferrable_key(struct timer_list *timer , char const   *name ,
                                      struct lock_class_key *key ) ;
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void destroy_timer_on_stack(struct timer_list *timer ) 
{ 

  {
#line 116
  return;
}
}
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void init_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                             struct lock_class_key *key ) 
{ 

  {
  {
#line 121
  init_timer_key(timer, name, key);
  }
#line 122
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void setup_timer_key(struct timer_list *timer , char const   *name ,
                                     struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                     unsigned long data ) 
{ 

  {
  {
#line 131
  timer->function = function;
#line 132
  timer->data = data;
#line 133
  init_timer_key(timer, name, key);
  }
#line 134
  return;
}
}
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void setup_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                              struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                              unsigned long data ) 
{ 

  {
  {
#line 142
  timer->function = function;
#line 143
  timer->data = data;
#line 144
  init_timer_on_stack_key(timer, name, key);
  }
#line 145
  return;
}
}
#line 157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 

  {
#line 159
  return ((unsigned long )timer->entry.next != (unsigned long )((void *)0));
}
}
#line 162
extern void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 163
extern int del_timer(struct timer_list *timer ) ;
#line 164
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 165
extern int mod_timer_pending(struct timer_list *timer , unsigned long expires ) ;
#line 177
extern unsigned long next_timer_interrupt(void) ;
#line 183
extern unsigned long get_next_timer_interrupt(unsigned long now ) ;
#line 192
extern void init_timer_stats(void) ;
#line 194
extern void timer_stats_update_stats(void *timer , pid_t pid , void *startf , void *timerf ,
                                     char *comm , unsigned int timer_flag ) ;
#line 198
extern void __timer_stats_timer_set_start_info(struct timer_list *timer , void *addr ) ;
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void timer_stats_timer_set_start_info(struct timer_list *timer ) 
{ void *tmp ;

  {
  {
#line 203
  tmp = __builtin_return_address(0U);
#line 203
  __timer_stats_timer_set_start_info(timer, tmp);
  }
#line 204
  return;
}
}
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void timer_stats_timer_clear_start_info(struct timer_list *timer ) 
{ 

  {
  {
#line 208
  timer->start_site = (void *)0;
  }
#line 209
  return;
}
}
#line 224
extern void add_timer(struct timer_list *timer ) ;
#line 227
extern int try_to_del_timer_sync(struct timer_list *timer ) ;
#line 228
extern int del_timer_sync(struct timer_list *timer ) ;
#line 236
extern void init_timers(void) ;
#line 237
extern void run_local_timers(void) ;
#line 239
extern enum hrtimer_restart it_real_fn(struct hrtimer * ) ;
#line 241
extern unsigned long __round_jiffies(unsigned long j , int cpu ) ;
#line 242
extern unsigned long __round_jiffies_relative(unsigned long j , int cpu ) ;
#line 243
extern unsigned long round_jiffies(unsigned long j ) ;
#line 244
extern unsigned long round_jiffies_relative(unsigned long j ) ;
#line 246
extern unsigned long __round_jiffies_up(unsigned long j , int cpu ) ;
#line 247
extern unsigned long __round_jiffies_up_relative(unsigned long j , int cpu ) ;
#line 248
extern unsigned long round_jiffies_up(unsigned long j ) ;
#line 249
extern unsigned long round_jiffies_up_relative(unsigned long j ) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static struct delayed_work *to_delayed_work(struct work_struct *work ) 
{ struct work_struct  const  *__mptr ;

  {
  {
#line 46
  __mptr = (struct work_struct  const  *)work;
  }
#line 46
  return ((struct delayed_work *)((char *)__mptr - (unsigned int )(& ((struct delayed_work *)0)->work)));
}
}
#line 167
extern struct workqueue_struct *__create_workqueue_key(char const   *name , int singlethread ,
                                                       int freezeable , int rt , struct lock_class_key *key ,
                                                       char const   *lock_name ) ;
#line 198
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
#line 200
extern int queue_work(struct workqueue_struct *wq , struct work_struct *work ) ;
#line 201
extern int queue_work_on(int cpu , struct workqueue_struct *wq , struct work_struct *work ) ;
#line 203
extern int queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *work ,
                              unsigned long delay ) ;
#line 205
extern int queue_delayed_work_on(int cpu , struct workqueue_struct *wq , struct delayed_work *work ,
                                 unsigned long delay ) ;
#line 208
extern void flush_workqueue(struct workqueue_struct *wq ) ;
#line 209
extern void flush_scheduled_work(void) ;
#line 211
extern int schedule_work(struct work_struct *work ) ;
#line 212
extern int schedule_work_on(int cpu , struct work_struct *work ) ;
#line 213
extern int schedule_delayed_work(struct delayed_work *work , unsigned long delay ) ;
#line 214
extern int schedule_delayed_work_on(int cpu , struct delayed_work *work , unsigned long delay ) ;
#line 216
extern int schedule_on_each_cpu(void (*func)(struct work_struct *work ) ) ;
#line 217
extern int current_is_keventd(void) ;
#line 218
extern int keventd_up(void) ;
#line 220
extern void init_workqueues(void) ;
#line 221
extern int execute_in_process_context(void (*fn)(struct work_struct *work ) , struct execute_work * ) ;
#line 223
extern int flush_work(struct work_struct *work ) ;
#line 225
extern int cancel_work_sync(struct work_struct *work ) ;
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static int cancel_delayed_work(struct delayed_work *work ) 
{ int ret ;

  {
  {
#line 237
  ret = del_timer_sync(& work->timer);
  }
#line 238
  if (ret) {
    {
#line 239
    clear_bit(0, (unsigned long volatile   *)((unsigned long *)(& work->work.data)));
    }
  }
#line 240
  return (ret);
}
}
#line 243
extern int cancel_delayed_work_sync(struct delayed_work *work ) ;
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static void cancel_rearming_delayed_workqueue(struct workqueue_struct *wq ,
                                                       struct delayed_work *work ) 
{ 

  {
  {
#line 250
  cancel_delayed_work_sync(work);
  }
#line 251
  return;
}
}
#line 254 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static void cancel_rearming_delayed_work(struct delayed_work *work ) 
{ 

  {
  {
#line 257
  cancel_delayed_work_sync(work);
  }
#line 258
  return;
}
}
#line 266
extern long work_on_cpu(unsigned int cpu , long (*fn)(void * ) , void *arg ) ;
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
extern int sysfs_schedule_callback(struct kobject *kobj , void (*func)(void * ) ,
                                   void *data , struct module *owner ) ;
#line 89
extern int sysfs_create_dir(struct kobject *kobj ) ;
#line 90
extern void sysfs_remove_dir(struct kobject *kobj ) ;
#line 91
extern int sysfs_rename_dir(struct kobject *kobj , char const   *new_name ) ;
#line 92
extern int sysfs_move_dir(struct kobject *kobj , struct kobject *new_parent_kobj ) ;
#line 95
extern int sysfs_create_file(struct kobject *kobj , struct attribute  const  *attr ) ;
#line 97
extern int sysfs_chmod_file(struct kobject *kobj , struct attribute *attr , mode_t mode ) ;
#line 99
extern void sysfs_remove_file(struct kobject *kobj , struct attribute  const  *attr ) ;
#line 101
extern int sysfs_create_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
#line 103
extern void sysfs_remove_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
#line 105
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char const   *name ) ;
#line 107
extern int sysfs_create_link_nowarn(struct kobject *kobj , struct kobject *target ,
                                    char const   *name ) ;
#line 110
extern void sysfs_remove_link(struct kobject *kobj , char const   *name ) ;
#line 112
extern int sysfs_create_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 114
extern int sysfs_update_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 116
extern void sysfs_remove_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 118
extern int sysfs_add_file_to_group(struct kobject *kobj , struct attribute  const  *attr ,
                                   char const   *group ) ;
#line 120
extern void sysfs_remove_file_from_group(struct kobject *kobj , struct attribute  const  *attr ,
                                         char const   *group ) ;
#line 123
extern void sysfs_notify(struct kobject *kobj , char const   *dir , char const   *attr ) ;
#line 124
extern void sysfs_notify_dirent(struct sysfs_dirent *sd ) ;
#line 125
extern struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd , unsigned char const   *name ) ;
#line 127
extern struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd ) ;
#line 128
extern void sysfs_put(struct sysfs_dirent *sd ) ;
#line 129
extern void sysfs_printk_last_file(void) ;
#line 130
extern int sysfs_init(void) ;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kref.h"
extern void kref_set(struct kref *kref , int num ) ;
#line 26
extern void kref_init(struct kref *kref ) ;
#line 27
extern void kref_get(struct kref *kref ) ;
#line 28
extern int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) ;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
extern char uevent_helper[] ;
#line 37
extern u64 uevent_seqnum ;
#line 74
extern int ( /* format attribute */  kobject_set_name)(struct kobject *kobj , char const   *name 
                                                       , ...) ;
#line 76
extern int kobject_set_name_vargs(struct kobject *kobj , char const   *fmt , va_list vargs ) ;
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 

  {
#line 81
  return ((char const   *)kobj->name);
}
}
#line 84
extern void kobject_init(struct kobject *kobj , struct kobj_type *ktype ) ;
#line 85
extern int kobject_add(struct kobject *kobj , struct kobject *parent , char const   *fmt 
                       , ...) ;
#line 88
extern int kobject_init_and_add(struct kobject *kobj , struct kobj_type *ktype , struct kobject *parent ,
                                char const   *fmt  , ...) ;
#line 93
extern void kobject_del(struct kobject *kobj ) ;
#line 95
extern struct kobject *kobject_create(void) ;
#line 96
extern struct kobject *kobject_create_and_add(char const   *name , struct kobject *parent ) ;
#line 99
extern int kobject_rename(struct kobject * , char const   *new_name ) ;
#line 100
extern int kobject_move(struct kobject * , struct kobject * ) ;
#line 102
extern struct kobject *kobject_get(struct kobject *kobj ) ;
#line 103
extern void kobject_put(struct kobject *kobj ) ;
#line 105
extern char *kobject_get_path(struct kobject *kobj , gfp_t flag ) ;
#line 135
extern struct sysfs_ops kobj_sysfs_ops ;
#line 161
extern void kset_init(struct kset *kset ) ;
#line 162
extern int kset_register(struct kset *kset ) ;
#line 163
extern void kset_unregister(struct kset *kset ) ;
#line 164
extern struct kset *kset_create_and_add(char const   *name , struct kset_uevent_ops *u ,
                                        struct kobject *parent_kobj ) ;
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static struct kset *to_kset(struct kobject *kobj ) 
{ struct kobject  const  *__mptr ;
  struct kset *tmp ;

  {
#line 170
  if (kobj) {
    {
#line 170
    __mptr = (struct kobject  const  *)kobj;
#line 170
    tmp = (struct kset *)((char *)__mptr - (unsigned int )(& ((struct kset *)0)->kobj));
    }
  } else {
    {
#line 170
    tmp = (struct kset *)((void *)0);
    }
  }
#line 170
  return (tmp);
}
}
#line 173 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static struct kset *kset_get(struct kset *k ) 
{ struct kobject *tmp ;
  struct kset *tmp___0 ;
  struct kset *tmp___1 ;

  {
#line 175
  if (k) {
    {
#line 175
    tmp = kobject_get(& k->kobj);
#line 175
    tmp___0 = to_kset(tmp);
#line 175
    tmp___1 = tmp___0;
    }
  } else {
    {
#line 175
    tmp___1 = (struct kset *)((void *)0);
    }
  }
#line 175
  return (tmp___1);
}
}
#line 178 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static void kset_put(struct kset *k ) 
{ 

  {
  {
#line 180
  kobject_put(& k->kobj);
  }
#line 181
  return;
}
}
#line 183 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static struct kobj_type *get_ktype(struct kobject *kobj ) 
{ 

  {
#line 185
  return (kobj->ktype);
}
}
#line 188
extern struct kobject *kset_find_obj(struct kset * , char const   * ) ;
#line 191
extern struct kobject *kernel_kobj ;
#line 193
extern struct kobject *mm_kobj ;
#line 195
extern struct kobject *hypervisor_kobj ;
#line 197
extern struct kobject *power_kobj ;
#line 199
extern struct kobject *firmware_kobj ;
#line 202
extern int kobject_uevent(struct kobject *kobj , enum kobject_action action ) ;
#line 203
extern int kobject_uevent_env(struct kobject *kobj , enum kobject_action action ,
                              char **envp ) ;
#line 206
extern int ( /* format attribute */  add_uevent_var)(struct kobj_uevent_env *env ,
                                                     char const   *format  , ...) ;
#line 209
extern int kobject_action_type(char const   *buf , size_t count , enum kobject_action *type ) ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 

  {
  {
#line 75
  x->done = 0U;
#line 76
  init_waitqueue_head(& x->wait);
  }
#line 77
  return;
}
}
#line 79
extern void wait_for_completion(struct completion * ) ;
#line 80
extern int wait_for_completion_interruptible(struct completion *x ) ;
#line 81
extern int wait_for_completion_killable(struct completion *x ) ;
#line 82
extern unsigned long wait_for_completion_timeout(struct completion *x , unsigned long timeout ) ;
#line 84
extern unsigned long wait_for_completion_interruptible_timeout(struct completion *x ,
                                                               unsigned long timeout ) ;
#line 86
extern bool try_wait_for_completion(struct completion *x ) ;
#line 87
extern bool completion_done(struct completion *x ) ;
#line 89
extern void complete(struct completion * ) ;
#line 90
extern void complete_all(struct completion * ) ;
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
extern int rcu_scheduler_active ;
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
extern void rcu_qsctr_inc(int cpu ) ;
#line 238
extern void rcu_bh_qsctr_inc(int cpu ) ;
#line 240
extern int rcu_pending(int cpu ) ;
#line 241
extern int rcu_needs_cpu(int cpu ) ;
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_lock(void) 
{ 

  {
  {
#line 255
  while (1) {
    while_28_continue: /* CIL Label */ ;
    goto while_28_break;
  }
  while_28_break: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_29_continue: /* CIL Label */ ;
    goto while_29_break;
  }
  while_29_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_unlock(void) 
{ 

  {
  {
#line 261
  while (1) {
    while_30_continue: /* CIL Label */ ;
    goto while_30_break;
  }
  while_30_break: /* CIL Label */ ;
  }
  {
#line 263
  while (1) {
    while_31_continue: /* CIL Label */ ;
    goto while_31_break;
  }
  while_31_break: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 265 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_lock_bh(void) 
{ 

  {
  {
#line 267
  local_bh_disable();
  }
  {
#line 269
  while (1) {
    while_32_continue: /* CIL Label */ ;
    goto while_32_break;
  }
  while_32_break: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 271 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_unlock_bh(void) 
{ 

  {
  {
#line 273
  while (1) {
    while_33_continue: /* CIL Label */ ;
    goto while_33_break;
  }
  while_33_break: /* CIL Label */ ;
  }
  {
#line 275
  local_bh_enable();
  }
#line 276
  return;
}
}
#line 282 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void rcu_init_sched(void) 
{ 

  {
#line 284
  return;
}
}
#line 286
extern void __rcu_init(void) ;
#line 287
extern void rcu_check_callbacks(int cpu , int user ) ;
#line 288
extern void rcu_restart_cpu(int cpu ) ;
#line 290
extern long rcu_batches_completed(void) ;
#line 291
extern long rcu_batches_completed_bh(void) ;
#line 294
extern void rcu_enter_nohz(void) ;
#line 295
extern void rcu_exit_nohz(void) ;
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static int rcu_blocking_is_gp(void) 
{ unsigned int tmp ;

  {
  {
#line 308
  tmp = cpumask_weight((struct cpumask  const  *)cpu_online_mask);
  }
#line 308
  return (tmp == 1U);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
extern void wakeme_after_rcu(struct rcu_head *head ) ;
#line 238
extern void call_rcu(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
#line 259
extern void call_rcu_bh(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
#line 263
extern void synchronize_rcu(void) ;
#line 264
extern void rcu_barrier(void) ;
#line 265
extern void rcu_barrier_bh(void) ;
#line 266
extern void rcu_barrier_sched(void) ;
#line 269
extern void rcu_init(void) ;
#line 270
extern void rcu_scheduler_starting(void) ;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
extern void tracepoint_update_probe_range(struct tracepoint *begin , struct tracepoint *end ) ;
#line 122
extern int tracepoint_probe_register(char const   *name , void *probe ) ;
#line 128
extern int tracepoint_probe_unregister(char const   *name , void *probe ) ;
#line 130
extern int tracepoint_probe_register_noupdate(char const   *name , void *probe ) ;
#line 131
extern int tracepoint_probe_unregister_noupdate(char const   *name , void *probe ) ;
#line 132
extern void tracepoint_probe_update_all(void) ;
#line 139
extern void tracepoint_iter_start(struct tracepoint_iter *iter ) ;
#line 140
extern void tracepoint_iter_next(struct tracepoint_iter *iter ) ;
#line 141
extern void tracepoint_iter_stop(struct tracepoint_iter *iter ) ;
#line 142
extern void tracepoint_iter_reset(struct tracepoint_iter *iter ) ;
#line 143
extern int tracepoint_get_iter_range(struct tracepoint **tracepoint , struct tracepoint *begin ,
                                     struct tracepoint *end ) ;
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
__inline static void tracepoint_synchronize_unregister(void) 
{ 

  {
  {
#line 153
  synchronize_rcu();
  }
#line 154
  return;
}
}
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void kmemtrace_init(void) 
{ 

  {
#line 20
  return;
}
}
#line 23
extern struct tracepoint __tracepoint_kmalloc ;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmalloc(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                                   size_t bytes_alloc , gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 23
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc.state)), 0L);
  }
#line 23
  if (tmp) {
    {
#line 23
    while (1) {
      while_34_continue: /* CIL Label */ ;
      {
#line 23
      while (1) {
        while_35_continue: /* CIL Label */ ;
        goto while_35_break;
      }
      while_35_break: /* CIL Label */ ;
      }
      {
#line 23
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc.funcs));
      }
      {
#line 23
      while (1) {
        while_36_continue: /* CIL Label */ ;
        goto while_36_break;
      }
      while_36_break: /* CIL Label */ ;
      }
      {
#line 23
      it_func = _________p1;
      }
#line 23
      if (it_func) {
        {
#line 23
        while (1) {
          while_37_continue: /* CIL Label */ ;
          {
#line 23
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
#line 23
          it_func ++;
          }
#line 23
          if (! *it_func) {
            goto while_37_break;
          }
        }
        while_37_break: /* CIL Label */ ;
        }
      }
      {
#line 23
      while (1) {
        while_38_continue: /* CIL Label */ ;
        goto while_38_break;
      }
      while_38_break: /* CIL Label */ ;
      }
      goto while_34_break;
    }
    while_34_break: /* CIL Label */ ;
    }
  }
#line 23
  return;
}
}
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr , size_t bytes_req ,
                                                         size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 23
  tmp = tracepoint_probe_register("kmalloc", (void *)probe);
  }
#line 23
  return (tmp);
}
}
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                           void const   *ptr , size_t bytes_req ,
                                                           size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 23
  tmp = tracepoint_probe_unregister("kmalloc", (void *)probe);
  }
#line 23
  return (tmp);
}
}
#line 30
extern struct tracepoint __tracepoint_kmem_cache_alloc ;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmem_cache_alloc(unsigned long call_site , void const   *ptr ,
                                            size_t bytes_req , size_t bytes_alloc ,
                                            gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 30
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc.state)), 0L);
  }
#line 30
  if (tmp) {
    {
#line 30
    while (1) {
      while_39_continue: /* CIL Label */ ;
      {
#line 30
      while (1) {
        while_40_continue: /* CIL Label */ ;
        goto while_40_break;
      }
      while_40_break: /* CIL Label */ ;
      }
      {
#line 30
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc.funcs));
      }
      {
#line 30
      while (1) {
        while_41_continue: /* CIL Label */ ;
        goto while_41_break;
      }
      while_41_break: /* CIL Label */ ;
      }
      {
#line 30
      it_func = _________p1;
      }
#line 30
      if (it_func) {
        {
#line 30
        while (1) {
          while_42_continue: /* CIL Label */ ;
          {
#line 30
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
#line 30
          it_func ++;
          }
#line 30
          if (! *it_func) {
            goto while_42_break;
          }
        }
        while_42_break: /* CIL Label */ ;
        }
      }
      {
#line 30
      while (1) {
        while_43_continue: /* CIL Label */ ;
        goto while_43_break;
      }
      while_43_break: /* CIL Label */ ;
      }
      goto while_39_break;
    }
    while_39_break: /* CIL Label */ ;
    }
  }
#line 30
  return;
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                  void const   *ptr ,
                                                                  size_t bytes_req ,
                                                                  size_t bytes_alloc ,
                                                                  gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 30
  tmp = tracepoint_probe_register("kmem_cache_alloc", (void *)probe);
  }
#line 30
  return (tmp);
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                    void const   *ptr ,
                                                                    size_t bytes_req ,
                                                                    size_t bytes_alloc ,
                                                                    gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 30
  tmp = tracepoint_probe_unregister("kmem_cache_alloc", (void *)probe);
  }
#line 30
  return (tmp);
}
}
#line 37
extern struct tracepoint __tracepoint_kmalloc_node ;
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmalloc_node(unsigned long call_site , void const   *ptr ,
                                        size_t bytes_req , size_t bytes_alloc , gfp_t gfp_flags ,
                                        int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 37
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc_node.state)), 0L);
  }
#line 37
  if (tmp) {
    {
#line 37
    while (1) {
      while_44_continue: /* CIL Label */ ;
      {
#line 37
      while (1) {
        while_45_continue: /* CIL Label */ ;
        goto while_45_break;
      }
      while_45_break: /* CIL Label */ ;
      }
      {
#line 37
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc_node.funcs));
      }
      {
#line 37
      while (1) {
        while_46_continue: /* CIL Label */ ;
        goto while_46_break;
      }
      while_46_break: /* CIL Label */ ;
      }
      {
#line 37
      it_func = _________p1;
      }
#line 37
      if (it_func) {
        {
#line 37
        while (1) {
          while_47_continue: /* CIL Label */ ;
          {
#line 37
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
#line 37
          it_func ++;
          }
#line 37
          if (! *it_func) {
            goto while_47_break;
          }
        }
        while_47_break: /* CIL Label */ ;
        }
      }
      {
#line 37
      while (1) {
        while_48_continue: /* CIL Label */ ;
        goto while_48_break;
      }
      while_48_break: /* CIL Label */ ;
      }
      goto while_44_break;
    }
    while_44_break: /* CIL Label */ ;
    }
  }
#line 37
  return;
}
}
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                              void const   *ptr ,
                                                              size_t bytes_req , size_t bytes_alloc ,
                                                              gfp_t gfp_flags , int node ) ) 
{ int tmp ;

  {
  {
#line 37
  tmp = tracepoint_probe_register("kmalloc_node", (void *)probe);
  }
#line 37
  return (tmp);
}
}
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                                void const   *ptr ,
                                                                size_t bytes_req ,
                                                                size_t bytes_alloc ,
                                                                gfp_t gfp_flags ,
                                                                int node ) ) 
{ int tmp ;

  {
  {
#line 37
  tmp = tracepoint_probe_unregister("kmalloc_node", (void *)probe);
  }
#line 37
  return (tmp);
}
}
#line 45
extern struct tracepoint __tracepoint_kmem_cache_alloc_node ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmem_cache_alloc_node(unsigned long call_site , void const   *ptr ,
                                                 size_t bytes_req , size_t bytes_alloc ,
                                                 gfp_t gfp_flags , int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 45
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc_node.state)),
                         0L);
  }
#line 45
  if (tmp) {
    {
#line 45
    while (1) {
      while_49_continue: /* CIL Label */ ;
      {
#line 45
      while (1) {
        while_50_continue: /* CIL Label */ ;
        goto while_50_break;
      }
      while_50_break: /* CIL Label */ ;
      }
      {
#line 45
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc_node.funcs));
      }
      {
#line 45
      while (1) {
        while_51_continue: /* CIL Label */ ;
        goto while_51_break;
      }
      while_51_break: /* CIL Label */ ;
      }
      {
#line 45
      it_func = _________p1;
      }
#line 45
      if (it_func) {
        {
#line 45
        while (1) {
          while_52_continue: /* CIL Label */ ;
          {
#line 45
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
#line 45
          it_func ++;
          }
#line 45
          if (! *it_func) {
            goto while_52_break;
          }
        }
        while_52_break: /* CIL Label */ ;
        }
      }
      {
#line 45
      while (1) {
        while_53_continue: /* CIL Label */ ;
        goto while_53_break;
      }
      while_53_break: /* CIL Label */ ;
      }
      goto while_49_break;
    }
    while_49_break: /* CIL Label */ ;
    }
  }
#line 45
  return;
}
}
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                       void const   *ptr ,
                                                                       size_t bytes_req ,
                                                                       size_t bytes_alloc ,
                                                                       gfp_t gfp_flags ,
                                                                       int node ) ) 
{ int tmp ;

  {
  {
#line 45
  tmp = tracepoint_probe_register("kmem_cache_alloc_node", (void *)probe);
  }
#line 45
  return (tmp);
}
}
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                         void const   *ptr ,
                                                                         size_t bytes_req ,
                                                                         size_t bytes_alloc ,
                                                                         gfp_t gfp_flags ,
                                                                         int node ) ) 
{ int tmp ;

  {
  {
#line 45
  tmp = tracepoint_probe_unregister("kmem_cache_alloc_node", (void *)probe);
  }
#line 45
  return (tmp);
}
}
#line 53
extern struct tracepoint __tracepoint_kfree ;
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kfree(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 53
  tmp = __builtin_expect((long )(! (! __tracepoint_kfree.state)), 0L);
  }
#line 53
  if (tmp) {
    {
#line 53
    while (1) {
      while_54_continue: /* CIL Label */ ;
      {
#line 53
      while (1) {
        while_55_continue: /* CIL Label */ ;
        goto while_55_break;
      }
      while_55_break: /* CIL Label */ ;
      }
      {
#line 53
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kfree.funcs));
      }
      {
#line 53
      while (1) {
        while_56_continue: /* CIL Label */ ;
        goto while_56_break;
      }
      while_56_break: /* CIL Label */ ;
      }
      {
#line 53
      it_func = _________p1;
      }
#line 53
      if (it_func) {
        {
#line 53
        while (1) {
          while_57_continue: /* CIL Label */ ;
          {
#line 53
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
#line 53
          it_func ++;
          }
#line 53
          if (! *it_func) {
            goto while_57_break;
          }
        }
        while_57_break: /* CIL Label */ ;
        }
      }
      {
#line 53
      while (1) {
        while_58_continue: /* CIL Label */ ;
        goto while_58_break;
      }
      while_58_break: /* CIL Label */ ;
      }
      goto while_54_break;
    }
    while_54_break: /* CIL Label */ ;
    }
  }
#line 53
  return;
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kfree(void (*probe)(unsigned long call_site , void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 53
  tmp = tracepoint_probe_register("kfree", (void *)probe);
  }
#line 53
  return (tmp);
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kfree(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 53
  tmp = tracepoint_probe_unregister("kfree", (void *)probe);
  }
#line 53
  return (tmp);
}
}
#line 56
extern struct tracepoint __tracepoint_kmem_cache_free ;
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmem_cache_free(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 56
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_free.state)), 0L);
  }
#line 56
  if (tmp) {
    {
#line 56
    while (1) {
      while_59_continue: /* CIL Label */ ;
      {
#line 56
      while (1) {
        while_60_continue: /* CIL Label */ ;
        goto while_60_break;
      }
      while_60_break: /* CIL Label */ ;
      }
      {
#line 56
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_free.funcs));
      }
      {
#line 56
      while (1) {
        while_61_continue: /* CIL Label */ ;
        goto while_61_break;
      }
      while_61_break: /* CIL Label */ ;
      }
      {
#line 56
      it_func = _________p1;
      }
#line 56
      if (it_func) {
        {
#line 56
        while (1) {
          while_62_continue: /* CIL Label */ ;
          {
#line 56
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
#line 56
          it_func ++;
          }
#line 56
          if (! *it_func) {
            goto while_62_break;
          }
        }
        while_62_break: /* CIL Label */ ;
        }
      }
      {
#line 56
      while (1) {
        while_63_continue: /* CIL Label */ ;
        goto while_63_break;
      }
      while_63_break: /* CIL Label */ ;
      }
      goto while_59_break;
    }
    while_59_break: /* CIL Label */ ;
    }
  }
#line 56
  return;
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                 void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 56
  tmp = tracepoint_probe_register("kmem_cache_free", (void *)probe);
  }
#line 56
  return (tmp);
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                   void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 56
  tmp = tracepoint_probe_unregister("kmem_cache_free", (void *)probe);
  }
#line 56
  return (tmp);
}
}
#line 141 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
extern struct kmem_cache kmalloc_caches[14] ;
#line 147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static int kmalloc_index(size_t size ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;

  {
#line 149
  if (! size) {
#line 150
    return (0);
  }
#line 152
  if (size <= 8U) {
#line 153
    if (8ULL & (1ULL << 63)) {
      {
#line 153
      tmp___63 = 63;
      }
    } else {
#line 153
      if (8ULL & (1ULL << 62)) {
        {
#line 153
        tmp___62 = 62;
        }
      } else {
#line 153
        if (8ULL & (1ULL << 61)) {
          {
#line 153
          tmp___61 = 61;
          }
        } else {
#line 153
          if (8ULL & (1ULL << 60)) {
            {
#line 153
            tmp___60 = 60;
            }
          } else {
#line 153
            if (8ULL & (1ULL << 59)) {
              {
#line 153
              tmp___59 = 59;
              }
            } else {
#line 153
              if (8ULL & (1ULL << 58)) {
                {
#line 153
                tmp___58 = 58;
                }
              } else {
#line 153
                if (8ULL & (1ULL << 57)) {
                  {
#line 153
                  tmp___57 = 57;
                  }
                } else {
#line 153
                  if (8ULL & (1ULL << 56)) {
                    {
#line 153
                    tmp___56 = 56;
                    }
                  } else {
#line 153
                    if (8ULL & (1ULL << 55)) {
                      {
#line 153
                      tmp___55 = 55;
                      }
                    } else {
#line 153
                      if (8ULL & (1ULL << 54)) {
                        {
#line 153
                        tmp___54 = 54;
                        }
                      } else {
#line 153
                        if (8ULL & (1ULL << 53)) {
                          {
#line 153
                          tmp___53 = 53;
                          }
                        } else {
#line 153
                          if (8ULL & (1ULL << 52)) {
                            {
#line 153
                            tmp___52 = 52;
                            }
                          } else {
#line 153
                            if (8ULL & (1ULL << 51)) {
                              {
#line 153
                              tmp___51 = 51;
                              }
                            } else {
#line 153
                              if (8ULL & (1ULL << 50)) {
                                {
#line 153
                                tmp___50 = 50;
                                }
                              } else {
#line 153
                                if (8ULL & (1ULL << 49)) {
                                  {
#line 153
                                  tmp___49 = 49;
                                  }
                                } else {
#line 153
                                  if (8ULL & (1ULL << 48)) {
                                    {
#line 153
                                    tmp___48 = 48;
                                    }
                                  } else {
#line 153
                                    if (8ULL & (1ULL << 47)) {
                                      {
#line 153
                                      tmp___47 = 47;
                                      }
                                    } else {
#line 153
                                      if (8ULL & (1ULL << 46)) {
                                        {
#line 153
                                        tmp___46 = 46;
                                        }
                                      } else {
#line 153
                                        if (8ULL & (1ULL << 45)) {
                                          {
#line 153
                                          tmp___45 = 45;
                                          }
                                        } else {
#line 153
                                          if (8ULL & (1ULL << 44)) {
                                            {
#line 153
                                            tmp___44 = 44;
                                            }
                                          } else {
#line 153
                                            if (8ULL & (1ULL << 43)) {
                                              {
#line 153
                                              tmp___43 = 43;
                                              }
                                            } else {
#line 153
                                              if (8ULL & (1ULL << 42)) {
                                                {
#line 153
                                                tmp___42 = 42;
                                                }
                                              } else {
#line 153
                                                if (8ULL & (1ULL << 41)) {
                                                  {
#line 153
                                                  tmp___41 = 41;
                                                  }
                                                } else {
#line 153
                                                  if (8ULL & (1ULL << 40)) {
                                                    {
#line 153
                                                    tmp___40 = 40;
                                                    }
                                                  } else {
#line 153
                                                    if (8ULL & (1ULL << 39)) {
                                                      {
#line 153
                                                      tmp___39 = 39;
                                                      }
                                                    } else {
#line 153
                                                      if (8ULL & (1ULL << 38)) {
                                                        {
#line 153
                                                        tmp___38 = 38;
                                                        }
                                                      } else {
#line 153
                                                        if (8ULL & (1ULL << 37)) {
                                                          {
#line 153
                                                          tmp___37 = 37;
                                                          }
                                                        } else {
#line 153
                                                          if (8ULL & (1ULL << 36)) {
                                                            {
#line 153
                                                            tmp___36 = 36;
                                                            }
                                                          } else {
#line 153
                                                            if (8ULL & (1ULL << 35)) {
                                                              {
#line 153
                                                              tmp___35 = 35;
                                                              }
                                                            } else {
#line 153
                                                              if (8ULL & (1ULL << 34)) {
                                                                {
#line 153
                                                                tmp___34 = 34;
                                                                }
                                                              } else {
#line 153
                                                                if (8ULL & (1ULL << 33)) {
                                                                  {
#line 153
                                                                  tmp___33 = 33;
                                                                  }
                                                                } else {
#line 153
                                                                  if (8ULL & (1ULL << 32)) {
                                                                    {
#line 153
                                                                    tmp___32 = 32;
                                                                    }
                                                                  } else {
#line 153
                                                                    if (8ULL & (1ULL << 31)) {
                                                                      {
#line 153
                                                                      tmp___31 = 31;
                                                                      }
                                                                    } else {
#line 153
                                                                      if (8ULL & (1ULL << 30)) {
                                                                        {
#line 153
                                                                        tmp___30 = 30;
                                                                        }
                                                                      } else {
#line 153
                                                                        if (8ULL & (1ULL << 29)) {
                                                                          {
#line 153
                                                                          tmp___29 = 29;
                                                                          }
                                                                        } else {
#line 153
                                                                          if (8ULL & (1ULL << 28)) {
                                                                            {
#line 153
                                                                            tmp___28 = 28;
                                                                            }
                                                                          } else {
#line 153
                                                                            if (8ULL & (1ULL << 27)) {
                                                                              {
#line 153
                                                                              tmp___27 = 27;
                                                                              }
                                                                            } else {
#line 153
                                                                              if (8ULL & (1ULL << 26)) {
                                                                                {
#line 153
                                                                                tmp___26 = 26;
                                                                                }
                                                                              } else {
#line 153
                                                                                if (8ULL & (1ULL << 25)) {
                                                                                  {
#line 153
                                                                                  tmp___25 = 25;
                                                                                  }
                                                                                } else {
#line 153
                                                                                  if (8ULL & (1ULL << 24)) {
                                                                                    {
#line 153
                                                                                    tmp___24 = 24;
                                                                                    }
                                                                                  } else {
#line 153
                                                                                    if (8ULL & (1ULL << 23)) {
                                                                                      {
#line 153
                                                                                      tmp___23 = 23;
                                                                                      }
                                                                                    } else {
#line 153
                                                                                      if (8ULL & (1ULL << 22)) {
                                                                                        {
#line 153
                                                                                        tmp___22 = 22;
                                                                                        }
                                                                                      } else {
#line 153
                                                                                        if (8ULL & (1ULL << 21)) {
                                                                                          {
#line 153
                                                                                          tmp___21 = 21;
                                                                                          }
                                                                                        } else {
#line 153
                                                                                          if (8ULL & (1ULL << 20)) {
                                                                                            {
#line 153
                                                                                            tmp___20 = 20;
                                                                                            }
                                                                                          } else {
#line 153
                                                                                            if (8ULL & (1ULL << 19)) {
                                                                                              {
#line 153
                                                                                              tmp___19 = 19;
                                                                                              }
                                                                                            } else {
#line 153
                                                                                              if (8ULL & (1ULL << 18)) {
                                                                                                {
#line 153
                                                                                                tmp___18 = 18;
                                                                                                }
                                                                                              } else {
#line 153
                                                                                                if (8ULL & (1ULL << 17)) {
                                                                                                  {
#line 153
                                                                                                  tmp___17 = 17;
                                                                                                  }
                                                                                                } else {
#line 153
                                                                                                  if (8ULL & (1ULL << 16)) {
                                                                                                    {
#line 153
                                                                                                    tmp___16 = 16;
                                                                                                    }
                                                                                                  } else {
#line 153
                                                                                                    if (8ULL & (1ULL << 15)) {
                                                                                                      {
#line 153
                                                                                                      tmp___15 = 15;
                                                                                                      }
                                                                                                    } else {
#line 153
                                                                                                      if (8ULL & (1ULL << 14)) {
                                                                                                        {
#line 153
                                                                                                        tmp___14 = 14;
                                                                                                        }
                                                                                                      } else {
#line 153
                                                                                                        if (8ULL & (1ULL << 13)) {
                                                                                                          {
#line 153
                                                                                                          tmp___13 = 13;
                                                                                                          }
                                                                                                        } else {
#line 153
                                                                                                          if (8ULL & (1ULL << 12)) {
                                                                                                            {
#line 153
                                                                                                            tmp___12 = 12;
                                                                                                            }
                                                                                                          } else {
#line 153
                                                                                                            if (8ULL & (1ULL << 11)) {
                                                                                                              {
#line 153
                                                                                                              tmp___11 = 11;
                                                                                                              }
                                                                                                            } else {
#line 153
                                                                                                              if (8ULL & (1ULL << 10)) {
                                                                                                                {
#line 153
                                                                                                                tmp___10 = 10;
                                                                                                                }
                                                                                                              } else {
#line 153
                                                                                                                if (8ULL & (1ULL << 9)) {
                                                                                                                  {
#line 153
                                                                                                                  tmp___9 = 9;
                                                                                                                  }
                                                                                                                } else {
#line 153
                                                                                                                  if (8ULL & (1ULL << 8)) {
                                                                                                                    {
#line 153
                                                                                                                    tmp___8 = 8;
                                                                                                                    }
                                                                                                                  } else {
#line 153
                                                                                                                    if (8ULL & (1ULL << 7)) {
                                                                                                                      {
#line 153
                                                                                                                      tmp___7 = 7;
                                                                                                                      }
                                                                                                                    } else {
#line 153
                                                                                                                      if (8ULL & (1ULL << 6)) {
                                                                                                                        {
#line 153
                                                                                                                        tmp___6 = 6;
                                                                                                                        }
                                                                                                                      } else {
#line 153
                                                                                                                        if (8ULL & (1ULL << 5)) {
                                                                                                                          {
#line 153
                                                                                                                          tmp___5 = 5;
                                                                                                                          }
                                                                                                                        } else {
#line 153
                                                                                                                          if (8ULL & (1ULL << 4)) {
                                                                                                                            {
#line 153
                                                                                                                            tmp___4 = 4;
                                                                                                                            }
                                                                                                                          } else {
#line 153
                                                                                                                            if (8ULL & (1ULL << 3)) {
                                                                                                                              {
#line 153
                                                                                                                              tmp___3 = 3;
                                                                                                                              }
                                                                                                                            } else {
#line 153
                                                                                                                              if (8ULL & (1ULL << 2)) {
                                                                                                                                {
#line 153
                                                                                                                                tmp___2 = 2;
                                                                                                                                }
                                                                                                                              } else {
#line 153
                                                                                                                                if (8ULL & (1ULL << 1)) {
                                                                                                                                  {
#line 153
                                                                                                                                  tmp___1 = 1;
                                                                                                                                  }
                                                                                                                                } else {
                                                                                                                                  {
#line 153
                                                                                                                                  tmp___0 = ____ilog2_NaN();
#line 153
                                                                                                                                  tmp___1 = tmp___0;
                                                                                                                                  }
                                                                                                                                }
                                                                                                                                {
#line 153
                                                                                                                                tmp___2 = tmp___1;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              {
#line 153
                                                                                                                              tmp___3 = tmp___2;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            {
#line 153
                                                                                                                            tmp___4 = tmp___3;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          {
#line 153
                                                                                                                          tmp___5 = tmp___4;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        {
#line 153
                                                                                                                        tmp___6 = tmp___5;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      {
#line 153
                                                                                                                      tmp___7 = tmp___6;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    {
#line 153
                                                                                                                    tmp___8 = tmp___7;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  {
#line 153
                                                                                                                  tmp___9 = tmp___8;
                                                                                                                  }
                                                                                                                }
                                                                                                                {
#line 153
                                                                                                                tmp___10 = tmp___9;
                                                                                                                }
                                                                                                              }
                                                                                                              {
#line 153
                                                                                                              tmp___11 = tmp___10;
                                                                                                              }
                                                                                                            }
                                                                                                            {
#line 153
                                                                                                            tmp___12 = tmp___11;
                                                                                                            }
                                                                                                          }
                                                                                                          {
#line 153
                                                                                                          tmp___13 = tmp___12;
                                                                                                          }
                                                                                                        }
                                                                                                        {
#line 153
                                                                                                        tmp___14 = tmp___13;
                                                                                                        }
                                                                                                      }
                                                                                                      {
#line 153
                                                                                                      tmp___15 = tmp___14;
                                                                                                      }
                                                                                                    }
                                                                                                    {
#line 153
                                                                                                    tmp___16 = tmp___15;
                                                                                                    }
                                                                                                  }
                                                                                                  {
#line 153
                                                                                                  tmp___17 = tmp___16;
                                                                                                  }
                                                                                                }
                                                                                                {
#line 153
                                                                                                tmp___18 = tmp___17;
                                                                                                }
                                                                                              }
                                                                                              {
#line 153
                                                                                              tmp___19 = tmp___18;
                                                                                              }
                                                                                            }
                                                                                            {
#line 153
                                                                                            tmp___20 = tmp___19;
                                                                                            }
                                                                                          }
                                                                                          {
#line 153
                                                                                          tmp___21 = tmp___20;
                                                                                          }
                                                                                        }
                                                                                        {
#line 153
                                                                                        tmp___22 = tmp___21;
                                                                                        }
                                                                                      }
                                                                                      {
#line 153
                                                                                      tmp___23 = tmp___22;
                                                                                      }
                                                                                    }
                                                                                    {
#line 153
                                                                                    tmp___24 = tmp___23;
                                                                                    }
                                                                                  }
                                                                                  {
#line 153
                                                                                  tmp___25 = tmp___24;
                                                                                  }
                                                                                }
                                                                                {
#line 153
                                                                                tmp___26 = tmp___25;
                                                                                }
                                                                              }
                                                                              {
#line 153
                                                                              tmp___27 = tmp___26;
                                                                              }
                                                                            }
                                                                            {
#line 153
                                                                            tmp___28 = tmp___27;
                                                                            }
                                                                          }
                                                                          {
#line 153
                                                                          tmp___29 = tmp___28;
                                                                          }
                                                                        }
                                                                        {
#line 153
                                                                        tmp___30 = tmp___29;
                                                                        }
                                                                      }
                                                                      {
#line 153
                                                                      tmp___31 = tmp___30;
                                                                      }
                                                                    }
                                                                    {
#line 153
                                                                    tmp___32 = tmp___31;
                                                                    }
                                                                  }
                                                                  {
#line 153
                                                                  tmp___33 = tmp___32;
                                                                  }
                                                                }
                                                                {
#line 153
                                                                tmp___34 = tmp___33;
                                                                }
                                                              }
                                                              {
#line 153
                                                              tmp___35 = tmp___34;
                                                              }
                                                            }
                                                            {
#line 153
                                                            tmp___36 = tmp___35;
                                                            }
                                                          }
                                                          {
#line 153
                                                          tmp___37 = tmp___36;
                                                          }
                                                        }
                                                        {
#line 153
                                                        tmp___38 = tmp___37;
                                                        }
                                                      }
                                                      {
#line 153
                                                      tmp___39 = tmp___38;
                                                      }
                                                    }
                                                    {
#line 153
                                                    tmp___40 = tmp___39;
                                                    }
                                                  }
                                                  {
#line 153
                                                  tmp___41 = tmp___40;
                                                  }
                                                }
                                                {
#line 153
                                                tmp___42 = tmp___41;
                                                }
                                              }
                                              {
#line 153
                                              tmp___43 = tmp___42;
                                              }
                                            }
                                            {
#line 153
                                            tmp___44 = tmp___43;
                                            }
                                          }
                                          {
#line 153
                                          tmp___45 = tmp___44;
                                          }
                                        }
                                        {
#line 153
                                        tmp___46 = tmp___45;
                                        }
                                      }
                                      {
#line 153
                                      tmp___47 = tmp___46;
                                      }
                                    }
                                    {
#line 153
                                    tmp___48 = tmp___47;
                                    }
                                  }
                                  {
#line 153
                                  tmp___49 = tmp___48;
                                  }
                                }
                                {
#line 153
                                tmp___50 = tmp___49;
                                }
                              }
                              {
#line 153
                              tmp___51 = tmp___50;
                              }
                            }
                            {
#line 153
                            tmp___52 = tmp___51;
                            }
                          }
                          {
#line 153
                          tmp___53 = tmp___52;
                          }
                        }
                        {
#line 153
                        tmp___54 = tmp___53;
                        }
                      }
                      {
#line 153
                      tmp___55 = tmp___54;
                      }
                    }
                    {
#line 153
                    tmp___56 = tmp___55;
                    }
                  }
                  {
#line 153
                  tmp___57 = tmp___56;
                  }
                }
                {
#line 153
                tmp___58 = tmp___57;
                }
              }
              {
#line 153
              tmp___59 = tmp___58;
              }
            }
            {
#line 153
            tmp___60 = tmp___59;
            }
          }
          {
#line 153
          tmp___61 = tmp___60;
          }
        }
        {
#line 153
        tmp___62 = tmp___61;
        }
      }
      {
#line 153
      tmp___63 = tmp___62;
      }
    }
#line 153
    return (tmp___63);
  }
#line 156
  if (size > 64U) {
#line 156
    if (size <= 96U) {
#line 157
      return (1);
    }
  }
#line 158
  if (size > 128U) {
#line 158
    if (size <= 192U) {
#line 159
      return (2);
    }
  }
#line 161
  if (size <= 8U) {
#line 161
    return (3);
  }
#line 162
  if (size <= 16U) {
#line 162
    return (4);
  }
#line 163
  if (size <= 32U) {
#line 163
    return (5);
  }
#line 164
  if (size <= 64U) {
#line 164
    return (6);
  }
#line 165
  if (size <= 128U) {
#line 165
    return (7);
  }
#line 166
  if (size <= 256U) {
#line 166
    return (8);
  }
#line 167
  if (size <= 512U) {
#line 167
    return (9);
  }
#line 168
  if (size <= 1024U) {
#line 168
    return (10);
  }
#line 169
  if (size <= 2048U) {
#line 169
    return (11);
  }
#line 170
  if (size <= 4096U) {
#line 170
    return (12);
  }
#line 175
  if (size <= 8192U) {
#line 175
    return (13);
  }
#line 176
  if (size <= 16384U) {
#line 176
    return (14);
  }
#line 177
  if (size <= 32768U) {
#line 177
    return (15);
  }
#line 178
  if (size <= 65536U) {
#line 178
    return (16);
  }
#line 179
  if (size <= 131072U) {
#line 179
    return (17);
  }
#line 180
  if (size <= 262144U) {
#line 180
    return (18);
  }
#line 181
  if (size <= 524288U) {
#line 181
    return (19);
  }
#line 182
  if (size <= 1048576U) {
#line 182
    return (20);
  }
#line 183
  if (size <= 2097152U) {
#line 183
    return (21);
  }
#line 184
  return (-1);
}
}
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static struct kmem_cache *kmalloc_slab(size_t size ) 
{ int index ;
  int tmp ;

  {
  {
#line 203
  tmp = kmalloc_index(size);
#line 203
  index = tmp;
  }
#line 205
  if (index == 0) {
#line 206
    return ((struct kmem_cache *)((void *)0));
  }
#line 208
  return (& kmalloc_caches[index]);
}
}
#line 218
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 219
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 224 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static void *kmem_cache_alloc_notrace(struct kmem_cache *s , gfp_t gfpflags ) 
{ void *tmp ;

  {
  {
#line 227
  tmp = kmem_cache_alloc(s, gfpflags);
  }
#line 227
  return (tmp);
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static void *kmalloc_large(size_t size , gfp_t flags ) 
{ unsigned int order ;
  int tmp ;
  void *ret ;
  unsigned long tmp___0 ;

  {
  {
#line 233
  tmp = get_order((unsigned long )size);
#line 233
  order = (unsigned int )tmp;
#line 234
  tmp___0 = __get_free_pages(flags | 16384U, order);
#line 234
  ret = (void *)tmp___0;
  }
  __here: 
  {
#line 236
  trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )((1UL << 12) << order),
                flags);
  }
#line 238
  return (ret);
}
}
#line 241 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *ret ;
  void *tmp ;
  struct kmem_cache *s ;
  struct kmem_cache *tmp___0 ;
  void *tmp___1 ;

  {
#line 245
  if (0) {
#line 246
    if ((unsigned long )size > 2UL * (1UL << 12)) {
      {
#line 247
      tmp = kmalloc_large(size, flags);
      }
#line 247
      return (tmp);
    }
#line 249
    if (! (flags & 1U)) {
      {
#line 250
      tmp___0 = kmalloc_slab(size);
#line 250
      s = tmp___0;
      }
#line 252
      if (! s) {
#line 253
        return ((void *)16);
      }
      {
#line 255
      ret = kmem_cache_alloc_notrace(s, flags);
      }
      __here: 
      {
#line 257
      trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )s->size,
                    flags);
      }
#line 259
      return (ret);
    }
  }
  {
#line 262
  tmp___1 = __kmalloc(size, flags);
  }
#line 262
  return (tmp___1);
}
}
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 213
  if (size != 0U) {
#line 213
    if ((unsigned long )n > 0xffffffffUL / (unsigned long )size) {
#line 214
      return ((void *)0);
    }
  }
  {
#line 215
  tmp = __kmalloc(n * size, flags | 32768U);
  }
#line 215
  return (tmp);
}
}
#line 229 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
#line 231
  tmp = kmalloc(size, flags);
  }
#line 231
  return (tmp);
}
}
#line 234 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *__kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
#line 236
  tmp = __kmalloc(size, flags);
  }
#line 236
  return (tmp);
}
}
#line 241 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kmem_cache_alloc_node(struct kmem_cache *cachep , gfp_t flags ,
                                            int node ) 
{ void *tmp ;

  {
  {
#line 244
  tmp = kmem_cache_alloc(cachep, flags);
  }
#line 244
  return (tmp);
}
}
#line 257
extern void *__kmalloc_track_caller(size_t  , gfp_t  , unsigned long  ) ;
#line 294 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ void *tmp ;

  {
  {
#line 296
  tmp = kmem_cache_alloc(k, flags | 32768U);
  }
#line 296
  return (tmp);
}
}
#line 304 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
#line 306
  tmp = kmalloc(size, flags | 32768U);
  }
#line 306
  return (tmp);
}
}
#line 315 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
#line 317
  tmp = kmalloc_node(size, flags | 32768U, node);
  }
#line 317
  return (tmp);
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
extern int ( /* format attribute */  __request_module)(bool wait , char const   *name 
                                                       , ...) ;
#line 50
extern struct subprocess_info *call_usermodehelper_setup(char *path , char **argv ,
                                                         char **envp , gfp_t gfp_mask ) ;
#line 54
extern void call_usermodehelper_setkeys(struct subprocess_info *info , struct key *session_keyring ) ;
#line 56
extern int call_usermodehelper_stdinpipe(struct subprocess_info *sub_info , struct file **filp ) ;
#line 58
extern void call_usermodehelper_setcleanup(struct subprocess_info *info , void (*cleanup)(char **argv ,
                                                                                          char **envp ) ) ;
#line 68
extern int call_usermodehelper_exec(struct subprocess_info *info , enum umh_wait wait ) ;
#line 72
extern void call_usermodehelper_freeinfo(struct subprocess_info *info ) ;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
__inline static int call_usermodehelper(char *path , char **argv , char **envp , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 78
  if ((int )wait == -1) {
    {
#line 78
    tmp = 32U;
    }
  } else {
    {
#line 78
    tmp = 208U;
    }
  }
  {
#line 78
  gfp_mask = tmp;
#line 80
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
#line 81
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 82
    return (-12);
  }
  {
#line 83
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
#line 83
  return (tmp___0);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
__inline static int call_usermodehelper_keys(char *path , char **argv , char **envp ,
                                             struct key *session_keyring , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 91
  if ((int )wait == -1) {
    {
#line 91
    tmp = 32U;
    }
  } else {
    {
#line 91
    tmp = 208U;
    }
  }
  {
#line 91
  gfp_mask = tmp;
#line 93
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
#line 94
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 95
    return (-12);
  }
  {
#line 97
  call_usermodehelper_setkeys(info, session_keyring);
#line 98
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
#line 98
  return (tmp___0);
}
}
#line 101
extern void usermodehelper_init(void) ;
#line 104
extern int call_usermodehelper_pipe(char *path , char **argv , char **envp , struct file **filp ) ;
#line 107
extern int usermodehelper_disable(void) ;
#line 108
extern void usermodehelper_enable(void) ;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vdso.h"
extern char const   VDSO32_PRELINK[] ;
#line 36
extern void __kernel_sigreturn ;
#line 37
extern void __kernel_rt_sigreturn ;
#line 43
extern char const   vdso32_int80_start ;
#line 43
extern char const   vdso32_int80_end ;
#line 44
extern char const   vdso32_syscall_start ;
#line 44
extern char const   vdso32_syscall_end ;
#line 45
extern char const   vdso32_sysenter_start ;
#line 45
extern char const   vdso32_sysenter_end ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
extern unsigned int vdso_enabled ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void fill_ldt(struct desc_struct *desc , struct user_desc  const  *info ) 
{ 

  {
  {
#line 13
  desc->__annonCompField10.__annonCompField8.limit0 = (unsigned short )(info->limit & 65535U);
#line 14
  desc->__annonCompField10.__annonCompField8.base0 = (unsigned short )(info->base_addr & 65535U);
#line 16
  desc->__annonCompField10.__annonCompField8.base1 = (unsigned int )((info->base_addr & 16711680U) >> 16);
#line 17
  desc->__annonCompField10.__annonCompField8.type = (unsigned int )((info->read_exec_only ^ 1U) << 1);
#line 18
  desc->__annonCompField10.__annonCompField8.type |= (unsigned int )(info->contents << 2);
#line 19
  desc->__annonCompField10.__annonCompField8.s = 1U;
#line 20
  desc->__annonCompField10.__annonCompField8.dpl = 3U;
#line 21
  desc->__annonCompField10.__annonCompField8.p = (unsigned int )(info->seg_not_present ^ 1U);
#line 22
  desc->__annonCompField10.__annonCompField8.limit = (unsigned int )((info->limit & 983040U) >> 16);
#line 23
  desc->__annonCompField10.__annonCompField8.avl = (unsigned int )info->useable;
#line 24
  desc->__annonCompField10.__annonCompField8.d = (unsigned int )info->seg_32bit;
#line 25
  desc->__annonCompField10.__annonCompField8.g = (unsigned int )info->limit_in_pages;
#line 26
  desc->__annonCompField10.__annonCompField8.base2 = (unsigned int )((info->base_addr & 4278190080U) >> 24);
#line 31
  desc->__annonCompField10.__annonCompField8.l = 0U;
  }
#line 32
  return;
}
}
#line 34
extern struct desc_ptr idt_descr ;
#line 35
extern gate_desc idt_table[] ;
#line 40
extern struct gdt_page per_cpu__gdt_page  __attribute__((__section__(".data.percpu.page_aligned"))) ;
#line 42 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static struct desc_struct *get_cpu_gdt_table(unsigned int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 44
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__gdt_page));
  }
#line 44
  return (((struct gdt_page *)(__ptr + __per_cpu_offset[cpu]))->gdt);
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void pack_gate(gate_desc *gate , unsigned char type , unsigned long base ,
                               unsigned int dpl , unsigned int flags , unsigned short seg ) 
{ 

  {
  {
#line 69
  gate->__annonCompField10.__annonCompField9.a = (unsigned int )((unsigned long )((int )seg << 16) | (base & 65535UL));
#line 70
  gate->__annonCompField10.__annonCompField9.b = (unsigned int )((base & 4294901760UL) | (unsigned long )((((unsigned int )(128 | (int )type) | (dpl << 5)) & 255U) << 8));
  }
#line 72
  return;
}
}
#line 76 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static int desc_empty(void const   *ptr ) 
{ u32 const   *desc ;

  {
  {
#line 78
  desc = (u32 const   *)ptr;
  }
#line 79
  return (! (*(desc + 0) | *(desc + 1)));
}
}
#line 105 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void paravirt_alloc_ldt(struct desc_struct *ldt , unsigned int entries ) 
{ 

  {
#line 107
  return;
}
}
#line 109 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void paravirt_free_ldt(struct desc_struct *ldt , unsigned int entries ) 
{ 

  {
#line 111
  return;
}
}
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_write_idt_entry(gate_desc *idt , int entry , gate_desc const   *gate ) 
{ 

  {
  {
#line 119
  __constant_memcpy((void *)(idt + entry), (void const   *)gate, (unsigned int )sizeof(*gate));
  }
#line 120
  return;
}
}
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_write_ldt_entry(struct desc_struct *ldt , int entry ,
                                            void const   *desc ) 
{ 

  {
  {
#line 125
  __constant_memcpy((void *)(ldt + entry), desc, 8U);
  }
#line 126
  return;
}
}
#line 128 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_write_gdt_entry(struct desc_struct *gdt , int entry ,
                                            void const   *desc , int type ) 
{ unsigned int size ;

  {
#line 133
  if (type == 9) {
    goto switch_64_9;
  } else {
#line 136
    if (type == 2) {
      goto switch_64_2;
    } else {
      {
      goto switch_64_default;
#line 132
      if (0) {
        switch_64_9: /* CIL Label */ 
        {
#line 134
        size = (unsigned int )sizeof(tss_desc );
        }
        goto switch_64_break;
        switch_64_2: /* CIL Label */ 
        {
#line 137
        size = (unsigned int )sizeof(ldt_desc );
        }
        goto switch_64_break;
        switch_64_default: /* CIL Label */ 
        {
#line 140
        size = (unsigned int )sizeof(struct desc_struct );
        }
        goto switch_64_break;
      } else {
        switch_64_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
#line 143
  __memcpy((void *)(gdt + entry), desc, size);
  }
#line 144
  return;
}
}
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void pack_descriptor(struct desc_struct *desc , unsigned long base ,
                                     unsigned long limit , unsigned char type , unsigned char flags ) 
{ 

  {
  {
#line 150
  desc->__annonCompField10.__annonCompField9.a = (unsigned int )(((base & 65535UL) << 16) | (limit & 65535UL));
#line 151
  desc->__annonCompField10.__annonCompField9.b = (unsigned int )(((((base & 4278190080UL) | ((base & 16711680UL) >> 16)) | (limit & 983040UL)) | (unsigned long )(((int )type & 255) << 8)) | (unsigned long )(((int )flags & 15) << 20));
#line 154
  desc->__annonCompField10.__annonCompField8.p = 1U;
  }
#line 155
  return;
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_tssldt_descriptor(void *d , unsigned long addr , unsigned int type ,
                                           unsigned int size ) 
{ 

  {
  {
#line 173
  pack_descriptor((struct desc_struct *)d, addr, (unsigned long )size, (unsigned char )(128U | type),
                  (unsigned char)0);
  }
#line 175
  return;
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void __set_tss_desc(unsigned int cpu , unsigned int entry , void *addr ) 
{ struct desc_struct *d ;
  struct desc_struct *tmp ;
  tss_desc tss ;

  {
  {
#line 179
  tmp = get_cpu_gdt_table(cpu);
#line 179
  d = tmp;
#line 189
  set_tssldt_descriptor((void *)(& tss), (unsigned long )addr, 9U, (unsigned int )(((unsigned long )((unsigned int )(& ((struct tss_struct *)0)->io_bitmap) + 8192U) + sizeof(unsigned long )) - 1UL));
#line 192
  native_write_gdt_entry(d, (int )entry, (void const   *)(& tss), 9);
  }
#line 193
  return;
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_set_ldt(void const   *addr , unsigned int entries ) 
{ unsigned int cpu ;
  int ret__ ;
  ldt_desc ldt ;
  struct desc_struct *tmp ;
  long tmp___0 ;

  {
  {
#line 199
  tmp___0 = __builtin_expect((long )(! (! (entries == 0U))), 1L);
  }
#line 199
  if (tmp___0) {
    {
#line 200
    __asm__  volatile   ("lldt %w0": : "q" (0));
    }
  } else {
#line 202
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_65_1;
    } else {
#line 202
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_65_2;
      } else {
#line 202
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_65_4;
        } else {
#line 202
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_65_8;
          } else {
            {
            goto switch_65_default;
#line 202
            if (0) {
              switch_65_1: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_65_break;
              switch_65_2: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_65_break;
              switch_65_4: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_65_break;
              switch_65_8: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_65_break;
              switch_65_default: /* CIL Label */ 
              {
#line 202
              __bad_percpu_size();
              }
            } else {
              switch_65_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 202
    cpu = (unsigned int )ret__;
#line 205
    set_tssldt_descriptor((void *)(& ldt), (unsigned long )addr, 2U, entries * 8U - 1U);
#line 207
    tmp = get_cpu_gdt_table(cpu);
#line 207
    native_write_gdt_entry(tmp, 17, (void const   *)(& ldt), 2);
#line 209
    __asm__  volatile   ("lldt %w0": : "q" (136));
    }
  }
#line 211
  return;
}
}
#line 213 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_tr_desc(void) 
{ 

  {
  {
#line 215
  __asm__  volatile   ("ltr %w0": : "q" (128));
  }
#line 216
  return;
}
}
#line 218 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_gdt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
#line 220
  __asm__  volatile   ("lgdt %0": : "m" (*dtr));
  }
#line 221
  return;
}
}
#line 223 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_idt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
#line 225
  __asm__  volatile   ("lidt %0": : "m" (*dtr));
  }
#line 226
  return;
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_store_gdt(struct desc_ptr *dtr ) 
{ 

  {
  {
#line 230
  __asm__  volatile   ("sgdt %0": "=m" (*dtr));
  }
#line 231
  return;
}
}
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_store_idt(struct desc_ptr *dtr ) 
{ 

  {
  {
#line 235
  __asm__  volatile   ("sidt %0": "=m" (*dtr));
  }
#line 236
  return;
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static unsigned long native_store_tr(void) 
{ unsigned long tr ;

  {
  {
#line 241
  __asm__  volatile   ("str %0": "=r" (tr));
  }
#line 242
  return (tr);
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_tls(struct thread_struct *t , unsigned int cpu ) 
{ unsigned int i ;
  struct desc_struct *gdt ;
  struct desc_struct *tmp ;

  {
  {
#line 248
  tmp = get_cpu_gdt_table(cpu);
#line 248
  gdt = tmp;
#line 250
  i = 0U;
  }
  {
#line 250
  while (1) {
    while_66_continue: /* CIL Label */ ;
#line 250
    if (! (i < 3U)) {
      goto while_66_break;
    }
    {
#line 251
    *(gdt + (6U + i)) = t->tls_array[i];
#line 250
    i ++;
    }
  }
  while_66_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 270 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void clear_LDT(void) 
{ 

  {
  {
#line 272
  native_set_ldt((void const   *)((void *)0), 0U);
  }
#line 273
  return;
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void load_LDT_nolock(mm_context_t *pc ) 
{ 

  {
  {
#line 280
  native_set_ldt((void const   *)pc->ldt, (unsigned int )pc->size);
  }
#line 281
  return;
}
}
#line 283 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void load_LDT(mm_context_t *pc ) 
{ 

  {
  {
#line 285
  while (1) {
    while_67_continue: /* CIL Label */ ;
    goto while_67_break;
  }
  while_67_break: /* CIL Label */ ;
  }
  {
#line 286
  load_LDT_nolock(pc);
  }
  {
#line 287
  while (1) {
    while_68_continue: /* CIL Label */ ;
    goto while_68_break;
  }
  while_68_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 290 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static unsigned long get_desc_base(struct desc_struct  const  *desc ) 
{ 

  {
#line 292
  return ((unsigned long )(((unsigned int const   )desc->__annonCompField10.__annonCompField8.base0 | (desc->__annonCompField10.__annonCompField8.base1 << 16)) | (desc->__annonCompField10.__annonCompField8.base2 << 24)));
}
}
#line 295 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static unsigned long get_desc_limit(struct desc_struct  const  *desc ) 
{ 

  {
#line 297
  return ((unsigned long )((unsigned int const   )desc->__annonCompField10.__annonCompField8.limit0 | (desc->__annonCompField10.__annonCompField8.limit << 16)));
}
}
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void _set_gate(int gate , unsigned int type , void *addr , unsigned int dpl ,
                               unsigned int ist , unsigned int seg ) 
{ gate_desc s ;

  {
  {
#line 304
  pack_gate(& s, (unsigned char )type, (unsigned long )addr, dpl, ist, (unsigned short )seg);
#line 309
  native_write_idt_entry(idt_table, gate, (gate_desc const   *)(& s));
  }
#line 310
  return;
}
}
#line 318 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 320
  while (1) {
    while_69_continue: /* CIL Label */ ;
    {
#line 320
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 320
    if (tmp) {
      {
#line 320
      while (1) {
        while_70_continue: /* CIL Label */ ;
        {
#line 320
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (320), "i" (sizeof(struct bug_entry )));
        }
        {
#line 320
        while (1) {
          while_71_continue: /* CIL Label */ ;
        }
        while_71_break: /* CIL Label */ ;
        }
        goto while_70_break;
      }
      while_70_break: /* CIL Label */ ;
      }
    }
    goto while_69_break;
  }
  while_69_break: /* CIL Label */ ;
  }
  {
#line 321
  _set_gate((int )n, 14U, addr, 0U, 0U, 96U);
  }
#line 322
  return;
}
}
#line 324
extern int first_system_vector ;
#line 326
extern unsigned long used_vectors[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 328 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void alloc_system_vector(int vector ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 330
  tmp___0 = variable_test_bit(vector, (unsigned long const volatile   *)(used_vectors));
  }
#line 330
  if (tmp___0) {
    {
#line 335
    while (1) {
      while_72_continue: /* CIL Label */ ;
      {
#line 335
      __asm__  volatile   ("1:\tud2\n"
                           ".pushsection __bug_table,\"a\"\n"
                           "2:\t.long 1b, %c0\n"
                           "\t.word %c1, 0\n"
                           "\t.org 2b+%c2\n"
                           ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                           "i" (335), "i" (sizeof(struct bug_entry )));
      }
      {
#line 335
      while (1) {
        while_73_continue: /* CIL Label */ ;
      }
      while_73_break: /* CIL Label */ ;
      }
      goto while_72_break;
    }
    while_72_break: /* CIL Label */ ;
    }
  } else {
    {
#line 331
    set_bit((unsigned int )vector, (unsigned long volatile   *)(used_vectors));
    }
#line 332
    if (first_system_vector > vector) {
      {
#line 333
      first_system_vector = vector;
      }
    }
  }
#line 336
  return;
}
}
#line 338 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void alloc_intr_gate(unsigned int n , void *addr ) 
{ 

  {
  {
#line 340
  alloc_system_vector((int )n);
#line 341
  set_intr_gate(n, addr);
  }
#line 342
  return;
}
}
#line 347 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_system_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 349
  while (1) {
    while_74_continue: /* CIL Label */ ;
    {
#line 349
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 349
    if (tmp) {
      {
#line 349
      while (1) {
        while_75_continue: /* CIL Label */ ;
        {
#line 349
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (349), "i" (sizeof(struct bug_entry )));
        }
        {
#line 349
        while (1) {
          while_76_continue: /* CIL Label */ ;
        }
        while_76_break: /* CIL Label */ ;
        }
        goto while_75_break;
      }
      while_75_break: /* CIL Label */ ;
      }
    }
    goto while_74_break;
  }
  while_74_break: /* CIL Label */ ;
  }
  {
#line 350
  _set_gate((int )n, 14U, addr, 3U, 0U, 96U);
  }
#line 351
  return;
}
}
#line 353 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_system_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 355
  while (1) {
    while_77_continue: /* CIL Label */ ;
    {
#line 355
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 355
    if (tmp) {
      {
#line 355
      while (1) {
        while_78_continue: /* CIL Label */ ;
        {
#line 355
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (355), "i" (sizeof(struct bug_entry )));
        }
        {
#line 355
        while (1) {
          while_79_continue: /* CIL Label */ ;
        }
        while_79_break: /* CIL Label */ ;
        }
        goto while_78_break;
      }
      while_78_break: /* CIL Label */ ;
      }
    }
    goto while_77_break;
  }
  while_77_break: /* CIL Label */ ;
  }
  {
#line 356
  _set_gate((int )n, 15U, addr, 3U, 0U, 96U);
  }
#line 357
  return;
}
}
#line 359 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 361
  while (1) {
    while_80_continue: /* CIL Label */ ;
    {
#line 361
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 361
    if (tmp) {
      {
#line 361
      while (1) {
        while_81_continue: /* CIL Label */ ;
        {
#line 361
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (361), "i" (sizeof(struct bug_entry )));
        }
        {
#line 361
        while (1) {
          while_82_continue: /* CIL Label */ ;
        }
        while_82_break: /* CIL Label */ ;
        }
        goto while_81_break;
      }
      while_81_break: /* CIL Label */ ;
      }
    }
    goto while_80_break;
  }
  while_80_break: /* CIL Label */ ;
  }
  {
#line 362
  _set_gate((int )n, 15U, addr, 0U, 0U, 96U);
  }
#line 363
  return;
}
}
#line 365 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_task_gate(unsigned int n , unsigned int gdt_entry ) 
{ long tmp ;

  {
  {
#line 367
  while (1) {
    while_83_continue: /* CIL Label */ ;
    {
#line 367
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 367
    if (tmp) {
      {
#line 367
      while (1) {
        while_84_continue: /* CIL Label */ ;
        {
#line 367
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (367), "i" (sizeof(struct bug_entry )));
        }
        {
#line 367
        while (1) {
          while_85_continue: /* CIL Label */ ;
        }
        while_85_break: /* CIL Label */ ;
        }
        goto while_84_break;
      }
      while_84_break: /* CIL Label */ ;
      }
    }
    goto while_83_break;
  }
  while_83_break: /* CIL Label */ ;
  }
  {
#line 368
  _set_gate((int )n, 5U, (void *)0, 0U, 0U, gdt_entry << 3);
  }
#line 369
  return;
}
}
#line 371 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
#line 373
  while (1) {
    while_86_continue: /* CIL Label */ ;
    {
#line 373
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
#line 373
    if (tmp) {
      {
#line 373
      while (1) {
        while_87_continue: /* CIL Label */ ;
        {
#line 373
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (373), "i" (sizeof(struct bug_entry )));
        }
        {
#line 373
        while (1) {
          while_88_continue: /* CIL Label */ ;
        }
        while_88_break: /* CIL Label */ ;
        }
        goto while_87_break;
      }
      while_87_break: /* CIL Label */ ;
      }
    }
    goto while_86_break;
  }
  while_86_break: /* CIL Label */ ;
  }
  {
#line 374
  _set_gate(n, 14U, addr, 0U, ist, 96U);
  }
#line 375
  return;
}
}
#line 377 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_system_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
#line 379
  while (1) {
    while_89_continue: /* CIL Label */ ;
    {
#line 379
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
#line 379
    if (tmp) {
      {
#line 379
      while (1) {
        while_90_continue: /* CIL Label */ ;
        {
#line 379
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (379), "i" (sizeof(struct bug_entry )));
        }
        {
#line 379
        while (1) {
          while_91_continue: /* CIL Label */ ;
        }
        while_91_break: /* CIL Label */ ;
        }
        goto while_90_break;
      }
      while_90_break: /* CIL Label */ ;
      }
    }
    goto while_89_break;
  }
  while_89_break: /* CIL Label */ ;
  }
  {
#line 380
  _set_gate(n, 14U, addr, 3U, ist, 96U);
  }
#line 381
  return;
}
}
#line 338 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
extern int arch_setup_additional_pages(struct linux_binprm *bprm , int uses_interp ) ;
#line 341
extern int syscall32_setup_pages(struct linux_binprm * , int exstack ) ;
#line 344
extern unsigned long arch_randomize_brk(struct mm_struct *mm ) ;
#line 391 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
extern Elf64_Dyn _DYNAMIC[] ;
#line 401 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
__inline static int elf_coredump_extra_notes_size(void) 
{ 

  {
#line 401
  return (0);
}
}
#line 402 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
__inline static int elf_coredump_extra_notes_write(struct file *file , loff_t *foffset ) 
{ 

  {
#line 403
  return (0);
}
}
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
extern int parse_args(char const   *name , char *args , struct kernel_param *params ,
                      unsigned int num , int (*unknown)(char *param , char *val ) ) ;
#line 143
extern void destroy_params(struct kernel_param  const  *params , unsigned int num ) ;
#line 157
extern int param_set_byte(char const   *val , struct kernel_param *kp ) ;
#line 158
extern int param_get_byte(char *buffer , struct kernel_param *kp ) ;
#line 161
extern int param_set_short(char const   *val , struct kernel_param *kp ) ;
#line 162
extern int param_get_short(char *buffer , struct kernel_param *kp ) ;
#line 165
extern int param_set_ushort(char const   *val , struct kernel_param *kp ) ;
#line 166
extern int param_get_ushort(char *buffer , struct kernel_param *kp ) ;
#line 169
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
#line 170
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
#line 173
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
#line 174
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
#line 177
extern int param_set_long(char const   *val , struct kernel_param *kp ) ;
#line 178
extern int param_get_long(char *buffer , struct kernel_param *kp ) ;
#line 181
extern int param_set_ulong(char const   *val , struct kernel_param *kp ) ;
#line 182
extern int param_get_ulong(char *buffer , struct kernel_param *kp ) ;
#line 185
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
#line 186
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
#line 189
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
#line 190
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
#line 193
extern int param_set_invbool(char const   *val , struct kernel_param *kp ) ;
#line 194
extern int param_get_invbool(char *buffer , struct kernel_param *kp ) ;
#line 209
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
#line 210
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
#line 212
extern int param_set_copystring(char const   *val , struct kernel_param *kp ) ;
#line 213
extern int param_get_string(char *buffer , struct kernel_param *kp ) ;
#line 220
extern int module_param_sysfs_setup(struct module *mod , struct kernel_param *kparam ,
                                    unsigned int num_params ) ;
#line 224
extern void module_param_sysfs_remove(struct module *mod ) ;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
extern void marker_update_probe_range(struct marker *begin , struct marker *end ) ;
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
__inline static void ( /* format attribute */  ___mark_check_format)(char const   *fmt 
                                                                     , ...) 
{ 

  {
#line 178
  return;
}
}
#line 186
extern marker_probe_func __mark_empty_function ;
#line 188
extern void marker_probe_cb(struct marker  const  *mdata , void *call_private  , ...) ;
#line 195
extern int marker_probe_register(char const   *name , char const   *format , marker_probe_func *probe ,
                                 void *probe_private ) ;
#line 201
extern int marker_probe_unregister(char const   *name , marker_probe_func *probe ,
                                   void *probe_private ) ;
#line 206
extern int marker_probe_unregister_private_data(marker_probe_func *probe , void *probe_private ) ;
#line 209
extern void *marker_get_private_data(char const   *name , marker_probe_func *probe ,
                                     int num ) ;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu.h"
extern void *pcpu_base_addr ;
#line 64
extern size_t pcpu_setup_first_chunk(struct page *(*get_page_fn)(unsigned int cpu ,
                                                                 int pageno ) , size_t static_size ,
                                     size_t reserved_size , ssize_t dyn_size , ssize_t unit_size ,
                                     void *base_addr , void (*populate_pte_fn)(unsigned long addr ) )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 70
extern ssize_t pcpu_embed_first_chunk(size_t static_size , size_t reserved_size ,
                                      ssize_t dyn_size , ssize_t unit_size )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 81
extern void *__alloc_reserved_percpu(size_t size , size_t align ) ;
#line 99
extern void *__alloc_percpu(size_t size , size_t align ) ;
#line 100
extern void free_percpu(void *__pdata ) ;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_inc(local_t *l ) 
{ 

  {
  {
#line 21
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
#line 23
  return;
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_dec(local_t *l ) 
{ 

  {
  {
#line 27
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
#line 29
  return;
}
}
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_add(long i , local_t *l ) 
{ 

  {
  {
#line 33
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
#line 36
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_sub(long i , local_t *l ) 
{ 

  {
  {
#line 40
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
#line 43
  return;
}
}
#line 54 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_sub_and_test(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
#line 58
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%2,%0; sete %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
#line 61
  return ((int )c);
}
}
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_dec_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
#line 76
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
#line 79
  return ((int )c != 0);
}
}
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_inc_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
#line 94
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
#line 97
  return ((int )c != 0);
}
}
#line 109 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_add_negative(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
#line 113
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%2,%0; sets %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
#line 116
  return ((int )c);
}
}
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static long local_add_return(long i , local_t *l ) 
{ long __i ;

  {
  {
#line 135
  __i = i;
#line 136
  __asm__  volatile   (" "
                       "xaddl"
                       " "
                       "%0, %1;": "+r" (i), "+m" (l->a.counter): : "memory");
  }
#line 139
  return (i + __i);
}
}
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static long local_sub_return(long i , local_t *l ) 
{ long tmp ;

  {
  {
#line 153
  tmp = local_add_return(- i, l);
  }
#line 153
  return (tmp);
}
}
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
extern int init_module(void) ;
#line 68
extern void cleanup_module(void) ;
#line 73
extern struct exception_table_entry  const  *search_extable(struct exception_table_entry  const  *first ,
                                                            struct exception_table_entry  const  *last ,
                                                            unsigned long value ) ;
#line 77
extern void sort_extable(struct exception_table_entry *start , struct exception_table_entry *finish ) ;
#line 79
extern void sort_main_extable(void) ;
#line 165
extern struct exception_table_entry  const  *search_exception_tables(unsigned long add ) ;
#line 172
extern void *__symbol_get(char const   *symbol ) ;
#line 173
extern void *__symbol_get_gpl(char const   *symbol ) ;
#line 362
extern struct mutex module_mutex ;
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int module_is_live(struct module *mod ) 
{ 

  {
#line 369
  return ((unsigned int )mod->state != 2U);
}
}
#line 372
extern struct module *__module_text_address(unsigned long addr ) ;
#line 373
extern struct module *__module_address(unsigned long addr ) ;
#line 374
extern bool is_module_address(unsigned long addr ) ;
#line 375
extern bool is_module_text_address(unsigned long addr ) ;
#line 377 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int within_module_core(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
#line 379
  if ((unsigned long )mod->module_core <= addr) {
#line 379
    if (addr < (unsigned long )mod->module_core + (unsigned long )mod->core_size) {
      {
#line 379
      tmp = 1;
      }
    } else {
      {
#line 379
      tmp = 0;
      }
    }
  } else {
    {
#line 379
    tmp = 0;
    }
  }
#line 379
  return (tmp);
}
}
#line 383 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int within_module_init(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
#line 385
  if ((unsigned long )mod->module_init <= addr) {
#line 385
    if (addr < (unsigned long )mod->module_init + (unsigned long )mod->init_size) {
      {
#line 385
      tmp = 1;
      }
    } else {
      {
#line 385
      tmp = 0;
      }
    }
  } else {
    {
#line 385
    tmp = 0;
    }
  }
#line 385
  return (tmp);
}
}
#line 390
extern struct module *find_module(char const   *name ) ;
#line 404
extern struct kernel_symbol  const  *find_symbol(char const   *name , struct module **owner ,
                                                 unsigned long const   **crc , bool gplok ,
                                                 bool warn ) ;
#line 411
extern bool each_symbol(bool (*fn)(struct symsearch  const  *arr , struct module *owner ,
                                   unsigned int symnum , void *data ) , void *data ) ;
#line 416
extern int module_get_kallsym(unsigned int symnum , unsigned long *value , char *type ,
                              char *name , char *module_name , int *exported ) ;
#line 420
extern unsigned long module_kallsyms_lookup_name(char const   *name ) ;
#line 422
extern int module_kallsyms_on_each_symbol(int (*fn)(void * , char const   * , struct module * ,
                                                    unsigned long  ) , void *data ) ;
#line 426
extern  __attribute__((__noreturn__)) void __module_put_and_exit(struct module *mod ,
                                                                 long code ) ;
#line 431
extern unsigned int module_refcount(struct module *mod ) ;
#line 432
extern void __symbol_put(char const   *symbol ) ;
#line 434
extern void symbol_put_addr(void *addr ) ;
#line 436 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static local_t *__module_ref_addr(struct module *mod , int cpu ) 
{ 

  {
#line 439
  return ((local_t *)(mod->refptr + __per_cpu_offset[cpu]));
}
}
#line 447 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static void __module_get(struct module *module ) 
{ int ret__ ;
  local_t *tmp ;

  {
#line 449
  if (module) {
    {
#line 450
    while (1) {
      while_92_continue: /* CIL Label */ ;
      goto while_92_break;
    }
    while_92_break: /* CIL Label */ ;
    }
#line 450
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_93_1;
    } else {
#line 450
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_93_2;
      } else {
#line 450
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_93_4;
        } else {
#line 450
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_93_8;
          } else {
            {
            goto switch_93_default;
#line 450
            if (0) {
              switch_93_1: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_2: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_4: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_8: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_default: /* CIL Label */ 
              {
#line 450
              __bad_percpu_size();
              }
            } else {
              switch_93_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 450
    tmp = __module_ref_addr(module, ret__);
#line 450
    local_inc(tmp);
    }
    {
#line 451
    while (1) {
      while_94_continue: /* CIL Label */ ;
      goto while_94_break;
    }
    while_94_break: /* CIL Label */ ;
    }
  }
#line 453
  return;
}
}
#line 455 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int try_module_get(struct module *module ) 
{ int ret ;
  unsigned int cpu ;
  int ret__ ;
  local_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 457
  ret = 1;
  }
#line 459
  if (module) {
    {
#line 460
    while (1) {
      while_95_continue: /* CIL Label */ ;
      goto while_95_break;
    }
    while_95_break: /* CIL Label */ ;
    }
#line 460
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_96_1;
    } else {
#line 460
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_96_2;
      } else {
#line 460
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_96_4;
        } else {
#line 460
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_96_8;
          } else {
            {
            goto switch_96_default;
#line 460
            if (0) {
              switch_96_1: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_2: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_4: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_8: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_default: /* CIL Label */ 
              {
#line 460
              __bad_percpu_size();
              }
            } else {
              switch_96_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 460
    cpu = (unsigned int )ret__;
#line 461
    tmp___0 = module_is_live(module);
    }
#line 461
    if (tmp___0) {
      {
#line 461
      tmp___1 = 1;
      }
    } else {
      {
#line 461
      tmp___1 = 0;
      }
    }
    {
#line 461
    tmp___2 = __builtin_expect((long )tmp___1, 1L);
    }
#line 461
    if (tmp___2) {
      {
#line 462
      tmp = __module_ref_addr(module, (int )cpu);
#line 462
      local_inc(tmp);
      }
    } else {
      {
#line 464
      ret = 0;
      }
    }
    {
#line 465
    while (1) {
      while_97_continue: /* CIL Label */ ;
      goto while_97_break;
    }
    while_97_break: /* CIL Label */ ;
    }
  }
#line 467
  return (ret);
}
}
#line 470
extern void module_put(struct module *module ) ;
#line 487
extern int use_module(struct module *a , struct module *b ) ;
#line 499
extern char const   *module_address_lookup(unsigned long addr , unsigned long *symbolsize ,
                                           unsigned long *offset , char **modname ,
                                           char *namebuf ) ;
#line 504
extern int lookup_module_symbol_name(unsigned long addr , char *symname ) ;
#line 505
extern int lookup_module_symbol_attrs(unsigned long addr , unsigned long *size , unsigned long *offset ,
                                      char *modname , char *name ) ;
#line 508
extern struct exception_table_entry  const  *search_module_extables(unsigned long addr ) ;
#line 510
extern int register_module_notifier(struct notifier_block *nb ) ;
#line 511
extern int unregister_module_notifier(struct notifier_block *nb ) ;
#line 513
extern void print_modules(void) ;
#line 515
extern void module_update_markers(void) ;
#line 517
extern void module_update_tracepoints(void) ;
#line 518
extern int module_get_iter_tracepoints(struct tracepoint_iter *iter ) ;
#line 650
extern struct kset *module_kset ;
#line 651
extern struct kobj_type module_ktype ;
#line 652
extern int module_sysfs_initialized ;
#line 654
extern int mod_sysfs_init(struct module *mod ) ;
#line 655
extern int mod_sysfs_setup(struct module *mod , struct kernel_param *kparam , unsigned int num_params ) ;
#line 658
extern int module_add_modinfo_attrs(struct module *mod ) ;
#line 659
extern void module_remove_modinfo_attrs(struct module *mod ) ;
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
extern int fixup_exception(struct pt_regs *regs ) ;
#line 116
extern int __get_user_1(void) ;
#line 117
extern int __get_user_2(void) ;
#line 118
extern int __get_user_4(void) ;
#line 119
extern int __get_user_8(void) ;
#line 120
extern int __get_user_bad(void) ;
#line 221
extern void __put_user_bad(void) ;
#line 227
extern void __put_user_1(void) ;
#line 228
extern void __put_user_2(void) ;
#line 229
extern void __put_user_4(void) ;
#line 230
extern void __put_user_8(void) ;
#line 563
extern struct movsl_mask movsl_mask ;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
extern unsigned long __copy_to_user_ll(void *to , void const   *from , unsigned long n ) ;
#line 16
extern unsigned long __copy_from_user_ll(void *to , void const   *from , unsigned long n ) ;
#line 18
extern unsigned long __copy_from_user_ll_nozero(void *to , void const   *from , unsigned long n ) ;
#line 20
extern unsigned long __copy_from_user_ll_nocache(void *to , void const   *from , unsigned long n ) ;
#line 22
extern unsigned long __copy_from_user_ll_nocache_nozero(void *to , void const   *from ,
                                                        unsigned long n ) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_to_user_inatomic(void *to , void const   *from ,
                                                      unsigned long n ) 
{ unsigned long ret ;
  unsigned long tmp ;

  {
#line 47
  if (0) {
#line 51
    if ((int )n == 1) {
      goto switch_98_1;
    } else {
#line 55
      if ((int )n == 2) {
        goto switch_98_2;
      } else {
#line 59
        if ((int )n == 4) {
          goto switch_98_4;
        } else {
#line 50
          if (0) {
            switch_98_1: /* CIL Label */ 
            {
#line 52
            while (1) {
              while_99_continue: /* CIL Label */ ;
              {
#line 52
              ret = 0UL;
              }
#line 52
              if (1 == 1) {
                goto switch_100_1;
              } else {
#line 52
                if (1 == 2) {
                  goto switch_100_2;
                } else {
#line 52
                  if (1 == 4) {
                    goto switch_100_4;
                  } else {
#line 52
                    if (1 == 8) {
                      goto switch_100_8;
                    } else {
                      {
                      goto switch_100_default;
#line 52
                      if (0) {
                        switch_100_1: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_100_break;
                        switch_100_2: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_100_break;
                        switch_100_4: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_100_break;
                        switch_100_8: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u8 *)from)),
                                             "r" ((u8 *)to), "i" (1), "0" (ret));
                        }
                        goto switch_100_break;
                        switch_100_default: /* CIL Label */ 
                        {
#line 52
                        __put_user_bad();
                        }
                      } else {
                        switch_100_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_99_break;
            }
            while_99_break: /* CIL Label */ ;
            }
#line 54
            return (ret);
            switch_98_2: /* CIL Label */ 
            {
#line 56
            while (1) {
              while_101_continue: /* CIL Label */ ;
              {
#line 56
              ret = 0UL;
              }
#line 56
              if (2 == 1) {
                goto switch_102_1;
              } else {
#line 56
                if (2 == 2) {
                  goto switch_102_2;
                } else {
#line 56
                  if (2 == 4) {
                    goto switch_102_4;
                  } else {
#line 56
                    if (2 == 8) {
                      goto switch_102_8;
                    } else {
                      {
                      goto switch_102_default;
#line 56
                      if (0) {
                        switch_102_1: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_102_break;
                        switch_102_2: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_102_break;
                        switch_102_4: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_102_break;
                        switch_102_8: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u16 *)from)),
                                             "r" ((u16 *)to), "i" (2), "0" (ret));
                        }
                        goto switch_102_break;
                        switch_102_default: /* CIL Label */ 
                        {
#line 56
                        __put_user_bad();
                        }
                      } else {
                        switch_102_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_101_break;
            }
            while_101_break: /* CIL Label */ ;
            }
#line 58
            return (ret);
            switch_98_4: /* CIL Label */ 
            {
#line 60
            while (1) {
              while_103_continue: /* CIL Label */ ;
              {
#line 60
              ret = 0UL;
              }
#line 60
              if (4 == 1) {
                goto switch_104_1;
              } else {
#line 60
                if (4 == 2) {
                  goto switch_104_2;
                } else {
#line 60
                  if (4 == 4) {
                    goto switch_104_4;
                  } else {
#line 60
                    if (4 == 8) {
                      goto switch_104_8;
                    } else {
                      {
                      goto switch_104_default;
#line 60
                      if (0) {
                        switch_104_1: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_104_break;
                        switch_104_2: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_104_break;
                        switch_104_4: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_104_break;
                        switch_104_8: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u32 *)from)),
                                             "r" ((u32 *)to), "i" (4), "0" (ret));
                        }
                        goto switch_104_break;
                        switch_104_default: /* CIL Label */ 
                        {
#line 60
                        __put_user_bad();
                        }
                      } else {
                        switch_104_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_103_break;
            }
            while_103_break: /* CIL Label */ ;
            }
#line 62
            return (ret);
          } else {
            switch_98_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 65
  tmp = __copy_to_user_ll(to, from, n);
  }
#line 65
  return (tmp);
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_to_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
#line 85
  might_fault();
#line 86
  tmp = __copy_to_user_inatomic(to, from, n);
  }
#line 86
  return (tmp);
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user_inatomic(void *to , void const   *from ,
                                                        unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 97
  if (0) {
#line 101
    if ((int )n == 1) {
      goto switch_105_1;
    } else {
#line 104
      if ((int )n == 2) {
        goto switch_105_2;
      } else {
#line 107
        if ((int )n == 4) {
          goto switch_105_4;
        } else {
#line 100
          if (0) {
            switch_105_1: /* CIL Label */ 
            {
#line 102
            while (1) {
              while_106_continue: /* CIL Label */ ;
              {
#line 102
              ret = 0UL;
              }
#line 102
              if (1 == 1) {
                goto switch_107_1;
              } else {
#line 102
                if (1 == 2) {
                  goto switch_107_2;
                } else {
#line 102
                  if (1 == 4) {
                    goto switch_107_4;
                  } else {
#line 102
                    if (1 == 8) {
                      goto switch_107_8;
                    } else {
                      {
                      goto switch_107_default;
#line 102
                      if (0) {
                        switch_107_1: /* CIL Label */ 
                        {
#line 102
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_107_break;
                        switch_107_2: /* CIL Label */ 
                        {
#line 102
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_107_break;
                        switch_107_4: /* CIL Label */ 
                        {
#line 102
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_107_break;
                        switch_107_8: /* CIL Label */ 
                        {
#line 102
                        tmp = __get_user_bad();
#line 102
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_107_break;
                        switch_107_default: /* CIL Label */ 
                        {
#line 102
                        tmp___0 = __get_user_bad();
#line 102
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_107_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_106_break;
            }
            while_106_break: /* CIL Label */ ;
            }
#line 103
            return (ret);
            switch_105_2: /* CIL Label */ 
            {
#line 105
            while (1) {
              while_108_continue: /* CIL Label */ ;
              {
#line 105
              ret = 0UL;
              }
#line 105
              if (2 == 1) {
                goto switch_109_1;
              } else {
#line 105
                if (2 == 2) {
                  goto switch_109_2;
                } else {
#line 105
                  if (2 == 4) {
                    goto switch_109_4;
                  } else {
#line 105
                    if (2 == 8) {
                      goto switch_109_8;
                    } else {
                      {
                      goto switch_109_default;
#line 105
                      if (0) {
                        switch_109_1: /* CIL Label */ 
                        {
#line 105
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_109_break;
                        switch_109_2: /* CIL Label */ 
                        {
#line 105
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_109_break;
                        switch_109_4: /* CIL Label */ 
                        {
#line 105
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_109_break;
                        switch_109_8: /* CIL Label */ 
                        {
#line 105
                        tmp___1 = __get_user_bad();
#line 105
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_109_break;
                        switch_109_default: /* CIL Label */ 
                        {
#line 105
                        tmp___2 = __get_user_bad();
#line 105
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_109_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_108_break;
            }
            while_108_break: /* CIL Label */ ;
            }
#line 106
            return (ret);
            switch_105_4: /* CIL Label */ 
            {
#line 108
            while (1) {
              while_110_continue: /* CIL Label */ ;
              {
#line 108
              ret = 0UL;
              }
#line 108
              if (4 == 1) {
                goto switch_111_1;
              } else {
#line 108
                if (4 == 2) {
                  goto switch_111_2;
                } else {
#line 108
                  if (4 == 4) {
                    goto switch_111_4;
                  } else {
#line 108
                    if (4 == 8) {
                      goto switch_111_8;
                    } else {
                      {
                      goto switch_111_default;
#line 108
                      if (0) {
                        switch_111_1: /* CIL Label */ 
                        {
#line 108
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_111_break;
                        switch_111_2: /* CIL Label */ 
                        {
#line 108
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_111_break;
                        switch_111_4: /* CIL Label */ 
                        {
#line 108
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_111_break;
                        switch_111_8: /* CIL Label */ 
                        {
#line 108
                        tmp___3 = __get_user_bad();
#line 108
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_111_break;
                        switch_111_default: /* CIL Label */ 
                        {
#line 108
                        tmp___4 = __get_user_bad();
#line 108
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_111_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_110_break;
            }
            while_110_break: /* CIL Label */ ;
            }
#line 109
            return (ret);
          } else {
            switch_105_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 112
  tmp___5 = __copy_from_user_ll_nozero(to, from, n);
  }
#line 112
  return (tmp___5);
}
}
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 140
  might_fault();
  }
#line 141
  if (0) {
#line 145
    if ((int )n == 1) {
      goto switch_112_1;
    } else {
#line 148
      if ((int )n == 2) {
        goto switch_112_2;
      } else {
#line 151
        if ((int )n == 4) {
          goto switch_112_4;
        } else {
#line 144
          if (0) {
            switch_112_1: /* CIL Label */ 
            {
#line 146
            while (1) {
              while_113_continue: /* CIL Label */ ;
              {
#line 146
              ret = 0UL;
              }
#line 146
              if (1 == 1) {
                goto switch_114_1;
              } else {
#line 146
                if (1 == 2) {
                  goto switch_114_2;
                } else {
#line 146
                  if (1 == 4) {
                    goto switch_114_4;
                  } else {
#line 146
                    if (1 == 8) {
                      goto switch_114_8;
                    } else {
                      {
                      goto switch_114_default;
#line 146
                      if (0) {
                        switch_114_1: /* CIL Label */ 
                        {
#line 146
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_114_break;
                        switch_114_2: /* CIL Label */ 
                        {
#line 146
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_114_break;
                        switch_114_4: /* CIL Label */ 
                        {
#line 146
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_114_break;
                        switch_114_8: /* CIL Label */ 
                        {
#line 146
                        tmp = __get_user_bad();
#line 146
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_114_break;
                        switch_114_default: /* CIL Label */ 
                        {
#line 146
                        tmp___0 = __get_user_bad();
#line 146
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_114_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_113_break;
            }
            while_113_break: /* CIL Label */ ;
            }
#line 147
            return (ret);
            switch_112_2: /* CIL Label */ 
            {
#line 149
            while (1) {
              while_115_continue: /* CIL Label */ ;
              {
#line 149
              ret = 0UL;
              }
#line 149
              if (2 == 1) {
                goto switch_116_1;
              } else {
#line 149
                if (2 == 2) {
                  goto switch_116_2;
                } else {
#line 149
                  if (2 == 4) {
                    goto switch_116_4;
                  } else {
#line 149
                    if (2 == 8) {
                      goto switch_116_8;
                    } else {
                      {
                      goto switch_116_default;
#line 149
                      if (0) {
                        switch_116_1: /* CIL Label */ 
                        {
#line 149
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_116_break;
                        switch_116_2: /* CIL Label */ 
                        {
#line 149
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_116_break;
                        switch_116_4: /* CIL Label */ 
                        {
#line 149
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_116_break;
                        switch_116_8: /* CIL Label */ 
                        {
#line 149
                        tmp___1 = __get_user_bad();
#line 149
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_116_break;
                        switch_116_default: /* CIL Label */ 
                        {
#line 149
                        tmp___2 = __get_user_bad();
#line 149
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_116_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_115_break;
            }
            while_115_break: /* CIL Label */ ;
            }
#line 150
            return (ret);
            switch_112_4: /* CIL Label */ 
            {
#line 152
            while (1) {
              while_117_continue: /* CIL Label */ ;
              {
#line 152
              ret = 0UL;
              }
#line 152
              if (4 == 1) {
                goto switch_118_1;
              } else {
#line 152
                if (4 == 2) {
                  goto switch_118_2;
                } else {
#line 152
                  if (4 == 4) {
                    goto switch_118_4;
                  } else {
#line 152
                    if (4 == 8) {
                      goto switch_118_8;
                    } else {
                      {
                      goto switch_118_default;
#line 152
                      if (0) {
                        switch_118_1: /* CIL Label */ 
                        {
#line 152
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_118_break;
                        switch_118_2: /* CIL Label */ 
                        {
#line 152
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_118_break;
                        switch_118_4: /* CIL Label */ 
                        {
#line 152
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_118_break;
                        switch_118_8: /* CIL Label */ 
                        {
#line 152
                        tmp___3 = __get_user_bad();
#line 152
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_118_break;
                        switch_118_default: /* CIL Label */ 
                        {
#line 152
                        tmp___4 = __get_user_bad();
#line 152
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_118_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_117_break;
            }
            while_117_break: /* CIL Label */ ;
            }
#line 153
            return (ret);
          } else {
            switch_112_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 156
  tmp___5 = __copy_from_user_ll(to, from, n);
  }
#line 156
  return (tmp___5);
}
}
#line 159 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user_nocache(void *to , void const   *from ,
                                                       unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 162
  might_fault();
  }
#line 163
  if (0) {
#line 167
    if ((int )n == 1) {
      goto switch_119_1;
    } else {
#line 170
      if ((int )n == 2) {
        goto switch_119_2;
      } else {
#line 173
        if ((int )n == 4) {
          goto switch_119_4;
        } else {
#line 166
          if (0) {
            switch_119_1: /* CIL Label */ 
            {
#line 168
            while (1) {
              while_120_continue: /* CIL Label */ ;
              {
#line 168
              ret = 0UL;
              }
#line 168
              if (1 == 1) {
                goto switch_121_1;
              } else {
#line 168
                if (1 == 2) {
                  goto switch_121_2;
                } else {
#line 168
                  if (1 == 4) {
                    goto switch_121_4;
                  } else {
#line 168
                    if (1 == 8) {
                      goto switch_121_8;
                    } else {
                      {
                      goto switch_121_default;
#line 168
                      if (0) {
                        switch_121_1: /* CIL Label */ 
                        {
#line 168
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_121_break;
                        switch_121_2: /* CIL Label */ 
                        {
#line 168
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_121_break;
                        switch_121_4: /* CIL Label */ 
                        {
#line 168
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_121_break;
                        switch_121_8: /* CIL Label */ 
                        {
#line 168
                        tmp = __get_user_bad();
#line 168
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_121_break;
                        switch_121_default: /* CIL Label */ 
                        {
#line 168
                        tmp___0 = __get_user_bad();
#line 168
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_121_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_120_break;
            }
            while_120_break: /* CIL Label */ ;
            }
#line 169
            return (ret);
            switch_119_2: /* CIL Label */ 
            {
#line 171
            while (1) {
              while_122_continue: /* CIL Label */ ;
              {
#line 171
              ret = 0UL;
              }
#line 171
              if (2 == 1) {
                goto switch_123_1;
              } else {
#line 171
                if (2 == 2) {
                  goto switch_123_2;
                } else {
#line 171
                  if (2 == 4) {
                    goto switch_123_4;
                  } else {
#line 171
                    if (2 == 8) {
                      goto switch_123_8;
                    } else {
                      {
                      goto switch_123_default;
#line 171
                      if (0) {
                        switch_123_1: /* CIL Label */ 
                        {
#line 171
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_123_break;
                        switch_123_2: /* CIL Label */ 
                        {
#line 171
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_123_break;
                        switch_123_4: /* CIL Label */ 
                        {
#line 171
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_123_break;
                        switch_123_8: /* CIL Label */ 
                        {
#line 171
                        tmp___1 = __get_user_bad();
#line 171
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_123_break;
                        switch_123_default: /* CIL Label */ 
                        {
#line 171
                        tmp___2 = __get_user_bad();
#line 171
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_123_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_122_break;
            }
            while_122_break: /* CIL Label */ ;
            }
#line 172
            return (ret);
            switch_119_4: /* CIL Label */ 
            {
#line 174
            while (1) {
              while_124_continue: /* CIL Label */ ;
              {
#line 174
              ret = 0UL;
              }
#line 174
              if (4 == 1) {
                goto switch_125_1;
              } else {
#line 174
                if (4 == 2) {
                  goto switch_125_2;
                } else {
#line 174
                  if (4 == 4) {
                    goto switch_125_4;
                  } else {
#line 174
                    if (4 == 8) {
                      goto switch_125_8;
                    } else {
                      {
                      goto switch_125_default;
#line 174
                      if (0) {
                        switch_125_1: /* CIL Label */ 
                        {
#line 174
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_125_break;
                        switch_125_2: /* CIL Label */ 
                        {
#line 174
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_125_break;
                        switch_125_4: /* CIL Label */ 
                        {
#line 174
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_125_break;
                        switch_125_8: /* CIL Label */ 
                        {
#line 174
                        tmp___3 = __get_user_bad();
#line 174
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_125_break;
                        switch_125_default: /* CIL Label */ 
                        {
#line 174
                        tmp___4 = __get_user_bad();
#line 174
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_125_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_124_break;
            }
            while_124_break: /* CIL Label */ ;
            }
#line 175
            return (ret);
          } else {
            switch_119_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 178
  tmp___5 = __copy_from_user_ll_nocache(to, from, n);
  }
#line 178
  return (tmp___5);
}
}
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user_inatomic_nocache(void *to , void const   *from ,
                                                                unsigned long n ) 
{ unsigned long tmp ;

  {
  {
#line 185
  tmp = __copy_from_user_ll_nocache_nozero(to, from, n);
  }
#line 185
  return (tmp);
}
}
#line 188
extern unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 190
extern unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) ;
#line 193
extern long strncpy_from_user(char *dst , char const   *src , long count ) ;
#line 195
extern long __strncpy_from_user(char *dst , char const   *src , long count ) ;
#line 214
extern long strnlen_user(char const   *str , long n ) ;
#line 215
extern unsigned long clear_user(void *mem , unsigned long len ) ;
#line 216
extern unsigned long __clear_user(void *mem , unsigned long len ) ;
#line 364 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_num(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 366
  return ((int )((int const   )epd->bEndpointAddress & 15));
}
}
#line 376 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_type(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 378
  return ((int )((int const   )epd->bmAttributes & 3));
}
}
#line 387 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 389
  return (((int const   )epd->bEndpointAddress & 128) == 128);
}
}
#line 398 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 401
  return (((int const   )epd->bEndpointAddress & 128) == 0);
}
}
#line 410 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 413
  return (((int const   )epd->bmAttributes & 3) == 2);
}
}
#line 423 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_control(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 426
  return (((int const   )epd->bmAttributes & 3) == 0);
}
}
#line 437 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_int(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 440
  return (((int const   )epd->bmAttributes & 3) == 3);
}
}
#line 451 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_isoc(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 454
  return (((int const   )epd->bmAttributes & 3) == 1);
}
}
#line 465 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 468
  tmp = usb_endpoint_xfer_bulk(epd);
  }
#line 468
  if (tmp) {
    {
#line 468
    tmp___0 = usb_endpoint_dir_in(epd);
    }
#line 468
    if (tmp___0) {
      {
#line 468
      tmp___1 = 1;
      }
    } else {
      {
#line 468
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 468
    tmp___1 = 0;
    }
  }
#line 468
  return (tmp___1);
}
}
#line 478 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_bulk_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 481
  tmp = usb_endpoint_xfer_bulk(epd);
  }
#line 481
  if (tmp) {
    {
#line 481
    tmp___0 = usb_endpoint_dir_out(epd);
    }
#line 481
    if (tmp___0) {
      {
#line 481
      tmp___1 = 1;
      }
    } else {
      {
#line 481
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 481
    tmp___1 = 0;
    }
  }
#line 481
  return (tmp___1);
}
}
#line 491 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_int_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 494
  tmp = usb_endpoint_xfer_int(epd);
  }
#line 494
  if (tmp) {
    {
#line 494
    tmp___0 = usb_endpoint_dir_in(epd);
    }
#line 494
    if (tmp___0) {
      {
#line 494
      tmp___1 = 1;
      }
    } else {
      {
#line 494
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 494
    tmp___1 = 0;
    }
  }
#line 494
  return (tmp___1);
}
}
#line 504 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_int_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 507
  tmp = usb_endpoint_xfer_int(epd);
  }
#line 507
  if (tmp) {
    {
#line 507
    tmp___0 = usb_endpoint_dir_out(epd);
    }
#line 507
    if (tmp___0) {
      {
#line 507
      tmp___1 = 1;
      }
    } else {
      {
#line 507
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 507
    tmp___1 = 0;
    }
  }
#line 507
  return (tmp___1);
}
}
#line 517 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_isoc_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 520
  tmp = usb_endpoint_xfer_isoc(epd);
  }
#line 520
  if (tmp) {
    {
#line 520
    tmp___0 = usb_endpoint_dir_in(epd);
    }
#line 520
    if (tmp___0) {
      {
#line 520
      tmp___1 = 1;
      }
    } else {
      {
#line 520
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 520
    tmp___1 = 0;
    }
  }
#line 520
  return (tmp___1);
}
}
#line 530 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_isoc_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 533
  tmp = usb_endpoint_xfer_isoc(epd);
  }
#line 533
  if (tmp) {
    {
#line 533
    tmp___0 = usb_endpoint_dir_out(epd);
    }
#line 533
    if (tmp___0) {
      {
#line 533
      tmp___1 = 1;
      }
    } else {
      {
#line 533
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 533
    tmp___1 = 0;
    }
  }
#line 533
  return (tmp___1);
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqnr.h"
extern int nr_irqs ;
#line 27
extern struct irq_desc *irq_to_desc(unsigned int irq ) ;
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
extern int file_caps_enabled ;
#line 444 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_combine(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 448
  while (1) {
    while_126_continue: /* CIL Label */ ;
    {
#line 448
    __capi = 0U;
    }
    {
#line 448
    while (1) {
      while_127_continue: /* CIL Label */ ;
#line 448
      if (! (__capi < 2U)) {
        goto while_127_break;
      }
      {
#line 448
      dest.cap[__capi] = a.cap[__capi] | b.cap[__capi];
#line 448
      __capi ++;
      }
    }
    while_127_break: /* CIL Label */ ;
    }
    goto while_126_break;
  }
  while_126_break: /* CIL Label */ ;
  }
#line 449
  return (dest);
}
}
#line 452 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_intersect(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 456
  while (1) {
    while_128_continue: /* CIL Label */ ;
    {
#line 456
    __capi = 0U;
    }
    {
#line 456
    while (1) {
      while_129_continue: /* CIL Label */ ;
#line 456
      if (! (__capi < 2U)) {
        goto while_129_break;
      }
      {
#line 456
      dest.cap[__capi] = a.cap[__capi] & b.cap[__capi];
#line 456
      __capi ++;
      }
    }
    while_129_break: /* CIL Label */ ;
    }
    goto while_128_break;
  }
  while_128_break: /* CIL Label */ ;
  }
#line 457
  return (dest);
}
}
#line 460 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop(kernel_cap_t a , kernel_cap_t drop ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 464
  while (1) {
    while_130_continue: /* CIL Label */ ;
    {
#line 464
    __capi = 0U;
    }
    {
#line 464
    while (1) {
      while_131_continue: /* CIL Label */ ;
#line 464
      if (! (__capi < 2U)) {
        goto while_131_break;
      }
      {
#line 464
      dest.cap[__capi] = a.cap[__capi] & ~ drop.cap[__capi];
#line 464
      __capi ++;
      }
    }
    while_131_break: /* CIL Label */ ;
    }
    goto while_130_break;
  }
  while_130_break: /* CIL Label */ ;
  }
#line 465
  return (dest);
}
}
#line 468 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_invert(kernel_cap_t c ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 471
  while (1) {
    while_132_continue: /* CIL Label */ ;
    {
#line 471
    __capi = 0U;
    }
    {
#line 471
    while (1) {
      while_133_continue: /* CIL Label */ ;
#line 471
      if (! (__capi < 2U)) {
        goto while_133_break;
      }
      {
#line 471
      dest.cap[__capi] = ~ c.cap[__capi];
#line 471
      __capi ++;
      }
    }
    while_133_break: /* CIL Label */ ;
    }
    goto while_132_break;
  }
  while_132_break: /* CIL Label */ ;
  }
#line 472
  return (dest);
}
}
#line 475 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static int cap_isclear(kernel_cap_t a ) 
{ unsigned int __capi ;

  {
  {
#line 478
  __capi = 0U;
  }
  {
#line 478
  while (1) {
    while_134_continue: /* CIL Label */ ;
#line 478
    if (! (__capi < 2U)) {
      goto while_134_break;
    }
#line 479
    if (a.cap[__capi] != 0U) {
#line 480
      return (0);
    }
    {
#line 478
    __capi ++;
    }
  }
  while_134_break: /* CIL Label */ ;
  }
#line 482
  return (1);
}
}
#line 492 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static int cap_issubset(kernel_cap_t a , kernel_cap_t set ) 
{ kernel_cap_t dest ;
  int tmp ;

  {
  {
#line 495
  dest = cap_drop(a, set);
#line 496
  tmp = cap_isclear(dest);
  }
#line 496
  return (tmp);
}
}
#line 501 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static int cap_is_fs_cap(int cap ) 
{ kernel_cap_t __cap_fs_set ;

  {
  {
#line 503
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 503
  __cap_fs_set.cap[1] = (__u32 )1;
  }
#line 504
  return (! (! ((unsigned int )(1 << (cap & 31)) & __cap_fs_set.cap[cap >> 5])));
}
}
#line 507 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop_fs_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
#line 509
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 509
  __cap_fs_set.cap[1] = (__u32 )1;
#line 510
  tmp = cap_drop(a, __cap_fs_set);
  }
#line 510
  return (tmp);
}
}
#line 513 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_raise_fs_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
#line 516
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 516
  __cap_fs_set.cap[1] = (__u32 )1;
#line 517
  tmp = cap_intersect(permitted, __cap_fs_set);
#line 517
  tmp___0 = cap_combine(a, tmp);
  }
#line 517
  return (tmp___0);
}
}
#line 521 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop_nfsd_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
#line 523
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
#line 523
  __cap_fs_set.cap[1] = (__u32 )1;
#line 524
  tmp = cap_drop(a, __cap_fs_set);
  }
#line 524
  return (tmp);
}
}
#line 527 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_raise_nfsd_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_nfsd_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
#line 530
  __cap_nfsd_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
#line 530
  __cap_nfsd_set.cap[1] = (__u32 )1;
#line 531
  tmp = cap_intersect(permitted, __cap_nfsd_set);
#line 531
  tmp___0 = cap_combine(a, tmp);
  }
#line 531
  return (tmp___0);
}
}
#line 535
extern kernel_cap_t const   __cap_empty_set ;
#line 536
extern kernel_cap_t const   __cap_full_set ;
#line 537
extern kernel_cap_t const   __cap_init_eff_set ;
#line 565
extern int capable(int cap ) ;
#line 569
extern int get_vfs_caps_from_disk(struct dentry  const  *dentry , struct cpu_vfs_cap_data *cpu_caps ) ;
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
__inline static void rb_set_parent(struct rb_node *rb , struct rb_node *p ) 
{ 

  {
  {
#line 125
  rb->rb_parent_color = (rb->rb_parent_color & 3UL) | (unsigned long )p;
  }
#line 126
  return;
}
}
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
__inline static void rb_set_color(struct rb_node *rb , int color ) 
{ 

  {
  {
#line 129
  rb->rb_parent_color = (rb->rb_parent_color & 0xfffffffeUL) | (unsigned long )color;
  }
#line 130
  return;
}
}
#line 139
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
#line 140
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
#line 143
extern struct rb_node *rb_next(struct rb_node  const  * ) ;
#line 144
extern struct rb_node *rb_prev(struct rb_node  const  * ) ;
#line 145
extern struct rb_node *rb_first(struct rb_root  const  * ) ;
#line 146
extern struct rb_node *rb_last(struct rb_root  const  * ) ;
#line 149
extern void rb_replace_node(struct rb_node *victim , struct rb_node *new , struct rb_root *root ) ;
#line 152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link ) 
{ struct rb_node *tmp ;

  {
  {
#line 155
  node->rb_parent_color = (unsigned long )parent;
#line 156
  tmp = (struct rb_node *)((void *)0);
#line 156
  node->rb_right = tmp;
#line 156
  node->rb_left = tmp;
#line 158
  *rb_link = node;
  }
#line 159
  return;
}
}
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static void prio_tree_iter_init(struct prio_tree_iter *iter , struct prio_tree_root *root ,
                                         unsigned long r_index , unsigned long h_index ) 
{ 

  {
  {
#line 52
  iter->root = root;
#line 53
  iter->r_index = r_index;
#line 54
  iter->h_index = h_index;
#line 55
  iter->cur = (struct prio_tree_node *)((void *)0);
  }
#line 56
  return;
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_empty(struct prio_tree_root  const  *root ) 
{ 

  {
#line 86
  return ((unsigned long )root->prio_tree_node == (unsigned long )((void *)0));
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_root(struct prio_tree_node  const  *node ) 
{ 

  {
#line 91
  return ((unsigned long )node->parent == (unsigned long )node);
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_left_empty(struct prio_tree_node  const  *node ) 
{ 

  {
#line 96
  return ((unsigned long )node->left == (unsigned long )node);
}
}
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_right_empty(struct prio_tree_node  const  *node ) 
{ 

  {
#line 101
  return ((unsigned long )node->right == (unsigned long )node);
}
}
#line 105
extern struct prio_tree_node *prio_tree_replace(struct prio_tree_root *root , struct prio_tree_node *old ,
                                                struct prio_tree_node *node ) ;
#line 107
extern struct prio_tree_node *prio_tree_insert(struct prio_tree_root *root , struct prio_tree_node *node ) ;
#line 109
extern void prio_tree_remove(struct prio_tree_root *root , struct prio_tree_node *node ) ;
#line 110
extern struct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter ) ;
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
extern int copy_semundo(unsigned long clone_flags , struct task_struct *tsk ) ;
#line 143
extern void exit_sem(struct task_struct *tsk ) ;
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
extern void do_notify_resume(struct pt_regs * , void * , __u32  ) ;
#line 275 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
extern void do_schedule_next_timer(struct siginfo *info ) ;
#line 281 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
__inline static void copy_siginfo(struct siginfo *to , struct siginfo *from ) 
{ 

  {
#line 283
  if (from->si_code < 0) {
    {
#line 284
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )sizeof(*to));
    }
  } else {
    {
#line 287
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )(4UL * sizeof(int ) + sizeof(from->_sifields._sigchld)));
    }
  }
#line 288
  return;
}
}
#line 292
extern int copy_siginfo_to_user(struct siginfo *to , struct siginfo *from ) ;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigaddset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
#line 40
  sig = (unsigned long )(_sig - 1);
#line 42
  set->sig[0] |= 1UL << sig;
  }
#line 45
  return;
}
}
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigdelset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
#line 49
  sig = (unsigned long )(_sig - 1);
#line 51
  set->sig[0] &= ~ (1UL << sig);
  }
#line 54
  return;
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigismember(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
#line 58
  sig = (unsigned long )(_sig - 1);
  }
#line 60
  return ((int )(1UL & (set->sig[0] >> sig)));
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigfindinword(unsigned long word ) 
{ unsigned long tmp ;

  {
  {
#line 67
  tmp = ffz(~ word);
  }
#line 67
  return ((int )tmp);
}
}
#line 74
extern void _NSIG_WORDS_is_unsupported_size(void) ;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigisemptyset(sigset_t *set ) 
{ 

  {
#line 76
  if (1 == 4) {
    goto switch_135_4;
  } else {
#line 79
    if (1 == 2) {
      goto switch_135_2;
    } else {
#line 81
      if (1 == 1) {
        goto switch_135_1;
      } else {
        {
        goto switch_135_default;
#line 75
        if (0) {
          switch_135_4: /* CIL Label */ 
#line 77
          return ((((set->sig[3] | set->sig[2]) | set->sig[1]) | set->sig[0]) == 0UL);
          switch_135_2: /* CIL Label */ 
#line 80
          return ((set->sig[1] | set->sig[0]) == 0UL);
          switch_135_1: /* CIL Label */ 
#line 82
          return (set->sig[0] == 0UL);
          switch_135_default: /* CIL Label */ 
          {
#line 84
          _NSIG_WORDS_is_unsupported_size();
          }
#line 85
          return (0);
        } else {
          switch_135_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigorsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
#line 119
  if (1 == 4) {
    goto switch_136_4;
  } else {
#line 119
    if (1 == 2) {
      goto switch_136_2;
    } else {
#line 119
      if (1 == 1) {
        goto switch_136_1;
      } else {
        {
        goto switch_136_default;
#line 119
        if (0) {
          switch_136_4: /* CIL Label */ 
          {
#line 119
          a3 = a->sig[3];
#line 119
          a2 = a->sig[2];
#line 119
          b3 = b->sig[3];
#line 119
          b2 = b->sig[2];
#line 119
          r->sig[3] = a3 | b3;
#line 119
          r->sig[2] = a2 | b2;
          }
          switch_136_2: /* CIL Label */ 
          {
#line 119
          a1 = a->sig[1];
#line 119
          b1 = b->sig[1];
#line 119
          r->sig[1] = a1 | b1;
          }
          switch_136_1: /* CIL Label */ 
          {
#line 119
          a0 = a->sig[0];
#line 119
          b0 = b->sig[0];
#line 119
          r->sig[0] = a0 | b0;
          }
          goto switch_136_break;
          switch_136_default: /* CIL Label */ 
          {
#line 119
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_136_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 119
  return;
}
}
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
#line 122
  if (1 == 4) {
    goto switch_137_4;
  } else {
#line 122
    if (1 == 2) {
      goto switch_137_2;
    } else {
#line 122
      if (1 == 1) {
        goto switch_137_1;
      } else {
        {
        goto switch_137_default;
#line 122
        if (0) {
          switch_137_4: /* CIL Label */ 
          {
#line 122
          a3 = a->sig[3];
#line 122
          a2 = a->sig[2];
#line 122
          b3 = b->sig[3];
#line 122
          b2 = b->sig[2];
#line 122
          r->sig[3] = a3 & b3;
#line 122
          r->sig[2] = a2 & b2;
          }
          switch_137_2: /* CIL Label */ 
          {
#line 122
          a1 = a->sig[1];
#line 122
          b1 = b->sig[1];
#line 122
          r->sig[1] = a1 & b1;
          }
          switch_137_1: /* CIL Label */ 
          {
#line 122
          a0 = a->sig[0];
#line 122
          b0 = b->sig[0];
#line 122
          r->sig[0] = a0 & b0;
          }
          goto switch_137_break;
          switch_137_default: /* CIL Label */ 
          {
#line 122
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_137_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 122
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void signandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
#line 125
  if (1 == 4) {
    goto switch_138_4;
  } else {
#line 125
    if (1 == 2) {
      goto switch_138_2;
    } else {
#line 125
      if (1 == 1) {
        goto switch_138_1;
      } else {
        {
        goto switch_138_default;
#line 125
        if (0) {
          switch_138_4: /* CIL Label */ 
          {
#line 125
          a3 = a->sig[3];
#line 125
          a2 = a->sig[2];
#line 125
          b3 = b->sig[3];
#line 125
          b2 = b->sig[2];
#line 125
          r->sig[3] = a3 & ~ b3;
#line 125
          r->sig[2] = a2 & ~ b2;
          }
          switch_138_2: /* CIL Label */ 
          {
#line 125
          a1 = a->sig[1];
#line 125
          b1 = b->sig[1];
#line 125
          r->sig[1] = a1 & ~ b1;
          }
          switch_138_1: /* CIL Label */ 
          {
#line 125
          a0 = a->sig[0];
#line 125
          b0 = b->sig[0];
#line 125
          r->sig[0] = a0 & ~ b0;
          }
          goto switch_138_break;
          switch_138_default: /* CIL Label */ 
          {
#line 125
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_138_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 125
  return;
}
}
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void signotset(sigset_t *set ) 
{ 

  {
#line 149
  if (1 == 4) {
    goto switch_139_4;
  } else {
#line 149
    if (1 == 2) {
      goto switch_139_2;
    } else {
#line 149
      if (1 == 1) {
        goto switch_139_1;
      } else {
        {
        goto switch_139_default;
#line 149
        if (0) {
          switch_139_4: /* CIL Label */ 
          {
#line 149
          set->sig[3] = ~ set->sig[3];
#line 149
          set->sig[2] = ~ set->sig[2];
          }
          switch_139_2: /* CIL Label */ 
          {
#line 149
          set->sig[1] = ~ set->sig[1];
          }
          switch_139_1: /* CIL Label */ 
          {
#line 149
          set->sig[0] = ~ set->sig[0];
          }
          goto switch_139_break;
          switch_139_default: /* CIL Label */ 
          {
#line 149
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_139_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 149
  return;
}
}
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigemptyset(sigset_t *set ) 
{ 

  {
#line 160
  if (1 == 2) {
    goto switch_140_2;
  } else {
#line 161
    if (1 == 1) {
      goto switch_140_1;
    } else {
      {
      goto switch_140_default;
#line 156
      if (0) {
        switch_140_default: /* CIL Label */ 
        {
#line 158
        __constant_c_and_count_memset((void *)set, 0UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_140_break;
        switch_140_2: /* CIL Label */ 
        {
#line 160
        set->sig[1] = 0UL;
        }
        switch_140_1: /* CIL Label */ 
        {
#line 161
        set->sig[0] = 0UL;
        }
        goto switch_140_break;
      } else {
        switch_140_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 164
  return;
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigfillset(sigset_t *set ) 
{ 

  {
#line 172
  if (1 == 2) {
    goto switch_141_2;
  } else {
#line 173
    if (1 == 1) {
      goto switch_141_1;
    } else {
      {
      goto switch_141_default;
#line 168
      if (0) {
        switch_141_default: /* CIL Label */ 
        {
#line 170
        __constant_c_and_count_memset((void *)set, 4294967295UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_141_break;
        switch_141_2: /* CIL Label */ 
        {
#line 172
        set->sig[1] = 0xffffffffUL;
        }
        switch_141_1: /* CIL Label */ 
        {
#line 173
        set->sig[0] = 0xffffffffUL;
        }
        goto switch_141_break;
      } else {
        switch_141_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 176
  return;
}
}
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigaddsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 182
  set->sig[0] |= mask;
  }
#line 183
  return;
}
}
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigdelsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 187
  set->sig[0] &= ~ mask;
  }
#line 188
  return;
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigtestsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
#line 192
  return ((set->sig[0] & mask) != 0UL);
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void siginitset(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 197
  set->sig[0] = mask;
  }
#line 202
  if (1 == 2) {
    goto switch_142_2;
  } else {
#line 203
    if (1 == 1) {
      goto switch_142_1;
    } else {
      {
      goto switch_142_default;
#line 198
      if (0) {
        switch_142_default: /* CIL Label */ 
        {
#line 200
        __constant_c_and_count_memset((void *)(& set->sig[1]), 0UL, 0U);
        }
        goto switch_142_break;
        switch_142_2: /* CIL Label */ 
        {
#line 202
        set->sig[1] = 0UL;
        }
        switch_142_1: /* CIL Label */ 
        {

        }
      } else {
        switch_142_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 205
  return;
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void siginitsetinv(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 209
  set->sig[0] = ~ mask;
  }
#line 214
  if (1 == 2) {
    goto switch_143_2;
  } else {
#line 215
    if (1 == 1) {
      goto switch_143_1;
    } else {
      {
      goto switch_143_default;
#line 210
      if (0) {
        switch_143_default: /* CIL Label */ 
        {
#line 212
        __constant_c_and_count_memset((void *)(& set->sig[1]), 4294967295UL, 0U);
        }
        goto switch_143_break;
        switch_143_2: /* CIL Label */ 
        {
#line 214
        set->sig[1] = 0xffffffffUL;
        }
        switch_143_1: /* CIL Label */ 
        {

        }
      } else {
        switch_143_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 217
  return;
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void init_sigpending(struct sigpending *sig ) 
{ 

  {
  {
#line 223
  sigemptyset(& sig->signal);
#line 224
  INIT_LIST_HEAD(& sig->list);
  }
#line 225
  return;
}
}
#line 227
extern void flush_sigqueue(struct sigpending *queue ) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int valid_signal(unsigned long sig ) 
{ int tmp ;

  {
#line 232
  if (sig <= 64UL) {
    {
#line 232
    tmp = 1;
    }
  } else {
    {
#line 232
    tmp = 0;
    }
  }
#line 232
  return (tmp);
}
}
#line 235
extern int next_signal(struct sigpending *pending , sigset_t *mask ) ;
#line 236
extern int group_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ) ;
#line 237
extern int __group_send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 238
extern long do_sigpending(void * , unsigned long  ) ;
#line 239
extern int sigprocmask(int  , sigset_t * , sigset_t * ) ;
#line 240
extern int show_unhandled_signals ;
#line 243
extern int get_signal_to_deliver(siginfo_t *info , struct k_sigaction *return_ka ,
                                 struct pt_regs *regs , void *cookie ) ;
#line 244
extern void exit_signals(struct task_struct *tsk ) ;
#line 246
extern struct kmem_cache *sighand_cachep ;
#line 248
extern int unhandled_signal(struct task_struct *tsk , int sig ) ;
#line 373
extern void signals_init(void) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/path.h"
extern void path_get(struct path * ) ;
#line 13
extern void path_put(struct path * ) ;
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
extern struct pid init_struct_pid ;
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
__inline static struct pid *get_pid(struct pid *pid ) 
{ 

  {
#line 77
  if (pid) {
    {
#line 78
    atomic_inc(& pid->count);
    }
  }
#line 79
  return (pid);
}
}
#line 82
extern void put_pid(struct pid *pid ) ;
#line 83
extern struct task_struct *pid_task(struct pid *pid , enum pid_type  ) ;
#line 84
extern struct task_struct *get_pid_task(struct pid *pid , enum pid_type  ) ;
#line 86
extern struct pid *get_task_pid(struct task_struct *task , enum pid_type type ) ;
#line 92
extern void attach_pid(struct task_struct *task , enum pid_type type , struct pid *pid ) ;
#line 94
extern void detach_pid(struct task_struct *task , enum pid_type  ) ;
#line 95
extern void change_pid(struct task_struct *task , enum pid_type  , struct pid *pid ) ;
#line 97
extern void transfer_pid(struct task_struct *old , struct task_struct *new , enum pid_type  ) ;
#line 101
extern struct pid_namespace init_pid_ns ;
#line 112
extern struct pid *find_pid_ns(int nr , struct pid_namespace *ns ) ;
#line 113
extern struct pid *find_vpid(int nr ) ;
#line 118
extern struct pid *find_get_pid(int nr ) ;
#line 119
extern struct pid *find_ge_pid(int nr , struct pid_namespace * ) ;
#line 120
extern int next_pidmap(struct pid_namespace *pid_ns , int last ) ;
#line 122
extern struct pid *alloc_pid(struct pid_namespace *ns ) ;
#line 123
extern void free_pid(struct pid *pid ) ;
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
__inline static struct pid_namespace *ns_of_pid(struct pid *pid ) 
{ struct pid_namespace *ns ;

  {
  {
#line 137
  ns = (struct pid_namespace *)((void *)0);
  }
#line 138
  if (pid) {
    {
#line 139
    ns = pid->numbers[pid->level].ns;
    }
  }
#line 140
  return (ns);
}
}
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
__inline static pid_t pid_nr(struct pid *pid ) 
{ pid_t nr ;

  {
  {
#line 156
  nr = 0;
  }
#line 157
  if (pid) {
    {
#line 158
    nr = pid->numbers[0].nr;
    }
  }
#line 159
  return (nr);
}
}
#line 162
extern pid_t pid_nr_ns(struct pid *pid , struct pid_namespace *ns ) ;
#line 163
extern pid_t pid_vnr(struct pid *pid ) ;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
extern int percpu_counter_batch ;
#line 29
extern int __percpu_counter_init(struct percpu_counter *fbc , s64 amount , struct lock_class_key *key ) ;
#line 39
extern void percpu_counter_destroy(struct percpu_counter *fbc ) ;
#line 40
extern void percpu_counter_set(struct percpu_counter *fbc , s64 amount ) ;
#line 41
extern void __percpu_counter_add(struct percpu_counter *fbc , s64 amount , s32 batch ) ;
#line 42
extern s64 __percpu_counter_sum(struct percpu_counter *fbc ) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_add(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
#line 46
  __percpu_counter_add(fbc, amount, percpu_counter_batch);
  }
#line 47
  return;
}
}
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_sum_positive(struct percpu_counter *fbc ) 
{ s64 ret ;
  s64 tmp ;
  s64 tmp___0 ;

  {
  {
#line 51
  tmp = __percpu_counter_sum(fbc);
#line 51
  ret = tmp;
  }
#line 52
  if (ret < 0LL) {
    {
#line 52
    tmp___0 = 0LL;
    }
  } else {
    {
#line 52
    tmp___0 = ret;
    }
  }
#line 52
  return (tmp___0);
}
}
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_sum(struct percpu_counter *fbc ) 
{ s64 tmp ;

  {
  {
#line 57
  tmp = __percpu_counter_sum(fbc);
  }
#line 57
  return (tmp);
}
}
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_read(struct percpu_counter *fbc ) 
{ 

  {
#line 62
  return (fbc->count);
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_read_positive(struct percpu_counter *fbc ) 
{ s64 ret ;

  {
  {
#line 72
  ret = fbc->count;
#line 74
  __asm__  volatile   ("": : : "memory");
  }
#line 75
  if (ret >= 0LL) {
#line 76
    return (ret);
  }
#line 77
  return (1LL);
}
}
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_inc(struct percpu_counter *fbc ) 
{ 

  {
  {
#line 136
  percpu_counter_add(fbc, 1LL);
  }
#line 137
  return;
}
}
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_dec(struct percpu_counter *fbc ) 
{ 

  {
  {
#line 141
  percpu_counter_add(fbc, -1LL);
  }
#line 142
  return;
}
}
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_sub(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
#line 146
  percpu_counter_add(fbc, - amount);
  }
#line 147
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
extern int prop_descriptor_init(struct prop_descriptor *pd , int shift ) ;
#line 44
extern void prop_change_shift(struct prop_descriptor *pd , int new_shift ) ;
#line 64
extern int prop_local_init_percpu(struct prop_local_percpu *pl ) ;
#line 65
extern void prop_local_destroy_percpu(struct prop_local_percpu *pl ) ;
#line 66
extern void __prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) ;
#line 67
extern void prop_fraction_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                 long *numerator , long *denominator ) ;
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
__inline static void prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
#line 75
  while (1) {
    while_144_continue: /* CIL Label */ ;
    {
#line 75
    while (1) {
      while_145_continue: /* CIL Label */ ;
      {
#line 75
      flags = __raw_local_irq_save();
      }
      goto while_145_break;
    }
    while_145_break: /* CIL Label */ ;
    }
    {
#line 75
    while (1) {
      while_146_continue: /* CIL Label */ ;
      goto while_146_break;
    }
    while_146_break: /* CIL Label */ ;
    }
    goto while_144_break;
  }
  while_144_break: /* CIL Label */ ;
  }
  {
#line 76
  __prop_inc_percpu(pd, pl);
  }
  {
#line 77
  while (1) {
    while_147_continue: /* CIL Label */ ;
    {
#line 77
    tmp = raw_irqs_disabled_flags(flags);
    }
#line 77
    if (tmp) {
      {
#line 77
      raw_local_irq_restore(flags);
      }
      {
#line 77
      while (1) {
        while_148_continue: /* CIL Label */ ;
        goto while_148_break;
      }
      while_148_break: /* CIL Label */ ;
      }
    } else {
      {
#line 77
      while (1) {
        while_149_continue: /* CIL Label */ ;
        goto while_149_break;
      }
      while_149_break: /* CIL Label */ ;
      }
      {
#line 77
      raw_local_irq_restore(flags);
      }
    }
    goto while_147_break;
  }
  while_147_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 89
extern void __prop_inc_percpu_max(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                  long frac ) ;
#line 116
extern int prop_local_init_single(struct prop_local_single *pl ) ;
#line 117
extern void prop_local_destroy_single(struct prop_local_single *pl ) ;
#line 118
extern void __prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) ;
#line 119
extern void prop_fraction_single(struct prop_descriptor *pd , struct prop_local_single *pl ,
                                 long *numerator , long *denominator ) ;
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
__inline static void prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
#line 127
  while (1) {
    while_150_continue: /* CIL Label */ ;
    {
#line 127
    while (1) {
      while_151_continue: /* CIL Label */ ;
      {
#line 127
      flags = __raw_local_irq_save();
      }
      goto while_151_break;
    }
    while_151_break: /* CIL Label */ ;
    }
    {
#line 127
    while (1) {
      while_152_continue: /* CIL Label */ ;
      goto while_152_break;
    }
    while_152_break: /* CIL Label */ ;
    }
    goto while_150_break;
  }
  while_150_break: /* CIL Label */ ;
  }
  {
#line 128
  __prop_inc_single(pd, pl);
  }
  {
#line 129
  while (1) {
    while_153_continue: /* CIL Label */ ;
    {
#line 129
    tmp = raw_irqs_disabled_flags(flags);
    }
#line 129
    if (tmp) {
      {
#line 129
      raw_local_irq_restore(flags);
      }
      {
#line 129
      while (1) {
        while_154_continue: /* CIL Label */ ;
        goto while_154_break;
      }
      while_154_break: /* CIL Label */ ;
      }
    } else {
      {
#line 129
      while (1) {
        while_155_continue: /* CIL Label */ ;
        goto while_155_break;
      }
      while_155_break: /* CIL Label */ ;
      }
      {
#line 129
      raw_local_irq_restore(flags);
      }
    }
    goto while_153_break;
  }
  while_153_break: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
extern void __secure_computing(int  ) ;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
__inline static void secure_computing(int this_syscall ) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 15
  tmp = current_thread_info();
#line 15
  tmp___0 = test_ti_thread_flag(tmp, 8);
  }
#line 15
  if (tmp___0) {
    {
#line 15
    tmp___1 = 1;
    }
  } else {
    {
#line 15
    tmp___1 = 0;
    }
  }
  {
#line 15
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 15
  if (tmp___2) {
    {
#line 16
    __secure_computing(this_syscall);
    }
  }
#line 17
  return;
}
}
#line 19
extern long prctl_get_seccomp(void) ;
#line 20
extern long prctl_set_seccomp(unsigned long  ) ;
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static void plist_head_init(struct plist_head *head , spinlock_t *lock ) 
{ 

  {
  {
#line 133
  INIT_LIST_HEAD(& head->prio_list);
#line 134
  INIT_LIST_HEAD(& head->node_list);
  }
#line 138
  return;
}
}
#line 145 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static void plist_node_init(struct plist_node *node , int prio ) 
{ 

  {
  {
#line 147
  node->prio = prio;
#line 148
  plist_head_init(& node->plist, (spinlock_t *)((void *)0));
  }
#line 149
  return;
}
}
#line 151
extern void plist_add(struct plist_node *node , struct plist_head *head ) ;
#line 152
extern void plist_del(struct plist_node *node , struct plist_head *head ) ;
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static int plist_head_empty(struct plist_head  const  *head ) 
{ int tmp ;

  {
  {
#line 200
  tmp = list_empty(& head->node_list);
  }
#line 200
  return (tmp);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static int plist_node_empty(struct plist_node  const  *node ) 
{ int tmp ;

  {
  {
#line 209
  tmp = plist_head_empty(& node->plist);
  }
#line 209
  return (tmp);
}
}
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static struct plist_node *plist_first(struct plist_head  const  *head ) 
{ struct list_head  const  *__mptr ;

  {
  {
#line 239
  __mptr = (struct list_head  const  *)head->node_list.next;
  }
#line 239
  return ((struct plist_node *)((char *)__mptr - (unsigned int )(& ((struct plist_node *)0)->plist.node_list)));
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rtmutex.h"
__inline static int rt_mutex_debug_check_no_locks_freed(void const   *from , unsigned long len ) 
{ 

  {
#line 49
  return (0);
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rtmutex.h"
__inline static int rt_mutex_is_locked(struct rt_mutex *lock ) 
{ 

  {
#line 82
  return ((unsigned long )lock->owner != (unsigned long )((void *)0));
}
}
#line 85
extern void __rt_mutex_init(struct rt_mutex *lock , char const   *name ) ;
#line 86
extern void rt_mutex_destroy(struct rt_mutex *lock ) ;
#line 88
extern void rt_mutex_lock(struct rt_mutex *lock ) ;
#line 89
extern int rt_mutex_lock_interruptible(struct rt_mutex *lock , int detect_deadlock ) ;
#line 91
extern int rt_mutex_timed_lock(struct rt_mutex *lock , struct hrtimer_sleeper *timeout ,
                               int detect_deadlock ) ;
#line 95
extern int rt_mutex_trylock(struct rt_mutex *lock ) ;
#line 97
extern void rt_mutex_unlock(struct rt_mutex *lock ) ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
extern int getrusage(struct task_struct *p , int who , struct rusage *ru ) ;
#line 178 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
#line 180
  timer->_expires = time;
#line 181
  timer->_softexpires = time;
  }
#line 182
  return;
}
}
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_range(struct hrtimer *timer , ktime_t time ,
                                               ktime_t delta ) 
{ 

  {
  {
#line 186
  timer->_softexpires = time;
#line 187
  timer->_expires = ktime_add_safe(time, delta);
  }
#line 188
  return;
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_range_ns(struct hrtimer *timer , ktime_t time ,
                                                  unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
#line 192
  timer->_softexpires = time;
#line 193
  tmp = ns_to_ktime((unsigned long long )delta);
#line 193
  timer->_expires = ktime_add_safe(time, tmp);
  }
#line 194
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_tv64(struct hrtimer *timer , s64 tv64 ) 
{ 

  {
  {
#line 198
  timer->_expires.tv64 = tv64;
#line 199
  timer->_softexpires.tv64 = tv64;
  }
#line 200
  return;
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_add_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
#line 204
  timer->_expires = ktime_add_safe(timer->_expires, time);
#line 205
  timer->_softexpires = ktime_add_safe(timer->_softexpires, time);
  }
#line 206
  return;
}
}
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_add_expires_ns(struct hrtimer *timer , u64 ns ) 
{ ktime_t __constr_expr_0 ;
  ktime_t __constr_expr_1 ;

  {
  {
#line 210
  __constr_expr_0.tv64 = (s64 )((u64 )timer->_expires.tv64 + ns);
#line 210
  timer->_expires = __constr_expr_0;
#line 211
  __constr_expr_1.tv64 = (s64 )((u64 )timer->_softexpires.tv64 + ns);
#line 211
  timer->_softexpires = __constr_expr_1;
  }
#line 212
  return;
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_get_expires(struct hrtimer  const  *timer ) 
{ 

  {
#line 216
  return ((union ktime )timer->_expires);
}
}
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_get_softexpires(struct hrtimer  const  *timer ) 
{ 

  {
#line 221
  return ((union ktime )timer->_softexpires);
}
}
#line 224 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_expires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
#line 226
  return ((long long )timer->_expires.tv64);
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_softexpires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
#line 230
  return ((long long )timer->_softexpires.tv64);
}
}
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_expires_ns(struct hrtimer  const  *timer ) 
{ 

  {
#line 235
  return ((long long )timer->_expires.tv64);
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_expires_remaining(struct hrtimer  const  *timer ) 
{ ktime_t __constr_expr_0 ;
  ktime_t tmp ;

  {
  {
#line 240
  tmp = (*((timer->base)->get_time))();
#line 240
  __constr_expr_0.tv64 = (s64 )(timer->_expires.tv64 - (s64 const   )tmp.tv64);
  }
#line 240
  return (__constr_expr_0);
}
}
#line 246
extern void clock_was_set(void) ;
#line 247
extern void hres_timers_resume(void) ;
#line 248
extern void hrtimer_interrupt(struct clock_event_device *dev ) ;
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_cb_get_time(struct hrtimer *timer ) 
{ ktime_t tmp ;

  {
  {
#line 255
  tmp = (*((timer->base)->get_time))();
  }
#line 255
  return (tmp);
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_is_hres_active(struct hrtimer *timer ) 
{ 

  {
#line 260
  return (((timer->base)->cpu_base)->hres_active);
}
}
#line 263
extern void hrtimer_peek_ahead_timers(void) ;
#line 306
extern ktime_t ktime_get(void) ;
#line 307
extern ktime_t ktime_get_real(void) ;
#line 310
extern struct tick_device per_cpu__tick_cpu_device  __attribute__((__section__(".data.percpu"))) ;
#line 316
extern void hrtimer_init(struct hrtimer *timer , clockid_t which_clock , enum hrtimer_mode mode ) ;
#line 325 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_init_on_stack(struct hrtimer *timer , clockid_t which_clock ,
                                           enum hrtimer_mode mode ) 
{ 

  {
  {
#line 329
  hrtimer_init(timer, which_clock, mode);
  }
#line 330
  return;
}
}
#line 331 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void destroy_hrtimer_on_stack(struct hrtimer *timer ) 
{ 

  {
#line 331
  return;
}
}
#line 335
extern int hrtimer_start(struct hrtimer *timer , ktime_t tim , enum hrtimer_mode mode ) ;
#line 337
extern int hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long range_ns ,
                                  enum hrtimer_mode mode ) ;
#line 339
extern int __hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long delta_ns ,
                                    enum hrtimer_mode mode , int wakeup ) ;
#line 344
extern int hrtimer_cancel(struct hrtimer *timer ) ;
#line 345
extern int hrtimer_try_to_cancel(struct hrtimer *timer ) ;
#line 347 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_start_expires(struct hrtimer *timer , enum hrtimer_mode mode ) 
{ unsigned long delta ;
  ktime_t soft ;
  ktime_t hard ;
  ktime_t __constr_expr_0 ;
  int tmp ;

  {
  {
#line 352
  soft = hrtimer_get_softexpires((struct hrtimer  const  *)timer);
#line 353
  hard = hrtimer_get_expires((struct hrtimer  const  *)timer);
#line 354
  __constr_expr_0.tv64 = hard.tv64 - soft.tv64;
#line 354
  delta = (unsigned long )__constr_expr_0.tv64;
#line 355
  tmp = hrtimer_start_range_ns(timer, soft, delta, mode);
  }
#line 355
  return (tmp);
}
}
#line 358 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_restart(struct hrtimer *timer ) 
{ int tmp ;

  {
  {
#line 360
  tmp = hrtimer_start_expires(timer, (enum hrtimer_mode )0);
  }
#line 360
  return (tmp);
}
}
#line 364
extern ktime_t hrtimer_get_remaining(struct hrtimer  const  *timer ) ;
#line 365
extern int hrtimer_get_res(clockid_t which_clock , struct timespec *tp ) ;
#line 367
extern ktime_t hrtimer_get_next_event(void) ;
#line 373 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_active(struct hrtimer  const  *timer ) 
{ 

  {
#line 375
  return (timer->state != 0UL);
}
}
#line 381 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_is_queued(struct hrtimer *timer ) 
{ 

  {
#line 383
  return ((int )(timer->state & 1UL));
}
}
#line 390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_callback_running(struct hrtimer *timer ) 
{ 

  {
#line 392
  return ((int )(timer->state & 2UL));
}
}
#line 396
extern u64 hrtimer_forward(struct hrtimer *timer , ktime_t now , ktime_t interval ) ;
#line 400 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static u64 hrtimer_forward_now(struct hrtimer *timer , ktime_t interval ) 
{ ktime_t tmp ;
  u64 tmp___0 ;

  {
  {
#line 403
  tmp = (*((timer->base)->get_time))();
#line 403
  tmp___0 = hrtimer_forward(timer, tmp, interval);
  }
#line 403
  return (tmp___0);
}
}
#line 407
extern long hrtimer_nanosleep(struct timespec *rqtp , struct timespec *rmtp , enum hrtimer_mode mode ,
                              clockid_t clockid ) ;
#line 411
extern long hrtimer_nanosleep_restart(struct restart_block *restart_block ) ;
#line 413
extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl , struct task_struct *tsk ) ;
#line 416
extern int schedule_hrtimeout_range(ktime_t *expires , unsigned long delta , enum hrtimer_mode mode ) ;
#line 418
extern int schedule_hrtimeout(ktime_t *expires , enum hrtimer_mode mode ) ;
#line 421
extern void hrtimer_run_queues(void) ;
#line 422
extern void hrtimer_run_pending(void) ;
#line 425
extern void hrtimers_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 428
extern u64 ktime_divns(ktime_t kt , s64 div ) ;
#line 434
extern void sysrq_timer_list_show(void) ;
#line 445 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void timer_stats_account_hrtimer(struct hrtimer *timer ) 
{ 

  {
  {
#line 447
  timer_stats_update_stats((void *)timer, timer->start_pid, timer->start_site, (void *)timer->function,
                           timer->start_comm, 0U);
  }
#line 449
  return;
}
}
#line 451
extern void __timer_stats_hrtimer_set_start_info(struct hrtimer *timer , void *addr ) ;
#line 454 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void timer_stats_hrtimer_set_start_info(struct hrtimer *timer ) 
{ void *tmp ;

  {
  {
#line 456
  tmp = __builtin_return_address(0U);
#line 456
  __timer_stats_hrtimer_set_start_info(timer, tmp);
  }
#line 457
  return;
}
}
#line 459 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void timer_stats_hrtimer_clear_start_info(struct hrtimer *timer ) 
{ 

  {
  {
#line 461
  timer->start_site = (void *)0;
  }
#line 462
  return;
}
}
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/latencytop.h"
__inline static void account_scheduler_latency(struct task_struct *task , int usecs ,
                                               int inter ) 
{ 

  {
#line 44
  return;
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/latencytop.h"
__inline static void clear_all_latency_tracing(struct task_struct *p ) 
{ 

  {
#line 48
  return;
}
}
#line 957 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
extern void setup_sysctl_set(struct ctl_table_set *p , struct ctl_table_set *parent ,
                             int (*is_seen)(struct ctl_table_set * ) ) ;
#line 963
extern void sysctl_head_get(struct ctl_table_header * ) ;
#line 964
extern void sysctl_head_put(struct ctl_table_header * ) ;
#line 965
extern int sysctl_is_seen(struct ctl_table_header * ) ;
#line 966
extern struct ctl_table_header *sysctl_head_grab(struct ctl_table_header * ) ;
#line 967
extern struct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev ) ;
#line 968
extern struct ctl_table_header *__sysctl_head_next(struct nsproxy *namespaces , struct ctl_table_header *prev ) ;
#line 970
extern void sysctl_head_finish(struct ctl_table_header *prev ) ;
#line 971
extern int sysctl_perm(struct ctl_table_root *root , struct ctl_table *table , int op ) ;
#line 983
extern int proc_dostring(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
#line 985
extern int proc_dointvec(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
#line 987
extern int proc_dointvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                size_t * , loff_t * ) ;
#line 989
extern int proc_dointvec_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                 size_t * , loff_t * ) ;
#line 991
extern int proc_dointvec_userhz_jiffies(struct ctl_table * , int  , struct file * ,
                                        void * , size_t * , loff_t * ) ;
#line 993
extern int proc_dointvec_ms_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                    size_t * , loff_t * ) ;
#line 995
extern int proc_doulongvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                  size_t * , loff_t * ) ;
#line 997
extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table , int  , struct file * ,
                                             void * , size_t * , loff_t * ) ;
#line 1000
extern int do_sysctl(int *name , int nlen , void *oldval , size_t *oldlenp , void *newval ,
                     size_t newlen ) ;
#line 1004
extern ctl_handler sysctl_data ;
#line 1005
extern ctl_handler sysctl_string ;
#line 1006
extern ctl_handler sysctl_intvec ;
#line 1007
extern ctl_handler sysctl_jiffies ;
#line 1008
extern ctl_handler sysctl_ms_jiffies ;
#line 1099
extern void register_sysctl_root(struct ctl_table_root *root ) ;
#line 1100
extern struct ctl_table_header *__register_sysctl_paths(struct ctl_table_root *root ,
                                                        struct nsproxy *namespaces ,
                                                        struct ctl_path  const  *path ,
                                                        struct ctl_table *table ) ;
#line 1103
extern struct ctl_table_header *register_sysctl_table(struct ctl_table *table ) ;
#line 1104
extern struct ctl_table_header *register_sysctl_paths(struct ctl_path  const  *path ,
                                                      struct ctl_table *table ) ;
#line 1107
extern void unregister_sysctl_table(struct ctl_table_header *table ) ;
#line 1108
extern int sysctl_check_table(struct nsproxy *namespaces , struct ctl_table *table ) ;
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static key_ref_t make_key_ref(struct key  const  *key , unsigned long possession ) 
{ 

  {
#line 103
  return ((struct __key_reference_with_attributes *)((unsigned long )key | possession));
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static struct key *key_ref_to_ptr(key_ref_t key_ref ) 
{ 

  {
#line 108
  return ((struct key *)((unsigned long )key_ref & 0xfffffffeUL));
}
}
#line 111 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static unsigned long is_key_possessed(key_ref_t key_ref ) 
{ 

  {
#line 113
  return ((unsigned long )key_ref & 1UL);
}
}
#line 183
extern struct key *key_alloc(struct key_type *type , char const   *desc , uid_t uid ,
                             gid_t gid , struct cred  const  *cred , key_perm_t perm ,
                             unsigned long flags ) ;
#line 195
extern void key_revoke(struct key *key ) ;
#line 196
extern void key_put(struct key *key ) ;
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static struct key *key_get(struct key *key ) 
{ 

  {
#line 200
  if (key) {
    {
#line 201
    atomic_inc(& key->usage);
    }
  }
#line 202
  return (key);
}
}
#line 205 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static void key_ref_put(key_ref_t key_ref ) 
{ struct key *tmp ;

  {
  {
#line 207
  tmp = key_ref_to_ptr(key_ref);
#line 207
  key_put(tmp);
  }
#line 208
  return;
}
}
#line 210
extern struct key *request_key(struct key_type *type , char const   *description ,
                               char const   *callout_info ) ;
#line 214
extern struct key *request_key_with_auxdata(struct key_type *type , char const   *description ,
                                            void const   *callout_info , size_t callout_len ,
                                            void *aux ) ;
#line 220
extern struct key *request_key_async(struct key_type *type , char const   *description ,
                                     void const   *callout_info , size_t callout_len ) ;
#line 225
extern struct key *request_key_async_with_auxdata(struct key_type *type , char const   *description ,
                                                  void const   *callout_info , size_t callout_len ,
                                                  void *aux ) ;
#line 231
extern int wait_for_key_construction(struct key *key , bool intr ) ;
#line 233
extern int key_validate(struct key *key ) ;
#line 235
extern key_ref_t key_create_or_update(key_ref_t keyring , char const   *type , char const   *description ,
                                      void const   *payload , size_t plen , key_perm_t perm ,
                                      unsigned long flags ) ;
#line 243
extern int key_update(key_ref_t key , void const   *payload , size_t plen ) ;
#line 247
extern int key_link(struct key *keyring , struct key *key ) ;
#line 250
extern int key_unlink(struct key *keyring , struct key *key ) ;
#line 253
extern struct key *keyring_alloc(char const   *description , uid_t uid , gid_t gid ,
                                 struct cred  const  *cred , unsigned long flags ,
                                 struct key *dest ) ;
#line 258
extern int keyring_clear(struct key *keyring ) ;
#line 260
extern key_ref_t keyring_search(key_ref_t keyring , struct key_type *type , char const   *description ) ;
#line 264
extern int keyring_add_key(struct key *keyring , struct key *key ) ;
#line 267
extern struct key *key_lookup(key_serial_t id ) ;
#line 269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static key_serial_t key_serial(struct key *key ) 
{ key_serial_t tmp ;

  {
#line 271
  if (key) {
    {
#line 271
    tmp = key->serial;
    }
  } else {
    {
#line 271
    tmp = 0;
    }
  }
#line 271
  return (tmp);
}
}
#line 275
extern ctl_table key_sysctls[] ;
#line 281
extern int install_thread_keyring_to_cred(struct cred *cred ) ;
#line 282
extern void key_fsuid_changed(struct task_struct *tsk ) ;
#line 283
extern void key_fsgid_changed(struct task_struct *tsk ) ;
#line 284
extern void key_init(void) ;
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static struct group_info *get_group_info(struct group_info *gi ) 
{ 

  {
  {
#line 49
  atomic_inc(& gi->usage);
  }
#line 50
  return (gi);
}
}
#line 63
extern struct group_info *groups_alloc(int  ) ;
#line 64
extern struct group_info init_groups ;
#line 65
extern void groups_free(struct group_info * ) ;
#line 66
extern int set_current_groups(struct group_info * ) ;
#line 67
extern int set_groups(struct cred * , struct group_info * ) ;
#line 68
extern int groups_search(struct group_info  const  * , gid_t  ) ;
#line 74
extern int in_group_p(gid_t  ) ;
#line 75
extern int in_egroup_p(gid_t  ) ;
#line 145
extern void __put_cred(struct cred * ) ;
#line 146
extern int copy_creds(struct task_struct * , unsigned long  ) ;
#line 147
extern struct cred *prepare_creds(void) ;
#line 148
extern struct cred *prepare_exec_creds(void) ;
#line 149
extern struct cred *prepare_usermodehelper_creds(void) ;
#line 150
extern int commit_creds(struct cred * ) ;
#line 151
extern void abort_creds(struct cred * ) ;
#line 152
extern struct cred  const  *override_creds(struct cred  const  * ) ;
#line 153
extern void revert_creds(struct cred  const  * ) ;
#line 154
extern struct cred *prepare_kernel_cred(struct task_struct * ) ;
#line 155
extern int change_create_files_as(struct cred * , struct inode * ) ;
#line 156
extern int set_security_override(struct cred * , u32  ) ;
#line 157
extern int set_security_override_from_ctx(struct cred * , char const   * ) ;
#line 158
extern int set_create_files_as(struct cred * , struct inode * ) ;
#line 159
extern void cred_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static struct cred *get_new_cred(struct cred *cred ) 
{ 

  {
  {
#line 170
  atomic_inc(& cred->usage);
  }
#line 171
  return (cred);
}
}
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static struct cred  const  *get_cred(struct cred  const  *cred ) 
{ struct cred *tmp ;

  {
  {
#line 189
  tmp = get_new_cred((struct cred *)cred);
  }
#line 189
  return ((struct cred  const  *)tmp);
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static void put_cred(struct cred  const  *_cred ) 
{ struct cred *cred ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 205
  cred = (struct cred *)_cred;
  }
  {
#line 207
  while (1) {
    while_156_continue: /* CIL Label */ ;
    {
#line 207
    tmp = __builtin_expect((long )(! (! (cred->usage.counter <= (int volatile   )0))),
                           0L);
    }
#line 207
    if (tmp) {
      {
#line 207
      while (1) {
        while_157_continue: /* CIL Label */ ;
        {
#line 207
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"),
                             "i" (207), "i" (sizeof(struct bug_entry )));
        }
        {
#line 207
        while (1) {
          while_158_continue: /* CIL Label */ ;
        }
        while_158_break: /* CIL Label */ ;
        }
        goto while_157_break;
      }
      while_157_break: /* CIL Label */ ;
      }
    }
    goto while_156_break;
  }
  while_156_break: /* CIL Label */ ;
  }
  {
#line 208
  tmp___0 = atomic_dec_and_test(& cred->usage);
  }
#line 208
  if (tmp___0) {
    {
#line 209
    __put_cred(cred);
    }
  }
#line 210
  return;
}
}
#line 118 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
extern unsigned long avenrun[] ;
#line 132
extern unsigned long total_forks ;
#line 133
extern int nr_threads ;
#line 134
extern unsigned long per_cpu__process_counts  __attribute__((__section__(".data.percpu"))) ;
#line 135
extern int nr_processes(void) ;
#line 136
extern unsigned long nr_running(void) ;
#line 137
extern unsigned long nr_uninterruptible(void) ;
#line 138
extern unsigned long nr_active(void) ;
#line 139
extern unsigned long nr_iowait(void) ;
#line 141
extern unsigned long get_parent_ip(unsigned long addr ) ;
#line 152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void proc_sched_show_task(struct task_struct *p , struct seq_file *m ) 
{ 

  {
#line 155
  return;
}
}
#line 156 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void proc_sched_set_task(struct task_struct *p ) 
{ 

  {
#line 158
  return;
}
}
#line 159 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void print_cfs_rq(struct seq_file *m , int cpu , struct cfs_rq *cfs_rq ) 
{ 

  {
#line 162
  return;
}
}
#line 165
extern unsigned long long time_sync_thresh ;
#line 243
extern rwlock_t tasklist_lock ;
#line 244
extern spinlock_t mmlist_lock ;
#line 248
extern void sched_init(void) ;
#line 249
extern void sched_init_smp(void) ;
#line 250
extern void ( __attribute__((__regparm__(0))) schedule_tail)(struct task_struct *prev ) ;
#line 251
extern void init_idle(struct task_struct *idle , int cpu ) ;
#line 252
extern void init_idle_bootup_task(struct task_struct *idle ) ;
#line 254
extern int runqueue_is_locked(void) ;
#line 255
extern void task_rq_unlock_wait(struct task_struct *p ) ;
#line 257
extern cpumask_var_t nohz_cpu_mask ;
#line 259
extern int select_nohz_load_balancer(int cpu ) ;
#line 270
extern void show_state_filter(unsigned long state_filter ) ;
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void show_state(void) 
{ 

  {
  {
#line 274
  show_state_filter(0UL);
  }
#line 275
  return;
}
}
#line 277
extern void show_regs(struct pt_regs * ) ;
#line 284
extern void show_stack(struct task_struct *task , unsigned long *sp ) ;
#line 286
extern void io_schedule(void) ;
#line 287
extern long io_schedule_timeout(long timeout ) ;
#line 290
extern void trap_init(void) ;
#line 291
extern void update_process_times(int user ) ;
#line 292
extern void scheduler_tick(void) ;
#line 294
extern void sched_show_task(struct task_struct *p ) ;
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void softlockup_tick(void) 
{ 

  {
#line 308
  return;
}
}
#line 309 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void touch_softlockup_watchdog(void) 
{ 

  {
#line 311
  return;
}
}
#line 312 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void touch_all_softlockup_watchdogs(void) 
{ 

  {
#line 314
  return;
}
}
#line 331
extern char __sched_text_start[] ;
#line 331
extern char __sched_text_end[] ;
#line 334
extern int in_sched_functions(unsigned long addr ) ;
#line 337
extern long schedule_timeout(long timeout ) ;
#line 338
extern long schedule_timeout_interruptible(long timeout ) ;
#line 339
extern long schedule_timeout_killable(long timeout ) ;
#line 340
extern long schedule_timeout_uninterruptible(long timeout ) ;
#line 341
extern void ( __attribute__((__regparm__(0))) __schedule)(void) ;
#line 342
extern void ( __attribute__((__regparm__(0))) schedule)(void) ;
#line 343
extern int mutex_spin_on_owner(struct mutex *lock , struct thread_info *owner ) ;
#line 351
extern int sysctl_max_map_count ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/uio.h"
__inline static size_t iov_length(struct iovec  const  *iov , unsigned long nr_segs ) 
{ unsigned long seg ;
  size_t ret ;

  {
  {
#line 48
  ret = (size_t )0;
#line 50
  seg = 0UL;
  }
  {
#line 50
  while (1) {
    while_159_continue: /* CIL Label */ ;
#line 50
    if (! (seg < nr_segs)) {
      goto while_159_break;
    }
    {
#line 51
    ret += (size_t )(iov + seg)->iov_len;
#line 50
    seg ++;
    }
  }
  while_159_break: /* CIL Label */ ;
  }
#line 52
  return (ret);
}
}
#line 55
extern unsigned long iov_shorten(struct iovec *iov , unsigned long nr_segs , size_t to ) ;
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
extern unsigned int aio_max_size ;
#line 211
extern ssize_t wait_on_sync_kiocb(struct kiocb *iocb ) ;
#line 212
extern int aio_put_req(struct kiocb *iocb ) ;
#line 213
extern void kick_iocb(struct kiocb *iocb ) ;
#line 214
extern int aio_complete(struct kiocb *iocb , long res , long res2 ) ;
#line 216
extern void exit_aio(struct mm_struct *mm ) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
__inline static struct kiocb *list_kiocb(struct list_head *h ) 
{ struct list_head  const  *__mptr ;

  {
  {
#line 232
  __mptr = (struct list_head  const  *)h;
  }
#line 232
  return ((struct kiocb *)((char *)__mptr - (unsigned int )(& ((struct kiocb *)0)->ki_list)));
}
}
#line 236
extern unsigned long aio_nr ;
#line 237
extern unsigned long aio_max_nr ;
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
extern unsigned long arch_get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                            unsigned long  , unsigned long  ) ;
#line 358
extern unsigned long arch_get_unmapped_area_topdown(struct file *filp , unsigned long addr ,
                                                    unsigned long len , unsigned long pgoff ,
                                                    unsigned long flags ) ;
#line 362
extern void arch_unmap_area(struct mm_struct * , unsigned long  ) ;
#line 363
extern void arch_unmap_area_topdown(struct mm_struct * , unsigned long  ) ;
#line 401 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long get_mm_hiwater_rss(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  long tmp ;
  long tmp___0 ;
  unsigned long _max2 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 403
  _max1 = mm->hiwater_rss;
#line 403
  tmp___1 = atomic_long_read(& mm->_file_rss);
#line 403
  tmp___2 = atomic_long_read(& mm->_anon_rss);
#line 403
  _max2 = (unsigned long )tmp___1 + (unsigned long )tmp___2;
  }
#line 403
  if (_max1 > _max2) {
    {
#line 403
    tmp___3 = _max1;
    }
  } else {
    {
#line 403
    tmp___3 = _max2;
    }
  }
#line 403
  return (tmp___3);
}
}
#line 406 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long get_mm_hiwater_vm(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp ;

  {
  {
#line 408
  _max1 = mm->hiwater_vm;
#line 408
  _max2 = mm->total_vm;
  }
#line 408
  if (_max1 > _max2) {
    {
#line 408
    tmp = _max1;
    }
  } else {
    {
#line 408
    tmp = _max2;
    }
  }
#line 408
  return (tmp);
}
}
#line 411
extern void set_dumpable(struct mm_struct *mm , int value ) ;
#line 412
extern int get_dumpable(struct mm_struct *mm ) ;
#line 631 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int signal_group_exit(struct signal_struct  const  *sig ) 
{ int tmp ;

  {
#line 633
  if (sig->flags & 8U) {
    {
#line 633
    tmp = 1;
    }
  } else {
#line 633
    if ((unsigned long )sig->group_exit_task != (unsigned long )((void *)0)) {
      {
#line 633
      tmp = 1;
      }
    } else {
      {
#line 633
      tmp = 0;
      }
    }
  }
#line 633
  return (tmp);
}
}
#line 677
extern int uids_sysfs_init(void) ;
#line 679
extern struct user_struct *find_user(uid_t  ) ;
#line 681
extern struct user_struct root_user ;
#line 738 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sched_info_on(void) 
{ 

  {
#line 741
  return (1);
}
}
#line 794
extern int sched_mc_power_savings ;
#line 794
extern int sched_smt_power_savings ;
#line 796 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sd_balance_for_mc_power(void) 
{ 

  {
#line 798
  if (sched_smt_power_savings) {
#line 799
    return (256);
  }
#line 801
  return (0);
}
}
#line 804 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sd_balance_for_package_power(void) 
{ 

  {
#line 806
  if (sched_mc_power_savings | sched_smt_power_savings) {
#line 807
    return (256);
  }
#line 809
  return (0);
}
}
#line 818 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sd_power_saving_flags(void) 
{ 

  {
#line 820
  if (sched_mc_power_savings | sched_smt_power_savings) {
#line 821
    return (2);
  }
#line 823
  return (0);
}
}
#line 844 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct cpumask *sched_group_cpus(struct sched_group *sg ) 
{ int tmp ;

  {
#line 846
  return ((struct cpumask *)(sg->cpumask));
}
}
#line 931 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct cpumask *sched_domain_span(struct sched_domain *sd ) 
{ int tmp ;

  {
#line 933
  return ((struct cpumask *)(sd->span));
}
}
#line 936
extern void partition_sched_domains(int ndoms_new , struct cpumask *doms_new , struct sched_domain_attr *dattr_new ) ;
#line 940 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_sd_parent(struct sched_domain *sd , int flag ) 
{ 

  {
#line 942
  if (sd->parent) {
#line 942
    if ((sd->parent)->flags & flag) {
#line 943
      return (1);
    }
  }
#line 945
  return (0);
}
}
#line 965 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void prefetch_stack(struct task_struct *t ) 
{ 

  {
#line 965
  return;
}
}
#line 1456 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int rt_prio(int prio ) 
{ long tmp ;

  {
  {
#line 1458
  tmp = __builtin_expect((long )(! (! (prio < 100))), 0L);
  }
#line 1458
  if (tmp) {
#line 1459
    return (1);
  }
#line 1460
  return (0);
}
}
#line 1463 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int rt_task(struct task_struct *p ) 
{ int tmp ;

  {
  {
#line 1465
  tmp = rt_prio(p->prio);
  }
#line 1465
  return (tmp);
}
}
#line 1468 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_pid(struct task_struct *task ) 
{ 

  {
#line 1470
  return (task->pids[0].pid);
}
}
#line 1473 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_tgid(struct task_struct *task ) 
{ 

  {
#line 1475
  return ((task->group_leader)->pids[0].pid);
}
}
#line 1483 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_pgrp(struct task_struct *task ) 
{ 

  {
#line 1485
  return ((task->group_leader)->pids[1].pid);
}
}
#line 1488 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_session(struct task_struct *task ) 
{ 

  {
#line 1490
  return ((task->group_leader)->pids[2].pid);
}
}
#line 1508
extern pid_t __task_pid_nr_ns(struct task_struct *task , enum pid_type type , struct pid_namespace *ns ) ;
#line 1511 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_nr(struct task_struct *tsk ) 
{ 

  {
#line 1513
  return (tsk->pid);
}
}
#line 1516 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
#line 1519
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, ns);
  }
#line 1519
  return (tmp);
}
}
#line 1522 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1524
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, (struct pid_namespace *)((void *)0));
  }
#line 1524
  return (tmp);
}
}
#line 1528 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_tgid_nr(struct task_struct *tsk ) 
{ 

  {
#line 1530
  return (tsk->tgid);
}
}
#line 1533
extern pid_t task_tgid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) ;
#line 1535 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_tgid_vnr(struct task_struct *tsk ) 
{ struct pid *tmp ;
  pid_t tmp___0 ;

  {
  {
#line 1537
  tmp = task_tgid(tsk);
#line 1537
  tmp___0 = pid_vnr(tmp);
  }
#line 1537
  return (tmp___0);
}
}
#line 1541 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
#line 1544
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, ns);
  }
#line 1544
  return (tmp);
}
}
#line 1547 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1549
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, (struct pid_namespace *)((void *)0));
  }
#line 1549
  return (tmp);
}
}
#line 1553 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_session_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
#line 1556
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, ns);
  }
#line 1556
  return (tmp);
}
}
#line 1559 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_session_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1561
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, (struct pid_namespace *)((void *)0));
  }
#line 1561
  return (tmp);
}
}
#line 1565 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_nr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1567
  tmp = task_pgrp_nr_ns(tsk, & init_pid_ns);
  }
#line 1567
  return (tmp);
}
}
#line 1578 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int pid_alive(struct task_struct *p ) 
{ 

  {
#line 1580
  return ((unsigned long )p->pids[0].pid != (unsigned long )((void *)0));
}
}
#line 1589 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int is_global_init(struct task_struct *tsk ) 
{ 

  {
#line 1591
  return (tsk->pid == 1);
}
}
#line 1598
extern int is_container_init(struct task_struct *tsk ) ;
#line 1600
extern struct pid *cad_pid ;
#line 1602
extern void free_task(struct task_struct *tsk ) ;
#line 1605
extern void __put_task_struct(struct task_struct *t ) ;
#line 1607 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void put_task_struct(struct task_struct *t ) 
{ int tmp ;

  {
  {
#line 1609
  tmp = atomic_dec_and_test(& t->usage);
  }
#line 1609
  if (tmp) {
    {
#line 1610
    __put_task_struct(t);
    }
  }
#line 1611
  return;
}
}
#line 1613
extern cputime_t task_utime(struct task_struct *p ) ;
#line 1614
extern cputime_t task_stime(struct task_struct *p ) ;
#line 1615
extern cputime_t task_gtime(struct task_struct *p ) ;
#line 1677
extern int set_cpus_allowed_ptr(struct task_struct *p , struct cpumask  const  *new_mask ) ;
#line 1688 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int set_cpus_allowed(struct task_struct *p , cpumask_t new_mask ) 
{ int tmp ;

  {
  {
#line 1690
  tmp = set_cpus_allowed_ptr(p, (struct cpumask  const  *)(& new_mask));
  }
#line 1690
  return (tmp);
}
}
#line 1700
extern int sched_clock_stable ;
#line 1703
extern unsigned long long sched_clock(void) ;
#line 1705
extern void sched_clock_init(void) ;
#line 1706
extern u64 sched_clock_cpu(int cpu ) ;
#line 1721
extern void sched_clock_tick(void) ;
#line 1722
extern void sched_clock_idle_sleep_event(void) ;
#line 1723
extern void sched_clock_idle_wakeup_event(u64 delta_ns ) ;
#line 1730
extern unsigned long long cpu_clock(int cpu ) ;
#line 1732
extern unsigned long long task_sched_runtime(struct task_struct *task ) ;
#line 1734
extern unsigned long long thread_group_sched_runtime(struct task_struct *task ) ;
#line 1738
extern void sched_exec(void) ;
#line 1747
extern void idle_task_exit(void) ;
#line 1752
extern void sched_idle_next(void) ;
#line 1755
extern void wake_up_idle_cpu(int cpu ) ;
#line 1760
extern unsigned int sysctl_sched_latency ;
#line 1761
extern unsigned int sysctl_sched_min_granularity ;
#line 1762
extern unsigned int sysctl_sched_wakeup_granularity ;
#line 1763
extern unsigned int sysctl_sched_shares_ratelimit ;
#line 1764
extern unsigned int sysctl_sched_shares_thresh ;
#line 1775
extern unsigned int sysctl_sched_rt_period ;
#line 1776
extern int sysctl_sched_rt_runtime ;
#line 1778
extern int sched_rt_handler(struct ctl_table *table , int write , struct file *filp ,
                            void *buffer , size_t *lenp , loff_t *ppos ) ;
#line 1782
extern unsigned int sysctl_sched_compat_yield ;
#line 1785
extern int rt_mutex_getprio(struct task_struct *p ) ;
#line 1786
extern void rt_mutex_setprio(struct task_struct *p , int prio ) ;
#line 1787
extern void rt_mutex_adjust_pi(struct task_struct *p ) ;
#line 1796
extern void set_user_nice(struct task_struct *p , long nice ) ;
#line 1797
extern int task_prio(struct task_struct  const  *p ) ;
#line 1798
extern int task_nice(struct task_struct  const  *p ) ;
#line 1799
extern int can_nice(struct task_struct  const  *p , int nice ) ;
#line 1800
extern int task_curr(struct task_struct  const  *p ) ;
#line 1801
extern int idle_cpu(int cpu ) ;
#line 1802
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param * ) ;
#line 1803
extern int sched_setscheduler_nocheck(struct task_struct * , int  , struct sched_param * ) ;
#line 1805
extern struct task_struct *idle_task(int cpu ) ;
#line 1806
extern struct task_struct *curr_task(int cpu ) ;
#line 1807
extern void set_curr_task(int cpu , struct task_struct *p ) ;
#line 1809
extern void yield(void) ;
#line 1814
extern struct exec_domain default_exec_domain ;
#line 1822 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int kstack_end(void *addr ) 
{ 

  {
#line 1827
  return (! ((((unsigned long )addr + sizeof(void *)) - 1UL) & (((1UL << 12) << 1) - sizeof(void *))));
}
}
#line 1831
extern union thread_union init_thread_union ;
#line 1832
extern struct task_struct init_task ;
#line 1834
extern struct mm_struct init_mm ;
#line 1852
extern struct task_struct *find_task_by_pid_type_ns(int type , int pid , struct pid_namespace *ns ) ;
#line 1855
extern struct task_struct *find_task_by_vpid(pid_t nr ) ;
#line 1856
extern struct task_struct *find_task_by_pid_ns(pid_t nr , struct pid_namespace *ns ) ;
#line 1859
extern void __set_special_pids(struct pid *pid ) ;
#line 1862
extern struct user_struct *alloc_uid(struct user_namespace * , uid_t  ) ;
#line 1863 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct user_struct *get_uid(struct user_struct *u ) 
{ 

  {
  {
#line 1865
  atomic_inc(& u->__count);
  }
#line 1866
  return (u);
}
}
#line 1868
extern void free_uid(struct user_struct * ) ;
#line 1869
extern void release_uids(struct user_namespace *ns ) ;
#line 1873
extern void do_timer(unsigned long ticks ) ;
#line 1875
extern int wake_up_state(struct task_struct *tsk , unsigned int state ) ;
#line 1876
extern int wake_up_process(struct task_struct *tsk ) ;
#line 1877
extern void wake_up_new_task(struct task_struct *tsk , unsigned long clone_flags ) ;
#line 1880
extern void kick_process(struct task_struct *tsk ) ;
#line 1884
extern void sched_fork(struct task_struct *p , int clone_flags ) ;
#line 1885
extern void sched_dead(struct task_struct *p ) ;
#line 1887
extern void proc_caches_init(void) ;
#line 1888
extern void flush_signals(struct task_struct * ) ;
#line 1889
extern void ignore_signals(struct task_struct * ) ;
#line 1890
extern void flush_signal_handlers(struct task_struct * , int force_default ) ;
#line 1891
extern int dequeue_signal(struct task_struct *tsk , sigset_t *mask , siginfo_t *info ) ;
#line 1893 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int dequeue_signal_lock(struct task_struct *tsk , sigset_t *mask ,
                                        siginfo_t *info ) 
{ unsigned long flags ;
  int ret ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
#line 1898
  while (1) {
    while_160_continue: /* CIL Label */ ;
    {
#line 1898
    flags = _spin_lock_irqsave(& (tsk->sighand)->siglock);
    }
    goto while_160_break;
  }
  while_160_break: /* CIL Label */ ;
  }
  {
#line 1899
  ret = dequeue_signal(tsk, mask, info);
  }
  {
#line 1900
  while (1) {
    while_161_continue: /* CIL Label */ ;
    {
#line 1900
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, flags);
    }
    goto while_161_break;
  }
  while_161_break: /* CIL Label */ ;
  }
#line 1902
  return (ret);
}
}
#line 1905
extern void block_all_signals(int (*notifier)(void *priv ) , void *priv , sigset_t *mask ) ;
#line 1907
extern void unblock_all_signals(void) ;
#line 1908
extern void release_task(struct task_struct *p ) ;
#line 1909
extern int send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 1910
extern int force_sigsegv(int  , struct task_struct * ) ;
#line 1911
extern int force_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 1912
extern int __kill_pgrp_info(int sig , struct siginfo *info , struct pid *pgrp ) ;
#line 1913
extern int kill_pid_info(int sig , struct siginfo *info , struct pid *pid ) ;
#line 1914
extern int kill_pid_info_as_uid(int  , struct siginfo * , struct pid * , uid_t  ,
                                uid_t  , u32  ) ;
#line 1915
extern int kill_pgrp(struct pid *pid , int sig , int priv ) ;
#line 1916
extern int kill_pid(struct pid *pid , int sig , int priv ) ;
#line 1917
extern int kill_proc_info(int  , struct siginfo * , pid_t  ) ;
#line 1918
extern int do_notify_parent(struct task_struct * , int  ) ;
#line 1919
extern void force_sig(int  , struct task_struct * ) ;
#line 1920
extern void force_sig_specific(int  , struct task_struct * ) ;
#line 1921
extern int send_sig(int  , struct task_struct * , int  ) ;
#line 1922
extern void zap_other_threads(struct task_struct *p ) ;
#line 1923
extern struct sigqueue *sigqueue_alloc(void) ;
#line 1924
extern void sigqueue_free(struct sigqueue * ) ;
#line 1925
extern int send_sigqueue(struct sigqueue * , struct task_struct * , int group ) ;
#line 1926
extern int do_sigaction(int  , struct k_sigaction * , struct k_sigaction * ) ;
#line 1927
extern int do_sigaltstack(stack_t const   * , stack_t * , unsigned long  ) ;
#line 1929 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int kill_cad_pid(int sig , int priv ) 
{ int tmp ;

  {
  {
#line 1931
  tmp = kill_pid(cad_pid, sig, priv);
  }
#line 1931
  return (tmp);
}
}
#line 1939 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int is_si_special(struct siginfo  const  *info ) 
{ 

  {
#line 1941
  return ((unsigned long )info <= (unsigned long )((struct siginfo *)2));
}
}
#line 1946 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int on_sig_stack(unsigned long sp ) 
{ struct task_struct *tmp ;
  struct task_struct *tmp___0 ;

  {
  {
#line 1948
  tmp = get_current();
#line 1948
  tmp___0 = get_current();
  }
#line 1948
  return (sp - tmp->sas_ss_sp < (unsigned long )tmp___0->sas_ss_size);
}
}
#line 1951 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sas_ss_flags(unsigned long sp ) 
{ struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;

  {
  {
#line 1953
  tmp___4 = get_current();
  }
#line 1953
  if (tmp___4->sas_ss_size == 0U) {
    {
#line 1953
    tmp___3 = 2;
    }
  } else {
    {
#line 1953
    tmp___2 = on_sig_stack(sp);
    }
#line 1953
    if (tmp___2) {
      {
#line 1953
      tmp___1 = 1;
      }
    } else {
      {
#line 1953
      tmp___1 = 0;
      }
    }
    {
#line 1953
    tmp___3 = tmp___1;
    }
  }
#line 1953
  return (tmp___3);
}
}
#line 1960
extern struct mm_struct *mm_alloc(void) ;
#line 1963
extern void __mmdrop(struct mm_struct * ) ;
#line 1964 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void mmdrop(struct mm_struct *mm ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1966
  tmp = atomic_dec_and_test(& mm->mm_count);
  }
#line 1966
  if (tmp) {
    {
#line 1966
    tmp___0 = 1;
    }
  } else {
    {
#line 1966
    tmp___0 = 0;
    }
  }
  {
#line 1966
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1966
  if (tmp___1) {
    {
#line 1967
    __mmdrop(mm);
    }
  }
#line 1968
  return;
}
}
#line 1971
extern void mmput(struct mm_struct * ) ;
#line 1973
extern struct mm_struct *get_task_mm(struct task_struct *task ) ;
#line 1975
extern void mm_release(struct task_struct * , struct mm_struct * ) ;
#line 1977
extern struct mm_struct *dup_mm(struct task_struct *tsk ) ;
#line 1979
extern int copy_thread(unsigned long  , unsigned long  , unsigned long  , struct task_struct * ,
                       struct pt_regs * ) ;
#line 1981
extern void flush_thread(void) ;
#line 1982
extern void exit_thread(void) ;
#line 1984
extern void exit_files(struct task_struct * ) ;
#line 1985
extern void __cleanup_signal(struct signal_struct * ) ;
#line 1986
extern void __cleanup_sighand(struct sighand_struct * ) ;
#line 1988
extern void exit_itimers(struct signal_struct * ) ;
#line 1989
extern void flush_itimer_signals(void) ;
#line 1991
extern void do_group_exit(int  ) ;
#line 1993
extern void daemonize(char const   *  , ...) ;
#line 1994
extern int allow_signal(int  ) ;
#line 1995
extern int disallow_signal(int  ) ;
#line 1997
extern int do_execve(char * , char ** , char ** , struct pt_regs * ) ;
#line 1998
extern long do_fork(unsigned long  , unsigned long  , struct pt_regs * , unsigned long  ,
                    int * , int * ) ;
#line 1999
extern struct task_struct *fork_idle(int  ) ;
#line 2001
extern void set_task_comm(struct task_struct *tsk , char *from ) ;
#line 2002
extern char *get_task_comm(char *to , struct task_struct *tsk ) ;
#line 2005
extern unsigned long wait_task_inactive(struct task_struct * , long match_state ) ;
#line 2019
extern bool is_single_threaded(struct task_struct * ) ;
#line 2040 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int has_group_leader_pid(struct task_struct *p ) 
{ 

  {
#line 2042
  return (p->pid == p->tgid);
}
}
#line 2045 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int same_thread_group(struct task_struct *p1 , struct task_struct *p2 ) 
{ 

  {
#line 2048
  return (p1->tgid == p2->tgid);
}
}
#line 2051 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct task_struct *next_thread(struct task_struct  const  *p ) 
{ struct list_head  const  *__mptr ;
  struct list_head *_________p1 ;

  {
  {
#line 2053
  _________p1 = (struct list_head *)*((struct list_head * const volatile  *)(& p->thread_group.next));
  }
  {
#line 2053
  while (1) {
    while_162_continue: /* CIL Label */ ;
    goto while_162_break;
  }
  while_162_break: /* CIL Label */ ;
  }
  {
#line 2053
  __mptr = (struct list_head  const  *)_________p1;
  }
#line 2053
  return ((struct task_struct *)((char *)__mptr - (unsigned int )(& ((struct task_struct *)0)->thread_group)));
}
}
#line 2057 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int thread_group_empty(struct task_struct *p ) 
{ int tmp ;

  {
  {
#line 2059
  tmp = list_empty((struct list_head  const  *)(& p->thread_group));
  }
#line 2059
  return (tmp);
}
}
#line 2065 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int task_detached(struct task_struct *p ) 
{ 

  {
#line 2067
  return (p->exit_signal == -1);
}
}
#line 2080 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void task_lock(struct task_struct *p ) 
{ 

  {
  {
#line 2082
  _spin_lock(& p->alloc_lock);
  }
#line 2083
  return;
}
}
#line 2085 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void task_unlock(struct task_struct *p ) 
{ 

  {
  {
#line 2087
  _spin_unlock(& p->alloc_lock);
  }
#line 2088
  return;
}
}
#line 2090
extern struct sighand_struct *lock_task_sighand(struct task_struct *tsk , unsigned long *flags ) ;
#line 2093 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void unlock_task_sighand(struct task_struct *tsk , unsigned long *flags ) 
{ unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
#line 2096
  while (1) {
    while_163_continue: /* CIL Label */ ;
    {
#line 2096
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, *flags);
    }
    goto while_163_break;
  }
  while_163_break: /* CIL Label */ ;
  }
#line 2097
  return;
}
}
#line 2104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void setup_thread_stack(struct task_struct *p , struct task_struct *org ) 
{ 

  {
  {
#line 2106
  *((struct thread_info *)p->stack) = *((struct thread_info *)org->stack);
#line 2107
  ((struct thread_info *)p->stack)->task = p;
  }
#line 2108
  return;
}
}
#line 2110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long *end_of_stack(struct task_struct *p ) 
{ 

  {
#line 2112
  return ((unsigned long *)((struct thread_info *)p->stack + 1));
}
}
#line 2117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int object_is_on_stack(void *obj ) 
{ void *stack ;
  struct task_struct *tmp ;
  int tmp___0 ;

  {
  {
#line 2119
  tmp = get_current();
#line 2119
  stack = tmp->stack;
  }
#line 2121
  if ((unsigned long )obj >= (unsigned long )stack) {
#line 2121
    if ((unsigned long )obj < (unsigned long )(stack + ((1UL << 12) << 1))) {
      {
#line 2121
      tmp___0 = 1;
      }
    } else {
      {
#line 2121
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 2121
    tmp___0 = 0;
    }
  }
#line 2121
  return (tmp___0);
}
}
#line 2124
extern void thread_info_cache_init(void) ;
#line 2127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long stack_not_used(struct task_struct *p ) 
{ unsigned long *n ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;

  {
  {
#line 2129
  tmp = end_of_stack(p);
#line 2129
  n = tmp;
  }
  {
#line 2131
  while (1) {
    while_164_continue: /* CIL Label */ ;
    {
#line 2132
    n ++;
    }
#line 2131
    if (! (! *n)) {
      goto while_164_break;
    }
  }
  while_164_break: /* CIL Label */ ;
  }
  {
#line 2135
  tmp___0 = end_of_stack(p);
  }
#line 2135
  return ((unsigned long )n - (unsigned long )tmp___0);
}
}
#line 2142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
#line 2144
  set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2145
  return;
}
}
#line 2147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
#line 2149
  clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2150
  return;
}
}
#line 2152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_and_set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
#line 2154
  tmp = test_and_set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2154
  return (tmp);
}
}
#line 2157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_and_clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
#line 2159
  tmp = test_and_clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2159
  return (tmp);
}
}
#line 2162 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
#line 2164
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2164
  return (tmp);
}
}
#line 2167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void set_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
#line 2169
  set_tsk_thread_flag(tsk, 3);
  }
#line 2170
  return;
}
}
#line 2172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void clear_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
#line 2174
  clear_tsk_thread_flag(tsk, 3);
  }
#line 2175
  return;
}
}
#line 2177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_tsk_need_resched(struct task_struct *tsk ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 2179
  tmp = test_tsk_thread_flag(tsk, 3);
  }
#line 2179
  if (tmp) {
    {
#line 2179
    tmp___0 = 1;
    }
  } else {
    {
#line 2179
    tmp___0 = 0;
    }
  }
  {
#line 2179
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 2179
  return ((int )tmp___1);
}
}
#line 2182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 2184
  tmp = test_tsk_thread_flag(p, 2);
  }
#line 2184
  if (tmp) {
    {
#line 2184
    tmp___0 = 1;
    }
  } else {
    {
#line 2184
    tmp___0 = 0;
    }
  }
  {
#line 2184
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 2184
  return ((int )tmp___1);
}
}
#line 2187
extern int __fatal_signal_pending(struct task_struct *p ) ;
#line 2189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int fatal_signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2191
  tmp = signal_pending(p);
  }
#line 2191
  if (tmp) {
    {
#line 2191
    tmp___0 = __fatal_signal_pending(p);
    }
#line 2191
    if (tmp___0) {
      {
#line 2191
      tmp___1 = 1;
      }
    } else {
      {
#line 2191
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 2191
    tmp___1 = 0;
    }
  }
#line 2191
  return (tmp___1);
}
}
#line 2194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int signal_pending_state(long state , struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2196
  if (! (state & 129L)) {
#line 2197
    return (0);
  }
  {
#line 2198
  tmp = signal_pending(p);
  }
#line 2198
  if (! tmp) {
#line 2199
    return (0);
  }
#line 2201
  if (state & 1L) {
    {
#line 2201
    tmp___1 = 1;
    }
  } else {
    {
#line 2201
    tmp___0 = __fatal_signal_pending(p);
    }
#line 2201
    if (tmp___0) {
      {
#line 2201
      tmp___1 = 1;
      }
    } else {
      {
#line 2201
      tmp___1 = 0;
      }
    }
  }
#line 2201
  return (tmp___1);
}
}
#line 2204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int need_resched(void) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2206
  tmp = current_thread_info();
#line 2206
  tmp___0 = test_ti_thread_flag(tmp, 3);
  }
#line 2206
  if (tmp___0) {
    {
#line 2206
    tmp___1 = 1;
    }
  } else {
    {
#line 2206
    tmp___1 = 0;
    }
  }
  {
#line 2206
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2206
  return ((int )tmp___2);
}
}
#line 2223 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int cond_resched(void) 
{ int tmp ;

  {
  {
#line 2225
  tmp = _cond_resched();
  }
#line 2225
  return (tmp);
}
}
#line 2228
extern int cond_resched_lock(spinlock_t *lock ) ;
#line 2229
extern int cond_resched_softirq(void) ;
#line 2230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int cond_resched_bkl(void) 
{ int tmp ;

  {
  {
#line 2232
  tmp = _cond_resched();
  }
#line 2232
  return (tmp);
}
}
#line 2240 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int spin_needbreak(spinlock_t *lock ) 
{ 

  {
#line 2245
  return (0);
}
}
#line 2252
extern void thread_group_cputime(struct task_struct *tsk , struct task_cputime *times ) ;
#line 2253
extern void thread_group_cputimer(struct task_struct *tsk , struct task_cputime *times ) ;
#line 2258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
static struct lock_class_key __key  ;
#line 2255 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void thread_group_cputime_init(struct signal_struct *sig ) 
{ struct task_cputime __constr_expr_0 ;

  {
  {
#line 2257
  __constr_expr_0.utime = 0UL;
#line 2257
  __constr_expr_0.stime = 0UL;
#line 2257
  __constr_expr_0.sum_exec_runtime = 0ULL;
#line 2257
  sig->cputimer.cputime = __constr_expr_0;
  }
  {
#line 2258
  while (1) {
    while_165_continue: /* CIL Label */ ;
    {
#line 2258
    __spin_lock_init(& sig->cputimer.lock, "&sig->cputimer.lock", & __key);
    }
    goto while_165_break;
  }
  while_165_break: /* CIL Label */ ;
  }
  {
#line 2259
  sig->cputimer.running = 0;
  }
#line 2260
  return;
}
}
#line 2262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void thread_group_cputime_free(struct signal_struct *sig ) 
{ 

  {
#line 2264
  return;
}
}
#line 2272
extern void recalc_sigpending_and_wake(struct task_struct *t ) ;
#line 2273
extern void recalc_sigpending(void) ;
#line 2275
extern void signal_wake_up(struct task_struct *t , int resume_stopped ) ;
#line 2282 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned int task_cpu(struct task_struct  const  *p ) 
{ 

  {
#line 2284
  return (((struct thread_info *)p->stack)->cpu);
}
}
#line 2287
extern void set_task_cpu(struct task_struct *p , unsigned int cpu ) ;
#line 2302
extern void arch_pick_mmap_layout(struct mm_struct *mm ) ;
#line 2305
extern void __trace_special(void *__tr , void *__data , unsigned long arg1 , unsigned long arg2 ,
                            unsigned long arg3 ) ;
#line 2316
extern long sched_setaffinity(pid_t pid , struct cpumask  const  *new_mask ) ;
#line 2317
extern long sched_getaffinity(pid_t pid , struct cpumask *mask ) ;
#line 2319
extern void normalize_rt_tasks(void) ;
#line 2323
extern struct task_group init_task_group ;
#line 2329
extern struct task_group *sched_create_group(struct task_group *parent ) ;
#line 2330
extern void sched_destroy_group(struct task_group *tg ) ;
#line 2331
extern void sched_move_task(struct task_struct *tsk ) ;
#line 2333
extern int sched_group_set_shares(struct task_group *tg , unsigned long shares ) ;
#line 2334
extern unsigned long sched_group_shares(struct task_group *tg ) ;
#line 2347
extern int task_can_switch_user(struct user_struct *up , struct task_struct *tsk ) ;
#line 2351 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void add_rchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
#line 2353
  tsk->ioac.rchar += (u64 )amt;
  }
#line 2354
  return;
}
}
#line 2356 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void add_wchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
#line 2358
  tsk->ioac.wchar += (u64 )amt;
  }
#line 2359
  return;
}
}
#line 2361 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void inc_syscr(struct task_struct *tsk ) 
{ 

  {
  {
#line 2363
  (tsk->ioac.syscr) ++;
  }
#line 2364
  return;
}
}
#line 2366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void inc_syscw(struct task_struct *tsk ) 
{ 

  {
  {
#line 2368
  (tsk->ioac.syscw) ++;
  }
#line 2369
  return;
}
}
#line 2396 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void mm_update_next_owner(struct mm_struct *mm ) 
{ 

  {
#line 2398
  return;
}
}
#line 2400 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void mm_init_owner(struct mm_struct *mm , struct task_struct *p ) 
{ 

  {
#line 2402
  return;
}
}
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp_lock.h"
extern int __reacquire_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 10
extern void __release_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp_lock.h"
__inline static int reacquire_kernel_lock(struct task_struct *task ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
#line 22
  tmp___0 = __builtin_expect((long )(! (! (task->lock_depth >= 0))), 0L);
  }
#line 22
  if (tmp___0) {
    {
#line 23
    tmp = __reacquire_kernel_lock();
    }
#line 23
    return (tmp);
  }
#line 24
  return (0);
}
}
#line 27
extern void lock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 28
extern void unlock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp_lock.h"
__inline static void cycle_kernel_lock(void) 
{ 

  {
  {
#line 38
  lock_kernel();
#line 39
  unlock_kernel();
  }
#line 40
  return;
}
}
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ftrace_irq.h"
__inline static void ftrace_nmi_enter(void) 
{ 

  {
#line 9
  return;
}
}
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ftrace_irq.h"
__inline static void ftrace_nmi_exit(void) 
{ 

  {
#line 10
  return;
}
}
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq.h"
__inline static int irq_canonicalize(int irq ) 
{ int tmp ;

  {
#line 15
  if (irq == 2) {
    {
#line 15
    tmp = 9;
    }
  } else {
    {
#line 15
    tmp = irq;
    }
  }
#line 15
  return (tmp);
}
}
#line 36
extern void fixup_irqs(void) ;
#line 39
extern void (*generic_interrupt_extension)(void) ;
#line 40
extern void init_IRQ(void) ;
#line 41
extern void native_init_IRQ(void) ;
#line 42
extern bool handle_irq(unsigned int irq , struct pt_regs *regs ) ;
#line 44
extern unsigned int do_IRQ(struct pt_regs *regs ) ;
#line 48
extern int vector_used_by_percpu_irq(unsigned int vector ) ;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
extern struct pt_regs *per_cpu__irq_regs  __attribute__((__section__(".data.percpu"))) ;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
__inline static struct pt_regs *get_irq_regs(void) 
{ struct pt_regs *ret__ ;

  {
#line 18
  if ((int )sizeof(per_cpu__irq_regs) == 1) {
    goto switch_166_1;
  } else {
#line 18
    if ((int )sizeof(per_cpu__irq_regs) == 2) {
      goto switch_166_2;
    } else {
#line 18
      if ((int )sizeof(per_cpu__irq_regs) == 4) {
        goto switch_166_4;
      } else {
#line 18
        if ((int )sizeof(per_cpu__irq_regs) == 8) {
          goto switch_166_8;
        } else {
          {
          goto switch_166_default;
#line 18
          if (0) {
            switch_166_1: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_166_break;
            switch_166_2: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_166_break;
            switch_166_4: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_166_break;
            switch_166_8: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_166_break;
            switch_166_default: /* CIL Label */ 
            {
#line 18
            __bad_percpu_size();
            }
          } else {
            switch_166_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
#line 18
  return (ret__);
}
}
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
__inline static struct pt_regs *set_irq_regs(struct pt_regs *new_regs ) 
{ struct pt_regs *old_regs ;
  T__ tmp__ ;

  {
  {
#line 25
  old_regs = get_irq_regs();
  }
  {
#line 26
  while (1) {
    while_167_continue: /* CIL Label */ ;
#line 26
    if ((int )sizeof(per_cpu__irq_regs) == 1) {
      goto switch_168_1;
    } else {
#line 26
      if ((int )sizeof(per_cpu__irq_regs) == 2) {
        goto switch_168_2;
      } else {
#line 26
        if ((int )sizeof(per_cpu__irq_regs) == 4) {
          goto switch_168_4;
        } else {
#line 26
          if ((int )sizeof(per_cpu__irq_regs) == 8) {
            goto switch_168_8;
          } else {
            {
            goto switch_168_default;
#line 26
            if (0) {
              switch_168_1: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "b %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "qi" (new_regs));
              }
              goto switch_168_break;
              switch_168_2: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "w %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_168_break;
              switch_168_4: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "l %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_168_break;
              switch_168_8: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "q %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "re" (new_regs));
              }
              goto switch_168_break;
              switch_168_default: /* CIL Label */ 
              {
#line 26
              __bad_percpu_size();
              }
            } else {
              switch_168_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_167_break;
  }
  while_167_break: /* CIL Label */ ;
  }
#line 28
  return (old_regs);
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
extern void arch_init_copy_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ,
                                     int cpu ) ;
#line 205
extern void arch_free_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ) ;
#line 210
extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc , int cpu ) ;
#line 213
extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq , int cpu ) ;
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static struct irq_desc *irq_remap_to_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
#line 221
  return (desc);
}
}
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/profile.h"
extern void create_prof_cpu_mask(struct proc_dir_entry *de ) ;
#line 22
extern int create_proc_profile(void) ;
#line 41
extern int prof_on  __attribute__((__section__(".data.read_mostly"))) ;
#line 44
extern int profile_init(void) ;
#line 45
extern int profile_setup(char *str ) ;
#line 46
extern void profile_tick(int type ) ;
#line 51
extern void profile_hits(int type , void *ip , unsigned int nr_hits ) ;
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/profile.h"
__inline static void profile_hit(int type , void *ip ) 
{ long tmp ;

  {
  {
#line 61
  tmp = __builtin_expect((long )(! (! (prof_on == type))), 0L);
  }
#line 61
  if (tmp) {
    {
#line 62
    profile_hits(type, ip, 1U);
    }
  }
#line 63
  return;
}
}
#line 69
extern void profile_task_exit(struct task_struct *task ) ;
#line 74
extern int profile_handoff_task(struct task_struct *task ) ;
#line 77
extern void profile_munmap(unsigned long addr ) ;
#line 79
extern int task_handoff_register(struct notifier_block *n ) ;
#line 80
extern int task_handoff_unregister(struct notifier_block *n ) ;
#line 82
extern int profile_event_register(enum profile_type  , struct notifier_block *n ) ;
#line 83
extern int profile_event_unregister(enum profile_type  , struct notifier_block *n ) ;
#line 85
extern int register_timer_hook(int (*hook)(struct pt_regs * ) ) ;
#line 86
extern void unregister_timer_hook(int (*hook)(struct pt_regs * ) ) ;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/sections.h"
extern char _text[] ;
#line 6
extern char _stext[] ;
#line 6
extern char _etext[] ;
#line 7
extern char _data[] ;
#line 7
extern char _sdata[] ;
#line 7
extern char _edata[] ;
#line 8
extern char __bss_start[] ;
#line 8
extern char __bss_stop[] ;
#line 9
extern char __init_begin[] ;
#line 9
extern char __init_end[] ;
#line 10
extern char _sinittext[] ;
#line 10
extern char _einittext[] ;
#line 11
extern char _end[] ;
#line 12
extern char __per_cpu_load[] ;
#line 12
extern char __per_cpu_start[] ;
#line 12
extern char __per_cpu_end[] ;
#line 13
extern char __kprobes_text_start[] ;
#line 13
extern char __kprobes_text_end[] ;
#line 14
extern char __initdata_begin[] ;
#line 14
extern char __initdata_end[] ;
#line 15
extern char __start_rodata[] ;
#line 15
extern char __end_rodata[] ;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sections.h"
extern char __brk_base[] ;
#line 6
extern char __brk_limit[] ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hw_irq.h"
extern void apic_timer_interrupt(void) ;
#line 30
extern void generic_interrupt(void) ;
#line 31
extern void error_interrupt(void) ;
#line 32
extern void spurious_interrupt(void) ;
#line 33
extern void thermal_interrupt(void) ;
#line 34
extern void reschedule_interrupt(void) ;
#line 36
extern void invalidate_interrupt(void) ;
#line 37
extern void invalidate_interrupt0(void) ;
#line 38
extern void invalidate_interrupt1(void) ;
#line 39
extern void invalidate_interrupt2(void) ;
#line 40
extern void invalidate_interrupt3(void) ;
#line 41
extern void invalidate_interrupt4(void) ;
#line 42
extern void invalidate_interrupt5(void) ;
#line 43
extern void invalidate_interrupt6(void) ;
#line 44
extern void invalidate_interrupt7(void) ;
#line 46
extern void irq_move_cleanup_interrupt(void) ;
#line 47
extern void threshold_interrupt(void) ;
#line 49
extern void call_function_interrupt(void) ;
#line 50
extern void call_function_single_interrupt(void) ;
#line 53
extern void disable_8259A_irq(unsigned int irq ) ;
#line 54
extern void enable_8259A_irq(unsigned int irq ) ;
#line 55
extern int i8259A_irq_pending(unsigned int irq ) ;
#line 56
extern void make_8259A_irq(unsigned int irq ) ;
#line 57
extern void init_8259A(int aeoi ) ;
#line 61
extern unsigned long io_apic_irqs ;
#line 63
extern void init_VISWS_APIC_irqs(void) ;
#line 64
extern void setup_IO_APIC(void) ;
#line 65
extern void disable_IO_APIC(void) ;
#line 66
extern int IO_APIC_get_PCI_irq_vector(int bus , int slot , int fn ) ;
#line 67
extern void setup_ioapic_dest(void) ;
#line 69
extern void enable_IO_APIC(void) ;
#line 72
extern atomic_t irq_err_count ;
#line 73
extern atomic_t irq_mis_count ;
#line 76
extern void eisa_set_level_irq(unsigned int irq ) ;
#line 79
extern void smp_apic_timer_interrupt(struct pt_regs * ) ;
#line 80
extern void smp_spurious_interrupt(struct pt_regs * ) ;
#line 81
extern void smp_error_interrupt(struct pt_regs * ) ;
#line 83
extern void smp_reschedule_interrupt(struct pt_regs * ) ;
#line 84
extern void smp_call_function_interrupt(struct pt_regs * ) ;
#line 85
extern void smp_call_function_single_interrupt(struct pt_regs * ) ;
#line 87
extern void smp_invalidate_interrupt(struct pt_regs * ) ;
#line 93
extern void (*interrupt[224])(void)  __attribute__((__section__(".init.rodata"))) ;
#line 96
extern vector_irq_t per_cpu__vector_irq  __attribute__((__section__(".data.percpu"))) ;
#line 99
extern void lock_vector_lock(void) ;
#line 100
extern void unlock_vector_lock(void) ;
#line 101
extern void __setup_vector_irq(int cpu ) ;
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
extern int setup_irq(unsigned int irq , struct irqaction *new ) ;
#line 238
extern void remove_irq(unsigned int irq , struct irqaction *act ) ;
#line 246
extern void move_native_irq(int irq ) ;
#line 247
extern void move_masked_irq(int irq ) ;
#line 272
extern int no_irq_affinity ;
#line 274 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static int irq_balancing_disabled(unsigned int irq ) 
{ struct irq_desc *desc ;

  {
  {
#line 278
  desc = irq_to_desc(irq);
  }
#line 279
  return ((int )(desc->status & 4194304U));
}
}
#line 283
extern irqreturn_t handle_IRQ_event(unsigned int irq , struct irqaction *action ) ;
#line 289
extern void handle_level_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 290
extern void handle_fasteoi_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 291
extern void handle_edge_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 292
extern void handle_simple_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 293
extern void handle_percpu_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 294
extern void handle_bad_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 309 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void generic_handle_irq_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
  {
#line 312
  (*(desc->handle_irq))(irq, desc);
  }
#line 319
  return;
}
}
#line 321 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void generic_handle_irq(unsigned int irq ) 
{ struct irq_desc *tmp ;

  {
  {
#line 323
  tmp = irq_to_desc(irq);
#line 323
  generic_handle_irq_desc(irq, tmp);
  }
#line 324
  return;
}
}
#line 327
extern void note_interrupt(unsigned int irq , struct irq_desc *desc , irqreturn_t action_ret ) ;
#line 331
extern void check_irq_resend(struct irq_desc *desc , unsigned int irq ) ;
#line 334
extern int noirqdebug_setup(char *str ) ;
#line 337
extern int can_request_irq(unsigned int irq , unsigned long irqflags ) ;
#line 340
extern struct irq_chip no_irq_chip ;
#line 341
extern struct irq_chip dummy_irq_chip ;
#line 343
extern void set_irq_chip_and_handler(unsigned int irq , struct irq_chip *chip , void (*handle)(unsigned int irq ,
                                                                                               struct irq_desc *desc ) ) ;
#line 346
extern void set_irq_chip_and_handler_name(unsigned int irq , struct irq_chip *chip ,
                                          void (*handle)(unsigned int irq , struct irq_desc *desc ) ,
                                          char const   *name ) ;
#line 350
extern void __set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                struct irq_desc *desc ) ,
                              int is_chained , char const   *name ) ;
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void __set_irq_handler_unlocked(int irq , void (*handler)(unsigned int irq ,
                                                                          struct irq_desc *desc ) ) 
{ struct irq_desc *desc ;

  {
  {
#line 360
  desc = irq_to_desc((unsigned int )irq);
#line 361
  desc->handle_irq = handler;
  }
#line 362
  return;
}
}
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                       struct irq_desc *desc ) ) 
{ 

  {
  {
#line 370
  __set_irq_handler(irq, handle, 0, (char const   *)((void *)0));
  }
#line 371
  return;
}
}
#line 378 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void set_irq_chained_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                               struct irq_desc *desc ) ) 
{ 

  {
  {
#line 382
  __set_irq_handler(irq, handle, 1, (char const   *)((void *)0));
  }
#line 383
  return;
}
}
#line 385
extern void set_irq_noprobe(unsigned int irq ) ;
#line 386
extern void set_irq_probe(unsigned int irq ) ;
#line 389
extern unsigned int create_irq_nr(unsigned int irq_want ) ;
#line 390
extern int create_irq(void) ;
#line 391
extern void destroy_irq(unsigned int irq ) ;
#line 394 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static int irq_has_action(unsigned int irq ) 
{ struct irq_desc *desc ;
  struct irq_desc *tmp ;

  {
  {
#line 396
  tmp = irq_to_desc(irq);
#line 396
  desc = tmp;
  }
#line 397
  return ((unsigned long )desc->action != (unsigned long )((void *)0));
}
}
#line 401
extern void dynamic_irq_init(unsigned int irq ) ;
#line 402
extern void dynamic_irq_cleanup(unsigned int irq ) ;
#line 405
extern int set_irq_chip(unsigned int irq , struct irq_chip *chip ) ;
#line 406
extern int set_irq_data(unsigned int irq , void *data ) ;
#line 407
extern int set_irq_chip_data(unsigned int irq , void *data ) ;
#line 408
extern int set_irq_type(unsigned int irq , unsigned int type ) ;
#line 409
extern int set_irq_msi(unsigned int irq , struct msi_desc *entry ) ;
#line 436 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static bool init_alloc_desc_masks(struct irq_desc *desc , int cpu , bool boot ) 
{ int node ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 441
  if (boot) {
    {
#line 442
    alloc_bootmem_cpumask_var(& desc->affinity);
#line 443
    cpumask_setall(desc->affinity);
#line 446
    alloc_bootmem_cpumask_var(& desc->pending_mask);
#line 447
    cpumask_clear(desc->pending_mask);
    }
#line 449
    return ((_Bool)1);
  }
  {
#line 452
  node = 0;
#line 454
  tmp = alloc_cpumask_var_node(& desc->affinity, 32U, node);
  }
#line 454
  if (! tmp) {
#line 455
    return ((_Bool)0);
  }
  {
#line 456
  cpumask_setall(desc->affinity);
#line 459
  tmp___0 = alloc_cpumask_var_node(& desc->pending_mask, 32U, node);
  }
#line 459
  if (! tmp___0) {
    {
#line 460
    free_cpumask_var((struct cpumask *)(desc->affinity));
    }
#line 461
    return ((_Bool)0);
  }
  {
#line 463
  cpumask_clear(desc->pending_mask);
  }
#line 465
  return ((_Bool)1);
}
}
#line 478 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void init_copy_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
#line 488
  return;
}
}
#line 490 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void free_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
  {
#line 493
  free_cpumask_var((struct cpumask *)(old_desc->affinity));
#line 496
  free_cpumask_var((struct cpumask *)(old_desc->pending_mask));
  }
#line 498
  return;
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hardirq.h"
extern irq_cpustat_t per_cpu__irq_stat  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
#line 45
extern void ack_bad_irq(unsigned int irq ) ;
#line 47
extern u64 arch_irq_stat_cpu(unsigned int cpu ) ;
#line 50
extern u64 arch_irq_stat(void) ;
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hardirq.h"
extern void synchronize_irq(unsigned int irq ) ;
#line 128 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hardirq.h"
__inline static void account_system_vtime(struct task_struct *tsk ) 
{ 

  {
#line 130
  return;
}
}
#line 134
extern void rcu_irq_enter(void) ;
#line 135
extern void rcu_irq_exit(void) ;
#line 136
extern void rcu_nmi_enter(void) ;
#line 137
extern void rcu_nmi_exit(void) ;
#line 161
extern void irq_enter(void) ;
#line 176
extern void irq_exit(void) ;
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
extern irqreturn_t no_action(int cpl , void *dev_id ) ;
#line 107
extern int request_threaded_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                irqreturn_t (*thread_fn)(int  , void * ) , unsigned long flags ,
                                char const   *name , void *dev ) ;
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ int tmp ;

  {
  {
#line 116
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                             flags, name, dev);
  }
#line 116
  return (tmp);
}
}
#line 119
extern void exit_irq_thread(void) ;
#line 143
extern void free_irq(unsigned int  , void * ) ;
#line 147
extern int devm_request_threaded_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     irqreturn_t (*thread_fn)(int  , void * ) , unsigned long irqflags ,
                                     char const   *devname , void *dev_id ) ;
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int devm_request_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     unsigned long irqflags , char const   *devname ,
                                     void *dev_id ) 
{ int tmp ;

  {
  {
#line 157
  tmp = devm_request_threaded_irq(dev, irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                                  irqflags, devname, dev_id);
  }
#line 157
  return (tmp);
}
}
#line 161
extern void devm_free_irq(struct device *dev , unsigned int irq , void *dev_id ) ;
#line 181
extern void disable_irq_nosync(unsigned int irq ) ;
#line 182
extern void disable_irq(unsigned int irq ) ;
#line 183
extern void enable_irq(unsigned int irq ) ;
#line 186
extern void suspend_device_irqs(void) ;
#line 187
extern void resume_device_irqs(void) ;
#line 189
extern int check_wakeup_irqs(void) ;
#line 196
extern cpumask_var_t irq_default_affinity ;
#line 198
extern int irq_set_affinity(unsigned int irq , struct cpumask  const  *cpumask ) ;
#line 199
extern int irq_can_set_affinity(unsigned int irq ) ;
#line 200
extern int irq_select_affinity(unsigned int irq ) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_nosync_lockdep(unsigned int irq ) 
{ 

  {
  {
#line 232
  disable_irq_nosync(irq);
  }
#line 236
  return;
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_nosync_lockdep_irqsave(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
#line 240
  disable_irq_nosync(irq);
  }
#line 244
  return;
}
}
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
#line 248
  disable_irq(irq);
  }
#line 252
  return;
}
}
#line 254 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void enable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
#line 259
  enable_irq(irq);
  }
#line 260
  return;
}
}
#line 262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void enable_irq_lockdep_irqrestore(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
#line 267
  enable_irq(irq);
  }
#line 268
  return;
}
}
#line 271
extern int set_irq_wake(unsigned int irq , unsigned int on ) ;
#line 273 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int enable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
#line 275
  tmp = set_irq_wake(irq, 1U);
  }
#line 275
  return (tmp);
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int disable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
#line 280
  tmp = set_irq_wake(irq, 0U);
  }
#line 280
  return (tmp);
}
}
#line 349
extern char *softirq_to_name[9] ;
#line 360
extern void ( __attribute__((__regparm__(0))) do_softirq)(void) ;
#line 361
extern void ( __attribute__((__regparm__(0))) __do_softirq)(void) ;
#line 362
extern void open_softirq(int nr , void (*action)(struct softirq_action * ) ) ;
#line 363
extern void softirq_init(void) ;
#line 365
extern void raise_softirq_irqoff(unsigned int nr ) ;
#line 366
extern void raise_softirq(unsigned int nr ) ;
#line 367
extern void wakeup_softirqd(void) ;
#line 376
extern struct list_head per_cpu__softirq_work_list[9]  __attribute__((__section__(".data.percpu"))) ;
#line 381
extern void send_remote_softirq(struct call_single_data *cp , int cpu , int softirq ) ;
#line 386
extern void __send_remote_softirq(struct call_single_data *cp , int cpu , int this_cpu ,
                                  int softirq ) ;
#line 432 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int tasklet_trylock(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 434
  tmp = test_and_set_bit(1, (unsigned long volatile   *)(& t->state));
  }
#line 434
  if (tmp) {
    {
#line 434
    tmp___0 = 0;
    }
  } else {
    {
#line 434
    tmp___0 = 1;
    }
  }
#line 434
  return (tmp___0);
}
}
#line 437 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_unlock(struct tasklet_struct *t ) 
{ 

  {
  {
#line 439
  __asm__  volatile   ("": : : "memory");
#line 440
  clear_bit(1, (unsigned long volatile   *)(& t->state));
  }
#line 441
  return;
}
}
#line 443 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_unlock_wait(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 445
  while (1) {
    while_169_continue: /* CIL Label */ ;
    {
#line 445
    tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& t->state));
    }
#line 445
    if (! tmp) {
      goto while_169_break;
    }
    {
#line 445
    __asm__  volatile   ("": : : "memory");
    }
  }
  while_169_break: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 453
extern void __tasklet_schedule(struct tasklet_struct *t ) ;
#line 455 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
#line 457
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
#line 457
  if (! tmp) {
    {
#line 458
    __tasklet_schedule(t);
    }
  }
#line 459
  return;
}
}
#line 461
extern void __tasklet_hi_schedule(struct tasklet_struct *t ) ;
#line 463 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
#line 465
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
#line 465
  if (! tmp) {
    {
#line 466
    __tasklet_hi_schedule(t);
    }
  }
#line 467
  return;
}
}
#line 470 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_disable_nosync(struct tasklet_struct *t ) 
{ 

  {
  {
#line 472
  atomic_inc(& t->count);
#line 473
  __asm__  volatile   ("": : : "memory");
  }
#line 474
  return;
}
}
#line 476 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_disable(struct tasklet_struct *t ) 
{ 

  {
  {
#line 478
  tasklet_disable_nosync(t);
#line 479
  tasklet_unlock_wait(t);
#line 480
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
#line 481
  return;
}
}
#line 483 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_enable(struct tasklet_struct *t ) 
{ 

  {
  {
#line 485
  __asm__  volatile   ("": : : "memory");
#line 486
  atomic_dec(& t->count);
  }
#line 487
  return;
}
}
#line 489 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hi_enable(struct tasklet_struct *t ) 
{ 

  {
  {
#line 491
  __asm__  volatile   ("": : : "memory");
#line 492
  atomic_dec(& t->count);
  }
#line 493
  return;
}
}
#line 495
extern void tasklet_kill(struct tasklet_struct *t ) ;
#line 496
extern void tasklet_kill_immediate(struct tasklet_struct *t , unsigned int cpu ) ;
#line 497
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
#line 542
extern unsigned long probe_irq_on(void) ;
#line 543
extern int probe_irq_off(unsigned long  ) ;
#line 544
extern unsigned int probe_irq_mask(unsigned long  ) ;
#line 549
extern void init_irq_proc(void) ;
#line 559 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void debug_poll_all_shared_irqs(void) 
{ 

  {
#line 559
  return;
}
}
#line 562
extern int show_interrupts(struct seq_file *p , void *v ) ;
#line 566
extern int early_irq_init(void) ;
#line 567
extern int arch_probe_nr_irqs(void) ;
#line 568
extern int arch_early_irq_init(void) ;
#line 569
extern int arch_init_chip_data(struct irq_desc *desc , int cpu ) ;
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
extern struct resource ioport_resource ;
#line 109
extern struct resource iomem_resource ;
#line 111
extern int request_resource(struct resource *root , struct resource *new ) ;
#line 112
extern int release_resource(struct resource *new ) ;
#line 113
extern void reserve_region_with_split(struct resource *root , resource_size_t start ,
                                      resource_size_t end , char const   *name ) ;
#line 116
extern int insert_resource(struct resource *parent , struct resource *new ) ;
#line 117
extern void insert_resource_expand_to_fit(struct resource *root , struct resource *new ) ;
#line 118
extern int allocate_resource(struct resource *root , struct resource *new , resource_size_t size ,
                             resource_size_t min , resource_size_t max , resource_size_t align ,
                             void (*alignf)(void * , struct resource * , resource_size_t  ,
                                            resource_size_t  ) , void *alignf_data ) ;
#line 124
extern int adjust_resource(struct resource *res , resource_size_t start , resource_size_t size ) ;
#line 126
extern resource_size_t resource_alignment(struct resource *res ) ;
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
__inline static resource_size_t resource_size(struct resource *res ) 
{ 

  {
#line 129
  return ((res->end - res->start) + 1U);
}
}
#line 131 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
__inline static unsigned long resource_type(struct resource *res ) 
{ 

  {
#line 133
  return (res->flags & 3840UL);
}
}
#line 144
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
#line 154
extern int __check_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 155
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
__inline static int check_region(resource_size_t s , resource_size_t n ) 
{ int tmp ;

  {
  {
#line 161
  tmp = __check_region(& ioport_resource, s, n);
  }
#line 161
  return (tmp);
}
}
#line 171
extern struct resource *__devm_request_region(struct device *dev , struct resource *parent ,
                                              resource_size_t start , resource_size_t n ,
                                              char const   *name ) ;
#line 180
extern void __devm_release_region(struct device *dev , struct resource *parent , resource_size_t start ,
                                  resource_size_t n ) ;
#line 182
extern int iomem_map_sanity_check(resource_size_t addr , unsigned long size ) ;
#line 183
extern int iomem_is_exclusive(u64 addr ) ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
extern void klist_init(struct klist *k , void (*get)(struct klist_node * ) , void (*put)(struct klist_node * ) ) ;
#line 45
extern void klist_add_tail(struct klist_node *n , struct klist *k ) ;
#line 46
extern void klist_add_head(struct klist_node *n , struct klist *k ) ;
#line 47
extern void klist_add_after(struct klist_node *n , struct klist_node *pos ) ;
#line 48
extern void klist_add_before(struct klist_node *n , struct klist_node *pos ) ;
#line 50
extern void klist_del(struct klist_node *n ) ;
#line 51
extern void klist_remove(struct klist_node *n ) ;
#line 53
extern int klist_node_attached(struct klist_node *n ) ;
#line 62
extern void klist_iter_init(struct klist *k , struct klist_iter *i ) ;
#line 63
extern void klist_iter_init_node(struct klist *k , struct klist_iter *i , struct klist_node *n ) ;
#line 65
extern void klist_iter_exit(struct klist_iter *i ) ;
#line 66
extern struct klist_node *klist_next(struct klist_iter *i ) ;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/semaphore.h"
static struct lock_class_key __key___0  ;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem , int val ) 
{ struct semaphore __constr_expr_0 ;

  {
  {
#line 35
  __constr_expr_0.lock.raw_lock.slock = 0U;
#line 35
  __constr_expr_0.lock.magic = 3735899821U;
#line 35
  __constr_expr_0.lock.owner_cpu = 4294967295U;
#line 35
  __constr_expr_0.lock.owner = (void *)-1L;
#line 35
  __constr_expr_0.count = (unsigned int )val;
#line 35
  __constr_expr_0.wait_list.next = & sem->wait_list;
#line 35
  __constr_expr_0.wait_list.prev = & sem->wait_list;
#line 35
  *sem = __constr_expr_0;
  }
  {
#line 36
  while (1) {
    while_170_continue: /* CIL Label */ ;
    goto while_170_break;
  }
  while_170_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 42
extern void down(struct semaphore *sem ) ;
#line 43
extern int down_interruptible(struct semaphore *sem ) ;
#line 44
extern int down_killable(struct semaphore *sem ) ;
#line 45
extern int down_trylock(struct semaphore *sem ) ;
#line 46
extern int down_timeout(struct semaphore *sem , long jiffies ) ;
#line 47
extern void up(struct semaphore *sem ) ;
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
extern int bus_create_file(struct bus_type * , struct bus_attribute * ) ;
#line 50
extern void bus_remove_file(struct bus_type * , struct bus_attribute * ) ;
#line 74
extern int bus_register(struct bus_type *bus ) ;
#line 75
extern void bus_unregister(struct bus_type *bus ) ;
#line 77
extern int bus_rescan_devices(struct bus_type *bus ) ;
#line 81
extern int bus_for_each_dev(struct bus_type *bus , struct device *start , void *data ,
                            int (*fn)(struct device *dev , void *data ) ) ;
#line 83
extern struct device *bus_find_device(struct bus_type *bus , struct device *start ,
                                      void *data , int (*match)(struct device *dev ,
                                                                void *data ) ) ;
#line 86
extern struct device *bus_find_device_by_name(struct bus_type *bus , struct device *start ,
                                              char const   *name ) ;
#line 90
extern int bus_for_each_drv(struct bus_type *bus , struct device_driver *start , void *data ,
                            int (*fn)(struct device_driver * , void * ) ) ;
#line 94
extern void bus_sort_breadthfirst(struct bus_type *bus , int (*compare)(struct device  const  *a ,
                                                                        struct device  const  *b ) ) ;
#line 105
extern int bus_register_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
#line 107
extern int bus_unregister_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
#line 120
extern struct kset *bus_get_kset(struct bus_type *bus ) ;
#line 121
extern struct klist *bus_get_device_klist(struct bus_type *bus ) ;
#line 143
extern int driver_register(struct device_driver *drv ) ;
#line 144
extern void driver_unregister(struct device_driver *drv ) ;
#line 146
extern struct device_driver *get_driver(struct device_driver *drv ) ;
#line 147
extern void put_driver(struct device_driver *drv ) ;
#line 148
extern struct device_driver *driver_find(char const   *name , struct bus_type *bus ) ;
#line 150
extern int driver_probe_done(void) ;
#line 151
extern void wait_for_device_probe(void) ;
#line 167
extern int driver_create_file(struct device_driver *driver , struct driver_attribute *attr ) ;
#line 169
extern void driver_remove_file(struct device_driver *driver , struct driver_attribute *attr ) ;
#line 172
extern int driver_add_kobj(struct device_driver *drv , struct kobject *kobj , char const   *fmt 
                           , ...) ;
#line 176
extern int driver_for_each_device(struct device_driver *drv , struct device *start ,
                                  void *data , int (*fn)(struct device *dev , void * ) ) ;
#line 181
extern struct device *driver_find_device(struct device_driver *drv , struct device *start ,
                                         void *data , int (*match)(struct device *dev ,
                                                                   void *data ) ) ;
#line 213
extern struct kobject *sysfs_dev_block_kobj ;
#line 214
extern struct kobject *sysfs_dev_char_kobj ;
#line 215
extern int __class_register(struct class *class , struct lock_class_key *key ) ;
#line 217
extern void class_unregister(struct class *class ) ;
#line 227
extern void class_dev_iter_init(struct class_dev_iter *iter , struct class *class ,
                                struct device *start , struct device_type  const  *type ) ;
#line 231
extern struct device *class_dev_iter_next(struct class_dev_iter *iter ) ;
#line 232
extern void class_dev_iter_exit(struct class_dev_iter *iter ) ;
#line 234
extern int class_for_each_device(struct class *class , struct device *start , void *data ,
                                 int (*fn)(struct device *dev , void *data ) ) ;
#line 237
extern struct device *class_find_device(struct class *class , struct device *start ,
                                        void *data , int (*match)(struct device * ,
                                                                  void * ) ) ;
#line 250
extern int class_create_file(struct class *class , struct class_attribute  const  *attr ) ;
#line 252
extern void class_remove_file(struct class *class , struct class_attribute  const  *attr ) ;
#line 263
extern int class_interface_register(struct class_interface * ) ;
#line 264
extern void class_interface_unregister(struct class_interface * ) ;
#line 266
extern struct class *__class_create(struct module *owner , char const   *name , struct lock_class_key *key ) ;
#line 269
extern void class_destroy(struct class *cls ) ;
#line 312
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
#line 314
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
#line 316
extern int device_create_bin_file(struct device *dev , struct bin_attribute *attr ) ;
#line 318
extern void device_remove_bin_file(struct device *dev , struct bin_attribute *attr ) ;
#line 320
extern int device_schedule_callback_owner(struct device *dev , void (*func)(struct device *dev ) ,
                                          struct module *owner ) ;
#line 332
extern void *__devres_alloc(void (*release)(struct device *dev , void *res ) , size_t size ,
                            gfp_t gfp , char const   *name ) ;
#line 339
extern void devres_free(void *res ) ;
#line 340
extern void devres_add(struct device *dev , void *res ) ;
#line 341
extern void *devres_find(struct device *dev , void (*release)(struct device *dev ,
                                                              void *res ) , int (*match)(struct device *dev ,
                                                                                         void *res ,
                                                                                         void *match_data ) ,
                         void *match_data ) ;
#line 343
extern void *devres_get(struct device *dev , void *new_res , int (*match)(struct device *dev ,
                                                                          void *res ,
                                                                          void *match_data ) ,
                        void *match_data ) ;
#line 345
extern void *devres_remove(struct device *dev , void (*release)(struct device *dev ,
                                                                void *res ) , int (*match)(struct device *dev ,
                                                                                           void *res ,
                                                                                           void *match_data ) ,
                           void *match_data ) ;
#line 347
extern int devres_destroy(struct device *dev , void (*release)(struct device *dev ,
                                                               void *res ) , int (*match)(struct device *dev ,
                                                                                          void *res ,
                                                                                          void *match_data ) ,
                          void *match_data ) ;
#line 351
extern void *devres_open_group(struct device *dev , void *id , gfp_t gfp ) ;
#line 353
extern void devres_close_group(struct device *dev , void *id ) ;
#line 354
extern void devres_remove_group(struct device *dev , void *id ) ;
#line 355
extern int devres_release_group(struct device *dev , void *id ) ;
#line 358
extern void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) ;
#line 359
extern void devm_kfree(struct device *dev , void *p ) ;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static void device_init_wakeup(struct device *dev , int val ) 
{ unsigned int tmp ;

  {
  {
#line 35
  tmp = (unsigned int )(! (! val));
#line 35
  dev->power.should_wakeup = tmp;
#line 35
  dev->power.can_wakeup = tmp;
  }
#line 36
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static void device_set_wakeup_capable(struct device *dev , int val ) 
{ 

  {
  {
#line 40
  dev->power.can_wakeup = (unsigned int )(! (! val));
  }
#line 41
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static int device_can_wakeup(struct device *dev ) 
{ 

  {
#line 45
  return ((int )dev->power.can_wakeup);
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static void device_set_wakeup_enable(struct device *dev , int val ) 
{ 

  {
  {
#line 50
  dev->power.should_wakeup = (unsigned int )(! (! val));
  }
#line 51
  return;
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static int device_may_wakeup(struct device *dev ) 
{ int tmp ;

  {
#line 55
  if (dev->power.can_wakeup) {
#line 55
    if (dev->power.should_wakeup) {
      {
#line 55
      tmp = 1;
      }
    } else {
      {
#line 55
      tmp = 0;
      }
    }
  } else {
    {
#line 55
    tmp = 0;
    }
  }
#line 55
  return (tmp);
}
}
#line 425 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ char const   *tmp ;

  {
  {
#line 427
  tmp = kobject_name(& dev->kobj);
  }
#line 427
  return (tmp);
}
}
#line 430
extern int ( /* format attribute */  dev_set_name)(struct device *dev , char const   *name 
                                                   , ...) ;
#line 443 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static int dev_to_node(struct device *dev ) 
{ 

  {
#line 445
  return (-1);
}
}
#line 447 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void set_dev_node(struct device *dev , int node ) 
{ 

  {
#line 449
  return;
}
}
#line 452 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 

  {
#line 454
  return ((void *)dev->driver_data);
}
}
#line 457 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 

  {
  {
#line 459
  dev->driver_data = data;
  }
#line 460
  return;
}
}
#line 462 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static unsigned int dev_get_uevent_suppress(struct device  const  *dev ) 
{ 

  {
#line 464
  return ((unsigned int )dev->kobj.uevent_suppress);
}
}
#line 467 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void dev_set_uevent_suppress(struct device *dev , int val ) 
{ 

  {
  {
#line 469
  dev->kobj.uevent_suppress = (unsigned int )val;
  }
#line 470
  return;
}
}
#line 472 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static int device_is_registered(struct device *dev ) 
{ 

  {
#line 474
  return ((int )dev->kobj.state_in_sysfs);
}
}
#line 477
extern void driver_init(void) ;
#line 482
extern int device_register(struct device *dev ) ;
#line 483
extern void device_unregister(struct device *dev ) ;
#line 484
extern void device_initialize(struct device *dev ) ;
#line 485
extern int device_add(struct device *dev ) ;
#line 486
extern void device_del(struct device *dev ) ;
#line 487
extern int device_for_each_child(struct device *dev , void *data , int (*fn)(struct device *dev ,
                                                                             void *data ) ) ;
#line 489
extern struct device *device_find_child(struct device *dev , void *data , int (*match)(struct device *dev ,
                                                                                       void *data ) ) ;
#line 491
extern int device_rename(struct device *dev , char *new_name ) ;
#line 492
extern int device_move(struct device *dev , struct device *new_parent , enum dpm_order dpm_order ) ;
#line 498
extern struct device *__root_device_register(char const   *name , struct module *owner ) ;
#line 500 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static struct device *root_device_register(char const   *name ) 
{ struct device *tmp ;

  {
  {
#line 502
  tmp = __root_device_register(name, (struct module *)0);
  }
#line 502
  return (tmp);
}
}
#line 504
extern void root_device_unregister(struct device *root ) ;
#line 510
extern int device_bind_driver(struct device *dev ) ;
#line 511
extern void device_release_driver(struct device *dev ) ;
#line 512
extern int device_attach(struct device *dev ) ;
#line 513
extern int driver_attach(struct device_driver *drv ) ;
#line 514
extern int device_reprobe(struct device *dev ) ;
#line 519
extern struct device *device_create_vargs(struct class *cls , struct device *parent ,
                                          dev_t devt , void *drvdata , char const   *fmt ,
                                          va_list vargs ) ;
#line 525
extern struct device *( /* format attribute */  device_create)(struct class *cls ,
                                                               struct device *parent ,
                                                               dev_t devt , void *drvdata ,
                                                               char const   *fmt 
                                                               , ...) ;
#line 529
extern void device_destroy(struct class *cls , dev_t devt ) ;
#line 537
extern int (*platform_notify)(struct device *dev ) ;
#line 539
extern int (*platform_notify_remove)(struct device *dev ) ;
#line 546
extern struct device *get_device(struct device *dev ) ;
#line 547
extern void put_device(struct device *dev ) ;
#line 552
extern void device_shutdown(void) ;
#line 555
extern void sysdev_shutdown(void) ;
#line 558
extern char const   *dev_driver_string(struct device  const  *dev ) ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int old_valid_dev(dev_t dev ) 
{ int tmp ;

  {
#line 23
  if (dev >> 20 < 256U) {
#line 23
    if ((dev & ((1U << 20) - 1U)) < 256U) {
      {
#line 23
      tmp = 1;
      }
    } else {
      {
#line 23
      tmp = 0;
      }
    }
  } else {
    {
#line 23
    tmp = 0;
    }
  }
#line 23
  return (tmp);
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u16 old_encode_dev(dev_t dev ) 
{ 

  {
#line 28
  return ((unsigned short )(((dev >> 20) << 8) | (dev & ((1U << 20) - 1U))));
}
}
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static dev_t old_decode_dev(u16 val ) 
{ 

  {
#line 33
  return ((unsigned int )(((((int )val >> 8) & 255) << 20) | ((int )val & 255)));
}
}
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int new_valid_dev(dev_t dev ) 
{ 

  {
#line 38
  return (1);
}
}
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u32 new_encode_dev(dev_t dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
#line 43
  major = dev >> 20;
#line 44
  minor = dev & ((1U << 20) - 1U);
  }
#line 45
  return (((minor & 255U) | (major << 8)) | ((minor & 4294967040U) << 12));
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static dev_t new_decode_dev(u32 dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
#line 50
  major = (dev & 1048320U) >> 8;
#line 51
  minor = (dev & 255U) | ((dev >> 12) & 1048320U);
  }
#line 52
  return ((major << 20) | minor);
}
}
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int huge_valid_dev(dev_t dev ) 
{ 

  {
#line 57
  return (1);
}
}
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u64 huge_encode_dev(dev_t dev ) 
{ u32 tmp ;

  {
  {
#line 62
  tmp = new_encode_dev(dev);
  }
#line 62
  return ((unsigned long long )tmp);
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static dev_t huge_decode_dev(u64 dev ) 
{ dev_t tmp ;

  {
  {
#line 67
  tmp = new_decode_dev((unsigned int )dev);
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int sysv_valid_dev(dev_t dev ) 
{ int tmp ;

  {
#line 72
  if (dev >> 20 < (unsigned int )(1 << 14)) {
#line 72
    if ((dev & ((1U << 20) - 1U)) < (unsigned int )(1 << 18)) {
      {
#line 72
      tmp = 1;
      }
    } else {
      {
#line 72
      tmp = 0;
      }
    }
  } else {
    {
#line 72
    tmp = 0;
    }
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u32 sysv_encode_dev(dev_t dev ) 
{ 

  {
#line 77
  return ((dev & ((1U << 20) - 1U)) | ((dev >> 20) << 18));
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static unsigned int sysv_major(u32 dev ) 
{ 

  {
#line 82
  return ((dev >> 18) & 16383U);
}
}
#line 85 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static unsigned int sysv_minor(u32 dev ) 
{ 

  {
#line 87
  return (dev & 262143U);
}
}
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void __list_add_rcu(struct list_head *new , struct list_head *prev ,
                                    struct list_head *next ) 
{ 

  {
  {
#line 21
  new->next = next;
#line 22
  new->prev = prev;
#line 23
  __asm__  volatile   ("": : : "memory");
#line 23
  prev->next = new;
#line 24
  next->prev = new;
  }
#line 25
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 45
  __list_add_rcu(new, head, head->next);
  }
#line 46
  return;
}
}
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_add_tail_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 67
  __list_add_rcu(new, head->prev, head);
  }
#line 68
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_del_rcu(struct list_head *entry ) 
{ 

  {
  {
#line 96
  __list_del(entry->prev, entry->next);
#line 97
  entry->prev = (struct list_head *)((void *)2097664);
  }
#line 98
  return;
}
}
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_del_init_rcu(struct hlist_node *n ) 
{ int tmp ;

  {
  {
#line 122
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
#line 122
  if (! tmp) {
    {
#line 123
    __hlist_del(n);
#line 124
    n->pprev = (struct hlist_node **)((void *)0);
    }
  }
#line 126
  return;
}
}
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_replace_rcu(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
#line 139
  new->next = old->next;
#line 140
  new->prev = old->prev;
#line 141
  __asm__  volatile   ("": : : "memory");
#line 141
  (new->prev)->next = new;
#line 142
  (new->next)->prev = new;
#line 143
  old->prev = (struct list_head *)((void *)2097664);
  }
#line 144
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *at ;
  int tmp ;

  {
  {
#line 167
  first = list->next;
#line 168
  last = list->prev;
#line 169
  at = head->next;
#line 171
  tmp = list_empty((struct list_head  const  *)head);
  }
#line 171
  if (tmp) {
#line 172
    return;
  }
  {
#line 176
  INIT_LIST_HEAD(list);
#line 185
  (*sync)();
#line 195
  last->next = at;
#line 196
  __asm__  volatile   ("": : : "memory");
#line 196
  head->next = first;
#line 197
  first->prev = head;
#line 198
  at->prev = last;
  }
#line 199
  return;
}
}
#line 257 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_del_rcu(struct hlist_node *n ) 
{ 

  {
  {
#line 259
  __hlist_del(n);
#line 260
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
#line 261
  return;
}
}
#line 270 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_replace_rcu(struct hlist_node *old , struct hlist_node *new ) 
{ struct hlist_node *next ;

  {
  {
#line 273
  next = old->next;
#line 275
  new->next = next;
#line 276
  new->pprev = old->pprev;
#line 277
  __asm__  volatile   ("": : : "memory");
#line 277
  *(new->pprev) = new;
  }
#line 278
  if (next) {
    {
#line 279
    (new->next)->pprev = & new->next;
    }
  }
  {
#line 280
  old->pprev = (struct hlist_node **)((void *)2097664);
  }
#line 281
  return;
}
}
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_add_head_rcu(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
#line 305
  first = h->first;
#line 307
  n->next = first;
#line 308
  n->pprev = & h->first;
#line 309
  __asm__  volatile   ("": : : "memory");
#line 309
  h->first = n;
  }
#line 310
  if (first) {
    {
#line 311
    first->pprev = & n->next;
    }
  }
#line 312
  return;
}
}
#line 332 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_add_before_rcu(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
#line 335
  n->pprev = next->pprev;
#line 336
  n->next = next;
#line 337
  __asm__  volatile   ("": : : "memory");
#line 337
  *(n->pprev) = n;
#line 338
  next->pprev = & n->next;
  }
#line 339
  return;
}
}
#line 359 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_add_after_rcu(struct hlist_node *prev , struct hlist_node *n ) 
{ 

  {
  {
#line 362
  n->next = prev->next;
#line 363
  n->pprev = & prev->next;
#line 364
  __asm__  volatile   ("": : : "memory");
#line 364
  prev->next = n;
  }
#line 365
  if (n->next) {
    {
#line 366
    (n->next)->pprev = & n->next;
    }
  }
#line 367
  return;
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
extern struct dentry_stat_t dentry_stat ;
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static unsigned long partial_name_hash(unsigned long c , unsigned long prevhash ) 
{ 

  {
#line 56
  return (((prevhash + (c << 4)) + (c >> 4)) * 11UL);
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static unsigned long end_name_hash(unsigned long hash ) 
{ 

  {
#line 65
  return ((unsigned long )((unsigned int )hash));
}
}
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static unsigned int full_name_hash(unsigned char const   *name , unsigned int len ) 
{ unsigned long hash ;
  unsigned char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 72
  hash = 0UL;
  }
  {
#line 73
  while (1) {
    while_171_continue: /* CIL Label */ ;
    {
#line 73
    tmp___0 = len;
#line 73
    len --;
    }
#line 73
    if (! tmp___0) {
      goto while_171_break;
    }
    {
#line 74
    tmp = name;
#line 74
    name ++;
#line 74
    hash = partial_name_hash((unsigned long )*tmp, hash);
    }
  }
  while_171_break: /* CIL Label */ ;
  }
  {
#line 75
  tmp___1 = end_name_hash(hash);
  }
#line 75
  return ((unsigned int )tmp___1);
}
}
#line 187
extern spinlock_t dcache_lock ;
#line 188
extern seqlock_t rename_lock ;
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static void __d_drop(struct dentry *dentry ) 
{ 

  {
#line 208
  if (! (dentry->d_flags & 16U)) {
    {
#line 209
    dentry->d_flags |= 16U;
#line 210
    hlist_del_rcu(& dentry->d_hash);
    }
  }
#line 212
  return;
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static void d_drop(struct dentry *dentry ) 
{ 

  {
  {
#line 216
  _spin_lock(& dcache_lock);
#line 217
  _spin_lock(& dentry->d_lock);
#line 218
  __d_drop(dentry);
#line 219
  _spin_unlock(& dentry->d_lock);
#line 220
  _spin_unlock(& dcache_lock);
  }
#line 221
  return;
}
}
#line 223 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static int dname_external(struct dentry *dentry ) 
{ 

  {
#line 225
  return ((unsigned long )dentry->d_name.name != (unsigned long )(dentry->d_iname));
}
}
#line 231
extern void d_instantiate(struct dentry * , struct inode * ) ;
#line 232
extern struct dentry *d_instantiate_unique(struct dentry * , struct inode * ) ;
#line 233
extern struct dentry *d_materialise_unique(struct dentry * , struct inode * ) ;
#line 234
extern void d_delete(struct dentry * ) ;
#line 237
extern struct dentry *d_alloc(struct dentry * , struct qstr  const  * ) ;
#line 238
extern struct dentry *d_splice_alias(struct inode * , struct dentry * ) ;
#line 239
extern struct dentry *d_add_ci(struct dentry * , struct inode * , struct qstr * ) ;
#line 240
extern struct dentry *d_obtain_alias(struct inode * ) ;
#line 241
extern void shrink_dcache_sb(struct super_block * ) ;
#line 242
extern void shrink_dcache_parent(struct dentry * ) ;
#line 243
extern void shrink_dcache_for_umount(struct super_block * ) ;
#line 244
extern int d_invalidate(struct dentry * ) ;
#line 247
extern struct dentry *d_alloc_root(struct inode * ) ;
#line 250
extern void d_genocide(struct dentry * ) ;
#line 252
extern struct dentry *d_find_alias(struct inode * ) ;
#line 253
extern void d_prune_aliases(struct inode * ) ;
#line 256
extern int have_submounts(struct dentry * ) ;
#line 261
extern void d_rehash(struct dentry * ) ;
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static void d_add(struct dentry *entry , struct inode *inode ) 
{ 

  {
  {
#line 274
  d_instantiate(entry, inode);
#line 275
  d_rehash(entry);
  }
#line 276
  return;
}
}
#line 286 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static struct dentry *d_add_unique(struct dentry *entry , struct inode *inode ) 
{ struct dentry *res ;
  struct dentry *tmp ;

  {
  {
#line 290
  res = d_instantiate_unique(entry, inode);
  }
#line 291
  if ((unsigned long )res != (unsigned long )((void *)0)) {
    {
#line 291
    tmp = res;
    }
  } else {
    {
#line 291
    tmp = entry;
    }
  }
  {
#line 291
  d_rehash(tmp);
  }
#line 292
  return (res);
}
}
#line 296
extern void d_move(struct dentry * , struct dentry * ) ;
#line 297
extern struct dentry *d_ancestor(struct dentry * , struct dentry * ) ;
#line 300
extern struct dentry *d_lookup(struct dentry * , struct qstr * ) ;
#line 301
extern struct dentry *__d_lookup(struct dentry * , struct qstr * ) ;
#line 302
extern struct dentry *d_hash_and_lookup(struct dentry * , struct qstr * ) ;
#line 305
extern int d_validate(struct dentry * , struct dentry * ) ;
#line 310
extern char *dynamic_dname(struct dentry * , char * , int  , char const   *  , ...) ;
#line 312
extern char *__d_path(struct path  const  *path , struct path *root , char * , int  ) ;
#line 313
extern char *d_path(struct path  const  * , char * , int  ) ;
#line 314
extern char *dentry_path(struct dentry * , char * , int  ) ;
#line 331 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static struct dentry *dget(struct dentry *dentry ) 
{ long tmp ;

  {
#line 333
  if (dentry) {
    {
#line 334
    while (1) {
      while_172_continue: /* CIL Label */ ;
      {
#line 334
      tmp = __builtin_expect((long )(! (! (! dentry->d_count.counter))), 0L);
      }
#line 334
      if (tmp) {
        {
#line 334
        while (1) {
          while_173_continue: /* CIL Label */ ;
          {
#line 334
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b, %c0\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"),
                               "i" (334), "i" (sizeof(struct bug_entry )));
          }
          {
#line 334
          while (1) {
            while_174_continue: /* CIL Label */ ;
          }
          while_174_break: /* CIL Label */ ;
          }
          goto while_173_break;
        }
        while_173_break: /* CIL Label */ ;
        }
      }
      goto while_172_break;
    }
    while_172_break: /* CIL Label */ ;
    }
    {
#line 335
    atomic_inc(& dentry->d_count);
    }
  }
#line 337
  return (dentry);
}
}
#line 340
extern struct dentry *dget_locked(struct dentry * ) ;
#line 349 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static int d_unhashed(struct dentry *dentry ) 
{ 

  {
#line 351
  return ((int )(dentry->d_flags & 16U));
}
}
#line 354 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static struct dentry *dget_parent(struct dentry *dentry ) 
{ struct dentry *ret ;

  {
  {
#line 358
  _spin_lock(& dentry->d_lock);
#line 359
  ret = dget(dentry->d_parent);
#line 360
  _spin_unlock(& dentry->d_lock);
  }
#line 361
  return (ret);
}
}
#line 364
extern void dput(struct dentry * ) ;
#line 366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static int d_mountpoint(struct dentry *dentry ) 
{ 

  {
#line 368
  return (dentry->d_mounted);
}
}
#line 371
extern struct vfsmount *lookup_mnt(struct vfsmount * , struct dentry * ) ;
#line 372
extern struct dentry *lookup_create(struct nameidata *nd , int is_dir ) ;
#line 374
extern int sysctl_vfs_cache_pressure ;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_ptr_to_indirect(void *ptr ) 
{ 

  {
#line 43
  return ((void *)((unsigned long )ptr | 1UL));
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_indirect_to_ptr(void *ptr ) 
{ 

  {
#line 48
  return ((void *)((unsigned long )ptr & 0xfffffffeUL));
}
}
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static int radix_tree_is_indirect_ptr(void *ptr ) 
{ 

  {
#line 53
  return ((int )((unsigned long )ptr & 1UL));
}
}
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_deref_slot(void **pslot ) 
{ void *ret ;
  void *_________p1 ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 139
  _________p1 = (void *)*((void * volatile  *)pslot);
  }
  {
#line 139
  while (1) {
    while_175_continue: /* CIL Label */ ;
    goto while_175_break;
  }
  while_175_break: /* CIL Label */ ;
  }
  {
#line 139
  ret = _________p1;
#line 140
  tmp = radix_tree_is_indirect_ptr(ret);
  }
#line 140
  if (tmp) {
    {
#line 140
    tmp___0 = 1;
    }
  } else {
    {
#line 140
    tmp___0 = 0;
    }
  }
  {
#line 140
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 140
  if (tmp___1) {
    {
#line 141
    ret = (void *)0xffffffffUL;
    }
  }
#line 142
  return (ret);
}
}
#line 152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void radix_tree_replace_slot(void **pslot , void *item ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 154
  while (1) {
    while_176_continue: /* CIL Label */ ;
    {
#line 154
    tmp = radix_tree_is_indirect_ptr(item);
    }
#line 154
    if (tmp) {
      {
#line 154
      tmp___0 = 1;
      }
    } else {
      {
#line 154
      tmp___0 = 0;
      }
    }
    {
#line 154
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 154
    if (tmp___1) {
      {
#line 154
      while (1) {
        while_177_continue: /* CIL Label */ ;
        {
#line 154
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"),
                             "i" (154), "i" (sizeof(struct bug_entry )));
        }
        {
#line 154
        while (1) {
          while_178_continue: /* CIL Label */ ;
        }
        while_178_break: /* CIL Label */ ;
        }
        goto while_177_break;
      }
      while_177_break: /* CIL Label */ ;
      }
    }
    goto while_176_break;
  }
  while_176_break: /* CIL Label */ ;
  }
  {
#line 155
  __asm__  volatile   ("": : : "memory");
#line 155
  *pslot = item;
  }
#line 156
  return;
}
}
#line 158
extern int radix_tree_insert(struct radix_tree_root * , unsigned long  , void * ) ;
#line 159
extern void *radix_tree_lookup(struct radix_tree_root * , unsigned long  ) ;
#line 160
extern void **radix_tree_lookup_slot(struct radix_tree_root * , unsigned long  ) ;
#line 161
extern void *radix_tree_delete(struct radix_tree_root * , unsigned long  ) ;
#line 162
extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root , void **results ,
                                           unsigned long first_index , unsigned int max_items ) ;
#line 165
extern unsigned int radix_tree_gang_lookup_slot(struct radix_tree_root *root , void ***results ,
                                                unsigned long first_index , unsigned int max_items ) ;
#line 168
extern unsigned long radix_tree_next_hole(struct radix_tree_root *root , unsigned long index ,
                                          unsigned long max_scan ) ;
#line 170
extern int radix_tree_preload(gfp_t gfp_mask ) ;
#line 171
extern void radix_tree_init(void) ;
#line 172
extern void *radix_tree_tag_set(struct radix_tree_root *root , unsigned long index ,
                                unsigned int tag ) ;
#line 174
extern void *radix_tree_tag_clear(struct radix_tree_root *root , unsigned long index ,
                                  unsigned int tag ) ;
#line 176
extern int radix_tree_tag_get(struct radix_tree_root *root , unsigned long index ,
                              unsigned int tag ) ;
#line 178
extern unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *root , void **results ,
                                               unsigned long first_index , unsigned int max_items ,
                                               unsigned int tag ) ;
#line 182
extern unsigned int radix_tree_gang_lookup_tag_slot(struct radix_tree_root *root ,
                                                    void ***results , unsigned long first_index ,
                                                    unsigned int max_items , unsigned int tag ) ;
#line 186
extern int radix_tree_tagged(struct radix_tree_root *root , unsigned int tag ) ;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void radix_tree_preload_end(void) 
{ 

  {
  {
#line 190
  while (1) {
    while_179_continue: /* CIL Label */ ;
    goto while_179_break;
  }
  while_179_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 392 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
extern void inode_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 393
extern void inode_init_early(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 394
extern void files_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 396
extern struct files_stat_struct files_stat ;
#line 397
extern int get_max_files(void) ;
#line 398
extern int sysctl_nr_open ;
#line 399
extern struct inodes_stat_t inodes_stat ;
#line 400
extern int leases_enable ;
#line 400
extern int lease_break_time ;
#line 402
extern int dir_notify_enable ;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
extern int qtree_write_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 41
extern int qtree_read_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 42
extern int qtree_delete_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 43
extern int qtree_release_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 44
extern int qtree_entry_unused(struct qtree_mem_dqinfo *info , char *disk ) ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
__inline static int qtree_depth(struct qtree_mem_dqinfo *info ) 
{ unsigned int epb ;
  unsigned long long entries ;
  int i ;

  {
  {
#line 47
  epb = info->dqi_usable_bs >> 2;
#line 48
  entries = (unsigned long long )epb;
#line 51
  i = 1;
  }
  {
#line 51
  while (1) {
    while_180_continue: /* CIL Label */ ;
#line 51
    if (! (entries < 1ULL << 32)) {
      goto while_180_break;
    }
    {
#line 52
    entries *= (unsigned long long )epb;
#line 51
    i ++;
    }
  }
  while_180_break: /* CIL Label */ ;
  }
#line 53
  return (i);
}
}
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
extern spinlock_t dq_data_lock ;
#line 233
extern void mark_info_dirty(struct super_block *sb , int type ) ;
#line 234 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
__inline static int info_dirty(struct mem_dqinfo *info ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 236
  tmp = constant_test_bit(16U, (unsigned long const volatile   *)(& info->dqi_flags));
  }
#line 236
  return (tmp);
}
}
#line 250
extern struct dqstats dqstats ;
#line 365 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
__inline static unsigned int dquot_state_flag(unsigned int flags , int type ) 
{ 

  {
#line 367
  if (type == 0) {
#line 368
    return (flags);
  }
#line 369
  return (flags << 3);
}
}
#line 372 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
__inline static unsigned int dquot_generic_flag(unsigned int flags , int type ) 
{ 

  {
#line 374
  if (type == 0) {
#line 375
    return (flags);
  }
#line 376
  return (flags >> 3);
}
}
#line 389
extern int register_quota_format(struct quota_format_type *fmt ) ;
#line 390
extern void unregister_quota_format(struct quota_format_type *fmt ) ;
#line 516 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
extern size_t iov_iter_copy_from_user_atomic(struct page *page , struct iov_iter *i ,
                                             unsigned long offset , size_t bytes ) ;
#line 518
extern size_t iov_iter_copy_from_user(struct page *page , struct iov_iter *i , unsigned long offset ,
                                      size_t bytes ) ;
#line 520
extern void iov_iter_advance(struct iov_iter *i , size_t bytes ) ;
#line 521
extern int iov_iter_fault_in_readable(struct iov_iter *i , size_t bytes ) ;
#line 522
extern size_t iov_iter_single_seg_count(struct iov_iter *i ) ;
#line 524 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void iov_iter_init(struct iov_iter *i , struct iovec  const  *iov ,
                                   unsigned long nr_segs , size_t count , size_t written ) 
{ 

  {
  {
#line 528
  i->iov = iov;
#line 529
  i->nr_segs = nr_segs;
#line 530
  i->iov_offset = 0U;
#line 531
  i->count = count + written;
#line 533
  iov_iter_advance(i, written);
  }
#line 534
  return;
}
}
#line 536 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static size_t iov_iter_count(struct iov_iter *i ) 
{ 

  {
#line 538
  return (i->count);
}
}
#line 604
extern int pagecache_write_begin(struct file * , struct address_space *mapping , loff_t pos ,
                                 unsigned int len , unsigned int flags , struct page **pagep ,
                                 void **fsdata ) ;
#line 608
extern int pagecache_write_end(struct file * , struct address_space *mapping , loff_t pos ,
                               unsigned int len , unsigned int copied , struct page *page ,
                               void *fsdata ) ;
#line 680
extern int mapping_tagged(struct address_space *mapping , int tag ) ;
#line 685 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int mapping_mapped(struct address_space *mapping ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 687
  tmp = prio_tree_empty((struct prio_tree_root  const  *)(& mapping->i_mmap));
  }
#line 687
  if (tmp) {
    {
#line 687
    tmp___0 = list_empty((struct list_head  const  *)(& mapping->i_mmap_nonlinear));
    }
#line 687
    if (tmp___0) {
      {
#line 687
      tmp___1 = 0;
      }
    } else {
      {
#line 687
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 687
    tmp___1 = 1;
    }
  }
#line 687
  return (tmp___1);
}
}
#line 697 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int mapping_writably_mapped(struct address_space *mapping ) 
{ 

  {
#line 699
  return (mapping->i_mmap_writable != 0U);
}
}
#line 810 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static loff_t i_size_read(struct inode  const  *inode ) 
{ loff_t i_size ;
  unsigned int seq ;
  int tmp ;

  {
  {
#line 816
  while (1) {
    while_181_continue: /* CIL Label */ ;
    {
#line 817
    seq = read_seqcount_begin(& inode->i_size_seqcount);
#line 818
    i_size = (long long )inode->i_size;
#line 816
    tmp = read_seqcount_retry(& inode->i_size_seqcount, seq);
    }
#line 816
    if (! tmp) {
      goto while_181_break;
    }
  }
  while_181_break: /* CIL Label */ ;
  }
#line 820
  return (i_size);
}
}
#line 838 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void i_size_write(struct inode *inode , loff_t i_size ) 
{ 

  {
  {
#line 841
  write_seqcount_begin(& inode->i_size_seqcount);
#line 842
  inode->i_size = i_size;
#line 843
  write_seqcount_end(& inode->i_size_seqcount);
  }
#line 851
  return;
}
}
#line 853 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static unsigned int iminor(struct inode  const  *inode ) 
{ 

  {
#line 855
  return ((unsigned int )(inode->i_rdev & (unsigned int const   )((1U << 20) - 1U)));
}
}
#line 858 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static unsigned int imajor(struct inode  const  *inode ) 
{ 

  {
#line 860
  return ((unsigned int )(inode->i_rdev >> 20));
}
}
#line 863
extern struct block_device *I_BDEV(struct inode *inode ) ;
#line 890 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int ra_has_index(struct file_ra_state *ra , unsigned long index ) 
{ int tmp ;

  {
#line 892
  if (index >= ra->start) {
#line 892
    if (index < ra->start + (unsigned long )ra->size) {
      {
#line 892
      tmp = 1;
      }
    } else {
      {
#line 892
      tmp = 0;
      }
    }
  } else {
    {
#line 892
    tmp = 0;
    }
  }
#line 892
  return (tmp);
}
}
#line 937
extern spinlock_t files_lock ;
#line 977 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_take_write(struct file *filp ) 
{ 

  {
#line 977
  return;
}
}
#line 978 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_release_write(struct file *filp ) 
{ 

  {
#line 978
  return;
}
}
#line 979 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_reset_write(struct file *filp ) 
{ 

  {
#line 979
  return;
}
}
#line 980 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_check_state(struct file *filp ) 
{ 

  {
#line 980
  return;
}
}
#line 981 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int file_check_writeable(struct file *filp ) 
{ 

  {
#line 983
  return (0);
}
}
#line 1040
extern void locks_start_grace(struct lock_manager * ) ;
#line 1041
extern void locks_end_grace(struct lock_manager * ) ;
#line 1042
extern int locks_in_grace(void) ;
#line 145 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
__inline static int nfs_compare_fh(struct nfs_fh  const  *a , struct nfs_fh  const  *b ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 147
  if ((int const   )a->size != (int const   )b->size) {
    {
#line 147
    tmp___0 = 1;
    }
  } else {
    {
#line 147
    tmp = __builtin_memcmp((void const   *)(a->data), (void const   *)(b->data), (unsigned int )a->size);
    }
#line 147
    if (tmp != 0) {
      {
#line 147
      tmp___0 = 1;
      }
    } else {
      {
#line 147
      tmp___0 = 0;
      }
    }
  }
#line 147
  return (tmp___0);
}
}
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
__inline static void nfs_copy_fh(struct nfs_fh *target , struct nfs_fh  const  *source ) 
{ 

  {
  {
#line 152
  target->size = (unsigned short )source->size;
#line 153
  __memcpy((void *)(target->data), (void const   *)(source->data), (unsigned int )source->size);
  }
#line 154
  return;
}
}
#line 1085 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
extern void send_sigio(struct fown_struct *fown , int fd , int band ) ;
#line 1088
extern int do_sync_mapping_range(struct address_space *mapping , loff_t offset , loff_t endbyte ,
                                 unsigned int flags ) ;
#line 1092
extern int fcntl_getlk(struct file * , struct flock * ) ;
#line 1093
extern int fcntl_setlk(unsigned int  , struct file * , unsigned int  , struct flock * ) ;
#line 1097
extern int fcntl_getlk64(struct file * , struct flock64 * ) ;
#line 1098
extern int fcntl_setlk64(unsigned int  , struct file * , unsigned int  , struct flock64 * ) ;
#line 1102
extern int fcntl_setlease(unsigned int fd , struct file *filp , long arg ) ;
#line 1103
extern int fcntl_getlease(struct file *filp ) ;
#line 1106
extern void locks_init_lock(struct file_lock * ) ;
#line 1107
extern void locks_copy_lock(struct file_lock * , struct file_lock * ) ;
#line 1108
extern void __locks_copy_lock(struct file_lock * , struct file_lock  const  * ) ;
#line 1109
extern void locks_remove_posix(struct file * , fl_owner_t  ) ;
#line 1110
extern void locks_remove_flock(struct file * ) ;
#line 1111
extern void posix_test_lock(struct file * , struct file_lock * ) ;
#line 1112
extern int posix_lock_file(struct file * , struct file_lock * , struct file_lock * ) ;
#line 1113
extern int posix_lock_file_wait(struct file * , struct file_lock * ) ;
#line 1114
extern int posix_unblock_lock(struct file * , struct file_lock * ) ;
#line 1115
extern int vfs_test_lock(struct file * , struct file_lock * ) ;
#line 1116
extern int vfs_lock_file(struct file * , unsigned int  , struct file_lock * , struct file_lock * ) ;
#line 1117
extern int vfs_cancel_lock(struct file *filp , struct file_lock *fl ) ;
#line 1118
extern int flock_lock_file_wait(struct file *filp , struct file_lock *fl ) ;
#line 1119
extern int __break_lease(struct inode *inode , unsigned int flags ) ;
#line 1120
extern void lease_get_mtime(struct inode * , struct timespec *time ) ;
#line 1121
extern int generic_setlease(struct file * , long  , struct file_lock ** ) ;
#line 1122
extern int vfs_setlease(struct file * , long  , struct file_lock ** ) ;
#line 1123
extern int lease_modify(struct file_lock ** , int  ) ;
#line 1124
extern int lock_may_read(struct inode * , loff_t start , unsigned long count ) ;
#line 1125
extern int lock_may_write(struct inode * , loff_t start , unsigned long count ) ;
#line 1281
extern int fasync_helper(int  , struct file * , int  , struct fasync_struct ** ) ;
#line 1283
extern void kill_fasync(struct fasync_struct ** , int  , int  ) ;
#line 1285
extern void __kill_fasync(struct fasync_struct * , int  , int  ) ;
#line 1287
extern int __f_setown(struct file *filp , struct pid * , enum pid_type  , int force ) ;
#line 1288
extern int f_setown(struct file *filp , unsigned long arg , int force ) ;
#line 1289
extern void f_delown(struct file *filp ) ;
#line 1290
extern pid_t f_getown(struct file *filp ) ;
#line 1291
extern int send_sigurg(struct fown_struct *fown ) ;
#line 1301
extern struct list_head super_blocks ;
#line 1302
extern spinlock_t sb_lock ;
#line 1382
extern struct timespec current_fs_time(struct super_block *sb ) ;
#line 1404
extern void lock_super(struct super_block * ) ;
#line 1405
extern void unlock_super(struct super_block * ) ;
#line 1410
extern int vfs_create(struct inode * , struct dentry * , int  , struct nameidata * ) ;
#line 1411
extern int vfs_mkdir(struct inode * , struct dentry * , int  ) ;
#line 1412
extern int vfs_mknod(struct inode * , struct dentry * , int  , dev_t  ) ;
#line 1413
extern int vfs_symlink(struct inode * , struct dentry * , char const   * ) ;
#line 1414
extern int vfs_link(struct dentry * , struct inode * , struct dentry * ) ;
#line 1415
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
#line 1416
extern int vfs_unlink(struct inode * , struct dentry * ) ;
#line 1417
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
#line 1422
extern void dentry_unhash(struct dentry *dentry ) ;
#line 1427
extern int file_permission(struct file * , int  ) ;
#line 1439
extern int fiemap_fill_next_extent(struct fiemap_extent_info *info , u64 logical ,
                                   u64 phys , u64 len , u32 flags ) ;
#line 1441
extern int fiemap_check_flags(struct fiemap_extent_info *fieinfo , u32 fs_flags ) ;
#line 1462
extern int generic_osync_inode(struct inode * , struct address_space * , int  ) ;
#line 1544
extern ssize_t rw_copy_check_uvector(int type , struct iovec  const  *uvector , unsigned long nr_segs ,
                                     unsigned long fast_segs , struct iovec *fast_pointer ,
                                     struct iovec **ret_pointer ) ;
#line 1549
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1550
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
#line 1551
extern ssize_t vfs_readv(struct file * , struct iovec  const  * , unsigned long  ,
                         loff_t * ) ;
#line 1553
extern ssize_t vfs_writev(struct file * , struct iovec  const  * , unsigned long  ,
                          loff_t * ) ;
#line 1650
extern void __mark_inode_dirty(struct inode * , int  ) ;
#line 1651 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void mark_inode_dirty(struct inode *inode ) 
{ 

  {
  {
#line 1653
  __mark_inode_dirty(inode, 7);
  }
#line 1654
  return;
}
}
#line 1656 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void mark_inode_dirty_sync(struct inode *inode ) 
{ 

  {
  {
#line 1658
  __mark_inode_dirty(inode, 1);
  }
#line 1659
  return;
}
}
#line 1669 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inc_nlink(struct inode *inode ) 
{ 

  {
  {
#line 1671
  (inode->i_nlink) ++;
  }
#line 1672
  return;
}
}
#line 1674 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inode_inc_link_count(struct inode *inode ) 
{ 

  {
  {
#line 1676
  inc_nlink(inode);
#line 1677
  mark_inode_dirty(inode);
  }
#line 1678
  return;
}
}
#line 1691 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void drop_nlink(struct inode *inode ) 
{ 

  {
  {
#line 1693
  (inode->i_nlink) --;
  }
#line 1694
  return;
}
}
#line 1704 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void clear_nlink(struct inode *inode ) 
{ 

  {
  {
#line 1706
  inode->i_nlink = 0U;
  }
#line 1707
  return;
}
}
#line 1709 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inode_dec_link_count(struct inode *inode ) 
{ 

  {
  {
#line 1711
  drop_nlink(inode);
#line 1712
  mark_inode_dirty(inode);
  }
#line 1713
  return;
}
}
#line 1723 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inode_inc_iversion(struct inode *inode ) 
{ 

  {
  {
#line 1725
  _spin_lock(& inode->i_lock);
#line 1726
  (inode->i_version) ++;
#line 1727
  _spin_unlock(& inode->i_lock);
  }
#line 1728
  return;
}
}
#line 1730
extern void touch_atime(struct vfsmount *mnt , struct dentry *dentry ) ;
#line 1731 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_accessed(struct file *file ) 
{ 

  {
#line 1733
  if (! (file->f_flags & 262144U)) {
    {
#line 1734
    touch_atime(file->f_path.mnt, file->f_path.dentry);
    }
  }
#line 1735
  return;
}
}
#line 1737
extern int sync_inode(struct inode *inode , struct writeback_control *wbc ) ;
#line 1758
extern int get_sb_ns(struct file_system_type *fs_type , int flags , void *data , int (*fill_super)(struct super_block * ,
                                                                                                   void * ,
                                                                                                   int  ) ,
                     struct vfsmount *mnt ) ;
#line 1761
extern int get_sb_bdev(struct file_system_type *fs_type , int flags , char const   *dev_name ,
                       void *data , int (*fill_super)(struct super_block * , void * ,
                                                      int  ) , struct vfsmount *mnt ) ;
#line 1765
extern int get_sb_single(struct file_system_type *fs_type , int flags , void *data ,
                         int (*fill_super)(struct super_block * , void * , int  ) ,
                         struct vfsmount *mnt ) ;
#line 1769
extern int get_sb_nodev(struct file_system_type *fs_type , int flags , void *data ,
                        int (*fill_super)(struct super_block * , void * , int  ) ,
                        struct vfsmount *mnt ) ;
#line 1773
extern void generic_shutdown_super(struct super_block *sb ) ;
#line 1774
extern void kill_block_super(struct super_block *sb ) ;
#line 1775
extern void kill_anon_super(struct super_block *sb ) ;
#line 1776
extern void kill_litter_super(struct super_block *sb ) ;
#line 1777
extern void deactivate_super(struct super_block *sb ) ;
#line 1778
extern void deactivate_locked_super(struct super_block *sb ) ;
#line 1779
extern int set_anon_super(struct super_block *s , void *data ) ;
#line 1780
extern struct super_block *sget(struct file_system_type *type , int (*test)(struct super_block * ,
                                                                            void * ) ,
                                int (*set)(struct super_block * , void * ) , void *data ) ;
#line 1784
extern int get_sb_pseudo(struct file_system_type * , char * , struct super_operations  const  *ops ,
                         unsigned long  , struct vfsmount *mnt ) ;
#line 1787
extern void simple_set_mnt(struct vfsmount *mnt , struct super_block *sb ) ;
#line 1788
extern int __put_super_and_need_restart(struct super_block *sb ) ;
#line 1796
extern int register_filesystem(struct file_system_type * ) ;
#line 1797
extern int unregister_filesystem(struct file_system_type * ) ;
#line 1798
extern struct vfsmount *kern_mount_data(struct file_system_type * , void *data ) ;
#line 1800
extern int may_umount_tree(struct vfsmount * ) ;
#line 1801
extern int may_umount(struct vfsmount * ) ;
#line 1802
extern long do_mount(char * , char * , char * , unsigned long  , void * ) ;
#line 1803
extern struct vfsmount *collect_mounts(struct vfsmount * , struct dentry * ) ;
#line 1804
extern void drop_collected_mounts(struct vfsmount * ) ;
#line 1806
extern int vfs_statfs(struct dentry * , struct kstatfs * ) ;
#line 1808
extern int current_umask(void) ;
#line 1811
extern struct kobject *fs_kobj ;
#line 1813
extern int rw_verify_area(int  , struct file * , loff_t * , size_t  ) ;
#line 1819
extern int locks_mandatory_locked(struct inode * ) ;
#line 1820
extern int locks_mandatory_area(int  , struct inode * , struct file * , loff_t  ,
                                size_t  ) ;
#line 1827 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int __mandatory_lock(struct inode *ino ) 
{ 

  {
#line 1829
  return (((int )ino->i_mode & 1032) == 1024);
}
}
#line 1837 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int mandatory_lock(struct inode *ino ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1839
  if ((ino->i_sb)->s_flags & 64UL) {
    {
#line 1839
    tmp = __mandatory_lock(ino);
    }
#line 1839
    if (tmp) {
      {
#line 1839
      tmp___0 = 1;
      }
    } else {
      {
#line 1839
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 1839
    tmp___0 = 0;
    }
  }
#line 1839
  return (tmp___0);
}
}
#line 1842 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int locks_verify_locked(struct inode *inode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 1844
  tmp___0 = mandatory_lock(inode);
  }
#line 1844
  if (tmp___0) {
    {
#line 1845
    tmp = locks_mandatory_locked(inode);
    }
#line 1845
    return (tmp);
  }
#line 1846
  return (0);
}
}
#line 1849 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int locks_verify_truncate(struct inode *inode , struct file *filp ,
                                          loff_t size ) 
{ loff_t tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1853
  if (inode->i_flock) {
    {
#line 1853
    tmp___2 = mandatory_lock(inode);
    }
#line 1853
    if (tmp___2) {
#line 1854
      if (size < inode->i_size) {
        {
#line 1854
        tmp = inode->i_size - size;
        }
      } else {
        {
#line 1854
        tmp = size - inode->i_size;
        }
      }
#line 1854
      if (size < inode->i_size) {
        {
#line 1854
        tmp___0 = size;
        }
      } else {
        {
#line 1854
        tmp___0 = inode->i_size;
        }
      }
      {
#line 1854
      tmp___1 = locks_mandatory_area(2, inode, filp, tmp___0, (unsigned int )tmp);
      }
#line 1854
      return (tmp___1);
    }
  }
#line 1860
  return (0);
}
}
#line 1863 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int break_lease(struct inode *inode , unsigned int mode ) 
{ int tmp ;

  {
#line 1865
  if (inode->i_flock) {
    {
#line 1866
    tmp = __break_lease(inode, mode);
    }
#line 1866
    return (tmp);
  }
#line 1867
  return (0);
}
}
#line 1912
extern int do_truncate(struct dentry * , loff_t start , unsigned int time_attrs ,
                       struct file *filp ) ;
#line 1914
extern long do_sys_open(int dfd , char const   *filename , int flags , int mode ) ;
#line 1916
extern struct file *filp_open(char const   * , int  , int  ) ;
#line 1917
extern struct file *dentry_open(struct dentry * , struct vfsmount * , int  , struct cred  const  * ) ;
#line 1919
extern int filp_close(struct file * , fl_owner_t id ) ;
#line 1920
extern char *getname(char const   * ) ;
#line 1923
extern void vfs_caches_init_early(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1924
extern void vfs_caches_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1926
extern struct kmem_cache *names_cachep ;
#line 1933
extern void putname(char const   *name ) ;
#line 1937
extern int register_blkdev(unsigned int  , char const   * ) ;
#line 1938
extern void unregister_blkdev(unsigned int  , char const   * ) ;
#line 1939
extern struct block_device *bdget(dev_t  ) ;
#line 1940
extern void bd_set_size(struct block_device * , loff_t size ) ;
#line 1941
extern void bd_forget(struct inode *inode ) ;
#line 1942
extern void bdput(struct block_device * ) ;
#line 1943
extern struct block_device *open_by_devnum(dev_t  , fmode_t  ) ;
#line 1944
extern void invalidate_bdev(struct block_device * ) ;
#line 1945
extern int sync_blockdev(struct block_device *bdev ) ;
#line 1946
extern struct super_block *freeze_bdev(struct block_device * ) ;
#line 1947
extern void emergency_thaw_all(void) ;
#line 1948
extern int thaw_bdev(struct block_device *bdev , struct super_block *sb ) ;
#line 1949
extern int fsync_bdev(struct block_device * ) ;
#line 1950
extern int fsync_super(struct super_block * ) ;
#line 1951
extern int fsync_no_super(struct block_device * ) ;
#line 1967
extern struct file_operations  const  def_blk_fops ;
#line 1968
extern struct file_operations  const  def_chr_fops ;
#line 1969
extern struct file_operations  const  bad_sock_fops ;
#line 1970
extern struct file_operations  const  def_fifo_fops ;
#line 1972
extern int ioctl_by_bdev(struct block_device * , unsigned int  , unsigned long  ) ;
#line 1973
extern int blkdev_ioctl(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
#line 1974
extern long compat_blkdev_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1975
extern int blkdev_get(struct block_device * , fmode_t  ) ;
#line 1976
extern int blkdev_put(struct block_device * , fmode_t  ) ;
#line 1977
extern int bd_claim(struct block_device * , void * ) ;
#line 1978
extern void bd_release(struct block_device * ) ;
#line 1980
extern int bd_claim_by_disk(struct block_device * , void * , struct gendisk * ) ;
#line 1981
extern void bd_release_from_disk(struct block_device * , struct gendisk * ) ;
#line 1990
extern int alloc_chrdev_region(dev_t * , unsigned int  , unsigned int  , char const   * ) ;
#line 1991
extern int register_chrdev_region(dev_t  , unsigned int  , char const   * ) ;
#line 1992
extern int register_chrdev(unsigned int  , char const   * , struct file_operations  const  * ) ;
#line 1994
extern void unregister_chrdev(unsigned int  , char const   * ) ;
#line 1995
extern void unregister_chrdev_region(dev_t  , unsigned int  ) ;
#line 1996
extern void chrdev_show(struct seq_file * , off_t  ) ;
#line 2004
extern char const   *__bdevname(dev_t  , char *buffer ) ;
#line 2005
extern char const   *bdevname(struct block_device *bdev , char *buffer ) ;
#line 2006
extern struct block_device *lookup_bdev(char const   * ) ;
#line 2007
extern struct block_device *open_bdev_exclusive(char const   * , fmode_t  , void * ) ;
#line 2008
extern void close_bdev_exclusive(struct block_device * , fmode_t  ) ;
#line 2009
extern void blkdev_show(struct seq_file * , off_t  ) ;
#line 2015
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
#line 2018
extern void make_bad_inode(struct inode * ) ;
#line 2019
extern int is_bad_inode(struct inode * ) ;
#line 2021
extern struct file_operations  const  read_pipefifo_fops ;
#line 2022
extern struct file_operations  const  write_pipefifo_fops ;
#line 2023
extern struct file_operations  const  rdwr_pipefifo_fops ;
#line 2025
extern int fs_may_remount_ro(struct super_block * ) ;
#line 2038
extern void check_disk_size_change(struct gendisk *disk , struct block_device *bdev ) ;
#line 2040
extern int revalidate_disk(struct gendisk * ) ;
#line 2041
extern int check_disk_change(struct block_device * ) ;
#line 2042
extern int __invalidate_device(struct block_device * ) ;
#line 2043
extern int invalidate_partition(struct gendisk * , int  ) ;
#line 2045
extern int invalidate_inodes(struct super_block * ) ;
#line 2046
extern unsigned long __invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                                unsigned long end , bool be_atomic ) ;
#line 2049
extern unsigned long invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                              unsigned long end ) ;
#line 2052 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static unsigned long invalidate_inode_pages(struct address_space *mapping ) 
{ unsigned long tmp ;

  {
  {
#line 2055
  tmp = invalidate_mapping_pages(mapping, 0UL, ~ 0UL);
  }
#line 2055
  return (tmp);
}
}
#line 2058 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void invalidate_remote_inode(struct inode *inode ) 
{ 

  {
#line 2060
  if (((int )inode->i_mode & 61440) == 32768) {
    {
#line 2062
    invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
    }
  } else {
#line 2060
    if (((int )inode->i_mode & 61440) == 16384) {
      {
#line 2062
      invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
      }
    } else {
#line 2060
      if (((int )inode->i_mode & 61440) == 40960) {
        {
#line 2062
        invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
        }
      }
    }
  }
#line 2063
  return;
}
}
#line 2064
extern int invalidate_inode_pages2(struct address_space *mapping ) ;
#line 2065
extern int invalidate_inode_pages2_range(struct address_space *mapping , unsigned long start ,
                                         unsigned long end ) ;
#line 2067
extern void generic_sync_sb_inodes(struct super_block *sb , struct writeback_control *wbc ) ;
#line 2069
extern int write_inode_now(struct inode * , int  ) ;
#line 2070
extern int filemap_fdatawrite(struct address_space * ) ;
#line 2071
extern int filemap_flush(struct address_space * ) ;
#line 2072
extern int filemap_fdatawait(struct address_space * ) ;
#line 2073
extern int filemap_write_and_wait(struct address_space *mapping ) ;
#line 2074
extern int filemap_write_and_wait_range(struct address_space *mapping , loff_t lstart ,
                                        loff_t lend ) ;
#line 2076
extern int wait_on_page_writeback_range(struct address_space *mapping , unsigned long start ,
                                        unsigned long end ) ;
#line 2078
extern int __filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                      loff_t end , int sync_mode ) ;
#line 2080
extern int filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                    loff_t end ) ;
#line 2083
extern int vfs_fsync(struct file *file , struct dentry *dentry , int datasync ) ;
#line 2084
extern void sync_supers(void) ;
#line 2085
extern void sync_filesystems(int wait ) ;
#line 2086
extern void __fsync_super(struct super_block *sb ) ;
#line 2087
extern void emergency_sync(void) ;
#line 2088
extern void emergency_remount(void) ;
#line 2089
extern int do_remount_sb(struct super_block *sb , int flags , void *data , int force ) ;
#line 2092
extern sector_t bmap(struct inode * , sector_t  ) ;
#line 2094
extern int notify_change(struct dentry * , struct iattr * ) ;
#line 2095
extern int inode_permission(struct inode * , int  ) ;
#line 2096
extern int generic_permission(struct inode * , int  , int (*check_acl)(struct inode * ,
                                                                       int  ) ) ;
#line 2099 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static bool execute_ok(struct inode *inode ) 
{ int tmp ;

  {
#line 2101
  if ((int )inode->i_mode & 73) {
    {
#line 2101
    tmp = 1;
    }
  } else {
#line 2101
    if (((int )inode->i_mode & 61440) == 16384) {
      {
#line 2101
      tmp = 1;
      }
    } else {
      {
#line 2101
      tmp = 0;
      }
    }
  }
#line 2101
  return ((_Bool )tmp);
}
}
#line 2104
extern int get_write_access(struct inode * ) ;
#line 2105
extern int deny_write_access(struct file * ) ;
#line 2106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void put_write_access(struct inode *inode ) 
{ 

  {
  {
#line 2108
  atomic_dec(& inode->i_writecount);
  }
#line 2109
  return;
}
}
#line 2110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void allow_write_access(struct file *file ) 
{ 

  {
#line 2112
  if (file) {
    {
#line 2113
    atomic_inc(& ((file->f_path.dentry)->d_inode)->i_writecount);
    }
  }
#line 2114
  return;
}
}
#line 2115
extern int do_pipe_flags(int * , int  ) ;
#line 2116
extern struct file *create_read_pipe(struct file *f , int flags ) ;
#line 2117
extern struct file *create_write_pipe(int flags ) ;
#line 2118
extern void free_write_pipe(struct file * ) ;
#line 2120
extern struct file *do_filp_open(int dfd , char const   *pathname , int open_flag ,
                                 int mode , int acc_mode ) ;
#line 2122
extern int may_open(struct path * , int  , int  ) ;
#line 2124
extern int kernel_read(struct file * , loff_t  , char * , unsigned long  ) ;
#line 2125
extern struct file *open_exec(char const   * ) ;
#line 2128
extern int is_subdir(struct dentry * , struct dentry * ) ;
#line 2129
extern ino_t find_inode_number(struct dentry * , struct qstr * ) ;
#line 2134
extern loff_t default_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2136
extern loff_t vfs_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2138
extern int inode_init_always(struct super_block * , struct inode * ) ;
#line 2139
extern void inode_init_once(struct inode * ) ;
#line 2140
extern void inode_add_to_lists(struct super_block * , struct inode * ) ;
#line 2141
extern void iput(struct inode * ) ;
#line 2142
extern struct inode *igrab(struct inode * ) ;
#line 2143
extern ino_t iunique(struct super_block * , ino_t  ) ;
#line 2144
extern int inode_needs_sync(struct inode *inode ) ;
#line 2145
extern void generic_delete_inode(struct inode *inode ) ;
#line 2146
extern void generic_drop_inode(struct inode *inode ) ;
#line 2148
extern struct inode *ilookup5_nowait(struct super_block *sb , unsigned long hashval ,
                                     int (*test)(struct inode * , void * ) , void *data ) ;
#line 2151
extern struct inode *ilookup5(struct super_block *sb , unsigned long hashval , int (*test)(struct inode * ,
                                                                                           void * ) ,
                              void *data ) ;
#line 2153
extern struct inode *ilookup(struct super_block *sb , unsigned long ino ) ;
#line 2155
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*test)(struct inode * ,
                                                                                      void * ) ,
                                  int (*set)(struct inode * , void * ) , void * ) ;
#line 2156
extern struct inode *iget_locked(struct super_block * , unsigned long  ) ;
#line 2157
extern int insert_inode_locked4(struct inode * , unsigned long  , int (*test)(struct inode * ,
                                                                              void * ) ,
                                void * ) ;
#line 2158
extern int insert_inode_locked(struct inode * ) ;
#line 2159
extern void unlock_new_inode(struct inode * ) ;
#line 2161
extern void __iget(struct inode *inode ) ;
#line 2162
extern void iget_failed(struct inode * ) ;
#line 2163
extern void clear_inode(struct inode * ) ;
#line 2164
extern void destroy_inode(struct inode * ) ;
#line 2165
extern void __destroy_inode(struct inode * ) ;
#line 2166
extern struct inode *new_inode(struct super_block * ) ;
#line 2167
extern int should_remove_suid(struct dentry * ) ;
#line 2168
extern int file_remove_suid(struct file * ) ;
#line 2170
extern void __insert_inode_hash(struct inode * , unsigned long hashval ) ;
#line 2171
extern void remove_inode_hash(struct inode * ) ;
#line 2172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void insert_inode_hash(struct inode *inode ) 
{ 

  {
  {
#line 2173
  __insert_inode_hash(inode, inode->i_ino);
  }
#line 2174
  return;
}
}
#line 2176
extern struct file *get_empty_filp(void) ;
#line 2177
extern void file_move(struct file *f , struct list_head *list ) ;
#line 2178
extern void file_kill(struct file *f ) ;
#line 2181
extern void submit_bio(int  , struct bio * ) ;
#line 2182
extern int bdev_read_only(struct block_device * ) ;
#line 2184
extern int set_blocksize(struct block_device * , int  ) ;
#line 2185
extern int sb_set_blocksize(struct super_block * , int  ) ;
#line 2186
extern int sb_min_blocksize(struct super_block * , int  ) ;
#line 2187
extern int sb_has_dirty_inodes(struct super_block * ) ;
#line 2189
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
#line 2190
extern int generic_file_readonly_mmap(struct file * , struct vm_area_struct * ) ;
#line 2191
extern int file_read_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
#line 2192
extern int generic_write_checks(struct file *file , loff_t *pos , size_t *count ,
                                int isblk ) ;
#line 2193
extern ssize_t generic_file_aio_read(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                     loff_t  ) ;
#line 2194
extern ssize_t generic_file_aio_write(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                      loff_t  ) ;
#line 2195
extern ssize_t generic_file_aio_write_nolock(struct kiocb * , struct iovec  const  * ,
                                             unsigned long  , loff_t  ) ;
#line 2197
extern ssize_t generic_file_direct_write(struct kiocb * , struct iovec  const  * ,
                                         unsigned long * , loff_t  , loff_t * , size_t  ,
                                         size_t  ) ;
#line 2199
extern ssize_t generic_file_buffered_write(struct kiocb * , struct iovec  const  * ,
                                           unsigned long  , loff_t  , loff_t * , size_t  ,
                                           ssize_t  ) ;
#line 2201
extern ssize_t do_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
#line 2202
extern ssize_t do_sync_write(struct file *filp , char const   *buf , size_t len ,
                             loff_t *ppos ) ;
#line 2203
extern int generic_segment_checks(struct iovec  const  *iov , unsigned long *nr_segs ,
                                  size_t *count , int access_flags ) ;
#line 2207
extern ssize_t generic_file_splice_read(struct file * , loff_t * , struct pipe_inode_info * ,
                                        size_t  , unsigned int  ) ;
#line 2209
extern ssize_t generic_file_splice_write(struct pipe_inode_info * , struct file * ,
                                         loff_t * , size_t  , unsigned int  ) ;
#line 2211
extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe , struct file *out ,
                                       loff_t * , size_t len , unsigned int flags ) ;
#line 2213
extern long do_splice_direct(struct file *in , loff_t *ppos , struct file *out , size_t len ,
                             unsigned int flags ) ;
#line 2216
extern void file_ra_state_init(struct file_ra_state *ra , struct address_space *mapping ) ;
#line 2218
extern loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2219
extern loff_t generic_file_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2220
extern loff_t generic_file_llseek_unlocked(struct file *file , loff_t offset , int origin ) ;
#line 2222
extern int generic_file_open(struct inode *inode , struct file *filp ) ;
#line 2223
extern int nonseekable_open(struct inode *inode , struct file *filp ) ;
#line 2233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int xip_truncate_page(struct address_space *mapping , loff_t from ) 
{ 

  {
#line 2235
  return (0);
}
}
#line 2240
extern ssize_t __blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                    struct block_device *bdev , struct iovec  const  *iov ,
                                    loff_t offset , unsigned long nr_segs , get_block_t *get_block ,
                                    dio_iodone_t *end_io , int lock_type ) ;
#line 2251 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ssize_t blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                           struct block_device *bdev , struct iovec  const  *iov ,
                                           loff_t offset , unsigned long nr_segs ,
                                           get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
#line 2256
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 1);
  }
#line 2256
  return (tmp);
}
}
#line 2260 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ssize_t blockdev_direct_IO_no_locking(int rw , struct kiocb *iocb ,
                                                      struct inode *inode , struct block_device *bdev ,
                                                      struct iovec  const  *iov ,
                                                      loff_t offset , unsigned long nr_segs ,
                                                      get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
#line 2265
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 2);
  }
#line 2265
  return (tmp);
}
}
#line 2269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ssize_t blockdev_direct_IO_own_locking(int rw , struct kiocb *iocb ,
                                                       struct inode *inode , struct block_device *bdev ,
                                                       struct iovec  const  *iov ,
                                                       loff_t offset , unsigned long nr_segs ,
                                                       get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
#line 2274
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 3);
  }
#line 2274
  return (tmp);
}
}
#line 2279
extern struct file_operations  const  generic_ro_fops ;
#line 2283
extern int vfs_readlink(struct dentry * , char * , int  , char const   * ) ;
#line 2284
extern int vfs_follow_link(struct nameidata * , char const   * ) ;
#line 2285
extern int page_readlink(struct dentry * , char * , int  ) ;
#line 2286
extern void *page_follow_link_light(struct dentry * , struct nameidata * ) ;
#line 2287
extern void page_put_link(struct dentry * , struct nameidata * , void * ) ;
#line 2288
extern int __page_symlink(struct inode *inode , char const   *symname , int len ,
                          int nofs ) ;
#line 2290
extern int page_symlink(struct inode *inode , char const   *symname , int len ) ;
#line 2291
extern struct inode_operations  const  page_symlink_inode_operations ;
#line 2292
extern int generic_readlink(struct dentry * , char * , int  ) ;
#line 2293
extern void generic_fillattr(struct inode * , struct kstat * ) ;
#line 2294
extern int vfs_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
#line 2295
extern void inode_add_bytes(struct inode *inode , loff_t bytes ) ;
#line 2296
extern void inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
#line 2297
extern loff_t inode_get_bytes(struct inode *inode ) ;
#line 2298
extern void inode_set_bytes(struct inode *inode , loff_t bytes ) ;
#line 2300
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               u64  , unsigned int  ) , void * ) ;
#line 2302
extern int vfs_stat(char * , struct kstat * ) ;
#line 2303
extern int vfs_lstat(char * , struct kstat * ) ;
#line 2304
extern int vfs_fstat(unsigned int  , struct kstat * ) ;
#line 2305
extern int vfs_fstatat(int  , char * , struct kstat * , int  ) ;
#line 2307
extern int do_vfs_ioctl(struct file *filp , unsigned int fd , unsigned int cmd , unsigned long arg ) ;
#line 2309
extern int __generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                  u64 start , u64 len , get_block_t *get_block ) ;
#line 2312
extern int generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                u64 start , u64 len , get_block_t *get_block ) ;
#line 2316
extern void get_filesystem(struct file_system_type *fs ) ;
#line 2317
extern void put_filesystem(struct file_system_type *fs ) ;
#line 2318
extern struct file_system_type *get_fs_type(char const   *name ) ;
#line 2319
extern struct super_block *get_super(struct block_device * ) ;
#line 2320
extern struct super_block *user_get_super(dev_t  ) ;
#line 2321
extern void drop_super(struct super_block *sb ) ;
#line 2323
extern int dcache_dir_open(struct inode * , struct file * ) ;
#line 2324
extern int dcache_dir_close(struct inode * , struct file * ) ;
#line 2325
extern loff_t dcache_dir_lseek(struct file * , loff_t  , int  ) ;
#line 2326
extern int dcache_readdir(struct file * , void * , int (*)(void * , char const   * ,
                                                           int  , loff_t  , u64  ,
                                                           unsigned int  ) ) ;
#line 2327
extern int simple_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
#line 2328
extern int simple_statfs(struct dentry * , struct kstatfs * ) ;
#line 2329
extern int simple_link(struct dentry * , struct inode * , struct dentry * ) ;
#line 2330
extern int simple_unlink(struct inode * , struct dentry * ) ;
#line 2331
extern int simple_rmdir(struct inode * , struct dentry * ) ;
#line 2332
extern int simple_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
#line 2333
extern int simple_sync_file(struct file * , struct dentry * , int  ) ;
#line 2334
extern int simple_empty(struct dentry * ) ;
#line 2335
extern int simple_readpage(struct file *file , struct page *page ) ;
#line 2336
extern int simple_prepare_write(struct file *file , struct page *page , unsigned int offset ,
                                unsigned int to ) ;
#line 2338
extern int simple_write_begin(struct file *file , struct address_space *mapping ,
                              loff_t pos , unsigned int len , unsigned int flags ,
                              struct page **pagep , void **fsdata ) ;
#line 2341
extern int simple_write_end(struct file *file , struct address_space *mapping , loff_t pos ,
                            unsigned int len , unsigned int copied , struct page *page ,
                            void *fsdata ) ;
#line 2345
extern struct dentry *simple_lookup(struct inode * , struct dentry * , struct nameidata * ) ;
#line 2346
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
#line 2347
extern struct file_operations  const  simple_dir_operations ;
#line 2348
extern struct inode_operations  const  simple_dir_inode_operations ;
#line 2350
extern struct dentry *d_alloc_name(struct dentry * , char const   * ) ;
#line 2351
extern int simple_fill_super(struct super_block * , int  , struct tree_descr * ) ;
#line 2352
extern int simple_pin_fs(struct file_system_type * , struct vfsmount **mount , int *count ) ;
#line 2353
extern void simple_release_fs(struct vfsmount **mount , int *count ) ;
#line 2355
extern ssize_t simple_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
#line 2365
extern int inode_change_ok(struct inode * , struct iattr * ) ;
#line 2366
extern int inode_setattr(struct inode * , struct iattr * ) ;
#line 2368
extern void file_update_time(struct file *file ) ;
#line 2370
extern int generic_show_options(struct seq_file *m , struct vfsmount *mnt ) ;
#line 2371
extern void save_mount_options(struct super_block *sb , char *options ) ;
#line 2372
extern void replace_mount_options(struct super_block *sb , char *options ) ;
#line 2374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ino_t parent_ino(struct dentry *dentry ) 
{ ino_t res ;

  {
  {
#line 2378
  _spin_lock(& dentry->d_lock);
#line 2379
  res = ((dentry->d_parent)->d_inode)->i_ino;
#line 2380
  _spin_unlock(& dentry->d_lock);
  }
#line 2381
  return (res);
}
}
#line 2397
extern char *simple_transaction_get(struct file *file , char const   *buf , size_t size ) ;
#line 2399
extern ssize_t simple_transaction_read(struct file *file , char *buf , size_t size ,
                                       loff_t *pos ) ;
#line 2401
extern int simple_transaction_release(struct inode *inode , struct file *file ) ;
#line 2403
extern void simple_transaction_set(struct file *file , size_t n ) ;
#line 2435 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void ( /* format attribute */  __simple_attr_check_format)(char const   *fmt 
                                                                           , ...) 
{ 

  {
#line 2439
  return;
}
}
#line 2441
extern int simple_attr_open(struct inode *inode , struct file *file , int (*get)(void * ,
                                                                                 u64 * ) ,
                            int (*set)(void * , u64  ) , char const   *fmt ) ;
#line 2444
extern int simple_attr_release(struct inode *inode , struct file *file ) ;
#line 2445
extern ssize_t simple_attr_read(struct file *file , char *buf , size_t len , loff_t *ppos ) ;
#line 2447
extern ssize_t simple_attr_write(struct file *file , char const   *buf , size_t len ,
                                 loff_t *ppos ) ;
#line 2451
extern int proc_nr_files(struct ctl_table *table , int write , struct file *filp ,
                         void *buffer , size_t *lenp , loff_t *ppos ) ;
#line 2454
extern int get_filesystem_list(char *buf )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ void *tmp ;

  {
  {
#line 191
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
  }
#line 191
  return (tmp);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 

  {
  {
#line 196
  dev_set_drvdata(& intf->dev, data);
  }
#line 197
  return;
}
}
#line 199
extern struct usb_interface *usb_get_intf(struct usb_interface *intf ) ;
#line 200
extern void usb_put_intf(struct usb_interface *intf ) ;
#line 293
extern int __usb_get_extra_descriptor(char *buffer , unsigned int size , unsigned char type ,
                                      void **ptr ) ;
#line 509
extern struct usb_device *usb_get_dev(struct usb_device *dev ) ;
#line 510
extern void usb_put_dev(struct usb_device *dev ) ;
#line 516
extern int usb_lock_device_for_reset(struct usb_device *udev , struct usb_interface  const  *iface ) ;
#line 520
extern int usb_reset_device(struct usb_device *dev ) ;
#line 521
extern void usb_queue_reset_device(struct usb_interface *dev ) ;
#line 523
extern struct usb_device *usb_find_device(u16 vendor_id , u16 product_id ) ;
#line 527
extern int usb_autopm_set_interface(struct usb_interface *intf ) ;
#line 528
extern int usb_autopm_get_interface(struct usb_interface *intf ) ;
#line 529
extern void usb_autopm_put_interface(struct usb_interface *intf ) ;
#line 530
extern int usb_autopm_get_interface_async(struct usb_interface *intf ) ;
#line 531
extern void usb_autopm_put_interface_async(struct usb_interface *intf ) ;
#line 533 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_autopm_enable(struct usb_interface *intf ) 
{ 

  {
  {
#line 535
  intf->pm_usage_cnt = 0;
#line 536
  usb_autopm_set_interface(intf);
  }
#line 537
  return;
}
}
#line 539 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_autopm_disable(struct usb_interface *intf ) 
{ 

  {
  {
#line 541
  intf->pm_usage_cnt = 1;
#line 542
  usb_autopm_set_interface(intf);
  }
#line 543
  return;
}
}
#line 545 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_mark_last_busy(struct usb_device *udev ) 
{ 

  {
  {
#line 547
  udev->last_busy = (unsigned long )jiffies;
  }
#line 548
  return;
}
}
#line 576
extern int usb_get_current_frame_number(struct usb_device *usb_dev ) ;
#line 579
extern int usb_driver_claim_interface(struct usb_driver *driver , struct usb_interface *iface ,
                                      void *priv ) ;
#line 592 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_interface_claimed(struct usb_interface *iface ) 
{ 

  {
#line 594
  return ((unsigned long )iface->dev.driver != (unsigned long )((void *)0));
}
}
#line 597
extern void usb_driver_release_interface(struct usb_driver *driver , struct usb_interface *iface ) ;
#line 599
extern struct usb_device_id  const  *usb_match_id(struct usb_interface *interface ,
                                                  struct usb_device_id  const  *id ) ;
#line 601
extern int usb_match_one_id(struct usb_interface *interface , struct usb_device_id  const  *id ) ;
#line 604
extern struct usb_interface *usb_find_interface(struct usb_driver *drv , int minor ) ;
#line 606
extern struct usb_interface *usb_ifnum_to_if(struct usb_device  const  *dev , unsigned int ifnum ) ;
#line 608
extern struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface  const  *intf ,
                                                           unsigned int altnum ) ;
#line 636 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ int actual ;
  int tmp ;

  {
  {
#line 639
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, dev->devpath);
  }
#line 641
  if (actual >= (int )size) {
    {
#line 641
    tmp = -1;
    }
  } else {
    {
#line 641
    tmp = actual;
    }
  }
#line 641
  return (tmp);
}
}
#line 772
extern ssize_t usb_store_new_id(struct usb_dynids *dynids , struct device_driver *driver ,
                                char const   *buf , size_t count ) ;
#line 901
extern struct bus_type usb_bus_type ;
#line 923
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 925 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_register(struct usb_driver *driver ) 
{ int tmp ;

  {
  {
#line 927
  tmp = usb_register_driver(driver, (struct module *)0, "SomeModule");
  }
#line 927
  return (tmp);
}
}
#line 929
extern void usb_deregister(struct usb_driver * ) ;
#line 931
extern int usb_register_device_driver(struct usb_device_driver * , struct module * ) ;
#line 933
extern void usb_deregister_device_driver(struct usb_device_driver * ) ;
#line 935
extern int usb_register_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) ;
#line 937
extern void usb_deregister_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) ;
#line 940
extern int usb_disabled(void) ;
#line 988 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
static struct lock_class_key __key___1  ;
#line 984 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void init_usb_anchor(struct usb_anchor *anchor ) 
{ 

  {
  {
#line 986
  INIT_LIST_HEAD(& anchor->urb_list);
#line 987
  init_waitqueue_head(& anchor->wait);
  }
  {
#line 988
  while (1) {
    while_182_continue: /* CIL Label */ ;
    {
#line 988
    __spin_lock_init(& anchor->lock, "&anchor->lock", & __key___1);
    }
    goto while_182_break;
  }
  while_182_break: /* CIL Label */ ;
  }
#line 989
  return;
}
}
#line 1211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_fill_control_urb(struct urb *urb , struct usb_device *dev ,
                                          unsigned int pipe , unsigned char *setup_packet ,
                                          void *transfer_buffer , int buffer_length ,
                                          void (*complete_fn)(struct urb * ) , void *context ) 
{ 

  {
  {
#line 1220
  urb->dev = dev;
#line 1221
  urb->pipe = pipe;
#line 1222
  urb->setup_packet = setup_packet;
#line 1223
  urb->transfer_buffer = transfer_buffer;
#line 1224
  urb->transfer_buffer_length = (unsigned int )buffer_length;
#line 1225
  urb->complete = complete_fn;
#line 1226
  urb->context = context;
  }
#line 1227
  return;
}
}
#line 1242 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 

  {
  {
#line 1250
  urb->dev = dev;
#line 1251
  urb->pipe = pipe;
#line 1252
  urb->transfer_buffer = transfer_buffer;
#line 1253
  urb->transfer_buffer_length = (unsigned int )buffer_length;
#line 1254
  urb->complete = complete_fn;
#line 1255
  urb->context = context;
  }
#line 1256
  return;
}
}
#line 1276 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval ) 
{ 

  {
  {
#line 1285
  urb->dev = dev;
#line 1286
  urb->pipe = pipe;
#line 1287
  urb->transfer_buffer = transfer_buffer;
#line 1288
  urb->transfer_buffer_length = (unsigned int )buffer_length;
#line 1289
  urb->complete = complete_fn;
#line 1290
  urb->context = context;
  }
#line 1291
  if ((unsigned int )dev->speed == 3U) {
    {
#line 1292
    urb->interval = 1 << (interval - 1);
    }
  } else {
    {
#line 1294
    urb->interval = interval;
    }
  }
  {
#line 1295
  urb->start_frame = -1;
  }
#line 1296
  return;
}
}
#line 1298
extern void usb_init_urb(struct urb *urb ) ;
#line 1299
extern struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) ;
#line 1300
extern void usb_free_urb(struct urb *urb ) ;
#line 1302
extern struct urb *usb_get_urb(struct urb *urb ) ;
#line 1303
extern int usb_submit_urb(struct urb *urb , gfp_t mem_flags ) ;
#line 1304
extern int usb_unlink_urb(struct urb *urb ) ;
#line 1305
extern void usb_kill_urb(struct urb *urb ) ;
#line 1306
extern void usb_poison_urb(struct urb *urb ) ;
#line 1307
extern void usb_unpoison_urb(struct urb *urb ) ;
#line 1308
extern void usb_kill_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1309
extern void usb_poison_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1310
extern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1311
extern void usb_unlink_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1312
extern void usb_anchor_urb(struct urb *urb , struct usb_anchor *anchor ) ;
#line 1313
extern void usb_unanchor_urb(struct urb *urb ) ;
#line 1314
extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor , unsigned int timeout ) ;
#line 1316
extern struct urb *usb_get_from_anchor(struct usb_anchor *anchor ) ;
#line 1317
extern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1318
extern int usb_anchor_empty(struct usb_anchor *anchor ) ;
#line 1327 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_urb_dir_in(struct urb *urb ) 
{ 

  {
#line 1329
  return ((urb->transfer_flags & 512U) == 512U);
}
}
#line 1339 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_urb_dir_out(struct urb *urb ) 
{ 

  {
#line 1341
  return ((urb->transfer_flags & 512U) == 0U);
}
}
#line 1344
extern void *usb_buffer_alloc(struct usb_device *dev , size_t size , gfp_t mem_flags ,
                              dma_addr_t *dma ) ;
#line 1346
extern void usb_buffer_free(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) ;
#line 1356
extern int usb_buffer_map_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                             int nents ) ;
#line 1362
extern void usb_buffer_unmap_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                                int n_hw_ents ) ;
#line 1369
extern int usb_control_msg(struct usb_device *dev , unsigned int pipe , __u8 request ,
                           __u8 requesttype , __u16 value , __u16 index , void *data ,
                           __u16 size , int timeout ) ;
#line 1372
extern int usb_interrupt_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                             int len , int *actual_length , int timeout ) ;
#line 1374
extern int usb_bulk_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                        int len , int *actual_length , int timeout ) ;
#line 1379
extern int usb_get_descriptor(struct usb_device *dev , unsigned char desctype , unsigned char descindex ,
                              void *buf , int size ) ;
#line 1381
extern int usb_get_status(struct usb_device *dev , int type , int target , void *data ) ;
#line 1383
extern int usb_string(struct usb_device *dev , int index , char *buf , size_t size ) ;
#line 1387
extern int usb_clear_halt(struct usb_device *dev , int pipe ) ;
#line 1388
extern int usb_reset_configuration(struct usb_device *dev ) ;
#line 1389
extern int usb_set_interface(struct usb_device *dev , int ifnum , int alternate ) ;
#line 1390
extern void usb_reset_endpoint(struct usb_device *dev , unsigned int epaddr ) ;
#line 1393
extern int usb_driver_set_configuration(struct usb_device *udev , int config ) ;
#line 1443
extern int usb_sg_init(struct usb_sg_request *io , struct usb_device *dev , unsigned int pipe ,
                       unsigned int period , struct scatterlist *sg , int nents ,
                       size_t length , gfp_t mem_flags ) ;
#line 1453
extern void usb_sg_cancel(struct usb_sg_request *io ) ;
#line 1454
extern void usb_sg_wait(struct usb_sg_request *io ) ;
#line 1495 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 

  {
#line 1498
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 1521 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static __u16 usb_maxpacket(struct usb_device *udev , int pipe , int is_out ) 
{ struct usb_host_endpoint *ep ;
  unsigned int epnum ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  {
#line 1525
  epnum = (unsigned int )((pipe >> 15) & 15);
  }
#line 1527
  if (is_out) {
    {
#line 1528
    __ret_warn_on = ! (! (pipe & 128));
#line 1528
    tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 1528
    if (tmp) {
      {
#line 1528
      warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h",
                         1528);
      }
    }
    {
#line 1528
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 1529
    ep = udev->ep_out[epnum];
    }
  } else {
    {
#line 1531
    __ret_warn_on___0 = ! (! (! (pipe & 128)));
#line 1531
    tmp___0 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
#line 1531
    if (tmp___0) {
      {
#line 1531
      warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h",
                         1531);
      }
    }
    {
#line 1531
    __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
#line 1532
    ep = udev->ep_in[epnum];
    }
  }
#line 1534
  if (! ep) {
#line 1535
    return ((unsigned short)0);
  }
#line 1538
  return (ep->desc.wMaxPacketSize);
}
}
#line 1548
extern void usb_register_notify(struct notifier_block *nb ) ;
#line 1549
extern void usb_unregister_notify(struct notifier_block *nb ) ;
#line 31 "usb-skeleton.c"
static struct usb_device_id skel_table[1]  = {      {(__u16 )3, (__u16 )65520, (__u16 )65520, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, 0UL}};
#line 67
static struct usb_driver skel_driver ;
#line 68
static void skel_draw_down(struct usb_skel *dev ) ;
#line 70 "usb-skeleton.c"
static void skel_delete(struct kref *kref ) 
{ struct usb_skel *dev ;
  struct kref  const  *__mptr ;

  {
  {
#line 72
  __mptr = (struct kref  const  *)kref;
#line 72
  dev = (struct usb_skel *)((char *)__mptr - (unsigned int )(& ((struct usb_skel *)0)->kref));
#line 74
  usb_put_dev(dev->udev);
#line 75
  kfree((void const   *)dev->bulk_in_buffer);
#line 76
  kfree((void const   *)dev);
  }
#line 77
  return;
}
}
#line 79 "usb-skeleton.c"
static int skel_open(struct inode *inode , struct file *file ) 
{ struct usb_skel *dev ;
  struct usb_interface *interface ;
  int subminor ;
  int retval ;
  unsigned int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  retval = 0;
#line 86
  tmp = iminor((struct inode  const  *)inode);
#line 86
  subminor = (int )tmp;
#line 88
  interface = usb_find_interface(& skel_driver, subminor);
  }
#line 89
  if (! interface) {
    {
#line 90
    printk("<3>SomeModule: %s - error, can\'t find device for minor %d\n", "skel_open",
           subminor);
#line 92
    retval = -19;
    }
    goto exit;
  }
  {
#line 96
  tmp___0 = usb_get_intfdata(interface);
#line 96
  dev = (struct usb_skel *)tmp___0;
  }
#line 97
  if (! dev) {
    {
#line 98
    retval = -19;
    }
    goto exit;
  }
  {
#line 103
  kref_get(& dev->kref);
#line 107
  mutex_lock(& dev->io_mutex);
#line 109
  tmp___1 = dev->open_count;
#line 109
  (dev->open_count) ++;
  }
#line 109
  if (! tmp___1) {
    {
#line 110
    retval = usb_autopm_get_interface(interface);
    }
#line 111
    if (retval) {
      {
#line 112
      (dev->open_count) --;
#line 113
      mutex_unlock(& dev->io_mutex);
#line 114
      kref_put(& dev->kref, & skel_delete);
      }
      goto exit;
    }
  }
  {
#line 127
  file->private_data = (void *)dev;
#line 128
  mutex_unlock(& dev->io_mutex);
  }
  exit: 
#line 131
  return (retval);
}
}
#line 134 "usb-skeleton.c"
static int skel_release(struct inode *inode , struct file *file ) 
{ struct usb_skel *dev ;

  {
  {
#line 138
  dev = (struct usb_skel *)file->private_data;
  }
#line 139
  if ((unsigned long )dev == (unsigned long )((void *)0)) {
#line 140
    return (-19);
  }
  {
#line 143
  mutex_lock(& dev->io_mutex);
#line 144
  (dev->open_count) --;
  }
#line 144
  if (! dev->open_count) {
#line 144
    if (dev->interface) {
      {
#line 145
      usb_autopm_put_interface(dev->interface);
      }
    }
  }
  {
#line 146
  mutex_unlock(& dev->io_mutex);
#line 149
  kref_put(& dev->kref, & skel_delete);
  }
#line 150
  return (0);
}
}
#line 153 "usb-skeleton.c"
static int skel_flush(struct file *file , fl_owner_t id ) 
{ struct usb_skel *dev ;
  int res ;
  int tmp ;

  {
  {
#line 158
  dev = (struct usb_skel *)file->private_data;
  }
#line 159
  if ((unsigned long )dev == (unsigned long )((void *)0)) {
#line 160
    return (-19);
  }
  {
#line 163
  mutex_lock(& dev->io_mutex);
#line 164
  skel_draw_down(dev);
#line 167
  _spin_lock_irq(& dev->err_lock);
  }
#line 168
  if (dev->errors) {
#line 168
    if (dev->errors == -32) {
      {
#line 168
      tmp = -32;
      }
    } else {
      {
#line 168
      tmp = -5;
      }
    }
    {
#line 168
    res = tmp;
    }
  } else {
    {
#line 168
    res = 0;
    }
  }
  {
#line 169
  dev->errors = 0;
#line 170
  _spin_unlock_irq(& dev->err_lock);
#line 172
  mutex_unlock(& dev->io_mutex);
  }
#line 174
  return (res);
}
}
#line 177 "usb-skeleton.c"
static ssize_t skel_read(struct file *file , char *buffer , size_t count , loff_t *ppos ) 
{ struct usb_skel *dev ;
  int retval ;
  int bytes_read ;
  size_t _min1 ;
  size_t _min2 ;
  size_t tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 183
  dev = (struct usb_skel *)file->private_data;
#line 185
  mutex_lock(& dev->io_mutex);
  }
#line 186
  if (! dev->interface) {
    {
#line 187
    retval = -19;
    }
    goto exit;
  }
  {
#line 195
  _min1 = dev->bulk_in_size;
#line 195
  _min2 = count;
  }
#line 195
  if (_min1 < _min2) {
    {
#line 195
    tmp = _min1;
    }
  } else {
    {
#line 195
    tmp = _min2;
    }
  }
  {
#line 195
  tmp___0 = __create_pipe(dev->udev, (unsigned int )dev->bulk_in_endpointAddr);
#line 195
  retval = usb_bulk_msg(dev->udev, ((unsigned int )(3 << 30) | tmp___0) | 128U, (void *)dev->bulk_in_buffer,
                        (int )tmp, & bytes_read, 10000);
  }
#line 199
  if (! retval) {
    {
#line 200
    tmp___1 = copy_to_user((void *)buffer, (void const   *)dev->bulk_in_buffer, (unsigned long )bytes_read);
    }
#line 200
    if (tmp___1) {
      {
#line 201
      retval = -14;
      }
    } else {
      {
#line 203
      retval = bytes_read;
      }
    }
  }
  exit: 
  {
#line 207
  mutex_unlock(& dev->io_mutex);
  }
#line 208
  return (retval);
}
}
#line 211 "usb-skeleton.c"
static void skel_write_bulk_callback(struct urb *urb ) 
{ struct usb_skel *dev ;

  {
  {
#line 215
  dev = (struct usb_skel *)urb->context;
  }
#line 218
  if (urb->status) {
#line 219
    if (! (urb->status == -2)) {
#line 219
      if (! (urb->status == -104)) {
#line 219
        if (! (urb->status == -108)) {
          {
#line 222
          printk("<3>SomeModule: %s - nonzero write bulk status received: %d\n", "skel_write_bulk_callback",
                 urb->status);
          }
        }
      }
    }
    {
#line 225
    _spin_lock(& dev->err_lock);
#line 226
    dev->errors = urb->status;
#line 227
    _spin_unlock(& dev->err_lock);
    }
  }
  {
#line 231
  usb_buffer_free(urb->dev, urb->transfer_buffer_length, urb->transfer_buffer, urb->transfer_dma);
#line 233
  up(& dev->limit_sem);
  }
#line 234
  return;
}
}
#line 236 "usb-skeleton.c"
static ssize_t skel_write(struct file *file , char const   *user_buffer , size_t count ,
                          loff_t *ppos ) 
{ struct usb_skel *dev ;
  int retval ;
  struct urb *urb ;
  char *buf ;
  size_t writesize ;
  size_t _min1 ;
  unsigned int _min2 ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 239
  retval = 0;
#line 240
  urb = (struct urb *)((void *)0);
#line 241
  buf = (char *)((void *)0);
#line 242
  _min1 = count;
#line 242
  _min2 = (unsigned int )((1UL << 12) - 512UL);
  }
#line 242
  if (_min1 < _min2) {
    {
#line 242
    tmp = _min1;
    }
  } else {
    {
#line 242
    tmp = _min2;
    }
  }
  {
#line 242
  writesize = tmp;
#line 244
  dev = (struct usb_skel *)file->private_data;
  }
#line 247
  if (count == 0U) {
    goto exit;
  }
  {
#line 251
  tmp___0 = down_interruptible(& dev->limit_sem);
  }
#line 251
  if (tmp___0) {
    {
#line 252
    retval = -512;
    }
    goto exit;
  }
  {
#line 256
  _spin_lock_irq(& dev->err_lock);
#line 257
  retval = dev->errors;
  }
#line 257
  if (retval < 0) {
    {
#line 259
    dev->errors = 0;
    }
#line 261
    if (retval == -32) {
      {
#line 261
      retval = retval;
      }
    } else {
      {
#line 261
      retval = -5;
      }
    }
  }
  {
#line 263
  _spin_unlock_irq(& dev->err_lock);
  }
#line 264
  if (retval < 0) {
    goto error;
  }
  {
#line 268
  urb = usb_alloc_urb(0, 208U);
  }
#line 269
  if (! urb) {
    {
#line 270
    retval = -12;
    }
    goto error;
  }
  {
#line 274
  tmp___1 = usb_buffer_alloc(dev->udev, writesize, 208U, & urb->transfer_dma);
#line 274
  buf = (char *)tmp___1;
  }
#line 275
  if (! buf) {
    {
#line 276
    retval = -12;
    }
    goto error;
  }
  {
#line 280
  tmp___2 = copy_from_user((void *)buf, (void const   *)user_buffer, (unsigned long )writesize);
  }
#line 280
  if (tmp___2) {
    {
#line 281
    retval = -14;
    }
    goto error;
  }
  {
#line 286
  mutex_lock(& dev->io_mutex);
  }
#line 287
  if (! dev->interface) {
    {
#line 288
    mutex_unlock(& dev->io_mutex);
#line 289
    retval = -19;
    }
    goto error;
  }
  {
#line 294
  tmp___3 = __create_pipe(dev->udev, (unsigned int )dev->bulk_out_endpointAddr);
#line 294
  usb_fill_bulk_urb(urb, dev->udev, (unsigned int )(3 << 30) | tmp___3, (void *)buf,
                    (int )writesize, & skel_write_bulk_callback, (void *)dev);
#line 297
  urb->transfer_flags |= 4U;
#line 298
  usb_anchor_urb(urb, & dev->submitted);
#line 301
  retval = usb_submit_urb(urb, 208U);
#line 302
  mutex_unlock(& dev->io_mutex);
  }
#line 303
  if (retval) {
    {
#line 304
    printk("<3>SomeModule: %s - failed submitting write urb, error %d\n", "skel_write",
           retval);
    }
    goto error_unanchor;
  }
  {
#line 309
  usb_free_urb(urb);
  }
#line 312
  return ((int )writesize);
  error_unanchor: 
  {
#line 315
  usb_unanchor_urb(urb);
  }
  error: 
#line 317
  if (urb) {
    {
#line 318
    usb_buffer_free(dev->udev, writesize, (void *)buf, urb->transfer_dma);
#line 319
    usb_free_urb(urb);
    }
  }
  {
#line 321
  up(& dev->limit_sem);
  }
  exit: 
#line 324
  return (retval);
}
}
#line 327 "usb-skeleton.c"
static struct file_operations  const  skel_fops  = 
#line 327
     {(struct module *)0, (loff_t (*)(struct file * , loff_t  , int  ))0, & skel_read,
    & skel_write, (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                               loff_t  ))0, (ssize_t (*)(struct kiocb * , struct iovec  const  * ,
                                                         unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, (unsigned int (*)(struct file * ,
                                                                                            struct poll_table_struct * ))0,
    (int (*)(struct inode * , struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct file * , struct vm_area_struct * ))0, & skel_open, & skel_flush,
    & skel_release, (int (*)(struct file * , struct dentry * , int datasync ))0, (int (*)(struct kiocb * ,
                                                                                          int datasync ))0,
    (int (*)(int  , struct file * , int  ))0, (int (*)(struct file * , int  , struct file_lock * ))0,
    (ssize_t (*)(struct file * , struct page * , int  , size_t  , loff_t * , int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0};
#line 340 "usb-skeleton.c"
static struct usb_class_driver skel_class  =    {(char *)"skel%d", & skel_fops, 192};
#line 363 "usb-skeleton.c"
static struct lock_class_key __key___2  ;
#line 364 "usb-skeleton.c"
static struct lock_class_key __key___3  ;
#line 346 "usb-skeleton.c"
static int skel_probe(struct usb_interface *interface , struct usb_device_id  const  *id ) 
{ struct usb_skel *dev ;
  struct usb_host_interface *iface_desc ;
  struct usb_endpoint_descriptor *endpoint ;
  size_t buffer_size ;
  int i ;
  int retval ;
  void *tmp ;
  struct device  const  *__mptr ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 353
  retval = -12;
#line 356
  tmp = kzalloc((unsigned int )sizeof(*dev), 208U);
#line 356
  dev = (struct usb_skel *)tmp;
  }
#line 357
  if (! dev) {
    {
#line 358
    printk("<3>SomeModule: Out of memory\n");
    }
    goto error;
  }
  {
#line 361
  kref_init(& dev->kref);
#line 362
  sema_init(& dev->limit_sem, 8);
  }
  {
#line 363
  while (1) {
    while_183_continue: /* CIL Label */ ;
    {
#line 363
    __mutex_init(& dev->io_mutex, "&dev->io_mutex", & __key___2);
    }
    goto while_183_break;
  }
  while_183_break: /* CIL Label */ ;
  }
  {
#line 364
  while (1) {
    while_184_continue: /* CIL Label */ ;
    {
#line 364
    __spin_lock_init(& dev->err_lock, "&dev->err_lock", & __key___3);
    }
    goto while_184_break;
  }
  while_184_break: /* CIL Label */ ;
  }
  {
#line 365
  init_usb_anchor(& dev->submitted);
#line 367
  __mptr = (struct device  const  *)interface->dev.parent;
#line 367
  dev->udev = usb_get_dev((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)));
#line 368
  dev->interface = interface;
#line 372
  iface_desc = interface->cur_altsetting;
#line 373
  i = 0;
  }
  {
#line 373
  while (1) {
    while_185_continue: /* CIL Label */ ;
#line 373
    if (! (i < (int )iface_desc->desc.bNumEndpoints)) {
      goto while_185_break;
    }
    {
#line 374
    endpoint = & (iface_desc->endpoint + i)->desc;
    }
#line 376
    if (! dev->bulk_in_endpointAddr) {
      {
#line 376
      tmp___1 = usb_endpoint_is_bulk_in((struct usb_endpoint_descriptor  const  *)endpoint);
      }
#line 376
      if (tmp___1) {
        {
#line 379
        buffer_size = (unsigned int )endpoint->wMaxPacketSize;
#line 380
        dev->bulk_in_size = buffer_size;
#line 381
        dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
#line 382
        tmp___0 = kmalloc(buffer_size, 208U);
#line 382
        dev->bulk_in_buffer = (unsigned char *)tmp___0;
        }
#line 383
        if (! dev->bulk_in_buffer) {
          {
#line 384
          printk("<3>SomeModule: Could not allocate bulk_in_buffer\n");
          }
          goto error;
        }
      }
    }
#line 389
    if (! dev->bulk_out_endpointAddr) {
      {
#line 389
      tmp___2 = usb_endpoint_is_bulk_out((struct usb_endpoint_descriptor  const  *)endpoint);
      }
#line 389
      if (tmp___2) {
        {
#line 392
        dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
        }
      }
    }
    {
#line 373
    i ++;
    }
  }
  while_185_break: /* CIL Label */ ;
  }
#line 395
  if (dev->bulk_in_endpointAddr) {
#line 395
    if (! dev->bulk_out_endpointAddr) {
      {
#line 396
      printk("<3>SomeModule: Could not find both bulk-in and bulk-out endpoints\n");
      }
      goto error;
    }
  } else {
    {
#line 396
    printk("<3>SomeModule: Could not find both bulk-in and bulk-out endpoints\n");
    }
    goto error;
  }
  {
#line 401
  usb_set_intfdata(interface, (void *)dev);
#line 404
  retval = usb_register_dev(interface, & skel_class);
  }
#line 405
  if (retval) {
    {
#line 407
    printk("<3>SomeModule: Not able to get a minor for this device.\n");
#line 408
    usb_set_intfdata(interface, (void *)0);
    }
    goto error;
  }
  {
#line 413
  tmp___3 = dev_name((struct device  const  *)(& interface->dev));
#line 413
  tmp___4 = dev_driver_string((struct device  const  *)(& interface->dev));
#line 413
  printk("<6>%s %s: USB Skeleton device now attached to USBSkel-%d", tmp___4, tmp___3,
         interface->minor);
  }
#line 416
  return (0);
  error: 
#line 419
  if (dev) {
    {
#line 421
    kref_put(& dev->kref, & skel_delete);
    }
  }
#line 422
  return (retval);
}
}
#line 425 "usb-skeleton.c"
static void skel_disconnect(struct usb_interface *interface ) 
{ struct usb_skel *dev ;
  int minor ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 428
  minor = interface->minor;
#line 430
  tmp = usb_get_intfdata(interface);
#line 430
  dev = (struct usb_skel *)tmp;
#line 431
  usb_set_intfdata(interface, (void *)0);
#line 434
  usb_deregister_dev(interface, & skel_class);
#line 437
  mutex_lock(& dev->io_mutex);
#line 438
  dev->interface = (struct usb_interface *)((void *)0);
#line 439
  mutex_unlock(& dev->io_mutex);
#line 441
  usb_kill_anchored_urbs(& dev->submitted);
#line 444
  kref_put(& dev->kref, & skel_delete);
#line 446
  tmp___0 = dev_name((struct device  const  *)(& interface->dev));
#line 446
  tmp___1 = dev_driver_string((struct device  const  *)(& interface->dev));
#line 446
  printk("<6>%s %s: USB Skeleton #%d now disconnected", tmp___1, tmp___0, minor);
  }
#line 447
  return;
}
}
#line 449 "usb-skeleton.c"
static void skel_draw_down(struct usb_skel *dev ) 
{ int time ;

  {
  {
#line 453
  time = usb_wait_anchor_empty_timeout(& dev->submitted, 1000U);
  }
#line 454
  if (! time) {
    {
#line 455
    usb_kill_anchored_urbs(& dev->submitted);
    }
  }
#line 456
  return;
}
}
#line 458 "usb-skeleton.c"
static int skel_suspend(struct usb_interface *intf , pm_message_t message ) 
{ struct usb_skel *dev ;
  void *tmp ;

  {
  {
#line 460
  tmp = usb_get_intfdata(intf);
#line 460
  dev = (struct usb_skel *)tmp;
  }
#line 462
  if (! dev) {
#line 463
    return (0);
  }
  {
#line 464
  skel_draw_down(dev);
  }
#line 465
  return (0);
}
}
#line 468 "usb-skeleton.c"
static int skel_resume(struct usb_interface *intf ) 
{ 

  {
#line 470
  return (0);
}
}
#line 473 "usb-skeleton.c"
static int skel_pre_reset(struct usb_interface *intf ) 
{ struct usb_skel *dev ;
  void *tmp ;

  {
  {
#line 475
  tmp = usb_get_intfdata(intf);
#line 475
  dev = (struct usb_skel *)tmp;
#line 477
  mutex_lock(& dev->io_mutex);
#line 478
  skel_draw_down(dev);
  }
#line 480
  return (0);
}
}
#line 483 "usb-skeleton.c"
static int skel_post_reset(struct usb_interface *intf ) 
{ struct usb_skel *dev ;
  void *tmp ;

  {
  {
#line 485
  tmp = usb_get_intfdata(intf);
#line 485
  dev = (struct usb_skel *)tmp;
#line 488
  dev->errors = -32;
#line 489
  mutex_unlock(& dev->io_mutex);
  }
#line 491
  return (0);
}
}
#line 494 "usb-skeleton.c"
static struct usb_driver skel_driver  = 
#line 494
     {"skeleton", & skel_probe, & skel_disconnect, (int (*)(struct usb_interface *intf ,
                                                          unsigned int code , void *buf ))0,
    & skel_suspend, & skel_resume, (int (*)(struct usb_interface *intf ))0, & skel_pre_reset,
    & skel_post_reset, (struct usb_device_id  const  *)(skel_table), {{{0U}, 0U, 0U,
                                                                       (void *)0},
                                                                      {(struct list_head *)0,
                                                                       (struct list_head *)0}},
    {{(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
      (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
      (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
      (struct attribute_group **)0, (struct dev_pm_ops *)0, (struct driver_private *)0},
     0}, 0U, 1U, 0U};
#line 506
static int usb_skel_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 506 "usb-skeleton.c"
static int usb_skel_init(void) 
{ int result ;

  {
  {
#line 511
  result = usb_register(& skel_driver);
  }
#line 512
  if (result) {
    {
#line 513
    printk("<3>SomeModule: usb_register failed. Error number %d\n", result);
    }
  }
#line 515
  return (result);
}
}
#line 518
static void usb_skel_exit(void)  __attribute__((__section__(".exit.text"))) ;
#line 518 "usb-skeleton.c"
static void usb_skel_exit(void) 
{ 

  {
  {
#line 521
  usb_deregister(& skel_driver);
  }
#line 522
  return;
}
}
#line 524 "usb-skeleton.c"
static int (*__initcall_usb_skel_init6)(void)  __attribute__((__section__(".initcall6.init")))  =    & usb_skel_init;
#line 525 "usb-skeleton.c"
static void (*__exitcall_usb_skel_exit)(void)  __attribute__((__section__(".exitcall.exit")))  =    & usb_skel_exit;
