/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
struct __anonstruct____missing_field_name_2 {
   unsigned long miss ;
   unsigned long hit ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
struct __anonstruct____missing_field_name_3 {
   unsigned long correct ;
   unsigned long incorrect ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
union __anonunion____missing_field_name_1 {
   struct __anonstruct____missing_field_name_3 __annonCompField2 ;
   struct __anonstruct____missing_field_name_2 __annonCompField1 ;
   unsigned long miss_hit[2] ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/compiler.h"
struct ftrace_branch_data {
   char const   *func ;
   char const   *file ;
   unsigned int line ;
   union __anonunion____missing_field_name_1 __annonCompField3 ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/stddef.h"
enum __anonenum_4 {
    false = 0,
    true = 1
} ;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef short s16;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef int s32;
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/types.h"
typedef unsigned short umode_t;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/types.h"
typedef u64 dma64_addr_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/types.h"
typedef u32 dma_addr_t;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
struct __anonstruct___kernel_fd_set_5 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef struct __anonstruct___kernel_fd_set_5 __kernel_fd_set;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned long __kernel_ino_t;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_nlink_t;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_off_t;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_pid_t;
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_ipc_pid_t;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_uid_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_gid_t;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_size_t;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_ssize_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_ptrdiff_t;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_time_t;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_suseconds_t;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long __kernel_clock_t;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_timer_t;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_clockid_t;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef int __kernel_daddr_t;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef char *__kernel_caddr_t;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_uid16_t;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_gid16_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_uid32_t;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned int __kernel_gid32_t;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_old_uid_t;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_old_gid_t;
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef unsigned short __kernel_old_dev_t;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef long long __kernel_loff_t;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
struct __anonstruct___kernel_fsid_t_6 {
   int val[2] ;
};
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/posix_types_32.h"
typedef struct __anonstruct___kernel_fsid_t_6 __kernel_fsid_t;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_fd_set fd_set;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_daddr_t daddr_t;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_key_t key_t;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_suseconds_t suseconds_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_timer_t timer_t;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_mqd_t mqd_t;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef _Bool bool;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_uid16_t uid16_t;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_gid16_t gid16_t;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long uintptr_t;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_old_uid_t old_uid_t;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_old_gid_t old_gid_t;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_ptrdiff_t ptrdiff_t;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_clock_t clock_t;
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __kernel_caddr_t caddr_t;
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned char u_char;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned short u_short;
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int u_int;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long u_long;
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned char unchar;
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned short ushort;
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int uint;
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long ulong;
#line 102 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u8 u_int8_t;
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s8 int8_t;
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 u_int16_t;
#line 105 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s16 int16_t;
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 u_int32_t;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s32 int32_t;
#line 111 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u8 uint8_t;
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 uint16_t;
#line 113 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 uint32_t;
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 uint64_t;
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 u_int64_t;
#line 118 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __s64 int64_t;
#line 138 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long sector_t;
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 __le16;
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 __be16;
#line 170 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __le32;
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __be32;
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 __le64;
#line 173 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u64 __be64;
#line 175 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u16 __sum16;
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef __u32 __wsum;
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int gfp_t;
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef unsigned int fmode_t;
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef u32 phys_addr_t;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/types.h"
struct ustat {
   __kernel_daddr_t f_tfree ;
   __kernel_ino_t f_tinode ;
   char f_fname[6] ;
   char f_fpack[6] ;
};
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct task_struct;
#line 7
struct task_struct;
#line 8
struct mm_struct;
#line 8
struct mm_struct;
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct revectored_struct {
   unsigned long __map[8] ;
};
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
#line 110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
#line 118 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct vm86plus_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
};
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace-abi.h"
struct ptrace_bts_config {
   __u32 size ;
   __u32 flags ;
   __u32 signal ;
   __u32 bts_size ;
};
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 133 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
typedef int (*initcall_t)(void);
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
typedef void (*exitcall_t)(void);
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
struct obs_kernel_param {
   char const   *str ;
   int (*setup_func)(char * ) ;
   int early ;
};
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
struct cpuinfo_x86;
#line 134
struct cpuinfo_x86;
#line 135
struct task_struct;
#line 233
struct user_desc;
#line 233
struct user_desc;
#line 141 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
struct kernel_vm86_struct {
   struct kernel_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
   struct pt_regs *regs32 ;
};
#line 191
struct task_struct;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_8 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _fpx_sw_bytes {
   __u32 magic1 ;
   __u32 extended_size ;
   __u64 xstate_bv ;
   __u32 xstate_size ;
   __u32 padding[7] ;
};
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
union __anonunion____missing_field_name_9 {
   __u32 reserved3[12] ;
   struct _fpx_sw_bytes sw_reserved ;
};
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _fpstate {
   __u16 cwd ;
   __u16 swd ;
   __u16 twd ;
   __u16 fop ;
   __u64 rip ;
   __u64 rdp ;
   __u32 mxcsr ;
   __u32 mxcsr_mask ;
   __u32 st_space[32] ;
   __u32 xmm_space[64] ;
   __u32 reserved2[12] ;
   union __anonunion____missing_field_name_9 __annonCompField5 ;
};
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct sigcontext {
   unsigned long r8 ;
   unsigned long r9 ;
   unsigned long r10 ;
   unsigned long r11 ;
   unsigned long r12 ;
   unsigned long r13 ;
   unsigned long r14 ;
   unsigned long r15 ;
   unsigned long di ;
   unsigned long si ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long dx ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long sp ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   unsigned long err ;
   unsigned long trapno ;
   unsigned long oldmask ;
   unsigned long cr2 ;
   void *fpstate ;
   unsigned long reserved1[8] ;
};
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _xsave_hdr {
   __u64 xstate_bv ;
   __u64 reserved1[2] ;
   __u64 reserved2[5] ;
};
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _ymmh_state {
   __u32 ymmh_space[64] ;
};
#line 283 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/current.h"
struct task_struct;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/alternative.h"
struct alt_instr {
   u8 *instr ;
   u8 *replacement ;
   u8 cpuid ;
   u8 instrlen ;
   u8 replacementlen ;
   u8 pad1 ;
};
#line 59
struct module;
#line 59
struct module;
#line 148
struct paravirt_patch_site;
#line 148
struct paravirt_patch_site;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
struct __xchg_dummy {
   unsigned long a[100] ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ratelimit.h"
struct ratelimit_state {
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dynamic_debug.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   char primary_hash ;
   char secondary_hash ;
   unsigned int lineno : 24 ;
   unsigned int flags : 8 ;
} __attribute__((__aligned__(8))) ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bug.h"
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
struct completion;
#line 114
struct completion;
#line 115
struct pt_regs;
#line 116
struct user;
#line 116
struct user;
#line 159
struct atomic_notifier_head;
#line 208
struct pid;
#line 208
struct pid;
#line 311
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4,
    SYSTEM_SUSPEND_DISK = 5
} ;
#line 334
enum __anonenum_10 {
    DUMP_PREFIX_NONE = 0,
    DUMP_PREFIX_ADDRESS = 1,
    DUMP_PREFIX_OFFSET = 2
} ;
#line 651
struct sysinfo;
#line 651
struct sysinfo;
#line 657 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
struct sysinfo {
   long uptime ;
   unsigned long loads[3] ;
   unsigned long totalram ;
   unsigned long freeram ;
   unsigned long sharedram ;
   unsigned long bufferram ;
   unsigned long totalswap ;
   unsigned long freeswap ;
   unsigned short procs ;
   unsigned short pad ;
   unsigned long totalhigh ;
   unsigned long freehigh ;
   unsigned int mem_unit ;
   char _f[(20UL - 2UL * sizeof(long )) - sizeof(int )] ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
struct task_struct;
#line 23
struct tss_struct;
#line 23
struct tss_struct;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page.h"
struct page;
#line 18
struct page;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pteval_t;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pmdval_t;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pudval_t;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pgdval_t;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef unsigned long pgprotval_t;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
union __anonunion_pte_t_11 {
   pteval_t pte ;
   pteval_t pte_low ;
};
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level_types.h"
typedef union __anonunion_pte_t_11 pte_t;
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
struct __anonstruct_pud_t_13 {
   pgd_t pgd ;
};
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
typedef struct __anonstruct_pud_t_13 pud_t;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
struct mm_struct;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
struct __anonstruct_pmd_t_14 {
   pud_t pud ;
};
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
typedef struct __anonstruct_pmd_t_14 pmd_t;
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 285
struct file;
#line 285
struct file;
#line 302
struct seq_file;
#line 302
struct seq_file;
#line 305
enum __anonenum_15 {
    PG_LEVEL_NONE = 0,
    PG_LEVEL_4K = 1,
    PG_LEVEL_2M = 2,
    PG_LEVEL_1G = 3,
    PG_LEVEL_NUM = 4
} ;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_17 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_18 {
   unsigned int a ;
   unsigned int b ;
};
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
union __anonunion____missing_field_name_16 {
   struct __anonstruct____missing_field_name_18 __annonCompField7 ;
   struct __anonstruct____missing_field_name_17 __annonCompField6 ;
};
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   union __anonunion____missing_field_name_16 __annonCompField8 ;
} __attribute__((__packed__)) ;
#line 37
enum __anonenum_19 {
    GATE_INTERRUPT = 14,
    GATE_TRAP = 15,
    GATE_CALL = 12,
    GATE_TASK = 5
} ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned int ist : 3 ;
   unsigned int zero0 : 5 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
#line 58
enum __anonenum_20 {
    DESC_TSS = 9,
    DESC_LDT = 2,
    DESCTYPE_S = 16
} ;
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct ldttss_desc64 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit1 : 4 ;
   unsigned int zero0 : 3 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
   u32 base3 ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct desc_struct gate_desc;
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct desc_struct ldt_desc;
#line 83 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
typedef struct desc_struct tss_desc;
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
} __attribute__((__packed__)) ;
#line 263 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
struct cpuinfo_x86;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
struct exec_domain;
#line 10
struct exec_domain;
#line 11
struct pt_regs;
#line 24
enum __anonenum_21 {
    ADDR_NO_RANDOMIZE = 262144,
    FDPIC_FUNCPTRS = 524288,
    MMAP_PAGE_ZERO = 1048576,
    ADDR_COMPAT_LAYOUT = 2097152,
    READ_IMPLIES_EXEC = 4194304,
    ADDR_LIMIT_32BIT = 8388608,
    SHORT_INODE = 16777216,
    WHOLE_SECONDS = 33554432,
    STICKY_TIMEOUTS = 67108864,
    ADDR_LIMIT_3GB = 134217728
} ;
#line 54
enum __anonenum_22 {
    PER_LINUX = 0,
    PER_LINUX_32BIT = 8388608,
    PER_LINUX_FDPIC = 524288,
    PER_SVR4 = 68157441,
    PER_SVR3 = 83886082,
    PER_SCOSVR3 = 117440515,
    PER_OSR5 = 100663299,
    PER_WYSEV386 = 83886084,
    PER_ISCR4 = 67108869,
    PER_BSD = 6,
    PER_SUNOS = 67108870,
    PER_XENIX = 83886087,
    PER_LINUX32 = 8,
    PER_LINUX32_3GB = 134217736,
    PER_IRIX32 = 67108873,
    PER_IRIXN32 = 67108874,
    PER_IRIX64 = 67108875,
    PER_RISCOS = 12,
    PER_SOLARIS = 67108877,
    PER_UW7 = 68157454,
    PER_OSF4 = 15,
    PER_HPUX = 16,
    PER_MASK = 255
} ;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
typedef void (*handler_t)(int  , struct pt_regs * );
#line 91
struct map_segment;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 1032 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
typedef struct cpumask cpumask_var_t[1];
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   char wp_works_ok ;
   char hlt_works_ok ;
   char hard_math ;
   char rfu ;
   char fdiv_bug ;
   char f00f_bug ;
   char coma_bug ;
   char pad0 ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[9] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   cpumask_var_t llc_shared_map ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u16 cpu_index ;
   unsigned int x86_hyper_vendor ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 149
struct seq_operations;
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   unsigned short back_link ;
   unsigned short __blh ;
   unsigned long sp0 ;
   unsigned short ss0 ;
   unsigned short __ss0h ;
   unsigned long sp1 ;
   unsigned short ss1 ;
   unsigned short __ss1h ;
   unsigned long sp2 ;
   unsigned short ss2 ;
   unsigned short __ss2h ;
   unsigned long __cr3 ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long bx ;
   unsigned long sp ;
   unsigned long bp ;
   unsigned long si ;
   unsigned long di ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short ldt ;
   unsigned short __ldth ;
   unsigned short trace ;
   unsigned short io_bitmap_base ;
} __attribute__((__packed__)) ;
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[8192UL / sizeof(long ) + 1UL] ;
   unsigned long stack[64] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct orig_ist {
   unsigned long ist[7] ;
};
#line 284 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_23 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_25 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_26 {
   u64 rip ;
   u64 rdp ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_26 __annonCompField11 ;
   struct __anonstruct____missing_field_name_25 __annonCompField10 ;
};
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField12 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_23 __annonCompField9 ;
} __attribute__((__aligned__(16))) ;
#line 335 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
#line 360 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
#line 366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
} __attribute__((__packed__, __aligned__(64))) ;
#line 373 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 421
struct kmem_cache;
#line 426 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long sysenter_cs ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_sp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
};
#line 628 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
#line 628 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 540
struct hlist_node;
#line 540 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 544 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 68 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/stat.h"
struct stat {
   unsigned long st_dev ;
   unsigned long st_ino ;
   unsigned long st_nlink ;
   unsigned int st_mode ;
   unsigned int st_uid ;
   unsigned int st_gid ;
   unsigned int __pad0 ;
   unsigned long st_rdev ;
   long st_size ;
   long st_blksize ;
   long st_blocks ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned long st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   long __unused[3] ;
};
#line 93 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/stat.h"
struct __old_kernel_stat {
   unsigned short st_dev ;
   unsigned short st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned short st_rdev ;
   unsigned int st_size ;
   unsigned int st_atime ;
   unsigned int st_mtime ;
   unsigned int st_ctime ;
};
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct timespec;
#line 12
struct timespec;
#line 13
struct compat_timespec;
#line 13
struct compat_timespec;
#line 18
struct pollfd;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct_poll_29 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct_nanosleep_30 {
   clockid_t index ;
   struct timespec *rmtp ;
   u64 expires ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct_futex_31 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct __anonstruct____missing_field_name_32 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_32 __annonCompField13 ;
   struct __anonstruct_futex_31 futex ;
   struct __anonstruct_nanosleep_30 nanosleep ;
   struct __anonstruct_poll_29 poll ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
struct task_struct;
#line 21
struct exec_domain;
#line 141 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
typedef atomic_t atomic_long_t;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
   int uaccess_err ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
struct raw_spinlock {
   unsigned int slock ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_raw_rwlock_t_33 {
   unsigned int lock ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock_types.h"
typedef struct __anonstruct_raw_rwlock_t_33 raw_rwlock_t;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
struct task_struct;
#line 13
struct lockdep_map;
#line 13
struct lockdep_map;
#line 337 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
struct lock_class_key {

};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_34 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_34 spinlock_t;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_35 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
};
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_35 rwlock_t;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_36 {
   unsigned int sequence ;
   spinlock_t lock ;
};
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_36 seqlock_t;
#line 121 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
struct seqcount {
   unsigned int sequence ;
};
#line 121 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/div64.h"
union __anonunion_d_37 {
   u64 v64 ;
   u32 v32[2] ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 121
struct itimerval;
#line 121
struct itimerval;
#line 136
struct tms;
#line 136
struct tms;
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 216 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct __wait_queue;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
typedef int (*wait_queue_func_t)(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key );
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct wait_bit_key {
   void *flags ;
   int bit_nr ;
};
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct wait_bit_queue {
   struct wait_bit_key key ;
   wait_queue_t wait ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 54 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 56
struct task_struct;
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_38 {
   unsigned long bits[((1UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_38 nodemask_t;
#line 363
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
} ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pageblock-flags.h"
enum pageblock_bits {
    PB_migrate = 0,
    PB_migrate_end = 2,
    NR_PAGEBLOCK_BITS = 3
} ;
#line 60
struct page;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[5] ;
   unsigned long nr_free ;
};
#line 64
struct pglist_data;
#line 64
struct pglist_data;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zone_padding {
   char x[0] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 81
enum zone_stat_item {
    NR_FREE_PAGES = 0,
    NR_LRU_BASE = 1,
    NR_INACTIVE_ANON = 1,
    NR_ACTIVE_ANON = 2,
    NR_INACTIVE_FILE = 3,
    NR_ACTIVE_FILE = 4,
    NR_UNEVICTABLE = 5,
    NR_MLOCK = 6,
    NR_ANON_PAGES = 7,
    NR_FILE_MAPPED = 8,
    NR_FILE_PAGES = 9,
    NR_FILE_DIRTY = 10,
    NR_WRITEBACK = 11,
    NR_SLAB_RECLAIMABLE = 12,
    NR_SLAB_UNRECLAIMABLE = 13,
    NR_PAGETABLE = 14,
    NR_UNSTABLE_NFS = 15,
    NR_BOUNCE = 16,
    NR_VMSCAN_WRITE = 17,
    NR_WRITEBACK_TEMP = 18,
    NR_VM_ZONE_STAT_ITEMS = 19
} ;
#line 133
enum lru_list {
    LRU_INACTIVE_ANON = 0,
    LRU_ACTIVE_ANON = 1,
    LRU_INACTIVE_FILE = 2,
    LRU_ACTIVE_FILE = 3,
    LRU_UNEVICTABLE = 4,
    NR_LRU_LISTS = 5
} ;
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head list ;
};
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 stat_threshold ;
   s8 vm_stat_diff[19] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 195
enum zone_type {
    ZONE_DMA = 0,
    ZONE_NORMAL = 1,
    ZONE_HIGHMEM = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2] ;
   unsigned long recent_scanned[2] ;
};
#line 279 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct __anonstruct_lru_39 {
   struct list_head list ;
   unsigned long nr_scan ;
};
#line 279 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zone {
   unsigned long pages_min ;
   unsigned long pages_low ;
   unsigned long pages_high ;
   unsigned long lowmem_reserve[4] ;
   struct per_cpu_pageset pageset[8] ;
   spinlock_t lock ;
   struct free_area free_area[11] ;
   unsigned long *pageblock_flags ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   struct __anonstruct_lru_39 lru[5] ;
   struct zone_reclaim_stat reclaim_stat ;
   unsigned long pages_scanned ;
   unsigned long flags ;
   atomic_long_t vm_stat[19] ;
   int prev_priority ;
   unsigned int inactive_ratio ;
   struct zone_padding _pad2_ ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct pglist_data *zone_pgdat ;
   unsigned long zone_start_pfn ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 418
enum __anonenum_zone_flags_t_40 {
    ZONE_ALL_UNRECLAIMABLE = 0,
    ZONE_RECLAIM_LOCKED = 1,
    ZONE_OOM_LOCKED = 2
} ;
#line 418 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
typedef enum __anonenum_zone_flags_t_40 zone_flags_t;
#line 542
struct zonelist_cache;
#line 542
struct zonelist_cache;
#line 549 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 571 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[5] ;
};
#line 580 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct node_active_region {
   unsigned long start_pfn ;
   unsigned long end_pfn ;
   int nid ;
};
#line 603
struct bootmem_data;
#line 603
struct bootmem_data;
#line 604 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4] ;
   struct zonelist node_zonelists[1] ;
   int nr_zones ;
   struct page *node_mem_map ;
   struct bootmem_data *bdata ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
};
#line 604 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
};
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
};
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rwsem.h"
struct rw_semaphore;
#line 17
struct rw_semaphore;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
struct rwsem_waiter;
#line 45
struct rwsem_waiter;
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/srcu.h"
struct srcu_struct_array {
   int c[2] ;
};
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/srcu.h"
struct srcu_struct {
   int completed ;
   struct srcu_struct_array *per_cpu_ref ;
   struct mutex mutex ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct atomic_notifier_head {
   spinlock_t lock ;
   struct notifier_block *head ;
};
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct raw_notifier_head {
   struct notifier_block *head ;
};
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
struct srcu_notifier_head {
   struct mutex mutex ;
   struct srcu_struct srcu ;
   struct notifier_block *head ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
struct page;
#line 9
struct zone;
#line 10
struct pglist_data;
#line 11
struct mem_section;
#line 11
struct mem_section;
#line 652 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
enum memmap_context {
    MEMMAP_EARLY = 0,
    MEMMAP_HOTPLUG = 1
} ;
#line 748
struct ctl_table;
#line 748
struct ctl_table;
#line 749
struct file;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
struct call_single_data {
   struct list_head list ;
   void (*func)(void *info ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpf_intel {
   char signature[4] ;
   unsigned int physptr ;
   unsigned char length ;
   unsigned char specification ;
   unsigned char checksum ;
   unsigned char feature1 ;
   unsigned char feature2 ;
   unsigned char feature3 ;
   unsigned char feature4 ;
   unsigned char feature5 ;
};
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_table {
   char signature[4] ;
   unsigned short length ;
   char spec ;
   char checksum ;
   char oem[8] ;
   char productid[12] ;
   unsigned int oemptr ;
   unsigned short oemsize ;
   unsigned short oemcount ;
   unsigned int lapic ;
   unsigned int reserved ;
};
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_cpu {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char cpuflag ;
   unsigned int cpufeature ;
   unsigned int featureflag ;
   unsigned int reserved[2] ;
};
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_bus {
   unsigned char type ;
   unsigned char busid ;
   unsigned char bustype[6] ;
};
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_ioapic {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char flags ;
   unsigned int apicaddr ;
};
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_intsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbus ;
   unsigned char srcbusirq ;
   unsigned char dstapic ;
   unsigned char dstirq ;
};
#line 130
enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3
} ;
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_lintsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbusid ;
   unsigned char srcbusirq ;
   unsigned char destapic ;
   unsigned char destapiclint ;
};
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec_def.h"
struct mpc_oemtable {
   char signature[4] ;
   unsigned short length ;
   char rev ;
   char checksum ;
   char mpc[8] ;
};
#line 175
enum mp_bustype {
    MP_BUS_ISA = 1,
    MP_BUS_EISA = 2,
    MP_BUS_PCI = 3,
    MP_BUS_MCA = 4
} ;
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
struct physid_mask {
   unsigned long mask[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
typedef struct physid_mask physid_mask_t;
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct device;
#line 37
struct device;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 170 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
#line 308
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
#line 318 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
#line 416
enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3
} ;
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_20_41 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_dcr_42 {
   unsigned int divisor : 4 ;
   unsigned int __reserved_1 : 28 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_19_43 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_18_44 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_17_45 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_16_46 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_ccr_47 {
   unsigned int curr_count ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_timer_icr_48 {
   unsigned int initial_count ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_error_49 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_lint1_50 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_lint0_51 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_pc_52 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_thermal_53 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_lvt_timer_54 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int timer_mode : 1 ;
   unsigned int __reserved_3 : 14 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
union __anonunion_dest_56 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_dest : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved_3 : 24 ;
   unsigned int logical_dest : 8 ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_icr2_55 {
   union __anonunion_dest_56 dest ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_icr1_57 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int destination_mode : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int level : 1 ;
   unsigned int trigger : 1 ;
   unsigned int __reserved_2 : 2 ;
   unsigned int shorthand : 2 ;
   unsigned int __reserved_3 : 12 ;
   unsigned int __reserved_4[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_14_58 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_13_59 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_12_60 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_11_61 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_10_62 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_09_63 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_08_64 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_all_errors_66 {
   unsigned int errors ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_error_bits_67 {
   unsigned int send_cs_error : 1 ;
   unsigned int receive_cs_error : 1 ;
   unsigned int send_accept_error : 1 ;
   unsigned int receive_accept_error : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int send_illegal_vector : 1 ;
   unsigned int receive_illegal_vector : 1 ;
   unsigned int illegal_register_address : 1 ;
   unsigned int __reserved_2 : 24 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
union __anonunion_esr_65 {
   struct __anonstruct_error_bits_67 error_bits ;
   struct __anonstruct_all_errors_66 all_errors ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_irr_68 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_tmr_69 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_isr_70 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_svr_71 {
   unsigned int spurious_vector : 8 ;
   unsigned int apic_enabled : 1 ;
   unsigned int focus_cpu : 1 ;
   unsigned int __reserved_2 : 22 ;
   unsigned int __reserved_3[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_dfr_72 {
   unsigned int __reserved_1 : 28 ;
   unsigned int model : 4 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_ldr_73 {
   unsigned int __reserved_1 : 24 ;
   unsigned int logical_dest : 8 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_07_74 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_eoi_75 {
   unsigned int eoi ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_ppr_76 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_apr_77 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_tpr_78 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_06_79 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_05_80 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_04_81 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_03_82 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_version_83 {
   unsigned int version : 8 ;
   unsigned int __reserved_1 : 8 ;
   unsigned int max_lvt : 8 ;
   unsigned int __reserved_2 : 8 ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct_id_84 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_apic_id : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved[3] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_02_85 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct __anonstruct___reserved_01_86 {
   unsigned int __reserved[4] ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apicdef.h"
struct local_apic {
   struct __anonstruct___reserved_01_86 __reserved_01 ;
   struct __anonstruct___reserved_02_85 __reserved_02 ;
   struct __anonstruct_id_84 id ;
   struct __anonstruct_version_83  const  version ;
   struct __anonstruct___reserved_03_82 __reserved_03 ;
   struct __anonstruct___reserved_04_81 __reserved_04 ;
   struct __anonstruct___reserved_05_80 __reserved_05 ;
   struct __anonstruct___reserved_06_79 __reserved_06 ;
   struct __anonstruct_tpr_78 tpr ;
   struct __anonstruct_apr_77  const  apr ;
   struct __anonstruct_ppr_76  const  ppr ;
   struct __anonstruct_eoi_75 eoi ;
   struct __anonstruct___reserved_07_74 __reserved_07 ;
   struct __anonstruct_ldr_73 ldr ;
   struct __anonstruct_dfr_72 dfr ;
   struct __anonstruct_svr_71 svr ;
   struct __anonstruct_isr_70 isr[8] ;
   struct __anonstruct_tmr_69 tmr[8] ;
   struct __anonstruct_irr_68 irr[8] ;
   union __anonunion_esr_65 esr ;
   struct __anonstruct___reserved_08_64 __reserved_08 ;
   struct __anonstruct___reserved_09_63 __reserved_09 ;
   struct __anonstruct___reserved_10_62 __reserved_10 ;
   struct __anonstruct___reserved_11_61 __reserved_11 ;
   struct __anonstruct___reserved_12_60 __reserved_12 ;
   struct __anonstruct___reserved_13_59 __reserved_13 ;
   struct __anonstruct___reserved_14_58 __reserved_14 ;
   struct __anonstruct_icr1_57 icr1 ;
   struct __anonstruct_icr2_55 icr2 ;
   struct __anonstruct_lvt_timer_54 lvt_timer ;
   struct __anonstruct_lvt_thermal_53 lvt_thermal ;
   struct __anonstruct_lvt_pc_52 lvt_pc ;
   struct __anonstruct_lvt_lint0_51 lvt_lint0 ;
   struct __anonstruct_lvt_lint1_50 lvt_lint1 ;
   struct __anonstruct_lvt_error_49 lvt_error ;
   struct __anonstruct_timer_icr_48 timer_icr ;
   struct __anonstruct_timer_ccr_47  const  timer_ccr ;
   struct __anonstruct___reserved_16_46 __reserved_16 ;
   struct __anonstruct___reserved_17_45 __reserved_17 ;
   struct __anonstruct___reserved_18_44 __reserved_18 ;
   struct __anonstruct___reserved_19_43 __reserved_19 ;
   struct __anonstruct_timer_dcr_42 timer_dcr ;
   struct __anonstruct___reserved_20_41 __reserved_20 ;
} __attribute__((__packed__)) ;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_87 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_87 mm_context_t;
#line 157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
struct bootnode;
#line 157
struct bootnode;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/kmap_types.h"
enum km_type {
    KM_BOUNCE_READ = 0,
    KM_SKB_SUNRPC_DATA = 1,
    KM_SKB_DATA_SOFTIRQ = 2,
    KM_USER0 = 3,
    KM_USER1 = 4,
    KM_BIO_SRC_IRQ = 5,
    KM_BIO_DST_IRQ = 6,
    KM_PTE0 = 7,
    KM_PTE1 = 8,
    KM_IRQ0 = 9,
    KM_IRQ1 = 10,
    KM_SOFTIRQ0 = 11,
    KM_SOFTIRQ1 = 12,
    KM_TYPE_NR = 13
} ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
enum fixed_addresses {
    FIX_HOLE = 0,
    FIX_VDSO = 1,
    FIX_DBGP_BASE = 2,
    FIX_EARLYCON_MEM_BASE = 3,
    FIX_APIC_BASE = 4,
    FIX_IO_APIC_BASE_0 = 5,
    FIX_IO_APIC_BASE_END = 68,
    FIX_KMAP_BEGIN = 69,
    FIX_KMAP_END = 172,
    FIX_PCIE_MCFG = 173,
    FIX_TEXT_POKE1 = 174,
    FIX_TEXT_POKE0 = 175,
    __end_of_permanent_fixed_addresses = 176,
    FIX_BTMAP_END = 256,
    FIX_BTMAP_BEGIN = 511,
    FIX_OHCI1394_BASE = 512,
    FIX_WP_TEST = 513,
    __end_of_fixed_addresses = 514
} ;
#line 274 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
struct apic {
   char *name ;
   int (*probe)(void) ;
   int (*acpi_madt_oem_check)(char *oem_id , char *oem_table_id ) ;
   int (*apic_id_registered)(void) ;
   u32 irq_delivery_mode ;
   u32 irq_dest_mode ;
   struct cpumask  const  *(*target_cpus)(void) ;
   int disable_esr ;
   int dest_logical ;
   unsigned long (*check_apicid_used)(physid_mask_t bitmap , int apicid ) ;
   unsigned long (*check_apicid_present)(int apicid ) ;
   void (*vector_allocation_domain)(int cpu , struct cpumask *retmask ) ;
   void (*init_apic_ldr)(void) ;
   physid_mask_t (*ioapic_phys_id_map)(physid_mask_t map ) ;
   void (*setup_apic_routing)(void) ;
   int (*multi_timer_check)(int apic , int irq ) ;
   int (*apicid_to_node)(int logical_apicid ) ;
   int (*cpu_to_logical_apicid)(int cpu ) ;
   int (*cpu_present_to_apicid)(int mps_cpu ) ;
   physid_mask_t (*apicid_to_cpu_present)(int phys_apicid ) ;
   void (*setup_portio_remap)(void) ;
   int (*check_phys_apicid_present)(int boot_cpu_physical_apicid ) ;
   void (*enable_apic_mode)(void) ;
   int (*phys_pkg_id)(int cpuid_apic , int index_msb ) ;
   int (*mps_oem_check)(struct mpc_table *mpc , char *oem , char *productid ) ;
   unsigned int (*get_apic_id)(unsigned long x ) ;
   unsigned long (*set_apic_id)(unsigned int id ) ;
   unsigned long apic_id_mask ;
   unsigned int (*cpu_mask_to_apicid)(struct cpumask  const  *cpumask ) ;
   unsigned int (*cpu_mask_to_apicid_and)(struct cpumask  const  *cpumask , struct cpumask  const  *andmask ) ;
   void (*send_IPI_mask)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_mask_allbutself)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_allbutself)(int vector ) ;
   void (*send_IPI_all)(int vector ) ;
   void (*send_IPI_self)(int vector ) ;
   int (*wakeup_secondary_cpu)(int apicid , unsigned long start_eip ) ;
   int trampoline_phys_low ;
   int trampoline_phys_high ;
   void (*wait_for_init_deassert)(atomic_t *deassert ) ;
   void (*smp_callin_clear_local_apic)(void) ;
   void (*inquire_remote_apic)(int apicid ) ;
   u32 (*read)(u32 reg ) ;
   void (*write)(u32 reg , u32 v ) ;
   u64 (*icr_read)(void) ;
   void (*icr_write)(u32 low , u32 high ) ;
   void (*wait_icr_idle)(void) ;
   u32 (*safe_wait_icr_idle)(void) ;
};
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_88 {
   u32 __reserved_2 : 14 ;
   u32 LTS : 1 ;
   u32 delivery_type : 1 ;
   u32 __reserved_1 : 8 ;
   u32 ID : 8 ;
} __attribute__((__packed__)) ;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_00 {
   u32 raw ;
   struct __anonstruct_bits_88 bits ;
};
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_89 {
   u32 version : 8 ;
   u32 __reserved_2 : 7 ;
   u32 PRQ : 1 ;
   u32 entries : 8 ;
   u32 __reserved_1 : 8 ;
} __attribute__((__packed__)) ;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_01 {
   u32 raw ;
   struct __anonstruct_bits_89 bits ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_90 {
   u32 __reserved_2 : 24 ;
   u32 arbitration : 4 ;
   u32 __reserved_1 : 4 ;
} __attribute__((__packed__)) ;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_02 {
   u32 raw ;
   struct __anonstruct_bits_90 bits ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct __anonstruct_bits_91 {
   u32 boot_DT : 1 ;
   u32 __reserved_1 : 31 ;
} __attribute__((__packed__)) ;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
union IO_APIC_reg_03 {
   u32 raw ;
   struct __anonstruct_bits_91 bits ;
};
#line 66
enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7
} ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct IO_APIC_route_entry {
   __u32 vector : 8 ;
   __u32 delivery_mode : 3 ;
   __u32 dest_mode : 1 ;
   __u32 delivery_status : 1 ;
   __u32 polarity : 1 ;
   __u32 irr : 1 ;
   __u32 trigger : 1 ;
   __u32 mask : 1 ;
   __u32 __reserved_2 : 15 ;
   __u32 __reserved_3 : 24 ;
   __u32 dest : 8 ;
} __attribute__((__packed__)) ;
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
struct IR_IO_APIC_route_entry {
   __u64 vector : 8 ;
   __u64 zero : 3 ;
   __u64 index2 : 1 ;
   __u64 delivery_status : 1 ;
   __u64 polarity : 1 ;
   __u64 irr : 1 ;
   __u64 trigger : 1 ;
   __u64 mask : 1 ;
   __u64 reserved : 31 ;
   __u64 format : 1 ;
   __u64 index : 15 ;
} __attribute__((__packed__)) ;
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
struct __anonstruct_stack_start_92 {
   void *sp ;
   unsigned short ss ;
};
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
struct smp_ops {
   void (*smp_prepare_boot_cpu)(void) ;
   void (*smp_prepare_cpus)(unsigned int max_cpus ) ;
   void (*smp_cpus_done)(unsigned int max_cpus ) ;
   void (*smp_send_stop)(void) ;
   void (*smp_send_reschedule)(int cpu ) ;
   int (*cpu_up)(unsigned int cpu ) ;
   int (*cpu_disable)(void) ;
   void (*cpu_die)(unsigned int cpu ) ;
   void (*play_dead)(void) ;
   void (*send_call_func_ipi)(struct cpumask  const  *mask ) ;
   void (*send_call_func_single_ipi)(int cpu ) ;
};
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 202
struct pci_bus;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
struct vm_area_struct;
#line 9
struct vm_area_struct;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
struct key;
#line 45
struct key;
#line 46
struct file;
#line 47
struct subprocess_info;
#line 47
struct subprocess_info;
#line 61
enum umh_wait {
    UMH_NO_WAIT = -1,
    UMH_WAIT_EXEC = 0,
    UMH_WAIT_PROC = 1
} ;
#line 103
struct file;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user_i387_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
};
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user_fxsr_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long reserved ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
};
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user_regs_struct {
   unsigned long bx ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long bp ;
   unsigned long ax ;
   unsigned long ds ;
   unsigned long es ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/user_32.h"
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   struct user_i387_struct i387 ;
   unsigned long u_tsize ;
   unsigned long u_dsize ;
   unsigned long u_ssize ;
   unsigned long start_code ;
   unsigned long start_stack ;
   long signal ;
   int reserved ;
   unsigned long u_ar0 ;
   struct user_i387_struct *u_fpstate ;
   unsigned long magic ;
   char u_comm[32] ;
   int u_debugreg[8] ;
};
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
typedef unsigned long elf_greg_t;
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
typedef elf_greg_t elf_gregset_t[sizeof(struct user_regs_struct ) / sizeof(elf_greg_t )];
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
typedef struct user_i387_struct elf_fpregset_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ldt.h"
struct user_desc {
   unsigned int entry_number ;
   unsigned int base_addr ;
   unsigned int limit ;
   unsigned int seg_32bit : 1 ;
   unsigned int contents : 2 ;
   unsigned int read_exec_only : 1 ;
   unsigned int limit_in_pages : 1 ;
   unsigned int seg_not_present : 1 ;
   unsigned int useable : 1 ;
   unsigned int lm : 1 ;
};
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
struct gdt_page {
   struct desc_struct gdt[32] ;
} __attribute__((__aligned__((1) <<  (12) ))) ;
#line 290 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
struct task_struct;
#line 335
struct linux_binprm;
#line 335
struct linux_binprm;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct file;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf32_Addr;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u16 Elf32_Half;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf32_Off;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s32 Elf32_Sword;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf32_Word;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u16 Elf64_Half;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s16 Elf64_SHalf;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u64 Elf64_Off;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s32 Elf64_Sword;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u32 Elf64_Word;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef __s64 Elf64_Sxword;
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
union __anonunion_d_un_93 {
   Elf32_Sword d_val ;
   Elf32_Addr d_ptr ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct dynamic {
   Elf32_Sword d_tag ;
   union __anonunion_d_un_93 d_un ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct dynamic Elf32_Dyn;
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
union __anonunion_d_un_95 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct __anonstruct_Elf64_Dyn_94 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_95 d_un ;
};
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct __anonstruct_Elf64_Dyn_94 Elf64_Dyn;
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_rel {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_rel Elf32_Rel;
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_rel {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
};
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_rel Elf64_Rel;
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_rela {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
   Elf32_Sword r_addend ;
};
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_rela Elf32_Rela;
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_rela {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_rela Elf64_Rela;
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_sym Elf32_Sym;
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_hdr Elf32_Ehdr;
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_hdr {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_hdr Elf64_Ehdr;
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_phdr Elf32_Phdr;
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_phdr {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_phdr Elf64_Phdr;
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct __anonstruct_Elf32_Shdr_96 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct __anonstruct_Elf32_Shdr_96 Elf32_Shdr;
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_shdr Elf64_Shdr;
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf32_note {
   Elf32_Word n_namesz ;
   Elf32_Word n_descsz ;
   Elf32_Word n_type ;
};
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf32_note Elf32_Nhdr;
#line 374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
struct elf64_note {
   Elf64_Word n_namesz ;
   Elf64_Word n_descsz ;
   Elf64_Word n_type ;
};
#line 374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
typedef struct elf64_note Elf64_Nhdr;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct kobject;
#line 20
struct kobject;
#line 21
struct module;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
#line 63
struct vm_area_struct;
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 82
struct sysfs_dirent;
#line 82
struct sysfs_dirent;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
#line 59
struct kobj_type;
#line 59
struct kset;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
#line 113 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kobj_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct kobject *kobj , struct kobj_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct kobject *kobj , struct kobj_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kernel_param;
#line 32
struct kernel_param;
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
typedef int (*param_set_fn)(char const   *val , struct kernel_param *kp );
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
typedef int (*param_get_fn)(char *buffer , struct kernel_param *kp );
#line 39
struct kparam_array;
#line 39
struct kparam_string;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
union __anonunion____missing_field_name_97 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_97 __annonCompField15 ;
};
#line 52 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
#line 217
struct module;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
struct module;
#line 19
struct marker;
#line 19
struct marker;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
#line 78 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_dynticks {
   int dynticks_nesting ;
   int dynticks ;
   int dynticks_nmi ;
};
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_node {
   spinlock_t lock ;
   unsigned long qsmask ;
   unsigned long qsmaskinit ;
   unsigned long grpmask ;
   int grplo ;
   int grphi ;
   u8 grpnum ;
   u8 level ;
   struct rcu_node *parent ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 111 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_data {
   long completed ;
   long gpnum ;
   long passed_quiesc_completed ;
   bool passed_quiesc ;
   bool qs_pending ;
   bool beenonline ;
   struct rcu_node *mynode ;
   unsigned long grpmask ;
   struct rcu_head *nxtlist ;
   struct rcu_head **nxttail[4] ;
   long qlen ;
   long blimit ;
   struct rcu_dynticks *dynticks ;
   int dynticks_snap ;
   int dynticks_nmi_snap ;
   unsigned long dynticks_fqs ;
   unsigned long offline_fqs ;
   unsigned long resched_ipi ;
   long n_rcu_pending ;
   int cpu ;
};
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
struct rcu_state {
   struct rcu_node node[1] ;
   struct rcu_node *level[1] ;
   u32 levelcnt[4] ;
   u8 levelspread[1] ;
   struct rcu_data *rda[8] ;
   u8 signaled  __attribute__((__aligned__((1) <<  (5) ))) ;
   long gpnum ;
   long completed ;
   spinlock_t onofflock ;
   spinlock_t fqslock ;
   unsigned long jiffies_force_qs ;
   unsigned long n_force_qs ;
   unsigned long n_force_qs_lh ;
   unsigned long n_force_qs_ngp ;
   long dynticks_completed ;
};
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
struct rcu_synchronize {
   struct rcu_head head ;
   struct completion completion ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
struct module;
#line 21
struct tracepoint;
#line 21
struct tracepoint;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
struct tracepoint_iter {
   struct module *module ;
   struct tracepoint *tracepoint ;
};
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timex.h"
struct timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
enum debug_obj_state {
    ODEBUG_STATE_NONE = 0,
    ODEBUG_STATE_INIT = 1,
    ODEBUG_STATE_INACTIVE = 2,
    ODEBUG_STATE_ACTIVE = 3,
    ODEBUG_STATE_DESTROYED = 4,
    ODEBUG_STATE_NOTAVAILABLE = 5,
    ODEBUG_STATE_MAX = 6
} ;
#line 17
struct debug_obj_descr;
#line 17
struct debug_obj_descr;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
struct debug_obj {
   struct hlist_node node ;
   enum debug_obj_state state ;
   void *object ;
   struct debug_obj_descr *descr ;
};
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
struct debug_obj_descr {
   char const   *name ;
   int (*fixup_init)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_activate)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_destroy)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_free)(void *addr , enum debug_obj_state state ) ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
struct tvec_base;
#line 10
struct tvec_base;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
   void *start_site ;
   char start_comm[16] ;
   int start_pid ;
};
#line 238
struct hrtimer;
#line 238
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct workqueue_struct;
#line 14
struct workqueue_struct;
#line 16
struct work_struct;
#line 16
struct work_struct;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
typedef void (*work_func_t)(struct work_struct *work );
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
enum stat_item {
    ALLOC_FASTPATH = 0,
    ALLOC_SLOWPATH = 1,
    FREE_FASTPATH = 2,
    FREE_SLOWPATH = 3,
    FREE_FROZEN = 4,
    FREE_ADD_PARTIAL = 5,
    FREE_REMOVE_PARTIAL = 6,
    ALLOC_FROM_PARTIAL = 7,
    ALLOC_SLAB = 8,
    ALLOC_REFILL = 9,
    FREE_SLAB = 10,
    CPUSLAB_FLUSH = 11,
    DEACTIVATE_FULL = 12,
    DEACTIVATE_EMPTY = 13,
    DEACTIVATE_TO_HEAD = 14,
    DEACTIVATE_TO_TAIL = 15,
    DEACTIVATE_REMOTE_FREES = 16,
    ORDER_FALLBACK = 17,
    NR_SLUB_STAT_ITEMS = 18
} ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   unsigned long min_partial ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct kmem_cache_cpu *cpu_slab[8] ;
};
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu.h"
typedef struct page *(*pcpu_get_page_fn_t)(unsigned int cpu , int pageno );
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu.h"
typedef void (*pcpu_populate_pte_fn_t)(unsigned long addr );
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
typedef struct __anonstruct_local_t_98 local_t;
#line 5 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/module.h"
struct mod_arch_specific {

};
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct modversion_info {
   unsigned long crc ;
   char name[64UL - sizeof(unsigned long )] ;
};
#line 46
struct module;
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 58
struct module_param_attrs;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
#line 71
struct exception_table_entry;
#line 71
struct exception_table_entry;
#line 167
struct notifier_block;
#line 222
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
#line 229
struct module_notes_attrs;
#line 229
struct module_sect_attrs;
#line 229 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   char const   **trace_bprintk_fmt_start ;
   unsigned int num_trace_bprintk_fmt ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
#line 392
enum __anonenum_licence_99 {
    NOT_GPL_ONLY = 0,
    GPL_ONLY = 1,
    WILL_BE_GPL_ONLY = 2
} ;
#line 392 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
struct symsearch {
   struct kernel_symbol  const  *start ;
   struct kernel_symbol  const  *stop ;
   unsigned long const   *crcs ;
   enum __anonenum_licence_99 licence ;
   bool unused ;
};
#line 646
struct device_driver;
#line 646
struct device_driver;
#line 648
struct module;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ieee1394_device_id {
   __u32 match_flags ;
   __u32 vendor_id ;
   __u32 model_id ;
   __u32 specifier_id ;
   __u32 version ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   kernel_ulong_t driver_info ;
};
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct hid_device_id {
   __u16 bus ;
   __u16 pad1 ;
   __u32 vendor ;
   __u32 product ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ccw_device_id {
   __u16 match_flags ;
   __u16 cu_type ;
   __u16 dev_type ;
   __u8 cu_model ;
   __u8 dev_model ;
   kernel_ulong_t driver_info ;
};
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ap_device_id {
   __u16 match_flags ;
   __u8 dev_type ;
   __u8 pad1 ;
   __u32 pad2 ;
   kernel_ulong_t driver_info ;
};
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct css_device_id {
   __u8 match_flags ;
   __u8 type ;
   __u16 pad2 ;
   __u32 pad3 ;
   kernel_ulong_t driver_data ;
};
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[16] ;
   kernel_ulong_t driver_data ;
};
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pnp_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
};
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct __anonstruct_devs_100 {
   __u8 id[8] ;
};
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pnp_card_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
   struct __anonstruct_devs_100 devs[8] ;
};
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct serio_device_id {
   __u8 type ;
   __u8 extra ;
   __u8 id ;
   __u8 proto ;
};
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void *data ;
};
#line 232 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct vio_device_id {
   char type[32] ;
   char compat[32] ;
};
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct pcmcia_device_id {
   __u16 match_flags ;
   __u16 manf_id ;
   __u16 card_id ;
   __u8 func_id ;
   __u8 function ;
   __u8 device_no ;
   __u32 prod_id_hash[4]  __attribute__((__aligned__(sizeof(__u32 )))) ;
   char const   *prod_id[4] ;
   kernel_ulong_t driver_info ;
   char *cisfile ;
};
#line 312 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1] ;
   kernel_ulong_t keybit[24] ;
   kernel_ulong_t relbit[1] ;
   kernel_ulong_t absbit[2] ;
   kernel_ulong_t mscbit[1] ;
   kernel_ulong_t ledbit[1] ;
   kernel_ulong_t sndbit[1] ;
   kernel_ulong_t ffbit[4] ;
   kernel_ulong_t swbit[1] ;
   kernel_ulong_t driver_info ;
};
#line 339 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct eisa_device_id {
   char sig[8] ;
   kernel_ulong_t driver_data ;
};
#line 346 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct parisc_device_id {
   __u8 hw_type ;
   __u8 hversion_rev ;
   __u16 hversion ;
   __u32 sversion ;
};
#line 362 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct sdio_device_id {
   __u8 class ;
   __u16 vendor ;
   __u16 device ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 371 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct ssb_device_id {
   __u16 vendor ;
   __u16 coreid ;
   __u8 revision ;
};
#line 385 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct virtio_device_id {
   __u32 device ;
   __u32 vendor ;
};
#line 396 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct i2c_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 403
enum dmi_field {
    DMI_NONE = 0,
    DMI_BIOS_VENDOR = 1,
    DMI_BIOS_VERSION = 2,
    DMI_BIOS_DATE = 3,
    DMI_SYS_VENDOR = 4,
    DMI_PRODUCT_NAME = 5,
    DMI_PRODUCT_VERSION = 6,
    DMI_PRODUCT_SERIAL = 7,
    DMI_PRODUCT_UUID = 8,
    DMI_BOARD_VENDOR = 9,
    DMI_BOARD_NAME = 10,
    DMI_BOARD_VERSION = 11,
    DMI_BOARD_SERIAL = 12,
    DMI_BOARD_ASSET_TAG = 13,
    DMI_CHASSIS_VENDOR = 14,
    DMI_CHASSIS_TYPE = 15,
    DMI_CHASSIS_VERSION = 16,
    DMI_CHASSIS_SERIAL = 17,
    DMI_CHASSIS_ASSET_TAG = 18,
    DMI_STRING_MAX = 19
} ;
#line 426 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct dmi_strmatch {
   unsigned char slot ;
   char substr[79] ;
};
#line 440 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct dmi_system_id {
   int (*callback)(struct dmi_system_id  const  * ) ;
   char const   *ident ;
   struct dmi_strmatch matches[4] ;
   void *driver_data ;
};
#line 460 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 26
struct pci_dev;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
struct resource_list {
   struct resource_list *next ;
   struct resource *res ;
   struct pci_dev *dev ;
};
#line 165
struct device;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist_node;
#line 19
struct klist_node;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
struct klist_iter {
   struct klist *i_klist ;
   struct klist_node *i_cur ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/semaphore.h"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *acpi_handle ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device;
#line 31
struct device_private;
#line 31
struct device_private;
#line 32
struct device_driver;
#line 33
struct driver_private;
#line 33
struct driver_private;
#line 34
struct class;
#line 34
struct class;
#line 35
struct class_private;
#line 35
struct class_private;
#line 36
struct bus_type;
#line 36
struct bus_type;
#line 37
struct bus_type_private;
#line 37
struct bus_type_private;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
#line 52
struct driver_attribute;
#line 52
struct device_attribute;
#line 52 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
#line 103
struct notifier_block;
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
#line 156 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
#line 188
struct class_attribute;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
#line 208
struct device_type;
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class_dev_iter {
   struct klist_iter ki ;
   struct device_type  const  *type ;
};
#line 241 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
#line 255 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct class_interface {
   struct list_head node ;
   struct class *class ;
   int (*add_dev)(struct device * , struct class_interface * ) ;
   void (*remove_dev)(struct device * , struct class_interface * ) ;
};
#line 288 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
#line 301 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 328 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
typedef void (*dr_release_t)(struct device *dev , void *res );
#line 329 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
typedef int (*dr_match_t)(struct device *dev , void *res , void *match_data );
#line 361 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 370
struct dma_coherent_mem;
#line 370 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
#line 68 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/iomap.h"
struct pci_dev;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmalloc.h"
struct vm_area_struct;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmalloc.h"
struct vm_struct {
   struct vm_struct *next ;
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   unsigned long phys_addr ;
   void *caller ;
};
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/io.h"
struct device;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqreturn.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct hotplug_slot;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 75
enum pci_mmap_state {
    pci_mmap_io = 0,
    pci_mmap_mem = 1
} ;
#line 89
enum __anonenum_101 {
    PCI_STD_RESOURCES = 0,
    PCI_STD_RESOURCE_END = 5,
    PCI_ROM_RESOURCE = 6,
    PCI_BRIDGE_RESOURCES = 7,
    PCI_BRIDGE_RESOURCE_END = 10,
    PCI_NUM_RESOURCES = 11,
    DEVICE_COUNT_RESOURCE = 12
} ;
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
typedef int pci_power_t;
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 137
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
typedef unsigned int pcie_reset_state_t;
#line 150
enum pcie_reset_state {
    pcie_deassert_reset = 1,
    pcie_warm_reset = 2,
    pcie_hot_reset = 3
} ;
#line 161 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 162
enum pci_dev_flags {
    PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
    PCI_DEV_FLAGS_NO_D3 = 2
} ;
#line 171
enum pci_irq_reroute_variant {
    INTEL_IRQ_REROUTE_VARIANT = 1,
    MAX_IRQ_REROUTE_VARIANTS = 3
} ;
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 177
enum pci_bus_flags {
    PCI_BUS_FLAGS_NO_MSI = 1,
    PCI_BUS_FLAGS_NO_MMRBC = 2
} ;
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_cap_saved_state {
   struct hlist_node next ;
   char cap_nr ;
   u32 data[0] ;
};
#line 188
struct pcie_link_state;
#line 188
struct pcie_link_state;
#line 189
struct pci_vpd;
#line 189
struct pci_vpd;
#line 190
struct pci_sriov;
#line 190
struct pci_sriov;
#line 195
struct pci_driver;
#line 195
struct proc_dir_entry;
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   struct bin_attribute *res_attr_wc[12] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
};
#line 327
struct pci_ops;
#line 327 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[16] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 391 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
#line 405 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_bus_region {
   resource_size_t start ;
   resource_size_t end ;
};
#line 410 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 422 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 424
enum pci_ers_result {
    PCI_ERS_RESULT_NONE = 1,
    PCI_ERS_RESULT_CAN_RECOVER = 2,
    PCI_ERS_RESULT_NEED_RESET = 3,
    PCI_ERS_RESULT_DISCONNECT = 4,
    PCI_ERS_RESULT_RECOVERED = 5
} ;
#line 442 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
#line 462
struct module;
#line 463 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 606
enum pci_lost_interrupt_reason {
    PCI_LOST_IRQ_NO_INFORMATION = 0,
    PCI_LOST_IRQ_DISABLE_MSI = 1,
    PCI_LOST_IRQ_DISABLE_MSIX = 2,
    PCI_LOST_IRQ_DISABLE_ACPI = 3
} ;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dmapool.h"
struct dma_pool;
#line 810 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
enum pci_dma_burst_strategy {
    PCI_DMA_BURST_INFINITY = 0,
    PCI_DMA_BURST_BOUNDARY = 1,
    PCI_DMA_BURST_MULTIPLE = 2
} ;
#line 819 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_node;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
struct prio_tree_iter {
   struct prio_tree_node *cur ;
   unsigned long mask ;
   unsigned long value ;
   int size_level ;
   struct prio_tree_root *root ;
   unsigned long r_index ;
   unsigned long h_index ;
};
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
struct task_struct;
#line 48
struct task_struct;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-debug-flags.h"
enum page_debug_flags {
    PAGE_DEBUG_FLAG_POISON = 0
} ;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct address_space;
#line 23
struct address_space;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
typedef atomic_long_t mm_counter_t;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_102 {
   unsigned long index ;
   void *freelist ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_104 {
   unsigned long private ;
   struct address_space *mapping ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_103 {
   struct __anonstruct____missing_field_name_104 __annonCompField17 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_106 {
   u16 inuse ;
   u16 objects ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion____missing_field_name_105 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_106 __annonCompField19 ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_105 __annonCompField20 ;
   union __anonunion____missing_field_name_103 __annonCompField18 ;
   union __anonunion____missing_field_name_102 __annonCompField16 ;
   struct list_head lru ;
};
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct vm_region {
   struct rb_node vm_rb ;
   unsigned long vm_flags ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   unsigned long vm_top ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   atomic_t vm_usage ;
};
#line 126
struct vm_operations_struct;
#line 126
struct anon_vma;
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct __anonstruct_vm_set_108 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
union __anonunion_shared_107 {
   struct __anonstruct_vm_set_108 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_107 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
#line 183 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[42] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
struct mempolicy;
#line 17
struct mempolicy;
#line 18
struct anon_vma;
#line 19
struct file_ra_state;
#line 19
struct file_ra_state;
#line 20
struct user_struct;
#line 20
struct user_struct;
#line 21
struct writeback_control;
#line 21
struct writeback_control;
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_32.h"
struct mm_struct;
#line 27
struct vm_area_struct;
#line 547 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
struct vm_area_struct;
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
};
#line 225
struct mmu_gather;
#line 225
struct mmu_gather;
#line 226
struct inode;
#line 226
struct inode;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
enum pageflags {
    PG_locked = 0,
    PG_error = 1,
    PG_referenced = 2,
    PG_uptodate = 3,
    PG_dirty = 4,
    PG_lru = 5,
    PG_active = 6,
    PG_slab = 7,
    PG_owner_priv_1 = 8,
    PG_arch_1 = 9,
    PG_reserved = 10,
    PG_private = 11,
    PG_private_2 = 12,
    PG_writeback = 13,
    PG_head = 14,
    PG_tail = 15,
    PG_swapcache = 16,
    PG_mappedtodisk = 17,
    PG_reclaim = 18,
    PG_buddy = 19,
    PG_swapbacked = 20,
    PG_unevictable = 21,
    PG_mlocked = 22,
    __NR_PAGEFLAGS = 23,
    PG_checked = 8,
    PG_fscache = 12,
    PG_pinned = 8,
    PG_savepinned = 4,
    PG_slob_page = 6,
    PG_slob_free = 11,
    PG_slub_frozen = 6,
    PG_slub_debug = 1
} ;
#line 190
struct page;
#line 333 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
typedef void compound_page_dtor(struct page * );
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
enum vm_event_item {
    PGPGIN = 0,
    PGPGOUT = 1,
    PSWPIN = 2,
    PSWPOUT = 3,
    PGALLOC_DMA = 4,
    PGALLOC_NORMAL = 5,
    PGALLOC_HIGH = 6,
    PGALLOC_MOVABLE = 7,
    PGFREE = 8,
    PGACTIVATE = 9,
    PGDEACTIVATE = 10,
    PGFAULT = 11,
    PGMAJFAULT = 12,
    PGREFILL_DMA = 13,
    PGREFILL_NORMAL = 14,
    PGREFILL_HIGH = 15,
    PGREFILL_MOVABLE = 16,
    PGSTEAL_DMA = 17,
    PGSTEAL_NORMAL = 18,
    PGSTEAL_HIGH = 19,
    PGSTEAL_MOVABLE = 20,
    PGSCAN_KSWAPD_DMA = 21,
    PGSCAN_KSWAPD_NORMAL = 22,
    PGSCAN_KSWAPD_HIGH = 23,
    PGSCAN_KSWAPD_MOVABLE = 24,
    PGSCAN_DIRECT_DMA = 25,
    PGSCAN_DIRECT_NORMAL = 26,
    PGSCAN_DIRECT_HIGH = 27,
    PGSCAN_DIRECT_MOVABLE = 28,
    PGINODESTEAL = 29,
    SLABS_SCANNED = 30,
    KSWAPD_STEAL = 31,
    KSWAPD_INODESTEAL = 32,
    PAGEOUTRUN = 33,
    ALLOCSTALL = 34,
    PGROTATED = 35,
    HTLB_BUDDY_PGALLOC = 36,
    HTLB_BUDDY_PGALLOC_FAIL = 37,
    UNEVICTABLE_PGCULLED = 38,
    UNEVICTABLE_PGSCANNED = 39,
    UNEVICTABLE_PGRESCUED = 40,
    UNEVICTABLE_PGMLOCKED = 41,
    UNEVICTABLE_PGMUNLOCKED = 42,
    UNEVICTABLE_PGCLEARED = 43,
    UNEVICTABLE_PGSTRANDED = 44,
    UNEVICTABLE_MLOCKFREED = 45,
    NR_VM_EVENT_ITEMS = 46
} ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
struct vm_event_state {
   unsigned long event[46] ;
};
#line 746 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
struct zap_details {
   struct vm_area_struct *nonlinear_vma ;
   struct address_space *check_mapping ;
   unsigned long first_index ;
   unsigned long last_index ;
   spinlock_t *i_mmap_lock ;
   unsigned long truncate_count ;
};
#line 777 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
struct mm_walk {
   int (*pgd_entry)(pgd_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pud_entry)(pud_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pmd_entry)(pmd_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pte_entry)(pte_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pte_hole)(unsigned long  , unsigned long  , struct mm_walk * ) ;
   struct mm_struct *mm ;
   void *private ;
};
#line 879 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
struct shrinker {
   int (*shrink)(int nr_to_scan , gfp_t gfp_mask ) ;
   int seeks ;
   struct list_head list ;
   long nr ;
};
#line 1042 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
typedef int (*work_fn_t)(unsigned long  , unsigned long  , void * );
#line 1248 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
typedef int (*pte_fn_t)(pte_t *pte , pgtable_t token , unsigned long addr , void *data );
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pci.h"
struct pci_sysdata {
   int domain ;
   int node ;
};
#line 64
struct irq_routing_table;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bug.h"
enum bug_trap_type {
    BUG_TRAP_TYPE_NONE = 0,
    BUG_TRAP_TYPE_WARN = 1,
    BUG_TRAP_TYPE_BUG = 2
} ;
#line 13
struct pt_regs;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-attrs.h"
enum dma_attr {
    DMA_ATTR_WRITE_BARRIER = 0,
    DMA_ATTR_WEAK_ORDERING = 1,
    DMA_ATTR_MAX = 2
} ;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-attrs.h"
struct dma_attrs {
   unsigned long flags[((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
typedef struct scatterlist *sg_alloc_fn(unsigned int  , gfp_t  );
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
typedef void sg_free_fn(struct scatterlist * , unsigned int  );
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
struct sg_mapping_iter {
   struct page *page ;
   void *addr ;
   size_t length ;
   size_t consumed ;
   struct scatterlist *__sg ;
   unsigned int __nents ;
   unsigned int __offset ;
   unsigned int __flags ;
};
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
struct dma_map_ops {
   void *(*alloc_coherent)(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                           gfp_t gfp ) ;
   void (*free_coherent)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
   dma_addr_t (*map_page)(struct device *dev , struct page *page , unsigned long offset ,
                          size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
   void (*unmap_page)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
   int (*map_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                 struct dma_attrs *attrs ) ;
   void (*unmap_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                    struct dma_attrs *attrs ) ;
   void (*sync_single_for_cpu)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                               enum dma_data_direction dir ) ;
   void (*sync_single_for_device)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                                  enum dma_data_direction dir ) ;
   void (*sync_single_range_for_cpu)(struct device *dev , dma_addr_t dma_handle ,
                                     unsigned long offset , size_t size , enum dma_data_direction dir ) ;
   void (*sync_single_range_for_device)(struct device *dev , dma_addr_t dma_handle ,
                                        unsigned long offset , size_t size , enum dma_data_direction dir ) ;
   void (*sync_sg_for_cpu)(struct device *dev , struct scatterlist *sg , int nents ,
                           enum dma_data_direction dir ) ;
   void (*sync_sg_for_device)(struct device *dev , struct scatterlist *sg , int nents ,
                              enum dma_data_direction dir ) ;
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   int (*dma_supported)(struct device *dev , u64 mask ) ;
   int is_phys ;
};
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
struct device;
#line 26
struct scatterlist;
#line 27
struct bus_type;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swiotlb.h"
struct device;
#line 7
struct dma_attrs;
#line 8
struct scatterlist;
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
struct dma_attrs;
#line 1157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
struct pci_fixup {
   u16 vendor ;
   u16 device ;
   void (*hook)(struct pci_dev *dev ) ;
};
#line 1162
enum pci_fixup_pass {
    pci_fixup_early = 0,
    pci_fixup_header = 1,
    pci_fixup_final = 2,
    pci_fixup_enable = 3,
    pci_fixup_resume = 4,
    pci_fixup_suspend = 5,
    pci_fixup_resume_early = 6
} ;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqnr.h"
struct irq_desc;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_param {
   int sched_priority ;
};
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct task_struct;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
typedef struct __user_cap_header_struct *cap_user_header_t;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
typedef struct __user_cap_data_struct *cap_user_data_t;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct __anonstruct_data_109 {
   __le32 permitted ;
   __le32 inheritable ;
};
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct vfs_cap_data {
   __le32 magic_etc ;
   struct __anonstruct_data_109 data[2] ;
};
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
struct cpu_vfs_cap_data {
   __u32 magic_etc ;
   kernel_cap_t permitted ;
   kernel_cap_t inheritable ;
};
#line 568
struct dentry;
#line 568
struct dentry;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/cputime.h"
typedef u64 cputime64_t;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct ipc_perm {
   __kernel_key_t key ;
   __kernel_uid_t uid ;
   __kernel_gid_t gid ;
   __kernel_uid_t cuid ;
   __kernel_gid_t cgid ;
   __kernel_mode_t mode ;
   unsigned short seq ;
};
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ipcbuf.h"
struct ipc64_perm {
   __kernel_key_t key ;
   __kernel_uid32_t uid ;
   __kernel_gid32_t gid ;
   __kernel_uid32_t cuid ;
   __kernel_gid32_t cgid ;
   __kernel_mode_t mode ;
   unsigned short __pad1 ;
   unsigned short seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct msgbuf;
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct ipc_kludge {
   struct msgbuf *msgp ;
   long msgtyp ;
};
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ipc.h"
struct kern_ipc_perm {
   spinlock_t lock ;
   int deleted ;
   int id ;
   key_t key ;
   uid_t uid ;
   gid_t gid ;
   uid_t cuid ;
   gid_t cgid ;
   mode_t mode ;
   unsigned long seq ;
   void *security ;
};
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_undo;
#line 23
struct sem_queue;
#line 23
struct sem;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned short sem_nsems ;
};
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sembuf.h"
struct semid64_ds {
   struct ipc64_perm sem_perm ;
   __kernel_time_t sem_otime ;
   unsigned long __unused1 ;
   __kernel_time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 45
struct seminfo;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
   void *__pad ;
};
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 83
struct task_struct;
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem {
   int semval ;
   int sempid ;
};
#line 92 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_array {
   struct kern_ipc_perm sem_perm ;
   time_t sem_otime ;
   time_t sem_ctime ;
   struct sem *sem_base ;
   struct list_head sem_pending ;
   struct list_head list_id ;
   unsigned long sem_nsems ;
};
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_queue {
   struct list_head list ;
   struct task_struct *sleeper ;
   struct sem_undo *undo ;
   int pid ;
   int status ;
   struct sembuf *sops ;
   int nsops ;
   int alter ;
};
#line 117
struct sem_undo_list;
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_undo {
   struct list_head list_proc ;
   struct rcu_head rcu ;
   struct sem_undo_list *ulp ;
   struct list_head list_id ;
   int semid ;
   short *semadj ;
};
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct siginfo;
#line 10
struct siginfo;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
typedef unsigned long old_sigset_t;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_110 {
   unsigned long sig[1] ;
};
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_110 sigset_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef void __signalfn_t(int  );
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef void __restorefn_t(void);
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/signal.h"
typedef __restorefn_t *__sigrestore_t;
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
typedef struct sigaltstack stack_t;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_112 {
   long _band ;
   int _fd ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_113 {
   void *_addr ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_114 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__rt_115 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__timer_116 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__kill_117 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
union __anonunion__sifields_111 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_117 _kill ;
   struct __anonstruct__timer_116 _timer ;
   struct __anonstruct__rt_115 _rt ;
   struct __anonstruct__sigchld_114 _sigchld ;
   struct __anonstruct__sigfault_113 _sigfault ;
   struct __anonstruct__sigpoll_112 _sigpoll ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_111 _sifields ;
};
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct __anonstruct__sigev_thread_119 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
union __anonunion__sigev_un_118 {
   int _pad[(64UL - (sizeof(int ) * 2UL + sizeof(sigval_t ))) / sizeof(int )] ;
   int _tid ;
   struct __anonstruct__sigev_thread_119 _sigev_thread ;
};
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_118 _sigev_un ;
};
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
typedef struct sigevent sigevent_t;
#line 274
struct siginfo;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
struct sigqueue {
   struct list_head list ;
   int flags ;
   siginfo_t info ;
   struct user_struct *user ;
};
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 242
struct pt_regs;
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/path.h"
struct dentry;
#line 5
struct vfsmount;
#line 5
struct vfsmount;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 50
struct pid_namespace;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 100
struct pid_namespace;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
struct percpu_counter {
   spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_global {
   int shift ;
   struct percpu_counter events ;
};
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_descriptor {
   int index ;
   struct prop_global pg[2] ;
   struct mutex mutex ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_local_percpu {
   struct percpu_counter events ;
   int shift ;
   unsigned long period ;
   spinlock_t lock ;
};
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
struct __anonstruct_seccomp_t_120 {
   int mode ;
};
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_120 seccomp_t;
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 88 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct plist_head plist ;
};
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rtmutex.h"
struct rt_mutex {
   spinlock_t wait_lock ;
   struct plist_head wait_list ;
   struct task_struct *owner ;
};
#line 38
struct rt_mutex_waiter;
#line 38
struct rt_mutex_waiter;
#line 39
struct hrtimer_sleeper;
#line 39
struct hrtimer_sleeper;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
struct task_struct;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_clock_base;
#line 26
struct hrtimer_clock_base;
#line 27
struct hrtimer_cpu_base;
#line 27
struct hrtimer_cpu_base;
#line 32
enum hrtimer_mode {
    HRTIMER_MODE_ABS = 0,
    HRTIMER_MODE_REL = 1
} ;
#line 40
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_sleeper {
   struct hrtimer timer ;
   struct task_struct *task ;
};
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
   ktime_t expires_next ;
   int hres_active ;
   unsigned long nr_events ;
};
#line 244
struct clock_event_device;
#line 244
struct clock_event_device;
#line 310
struct tick_device;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/task_io_accounting.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct file;
#line 33
struct completion;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct __sysctl_args {
   int *name ;
   int nlen ;
   void *oldval ;
   size_t *oldlenp ;
   void *newval ;
   size_t newlen ;
   unsigned long __unused[4] ;
};
#line 60
enum __anonenum_121 {
    CTL_KERN = 1,
    CTL_VM = 2,
    CTL_NET = 3,
    CTL_PROC = 4,
    CTL_FS = 5,
    CTL_DEBUG = 6,
    CTL_DEV = 7,
    CTL_BUS = 8,
    CTL_ABI = 9,
    CTL_CPU = 10,
    CTL_ARLAN = 254,
    CTL_S390DBF = 5677,
    CTL_SUNRPC = 7249,
    CTL_PM = 9899,
    CTL_FRV = 9898
} ;
#line 80
enum __anonenum_122 {
    CTL_BUS_ISA = 1
} ;
#line 86
enum __anonenum_123 {
    INOTIFY_MAX_USER_INSTANCES = 1,
    INOTIFY_MAX_USER_WATCHES = 2,
    INOTIFY_MAX_QUEUED_EVENTS = 3
} ;
#line 94
enum __anonenum_124 {
    KERN_OSTYPE = 1,
    KERN_OSRELEASE = 2,
    KERN_OSREV = 3,
    KERN_VERSION = 4,
    KERN_SECUREMASK = 5,
    KERN_PROF = 6,
    KERN_NODENAME = 7,
    KERN_DOMAINNAME = 8,
    KERN_PANIC = 15,
    KERN_REALROOTDEV = 16,
    KERN_SPARC_REBOOT = 21,
    KERN_CTLALTDEL = 22,
    KERN_PRINTK = 23,
    KERN_NAMETRANS = 24,
    KERN_PPC_HTABRECLAIM = 25,
    KERN_PPC_ZEROPAGED = 26,
    KERN_PPC_POWERSAVE_NAP = 27,
    KERN_MODPROBE = 28,
    KERN_SG_BIG_BUFF = 29,
    KERN_ACCT = 30,
    KERN_PPC_L2CR = 31,
    KERN_RTSIGNR = 32,
    KERN_RTSIGMAX = 33,
    KERN_SHMMAX = 34,
    KERN_MSGMAX = 35,
    KERN_MSGMNB = 36,
    KERN_MSGPOOL = 37,
    KERN_SYSRQ = 38,
    KERN_MAX_THREADS = 39,
    KERN_RANDOM = 40,
    KERN_SHMALL = 41,
    KERN_MSGMNI = 42,
    KERN_SEM = 43,
    KERN_SPARC_STOP_A = 44,
    KERN_SHMMNI = 45,
    KERN_OVERFLOWUID = 46,
    KERN_OVERFLOWGID = 47,
    KERN_SHMPATH = 48,
    KERN_HOTPLUG = 49,
    KERN_IEEE_EMULATION_WARNINGS = 50,
    KERN_S390_USER_DEBUG_LOGGING = 51,
    KERN_CORE_USES_PID = 52,
    KERN_TAINTED = 53,
    KERN_CADPID = 54,
    KERN_PIDMAX = 55,
    KERN_CORE_PATTERN = 56,
    KERN_PANIC_ON_OOPS = 57,
    KERN_HPPA_PWRSW = 58,
    KERN_HPPA_UNALIGNED = 59,
    KERN_PRINTK_RATELIMIT = 60,
    KERN_PRINTK_RATELIMIT_BURST = 61,
    KERN_PTY = 62,
    KERN_NGROUPS_MAX = 63,
    KERN_SPARC_SCONS_PWROFF = 64,
    KERN_HZ_TIMER = 65,
    KERN_UNKNOWN_NMI_PANIC = 66,
    KERN_BOOTLOADER_TYPE = 67,
    KERN_RANDOMIZE = 68,
    KERN_SETUID_DUMPABLE = 69,
    KERN_SPIN_RETRY = 70,
    KERN_ACPI_VIDEO_FLAGS = 71,
    KERN_IA64_UNALIGNED = 72,
    KERN_COMPAT_LOG = 73,
    KERN_MAX_LOCK_DEPTH = 74,
    KERN_NMI_WATCHDOG = 75,
    KERN_PANIC_ON_NMI = 76
} ;
#line 171
enum __anonenum_125 {
    VM_UNUSED1 = 1,
    VM_UNUSED2 = 2,
    VM_UNUSED3 = 3,
    VM_UNUSED4 = 4,
    VM_OVERCOMMIT_MEMORY = 5,
    VM_UNUSED5 = 6,
    VM_UNUSED7 = 7,
    VM_UNUSED8 = 8,
    VM_UNUSED9 = 9,
    VM_PAGE_CLUSTER = 10,
    VM_DIRTY_BACKGROUND = 11,
    VM_DIRTY_RATIO = 12,
    VM_DIRTY_WB_CS = 13,
    VM_DIRTY_EXPIRE_CS = 14,
    VM_NR_PDFLUSH_THREADS = 15,
    VM_OVERCOMMIT_RATIO = 16,
    VM_PAGEBUF = 17,
    VM_HUGETLB_PAGES = 18,
    VM_SWAPPINESS = 19,
    VM_LOWMEM_RESERVE_RATIO = 20,
    VM_MIN_FREE_KBYTES = 21,
    VM_MAX_MAP_COUNT = 22,
    VM_LAPTOP_MODE = 23,
    VM_BLOCK_DUMP = 24,
    VM_HUGETLB_GROUP = 25,
    VM_VFS_CACHE_PRESSURE = 26,
    VM_LEGACY_VA_LAYOUT = 27,
    VM_SWAP_TOKEN_TIMEOUT = 28,
    VM_DROP_PAGECACHE = 29,
    VM_PERCPU_PAGELIST_FRACTION = 30,
    VM_ZONE_RECLAIM_MODE = 31,
    VM_MIN_UNMAPPED = 32,
    VM_PANIC_ON_OOM = 33,
    VM_VDSO_ENABLED = 34,
    VM_MIN_SLAB = 35
} ;
#line 212
enum __anonenum_126 {
    NET_CORE = 1,
    NET_ETHER = 2,
    NET_802 = 3,
    NET_UNIX = 4,
    NET_IPV4 = 5,
    NET_IPX = 6,
    NET_ATALK = 7,
    NET_NETROM = 8,
    NET_AX25 = 9,
    NET_BRIDGE = 10,
    NET_ROSE = 11,
    NET_IPV6 = 12,
    NET_X25 = 13,
    NET_TR = 14,
    NET_DECNET = 15,
    NET_ECONET = 16,
    NET_SCTP = 17,
    NET_LLC = 18,
    NET_NETFILTER = 19,
    NET_DCCP = 20,
    NET_IRDA = 412
} ;
#line 238
enum __anonenum_127 {
    RANDOM_POOLSIZE = 1,
    RANDOM_ENTROPY_COUNT = 2,
    RANDOM_READ_THRESH = 3,
    RANDOM_WRITE_THRESH = 4,
    RANDOM_BOOT_ID = 5,
    RANDOM_UUID = 6
} ;
#line 249
enum __anonenum_128 {
    PTY_MAX = 1,
    PTY_NR = 2
} ;
#line 256
enum __anonenum_129 {
    BUS_ISA_MEM_BASE = 1,
    BUS_ISA_PORT_BASE = 2,
    BUS_ISA_PORT_SHIFT = 3
} ;
#line 264
enum __anonenum_130 {
    NET_CORE_WMEM_MAX = 1,
    NET_CORE_RMEM_MAX = 2,
    NET_CORE_WMEM_DEFAULT = 3,
    NET_CORE_RMEM_DEFAULT = 4,
    NET_CORE_MAX_BACKLOG = 6,
    NET_CORE_FASTROUTE = 7,
    NET_CORE_MSG_COST = 8,
    NET_CORE_MSG_BURST = 9,
    NET_CORE_OPTMEM_MAX = 10,
    NET_CORE_HOT_LIST_LENGTH = 11,
    NET_CORE_DIVERT_VERSION = 12,
    NET_CORE_NO_CONG_THRESH = 13,
    NET_CORE_NO_CONG = 14,
    NET_CORE_LO_CONG = 15,
    NET_CORE_MOD_CONG = 16,
    NET_CORE_DEV_WEIGHT = 17,
    NET_CORE_SOMAXCONN = 18,
    NET_CORE_BUDGET = 19,
    NET_CORE_AEVENT_ETIME = 20,
    NET_CORE_AEVENT_RSEQTH = 21,
    NET_CORE_WARNINGS = 22
} ;
#line 296
enum __anonenum_131 {
    NET_UNIX_DESTROY_DELAY = 1,
    NET_UNIX_DELETE_DELAY = 2,
    NET_UNIX_MAX_DGRAM_QLEN = 3
} ;
#line 304
enum __anonenum_132 {
    NET_NF_CONNTRACK_MAX = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_NF_CONNTRACK_BUCKETS = 14,
    NET_NF_CONNTRACK_LOG_INVALID = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_NF_CONNTRACK_COUNT = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
    NET_NF_CONNTRACK_CHECKSUM = 32
} ;
#line 341
enum __anonenum_133 {
    NET_IPV4_FORWARD = 8,
    NET_IPV4_DYNADDR = 9,
    NET_IPV4_CONF = 16,
    NET_IPV4_NEIGH = 17,
    NET_IPV4_ROUTE = 18,
    NET_IPV4_FIB_HASH = 19,
    NET_IPV4_NETFILTER = 20,
    NET_IPV4_TCP_TIMESTAMPS = 33,
    NET_IPV4_TCP_WINDOW_SCALING = 34,
    NET_IPV4_TCP_SACK = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
    NET_IPV4_DEFAULT_TTL = 37,
    NET_IPV4_AUTOCONFIG = 38,
    NET_IPV4_NO_PMTU_DISC = 39,
    NET_IPV4_TCP_SYN_RETRIES = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH = 41,
    NET_IPV4_IPFRAG_LOW_THRESH = 42,
    NET_IPV4_IPFRAG_TIME = 43,
    NET_IPV4_TCP_MAX_KA_PROBES = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
    NET_IPV4_TCP_RETRIES1 = 47,
    NET_IPV4_TCP_RETRIES2 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT = 49,
    NET_IPV4_IP_MASQ_DEBUG = 50,
    NET_TCP_SYNCOOKIES = 51,
    NET_TCP_STDURG = 52,
    NET_TCP_RFC1337 = 53,
    NET_TCP_SYN_TAILDROP = 54,
    NET_TCP_MAX_SYN_BACKLOG = 55,
    NET_IPV4_LOCAL_PORT_RANGE = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
    NET_TCP_TW_RECYCLE = 66,
    NET_IPV4_ALWAYS_DEFRAG = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
    NET_IPV4_INET_PEER_THRESHOLD = 69,
    NET_IPV4_INET_PEER_MINTTL = 70,
    NET_IPV4_INET_PEER_MAXTTL = 71,
    NET_IPV4_INET_PEER_GC_MINTIME = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME = 73,
    NET_TCP_ORPHAN_RETRIES = 74,
    NET_TCP_ABORT_ON_OVERFLOW = 75,
    NET_TCP_SYNACK_RETRIES = 76,
    NET_TCP_MAX_ORPHANS = 77,
    NET_TCP_MAX_TW_BUCKETS = 78,
    NET_TCP_FACK = 79,
    NET_TCP_REORDERING = 80,
    NET_TCP_ECN = 81,
    NET_TCP_DSACK = 82,
    NET_TCP_MEM = 83,
    NET_TCP_WMEM = 84,
    NET_TCP_RMEM = 85,
    NET_TCP_APP_WIN = 86,
    NET_TCP_ADV_WIN_SCALE = 87,
    NET_IPV4_NONLOCAL_BIND = 88,
    NET_IPV4_ICMP_RATELIMIT = 89,
    NET_IPV4_ICMP_RATEMASK = 90,
    NET_TCP_TW_REUSE = 91,
    NET_TCP_FRTO = 92,
    NET_TCP_LOW_LATENCY = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
    NET_IPV4_IGMP_MAX_MSF = 96,
    NET_TCP_NO_METRICS_SAVE = 97,
    NET_TCP_DEFAULT_WIN_SCALE = 105,
    NET_TCP_MODERATE_RCVBUF = 106,
    NET_TCP_TSO_WIN_DIVISOR = 107,
    NET_TCP_BIC_BETA = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
    NET_TCP_CONG_CONTROL = 110,
    NET_TCP_ABC = 111,
    NET_IPV4_IPFRAG_MAX_DIST = 112,
    NET_TCP_MTU_PROBING = 113,
    NET_TCP_BASE_MSS = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
    NET_TCP_DMA_COPYBREAK = 116,
    NET_TCP_SLOW_START_AFTER_IDLE = 117,
    NET_CIPSOV4_CACHE_ENABLE = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
    NET_CIPSOV4_RBM_OPTFMT = 120,
    NET_CIPSOV4_RBM_STRICTVALID = 121,
    NET_TCP_AVAIL_CONG_CONTROL = 122,
    NET_TCP_ALLOWED_CONG_CONTROL = 123,
    NET_TCP_MAX_SSTHRESH = 124,
    NET_TCP_FRTO_RESPONSE = 125
} ;
#line 440
enum __anonenum_134 {
    NET_IPV4_ROUTE_FLUSH = 1,
    NET_IPV4_ROUTE_MIN_DELAY = 2,
    NET_IPV4_ROUTE_MAX_DELAY = 3,
    NET_IPV4_ROUTE_GC_THRESH = 4,
    NET_IPV4_ROUTE_MAX_SIZE = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT = 7,
    NET_IPV4_ROUTE_GC_INTERVAL = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
    NET_IPV4_ROUTE_ERROR_COST = 12,
    NET_IPV4_ROUTE_ERROR_BURST = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES = 15,
    NET_IPV4_ROUTE_MIN_PMTU = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19
} ;
#line 462
enum __anonenum_135 {
    NET_PROTO_CONF_ALL = -2,
    NET_PROTO_CONF_DEFAULT = -3
} ;
#line 470
enum __anonenum_136 {
    NET_IPV4_CONF_FORWARDING = 1,
    NET_IPV4_CONF_MC_FORWARDING = 2,
    NET_IPV4_CONF_PROXY_ARP = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS = 5,
    NET_IPV4_CONF_SEND_REDIRECTS = 6,
    NET_IPV4_CONF_SHARED_MEDIA = 7,
    NET_IPV4_CONF_RP_FILTER = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
    NET_IPV4_CONF_BOOTP_RELAY = 10,
    NET_IPV4_CONF_LOG_MARTIANS = 11,
    NET_IPV4_CONF_TAG = 12,
    NET_IPV4_CONF_ARPFILTER = 13,
    NET_IPV4_CONF_MEDIUM_ID = 14,
    NET_IPV4_CONF_NOXFRM = 15,
    NET_IPV4_CONF_NOPOLICY = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE = 18,
    NET_IPV4_CONF_ARP_IGNORE = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
    NET_IPV4_CONF_ARP_ACCEPT = 21,
    NET_IPV4_CONF_ARP_NOTIFY = 22,
    __NET_IPV4_CONF_MAX = 23
} ;
#line 498
enum __anonenum_137 {
    NET_IPV4_NF_CONNTRACK_MAX = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_IPV4_NF_CONNTRACK_COUNT = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM = 28
} ;
#line 531
enum __anonenum_138 {
    NET_IPV6_CONF = 16,
    NET_IPV6_NEIGH = 17,
    NET_IPV6_ROUTE = 18,
    NET_IPV6_ICMP = 19,
    NET_IPV6_BINDV6ONLY = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH = 22,
    NET_IPV6_IP6FRAG_TIME = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
    NET_IPV6_MLD_MAX_MSF = 25
} ;
#line 544
enum __anonenum_139 {
    NET_IPV6_ROUTE_FLUSH = 1,
    NET_IPV6_ROUTE_GC_THRESH = 2,
    NET_IPV6_ROUTE_MAX_SIZE = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT = 5,
    NET_IPV6_ROUTE_GC_INTERVAL = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10
} ;
#line 557
enum __anonenum_140 {
    NET_IPV6_FORWARDING = 1,
    NET_IPV6_HOP_LIMIT = 2,
    NET_IPV6_MTU = 3,
    NET_IPV6_ACCEPT_RA = 4,
    NET_IPV6_ACCEPT_REDIRECTS = 5,
    NET_IPV6_AUTOCONF = 6,
    NET_IPV6_DAD_TRANSMITS = 7,
    NET_IPV6_RTR_SOLICITS = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
    NET_IPV6_RTR_SOLICIT_DELAY = 10,
    NET_IPV6_USE_TEMPADDR = 11,
    NET_IPV6_TEMP_VALID_LFT = 12,
    NET_IPV6_TEMP_PREFERED_LFT = 13,
    NET_IPV6_REGEN_MAX_RETRY = 14,
    NET_IPV6_MAX_DESYNC_FACTOR = 15,
    NET_IPV6_MAX_ADDRESSES = 16,
    NET_IPV6_FORCE_MLD_VERSION = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR = 18,
    NET_IPV6_ACCEPT_RA_PINFO = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
    NET_IPV6_RTR_PROBE_INTERVAL = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
    NET_IPV6_PROXY_NDP = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
    __NET_IPV6_MAX = 26
} ;
#line 586
enum __anonenum_141 {
    NET_IPV6_ICMP_RATELIMIT = 1
} ;
#line 591
enum __anonenum_142 {
    NET_NEIGH_MCAST_SOLICIT = 1,
    NET_NEIGH_UCAST_SOLICIT = 2,
    NET_NEIGH_APP_SOLICIT = 3,
    NET_NEIGH_RETRANS_TIME = 4,
    NET_NEIGH_REACHABLE_TIME = 5,
    NET_NEIGH_DELAY_PROBE_TIME = 6,
    NET_NEIGH_GC_STALE_TIME = 7,
    NET_NEIGH_UNRES_QLEN = 8,
    NET_NEIGH_PROXY_QLEN = 9,
    NET_NEIGH_ANYCAST_DELAY = 10,
    NET_NEIGH_PROXY_DELAY = 11,
    NET_NEIGH_LOCKTIME = 12,
    NET_NEIGH_GC_INTERVAL = 13,
    NET_NEIGH_GC_THRESH1 = 14,
    NET_NEIGH_GC_THRESH2 = 15,
    NET_NEIGH_GC_THRESH3 = 16,
    NET_NEIGH_RETRANS_TIME_MS = 17,
    NET_NEIGH_REACHABLE_TIME_MS = 18,
    __NET_NEIGH_MAX = 19
} ;
#line 614
enum __anonenum_143 {
    NET_DCCP_DEFAULT = 1
} ;
#line 619
enum __anonenum_144 {
    NET_IPX_PPROP_BROADCASTING = 1,
    NET_IPX_FORWARDING = 2
} ;
#line 625
enum __anonenum_145 {
    NET_LLC2 = 1,
    NET_LLC_STATION = 2
} ;
#line 631
enum __anonenum_146 {
    NET_LLC2_TIMEOUT = 1
} ;
#line 636
enum __anonenum_147 {
    NET_LLC_STATION_ACK_TIMEOUT = 1
} ;
#line 641
enum __anonenum_148 {
    NET_LLC2_ACK_TIMEOUT = 1,
    NET_LLC2_P_TIMEOUT = 2,
    NET_LLC2_REJ_TIMEOUT = 3,
    NET_LLC2_BUSY_TIMEOUT = 4
} ;
#line 649
enum __anonenum_149 {
    NET_ATALK_AARP_EXPIRY_TIME = 1,
    NET_ATALK_AARP_TICK_TIME = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
    NET_ATALK_AARP_RESOLVE_TIME = 4
} ;
#line 658
enum __anonenum_150 {
    NET_NETROM_DEFAULT_PATH_QUALITY = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER = 3,
    NET_NETROM_TRANSPORT_TIMEOUT = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
    NET_NETROM_ROUTING_CONTROL = 10,
    NET_NETROM_LINK_FAILS_COUNT = 11,
    NET_NETROM_RESET = 12
} ;
#line 674
enum __anonenum_151 {
    NET_AX25_IP_DEFAULT_MODE = 1,
    NET_AX25_DEFAULT_MODE = 2,
    NET_AX25_BACKOFF_TYPE = 3,
    NET_AX25_CONNECT_MODE = 4,
    NET_AX25_STANDARD_WINDOW = 5,
    NET_AX25_EXTENDED_WINDOW = 6,
    NET_AX25_T1_TIMEOUT = 7,
    NET_AX25_T2_TIMEOUT = 8,
    NET_AX25_T3_TIMEOUT = 9,
    NET_AX25_IDLE_TIMEOUT = 10,
    NET_AX25_N2 = 11,
    NET_AX25_PACLEN = 12,
    NET_AX25_PROTOCOL = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT = 14
} ;
#line 692
enum __anonenum_152 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_ROSE_ROUTING_CONTROL = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT = 7,
    NET_ROSE_MAX_VCS = 8,
    NET_ROSE_WINDOW_SIZE = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT = 10
} ;
#line 706
enum __anonenum_153 {
    NET_X25_RESTART_REQUEST_TIMEOUT = 1,
    NET_X25_CALL_REQUEST_TIMEOUT = 2,
    NET_X25_RESET_REQUEST_TIMEOUT = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_X25_FORWARD = 6
} ;
#line 716
enum __anonenum_154 {
    NET_TR_RIF_TIMEOUT = 1
} ;
#line 722
enum __anonenum_155 {
    NET_DECNET_NODE_TYPE = 1,
    NET_DECNET_NODE_ADDRESS = 2,
    NET_DECNET_NODE_NAME = 3,
    NET_DECNET_DEFAULT_DEVICE = 4,
    NET_DECNET_TIME_WAIT = 5,
    NET_DECNET_DN_COUNT = 6,
    NET_DECNET_DI_COUNT = 7,
    NET_DECNET_DR_COUNT = 8,
    NET_DECNET_DST_GC_INTERVAL = 9,
    NET_DECNET_CONF = 10,
    NET_DECNET_NO_FC_MAX_CWND = 11,
    NET_DECNET_MEM = 12,
    NET_DECNET_RMEM = 13,
    NET_DECNET_WMEM = 14,
    NET_DECNET_DEBUG_LEVEL = 255
} ;
#line 741
enum __anonenum_156 {
    NET_DECNET_CONF_LOOPBACK = -2,
    NET_DECNET_CONF_DDCMP = -3,
    NET_DECNET_CONF_PPP = -4,
    NET_DECNET_CONF_X25 = -5,
    NET_DECNET_CONF_GRE = -6,
    NET_DECNET_CONF_ETHER = -7
} ;
#line 753
enum __anonenum_157 {
    NET_DECNET_CONF_DEV_PRIORITY = 1,
    NET_DECNET_CONF_DEV_T1 = 2,
    NET_DECNET_CONF_DEV_T2 = 3,
    NET_DECNET_CONF_DEV_T3 = 4,
    NET_DECNET_CONF_DEV_FORWARDING = 5,
    NET_DECNET_CONF_DEV_BLKSIZE = 6,
    NET_DECNET_CONF_DEV_STATE = 7
} ;
#line 764
enum __anonenum_158 {
    NET_SCTP_RTO_INITIAL = 1,
    NET_SCTP_RTO_MIN = 2,
    NET_SCTP_RTO_MAX = 3,
    NET_SCTP_RTO_ALPHA = 4,
    NET_SCTP_RTO_BETA = 5,
    NET_SCTP_VALID_COOKIE_LIFE = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
    NET_SCTP_PATH_MAX_RETRANS = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS = 9,
    NET_SCTP_HB_INTERVAL = 10,
    NET_SCTP_PRESERVE_ENABLE = 11,
    NET_SCTP_MAX_BURST = 12,
    NET_SCTP_ADDIP_ENABLE = 13,
    NET_SCTP_PRSCTP_ENABLE = 14,
    NET_SCTP_SNDBUF_POLICY = 15,
    NET_SCTP_SACK_TIMEOUT = 16,
    NET_SCTP_RCVBUF_POLICY = 17
} ;
#line 785
enum __anonenum_159 {
    NET_BRIDGE_NF_CALL_ARPTABLES = 1,
    NET_BRIDGE_NF_CALL_IPTABLES = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5
} ;
#line 794
enum __anonenum_160 {
    NET_IRDA_DISCOVERY = 1,
    NET_IRDA_DEVNAME = 2,
    NET_IRDA_DEBUG = 3,
    NET_IRDA_FAST_POLL = 4,
    NET_IRDA_DISCOVERY_SLOTS = 5,
    NET_IRDA_DISCOVERY_TIMEOUT = 6,
    NET_IRDA_SLOT_TIMEOUT = 7,
    NET_IRDA_MAX_BAUD_RATE = 8,
    NET_IRDA_MIN_TX_TURN_TIME = 9,
    NET_IRDA_MAX_TX_DATA_SIZE = 10,
    NET_IRDA_MAX_TX_WINDOW = 11,
    NET_IRDA_MAX_NOREPLY_TIME = 12,
    NET_IRDA_WARN_NOREPLY_TIME = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME = 14
} ;
#line 813
enum __anonenum_161 {
    FS_NRINODE = 1,
    FS_STATINODE = 2,
    FS_MAXINODE = 3,
    FS_NRDQUOT = 4,
    FS_MAXDQUOT = 5,
    FS_NRFILE = 6,
    FS_MAXFILE = 7,
    FS_DENTRY = 8,
    FS_NRSUPER = 9,
    FS_MAXSUPER = 10,
    FS_OVERFLOWUID = 11,
    FS_OVERFLOWGID = 12,
    FS_LEASES = 13,
    FS_DIR_NOTIFY = 14,
    FS_LEASE_TIME = 15,
    FS_DQSTATS = 16,
    FS_XFS = 17,
    FS_AIO_NR = 18,
    FS_AIO_MAX_NR = 19,
    FS_INOTIFY = 20,
    FS_OCFS2 = 988
} ;
#line 839
enum __anonenum_162 {
    FS_DQ_LOOKUPS = 1,
    FS_DQ_DROPS = 2,
    FS_DQ_READS = 3,
    FS_DQ_WRITES = 4,
    FS_DQ_CACHE_HITS = 5,
    FS_DQ_ALLOCATED = 6,
    FS_DQ_FREE = 7,
    FS_DQ_SYNCS = 8,
    FS_DQ_WARNINGS = 9
} ;
#line 854
enum __anonenum_163 {
    DEV_CDROM = 1,
    DEV_HWMON = 2,
    DEV_PARPORT = 3,
    DEV_RAID = 4,
    DEV_MAC_HID = 5,
    DEV_SCSI = 6,
    DEV_IPMI = 7
} ;
#line 865
enum __anonenum_164 {
    DEV_CDROM_INFO = 1,
    DEV_CDROM_AUTOCLOSE = 2,
    DEV_CDROM_AUTOEJECT = 3,
    DEV_CDROM_DEBUG = 4,
    DEV_CDROM_LOCK = 5,
    DEV_CDROM_CHECK_MEDIA = 6
} ;
#line 875
enum __anonenum_165 {
    DEV_PARPORT_DEFAULT = -3
} ;
#line 880
enum __anonenum_166 {
    DEV_RAID_SPEED_LIMIT_MIN = 1,
    DEV_RAID_SPEED_LIMIT_MAX = 2
} ;
#line 886
enum __anonenum_167 {
    DEV_PARPORT_DEFAULT_TIMESLICE = 1,
    DEV_PARPORT_DEFAULT_SPINTIME = 2
} ;
#line 892
enum __anonenum_168 {
    DEV_PARPORT_SPINTIME = 1,
    DEV_PARPORT_BASE_ADDR = 2,
    DEV_PARPORT_IRQ = 3,
    DEV_PARPORT_DMA = 4,
    DEV_PARPORT_MODES = 5,
    DEV_PARPORT_DEVICES = 6,
    DEV_PARPORT_AUTOPROBE = 16
} ;
#line 903
enum __anonenum_169 {
    DEV_PARPORT_DEVICES_ACTIVE = -3
} ;
#line 908
enum __anonenum_170 {
    DEV_PARPORT_DEVICE_TIMESLICE = 1
} ;
#line 913
enum __anonenum_171 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6
} ;
#line 923
enum __anonenum_172 {
    DEV_SCSI_LOGGING_LEVEL = 1
} ;
#line 928
enum __anonenum_173 {
    DEV_IPMI_POWEROFF_POWERCYCLE = 1
} ;
#line 933
enum __anonenum_174 {
    ABI_DEFHANDLER_COFF = 1,
    ABI_DEFHANDLER_ELF = 2,
    ABI_DEFHANDLER_LCALL7 = 3,
    ABI_DEFHANDLER_LIBCSO = 4,
    ABI_TRACE = 5,
    ABI_FAKE_UTSNAME = 6
} ;
#line 947
struct ctl_table;
#line 948
struct nsproxy;
#line 948
struct nsproxy;
#line 949
struct ctl_table_root;
#line 949
struct ctl_table_root;
#line 951 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table_set {
   struct list_head list ;
   struct ctl_table_set *parent ;
   int (*is_seen)(struct ctl_table_set * ) ;
};
#line 961
struct ctl_table_header;
#line 961
struct ctl_table_header;
#line 974 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
typedef struct ctl_table ctl_table;
#line 976 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
typedef int ctl_handler(struct ctl_table *table , void *oldval , size_t *oldlenp ,
                        void *newval , size_t newlen );
#line 980 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table *ctl , int write , struct file *filp , void *buffer ,
                         size_t *lenp , loff_t *ppos );
#line 1052 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table {
   int ctl_name ;
   char const   *procname ;
   void *data ;
   int maxlen ;
   mode_t mode ;
   struct ctl_table *child ;
   struct ctl_table *parent ;
   proc_handler *proc_handler ;
   ctl_handler *strategy ;
   void *extra1 ;
   void *extra2 ;
};
#line 1067 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table_root {
   struct list_head root_list ;
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *root , struct nsproxy *namespaces ) ;
   int (*permissions)(struct ctl_table_root *root , struct nsproxy *namespaces , struct ctl_table *table ) ;
};
#line 1078 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_table_header {
   struct ctl_table *ctl_table ;
   struct list_head ctl_entry ;
   int used ;
   int count ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_table *attached_by ;
   struct ctl_table *attached_to ;
   struct ctl_table_header *parent ;
};
#line 1094 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
struct ctl_path {
   char const   *procname ;
   int ctl_name ;
};
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
typedef int32_t key_serial_t;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 34
struct key;
#line 74
struct seq_file;
#line 75
struct user_struct;
#line 76
struct signal_struct;
#line 76
struct signal_struct;
#line 77
struct cred;
#line 77
struct cred;
#line 79
struct key_type;
#line 79
struct key_type;
#line 80
struct key_owner;
#line 80
struct key_owner;
#line 81
struct keyring_list;
#line 81
struct keyring_list;
#line 82
struct keyring_name;
#line 82
struct keyring_name;
#line 98
struct __key_reference_with_attributes;
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
typedef struct __key_reference_with_attributes *key_ref_t;
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
union __anonunion_payload_175 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
union __anonunion_type_data_176 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
#line 124
struct key_user;
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_176 type_data ;
   union __anonunion_payload_175 payload ;
};
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct user_struct;
#line 21
struct cred;
#line 22
struct inode;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct mem_cgroup;
#line 94
struct mem_cgroup;
#line 95
struct exec_domain;
#line 96
struct futex_pi_state;
#line 96
struct futex_pi_state;
#line 97
struct robust_list_head;
#line 97
struct robust_list_head;
#line 98
struct bio;
#line 98
struct bio;
#line 99
struct bts_tracer;
#line 99
struct bts_tracer;
#line 100
struct fs_struct;
#line 100
struct fs_struct;
#line 143
struct seq_file;
#line 144
struct cfs_rq;
#line 144
struct cfs_rq;
#line 145
struct task_group;
#line 145
struct task_group;
#line 246
struct task_struct;
#line 345
struct nsproxy;
#line 346
struct user_namespace;
#line 346
struct user_namespace;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio_abi.h"
typedef unsigned long aio_context_t;
#line 35
enum __anonenum_177 {
    IOCB_CMD_PREAD = 0,
    IOCB_CMD_PWRITE = 1,
    IOCB_CMD_FSYNC = 2,
    IOCB_CMD_FDSYNC = 3,
    IOCB_CMD_NOOP = 6,
    IOCB_CMD_PREADV = 7,
    IOCB_CMD_PWRITEV = 8
} ;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio_abi.h"
struct iocb {
   __u64 aio_data ;
   __u32 aio_key ;
   __u32 aio_reserved1 ;
   __u16 aio_lio_opcode ;
   __s16 aio_reqprio ;
   __u32 aio_fildes ;
   __u64 aio_buf ;
   __u64 aio_nbytes ;
   __s64 aio_offset ;
   __u64 aio_reserved2 ;
   __u32 aio_flags ;
   __u32 aio_resfd ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct kioctx;
#line 15
struct kioctx;
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
union __anonunion_ki_obj_178 {
   void *user ;
   struct task_struct *tsk ;
};
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_178 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct aio_ring {
   unsigned int id ;
   unsigned int nr ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int magic ;
   unsigned int compat_features ;
   unsigned int incompat_features ;
   unsigned int header_length ;
   struct io_event io_events[0] ;
};
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
#line 215
struct mm_struct;
#line 442 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 449 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 468 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 495 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
#line 508
struct tty_audit_buf;
#line 508
struct taskstats;
#line 508
struct tty_struct;
#line 508 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
#line 640 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
#line 685
struct backing_dev_info;
#line 685
struct backing_dev_info;
#line 686
struct reclaim_state;
#line 686
struct reclaim_state;
#line 689 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
#line 705 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 750
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
#line 783
enum powersavings_balance_level {
    POWERSAVINGS_BALANCE_NONE = 0,
    POWERSAVINGS_BALANCE_BASIC = 1,
    POWERSAVINGS_BALANCE_WAKEUP = 2,
    MAX_POWERSAVINGS_BALANCE_LEVELS = 3
} ;
#line 826 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
#line 849
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
#line 859 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_domain_attr {
   int relax_domain_level ;
};
#line 867 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   unsigned long span[] ;
};
#line 959
struct io_context;
#line 959
struct io_context;
#line 968
struct audit_context;
#line 968
struct audit_context;
#line 969
struct mempolicy;
#line 970
struct pipe_inode_info;
#line 970
struct pipe_inode_info;
#line 971
struct uts_namespace;
#line 971
struct uts_namespace;
#line 973
struct rq;
#line 973
struct rq;
#line 974
struct sched_domain;
#line 976 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   int (*needs_post_schedule)(struct rq *this_rq ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
   void (*moved_group)(struct task_struct *p ) ;
};
#line 1027 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
#line 1041 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 start_runtime ;
   u64 avg_wakeup ;
   u64 nr_migrations ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
#line 1101 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
#line 1117
struct css_set;
#line 1117
struct irqaction;
#line 1117
struct files_struct;
#line 1117
struct linux_binfmt;
#line 1117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   int cpuset_mems_generation ;
   int cpuset_mem_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   struct prop_local_single dirties ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
#line 1493
struct pid_namespace;
#line 1816 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
union thread_union {
   struct thread_info thread_info ;
   unsigned long stack[((1UL << 12) << 1) / sizeof(long )] ;
};
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
typedef struct pt_regs *T__;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
struct irq_desc;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
typedef void (*irq_flow_handler_t)(unsigned int irq , struct irq_desc *desc );
#line 81
struct proc_dir_entry;
#line 82
struct msi_desc;
#line 82
struct msi_desc;
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
struct irq_chip {
   char const   *name ;
   unsigned int (*startup)(unsigned int irq ) ;
   void (*shutdown)(unsigned int irq ) ;
   void (*enable)(unsigned int irq ) ;
   void (*disable)(unsigned int irq ) ;
   void (*ack)(unsigned int irq ) ;
   void (*mask)(unsigned int irq ) ;
   void (*mask_ack)(unsigned int irq ) ;
   void (*unmask)(unsigned int irq ) ;
   void (*eoi)(unsigned int irq ) ;
   void (*end)(unsigned int irq ) ;
   void (*set_affinity)(unsigned int irq , struct cpumask  const  *dest ) ;
   int (*retrigger)(unsigned int irq ) ;
   int (*set_type)(unsigned int irq , unsigned int flow_type ) ;
   int (*set_wake)(unsigned int irq , unsigned int on ) ;
   char const   *typename ;
};
#line 137
struct timer_rand_state;
#line 137
struct timer_rand_state;
#line 138
struct irq_2_iommu;
#line 138
struct irq_2_iommu;
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
struct irq_desc {
   unsigned int irq ;
   struct timer_rand_state *timer_rand_state ;
   unsigned int *kstat_irqs ;
   void (*handle_irq)(unsigned int irq , struct irq_desc *desc ) ;
   struct irq_chip *chip ;
   struct msi_desc *msi_desc ;
   void *handler_data ;
   void *chip_data ;
   struct irqaction *action ;
   unsigned int status ;
   unsigned int depth ;
   unsigned int wake_depth ;
   unsigned int irq_count ;
   unsigned long last_unhandled ;
   unsigned int irqs_unhandled ;
   spinlock_t lock ;
   cpumask_var_t affinity ;
   unsigned int cpu ;
   cpumask_var_t pending_mask ;
   atomic_t threads_active ;
   wait_queue_head_t wait_for_threads ;
   struct proc_dir_entry *dir ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
typedef struct irq_desc irq_desc_t;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/profile.h"
struct proc_dir_entry;
#line 17
struct pt_regs;
#line 18
struct notifier_block;
#line 34
enum profile_type {
    PROFILE_TASK_EXIT = 0,
    PROFILE_MUNMAP = 1
} ;
#line 65
struct task_struct;
#line 66
struct mm_struct;
#line 88
struct pt_regs;
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hw_irq.h"
typedef int vector_irq_t[256];
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hardirq.h"
struct __anonstruct_irq_cpustat_t_179 {
   unsigned int __softirq_pending ;
   unsigned int __nmi_count ;
   unsigned int irq0_irqs ;
   unsigned int apic_timer_irqs ;
   unsigned int irq_spurious_count ;
   unsigned int generic_irqs ;
   unsigned int irq_resched_count ;
   unsigned int irq_call_count ;
   unsigned int irq_tlb_count ;
   unsigned int irq_thermal_count ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hardirq.h"
typedef struct __anonstruct_irq_cpustat_t_179 irq_cpustat_t;
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hardirq.h"
struct task_struct;
#line 68 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
enum __anonenum_180 {
    IRQTF_RUNTHREAD = 0,
    IRQTF_DIED = 1,
    IRQTF_WARNED = 2
} ;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
typedef irqreturn_t (*irq_handler_t)(int  , void * );
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   unsigned long flags ;
   cpumask_t mask ;
   char const   *name ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   struct proc_dir_entry *dir ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
};
#line 145
struct device;
#line 331
enum __anonenum_181 {
    HI_SOFTIRQ = 0,
    TIMER_SOFTIRQ = 1,
    NET_TX_SOFTIRQ = 2,
    NET_RX_SOFTIRQ = 3,
    BLOCK_SOFTIRQ = 4,
    TASKLET_SOFTIRQ = 5,
    SCHED_SOFTIRQ = 6,
    HRTIMER_SOFTIRQ = 7,
    RCU_SOFTIRQ = 8,
    NR_SOFTIRQS = 9
} ;
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
struct softirq_action {
   void (*action)(struct softirq_action * ) ;
};
#line 409 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 425
enum __anonenum_182 {
    TASKLET_STATE_SCHED = 0,
    TASKLET_STATE_RUN = 1
} ;
#line 564
struct irq_desc;
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct files_stat_struct {
   int nr_files ;
   int nr_free_files ;
   int max_files ;
};
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct inodes_stat_t {
   int nr_inodes ;
   int nr_unused ;
   int dummy[5] ;
};
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct nameidata;
#line 11
struct nameidata;
#line 12
struct path;
#line 13
struct vfsmount;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct dentry_stat_t {
   int nr_dentry ;
   int nr_unused ;
   int age_limit ;
   int want_pages ;
   int dummy[2] ;
};
#line 89
struct super_block;
#line 89
struct dentry_operations;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
union __anonunion_d_u_183 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_183 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[40] ;
};
#line 128
enum dentry_d_lock_class {
    DENTRY_D_LOCK_NORMAL = 0,
    DENTRY_D_LOCK_NESTED = 1
} ;
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
struct radix_tree_node;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fiemap.h"
struct fiemap {
   __u64 fm_start ;
   __u64 fm_length ;
   __u32 fm_flags ;
   __u32 fm_mapped_extents ;
   __u32 fm_extent_count ;
   __u32 fm_reserved ;
   struct fiemap_extent fm_extents[0] ;
};
#line 380 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct export_operations;
#line 380
struct export_operations;
#line 381
struct hd_geometry;
#line 381
struct hd_geometry;
#line 382
struct iovec;
#line 383
struct nameidata;
#line 384
struct kiocb;
#line 385
struct pipe_inode_info;
#line 386
struct poll_table_struct;
#line 386
struct poll_table_struct;
#line 387
struct kstatfs;
#line 387
struct kstatfs;
#line 388
struct vm_area_struct;
#line 389
struct vfsmount;
#line 390
struct cred;
#line 405
struct buffer_head;
#line 405
struct buffer_head;
#line 406 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef int get_block_t(struct inode *inode , sector_t iblock , struct buffer_head *bh_result ,
                        int create );
#line 408 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef void dio_iodone_t(struct kiocb *iocb , loff_t offset , ssize_t bytes , void *private );
#line 442 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
enum __anonenum_184 {
    QIF_BLIMITS_B = 0,
    QIF_SPACE_B = 1,
    QIF_ILIMITS_B = 2,
    QIF_INODES_B = 3,
    QIF_BTIME_B = 4,
    QIF_ITIME_B = 5
} ;
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 149
enum __anonenum_185 {
    QUOTA_NL_C_UNSPEC = 0,
    QUOTA_NL_C_WARNING = 1,
    __QUOTA_NL_C_MAX = 2
} ;
#line 156
enum __anonenum_186 {
    QUOTA_NL_A_UNSPEC = 0,
    QUOTA_NL_A_QTYPE = 1,
    QUOTA_NL_A_EXCESS_ID = 2,
    QUOTA_NL_A_WARNING = 3,
    QUOTA_NL_A_DEV_MAJOR = 4,
    QUOTA_NL_A_DEV_MINOR = 5,
    QUOTA_NL_A_CAUSED_ID = 6,
    __QUOTA_NL_A_MAX = 7
} ;
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
typedef struct fs_disk_quota fs_disk_quota_t;
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_xfs.h"
typedef struct fs_quota_stat fs_quota_stat_t;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
struct dquot;
#line 17
struct dquot;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
struct qtree_fmt_operations {
   void (*mem2disk_dqblk)(void *disk , struct dquot *dquot ) ;
   void (*disk2mem_dqblk)(struct dquot *dquot , void *disk ) ;
   int (*is_id)(void *disk , struct dquot *dquot ) ;
};
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
struct qtree_mem_dqinfo {
   struct super_block *dqi_sb ;
   int dqi_type ;
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
   unsigned int dqi_blocksize_bits ;
   unsigned int dqi_entry_size ;
   unsigned int dqi_usable_bs ;
   unsigned int dqi_qtree_depth ;
   struct qtree_fmt_operations *dqi_ops ;
};
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
#line 183 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
typedef long long qsize_t;
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 212
struct quota_format_type;
#line 212
struct quota_format_type;
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 227
struct super_block;
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct dqstats {
   int lookups ;
   int drops ;
   int reads ;
   int writes ;
   int cache_hits ;
   int allocated_dquots ;
   int free_dquots ;
   int syncs ;
};
#line 264 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
#line 284 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
#line 295 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   int (*reserve_space)(struct inode * , qsize_t  , int  ) ;
   int (*claim_space)(struct inode * , qsize_t  ) ;
   void (*release_rsv)(struct inode * , qsize_t  ) ;
   qsize_t (*get_reserved_space)(struct inode * ) ;
};
#line 321 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
#line 335 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 343
enum __anonenum_187 {
    _DQUOT_USAGE_ENABLED = 0,
    _DQUOT_LIMITS_ENABLED = 1,
    _DQUOT_SUSPENDED = 2,
    _DQUOT_STATE_FLAGS = 3
} ;
#line 379 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
#line 392 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
struct quota_module_name {
   int qm_fmt_id ;
   char *qm_mod_name ;
};
#line 491 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
enum positive_aop_returns {
    AOP_WRITEPAGE_ACTIVATE = 524288,
    AOP_TRUNCATED_PAGE = 524289
} ;
#line 505
struct page;
#line 506
struct address_space;
#line 507
struct writeback_control;
#line 509 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct iov_iter {
   struct iovec  const  *iov ;
   unsigned long nr_segs ;
   size_t iov_offset ;
   size_t count ;
};
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion_arg_189 {
   char *buf ;
   void *data ;
};
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_188 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_189 arg ;
   int error ;
};
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_188 read_descriptor_t;
#line 560 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef int (*read_actor_t)(read_descriptor_t * , struct page * , unsigned long  ,
                            unsigned long  );
#line 563 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
#line 612
struct backing_dev_info;
#line 613 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
#line 637
struct gendisk;
#line 637
struct hd_struct;
#line 637 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 713
struct dnotify_struct;
#line 713
struct cdev;
#line 713 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion____missing_field_name_190 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 713
struct file_lock;
#line 713
struct file_operations;
#line 713
struct inode_operations;
#line 713 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_190 __annonCompField21 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
#line 791
enum inode_i_mutex_lock_class {
    I_MUTEX_NORMAL = 0,
    I_MUTEX_PARENT = 1,
    I_MUTEX_CHILD = 2,
    I_MUTEX_XATTR = 3,
    I_MUTEX_QUOTA = 4
} ;
#line 865 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
#line 876 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
#line 899 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion_f_u_191 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
#line 899 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file {
   union __anonunion_f_u_191 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
};
#line 1018 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 1020 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 1025 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
#line 1036 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct lock_manager {
   struct list_head list ;
};
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
enum nfs_stat {
    NFS_OK = 0,
    NFSERR_PERM = 1,
    NFSERR_NOENT = 2,
    NFSERR_IO = 5,
    NFSERR_NXIO = 6,
    NFSERR_EAGAIN = 11,
    NFSERR_ACCES = 13,
    NFSERR_EXIST = 17,
    NFSERR_XDEV = 18,
    NFSERR_NODEV = 19,
    NFSERR_NOTDIR = 20,
    NFSERR_ISDIR = 21,
    NFSERR_INVAL = 22,
    NFSERR_FBIG = 27,
    NFSERR_NOSPC = 28,
    NFSERR_ROFS = 30,
    NFSERR_MLINK = 31,
    NFSERR_OPNOTSUPP = 45,
    NFSERR_NAMETOOLONG = 63,
    NFSERR_NOTEMPTY = 66,
    NFSERR_DQUOT = 69,
    NFSERR_STALE = 70,
    NFSERR_REMOTE = 71,
    NFSERR_WFLUSH = 99,
    NFSERR_BADHANDLE = 10001,
    NFSERR_NOT_SYNC = 10002,
    NFSERR_BAD_COOKIE = 10003,
    NFSERR_NOTSUPP = 10004,
    NFSERR_TOOSMALL = 10005,
    NFSERR_SERVERFAULT = 10006,
    NFSERR_BADTYPE = 10007,
    NFSERR_JUKEBOX = 10008,
    NFSERR_SAME = 10009,
    NFSERR_DENIED = 10010,
    NFSERR_EXPIRED = 10011,
    NFSERR_LOCKED = 10012,
    NFSERR_GRACE = 10013,
    NFSERR_FHEXPIRED = 10014,
    NFSERR_SHARE_DENIED = 10015,
    NFSERR_WRONGSEC = 10016,
    NFSERR_CLID_INUSE = 10017,
    NFSERR_RESOURCE = 10018,
    NFSERR_MOVED = 10019,
    NFSERR_NOFILEHANDLE = 10020,
    NFSERR_MINOR_VERS_MISMATCH = 10021,
    NFSERR_STALE_CLIENTID = 10022,
    NFSERR_STALE_STATEID = 10023,
    NFSERR_OLD_STATEID = 10024,
    NFSERR_BAD_STATEID = 10025,
    NFSERR_BAD_SEQID = 10026,
    NFSERR_NOT_SAME = 10027,
    NFSERR_LOCK_RANGE = 10028,
    NFSERR_SYMLINK = 10029,
    NFSERR_RESTOREFH = 10030,
    NFSERR_LEASE_MOVED = 10031,
    NFSERR_ATTRNOTSUPP = 10032,
    NFSERR_NO_GRACE = 10033,
    NFSERR_RECLAIM_BAD = 10034,
    NFSERR_RECLAIM_CONFLICT = 10035,
    NFSERR_BAD_XDR = 10036,
    NFSERR_LOCKS_HELD = 10037,
    NFSERR_OPENMODE = 10038,
    NFSERR_BADOWNER = 10039,
    NFSERR_BADCHAR = 10040,
    NFSERR_BADNAME = 10041,
    NFSERR_BAD_RANGE = 10042,
    NFSERR_LOCK_NOTSUPP = 10043,
    NFSERR_OP_ILLEGAL = 10044,
    NFSERR_DEADLOCK = 10045,
    NFSERR_FILE_OPEN = 10046,
    NFSERR_ADMIN_REVOKED = 10047,
    NFSERR_CB_PATH_DOWN = 10048
} ;
#line 116
enum nfs_ftype {
    NFNON = 0,
    NFREG = 1,
    NFDIR = 2,
    NFBLK = 3,
    NFCHR = 4,
    NFLNK = 5,
    NFSOCK = 6,
    NFBAD = 7,
    NFFIFO = 8
} ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sunrpc/msg_prot.h"
typedef u32 rpc_authflavor_t;
#line 20
enum rpc_auth_flavors {
    RPC_AUTH_NULL = 0,
    RPC_AUTH_UNIX = 1,
    RPC_AUTH_SHORT = 2,
    RPC_AUTH_DES = 3,
    RPC_AUTH_KRB = 4,
    RPC_AUTH_GSS = 6,
    RPC_AUTH_MAXFLAVOR = 8,
    RPC_AUTH_GSS_KRB5 = 390003,
    RPC_AUTH_GSS_KRB5I = 390004,
    RPC_AUTH_GSS_KRB5P = 390005,
    RPC_AUTH_GSS_LKEY = 390006,
    RPC_AUTH_GSS_LKEYI = 390007,
    RPC_AUTH_GSS_LKEYP = 390008,
    RPC_AUTH_GSS_SPKM = 390009,
    RPC_AUTH_GSS_SPKMI = 390010,
    RPC_AUTH_GSS_SPKMP = 390011
} ;
#line 43
enum rpc_msg_type {
    RPC_CALL = 0,
    RPC_REPLY = 1
} ;
#line 48
enum rpc_reply_stat {
    RPC_MSG_ACCEPTED = 0,
    RPC_MSG_DENIED = 1
} ;
#line 53
enum rpc_accept_stat {
    RPC_SUCCESS = 0,
    RPC_PROG_UNAVAIL = 1,
    RPC_PROG_MISMATCH = 2,
    RPC_PROC_UNAVAIL = 3,
    RPC_GARBAGE_ARGS = 4,
    RPC_SYSTEM_ERR = 5,
    RPC_DROP_REPLY = 60000
} ;
#line 64
enum rpc_reject_stat {
    RPC_MISMATCH = 0,
    RPC_AUTH_ERROR = 1
} ;
#line 69
enum rpc_auth_stat {
    RPC_AUTH_OK = 0,
    RPC_AUTH_BADCRED = 1,
    RPC_AUTH_REJECTEDCRED = 2,
    RPC_AUTH_BADVERF = 3,
    RPC_AUTH_REJECTEDVERF = 4,
    RPC_AUTH_TOOWEAK = 5,
    RPCSEC_GSS_CREDPROBLEM = 13,
    RPCSEC_GSS_CTXPROBLEM = 14
} ;
#line 102 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sunrpc/msg_prot.h"
typedef __be32 rpc_fraghdr;
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
struct nfs_fh {
   unsigned short size ;
   unsigned char data[128] ;
};
#line 164
enum nfs3_stable_how {
    NFS_UNSTABLE = 0,
    NFS_DATA_SYNC = 1,
    NFS_FILE_SYNC = 2
} ;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs_fs_i.h"
struct nlm_lockowner;
#line 8
struct nlm_lockowner;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 19
struct nfs4_lock_state;
#line 19
struct nfs4_lock_state;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 1047 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct __anonstruct_afs_193 {
   struct list_head link ;
   int state ;
};
#line 1047 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
union __anonunion_fl_u_192 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_193 afs ;
};
#line 1047
struct fasync_struct;
#line 1047 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_192 fl_u ;
};
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __kernel_off_t l_start ;
   __kernel_off_t l_len ;
   __kernel_pid_t l_pid ;
};
#line 140 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __kernel_loff_t l_start ;
   __kernel_loff_t l_len ;
   __kernel_pid_t l_pid ;
};
#line 1271 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
#line 1306
struct mtd_info;
#line 1306
struct xattr_handler;
#line 1306
struct super_operations;
#line 1306
struct file_system_type;
#line 1306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
#line 1387
enum __anonenum_194 {
    SB_UNFROZEN = 0,
    SB_FREEZE_WRITE = 1,
    SB_FREEZE_TRANS = 2
} ;
#line 1432 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1470 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
typedef int (*filldir_t)(void * , char const   * , int  , loff_t  , u64  , unsigned int  );
#line 1471
struct block_device_operations;
#line 1471
struct block_device_operations;
#line 1484 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
#line 1513 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
#line 1542
struct seq_file;
#line 1556 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
#line 1739 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
#line 2180
struct bio;
#line 2245
enum __anonenum_195 {
    DIO_LOCKING = 1,
    DIO_NO_LOCKING = 2,
    DIO_OWN_LOCKING = 3
} ;
#line 2349 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct tree_descr {
   char *name ;
   struct file_operations  const  *ops ;
   int mode ;
};
#line 2390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
struct simple_transaction_argresp {
   ssize_t size ;
   char data[0] ;
};
#line 2450
struct ctl_table;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugfs.h"
struct file_operations;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugfs.h"
struct debugfs_blob_wrapper {
   void *data ;
   unsigned long size ;
};
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_ctrlrequest {
   __u8 bRequestType ;
   __u8 bRequest ;
   __le16 wValue ;
   __le16 wIndex ;
   __le16 wLength ;
} __attribute__((__packed__)) ;
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_descriptor_header {
   __u8 bLength ;
   __u8 bDescriptorType ;
} __attribute__((__packed__)) ;
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
} __attribute__((__packed__)) ;
#line 269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
} __attribute__((__packed__)) ;
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_string_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wData[1] ;
} __attribute__((__packed__)) ;
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
} __attribute__((__packed__)) ;
#line 324 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
} __attribute__((__packed__)) ;
#line 539 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_qualifier_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __u8 bNumConfigurations ;
   __u8 bRESERVED ;
} __attribute__((__packed__)) ;
#line 556 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_otg_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bmAttributes ;
} __attribute__((__packed__)) ;
#line 570 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_debug_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDebugInEndpoint ;
   __u8 bDebugOutEndpoint ;
} __attribute__((__packed__)) ;
#line 582 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
} __attribute__((__packed__)) ;
#line 600 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_security_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumEncryptionTypes ;
} __attribute__((__packed__)) ;
#line 613 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_key_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 tTKID[3] ;
   __u8 bReserved ;
   __u8 bKeyData[0] ;
} __attribute__((__packed__)) ;
#line 625 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_encryption_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEncryptionType ;
   __u8 bEncryptionValue ;
   __u8 bAuthKeyIndex ;
} __attribute__((__packed__)) ;
#line 642 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
} __attribute__((__packed__)) ;
#line 653 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_dev_cap_header {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
} __attribute__((__packed__)) ;
#line 661 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_wireless_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wPHYRates ;
   __u8 bmTFITXPowerInfo ;
   __u8 bmFFITXPowerInfo ;
   __le16 bmBandGroup ;
   __u8 bReserved ;
} __attribute__((__packed__)) ;
#line 689 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
} __attribute__((__packed__)) ;
#line 702 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_wireless_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bMaxSequence ;
   __le16 wMaxStreamDelay ;
   __le16 wOverTheAirPacketSize ;
   __u8 bOverTheAirInterval ;
   __u8 bmCompAttributes ;
} __attribute__((__packed__)) ;
#line 724 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_handshake {
   __u8 bMessageNumber ;
   __u8 bStatus ;
   __u8 tTKID[3] ;
   __u8 bReserved ;
   __u8 CDID[16] ;
   __u8 nonce[16] ;
   __u8 MIC[8] ;
} __attribute__((__packed__)) ;
#line 740 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
struct usb_connection_context {
   __u8 CHID[16] ;
   __u8 CDID[16] ;
   __u8 CK[16] ;
} __attribute__((__packed__)) ;
#line 750
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_VARIABLE = 4
} ;
#line 757
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_device;
#line 24
struct usb_device;
#line 25
struct usb_driver;
#line 25
struct usb_driver;
#line 26
struct wusb_dev;
#line 26
struct wusb_dev;
#line 45
struct ep_device;
#line 45
struct ep_device;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
};
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
   unsigned char *extra ;
   int extralen ;
};
#line 86
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned int is_active : 1 ;
   unsigned int sysfs_files_created : 1 ;
   unsigned int ep_devs_created : 1 ;
   unsigned int unregistering : 1 ;
   unsigned int needs_remote_wakeup : 1 ;
   unsigned int needs_altsetting0 : 1 ;
   unsigned int needs_binding : 1 ;
   unsigned int reset_running : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   int pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 220 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0] ;
};
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16] ;
   struct usb_interface *interface[32] ;
   struct usb_interface_cache *intf_cache[32] ;
   unsigned char *extra ;
   int extralen ;
};
#line 303 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[128UL / (8UL * sizeof(unsigned long ))] ;
};
#line 310
struct mon_bus;
#line 310 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 otg_port ;
   unsigned int is_b_host : 1 ;
   unsigned int b_hnp_enable : 1 ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   struct dentry *usbfs_dentry ;
   struct device *dev ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 360
struct usb_tt;
#line 360
struct usb_tt;
#line 428 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16] ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16] ;
   struct usb_host_endpoint *ep_out[16] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned int can_submit : 1 ;
   unsigned int discon_suspended : 1 ;
   unsigned int persist_enabled : 1 ;
   unsigned int have_langid : 1 ;
   unsigned int authorized : 1 ;
   unsigned int authenticated : 1 ;
   unsigned int wusb : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   struct dentry *usbfs_dentry ;
   int maxchild ;
   struct usb_device *children[31] ;
   int pm_usage_cnt ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   struct delayed_work autosuspend ;
   struct work_struct autoresume ;
   struct mutex pm_mutex ;
   unsigned long last_busy ;
   int autosuspend_delay ;
   unsigned long connect_time ;
   unsigned int auto_pm : 1 ;
   unsigned int do_remote_wakeup : 1 ;
   unsigned int reset_resume : 1 ;
   unsigned int autosuspend_disabled : 1 ;
   unsigned int autoresume_disabled : 1 ;
   unsigned int skip_sys_resume : 1 ;
   struct wusb_dev *wusb_dev ;
};
#line 762 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 767 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_dynid {
   struct list_head node ;
   struct usb_device_id id ;
};
#line 781 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 840 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface *intf , struct usb_device_id  const  *id ) ;
   void (*disconnect)(struct usb_interface *intf ) ;
   int (*ioctl)(struct usb_interface *intf , unsigned int code , void *buf ) ;
   int (*suspend)(struct usb_interface *intf , pm_message_t message ) ;
   int (*resume)(struct usb_interface *intf ) ;
   int (*reset_resume)(struct usb_interface *intf ) ;
   int (*pre_reset)(struct usb_interface *intf ) ;
   int (*post_reset)(struct usb_interface *intf ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned int no_dynamic_id : 1 ;
   unsigned int supports_autosuspend : 1 ;
   unsigned int soft_unbind : 1 ;
};
#line 887 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_device_driver {
   char const   *name ;
   int (*probe)(struct usb_device *udev ) ;
   void (*disconnect)(struct usb_device *udev ) ;
   int (*suspend)(struct usb_device *udev , pm_message_t message ) ;
   int (*resume)(struct usb_device *udev , pm_message_t message ) ;
   struct usbdrv_wrap drvwrap ;
   unsigned int supports_autosuspend : 1 ;
};
#line 913 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_class_driver {
   char *name ;
   struct file_operations  const  *fops ;
   int minor_base ;
};
#line 968 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 975
struct urb;
#line 975
struct urb;
#line 977 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned int poisoned : 1 ;
};
#line 991 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
typedef void (*usb_complete_t)(struct urb * );
#line 1160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0] ;
};
#line 1355
struct scatterlist;
#line 1421 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
struct usb_sg_request {
   int status ;
   size_t bytes ;
   spinlock_t lock ;
   struct usb_device *dev ;
   int pipe ;
   struct scatterlist *sg ;
   int nents ;
   int entries ;
   struct urb **urbs ;
   int count ;
   struct completion complete ;
};
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dmi.h"
enum dmi_device_type {
    DMI_DEV_TYPE_ANY = 0,
    DMI_DEV_TYPE_OTHER = 1,
    DMI_DEV_TYPE_UNKNOWN = 2,
    DMI_DEV_TYPE_VIDEO = 3,
    DMI_DEV_TYPE_SCSI = 4,
    DMI_DEV_TYPE_ETHERNET = 5,
    DMI_DEV_TYPE_TOKENRING = 6,
    DMI_DEV_TYPE_SOUND = 7,
    DMI_DEV_TYPE_PATA = 8,
    DMI_DEV_TYPE_SATA = 9,
    DMI_DEV_TYPE_SAS = 10,
    DMI_DEV_TYPE_IPMI = -1,
    DMI_DEV_TYPE_OEM_STRING = -2
} ;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dmi.h"
struct dmi_header {
   u8 type ;
   u8 length ;
   u16 handle ;
};
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dmi.h"
struct dmi_device {
   struct list_head list ;
   int type ;
   char const   *name ;
   void *device_data ;
};
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
#line 432 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
struct __large_struct {
   unsigned long buf[100] ;
};
#line 563 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
struct movsl_mask {
   int mask ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
#line 70 "../core/hcd.h"
struct hc_driver;
#line 70 "../core/hcd.h"
struct usb_hcd {
   struct usb_bus self ;
   struct kref kref ;
   char const   *product_desc ;
   char irq_descr[24] ;
   struct timer_list rh_timer ;
   struct urb *status_urb ;
   struct work_struct wakeup_work ;
   struct hc_driver  const  *driver ;
   unsigned long flags ;
   unsigned int rh_registered : 1 ;
   unsigned int uses_new_polling : 1 ;
   unsigned int poll_rh : 1 ;
   unsigned int poll_pending : 1 ;
   unsigned int wireless : 1 ;
   unsigned int authorized_default : 1 ;
   unsigned int has_tt : 1 ;
   int irq ;
   void *regs ;
   u64 rsrc_start ;
   u64 rsrc_len ;
   unsigned int power_budget ;
   struct dma_pool *pool[4] ;
   int state ;
   unsigned long hcd_priv[0]  __attribute__((__aligned__(sizeof(unsigned long )))) ;
};
#line 155 "../core/hcd.h"
struct hcd_timeout {
   struct list_head timeout_list ;
   struct timer_list timer ;
};
#line 163 "../core/hcd.h"
struct hc_driver {
   char const   *description ;
   char const   *product_desc ;
   size_t hcd_priv_size ;
   irqreturn_t (*irq)(struct usb_hcd *hcd ) ;
   int flags ;
   int (*reset)(struct usb_hcd *hcd ) ;
   int (*start)(struct usb_hcd *hcd ) ;
   int (*pci_suspend)(struct usb_hcd *hcd , pm_message_t message ) ;
   int (*pci_resume)(struct usb_hcd *hcd ) ;
   void (*stop)(struct usb_hcd *hcd ) ;
   void (*shutdown)(struct usb_hcd *hcd ) ;
   int (*get_frame_number)(struct usb_hcd *hcd ) ;
   int (*urb_enqueue)(struct usb_hcd *hcd , struct urb *urb , gfp_t mem_flags ) ;
   int (*urb_dequeue)(struct usb_hcd *hcd , struct urb *urb , int status ) ;
   void (*endpoint_disable)(struct usb_hcd *hcd , struct usb_host_endpoint *ep ) ;
   void (*endpoint_reset)(struct usb_hcd *hcd , struct usb_host_endpoint *ep ) ;
   int (*hub_status_data)(struct usb_hcd *hcd , char *buf ) ;
   int (*hub_control)(struct usb_hcd *hcd , u16 typeReq , u16 wValue , u16 wIndex ,
                      char *buf , u16 wLength ) ;
   int (*bus_suspend)(struct usb_hcd * ) ;
   int (*bus_resume)(struct usb_hcd * ) ;
   int (*start_port_reset)(struct usb_hcd * , unsigned int port_num ) ;
   void (*relinquish_port)(struct usb_hcd * , int  ) ;
   int (*port_handed_over)(struct usb_hcd * , int  ) ;
   void (*clear_tt_buffer_complete)(struct usb_hcd * , struct usb_host_endpoint * ) ;
};
#line 259
struct platform_device;
#line 259
struct platform_device;
#line 263
struct pci_dev;
#line 264
struct pci_device_id;
#line 64 "../core/hub.h"
struct usb_port_status {
   __le16 wPortStatus ;
   __le16 wPortChange ;
} __attribute__((__packed__)) ;
#line 109 "../core/hub.h"
struct usb_hub_status {
   __le16 wHubStatus ;
   __le16 wHubChange ;
} __attribute__((__packed__)) ;
#line 134 "../core/hub.h"
struct usb_hub_descriptor {
   __u8 bDescLength ;
   __u8 bDescriptorType ;
   __u8 bNbrPorts ;
   __le16 wHubCharacteristics ;
   __u8 bPwrOn2PwrGood ;
   __u8 bHubContrCurrent ;
   __u8 DeviceRemovable[4] ;
   __u8 PortPwrCtrlMask[4] ;
} __attribute__((__packed__)) ;
#line 153
enum hub_led_mode {
    INDICATOR_AUTO = 0,
    INDICATOR_CYCLE = 1,
    INDICATOR_GREEN_BLINK = 2,
    INDICATOR_GREEN_BLINK_OFF = 3,
    INDICATOR_AMBER_BLINK = 4,
    INDICATOR_AMBER_BLINK_OFF = 5,
    INDICATOR_ALT_BLINK = 6,
    INDICATOR_ALT_BLINK_OFF = 7
}  __attribute__((__packed__)) ;
#line 162
struct usb_device;
#line 180 "../core/hub.h"
struct usb_tt {
   struct usb_device *hub ;
   int multi ;
   unsigned int think_time ;
   spinlock_t lock ;
   struct list_head clear_list ;
   struct work_struct clear_work ;
};
#line 191 "../core/hub.h"
struct usb_tt_clear {
   struct list_head clear_list ;
   unsigned int tt ;
   u16 devinfo ;
   struct usb_hcd *hcd ;
   struct usb_host_endpoint *ep ;
};
#line 444 "../core/hcd.h"
struct usb_mon_operations {
   void (*urb_submit)(struct usb_bus *bus , struct urb *urb ) ;
   void (*urb_submit_error)(struct usb_bus *bus , struct urb *urb , int err ) ;
   void (*urb_complete)(struct usb_bus *bus , struct urb *urb , int status ) ;
};
#line 126 "uhci-hcd.h"
struct uhci_td;
#line 126 "uhci-hcd.h"
struct uhci_qh {
   __le32 link ;
   __le32 element ;
   dma_addr_t dma_handle ;
   struct list_head node ;
   struct usb_host_endpoint *hep ;
   struct usb_device *udev ;
   struct list_head queue ;
   struct uhci_td *dummy_td ;
   struct uhci_td *post_td ;
   struct usb_iso_packet_descriptor *iso_packet_desc ;
   unsigned long advance_jiffies ;
   unsigned int unlink_frame ;
   unsigned int period ;
   short phase ;
   short load ;
   unsigned int iso_frame ;
   int state ;
   int type ;
   int skel ;
   unsigned int initial_toggle : 1 ;
   unsigned int needs_fixup : 1 ;
   unsigned int is_stopped : 1 ;
   unsigned int wait_expired : 1 ;
   unsigned int bandwidth_reserved : 1 ;
} __attribute__((__aligned__(16))) ;
#line 241 "uhci-hcd.h"
struct uhci_td {
   __le32 link ;
   __le32 status ;
   __le32 token ;
   __le32 buffer ;
   dma_addr_t dma_handle ;
   struct list_head list ;
   int frame ;
   struct list_head fl_list ;
} __attribute__((__aligned__(16))) ;
#line 348
enum uhci_rh_state {
    UHCI_RH_RESET = 0,
    UHCI_RH_SUSPENDED = 1,
    UHCI_RH_AUTO_STOPPED = 2,
    UHCI_RH_RESUMING = 3,
    UHCI_RH_SUSPENDING = 4,
    UHCI_RH_RUNNING = 5,
    UHCI_RH_RUNNING_NODEVS = 6
} ;
#line 370 "uhci-hcd.h"
struct uhci_hcd {
   struct dentry *dentry ;
   unsigned long io_addr ;
   struct dma_pool *qh_pool ;
   struct dma_pool *td_pool ;
   struct uhci_td *term_td ;
   struct uhci_qh *skelqh[11] ;
   struct uhci_qh *next_qh ;
   spinlock_t lock ;
   dma_addr_t frame_dma_handle ;
   __le32 *frame ;
   void **frame_cpu ;
   enum uhci_rh_state rh_state ;
   unsigned long auto_stop_time ;
   unsigned int frame_number ;
   unsigned int is_stopped ;
   unsigned int last_iso_frame ;
   unsigned int cur_iso_frame ;
   unsigned int scan_in_progress : 1 ;
   unsigned int need_rescan : 1 ;
   unsigned int dead : 1 ;
   unsigned int RD_enable : 1 ;
   unsigned int is_initialized : 1 ;
   unsigned int fsbr_is_on : 1 ;
   unsigned int fsbr_is_wanted : 1 ;
   unsigned int fsbr_expiring : 1 ;
   struct timer_list fsbr_timer ;
   unsigned long port_c_suspend ;
   unsigned long resuming_ports ;
   unsigned long ports_timeout ;
   struct list_head idle_qh_list ;
   int rh_numports ;
   wait_queue_head_t waitqh ;
   int num_waiting ;
   int total_load ;
   short load[32] ;
};
#line 448 "uhci-hcd.h"
struct urb_priv {
   struct list_head node ;
   struct urb *urb ;
   struct uhci_qh *qh ;
   struct list_head td_list ;
   unsigned int fsbr : 1 ;
};
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#line 212 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/segment.h"
extern char const   early_idt_handlers[32][10] ;
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/init.h"
extern initcall_t __con_initcall_start[] ;
#line 136
extern initcall_t __con_initcall_end[] ;
#line 137
extern initcall_t __security_initcall_start[] ;
#line 137
extern initcall_t __security_initcall_end[] ;
#line 140
extern int do_one_initcall(int (*fn)(void) ) ;
#line 141
extern char boot_command_line[]  __attribute__((__section__(".init.data"))) ;
#line 142
extern char *saved_command_line ;
#line 143
extern unsigned int reset_devices ;
#line 146
extern void setup_arch(char ** ) ;
#line 147
extern void prepare_namespace(void) ;
#line 149
extern void (*late_time_init)(void) ;
#line 243
extern void parse_early_param(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 244
extern void parse_early_options(char *cmdline )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
extern unsigned long profile_pc(struct pt_regs *regs ) ;
#line 139
extern unsigned long convert_ip_to_linear(struct task_struct *child , struct pt_regs *regs ) ;
#line 141
extern void send_sigtrap(struct task_struct *tsk , struct pt_regs *regs , int error_code ,
                         int si_code ) ;
#line 143
extern void signal_fault(struct pt_regs *regs , void *frame , char *where ) ;
#line 145
extern long syscall_trace_enter(struct pt_regs * ) ;
#line 146
extern void syscall_trace_leave(struct pt_regs * ) ;
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long regs_return_value(struct pt_regs *regs ) 
{ 

  {
#line 150
  return (regs->ax);
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int user_mode(struct pt_regs *regs ) 
{ 

  {
#line 163
  return ((regs->cs & 3UL) == 3UL);
}
}
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int user_mode_vm(struct pt_regs *regs ) 
{ 

  {
#line 172
  return (((regs->cs & 3UL) | (regs->flags & 131072UL)) >= 3UL);
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static int v8086_mode(struct pt_regs *regs ) 
{ 

  {
#line 182
  return ((int )(regs->flags & 131072UL));
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long kernel_stack_pointer(struct pt_regs *regs ) 
{ 

  {
#line 198
  return ((unsigned long )(& regs->sp));
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long instruction_pointer(struct pt_regs *regs ) 
{ 

  {
#line 206
  return (regs->ip);
}
}
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long frame_pointer(struct pt_regs *regs ) 
{ 

  {
#line 211
  return (regs->bp);
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ptrace.h"
__inline static unsigned long user_stack_pointer(struct pt_regs *regs ) 
{ 

  {
#line 216
  return (regs->sp);
}
}
#line 223
extern void user_enable_single_step(struct task_struct * ) ;
#line 224
extern void user_disable_single_step(struct task_struct * ) ;
#line 226
extern void user_enable_block_step(struct task_struct * ) ;
#line 234
extern int do_get_thread_area(struct task_struct *p , int idx , struct user_desc *info ) ;
#line 236
extern int do_set_thread_area(struct task_struct *p , int idx , struct user_desc *info ,
                              int can_allocate ) ;
#line 239
extern void x86_ptrace_untrace(struct task_struct * ) ;
#line 240
extern void x86_ptrace_fork(struct task_struct *child , unsigned long clone_flags ) ;
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vm86.h"
extern void handle_vm86_fault(struct kernel_vm86_regs * , long  ) ;
#line 188
extern int handle_vm86_trap(struct kernel_vm86_regs * , long  , int  ) ;
#line 189
extern struct pt_regs *save_v86_state(struct kernel_vm86_regs * ) ;
#line 192
extern void release_vm86_irqs(struct task_struct * ) ;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8] ;
#line 61
extern void setup_per_cpu_areas(void) ;
#line 156 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/percpu.h"
extern unsigned long per_cpu__this_cpu_off  __attribute__((__section__(".data.percpu"))) ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/current.h"
extern struct task_struct *per_cpu__current_task  __attribute__((__section__(".data.percpu"))) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ struct task_struct *ret__ ;

  {
#line 14
  if ((int )sizeof(per_cpu__current_task) == 1) {
    goto switch_0_1;
  } else {
#line 14
    if ((int )sizeof(per_cpu__current_task) == 2) {
      goto switch_0_2;
    } else {
#line 14
      if ((int )sizeof(per_cpu__current_task) == 4) {
        goto switch_0_4;
      } else {
#line 14
        if ((int )sizeof(per_cpu__current_task) == 8) {
          goto switch_0_8;
        } else {
          {
          goto switch_0_default;
#line 14
          if (0) {
            switch_0_1: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_2: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_4: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_8: /* CIL Label */ 
            {
#line 14
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_default: /* CIL Label */ 
            {
#line 14
            __bad_percpu_size();
            }
          } else {
            switch_0_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
#line 14
  return (ret__);
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/alternative.h"
extern void alternative_instructions(void) ;
#line 57
extern void apply_alternatives(struct alt_instr *start , struct alt_instr *end ) ;
#line 62
extern void alternatives_smp_module_add(struct module *mod , char *name , void *locks ,
                                        void *locks_end , void *text , void *text_end ) ;
#line 65
extern void alternatives_smp_module_del(struct module *mod ) ;
#line 66
extern void alternatives_smp_switch(int smp ) ;
#line 75
extern unsigned char const   * const  *find_nop_table(void) ;
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/alternative.h"
__inline static void apply_paravirt(struct paravirt_patch_site *start , struct paravirt_patch_site *end ) 
{ 

  {
#line 155
  return;
}
}
#line 160
extern void add_nops(void *insns , unsigned int len ) ;
#line 180
extern void *text_poke(void *addr , void const   *opcode , size_t len ) ;
#line 181
extern void *text_poke_early(void *addr , void const   *opcode , size_t len ) ;
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 68
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 71
  return;
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 84
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 85
  return;
}
}
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 105
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 109
  return;
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 121
  __asm__  volatile   ("": : : "memory");
#line 122
  clear_bit((int )nr, addr);
  }
#line 123
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 127
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 128
  return;
}
}
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 144
  __asm__  volatile   ("": : : "memory");
#line 145
  __clear_bit((int )nr, addr);
  }
#line 146
  return;
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void __change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 162
  __asm__  volatile   ("btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 163
  return;
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static void change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
#line 181
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 185
  return;
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 199
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 202
  return (oldbit);
}
}
#line 212 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit_lock(int nr , unsigned long volatile   *addr ) 
{ int tmp ;

  {
  {
#line 215
  tmp = test_and_set_bit(nr, addr);
  }
#line 215
  return (tmp);
}
}
#line 227 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 231
  __asm__  ("bts %2,%1\n\t"
            "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 235
  return (oldbit);
}
}
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 250
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 254
  return (oldbit);
}
}
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 270
  __asm__  volatile   ("btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
#line 274
  return (oldbit);
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int __test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 282
  __asm__  volatile   ("btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 287
  return (oldbit);
}
}
#line 298 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 302
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
#line 306
  return (oldbit);
}
}
#line 309 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 

  {
#line 311
  return (((1UL << nr % 32U) & *((unsigned long *)addr + nr / 32U)) != 0UL);
}
}
#line 315 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
  {
#line 319
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  }
#line 324
  return (oldbit);
}
}
#line 347 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long __ffs(unsigned long word ) 
{ 

  {
  {
#line 349
  __asm__  ("bsf %1,%0": "=r" (word): "rm" (word));
  }
#line 352
  return (word);
}
}
#line 361 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long ffz(unsigned long word ) 
{ 

  {
  {
#line 363
  __asm__  ("bsf %1,%0": "=r" (word): "r" (~ word));
  }
#line 366
  return (word);
}
}
#line 375 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static unsigned long __fls(unsigned long word ) 
{ 

  {
  {
#line 377
  __asm__  ("bsr %1,%0": "=r" (word): "rm" (word));
  }
#line 380
  return (word);
}
}
#line 395 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ int r ;

  {
  {
#line 399
  __asm__  ("bsfl %1,%0\n\t"
            "cmovzl %2,%0": "=r" (r): "rm" (x), "r" (-1));
  }
#line 408
  return (r + 1);
}
}
#line 422 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ int r ;

  {
  {
#line 426
  __asm__  ("bsrl %1,%0\n\t"
            "cmovzl %2,%0": "=&r" (r): "rm" (x), "rm" (-1));
  }
#line 435
  return (r + 1);
}
}
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bitops/sched.h"
__inline static int sched_find_first_bit(unsigned long const   *b ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 19
  if (*(b + 0)) {
    {
#line 20
    tmp = __ffs((unsigned long )*(b + 0));
    }
#line 20
    return ((int )tmp);
  }
#line 21
  if (*(b + 1)) {
    {
#line 22
    tmp___0 = __ffs((unsigned long )*(b + 1));
    }
#line 22
    return ((int )(tmp___0 + 32UL));
  }
#line 23
  if (*(b + 2)) {
    {
#line 24
    tmp___1 = __ffs((unsigned long )*(b + 2));
    }
#line 24
    return ((int )(tmp___1 + 64UL));
  }
  {
#line 25
  tmp___2 = __ffs((unsigned long )*(b + 3));
  }
#line 25
  return ((int )(tmp___2 + 96UL));
}
}
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bitops/hweight.h"
extern unsigned int hweight32(unsigned int w ) ;
#line 7
extern unsigned int hweight16(unsigned int w ) ;
#line 8
extern unsigned int hweight8(unsigned int w ) ;
#line 9
extern unsigned long hweight64(__u64 w ) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bitops/fls64.h"
__inline static int fls64(__u64 x ) 
{ __u32 h ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 20
  h = (__u32 )(x >> 32);
  }
#line 21
  if (h) {
    {
#line 22
    tmp = fls((int )h);
    }
#line 22
    return (tmp + 32);
  }
  {
#line 23
  tmp___0 = fls((int )x);
  }
#line 23
  return (tmp___0);
}
}
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val )  __attribute__((__const__)) ;
#line 7 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 

  {
  {
#line 21
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
  }
#line 25
  return (val);
}
}
#line 29
__inline static __u64 __arch_swab64(__u64 val )  __attribute__((__const__)) ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 

  {
  {
#line 53
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
  }
#line 56
  return (val);
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u16 __fswab16(__u16 val )  __attribute__((__const__)) ;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 

  {
#line 51
  return ((unsigned short )((((int )val & 255) << 8) | (((int )val & 65280) >> 8)));
}
}
#line 55
__inline static __u32 __fswab32(__u32 val )  __attribute__((__const__)) ;
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ __u32 tmp ;

  {
  {
#line 58
  tmp = __arch_swab32(val);
  }
#line 58
  return (tmp);
}
}
#line 64
__inline static __u64 __fswab64(__u64 val )  __attribute__((__const__)) ;
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ __u64 tmp ;

  {
  {
#line 67
  tmp = __arch_swab64(val);
  }
#line 67
  return (tmp);
}
}
#line 77
__inline static __u32 __fswahw32(__u32 val )  __attribute__((__const__)) ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __fswahw32(__u32 val ) 
{ 

  {
#line 82
  return (((val & 65535U) << 16) | ((val & 4294901760U) >> 16));
}
}
#line 86
__inline static __u32 __fswahb32(__u32 val )  __attribute__((__const__)) ;
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __fswahb32(__u32 val ) 
{ 

  {
#line 91
  return (((val & 16711935U) << 8) | ((val & 4278255360U) >> 8));
}
}
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
#line 153
  tmp = __fswab16((unsigned short )*p);
  }
#line 153
  return ((unsigned short )((int )tmp));
}
}
#line 161 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __swab32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 166
  tmp = __fswab32((unsigned int )*p);
  }
#line 166
  return (tmp);
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u64 __swab64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
#line 179
  tmp = __fswab64((unsigned long long )*p);
  }
#line 179
  return (tmp);
}
}
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __swahw32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 194
  tmp = __fswahw32((unsigned int )*p);
  }
#line 194
  return (tmp);
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static __u32 __swahb32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 209
  tmp = __fswahb32((unsigned int )*p);
  }
#line 209
  return (tmp);
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swab16s(__u16 *p ) 
{ 

  {
  {
#line 222
  *p = __swab16p((__u16 const   *)p);
  }
#line 224
  return;
}
}
#line 229 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swab32s(__u32 *p ) 
{ 

  {
  {
#line 234
  *p = __swab32p((__u32 const   *)p);
  }
#line 236
  return;
}
}
#line 242 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swab64s(__u64 *p ) 
{ 

  {
  {
#line 247
  *p = __swab64p((__u64 const   *)p);
  }
#line 249
  return;
}
}
#line 257 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swahw32s(__u32 *p ) 
{ 

  {
  {
#line 262
  *p = __swahw32p((__u32 const   *)p);
  }
#line 264
  return;
}
}
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swab.h"
__inline static void __swahb32s(__u32 *p ) 
{ 

  {
  {
#line 277
  *p = __swahb32p((__u32 const   *)p);
  }
#line 279
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __le64 __cpu_to_le64p(__u64 const   *p ) 
{ 

  {
#line 45
  return ((unsigned long long )*p);
}
}
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 

  {
#line 49
  return ((unsigned long long )*p);
}
}
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __le32 __cpu_to_le32p(__u32 const   *p ) 
{ 

  {
#line 53
  return ((unsigned int )*p);
}
}
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 

  {
#line 57
  return ((unsigned int )*p);
}
}
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __le16 __cpu_to_le16p(__u16 const   *p ) 
{ 

  {
#line 61
  return ((unsigned short )*p);
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 

  {
#line 65
  return ((unsigned short )*p);
}
}
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __be64 __cpu_to_be64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
#line 69
  tmp = __swab64p(p);
  }
#line 69
  return (tmp);
}
}
#line 71 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ __u64 tmp ;

  {
  {
#line 73
  tmp = __swab64p((__u64 const   *)((__u64 *)p));
  }
#line 73
  return (tmp);
}
}
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __be32 __cpu_to_be32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 77
  tmp = __swab32p(p);
  }
#line 77
  return (tmp);
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ __u32 tmp ;

  {
  {
#line 81
  tmp = __swab32p((__u32 const   *)((__u32 *)p));
  }
#line 81
  return (tmp);
}
}
#line 83 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __be16 __cpu_to_be16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
#line 85
  tmp = __swab16p(p);
  }
#line 85
  return (tmp);
}
}
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/little_endian.h"
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ __u16 tmp ;

  {
  {
#line 89
  tmp = __swab16p((__u16 const   *)((__u16 *)p));
  }
#line 89
  return (tmp);
}
}
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void le16_add_cpu(__le16 *var , u16 val ) 
{ 

  {
  {
#line 145
  *var = (unsigned short )((int )*var + (int )val);
  }
#line 146
  return;
}
}
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void le32_add_cpu(__le32 *var , u32 val ) 
{ 

  {
  {
#line 150
  *var += val;
  }
#line 151
  return;
}
}
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void le64_add_cpu(__le64 *var , u64 val ) 
{ 

  {
  {
#line 155
  *var += val;
  }
#line 156
  return;
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void be16_add_cpu(__be16 *var , u16 val ) 
{ __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;

  {
  {
#line 160
  tmp___2 = __fswab16(*var);
#line 160
  tmp___3 = __fswab16((unsigned short )((int )tmp___2 + (int )val));
#line 160
  *var = (unsigned short )((int )tmp___3);
  }
#line 161
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void be32_add_cpu(__be32 *var , u32 val ) 
{ __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
  {
#line 165
  tmp___4 = __fswab32(*var);
#line 165
  tmp___5 = __fswab32(tmp___4 + val);
#line 165
  *var = tmp___5;
  }
#line 166
  return;
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/byteorder/generic.h"
__inline static void be64_add_cpu(__be64 *var , u64 val ) 
{ __u64 tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;
  __u64 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;
  __u64 tmp___7 ;
  __u64 tmp___8 ;
  __u64 tmp___9 ;

  {
  {
#line 170
  tmp___8 = __fswab64(*var);
#line 170
  tmp___9 = __fswab64(tmp___8 + val);
#line 170
  *var = tmp___9;
  }
#line 171
  return;
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static int get_bitmask_order(unsigned int count ) 
{ int order ;

  {
  {
#line 29
  order = fls((int )count);
  }
#line 30
  return (order);
}
}
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static int get_count_order(unsigned int count ) 
{ int order ;
  int tmp ;

  {
  {
#line 37
  tmp = fls((int )count);
#line 37
  order = tmp - 1;
  }
#line 38
  if (count & (count - 1U)) {
    {
#line 39
    order ++;
    }
  }
#line 40
  return (order);
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static unsigned long hweight_long(unsigned long w ) 
{ unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 45
  if (sizeof(w) == 4UL) {
    {
#line 45
    tmp = hweight32((unsigned int )w);
#line 45
    tmp___1 = (unsigned long )tmp;
    }
  } else {
    {
#line 45
    tmp___0 = hweight64((unsigned long long )w);
#line 45
    tmp___1 = tmp___0;
    }
  }
#line 45
  return (tmp___1);
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 

  {
#line 55
  return ((word << shift) | (word >> (32U - shift)));
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u32 ror32(__u32 word , unsigned int shift ) 
{ 

  {
#line 65
  return ((word >> shift) | (word << (32U - shift)));
}
}
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u16 rol16(__u16 word , unsigned int shift ) 
{ 

  {
#line 75
  return ((unsigned short )(((int )word << shift) | ((int )word >> (16U - shift))));
}
}
#line 83 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u16 ror16(__u16 word , unsigned int shift ) 
{ 

  {
#line 85
  return ((unsigned short )(((int )word >> shift) | ((int )word << (16U - shift))));
}
}
#line 93 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u8 rol8(__u8 word , unsigned int shift ) 
{ 

  {
#line 95
  return ((unsigned char )(((int )word << shift) | ((int )word >> (8U - shift))));
}
}
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static __u8 ror8(__u8 word , unsigned int shift ) 
{ 

  {
#line 105
  return ((unsigned char )(((int )word >> shift) | ((int )word << (8U - shift))));
}
}
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 110
  if (sizeof(l) == 4UL) {
    {
#line 111
    tmp = fls((int )l);
    }
#line 111
    return ((unsigned int )tmp);
  }
  {
#line 112
  tmp___0 = fls64((unsigned long long )l);
  }
#line 112
  return ((unsigned int )tmp___0);
}
}
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitops.h"
__inline static unsigned long __ffs64(u64 word ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 126
  if ((unsigned long )((unsigned int )word) == 0UL) {
    {
#line 127
    tmp = __ffs((unsigned long )((unsigned int )(word >> 32)));
    }
#line 127
    return (tmp + 32UL);
  }
  {
#line 131
  tmp___0 = __ffs((unsigned long )word);
  }
#line 131
  return (tmp___0);
}
}
#line 144
extern unsigned long find_first_bit(unsigned long const   *addr , unsigned long size ) ;
#line 154
extern unsigned long find_first_zero_bit(unsigned long const   *addr , unsigned long size ) ;
#line 166
extern unsigned long find_last_bit(unsigned long const   *addr , unsigned long size ) ;
#line 178
extern unsigned long find_next_bit(unsigned long const   *addr , unsigned long size ,
                                   unsigned long offset ) ;
#line 188
extern unsigned long find_next_zero_bit(unsigned long const   *addr , unsigned long size ,
                                        unsigned long offset ) ;
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cpufeature.h"
extern char const   * const  x86_cap_flags[288] ;
#line 172
extern char const   * const  x86_power_flags[32] ;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static void __set_64bit(unsigned long long *ptr , unsigned int low , unsigned int high ) 
{ 

  {
  {
#line 36
  __asm__  volatile   ("\n1:\t"
                       "movl (%0), %%eax\n\t"
                       "movl 4(%0), %%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b (%0)\n\t"
                       "jnz 1b": : "D" (ptr), "b" (low), "c" (high): "ax", "dx", "memory");
  }
#line 46
  return;
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static void __set_64bit_constant(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
#line 51
  __set_64bit(ptr, (unsigned int )value, (unsigned int )(value >> 32));
  }
#line 52
  return;
}
}
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static void __set_64bit_var(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
#line 60
  __set_64bit(ptr, *((unsigned int *)(& value) + 0), *((unsigned int *)(& value) + 1));
  }
#line 61
  return;
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __xchg(unsigned long x , void volatile   *ptr , int size ) 
{ 

  {
#line 83
  if (size == 1) {
    goto switch_1_1;
  } else {
#line 89
    if (size == 2) {
      goto switch_1_2;
    } else {
#line 95
      if (size == 4) {
        goto switch_1_4;
      } else {
#line 82
        if (0) {
          switch_1_1: /* CIL Label */ 
          {
#line 84
          __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
          switch_1_2: /* CIL Label */ 
          {
#line 90
          __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
          switch_1_4: /* CIL Label */ 
          {
#line 96
          __asm__  volatile   ("xchgl %0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
        } else {
          switch_1_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 102
  return (x);
}
}
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __cmpxchg(void volatile   *ptr , unsigned long old ,
                                        unsigned long new , int size ) 
{ unsigned long prev ;

  {
#line 141
  if (size == 1) {
    goto switch_2_1;
  } else {
#line 147
    if (size == 2) {
      goto switch_2_2;
    } else {
#line 153
      if (size == 4) {
        goto switch_2_4;
      } else {
#line 140
        if (0) {
          switch_2_1: /* CIL Label */ 
          {
#line 142
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 146
          return (prev);
          switch_2_2: /* CIL Label */ 
          {
#line 148
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 152
          return (prev);
          switch_2_4: /* CIL Label */ 
          {
#line 154
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 158
          return (prev);
        } else {
          switch_2_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 160
  return (old);
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __sync_cmpxchg(void volatile   *ptr , unsigned long old ,
                                             unsigned long new , int size ) 
{ unsigned long prev ;

  {
#line 174
  if (size == 1) {
    goto switch_3_1;
  } else {
#line 180
    if (size == 2) {
      goto switch_3_2;
    } else {
#line 186
      if (size == 4) {
        goto switch_3_4;
      } else {
#line 173
        if (0) {
          switch_3_1: /* CIL Label */ 
          {
#line 175
          __asm__  volatile   ("lock; cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 179
          return (prev);
          switch_3_2: /* CIL Label */ 
          {
#line 181
          __asm__  volatile   ("lock; cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 185
          return (prev);
          switch_3_4: /* CIL Label */ 
          {
#line 187
          __asm__  volatile   ("lock; cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 191
          return (prev);
        } else {
          switch_3_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 193
  return (old);
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long __cmpxchg_local(void volatile   *ptr , unsigned long old ,
                                              unsigned long new , int size ) 
{ unsigned long prev ;

  {
#line 202
  if (size == 1) {
    goto switch_4_1;
  } else {
#line 208
    if (size == 2) {
      goto switch_4_2;
    } else {
#line 214
      if (size == 4) {
        goto switch_4_4;
      } else {
#line 201
        if (0) {
          switch_4_1: /* CIL Label */ 
          {
#line 203
          __asm__  volatile   ("cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 207
          return (prev);
          switch_4_2: /* CIL Label */ 
          {
#line 209
          __asm__  volatile   ("cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 213
          return (prev);
          switch_4_4: /* CIL Label */ 
          {
#line 215
          __asm__  volatile   ("cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
#line 219
          return (prev);
        } else {
          switch_4_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 221
  return (old);
}
}
#line 224 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long long __cmpxchg64(void volatile   *ptr , unsigned long long old ,
                                               unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
#line 229
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
#line 236
  return (prev);
}
}
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cmpxchg_32.h"
__inline static unsigned long long __cmpxchg64_local(void volatile   *ptr , unsigned long long old ,
                                                     unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
#line 244
  __asm__  volatile   ("cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
#line 251
  return (prev);
}
}
#line 313
extern unsigned long long cmpxchg_486_u64(void volatile   * , u64  , u64  ) ;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
extern  __attribute__((__noreturn__)) int ____ilog2_NaN(void)  __attribute__((__const__)) ;
#line 31
__inline static int __ilog2_u32(u32 n )  __attribute__((__const__)) ;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ int tmp ;

  {
  {
#line 34
  tmp = fls((int )n);
  }
#line 34
  return (tmp - 1);
}
}
#line 39
__inline static int __ilog2_u64(u64 n )  __attribute__((__const__)) ;
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static int __ilog2_u64(u64 n ) 
{ int tmp ;

  {
  {
#line 42
  tmp = fls64(n);
  }
#line 42
  return (tmp - 1);
}
}
#line 51
__inline static bool is_power_of_2(unsigned long n )  __attribute__((__const__)) ;
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static bool is_power_of_2(unsigned long n ) 
{ int tmp ;

  {
#line 54
  if (n != 0UL) {
#line 54
    if ((n & (n - 1UL)) == 0UL) {
      {
#line 54
      tmp = 1;
      }
    } else {
      {
#line 54
      tmp = 0;
      }
    }
  } else {
    {
#line 54
    tmp = 0;
    }
  }
#line 54
  return ((_Bool )tmp);
}
}
#line 60
__inline static unsigned long __roundup_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
#line 63
  tmp = fls_long(n - 1UL);
  }
#line 63
  return (1UL << tmp);
}
}
#line 69
__inline static unsigned long __rounddown_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/log2.h"
__inline static unsigned long __rounddown_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
#line 72
  tmp = fls_long(n);
  }
#line 72
  return (1UL << (tmp - 1U));
}
}
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ratelimit.h"
extern int __ratelimit(struct ratelimit_state *rs ) ;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dynamic_debug.h"
extern long long dynamic_debug_enabled ;
#line 9
extern long long dynamic_debug_enabled2 ;
#line 39
extern int ddebug_add_module(struct _ddebug *tab , unsigned int n , char const   *modname ) ;
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dynamic_debug.h"
__inline static int ddebug_remove_module(char *mod ) 
{ 

  {
#line 81
  return (0);
}
}
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/bug.h"
extern void ( /* format attribute */  warn_slowpath_fmt)(char const   *file , int line ,
                                                         char const   *fmt  , ...) ;
#line 63
extern void warn_slowpath_null(char const   *file , int line ) ;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
extern char const   linux_banner[] ;
#line 24
extern char const   linux_proc_banner[] ;
#line 107
extern int console_printk[] ;
#line 119
extern int _cond_resched(void) ;
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void might_fault(void) 
{ 

  {
  {
#line 155
  while (1) {
    while_5_continue: /* CIL Label */ ;
    {
#line 155
    _cond_resched();
    }
    goto while_5_break;
  }
  while_5_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 159
extern struct atomic_notifier_head panic_notifier_list ;
#line 160
extern long (*panic_blink)(long time ) ;
#line 161
extern  __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *fmt 
                                                                            , ...) ;
#line 163
extern void oops_enter(void) ;
#line 164
extern void oops_exit(void) ;
#line 165
extern int oops_may_print(void) ;
#line 166
extern  __attribute__((__noreturn__)) void do_exit(long error_code ) ;
#line 168
extern  __attribute__((__noreturn__)) void complete_and_exit(struct completion * ,
                                                             long  ) ;
#line 170
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
#line 171
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 172
extern unsigned long long simple_strtoull(char const   * , char ** , unsigned int  ) ;
#line 173
extern long long simple_strtoll(char const   * , char ** , unsigned int  ) ;
#line 174
extern int strict_strtoul(char const   * , unsigned int  , unsigned long * ) ;
#line 175
extern int strict_strtol(char const   * , unsigned int  , long * ) ;
#line 176
extern int strict_strtoull(char const   * , unsigned int  , unsigned long long * ) ;
#line 177
extern int strict_strtoll(char const   * , unsigned int  , long long * ) ;
#line 178
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
#line 180
extern int ( /* format attribute */  vsprintf)(char *buf , char const   * , va_list  ) ;
#line 182
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
#line 184
extern int ( /* format attribute */  vsnprintf)(char *buf , size_t size , char const   *fmt ,
                                                va_list args ) ;
#line 186
extern int ( /* format attribute */  scnprintf)(char *buf , size_t size , char const   *fmt 
                                                , ...) ;
#line 188
extern int ( /* format attribute */  vscnprintf)(char *buf , size_t size , char const   *fmt ,
                                                 va_list args ) ;
#line 190
extern char *( /* format attribute */  kasprintf)(gfp_t gfp , char const   *fmt  , ...) ;
#line 192
extern char *kvasprintf(gfp_t gfp , char const   *fmt , va_list args ) ;
#line 194
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
#line 196
extern int ( /* format attribute */  vsscanf)(char const   * , char const   * , va_list  ) ;
#line 199
extern int get_option(char **str , int *pint ) ;
#line 200
extern char *get_options(char const   *str , int nints , int *ints ) ;
#line 201
extern unsigned long long memparse(char const   *ptr , char **retptr ) ;
#line 203
extern int core_kernel_text(unsigned long addr ) ;
#line 204
extern int __kernel_text_address(unsigned long addr ) ;
#line 205
extern int kernel_text_address(unsigned long addr ) ;
#line 206
extern int func_ptr_is_kernel_text(void *ptr ) ;
#line 209
extern struct pid *session_of_pgrp(struct pid *pgrp ) ;
#line 236
extern int ( /* format attribute */ __attribute__((__regparm__(0))) vprintk)(char const   *fmt ,
                                                                             va_list args ) ;
#line 238
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...) ;
#line 241
extern struct ratelimit_state printk_ratelimit_state ;
#line 242
extern int printk_ratelimit(void) ;
#line 243
extern bool printk_timed_ratelimit(unsigned long *caller_jiffies , unsigned int interval_msec ) ;
#line 258
extern void log_buf_kexec_setup(void) ;
#line 279
extern int printk_needs_cpu(int cpu ) ;
#line 280
extern void printk_tick(void) ;
#line 282
extern void ( /* format attribute */ __attribute__((__regparm__(0))) early_printk)(char const   *fmt 
                                                                                   , ...) ;
#line 285
extern unsigned long int_sqrt(unsigned long  ) ;
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void console_silent(void) 
{ 

  {
  {
#line 289
  console_printk[0] = 0;
  }
#line 290
  return;
}
}
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void console_verbose(void) 
{ 

  {
#line 294
  if (console_printk[0]) {
    {
#line 295
    console_printk[0] = 15;
    }
  }
#line 296
  return;
}
}
#line 298
extern void bust_spinlocks(int yes ) ;
#line 299
extern void wake_up_klogd(void) ;
#line 300
extern int oops_in_progress ;
#line 301
extern int panic_timeout ;
#line 302
extern int panic_on_oops ;
#line 303
extern int panic_on_unrecovered_nmi ;
#line 304
extern char const   *print_tainted(void) ;
#line 305
extern void add_taint(unsigned int flag ) ;
#line 306
extern int test_taint(unsigned int flag ) ;
#line 307
extern unsigned long get_taint(void) ;
#line 308
extern int root_mountflags ;
#line 311
extern enum system_states system_state ;
#line 332
extern void dump_stack(void) ;
#line 339
extern void hex_dump_to_buffer(void const   *buf , size_t len , int rowsize , int groupsize ,
                               char *linebuf , size_t linebuflen , bool ascii ) ;
#line 342
extern void print_hex_dump(char const   *level , char const   *prefix_str , int prefix_type ,
                           int rowsize , int groupsize , void const   *buf , size_t len ,
                           bool ascii ) ;
#line 345
extern void print_hex_dump_bytes(char const   *prefix_str , int prefix_type , void const   *buf ,
                                 size_t len ) ;
#line 348
extern char const   hex_asc[] ;
#line 352 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static char *pack_hex_byte(char *buf , u8 byte ) 
{ char *tmp ;
  char *tmp___0 ;

  {
  {
#line 354
  tmp = buf;
#line 354
  buf ++;
#line 354
  *tmp = (char )hex_asc[((int )byte & 240) >> 4];
#line 355
  tmp___0 = buf;
#line 355
  buf ++;
#line 355
  *tmp___0 = (char )hex_asc[(int )byte & 15];
  }
#line 356
  return (buf);
}
}
#line 423
extern void tracing_on(void) ;
#line 424
extern void tracing_off(void) ;
#line 426
extern void tracing_off_permanent(void) ;
#line 427
extern int tracing_is_on(void) ;
#line 435
extern void tracing_start(void) ;
#line 436
extern void tracing_stop(void) ;
#line 437
extern void ftrace_off_permanent(void) ;
#line 439
extern void ftrace_special(unsigned long arg1 , unsigned long arg2 , unsigned long arg3 ) ;
#line 442 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kernel.h"
__inline static void ( /* format attribute */  ____trace_printk_check_format)(char const   *fmt 
                                                                              , ...) 
{ 

  {
#line 445
  return;
}
}
#line 482
extern int ( /* format attribute */  __trace_bprintk)(unsigned long ip , char const   *fmt 
                                                      , ...) ;
#line 486
extern int ( /* format attribute */  __trace_printk)(unsigned long ip , char const   *fmt 
                                                     , ...) ;
#line 507
extern int __ftrace_vbprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
#line 510
extern int __ftrace_vprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
#line 513
extern void ftrace_dump(void) ;
#line 652
extern int do_sysinfo(struct sysinfo *info ) ;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long native_save_fl(void) 
{ unsigned long flags ;

  {
  {
#line 21
  __asm__  volatile   ("# __raw_save_flags\n\t"
                       "pushf ; pop %0": "=r" (flags): : "memory");
  }
#line 27
  return (flags);
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_restore_fl(unsigned long flags ) 
{ 

  {
  {
#line 32
  __asm__  volatile   ("push %0 ; popf": : "g" (flags): "memory", "cc");
  }
#line 36
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_irq_disable(void) 
{ 

  {
  {
#line 40
  __asm__  volatile   ("cli": : : "memory");
  }
#line 41
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_irq_enable(void) 
{ 

  {
  {
#line 45
  __asm__  volatile   ("sti": : : "memory");
  }
#line 46
  return;
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_safe_halt(void) 
{ 

  {
  {
#line 50
  __asm__  volatile   ("sti; hlt": : : "memory");
  }
#line 51
  return;
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void native_halt(void) 
{ 

  {
  {
#line 55
  __asm__  volatile   ("hlt": : : "memory");
  }
#line 56
  return;
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long __raw_local_save_flags(void) 
{ unsigned long tmp ;

  {
  {
#line 67
  tmp = native_save_fl();
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_local_irq_restore(unsigned long flags ) 
{ 

  {
  {
#line 72
  native_restore_fl(flags);
  }
#line 73
  return;
}
}
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_local_irq_disable(void) 
{ 

  {
  {
#line 77
  native_irq_disable();
  }
#line 78
  return;
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_local_irq_enable(void) 
{ 

  {
  {
#line 82
  native_irq_enable();
  }
#line 83
  return;
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void raw_safe_halt(void) 
{ 

  {
  {
#line 91
  native_safe_halt();
  }
#line 92
  return;
}
}
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static void halt(void) 
{ 

  {
  {
#line 100
  native_halt();
  }
#line 101
  return;
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static unsigned long __raw_local_irq_save(void) 
{ unsigned long flags ;
  unsigned long tmp ;

  {
  {
#line 108
  tmp = __raw_local_save_flags();
#line 108
  flags = tmp;
#line 110
  raw_local_irq_disable();
  }
#line 112
  return (flags);
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static int raw_irqs_disabled_flags(unsigned long flags ) 
{ 

  {
#line 165
  return (! (flags & 512UL));
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irqflags.h"
__inline static int raw_irqs_disabled(void) 
{ unsigned long flags ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 170
  tmp = __raw_local_save_flags();
#line 170
  flags = tmp;
#line 172
  tmp___0 = raw_irqs_disabled_flags(flags);
  }
#line 172
  return (tmp___0);
}
}
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
extern struct task_struct *__switch_to(struct task_struct *prev , struct task_struct *next ) ;
#line 24
extern void __switch_to_xtra(struct task_struct *prev_p , struct task_struct *next_p ,
                             struct tss_struct *tss ) ;
#line 181
extern void native_load_gs_index(unsigned int  ) ;
#line 226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long get_limit(unsigned long segment ) 
{ unsigned long __limit ;

  {
  {
#line 229
  __asm__  ("lsll %1,%0": "=r" (__limit): "r" (segment));
  }
#line 230
  return (__limit + 1UL);
}
}
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_clts(void) 
{ 

  {
  {
#line 235
  __asm__  volatile   ("clts":);
  }
#line 236
  return;
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
static unsigned long __force_order  ;
#line 247 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr0(void) 
{ unsigned long val ;

  {
  {
#line 250
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 251
  return (val);
}
}
#line 254 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr0(unsigned long val ) 
{ 

  {
  {
#line 256
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order));
  }
#line 257
  return;
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr2(void) 
{ unsigned long val ;

  {
  {
#line 262
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 263
  return (val);
}
}
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr2(unsigned long val ) 
{ 

  {
  {
#line 268
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order));
  }
#line 269
  return;
}
}
#line 271 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr3(void) 
{ unsigned long val ;

  {
  {
#line 274
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 275
  return (val);
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr3(unsigned long val ) 
{ 

  {
  {
#line 280
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order));
  }
#line 281
  return;
}
}
#line 283 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr4(void) 
{ unsigned long val ;

  {
  {
#line 286
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order));
  }
#line 287
  return (val);
}
}
#line 290 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static unsigned long native_read_cr4_safe(void) 
{ unsigned long val ;

  {
  {
#line 296
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order): "0" (0));
  }
#line 303
  return (val);
}
}
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_write_cr4(unsigned long val ) 
{ 

  {
  {
#line 308
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order));
  }
#line 309
  return;
}
}
#line 325 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void native_wbinvd(void) 
{ 

  {
  {
#line 327
  __asm__  volatile   ("wbinvd": : : "memory");
  }
#line 328
  return;
}
}
#line 358 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void clflush(void volatile   *__p ) 
{ 

  {
  {
#line 360
  __asm__  volatile   ("clflush %0": "+m" (*((char volatile   *)__p)));
  }
#line 361
  return;
}
}
#line 365
extern void disable_hlt(void) ;
#line 366
extern void enable_hlt(void) ;
#line 368
extern void cpu_idle_wait(void) ;
#line 370
extern unsigned long arch_align_stack(unsigned long sp ) ;
#line 371
extern void free_init_pages(char *what , unsigned long begin , unsigned long end ) ;
#line 373
extern void default_idle(void) ;
#line 375
extern void stop_this_cpu(void *dummy ) ;
#line 479 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/system.h"
__inline static void rdtsc_barrier(void) 
{ 

  {
  {
#line 481
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (113): "memory");
#line 482
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (114): "memory");
  }
#line 483
  return;
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_32_types.h"
extern unsigned int __VMALLOC_RESERVE ;
#line 54
extern int sysctl_legacy_va_layout ;
#line 56
extern void find_low_pfn_range(void) ;
#line 57
extern unsigned long init_memory_mapping(unsigned long start , unsigned long end ) ;
#line 59
extern void initmem_init(unsigned long  , unsigned long  ) ;
#line 60
extern void free_initmem(void) ;
#line 61
extern void setup_bootmem_allocator(void) ;
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_types.h"
extern int page_is_ram(unsigned long pagenr ) ;
#line 44
extern int devmem_is_allowed(unsigned long pagenr ) ;
#line 46
extern unsigned long max_low_pfn_mapped ;
#line 47
extern unsigned long max_pfn_mapped ;
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/string.h"
extern char *strndup_user(char const   * , long  ) ;
#line 16
extern void *memdup_user(void const   * , size_t  ) ;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
extern char *strcpy(char *dest , char const   *src ) ;
#line 12
extern char *strncpy(char *dest , char const   *src , size_t count ) ;
#line 15
extern char *strcat(char *dest , char const   *src ) ;
#line 18
extern char *strncat(char *dest , char const   *src , size_t count ) ;
#line 21
extern int strcmp(char const   *cs , char const   *ct ) ;
#line 24
extern int strncmp(char const   *cs , char const   *ct , size_t count ) ;
#line 27
extern char *strchr(char const   *s , int c ) ;
#line 30
extern size_t strlen(char const   *s ) ;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__memcpy(void *to , void const   *from , size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  {
#line 35
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  }
#line 44
  return (to);
}
}
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__constant_memcpy(void *to , void const   *from , size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;

  {
#line 55
  if (! n) {
#line 56
    return (to);
  }
#line 59
  if ((int )n == 1) {
    goto switch_6_1;
  } else {
#line 62
    if ((int )n == 2) {
      goto switch_6_2;
    } else {
#line 65
      if ((int )n == 4) {
        goto switch_6_4;
      } else {
#line 69
        if ((int )n == 3) {
          goto switch_6_3;
        } else {
#line 73
          if ((int )n == 5) {
            goto switch_6_5;
          } else {
#line 77
            if ((int )n == 6) {
              goto switch_6_6;
            } else {
#line 81
              if ((int )n == 8) {
                goto switch_6_8;
              } else {
#line 58
                if (0) {
                  switch_6_1: /* CIL Label */ 
                  {
#line 60
                  *((char *)to) = *((char *)from);
                  }
#line 61
                  return (to);
                  switch_6_2: /* CIL Label */ 
                  {
#line 63
                  *((short *)to) = *((short *)from);
                  }
#line 64
                  return (to);
                  switch_6_4: /* CIL Label */ 
                  {
#line 66
                  *((int *)to) = *((int *)from);
                  }
#line 67
                  return (to);
                  switch_6_3: /* CIL Label */ 
                  {
#line 70
                  *((short *)to) = *((short *)from);
#line 71
                  *((char *)to + 2) = *((char *)from + 2);
                  }
#line 72
                  return (to);
                  switch_6_5: /* CIL Label */ 
                  {
#line 74
                  *((int *)to) = *((int *)from);
#line 75
                  *((char *)to + 4) = *((char *)from + 4);
                  }
#line 76
                  return (to);
                  switch_6_6: /* CIL Label */ 
                  {
#line 78
                  *((int *)to) = *((int *)from);
#line 79
                  *((short *)to + 2) = *((short *)from + 2);
                  }
#line 80
                  return (to);
                  switch_6_8: /* CIL Label */ 
                  {
#line 82
                  *((int *)to) = *((int *)from);
#line 83
                  *((int *)to + 1) = *((int *)from + 1);
                  }
#line 84
                  return (to);
                } else {
                  switch_6_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 87
  esi = (long )from;
#line 88
  edi = (long )to;
  }
#line 89
  if (n >= 20U) {
    {
#line 92
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n / 4U),
                         "1" (edi), "2" (esi): "memory");
    }
  } else {
#line 99
    if (n >= 16U) {
      {
#line 100
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
#line 104
    if (n >= 12U) {
      {
#line 105
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
#line 109
    if (n >= 8U) {
      {
#line 110
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
#line 114
    if (n >= 4U) {
      {
#line 115
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
  }
#line 122
  if ((int )(n % 4U) == 0) {
    goto switch_7_0;
  } else {
#line 124
    if ((int )(n % 4U) == 1) {
      goto switch_7_1;
    } else {
#line 130
      if ((int )(n % 4U) == 2) {
        goto switch_7_2;
      } else {
        {
        goto switch_7_default;
#line 120
        if (0) {
          switch_7_0: /* CIL Label */ 
#line 123
          return (to);
          switch_7_1: /* CIL Label */ 
          {
#line 125
          __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
#line 129
          return (to);
          switch_7_2: /* CIL Label */ 
          {
#line 131
          __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
#line 135
          return (to);
          switch_7_default: /* CIL Label */ 
          {
#line 137
          __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi),
                               "1" (esi): "memory");
          }
#line 141
          return (to);
        } else {
          switch_7_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 188
extern void *memmove(void *dest , void const   *src , size_t n ) ;
#line 193
extern void *memchr(void const   *cs , int c , size_t count ) ;
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__memset_generic(void *s , char c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
#line 198
  __asm__  volatile   ("rep\n\t"
                       "stosb": "=&c" (d0), "=&D" (d1): "a" (c), "1" (s), "0" (count): "memory");
  }
#line 203
  return (s);
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__constant_c_memset(void *s , unsigned long c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
#line 218
  __asm__  volatile   ("rep ; stosl\n\t"
                       "testb $2,%b3\n\t"
                       "je 1f\n\t"
                       "stosw\n"
                       "1:\ttestb $1,%b3\n\t"
                       "je 2f\n\t"
                       "stosb\n"
                       "2:": "=&c" (d0), "=&D" (d1): "a" (c), "q" (count), "0" (count / 4U),
                       "1" ((long )s): "memory");
  }
#line 229
  return (s);
}
}
#line 234
extern size_t strnlen(char const   *s , size_t count ) ;
#line 238
extern char *strstr(char const   *cs , char const   *ct ) ;
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/string_32.h"
__inline static void *__constant_c_and_count_memset(void *s , unsigned long pattern ,
                                                    size_t count ) 
{ int d0 ;
  int d1 ;
  unsigned long eax ;

  {
#line 249
  if ((int )count == 0) {
    goto switch_8_0;
  } else {
#line 251
    if ((int )count == 1) {
      goto switch_8_1;
    } else {
#line 254
      if ((int )count == 2) {
        goto switch_8_2;
      } else {
#line 257
        if ((int )count == 3) {
          goto switch_8_3;
        } else {
#line 261
          if ((int )count == 4) {
            goto switch_8_4;
          } else {
#line 248
            if (0) {
              switch_8_0: /* CIL Label */ 
#line 250
              return (s);
              switch_8_1: /* CIL Label */ 
              {
#line 252
              *((unsigned char *)s) = (unsigned char )(pattern & 255UL);
              }
#line 253
              return (s);
              switch_8_2: /* CIL Label */ 
              {
#line 255
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              }
#line 256
              return (s);
              switch_8_3: /* CIL Label */ 
              {
#line 258
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
#line 259
              *((unsigned char *)s + 2) = (unsigned char )(pattern & 255UL);
              }
#line 260
              return (s);
              switch_8_4: /* CIL Label */ 
              {
#line 262
              *((unsigned long *)s) = pattern;
              }
#line 263
              return (s);
            } else {
              switch_8_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 279
  eax = pattern;
  }
#line 283
  if ((int )(count % 4U) == 0) {
    goto switch_9_0;
  } else {
#line 286
    if ((int )(count % 4U) == 1) {
      goto switch_9_1;
    } else {
#line 289
      if ((int )(count % 4U) == 2) {
        goto switch_9_2;
      } else {
        {
        goto switch_9_default;
#line 282
        if (0) {
          switch_9_0: /* CIL Label */ 
          {
#line 284
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
#line 285
          return (s);
          switch_9_1: /* CIL Label */ 
          {
#line 287
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
#line 288
          return (s);
          switch_9_2: /* CIL Label */ 
          {
#line 290
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
#line 291
          return (s);
          switch_9_default: /* CIL Label */ 
          {
#line 293
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
#line 294
          return (s);
        } else {
          switch_9_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 322
extern void *memscan(void *addr , int c , size_t size ) ;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 39
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
#line 48
extern int strnicmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 51
extern int strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 54
extern int strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 60
extern char *strnchr(char const   * , size_t  , int  ) ;
#line 63
extern char *strrchr(char const   * , int  ) ;
#line 65
extern char *strstrip(char * ) ;
#line 76
extern char *strpbrk(char const   * , char const   * ) ;
#line 79
extern char *strsep(char ** , char const   * ) ;
#line 82
extern __kernel_size_t strspn(char const   * , char const   * ) ;
#line 85
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
#line 101
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
#line 107
extern char *kstrdup(char const   *s , gfp_t gfp ) ;
#line 108
extern char *kstrndup(char const   *s , size_t len , gfp_t gfp ) ;
#line 109
extern void *kmemdup(void const   *src , size_t len , gfp_t gfp ) ;
#line 111
extern char **argv_split(gfp_t gfp , char const   *str , int *argcp ) ;
#line 112
extern void argv_free(char **argv ) ;
#line 114
extern bool sysfs_streq(char const   *s1 , char const   *s2 ) ;
#line 117
extern int vbin_printf(u32 *bin_buf , size_t size , char const   *fmt , va_list args ) ;
#line 118
extern int bstr_printf(char *buf , size_t size , char const   *fmt , u32 const   *bin_buf ) ;
#line 119
extern int ( /* format attribute */  bprintf)(u32 *bin_buf , size_t size , char const   *fmt 
                                              , ...) ;
#line 122
extern ssize_t memory_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/string.h"
__inline static bool strstarts(char const   *str , char const   *prefix ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  {
#line 132
  tmp = strlen(prefix);
#line 132
  tmp___0 = strncmp(str, prefix, tmp);
  }
#line 132
  return ((_Bool )(tmp___0 == 0));
}
}
#line 39 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_32.h"
__inline static void clear_page(void *page ) 
{ 

  {
  {
#line 41
  __constant_c_and_count_memset(page, 0UL, (unsigned int )(1UL << 12));
  }
#line 42
  return;
}
}
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page_32.h"
__inline static void copy_page(void *to , void *from ) 
{ 

  {
  {
#line 46
  __constant_memcpy(to, (void const   *)from, (unsigned int )(1UL << 12));
  }
#line 47
  return;
}
}
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page.h"
__inline static void clear_user_page(void *page , unsigned long vaddr , struct page *pg ) 
{ 

  {
  {
#line 23
  clear_page(page);
  }
#line 24
  return;
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/page.h"
__inline static void copy_user_page(void *to , void *from , unsigned long vaddr ,
                                    struct page *topage ) 
{ 

  {
  {
#line 29
  copy_page(to, from);
  }
#line 30
  return;
}
}
#line 53
extern bool __virt_addr_valid(unsigned long kaddr ) ;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/page.h"
__inline static int get_order(unsigned long size )  __attribute__((__const__)) ;
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/page.h"
__inline static int get_order(unsigned long size ) 
{ int order ;

  {
  {
#line 13
  size = (size - 1UL) >> 11;
#line 14
  order = -1;
  }
  {
#line 15
  while (1) {
    while_10_continue: /* CIL Label */ ;
    {
#line 16
    size >>= 1;
#line 17
    order ++;
    }
#line 15
    if (! size) {
      goto while_10_break;
    }
  }
  while_10_break: /* CIL Label */ ;
  }
#line 19
  return (order);
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_32_types.h"
extern bool __vmalloc_start_set ;
#line 186 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgd_t native_make_pgd(pgdval_t val ) 
{ pgd_t __constr_expr_0 ;

  {
  {
#line 188
  __constr_expr_0.pgd = val;
  }
#line 188
  return (__constr_expr_0);
}
}
#line 191 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t native_pgd_val(pgd_t pgd ) 
{ 

  {
#line 193
  return (pgd.pgd);
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t pgd_flags(pgd_t pgd ) 
{ pgdval_t tmp ;

  {
  {
#line 198
  tmp = native_pgd_val(pgd);
  }
#line 198
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static int pgd_none(pgd_t pgd ) 
{ 

  {
#line 25
  return (0);
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static int pgd_bad(pgd_t pgd ) 
{ 

  {
#line 26
  return (0);
}
}
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static int pgd_present(pgd_t pgd ) 
{ 

  {
#line 27
  return (1);
}
}
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static void pgd_clear(pgd_t *pgd ) 
{ 

  {
#line 28
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopud.h"
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address ) 
{ 

  {
#line 40
  return ((pud_t *)pgd);
}
}
#line 216 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t native_pud_val(pud_t pud ) 
{ pgdval_t tmp ;

  {
  {
#line 218
  tmp = native_pgd_val(pud.pgd);
  }
#line 218
  return (tmp);
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static int pud_none(pud_t pud ) 
{ 

  {
#line 29
  return (0);
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static int pud_bad(pud_t pud ) 
{ 

  {
#line 30
  return (0);
}
}
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static int pud_present(pud_t pud ) 
{ 

  {
#line 31
  return (1);
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static void pud_clear(pud_t *pud ) 
{ 

  {
#line 32
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address ) 
{ 

  {
#line 45
  return ((pmd_t *)pud);
}
}
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable-nopmd.h"
__inline static void pmd_free(struct mm_struct *mm , pmd_t *pmd ) 
{ 

  {
#line 61
  return;
}
}
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t native_pmd_val(pmd_t pmd ) 
{ pgdval_t tmp ;

  {
  {
#line 239
  tmp = native_pgd_val(pmd.pud.pgd);
  }
#line 239
  return (tmp);
}
}
#line 243 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t pud_flags(pud_t pud ) 
{ pudval_t tmp ;

  {
  {
#line 245
  tmp = native_pud_val(pud);
  }
#line 245
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 248 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t pmd_flags(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
#line 250
  tmp = native_pmd_val(pmd);
  }
#line 250
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pte_t native_make_pte(pteval_t val ) 
{ pte_t __constr_expr_0 ;

  {
  {
#line 255
  __constr_expr_0.pte = val;
  }
#line 255
  return (__constr_expr_0);
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t native_pte_val(pte_t pte ) 
{ 

  {
#line 260
  return (pte.pte);
}
}
#line 263 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t pte_flags(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 265
  tmp = native_pte_val(pte);
  }
#line 265
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
#line 274
extern pteval_t __supported_pte_mask ;
#line 275
extern int nx_enabled ;
#line 276
extern void set_nx(void) ;
#line 279
extern pgprot_t pgprot_writecombine(pgprot_t prot ) ;
#line 286
extern pgprot_t phys_mem_access_prot(struct file *file , unsigned long pfn , unsigned long size ,
                                     pgprot_t vma_prot ) ;
#line 288
extern int phys_mem_access_prot_allowed(struct file *file , unsigned long pfn , unsigned long size ,
                                        pgprot_t *vma_prot ) ;
#line 292
extern void set_pte_vaddr(unsigned long vaddr , pte_t pte ) ;
#line 295
extern void native_pagetable_setup_start(pgd_t *base ) ;
#line 296
extern void native_pagetable_setup_done(pgd_t *base ) ;
#line 303
extern void arch_report_meminfo(struct seq_file *m ) ;
#line 314
extern void update_page_count(int level , unsigned long pages ) ;
#line 325
extern pte_t *lookup_address(unsigned long address , unsigned int *level ) ;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_tscp(unsigned int *aux ) 
{ unsigned long low ;
  unsigned long high ;

  {
  {
#line 19
  __asm__  volatile   (".byte 0x0f,0x01,0xf9": "=a" (low), "=d" (high), "=c" (*aux));
  }
#line 21
  return ((unsigned long long )low | ((unsigned long long )high << 32));
}
}
#line 42 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr(unsigned int msr ) 
{ unsigned long long val ;

  {
  {
#line 46
  __asm__  volatile   ("rdmsr": "=A" (val): "c" (msr));
  }
#line 47
  return (val);
}
}
#line 50 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
#line 55
  __asm__  volatile   ("2: rdmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=r" (*err), "=A" (val): "c" (msr), [fault] "i" (-14));
  }
#line 63
  return (val);
}
}
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_msr_amd_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
#line 71
  __asm__  volatile   ("2: rdmsr ; xor %0,%0\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %3,%0 ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": "=r" (*err), "=A" (val): "c" (msr), "D" (2623152186U),
                       "i" (-14));
  }
#line 79
  return (val);
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static void native_write_msr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
#line 85
  __asm__  volatile   ("wrmsr": : "c" (msr), "a" (low), "d" (high): "memory");
  }
#line 86
  return;
}
}
#line 89
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int err ;

  {
  {
#line 93
  __asm__  volatile   ("2: wrmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=a" (err): "c" (msr), "0" (low), "d" (high),
                       [fault] "i" (-14): "memory");
  }
#line 103
  return (err);
}
}
#line 106
extern unsigned long long native_read_tsc(void) ;
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long __native_read_tsc(void) 
{ unsigned long long val ;

  {
  {
#line 112
  __asm__  volatile   ("rdtsc": "=A" (val));
  }
#line 114
  return (val);
}
}
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static unsigned long long native_read_pmc(int counter ) 
{ unsigned long long val ;

  {
  {
#line 121
  __asm__  volatile   ("rdpmc": "=A" (val): "c" (counter));
  }
#line 122
  return (val);
}
}
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static void wrmsr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
#line 144
  native_write_msr(msr, low, high);
  }
#line 145
  return;
}
}
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int wrmsr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int tmp ;

  {
  {
#line 156
  tmp = native_write_msr_safe(msr, low, high);
  }
#line 156
  return (tmp);
}
}
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int rdmsrl_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
#line 173
  *p = native_read_msr_safe(msr, & err);
  }
#line 174
  return (err);
}
}
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/msr.h"
__inline static int rdmsrl_amd_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
#line 180
  *p = native_read_msr_amd_safe(msr, & err);
  }
#line 181
  return (err);
}
}
#line 217
extern int rdmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
#line 218
extern int wrmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
#line 219
extern int rdmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
#line 220
extern int wrmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static void *ERR_PTR(long error ) 
{ 

  {
#line 24
  return ((void *)error);
}
}
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
#line 29
  return ((long )ptr);
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
  {
#line 34
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 0xfffff001UL))), 0L);
  }
#line 34
  return (tmp);
}
}
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/err.h"
__inline static void *ERR_CAST(void const   *ptr ) 
{ 

  {
#line 47
  return ((void *)ptr);
}
}
#line 264 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored )  __attribute__((__section__(".cpuinit.text"))) ;
#line 264 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored ) 
{ 

  {
#line 264
  return;
}
}
#line 265 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_switch_to(struct task_struct *prev , struct task_struct *next ) 
{ 

  {
#line 266
  return;
}
}
#line 267 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_copy_thread(struct task_struct *tsk , struct task_struct *father ) 
{ 

  {
#line 268
  return;
}
}
#line 269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/ds.h"
__inline static void ds_exit_thread(struct task_struct *tsk ) 
{ 

  {
#line 269
  return;
}
}
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/personality.h"
extern int register_exec_domain(struct exec_domain * ) ;
#line 14
extern int unregister_exec_domain(struct exec_domain * ) ;
#line 15
extern int __set_personality(unsigned long  ) ;
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
extern int __bitmap_empty(unsigned long const   *bitmap , int bits ) ;
#line 88
extern int __bitmap_full(unsigned long const   *bitmap , int bits ) ;
#line 89
extern int __bitmap_equal(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                          int bits ) ;
#line 91
extern void __bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                int bits ) ;
#line 93
extern void __bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                 int shift , int bits ) ;
#line 95
extern void __bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                int shift , int bits ) ;
#line 97
extern int __bitmap_and(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
#line 99
extern void __bitmap_or(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
#line 101
extern void __bitmap_xor(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
#line 103
extern int __bitmap_andnot(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
#line 105
extern int __bitmap_intersects(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                               int bits ) ;
#line 107
extern int __bitmap_subset(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
#line 109
extern int __bitmap_weight(unsigned long const   *bitmap , int bits ) ;
#line 111
extern int bitmap_scnprintf(char *buf , unsigned int len , unsigned long const   *src ,
                            int nbits ) ;
#line 113
extern int __bitmap_parse(char const   *buf , unsigned int buflen , int is_user ,
                          unsigned long *dst , int nbits ) ;
#line 115
extern int bitmap_parse_user(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                             int nbits ) ;
#line 117
extern int bitmap_scnlistprintf(char *buf , unsigned int len , unsigned long const   *src ,
                                int nbits ) ;
#line 119
extern int bitmap_parselist(char const   *buf , unsigned long *maskp , int nmaskbits ) ;
#line 121
extern void bitmap_remap(unsigned long *dst , unsigned long const   *src , unsigned long const   *old ,
                         unsigned long const   *new , int bits ) ;
#line 123
extern int bitmap_bitremap(int oldbit , unsigned long const   *old , unsigned long const   *new ,
                           int bits ) ;
#line 125
extern void bitmap_onto(unsigned long *dst , unsigned long const   *orig , unsigned long const   *relmap ,
                        int bits ) ;
#line 127
extern void bitmap_fold(unsigned long *dst , unsigned long const   *orig , int sz ,
                        int bits ) ;
#line 129
extern int bitmap_find_free_region(unsigned long *bitmap , int bits , int order ) ;
#line 130
extern void bitmap_release_region(unsigned long *bitmap , int pos , int order ) ;
#line 131
extern int bitmap_allocate_region(unsigned long *bitmap , int pos , int order ) ;
#line 132
extern void bitmap_copy_le(void *dst , unsigned long const   *src , int nbits ) ;
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ int len ;

  {
  {
#line 148
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
#line 149
  __constant_c_memset((void *)dst, 0UL, (unsigned int )len);
  }
#line 151
  return;
}
}
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_fill(unsigned long *dst , int nbits ) 
{ size_t nlongs ;
  int len ;

  {
  {
#line 155
  nlongs = (size_t )((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long )));
#line 157
  len = (int )((unsigned long )(nlongs - 1U) * sizeof(unsigned long ));
#line 158
  __constant_c_memset((void *)dst, 4294967295UL, (unsigned int )len);
  }
#line 160
  if (nbits % 32) {
    {
#line 160
    *(dst + (nlongs - 1U)) = (1UL << nbits % 32) - 1UL;
    }
  } else {
    {
#line 160
    *(dst + (nlongs - 1U)) = ~ 0UL;
    }
  }
#line 161
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
                                 int nbits ) 
{ int len ;

  {
  {
#line 169
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
#line 170
  __memcpy((void *)dst, (void const   *)src, (unsigned int )len);
  }
#line 172
  return;
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_and(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 179
  tmp___0 = __bitmap_and(dst, src1, src2, nbits);
  }
#line 179
  return (tmp___0);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_or(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
#line 188
  __bitmap_or(dst, src1, src2, nbits);
  }
#line 189
  return;
}
}
#line 191 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_xor(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
#line 197
  __bitmap_xor(dst, src1, src2, nbits);
  }
#line 198
  return;
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_andnot(unsigned long *dst , unsigned long const   *src1 ,
                                  unsigned long const   *src2 , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 205
  tmp___0 = __bitmap_andnot(dst, src1, src2, nbits);
  }
#line 205
  return (tmp___0);
}
}
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                       int nbits ) 
{ unsigned long tmp ;

  {
  {
#line 214
  __bitmap_complement(dst, src, nbits);
  }
#line 215
  return;
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
                                 int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 223
  tmp___1 = __bitmap_equal(src1, src2, nbits);
  }
#line 223
  return (tmp___1);
}
}
#line 226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_intersects(unsigned long const   *src1 , unsigned long const   *src2 ,
                                      int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 232
  tmp___0 = __bitmap_intersects(src1, src2, nbits);
  }
#line 232
  return (tmp___0);
}
}
#line 235 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_subset(unsigned long const   *src1 , unsigned long const   *src2 ,
                                  int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 241
  tmp___1 = __bitmap_subset(src1, src2, nbits);
  }
#line 241
  return (tmp___1);
}
}
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_empty(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 249
  tmp___1 = __bitmap_empty(src, nbits);
  }
#line 249
  return (tmp___1);
}
}
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_full(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 257
  tmp___1 = __bitmap_full(src, nbits);
  }
#line 257
  return (tmp___1);
}
}
#line 260 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 264
  tmp___1 = __bitmap_weight(src, nbits);
  }
#line 264
  return (tmp___1);
}
}
#line 267 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                        int n , int nbits ) 
{ 

  {
  {
#line 273
  __bitmap_shift_right(dst, src, n, nbits);
  }
#line 274
  return;
}
}
#line 276 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static void bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                       int n , int nbits ) 
{ unsigned long tmp ;

  {
  {
#line 282
  __bitmap_shift_left(dst, src, n, nbits);
  }
#line 283
  return;
}
}
#line 285 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bitmap.h"
__inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
                                 int nmaskbits ) 
{ int tmp ;

  {
  {
#line 288
  tmp = __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
  }
#line 288
  return (tmp);
}
}
#line 145 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
extern cpumask_t _unused_cpumask_arg_ ;
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpu_set(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
#line 151
  set_bit((unsigned int )cpu, (unsigned long volatile   *)(dstp->bits));
  }
#line 152
  return;
}
}
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpu_clear(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
#line 157
  clear_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  }
#line 158
  return;
}
}
#line 161 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_setall(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
#line 163
  bitmap_fill(dstp->bits, nbits);
  }
#line 164
  return;
}
}
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_clear(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
#line 169
  bitmap_zero(dstp->bits, nbits);
  }
#line 170
  return;
}
}
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpu_test_and_set(int cpu , cpumask_t *addr ) 
{ int tmp ;

  {
  {
#line 178
  tmp = test_and_set_bit(cpu, (unsigned long volatile   *)(addr->bits));
  }
#line 178
  return (tmp);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_and(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ int tmp ;

  {
  {
#line 185
  tmp = bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                   nbits);
  }
#line 185
  return (tmp);
}
}
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_or(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ 

  {
  {
#line 192
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
#line 193
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_xor(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
#line 199
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
#line 200
  return;
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_andnot(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
#line 207
  tmp = bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
#line 207
  return (tmp);
}
}
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_complement(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int nbits ) 
{ 

  {
  {
#line 214
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
#line 215
  return;
}
}
#line 218 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_equal(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                 int nbits ) 
{ int tmp ;

  {
  {
#line 221
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
#line 221
  return (tmp);
}
}
#line 225 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_intersects(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                      int nbits ) 
{ int tmp ;

  {
  {
#line 228
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
#line 228
  return (tmp);
}
}
#line 232 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_subset(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
#line 235
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
#line 235
  return (tmp);
}
}
#line 239 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_empty(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 241
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
#line 241
  return (tmp);
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_full(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 247
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
#line 247
  return (tmp);
}
}
#line 251 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpus_weight(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 253
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
#line 253
  return (tmp);
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_shift_right(cpumask_t *dstp , cpumask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
#line 261
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 262
  return;
}
}
#line 266 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_shift_left(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int n , int nbits ) 
{ 

  {
  {
#line 269
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 270
  return;
}
}
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __check_is_bitmap(unsigned long const   *bitmap ) 
{ 

  {
#line 289
  return (1);
}
}
#line 299
extern unsigned long const   cpu_bit_bitmap[33][((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static struct cpumask  const  *get_cpu_mask(unsigned int cpu ) 
{ unsigned long const   *p ;
  int tmp ;

  {
  {
#line 304
  p = cpu_bit_bitmap[1U + cpu % 32U];
#line 305
  p -= cpu / 32U;
  }
#line 306
  return ((struct cpumask  const  *)((struct cpumask *)p));
}
}
#line 366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int __cpu_remap(int oldbit , cpumask_t const   *oldp , cpumask_t const   *newp ,
                                int nbits ) 
{ int tmp ;

  {
  {
#line 369
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
#line 369
  return (tmp);
}
}
#line 374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_remap(cpumask_t *dstp , cpumask_t const   *srcp , cpumask_t const   *oldp ,
                                  cpumask_t const   *newp , int nbits ) 
{ 

  {
  {
#line 377
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
#line 378
  return;
}
}
#line 382 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_onto(cpumask_t *dstp , cpumask_t const   *origp , cpumask_t const   *relmapp ,
                                 int nbits ) 
{ 

  {
  {
#line 385
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
#line 386
  return;
}
}
#line 390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void __cpus_fold(cpumask_t *dstp , cpumask_t const   *origp , int sz ,
                                 int nbits ) 
{ 

  {
  {
#line 393
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
#line 394
  return;
}
}
#line 409
extern int nr_cpu_ids ;
#line 411
extern int __first_cpu(cpumask_t const   *srcp ) ;
#line 412
extern int __next_cpu(int n , cpumask_t const   *srcp ) ;
#line 413
extern int __any_online_cpu(cpumask_t const   *mask ) ;
#line 485
extern struct cpumask  const  * const  cpu_possible_mask ;
#line 486
extern struct cpumask  const  * const  cpu_online_mask ;
#line 487
extern struct cpumask  const  * const  cpu_present_mask ;
#line 488
extern struct cpumask  const  * const  cpu_active_mask ;
#line 544 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 

  {
#line 549
  return (cpu);
}
}
#line 595 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_first(struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  {
#line 597
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 8UL);
  }
#line 597
  return ((unsigned int )tmp);
}
}
#line 607 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
#line 610
  if (n != -1) {
    {
#line 611
    cpumask_check((unsigned int )n);
    }
  }
  {
#line 612
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
#line 612
  return ((unsigned int )tmp);
}
}
#line 622 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_next_zero(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
#line 625
  if (n != -1) {
    {
#line 626
    cpumask_check((unsigned int )n);
    }
  }
  {
#line 627
  tmp = find_next_zero_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
#line 627
  return ((unsigned int )tmp);
}
}
#line 630
extern int cpumask_next_and(int n , struct cpumask  const  * , struct cpumask  const  * ) ;
#line 631
extern int cpumask_any_but(struct cpumask  const  *mask , unsigned int cpu ) ;
#line 680 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
#line 682
  tmp = cpumask_check(cpu);
#line 682
  set_bit(tmp, (unsigned long volatile   *)(dstp->bits));
  }
#line 683
  return;
}
}
#line 690 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_clear_cpu(int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
#line 692
  tmp = cpumask_check((unsigned int )cpu);
#line 692
  clear_bit((int )tmp, (unsigned long volatile   *)(dstp->bits));
  }
#line 693
  return;
}
}
#line 712 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_test_and_set_cpu(int cpu , struct cpumask *cpumask ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 714
  tmp = cpumask_check((unsigned int )cpu);
#line 714
  tmp___0 = test_and_set_bit((int )tmp, (unsigned long volatile   *)(cpumask->bits));
  }
#line 714
  return (tmp___0);
}
}
#line 721 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_setall(struct cpumask *dstp ) 
{ 

  {
  {
#line 723
  bitmap_fill(dstp->bits, 8);
  }
#line 724
  return;
}
}
#line 730 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_clear(struct cpumask *dstp ) 
{ 

  {
  {
#line 732
  bitmap_zero(dstp->bits, 8);
  }
#line 733
  return;
}
}
#line 741 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_and(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 745
  tmp = bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                   8);
  }
#line 745
  return (tmp);
}
}
#line 755 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_or(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ 

  {
  {
#line 758
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            8);
  }
#line 760
  return;
}
}
#line 768 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_xor(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p ) 
{ 

  {
  {
#line 772
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             8);
  }
#line 774
  return;
}
}
#line 782 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_andnot(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                   struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 786
  tmp = bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      8);
  }
#line 786
  return (tmp);
}
}
#line 795 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_complement(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
#line 798
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
#line 800
  return;
}
}
#line 807 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 810
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     8);
  }
#line 810
  return ((_Bool )tmp);
}
}
#line 819 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_intersects(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 822
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          8);
  }
#line 822
  return ((_Bool )tmp);
}
}
#line 831 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_subset(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
#line 834
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      8);
  }
#line 834
  return (tmp);
}
}
#line 842 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_empty(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 844
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), 8);
  }
#line 844
  return ((_Bool )tmp);
}
}
#line 851 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool cpumask_full(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 853
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), 8);
  }
#line 853
  return ((_Bool )tmp);
}
}
#line 860 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 862
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), 8);
  }
#line 862
  return ((unsigned int )tmp);
}
}
#line 871 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_shift_right(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                         int n ) 
{ 

  {
  {
#line 874
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
#line 876
  return;
}
}
#line 884 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_shift_left(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                        int n ) 
{ 

  {
  {
#line 887
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
#line 889
  return;
}
}
#line 896 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
#line 899
  bitmap_copy(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
#line 900
  return;
}
}
#line 943 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 946
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         8);
  }
#line 946
  return (tmp);
}
}
#line 957 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpumask_parse_user(char const   *buf , int len , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
#line 960
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, 8);
  }
#line 960
  return (tmp);
}
}
#line 972 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpulist_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
#line 975
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             8);
  }
#line 975
  return (tmp);
}
}
#line 987 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static int cpulist_parse(char const   *buf , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
#line 989
  tmp = bitmap_parselist(buf, dstp->bits, 8);
  }
#line 989
  return (tmp);
}
}
#line 997 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static size_t cpumask_size(void) 
{ 

  {
#line 1001
  return ((unsigned int )((((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long )));
}
}
#line 1034 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool alloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
#line 1036
  return ((_Bool)1);
}
}
#line 1039 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool alloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
#line 1042
  return ((_Bool)1);
}
}
#line 1045 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool zalloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
  {
#line 1047
  cpumask_clear(*mask);
  }
#line 1048
  return ((_Bool)1);
}
}
#line 1051 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static bool zalloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
  {
#line 1054
  cpumask_clear(*mask);
  }
#line 1055
  return ((_Bool)1);
}
}
#line 1058 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void alloc_bootmem_cpumask_var(cpumask_var_t *mask ) 
{ 

  {
#line 1060
  return;
}
}
#line 1062 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void free_cpumask_var(struct cpumask *mask ) 
{ 

  {
#line 1064
  return;
}
}
#line 1066 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cpumask.h"
__inline static void free_bootmem_cpumask_var(struct cpumask *mask ) 
{ 

  {
#line 1068
  return;
}
}
#line 1073
extern unsigned long const   cpu_all_bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 1084
extern void set_cpu_possible(unsigned int cpu , bool possible ) ;
#line 1085
extern void set_cpu_present(unsigned int cpu , bool present ) ;
#line 1086
extern void set_cpu_online(unsigned int cpu , bool online ) ;
#line 1087
extern void set_cpu_active(unsigned int cpu , bool active ) ;
#line 1088
extern void init_cpu_present(struct cpumask  const  *src ) ;
#line 1089
extern void init_cpu_possible(struct cpumask  const  *src ) ;
#line 1090
extern void init_cpu_online(struct cpumask  const  *src ) ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void *current_text_addr(void) 
{ void *pc ;

  {
  {
#line 40
  __asm__  volatile   ("mov $1f, %0; 1:": "=r" (pc));
  }
#line 42
  return (pc);
}
}
#line 134
extern struct cpuinfo_x86 boot_cpu_data ;
#line 135
extern struct cpuinfo_x86 new_cpu_data ;
#line 137
extern struct tss_struct doublefault_tss ;
#line 138
extern __u32 cleared_cpu_caps[9] ;
#line 141
extern struct cpuinfo_x86 per_cpu__cpu_info  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
#line 149
extern struct seq_operations  const  cpuinfo_op ;
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static int hlt_works(int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 154
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_info));
  }
#line 154
  return ((int )((struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[cpu]))->hlt_works_ok);
}
}
#line 162
extern void cpu_detect(struct cpuinfo_x86 *c ) ;
#line 164
extern struct pt_regs *idle_regs(struct pt_regs * ) ;
#line 166
extern void early_cpu_init(void) ;
#line 167
extern void identify_boot_cpu(void) ;
#line 168
extern void identify_secondary_cpu(struct cpuinfo_x86 * ) ;
#line 169
extern void print_cpu_info(struct cpuinfo_x86 * ) ;
#line 170
extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c ) ;
#line 171
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c ) ;
#line 172
extern unsigned short num_cache_leaves ;
#line 174
extern void detect_extended_topology(struct cpuinfo_x86 *c ) ;
#line 175
extern void detect_ht(struct cpuinfo_x86 *c ) ;
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                                  unsigned int *edx ) 
{ 

  {
  {
#line 181
  __asm__  ("cpuid": "=a" (*eax), "=b" (*ebx), "=c" (*ecx), "=d" (*edx): "0" (*eax),
            "2" (*ecx));
  }
#line 187
  return;
}
}
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void load_cr3(pgd_t *pgdir ) 
{ 

  {
  {
#line 191
  native_write_cr3((unsigned long )pgdir - 3221225472UL);
  }
#line 192
  return;
}
}
#line 273
extern struct tss_struct per_cpu__init_tss  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
#line 419
extern unsigned int xstate_size ;
#line 420
extern void free_thread_xstate(struct task_struct * ) ;
#line 421
extern struct kmem_cache *task_xstate_cachep ;
#line 483 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned long native_get_debugreg(int regno ) 
{ unsigned long val ;

  {
  {
#line 485
  val = 0UL;
  }
#line 488
  if (regno == 0) {
    goto switch_11_0;
  } else {
#line 491
    if (regno == 1) {
      goto switch_11_1;
    } else {
#line 494
      if (regno == 2) {
        goto switch_11_2;
      } else {
#line 497
        if (regno == 3) {
          goto switch_11_3;
        } else {
#line 500
          if (regno == 6) {
            goto switch_11_6;
          } else {
#line 503
            if (regno == 7) {
              goto switch_11_7;
            } else {
              {
              goto switch_11_default;
#line 487
              if (0) {
                switch_11_0: /* CIL Label */ 
                {
#line 489
                __asm__  ("mov %%db0, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_1: /* CIL Label */ 
                {
#line 492
                __asm__  ("mov %%db1, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_2: /* CIL Label */ 
                {
#line 495
                __asm__  ("mov %%db2, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_3: /* CIL Label */ 
                {
#line 498
                __asm__  ("mov %%db3, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_6: /* CIL Label */ 
                {
#line 501
                __asm__  ("mov %%db6, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_7: /* CIL Label */ 
                {
#line 504
                __asm__  ("mov %%db7, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_default: /* CIL Label */ 
                {

                }
                {
#line 507
                while (1) {
                  while_12_continue: /* CIL Label */ ;
                  {
#line 507
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (507), "i" (sizeof(struct bug_entry )));
                  }
                  {
#line 507
                  while (1) {
                    while_13_continue: /* CIL Label */ ;
                  }
                  while_13_break: /* CIL Label */ ;
                  }
                  goto while_12_break;
                }
                while_12_break: /* CIL Label */ ;
                }
              } else {
                switch_11_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
#line 509
  return (val);
}
}
#line 512 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_set_debugreg(int regno , unsigned long value ) 
{ 

  {
#line 515
  if (regno == 0) {
    goto switch_14_0;
  } else {
#line 518
    if (regno == 1) {
      goto switch_14_1;
    } else {
#line 521
      if (regno == 2) {
        goto switch_14_2;
      } else {
#line 524
        if (regno == 3) {
          goto switch_14_3;
        } else {
#line 527
          if (regno == 6) {
            goto switch_14_6;
          } else {
#line 530
            if (regno == 7) {
              goto switch_14_7;
            } else {
              {
              goto switch_14_default;
#line 514
              if (0) {
                switch_14_0: /* CIL Label */ 
                {
#line 516
                __asm__  ("mov %0, %%db0": : "r" (value));
                }
                goto switch_14_break;
                switch_14_1: /* CIL Label */ 
                {
#line 519
                __asm__  ("mov %0, %%db1": : "r" (value));
                }
                goto switch_14_break;
                switch_14_2: /* CIL Label */ 
                {
#line 522
                __asm__  ("mov %0, %%db2": : "r" (value));
                }
                goto switch_14_break;
                switch_14_3: /* CIL Label */ 
                {
#line 525
                __asm__  ("mov %0, %%db3": : "r" (value));
                }
                goto switch_14_break;
                switch_14_6: /* CIL Label */ 
                {
#line 528
                __asm__  ("mov %0, %%db6": : "r" (value));
                }
                goto switch_14_break;
                switch_14_7: /* CIL Label */ 
                {
#line 531
                __asm__  ("mov %0, %%db7": : "r" (value));
                }
                goto switch_14_break;
                switch_14_default: /* CIL Label */ 
                {

                }
                {
#line 534
                while (1) {
                  while_15_continue: /* CIL Label */ ;
                  {
#line 534
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (534), "i" (sizeof(struct bug_entry )));
                  }
                  {
#line 534
                  while (1) {
                    while_16_continue: /* CIL Label */ ;
                  }
                  while_16_break: /* CIL Label */ ;
                  }
                  goto while_15_break;
                }
                while_15_break: /* CIL Label */ ;
                }
              } else {
                switch_14_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
#line 536
  return;
}
}
#line 541 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_set_iopl_mask(unsigned int mask ) 
{ unsigned int reg ;

  {
  {
#line 546
  __asm__  volatile   ("pushfl;"
                       "popl %0;"
                       "andl %1, %0;"
                       "orl %2, %0;"
                       "pushl %0;"
                       "popfl": "=&r" (reg): "i" (~ 12288), "r" (mask));
  }
#line 555
  return;
}
}
#line 557 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ long tmp ;

  {
  {
#line 560
  tss->x86_tss.sp0 = thread->sp0;
#line 563
  tmp = __builtin_expect((long )(! (! ((unsigned long )tss->x86_tss.ss1 != thread->sysenter_cs))),
                         0L);
  }
#line 563
  if (tmp) {
    {
#line 564
    tss->x86_tss.ss1 = (unsigned short )thread->sysenter_cs;
#line 565
    wrmsr(372U, (unsigned int )thread->sysenter_cs, 0U);
    }
  }
#line 568
  return;
}
}
#line 570 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void native_swapgs(void) 
{ 

  {
#line 575
  return;
}
}
#line 591 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ 

  {
  {
#line 594
  native_load_sp0(tss, thread);
  }
#line 595
  return;
}
}
#line 606
extern unsigned long mmu_cr4_features ;
#line 608 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void set_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
#line 612
  mmu_cr4_features |= mask;
#line 613
  tmp = native_read_cr4();
#line 613
  cr4 = (unsigned int )tmp;
#line 614
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
#line 615
  native_write_cr4((unsigned long )cr4);
  }
#line 616
  return;
}
}
#line 618 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void clear_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
#line 622
  mmu_cr4_features &= ~ mask;
#line 623
  tmp = native_read_cr4();
#line 623
  cr4 = (unsigned int )tmp;
#line 624
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
#line 625
  native_write_cr4((unsigned long )cr4);
  }
#line 626
  return;
}
}
#line 636
extern int kernel_thread(int (*fn)(void * ) , void *arg , unsigned long flags ) ;
#line 639
extern void release_thread(struct task_struct * ) ;
#line 642
extern void prepare_to_copy(struct task_struct *tsk ) ;
#line 644
extern unsigned long get_wchan(struct task_struct *p ) ;
#line 651 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
#line 655
  *eax = op;
#line 656
  *ecx = 0U;
#line 657
  native_cpuid(eax, ebx, ecx, edx);
  }
#line 658
  return;
}
}
#line 661 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpuid_count(unsigned int op , int count , unsigned int *eax ,
                                 unsigned int *ebx , unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
#line 665
  *eax = op;
#line 666
  *ecx = (unsigned int )count;
#line 667
  native_cpuid(eax, ebx, ecx, edx);
  }
#line 668
  return;
}
}
#line 673 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_eax(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 677
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 679
  return (eax);
}
}
#line 682 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_ebx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 686
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 688
  return (ebx);
}
}
#line 691 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_ecx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 695
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 697
  return (ecx);
}
}
#line 700 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned int cpuid_edx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
#line 704
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
#line 706
  return (edx);
}
}
#line 710 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 

  {
  {
#line 712
  __asm__  volatile   ("rep; nop": : : "memory");
  }
#line 713
  return;
}
}
#line 715 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 

  {
  {
#line 717
  rep_nop();
  }
#line 718
  return;
}
}
#line 721 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void sync_core(void) 
{ int tmp ;

  {
  {
#line 725
  __asm__  volatile   ("cpuid": "=a" (tmp): "0" (1): "ebx", "ecx", "edx", "memory");
  }
#line 727
  return;
}
}
#line 729 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void __monitor(void const   *eax , unsigned long ecx , unsigned long edx ) 
{ 

  {
  {
#line 733
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc8;": : "a" (eax), "c" (ecx), "d" (edx));
  }
#line 735
  return;
}
}
#line 737 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void __mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
#line 740
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
#line 742
  return;
}
}
#line 744 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void __sti_mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
#line 746
  while (1) {
    while_17_continue: /* CIL Label */ ;
    goto while_17_break;
  }
  while_17_break: /* CIL Label */ ;
  }
  {
#line 748
  __asm__  volatile   ("sti; .byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
#line 750
  return;
}
}
#line 752
extern void mwait_idle_with_hints(unsigned long eax , unsigned long ecx ) ;
#line 754
extern void select_idle_routine(struct cpuinfo_x86  const  *c ) ;
#line 755
extern void init_c1e_mask(void) ;
#line 757
extern unsigned long boot_option_idle_override ;
#line 758
extern unsigned long idle_halt ;
#line 759
extern unsigned long idle_nomwait ;
#line 773 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void wbinvd_halt(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 775
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
#line 777
  if (19 >> 5 == 0) {
#line 777
    if ((1UL << 19) & (unsigned long )(1 | (1 << 15))) {
      {
#line 777
      tmp___1 = 1;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 777
    if (19 >> 5 == 1) {
      goto _L___4;
    } else {
      _L___4: /* CIL Label */ 
#line 777
      if (19 >> 5 == 2) {
        goto _L___3;
      } else {
        _L___3: /* CIL Label */ 
#line 777
        if (19 >> 5 == 3) {
          goto _L___2;
        } else {
          _L___2: /* CIL Label */ 
#line 777
          if (19 >> 5 == 4) {
            goto _L___1;
          } else {
            _L___1: /* CIL Label */ 
#line 777
            if (19 >> 5 == 5) {
              goto _L___0;
            } else {
              _L___0: /* CIL Label */ 
#line 777
              if (19 >> 5 == 6) {
                goto _L;
              } else {
                _L: /* CIL Label */ 
#line 777
                if (19 >> 5 == 7) {
                  {
#line 777
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 777
                  tmp___1 = tmp;
                  }
                } else {
                  {
#line 777
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 777
                  tmp___1 = tmp;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 777
  if (tmp___1) {
    {
#line 778
    __asm__  volatile   ("cli; wbinvd; 1: hlt; jmp 1b": : : "memory");
    }
  } else {
    {
#line 780
    while (1) {
      while_18_continue: /* CIL Label */ ;
      {
#line 781
      halt();
      }
    }
    while_18_break: /* CIL Label */ ;
    }
  }
#line 782
  return;
}
}
#line 784
extern void enable_sep_cpu(void) ;
#line 785
extern int sysenter_setup(void) ;
#line 788
extern struct desc_ptr early_gdt_descr ;
#line 790
extern void cpu_set_gdt(int  ) ;
#line 791
extern void switch_to_new_gdt(int  ) ;
#line 792
extern void load_percpu_segment(int  ) ;
#line 793
extern void cpu_init(void) ;
#line 795 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static unsigned long get_debugctlmsr(void) 
{ unsigned long debugctlmsr ;
  unsigned long long tmp ;

  {
  {
#line 797
  debugctlmsr = 0UL;
#line 803
  tmp = native_read_msr(473U);
#line 803
  debugctlmsr = (unsigned long )tmp;
  }
#line 805
  return (debugctlmsr);
}
}
#line 808 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void update_debugctlmsr(unsigned long debugctlmsr ) 
{ 

  {
  {
#line 814
  native_write_msr(473U, (unsigned int )((unsigned long long )debugctlmsr), (unsigned int )((unsigned long long )debugctlmsr >> 32));
  }
#line 815
  return;
}
}
#line 821
extern unsigned int machine_id ;
#line 822
extern unsigned int machine_submodel_id ;
#line 823
extern unsigned int BIOS_revision ;
#line 826
extern int bootloader_type ;
#line 828
extern char ignore_fpu_irq ;
#line 847 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
#line 849
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
#line 853
  return;
}
}
#line 860 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const   *x ) 
{ 

  {
  {
#line 862
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchw (%1)"
                       "\n664:\n"
                       ".previous": : "i" (63), "r" (x));
  }
#line 866
  return;
}
}
#line 868 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"
__inline static void spin_lock_prefetch(void const   *x ) 
{ 

  {
  {
#line 870
  prefetchw(x);
  }
#line 871
  return;
}
}
#line 906
extern unsigned long thread_saved_pc(struct task_struct *tsk ) ;
#line 972
extern void start_thread(struct pt_regs *regs , unsigned long new_ip , unsigned long new_sp ) ;
#line 987
extern int get_tsc_mode(unsigned long adr ) ;
#line 988
extern int set_tsc_mode(unsigned int val ) ;
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prefetch.h"
__inline static void prefetch_range(void *addr , size_t len ) 
{ char *cp ;
  char *end ;

  {
  {
#line 57
  end = (char *)(addr + len);
#line 59
  cp = (char *)addr;
  }
  {
#line 59
  while (1) {
    while_19_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )cp < (unsigned long )end)) {
      goto while_19_break;
    }
    {
#line 60
    prefetch((void const   *)cp);
#line 59
    cp += 4 * (1 << 5);
    }
  }
  while_19_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  {
#line 30
  list->next = list;
#line 31
  list->prev = list;
  }
#line 32
  return;
}
}
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
#line 45
  next->prev = new;
#line 46
  new->next = next;
#line 47
  new->prev = prev;
#line 48
  prev->next = new;
  }
#line 49
  return;
}
}
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 66
  __list_add(new, head, head->next);
  }
#line 67
  return;
}
}
#line 78 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 80
  __list_add(new, head->prev, head);
  }
#line 81
  return;
}
}
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
#line 92
  next->prev = prev;
#line 93
  prev->next = next;
  }
#line 94
  return;
}
}
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
#line 105
  __list_del(entry->prev, entry->next);
#line 106
  entry->next = (struct list_head *)((void *)1048832);
#line 107
  entry->prev = (struct list_head *)((void *)2097664);
  }
#line 108
  return;
}
}
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_replace(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
#line 123
  new->next = old->next;
#line 124
  (new->next)->prev = new;
#line 125
  new->prev = old->prev;
#line 126
  (new->prev)->next = new;
  }
#line 127
  return;
}
}
#line 129 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_replace_init(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
#line 132
  list_replace(old, new);
#line 133
  INIT_LIST_HEAD(old);
  }
#line 134
  return;
}
}
#line 140 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
  {
#line 142
  __list_del(entry->prev, entry->next);
#line 143
  INIT_LIST_HEAD(entry);
  }
#line 144
  return;
}
}
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
#line 153
  __list_del(list->prev, list->next);
#line 154
  list_add(list, head);
  }
#line 155
  return;
}
}
#line 162 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
#line 165
  __list_del(list->prev, list->next);
#line 166
  list_add_tail(list, head);
  }
#line 167
  return;
}
}
#line 174 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_is_last(struct list_head  const  *list , struct list_head  const  *head ) 
{ 

  {
#line 177
  return ((unsigned long )list->next == (unsigned long )head);
}
}
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
#line 186
  return ((unsigned long )head->next == (unsigned long )head);
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_empty_careful(struct list_head  const  *head ) 
{ struct list_head *next ;
  int tmp ;

  {
  {
#line 204
  next = (struct list_head *)head->next;
  }
#line 205
  if ((unsigned long )next == (unsigned long )head) {
#line 205
    if ((unsigned long )next == (unsigned long )head->prev) {
      {
#line 205
      tmp = 1;
      }
    } else {
      {
#line 205
      tmp = 0;
      }
    }
  } else {
    {
#line 205
    tmp = 0;
    }
  }
#line 205
  return (tmp);
}
}
#line 212 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int list_is_singular(struct list_head  const  *head ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 214
  tmp = list_empty(head);
  }
#line 214
  if (tmp) {
    {
#line 214
    tmp___0 = 0;
    }
  } else {
#line 214
    if ((unsigned long )head->next == (unsigned long )head->prev) {
      {
#line 214
      tmp___0 = 1;
      }
    } else {
      {
#line 214
      tmp___0 = 0;
      }
    }
  }
#line 214
  return (tmp___0);
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_cut_position(struct list_head *list , struct list_head *head ,
                                         struct list_head *entry ) 
{ struct list_head *new_first ;

  {
  {
#line 220
  new_first = entry->next;
#line 221
  list->next = head->next;
#line 222
  (list->next)->prev = list;
#line 223
  list->prev = entry;
#line 224
  entry->next = list;
#line 225
  head->next = new_first;
#line 226
  new_first->prev = head;
  }
#line 227
  return;
}
}
#line 243 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_cut_position(struct list_head *list , struct list_head *head ,
                                       struct list_head *entry ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 246
  tmp = list_empty((struct list_head  const  *)head);
  }
#line 246
  if (tmp) {
#line 247
    return;
  }
  {
#line 248
  tmp___0 = list_is_singular((struct list_head  const  *)head);
  }
#line 248
  if (tmp___0) {
#line 248
    if ((unsigned long )head->next != (unsigned long )entry) {
#line 248
      if ((unsigned long )head != (unsigned long )entry) {
#line 250
        return;
      }
    }
  }
#line 251
  if ((unsigned long )entry == (unsigned long )head) {
    {
#line 252
    INIT_LIST_HEAD(list);
    }
  } else {
    {
#line 254
    __list_cut_position(list, head, entry);
    }
  }
#line 255
  return;
}
}
#line 257 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;

  {
  {
#line 261
  first = (struct list_head *)list->next;
#line 262
  last = (struct list_head *)list->prev;
#line 264
  first->prev = prev;
#line 265
  prev->next = first;
#line 267
  last->next = next;
#line 268
  next->prev = last;
  }
#line 269
  return;
}
}
#line 276 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 279
  tmp = list_empty(list);
  }
#line 279
  if (! tmp) {
    {
#line 280
    __list_splice(list, head, head->next);
    }
  }
#line 281
  return;
}
}
#line 288 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice_tail(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 291
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 291
  if (! tmp) {
    {
#line 292
    __list_splice((struct list_head  const  *)list, head->prev, head);
    }
  }
#line 293
  return;
}
}
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 305
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 305
  if (! tmp) {
    {
#line 306
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 307
    INIT_LIST_HEAD(list);
    }
  }
#line 309
  return;
}
}
#line 319 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
#line 322
  tmp = list_empty((struct list_head  const  *)list);
  }
#line 322
  if (! tmp) {
    {
#line 323
    __list_splice((struct list_head  const  *)list, head->prev, head);
#line 324
    INIT_LIST_HEAD(list);
    }
  }
#line 326
  return;
}
}
#line 551 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
{ 

  {
  {
#line 553
  h->next = (struct hlist_node *)((void *)0);
#line 554
  h->pprev = (struct hlist_node **)((void *)0);
  }
#line 555
  return;
}
}
#line 557 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int hlist_unhashed(struct hlist_node  const  *h ) 
{ 

  {
#line 559
  return (! h->pprev);
}
}
#line 562 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static int hlist_empty(struct hlist_head  const  *h ) 
{ 

  {
#line 564
  return (! h->first);
}
}
#line 567 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n ) 
{ struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
  {
#line 569
  next = n->next;
#line 570
  pprev = n->pprev;
#line 571
  *pprev = next;
  }
#line 572
  if (next) {
    {
#line 573
    next->pprev = pprev;
    }
  }
#line 574
  return;
}
}
#line 576 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n ) 
{ 

  {
  {
#line 578
  __hlist_del(n);
#line 579
  n->next = (struct hlist_node *)((void *)1048832);
#line 580
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
#line 581
  return;
}
}
#line 583 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_del_init(struct hlist_node *n ) 
{ int tmp ;

  {
  {
#line 585
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
#line 585
  if (! tmp) {
    {
#line 586
    __hlist_del(n);
#line 587
    INIT_HLIST_NODE(n);
    }
  }
#line 589
  return;
}
}
#line 591 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
#line 593
  first = h->first;
#line 594
  n->next = first;
  }
#line 595
  if (first) {
    {
#line 596
    first->pprev = & n->next;
    }
  }
  {
#line 597
  h->first = n;
#line 598
  n->pprev = & h->first;
  }
#line 599
  return;
}
}
#line 602 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_add_before(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
#line 605
  n->pprev = next->pprev;
#line 606
  n->next = next;
#line 607
  next->pprev = & n->next;
#line 608
  *(n->pprev) = n;
  }
#line 609
  return;
}
}
#line 611 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_add_after(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
#line 614
  next->next = n->next;
#line 615
  n->next = next;
#line 616
  next->pprev = & n->next;
  }
#line 618
  if (next->next) {
    {
#line 619
    (next->next)->pprev = & next->next;
    }
  }
#line 620
  return;
}
}
#line 626 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/list.h"
__inline static void hlist_move_list(struct hlist_head *old , struct hlist_head *new ) 
{ 

  {
  {
#line 629
  new->first = old->first;
  }
#line 630
  if (new->first) {
    {
#line 631
    (new->first)->pprev = & new->first;
    }
  }
  {
#line 632
  old->first = (struct hlist_node *)((void *)0);
  }
#line 633
  return;
}
}
#line 52 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
extern long do_no_restart_syscall(struct restart_block *parm ) ;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 

  {
  {
#line 42
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (v->counter): "ir" (i));
  }
#line 45
  return;
}
}
#line 54 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 

  {
  {
#line 56
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %1,%0": "+m" (v->counter): "ir" (i));
  }
#line 59
  return;
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 74
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %2,%0; sete %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
#line 77
  return ((int )c);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 

  {
  {
#line 88
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (v->counter));
  }
#line 90
  return;
}
}
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 

  {
  {
#line 100
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0": "+m" (v->counter));
  }
#line 102
  return;
}
}
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 116
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
#line 119
  return ((int )c != 0);
}
}
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_inc_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 134
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
#line 137
  return ((int )c != 0);
}
}
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_add_negative(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
#line 153
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %2,%0; sets %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
#line 156
  return ((int )c);
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ int __i ;

  {
  {
#line 175
  __i = i;
#line 176
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddl %0, %1": "+r" (i), "+m" (v->counter): : "memory");
  }
#line 179
  return (i + __i);
}
}
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ int tmp ;

  {
  {
#line 200
  tmp = atomic_add_return(- i, v);
  }
#line 200
  return (tmp);
}
}
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/atomic_32.h"
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ int c ;
  int old ;
  long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 218
  c = (int )v->counter;
  }
  {
#line 219
  while (1) {
    while_20_continue: /* CIL Label */ ;
    {
#line 220
    tmp = __builtin_expect((long )(! (! (c == u))), 0L);
    }
#line 220
    if (tmp) {
      goto while_20_break;
    }
    {
#line 222
    tmp___0 = __cmpxchg((void volatile   *)(& v->counter), (unsigned long )c, (unsigned long )(c + a),
                        (int )sizeof(v->counter));
#line 222
    old = (int )((int volatile   )tmp___0);
#line 223
    tmp___1 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
#line 223
    if (tmp___1) {
      goto while_20_break;
    }
    {
#line 225
    c = old;
    }
  }
  while_20_break: /* CIL Label */ ;
  }
#line 227
  return (c != u);
}
}
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_read(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 146
  v = l;
  }
#line 148
  return ((long )v->counter);
}
}
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_set(atomic_long_t *l , long i ) 
{ atomic_t *v ;

  {
  {
#line 153
  v = l;
#line 155
  v->counter = (int volatile   )i;
  }
#line 156
  return;
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_inc(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 160
  v = l;
#line 162
  atomic_inc(v);
  }
#line 163
  return;
}
}
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_dec(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 167
  v = l;
#line 169
  atomic_dec(v);
  }
#line 170
  return;
}
}
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_add(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 174
  v = l;
#line 176
  atomic_add((int )i, v);
  }
#line 177
  return;
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static void atomic_long_sub(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
#line 181
  v = l;
#line 183
  atomic_sub((int )i, v);
  }
#line 184
  return;
}
}
#line 186 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_sub_and_test(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 188
  v = l;
#line 190
  tmp = atomic_sub_and_test((int )i, v);
  }
#line 190
  return (tmp);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_dec_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 195
  v = l;
#line 197
  tmp = atomic_dec_and_test(v);
  }
#line 197
  return (tmp);
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_inc_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 202
  v = l;
#line 204
  tmp = atomic_inc_and_test(v);
  }
#line 204
  return (tmp);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static int atomic_long_add_negative(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 209
  v = l;
#line 211
  tmp = atomic_add_negative((int )i, v);
  }
#line 211
  return (tmp);
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_add_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 216
  v = l;
#line 218
  tmp = atomic_add_return((int )i, v);
  }
#line 218
  return ((long )tmp);
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_sub_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 223
  v = l;
#line 225
  tmp = atomic_sub_return((int )i, v);
  }
#line 225
  return ((long )tmp);
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_inc_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 230
  v = l;
#line 232
  tmp = atomic_add_return(1, v);
  }
#line 232
  return ((long )tmp);
}
}
#line 235 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_dec_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 237
  v = l;
#line 239
  tmp = atomic_sub_return(1, v);
  }
#line 239
  return ((long )tmp);
}
}
#line 242 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/atomic.h"
__inline static long atomic_long_add_unless(atomic_long_t *l , long a , long u ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
#line 244
  v = l;
#line 246
  tmp = atomic_add_unless(v, (int )a, (int )u);
  }
#line 246
  return ((long )tmp);
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
register unsigned long current_stack_pointer  __asm__("esp")   ;
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
__inline static struct thread_info *current_thread_info(void) 
{ 

  {
#line 182
  return ((struct thread_info *)(current_stack_pointer & ~ (((1UL << 12) << 1) - 1UL)));
}
}
#line 249 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/thread_info.h"
__inline static void set_restore_sigmask(void) 
{ struct thread_info *ti ;
  struct thread_info *tmp ;

  {
  {
#line 251
  tmp = current_thread_info();
#line 251
  ti = tmp;
#line 252
  ti->status |= 8U;
#line 253
  set_bit(2U, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 254
  return;
}
}
#line 258
extern void arch_task_cache_init(void) ;
#line 259
extern void free_thread_info(struct thread_info *ti ) ;
#line 260
extern int arch_dup_task_struct(struct task_struct *dst , struct task_struct *src ) ;
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
#line 66
  set_bit((unsigned int )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 67
  return;
}
}
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static void clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
#line 71
  clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 72
  return;
}
}
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static int test_and_set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
#line 76
  tmp = test_and_set_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 76
  return (tmp);
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static int test_and_clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
#line 81
  tmp = test_and_clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 81
  return (tmp);
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 86
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
  }
#line 86
  return (tmp___0);
}
}
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bottom_half.h"
extern void local_bh_disable(void) ;
#line 5
extern void _local_bh_enable(void) ;
#line 6
extern void local_bh_enable(void) ;
#line 7
extern void local_bh_enable_ip(unsigned long ip ) ;
#line 304 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void lockdep_off(void) 
{ 

  {
#line 306
  return;
}
}
#line 308 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void lockdep_on(void) 
{ 

  {
#line 310
  return;
}
}
#line 385
extern void early_init_irq_lock_class(void) ;
#line 397 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void early_boot_irqs_off(void) 
{ 

  {
#line 399
  return;
}
}
#line 400 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void early_boot_irqs_on(void) 
{ 

  {
#line 402
  return;
}
}
#line 403 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/lockdep.h"
__inline static void print_irqtrace_events(struct task_struct *curr ) 
{ 

  {
#line 405
  return;
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock.h"
extern int generic__raw_read_trylock(raw_rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __ticket_spin_lock(raw_spinlock_t *lock ) 
{ short inc ;

  {
  {
#line 63
  inc = (short)256;
#line 65
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddw %w0, %1\n"
                       "1:\t"
                       "cmpb %h0, %b0\n\t"
                       "je 2f\n\t"
                       "rep ; nop\n\t"
                       "movb %1, %b0\n\t"
                       "jmp 1b\n"
                       "2:": "+Q" (inc), "+m" (lock->slock): : "memory", "cc");
  }
#line 78
  return;
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __ticket_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;
  int new ;

  {
  {
#line 84
  __asm__  volatile   ("movzwl %2, %0\n\t"
                       "cmpb %h0,%b0\n\t"
                       "leal 0x100(%"
                       "k"
                       "0), %1\n\t"
                       "jne 1f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchgw %w1,%2\n\t"
                       "1:"
                       "sete %b1\n\t"
                       "movzbl %b1,%0\n\t": "=&a" (tmp), "=&q" (new), "+m" (lock->slock): : "memory",
                       "cc");
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __ticket_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
#line 101
  __asm__  volatile   ("incb %0": "+m" (lock->slock): : "memory", "cc");
  }
#line 105
  return;
}
}
#line 161 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __ticket_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 163
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
#line 165
  return (! (! (((tmp >> 8) ^ tmp) & ((1 << 8) - 1))));
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __ticket_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 170
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
#line 172
  return ((((tmp >> 8) - tmp) & ((1 << 8) - 1)) > 1);
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 179
  tmp = __ticket_spin_is_locked(lock);
  }
#line 179
  return (tmp);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 184
  tmp = __ticket_spin_is_contended(lock);
  }
#line 184
  return (tmp);
}
}
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_lock(raw_spinlock_t *lock ) 
{ 

  {
  {
#line 190
  __ticket_spin_lock(lock);
  }
#line 191
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 195
  tmp = __ticket_spin_trylock(lock);
  }
#line 195
  return (tmp);
}
}
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
#line 200
  __ticket_spin_unlock(lock);
  }
#line 201
  return;
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_lock_flags(raw_spinlock_t *lock , unsigned long flags ) 
{ 

  {
  {
#line 206
  __raw_spin_lock(lock);
  }
#line 207
  return;
}
}
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_spin_unlock_wait(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
#line 213
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
#line 213
    tmp = __raw_spin_is_locked(lock);
    }
#line 213
    if (! tmp) {
      goto while_21_break;
    }
    {
#line 214
    cpu_relax();
    }
  }
  while_21_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 235 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_read_can_lock(raw_rwlock_t *lock ) 
{ 

  {
#line 237
  return ((int )lock->lock > 0);
}
}
#line 244 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_write_can_lock(raw_rwlock_t *lock ) 
{ 

  {
#line 246
  return (lock->lock == 16777216U);
}
}
#line 249 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_read_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 251
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl $1,(%0)\n\t"
                       "jns 1f\n"
                       "call __read_lock_failed\n\t"
                       "1:\n": : "a" (rw): "memory");
  }
#line 256
  return;
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_write_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 260
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl %1,(%0)\n\t"
                       "jz 1f\n"
                       "call __write_lock_failed\n\t"
                       "1:\n": : "a" (rw), "i" (16777216): "memory");
  }
#line 265
  return;
}
}
#line 267 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_read_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
#line 269
  count = (atomic_t *)lock;
#line 271
  tmp = atomic_sub_return(1, count);
  }
#line 271
  if (tmp >= 0) {
#line 272
    return (1);
  }
  {
#line 273
  atomic_inc(count);
  }
#line 274
  return (0);
}
}
#line 277 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static int __raw_write_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
#line 279
  count = (atomic_t *)lock;
#line 281
  tmp = atomic_sub_and_test(16777216, count);
  }
#line 281
  if (tmp) {
#line 282
    return (1);
  }
  {
#line 283
  atomic_add(16777216, count);
  }
#line 284
  return (0);
}
}
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_read_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 289
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (rw->lock): : "memory");
  }
#line 290
  return;
}
}
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/spinlock.h"
__inline static void __raw_write_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
#line 294
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1, %0": "+m" (rw->lock): "i" (16777216): "memory");
  }
#line 296
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock.h"
extern void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 109
extern void __rwlock_init(rwlock_t *lock , char const   *name , struct lock_class_key *key ) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock_api_smp.h"
extern int in_lock_functions(unsigned long addr ) ;
#line 22
extern void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 23
extern void _spin_lock_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
#line 25
extern void _spin_lock_nest_lock(spinlock_t *lock , struct lockdep_map *map )  __attribute__((__section__(".spinlock.text"))) ;
#line 27
extern void _read_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 28
extern void _write_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 29
extern void _spin_lock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 30
extern void _read_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 31
extern void _write_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 32
extern void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 33
extern void _read_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 34
extern void _write_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 35
extern unsigned long _spin_lock_irqsave(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 37
extern unsigned long _spin_lock_irqsave_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
#line 39
extern unsigned long _read_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 41
extern unsigned long _write_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 43
extern int _spin_trylock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 44
extern int _read_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 45
extern int _write_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 46
extern int _spin_trylock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 47
extern void _spin_unlock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 48
extern void _read_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 49
extern void _write_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 50
extern void _spin_unlock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 51
extern void _read_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 52
extern void _write_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 53
extern void _spin_unlock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 54
extern void _read_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 55
extern void _write_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
#line 56
extern void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 58
extern void _read_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 60
extern void _write_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/spinlock.h"
extern void _raw_spin_lock(spinlock_t *lock ) ;
#line 153
extern int _raw_spin_trylock(spinlock_t *lock ) ;
#line 154
extern void _raw_spin_unlock(spinlock_t *lock ) ;
#line 155
extern void _raw_read_lock(rwlock_t *lock ) ;
#line 157
extern int _raw_read_trylock(rwlock_t *lock ) ;
#line 158
extern void _raw_read_unlock(rwlock_t *lock ) ;
#line 159
extern void _raw_write_lock(rwlock_t *lock ) ;
#line 161
extern int _raw_write_trylock(rwlock_t *lock ) ;
#line 162
extern void _raw_write_unlock(rwlock_t *lock ) ;
#line 368
extern int _atomic_dec_and_lock(atomic_t *atomic , spinlock_t *lock ) ;
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_seqlock(seqlock_t *sl ) 
{ 

  {
  {
#line 62
  _spin_lock(& sl->lock);
#line 63
  (sl->sequence) ++;
#line 64
  __asm__  volatile   ("": : : "memory");
  }
#line 65
  return;
}
}
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_sequnlock(seqlock_t *sl ) 
{ 

  {
  {
#line 69
  __asm__  volatile   ("": : : "memory");
#line 70
  (sl->sequence) ++;
#line 71
  _spin_unlock(& sl->lock);
  }
#line 72
  return;
}
}
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static int write_tryseqlock(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  {
#line 76
  tmp = _spin_trylock(& sl->lock);
#line 76
  ret = tmp;
  }
#line 78
  if (ret) {
    {
#line 79
    (sl->sequence) ++;
#line 80
    __asm__  volatile   ("": : : "memory");
    }
  }
#line 82
  return (ret);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static unsigned int read_seqbegin(seqlock_t const   *sl ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
#line 91
  ret = (unsigned int )sl->sequence;
#line 92
  __asm__  volatile   ("": : : "memory");
#line 93
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
#line 93
  if (tmp) {
    {
#line 94
    cpu_relax();
    }
    goto repeat;
  }
#line 98
  return (ret);
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static int read_seqretry(seqlock_t const   *sl , unsigned int start ) 
{ 

  {
  {
#line 108
  __asm__  volatile   ("": : : "memory");
  }
#line 110
  return (sl->sequence != (unsigned int const   )start);
}
}
#line 129 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static unsigned int read_seqcount_begin(seqcount_t const   *s ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
#line 134
  ret = (unsigned int )s->sequence;
#line 135
  __asm__  volatile   ("": : : "memory");
#line 136
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
#line 136
  if (tmp) {
    {
#line 137
    cpu_relax();
    }
    goto repeat;
  }
#line 140
  return (ret);
}
}
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static int read_seqcount_retry(seqcount_t const   *s , unsigned int start ) 
{ 

  {
  {
#line 148
  __asm__  volatile   ("": : : "memory");
  }
#line 150
  return (s->sequence != (unsigned int const   )start);
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_begin(seqcount_t *s ) 
{ 

  {
  {
#line 160
  (s->sequence) ++;
#line 161
  __asm__  volatile   ("": : : "memory");
  }
#line 162
  return;
}
}
#line 164 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seqlock.h"
__inline static void write_seqcount_end(seqcount_t *s ) 
{ 

  {
  {
#line 166
  __asm__  volatile   ("": : : "memory");
#line 167
  (s->sequence) ++;
  }
#line 168
  return;
}
}
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/div64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37 d ;
  u32 upper ;

  {
  {
#line 38
  d.v64 = dividend;
#line 44
  upper = d.v32[1];
#line 45
  d.v32[1] = 0U;
  }
#line 46
  if (upper >= divisor) {
    {
#line 47
    d.v32[1] = upper / divisor;
#line 48
    upper %= divisor;
    }
  }
  {
#line 50
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
#line 52
  return (d.v64);
}
}
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
extern s64 div_s64_rem(s64 dividend , s32 divisor , s32 *remainder ) ;
#line 53
extern u64 div64_u64(u64 dividend , u64 divisor ) ;
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
#line 69
  tmp = div_u64_rem(dividend, divisor, & remainder);
  }
#line 69
  return (tmp);
}
}
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
__inline static s64 div_s64(s64 dividend , s32 divisor ) 
{ s32 remainder ;
  s64 tmp ;

  {
  {
#line 80
  tmp = div_s64_rem(dividend, divisor, & remainder);
  }
#line 80
  return (tmp);
}
}
#line 84
extern u32 iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) ;
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/math64.h"
__inline static u32 __iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) 
{ u32 ret ;

  {
  {
#line 89
  ret = (u32 )0;
  }
  {
#line 91
  while (1) {
    while_22_continue: /* CIL Label */ ;
#line 91
    if (! (dividend >= (u64 )divisor)) {
      goto while_22_break;
    }
    {
#line 94
    __asm__  ("": "+rm" (dividend));
#line 96
    dividend -= (u64 )divisor;
#line 97
    ret ++;
    }
  }
  while_22_break: /* CIL Label */ ;
  }
  {
#line 100
  *remainder = dividend;
  }
#line 102
  return (ret);
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
extern struct timezone sys_tz ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static int timespec_equal(struct timespec  const  *a , struct timespec  const  *b ) 
{ int tmp ;

  {
#line 48
  if (a->tv_sec == b->tv_sec) {
#line 48
    if (a->tv_nsec == b->tv_nsec) {
      {
#line 48
      tmp = 1;
      }
    } else {
      {
#line 48
      tmp = 0;
      }
    }
  } else {
    {
#line 48
    tmp = 0;
    }
  }
#line 48
  return (tmp);
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 

  {
#line 58
  if (lhs->tv_sec < rhs->tv_sec) {
#line 59
    return (-1);
  }
#line 60
  if (lhs->tv_sec > rhs->tv_sec) {
#line 61
    return (1);
  }
#line 62
  return ((int )(lhs->tv_nsec - rhs->tv_nsec));
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static int timeval_compare(struct timeval  const  *lhs , struct timeval  const  *rhs ) 
{ 

  {
#line 67
  if (lhs->tv_sec < rhs->tv_sec) {
#line 68
    return (-1);
  }
#line 69
  if (lhs->tv_sec > rhs->tv_sec) {
#line 70
    return (1);
  }
#line 71
  return ((int )(lhs->tv_usec - rhs->tv_usec));
}
}
#line 74
extern unsigned long mktime(unsigned int year , unsigned int mon , unsigned int day ,
                            unsigned int hour , unsigned int min , unsigned int sec ) ;
#line 78
extern void set_normalized_timespec(struct timespec *ts , time_t sec , long nsec ) ;
#line 79
extern struct timespec timespec_add_safe(struct timespec lhs , struct timespec rhs ) ;
#line 85 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ struct timespec ts_delta ;

  {
  {
#line 89
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, lhs.tv_nsec - rhs.tv_nsec);
  }
#line 91
  return (ts_delta);
}
}
#line 100
extern struct timespec xtime ;
#line 101
extern struct timespec wall_to_monotonic ;
#line 102
extern seqlock_t xtime_lock ;
#line 104
extern unsigned long read_persistent_clock(void) ;
#line 105
extern int update_persistent_clock(struct timespec now ) ;
#line 106
extern int no_sync_cmos_clock  __attribute__((__section__(".data.read_mostly"))) ;
#line 107
extern void timekeeping_init(void) ;
#line 108
extern int timekeeping_suspended ;
#line 110
extern unsigned long get_seconds(void) ;
#line 111
extern struct timespec current_kernel_time(void) ;
#line 116
extern void do_gettimeofday(struct timeval *tv ) ;
#line 117
extern int do_settimeofday(struct timespec *tv ) ;
#line 118
extern int do_sys_settimeofday(struct timespec *tv , struct timezone *tz ) ;
#line 120
extern long do_utimes(int dfd , char *filename , struct timespec *times , int flags ) ;
#line 122
extern int do_setitimer(int which , struct itimerval *value , struct itimerval *ovalue ) ;
#line 124
extern unsigned int alarm_setitimer(unsigned int seconds ) ;
#line 125
extern int do_getitimer(int which , struct itimerval *value ) ;
#line 126
extern void getnstimeofday(struct timespec *tv ) ;
#line 127
extern void getrawmonotonic(struct timespec *ts ) ;
#line 128
extern void getboottime(struct timespec *ts ) ;
#line 129
extern void monotonic_to_bootbased(struct timespec *ts ) ;
#line 131
extern struct timespec timespec_trunc(struct timespec t , unsigned int gran ) ;
#line 132
extern int timekeeping_valid_for_hres(void) ;
#line 133
extern void update_wall_time(void) ;
#line 134
extern void update_xtime_cache(u64 nsec ) ;
#line 137
extern void do_sys_times(struct tms * ) ;
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static s64 timespec_to_ns(struct timespec  const  *ts ) 
{ 

  {
#line 148
  return ((long long )ts->tv_sec * 1000000000LL + (long long )ts->tv_nsec);
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static s64 timeval_to_ns(struct timeval  const  *tv ) 
{ 

  {
#line 160
  return ((long long )tv->tv_sec * 1000000000LL + (long long )(tv->tv_usec * 1000L));
}
}
#line 170
extern struct timespec ns_to_timespec(s64 nsec ) ;
#line 178
extern struct timeval ns_to_timeval(s64 nsec ) ;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/time.h"
__inline static void timespec_add_ns(struct timespec *a , u64 ns ) 
{ u32 tmp ;

  {
  {
#line 190
  tmp = __iter_div_u64_rem((u64 )a->tv_nsec + ns, 1000000000U, & ns);
#line 190
  a->tv_sec += (__kernel_time_t )tmp;
#line 191
  a->tv_nsec = (long )ns;
  }
#line 192
  return;
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key ) ;
#line 80
extern void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void init_waitqueue_entry(wait_queue_t *q , struct task_struct *p ) 
{ 

  {
  {
#line 93
  q->flags = 0U;
#line 94
  q->private = (void *)p;
#line 95
  q->func = & default_wake_function;
  }
#line 96
  return;
}
}
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void init_waitqueue_func_entry(wait_queue_t *q , int (*func)(wait_queue_t *wait ,
                                                                             unsigned int mode ,
                                                                             int sync ,
                                                                             void *key ) ) 
{ 

  {
  {
#line 101
  q->flags = 0U;
#line 102
  q->private = (void *)0;
#line 103
  q->func = func;
  }
#line 104
  return;
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static int waitqueue_active(wait_queue_head_t *q ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 108
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
  }
#line 108
  if (tmp) {
    {
#line 108
    tmp___0 = 0;
    }
  } else {
    {
#line 108
    tmp___0 = 1;
    }
  }
#line 108
  return (tmp___0);
}
}
#line 111
extern void add_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 112
extern void add_wait_queue_exclusive(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 113
extern void remove_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
#line 117
  list_add(& new->task_list, & head->task_list);
  }
#line 118
  return;
}
}
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void __add_wait_queue_tail(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
#line 126
  list_add_tail(& new->task_list, & head->task_list);
  }
#line 127
  return;
}
}
#line 129 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void __remove_wait_queue(wait_queue_head_t *head , wait_queue_t *old ) 
{ 

  {
  {
#line 132
  list_del(& old->task_list);
  }
#line 133
  return;
}
}
#line 135
extern void __wake_up_common(wait_queue_head_t *q , unsigned int mode , int nr_exclusive ,
                             int sync , void *key ) ;
#line 137
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
#line 138
extern void __wake_up_locked_key(wait_queue_head_t *q , unsigned int mode , void *key ) ;
#line 139
extern void __wake_up_sync_key(wait_queue_head_t *q , unsigned int mode , int nr ,
                               void *key ) ;
#line 141
extern void __wake_up_locked(wait_queue_head_t *q , unsigned int mode ) ;
#line 142
extern void __wake_up_sync(wait_queue_head_t *q , unsigned int mode , int nr ) ;
#line 143
extern void __wake_up_bit(wait_queue_head_t * , void * , int  ) ;
#line 144
extern int __wait_on_bit(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                         unsigned int  ) ;
#line 145
extern int __wait_on_bit_lock(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                              unsigned int  ) ;
#line 146
extern void wake_up_bit(void * , int  ) ;
#line 147
extern int out_of_line_wait_on_bit(void * , int  , int (*)(void * ) , unsigned int  ) ;
#line 148
extern int out_of_line_wait_on_bit_lock(void * , int  , int (*)(void * ) , unsigned int  ) ;
#line 149
extern wait_queue_head_t *bit_waitqueue(void * , int  ) ;
#line 404 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void add_wait_queue_exclusive_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
#line 407
  wait->flags |= 1U;
#line 408
  __add_wait_queue_tail(q, wait);
  }
#line 409
  return;
}
}
#line 414 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static void remove_wait_queue_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
#line 417
  __remove_wait_queue(q, wait);
  }
#line 418
  return;
}
}
#line 425
extern void sleep_on(wait_queue_head_t *q ) ;
#line 426
extern long sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
#line 428
extern void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 429
extern long interruptible_sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
#line 435
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
#line 436
extern void prepare_to_wait_exclusive(wait_queue_head_t *q , wait_queue_t *wait ,
                                      int state ) ;
#line 437
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 438
extern void abort_exclusive_wait(wait_queue_head_t *q , wait_queue_t *wait , unsigned int mode ,
                                 void *key ) ;
#line 440
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
#line 441
extern int wake_bit_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
#line 484 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static int wait_on_bit(void *word , int bit , int (*action)(void * ) , unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 487
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)word);
  }
#line 487
  if (! tmp___0) {
#line 488
    return (0);
  }
  {
#line 489
  tmp___1 = out_of_line_wait_on_bit(word, bit, action, mode);
  }
#line 489
  return (tmp___1);
}
}
#line 508 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/wait.h"
__inline static int wait_on_bit_lock(void *word , int bit , int (*action)(void * ) ,
                                     unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 511
  tmp = test_and_set_bit(bit, (unsigned long volatile   *)word);
  }
#line 511
  if (! tmp) {
#line 512
    return (0);
  }
  {
#line 513
  tmp___0 = out_of_line_wait_on_bit_lock(word, bit, action, mode);
  }
#line 513
  return (tmp___0);
}
}
#line 93 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
extern nodemask_t _unused_nodemask_arg_ ;
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __node_set(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
#line 98
  set_bit((unsigned int )node, (unsigned long volatile   *)(dstp->bits));
  }
#line 99
  return;
}
}
#line 102 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __node_clear(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
#line 104
  clear_bit(node, (unsigned long volatile   *)(dstp->bits));
  }
#line 105
  return;
}
}
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_setall(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
#line 110
  bitmap_fill(dstp->bits, nbits);
  }
#line 111
  return;
}
}
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_clear(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
#line 116
  bitmap_zero(dstp->bits, nbits);
  }
#line 117
  return;
}
}
#line 124 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __node_test_and_set(int node , nodemask_t *addr ) 
{ int tmp ;

  {
  {
#line 126
  tmp = test_and_set_bit(node, (unsigned long volatile   *)(addr->bits));
  }
#line 126
  return (tmp);
}
}
#line 131 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_and(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
#line 134
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
#line 135
  return;
}
}
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_or(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
#line 142
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
#line 143
  return;
}
}
#line 147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_xor(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
#line 150
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
#line 151
  return;
}
}
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_andnot(nodemask_t *dstp , nodemask_t const   *src1p ,
                                    nodemask_t const   *src2p , int nbits ) 
{ 

  {
  {
#line 158
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  }
#line 159
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_complement(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int nbits ) 
{ 

  {
  {
#line 166
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
#line 167
  return;
}
}
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_equal(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
#line 174
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
#line 174
  return (tmp);
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_intersects(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                       int nbits ) 
{ int tmp ;

  {
  {
#line 182
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
#line 182
  return (tmp);
}
}
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_subset(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                   int nbits ) 
{ int tmp ;

  {
  {
#line 190
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
#line 190
  return (tmp);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_empty(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 196
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
#line 196
  return (tmp);
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_full(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 202
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
#line 202
  return (tmp);
}
}
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodes_weight(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
#line 208
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
#line 208
  return (tmp);
}
}
#line 213 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_shift_right(nodemask_t *dstp , nodemask_t const   *srcp ,
                                         int n , int nbits ) 
{ 

  {
  {
#line 216
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 217
  return;
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_shift_left(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
#line 224
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
#line 225
  return;
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __first_node(nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 233
  __min1 = 1;
#line 233
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 1UL);
#line 233
  __min2 = (int )tmp;
  }
#line 233
  if (__min1 < __min2) {
    {
#line 233
    tmp___0 = __min1;
    }
  } else {
    {
#line 233
    tmp___0 = __min2;
    }
  }
#line 233
  return (tmp___0);
}
}
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __next_node(int n , nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 239
  __min1 = 1;
#line 239
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 1UL, (unsigned long )(n + 1));
#line 239
  __min2 = (int )tmp;
  }
#line 239
  if (__min1 < __min2) {
    {
#line 239
    tmp___0 = __min1;
    }
  } else {
    {
#line 239
    tmp___0 = __min2;
    }
  }
#line 239
  return (tmp___0);
}
}
#line 255 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __first_unset_node(nodemask_t const   *maskp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
#line 257
  __min1 = 1;
#line 257
  tmp = find_first_zero_bit((unsigned long const   *)(maskp->bits), 1UL);
#line 257
  __min2 = (int )tmp;
  }
#line 257
  if (__min1 < __min2) {
    {
#line 257
    tmp___0 = __min1;
    }
  } else {
    {
#line 257
    tmp___0 = __min2;
    }
  }
#line 257
  return (tmp___0);
}
}
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodemask_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
#line 292
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         nbits);
  }
#line 292
  return (tmp);
}
}
#line 297 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodemask_parse_user(char const   *buf , int len , nodemask_t *dstp ,
                                          int nbits ) 
{ int tmp ;

  {
  {
#line 300
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, nbits);
  }
#line 300
  return (tmp);
}
}
#line 305 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodelist_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
#line 308
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             nbits);
  }
#line 308
  return (tmp);
}
}
#line 312 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __nodelist_parse(char const   *buf , nodemask_t *dstp , int nbits ) 
{ int tmp ;

  {
  {
#line 314
  tmp = bitmap_parselist(buf, dstp->bits, nbits);
  }
#line 314
  return (tmp);
}
}
#line 319 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int __node_remap(int oldbit , nodemask_t const   *oldp , nodemask_t const   *newp ,
                                 int nbits ) 
{ int tmp ;

  {
  {
#line 322
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
#line 322
  return (tmp);
}
}
#line 327 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_remap(nodemask_t *dstp , nodemask_t const   *srcp , nodemask_t const   *oldp ,
                                   nodemask_t const   *newp , int nbits ) 
{ 

  {
  {
#line 330
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
#line 331
  return;
}
}
#line 335 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_onto(nodemask_t *dstp , nodemask_t const   *origp , nodemask_t const   *relmapp ,
                                  int nbits ) 
{ 

  {
  {
#line 338
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
#line 339
  return;
}
}
#line 343 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void __nodes_fold(nodemask_t *dstp , nodemask_t const   *origp , int sz ,
                                  int nbits ) 
{ 

  {
  {
#line 346
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
#line 347
  return;
}
}
#line 381
extern nodemask_t node_states[5] ;
#line 413 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int node_state(int node , enum node_states state ) 
{ 

  {
#line 415
  return (node == 0);
}
}
#line 418 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void node_set_state(int node , enum node_states state ) 
{ 

  {
#line 420
  return;
}
}
#line 422 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static void node_clear_state(int node , enum node_states state ) 
{ 

  {
#line 424
  return;
}
}
#line 426 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nodemask.h"
__inline static int num_node_state(enum node_states state ) 
{ 

  {
#line 428
  return (1);
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pageblock-flags.h"
extern unsigned long get_pageblock_flags_group(struct page *page , int start_bitidx ,
                                               int end_bitidx ) ;
#line 65
extern void set_pageblock_flags_group(struct page *page , unsigned long flags , int start_bitidx ,
                                      int end_bitidx ) ;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
extern int page_group_by_mobility_disabled ;
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int get_pageblock_migratetype(struct page *page ) 
{ long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 53
  tmp = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
#line 53
  if (tmp) {
#line 54
    return (0);
  }
  {
#line 56
  tmp___0 = get_pageblock_flags_group(page, 0, 2);
  }
#line 56
  return ((int )tmp___0);
}
}
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_file_lru(enum lru_list l ) 
{ int tmp ;

  {
#line 152
  if ((unsigned int )l == 2U) {
    {
#line 152
    tmp = 1;
    }
  } else {
#line 152
    if ((unsigned int )l == 3U) {
      {
#line 152
      tmp = 1;
      }
    } else {
      {
#line 152
      tmp = 0;
      }
    }
  }
#line 152
  return (tmp);
}
}
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_active_lru(enum lru_list l ) 
{ int tmp ;

  {
#line 157
  if ((unsigned int )l == 1U) {
    {
#line 157
    tmp = 1;
    }
  } else {
#line 157
    if ((unsigned int )l == 3U) {
      {
#line 157
      tmp = 1;
      }
    } else {
      {
#line 157
      tmp = 0;
      }
    }
  }
#line 157
  return (tmp);
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_unevictable_lru(enum lru_list l ) 
{ 

  {
#line 163
  return ((unsigned int )l == 4U);
}
}
#line 424 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static void zone_set_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
#line 426
  set_bit((unsigned int )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 427
  return;
}
}
#line 429 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_test_and_set_flag(struct zone *zone , zone_flags_t flag ) 
{ int tmp ;

  {
  {
#line 431
  tmp = test_and_set_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 431
  return (tmp);
}
}
#line 434 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static void zone_clear_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
#line 436
  clear_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
#line 437
  return;
}
}
#line 439 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_is_all_unreclaimable(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 441
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& zone->flags));
  }
#line 441
  return (tmp);
}
}
#line 444 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_is_reclaim_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 446
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& zone->flags));
  }
#line 446
  return (tmp);
}
}
#line 449 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_is_oom_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 451
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& zone->flags));
  }
#line 451
  return (tmp);
}
}
#line 589
extern struct page *mem_map ;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mutex.h"
__inline static int mutex_is_locked(struct mutex *lock ) 
{ 

  {
#line 118
  return (lock->count.counter != (int volatile   )1);
}
}
#line 136
extern void mutex_lock(struct mutex *lock ) ;
#line 137
extern int mutex_lock_interruptible(struct mutex *lock ) ;
#line 138
extern int mutex_lock_killable(struct mutex *lock ) ;
#line 151
extern int mutex_trylock(struct mutex *lock ) ;
#line 152
extern void mutex_unlock(struct mutex *lock ) ;
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_read_failed)(struct rw_semaphore *sem ) ;
#line 49
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_write_failed)(struct rw_semaphore *sem ) ;
#line 51
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_wake)(struct rw_semaphore * ) ;
#line 53
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_downgrade_wake)(struct rw_semaphore *sem ) ;
#line 92
extern void __init_rwsem(struct rw_semaphore *sem , char const   *name , struct lock_class_key *key ) ;
#line 105 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_read(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 107
  __asm__  volatile   ("# beginning down_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  incl      (%%eax)\n\t"
                       "  jns        1f\n"
                       "  call call_rwsem_down_read_failed\n"
                       "1:\n\t"
                       "# ending down_read\n\t": "+m" (sem->count): "a" (sem): "memory",
                       "cc");
  }
#line 117
  return;
}
}
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int __down_read_trylock(struct rw_semaphore *sem ) 
{ __s32 result ;
  __s32 tmp ;
  int tmp___0 ;

  {
  {
#line 125
  __asm__  volatile   ("# beginning __down_read_trylock\n\t"
                       "  movl      %0,%1\n\t"
                       "1:\n\t"
                       "  movl\t     %1,%2\n\t"
                       "  addl      %3,%2\n\t"
                       "  jle\t     2f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  cmpxchgl  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "# ending __down_read_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "i" (1): "memory", "cc");
  }
#line 138
  if (result >= 0) {
    {
#line 138
    tmp___0 = 1;
    }
  } else {
    {
#line 138
    tmp___0 = 0;
    }
  }
#line 138
  return (tmp___0);
}
}
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_write_nested(struct rw_semaphore *sem , int subclass ) 
{ int tmp ;

  {
  {
#line 148
  tmp = -65535;
#line 149
  __asm__  volatile   ("# beginning down_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  testl     %%edx,%%edx\n\t"
                       "  jz        1f\n"
                       "  call call_rwsem_down_write_failed\n"
                       "1:\n"
                       "# ending down_write": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
#line 161
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __down_write(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 165
  __down_write_nested(sem, 0);
  }
#line 166
  return;
}
}
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int __down_write_trylock(struct rw_semaphore *sem ) 
{ long ret ;
  unsigned long tmp ;

  {
  {
#line 173
  tmp = __cmpxchg((void volatile   *)(& sem->count), 0UL, 0xffff0001UL, (int )sizeof(sem->count));
#line 173
  ret = (long )tmp;
  }
#line 176
  if (ret == 0L) {
#line 177
    return (1);
  }
#line 178
  return (0);
}
}
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __up_read(struct rw_semaphore *sem ) 
{ __s32 tmp ;

  {
  {
#line 186
  tmp = -1;
#line 187
  __asm__  volatile   ("# beginning __up_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  jns        1f\n\t"
                       "  call call_rwsem_wake\n"
                       "1:\n"
                       "# ending __up_read\n": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
#line 197
  return;
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __up_write(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 204
  __asm__  volatile   ("# beginning __up_write\n\t"
                       "  movl      %2,%%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xaddl     %%edx,(%%eax)\n\t"
                       "  jz       1f\n"
                       "  call call_rwsem_wake\n"
                       "1:\n\t"
                       "# ending __up_write\n": "+m" (sem->count): "a" (sem), "i" (65535): "memory",
                       "cc", "edx");
  }
#line 216
  return;
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void __downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  {
#line 223
  __asm__  volatile   ("# beginning __downgrade_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  addl      %2,(%%eax)\n\t"
                       "  jns       1f\n\t"
                       "  call call_rwsem_downgrade_wake\n"
                       "1:\n\t"
                       "# ending __downgrade_write\n": "+m" (sem->count): "a" (sem),
                       "i" (65536): "memory", "cc");
  }
#line 233
  return;
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static void rwsem_atomic_add(int delta , struct rw_semaphore *sem ) 
{ 

  {
  {
#line 240
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (sem->count): "ir" (delta));
  }
#line 243
  return;
}
}
#line 248 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int rwsem_atomic_update(int delta , struct rw_semaphore *sem ) 
{ int tmp ;

  {
  {
#line 250
  tmp = delta;
#line 252
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xadd %0,%1": "+r" (tmp), "+m" (sem->count): : "memory");
  }
#line 256
  return (tmp + delta);
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/rwsem.h"
__inline static int rwsem_is_locked(struct rw_semaphore *sem ) 
{ 

  {
#line 261
  return (sem->count != 0L);
}
}
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rwsem.h"
extern void down_read(struct rw_semaphore *sem ) ;
#line 33
extern int down_read_trylock(struct rw_semaphore *sem ) ;
#line 38
extern void down_write(struct rw_semaphore *sem ) ;
#line 43
extern int down_write_trylock(struct rw_semaphore *sem ) ;
#line 48
extern void up_read(struct rw_semaphore *sem ) ;
#line 53
extern void up_write(struct rw_semaphore *sem ) ;
#line 58
extern void downgrade_write(struct rw_semaphore *sem ) ;
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/srcu.h"
extern int init_srcu_struct(struct srcu_struct *sp ) ;
#line 47
extern void cleanup_srcu_struct(struct srcu_struct *sp ) ;
#line 48
extern int srcu_read_lock(struct srcu_struct *sp ) ;
#line 49
extern void srcu_read_unlock(struct srcu_struct *sp , int idx ) ;
#line 50
extern void synchronize_srcu(struct srcu_struct *sp ) ;
#line 51
extern long srcu_batches_completed(struct srcu_struct *sp ) ;
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh ) ;
#line 115
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
#line 117
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh , struct notifier_block *nb ) ;
#line 119
extern int raw_notifier_chain_register(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
#line 121
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
#line 124
extern int blocking_notifier_chain_cond_register(struct blocking_notifier_head *nh ,
                                                 struct notifier_block *nb ) ;
#line 128
extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
#line 130
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh ,
                                              struct notifier_block *nb ) ;
#line 132
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
#line 134
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
#line 137
extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                      void *v ) ;
#line 139
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                        void *v , int nr_to_call , int *nr_calls ) ;
#line 141
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                        void *v ) ;
#line 143
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                          void *v , int nr_to_call , int *nr_calls ) ;
#line 145
extern int raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                   void *v ) ;
#line 147
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                     void *v , int nr_to_call , int *nr_calls ) ;
#line 149
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                    void *v ) ;
#line 151
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                      void *v , int nr_to_call , int *nr_calls ) ;
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
__inline static int notifier_from_errno(int err ) 
{ 

  {
#line 167
  return (32768 | (1 - err));
}
}
#line 171 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/notifier.h"
__inline static int notifier_to_errno(int ret ) 
{ int tmp ;

  {
  {
#line 173
  ret &= -32769;
  }
#line 174
  if (ret > 1) {
    {
#line 174
    tmp = 1 - ret;
    }
  } else {
    {
#line 174
    tmp = 0;
    }
  }
#line 174
  return (tmp);
}
}
#line 258
extern struct blocking_notifier_head reboot_notifier_list ;
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_lock(struct pglist_data *p , unsigned long *f ) 
{ 

  {
#line 165
  return;
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_unlock(struct pglist_data *p , unsigned long *f ) 
{ 

  {
#line 166
  return;
}
}
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void pgdat_resize_init(struct pglist_data *pgdat ) 
{ 

  {
#line 167
  return;
}
}
#line 169 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static unsigned int zone_span_seqbegin(struct zone *zone ) 
{ 

  {
#line 171
  return (0U);
}
}
#line 173 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static int zone_span_seqretry(struct zone *zone , unsigned int iv ) 
{ 

  {
#line 175
  return (0);
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_span_writelock(struct zone *zone ) 
{ 

  {
#line 177
  return;
}
}
#line 178 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_span_writeunlock(struct zone *zone ) 
{ 

  {
#line 178
  return;
}
}
#line 179 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void zone_seqlock_init(struct zone *zone ) 
{ 

  {
#line 179
  return;
}
}
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static int mhp_notimplemented(char const   *func ) 
{ 

  {
  {
#line 183
  printk("<4>%s() called, with CONFIG_MEMORY_HOTPLUG disabled\n", func);
#line 184
  dump_stack();
  }
#line 185
  return (-38);
}
}
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static void register_page_bootmem_info_node(struct pglist_data *pgdat ) 
{ 

  {
#line 190
  return;
}
}
#line 198
extern int walk_memory_resource(unsigned long start_pfn , unsigned long nr_pages ,
                                void *arg , int (*func)(unsigned long  , unsigned long  ,
                                                        void * ) ) ;
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/memory_hotplug.h"
__inline static int is_mem_section_removable(unsigned long pfn , unsigned long nr_pages ) 
{ 

  {
#line 210
  return (0);
}
}
#line 214
extern int add_memory(int nid , u64 start , u64 size ) ;
#line 215
extern int arch_add_memory(int nid , u64 start , u64 size ) ;
#line 216
extern int remove_memory(u64 start , u64 size ) ;
#line 217
extern int sparse_add_one_section(struct zone *zone , unsigned long start_pfn , int nr_pages ) ;
#line 219
extern void sparse_remove_one_section(struct zone *zone , struct mem_section *ms ) ;
#line 220
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map , unsigned long pnum ) ;
#line 646 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
extern void get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ) ;
#line 648
extern void build_all_zonelists(void) ;
#line 649
extern void wakeup_kswapd(struct zone *zone , int order ) ;
#line 650
extern int zone_watermark_ok(struct zone *z , int order , unsigned long mark , int classzone_idx ,
                             int alloc_flags ) ;
#line 656
extern int init_currently_empty_zone(struct zone *zone , unsigned long start_pfn ,
                                     unsigned long size , enum memmap_context context ) ;
#line 663 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static void memory_present(int nid , unsigned long start , unsigned long end ) 
{ 

  {
#line 663
  return;
}
}
#line 675 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int populated_zone(struct zone *zone ) 
{ 

  {
#line 677
  return (! (! zone->present_pages));
}
}
#line 680
extern int movable_zone ;
#line 682 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zone_movable_is_highmem(void) 
{ 

  {
#line 685
  return (movable_zone == 2);
}
}
#line 691 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_highmem_idx(enum zone_type idx ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 694
  if ((unsigned int )idx == 2U) {
    {
#line 694
    tmp___0 = 1;
    }
  } else {
#line 694
    if ((unsigned int )idx == 3U) {
      {
#line 694
      tmp = zone_movable_is_highmem();
      }
#line 694
      if (tmp) {
        {
#line 694
        tmp___0 = 1;
        }
      } else {
        {
#line 694
        tmp___0 = 0;
        }
      }
    } else {
      {
#line 694
      tmp___0 = 0;
      }
    }
  }
#line 694
  return (tmp___0);
}
}
#line 701 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_normal_idx(enum zone_type idx ) 
{ 

  {
#line 703
  return ((unsigned int )idx == 1U);
}
}
#line 712 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_highmem(struct zone *zone ) 
{ int zone_off ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 715
  zone_off = (char *)zone - (char *)((zone->zone_pgdat)->node_zones);
  }
#line 716
  if ((unsigned long )zone_off == 2UL * sizeof(*zone)) {
    {
#line 716
    tmp___0 = 1;
    }
  } else {
#line 716
    if ((unsigned long )zone_off == 3UL * sizeof(*zone)) {
      {
#line 716
      tmp = zone_movable_is_highmem();
      }
#line 716
      if (tmp) {
        {
#line 716
        tmp___0 = 1;
        }
      } else {
        {
#line 716
        tmp___0 = 0;
        }
      }
    } else {
      {
#line 716
      tmp___0 = 0;
      }
    }
  }
#line 716
  return (tmp___0);
}
}
#line 724 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_normal(struct zone *zone ) 
{ 

  {
#line 726
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 1));
}
}
#line 729 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_dma32(struct zone *zone ) 
{ 

  {
#line 734
  return (0);
}
}
#line 738 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int is_dma(struct zone *zone ) 
{ 

  {
#line 741
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 0));
}
}
#line 750
extern int min_free_kbytes_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                          void * , size_t * , loff_t * ) ;
#line 752
extern int sysctl_lowmem_reserve_ratio[3] ;
#line 753
extern int lowmem_reserve_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                               void * , size_t * , loff_t * ) ;
#line 755
extern int percpu_pagelist_fraction_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                   void * , size_t * , loff_t * ) ;
#line 757
extern int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                    void * , size_t * , loff_t * ) ;
#line 759
extern int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                void * , size_t * , loff_t * ) ;
#line 762
extern int numa_zonelist_order_handler(struct ctl_table * , int  , struct file * ,
                                       void * , size_t * , loff_t * ) ;
#line 764
extern char numa_zonelist_order[] ;
#line 769
extern struct pglist_data contig_page_data ;
#line 779
extern struct pglist_data *first_online_pgdat(void) ;
#line 780
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat ) ;
#line 781
extern struct zone *next_zone(struct zone *zone ) ;
#line 811 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static struct zone *zonelist_zone(struct zoneref *zoneref ) 
{ 

  {
#line 813
  return (zoneref->zone);
}
}
#line 816 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zonelist_zone_idx(struct zoneref *zoneref ) 
{ 

  {
#line 818
  return (zoneref->zone_idx);
}
}
#line 821 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int zonelist_node_idx(struct zoneref *zoneref ) 
{ 

  {
#line 827
  return (0);
}
}
#line 844
extern struct zoneref *next_zones_zonelist(struct zoneref *z , enum zone_type highest_zoneidx ,
                                           nodemask_t *nodes , struct zone **zone ) ;
#line 861 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static struct zoneref *first_zones_zonelist(struct zonelist *zonelist , enum zone_type highest_zoneidx ,
                                                     nodemask_t *nodes , struct zone **zone ) 
{ struct zoneref *tmp ;

  {
  {
#line 866
  tmp = next_zones_zonelist(zonelist->_zonerefs, highest_zoneidx, nodes, zone);
  }
#line 866
  return (tmp);
}
}
#line 1086
extern unsigned long node_memmap_size_bytes(int  , unsigned long  , unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mmzone.h"
__inline static int memmap_valid_within(unsigned long pfn , struct page *page , struct zone *zone ) 
{ 

  {
#line 1122
  return (1);
}
}
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
extern void cpu_idle(void) ;
#line 25
extern unsigned int total_cpus ;
#line 27
extern int smp_call_function_single(int cpuid , void (*func)(void *info ) , void *info ,
                                    int wait ) ;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
extern int apic_version[256] ;
#line 9
extern int pic_mode ;
#line 25
extern unsigned int def_to_bigsmp ;
#line 26
extern u8 apicid_2_node[] ;
#line 44
extern void early_find_smp_config(void) ;
#line 45
extern void early_get_smp_config(void) ;
#line 51
extern unsigned long mp_bus_not_pci[((260UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 53
extern unsigned int boot_cpu_physical_apicid ;
#line 54
extern unsigned int max_physical_apicid ;
#line 55
extern int smp_found_config ;
#line 56
extern int mpc_default_type ;
#line 57
extern unsigned long mp_lapic_addr ;
#line 59
extern void get_smp_config(void) ;
#line 62
extern void find_smp_config(void) ;
#line 63
extern void early_reserve_e820_mpc_new(void) ;
#line 69
extern void generic_processor_info(int apicid , int version )  __attribute__((__section__(".cpuinit.text"))) ;
#line 71
extern void mp_register_ioapic(int id , u32 address , u32 gsi_base ) ;
#line 72
extern void mp_override_legacy_irq(u8 bus_irq , u8 polarity , u8 trigger , u32 gsi ) ;
#line 74
extern void mp_config_acpi_legacy_irqs(void) ;
#line 75
extern int mp_register_gsi(u32 gsi , int edge_level , int active_high_low ) ;
#line 76
extern int acpi_probe_gsi(void) ;
#line 78
extern int mp_config_acpi_gsi(unsigned char number , unsigned int devfn , u8 pin ,
                              u32 gsi , int triggering , int polarity ) ;
#line 80
extern int mp_find_ioapic(int gsi ) ;
#line 81
extern int mp_find_ioapic_pin(int ioapic , int gsi ) ;
#line 155 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mpspec.h"
__inline static void physid_set_mask_of_physid(int physid , physid_mask_t *map ) 
{ 

  {
  {
#line 157
  bitmap_zero(map->mask, 256);
#line 158
  set_bit((unsigned int )physid, (unsigned long volatile   *)(map->mask));
  }
#line 159
  return;
}
}
#line 164
extern physid_mask_t phys_cpu_present_map ;
#line 166
extern int generic_mps_oem_check(struct mpc_table * , char * , char * ) ;
#line 168
extern int default_acpi_madt_oem_check(char * , char * ) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/delay.h"
extern unsigned long loops_per_jiffy ;
#line 11 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/delay.h"
extern void __bad_udelay(void) ;
#line 12
extern void __bad_ndelay(void) ;
#line 14
extern void __udelay(unsigned long usecs ) ;
#line 15
extern void __ndelay(unsigned long nsecs ) ;
#line 16
extern void __const_udelay(unsigned long xloops ) ;
#line 17
extern void __delay(unsigned long loops ) ;
#line 29
extern void use_tsc_delay(void) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/delay.h"
extern unsigned long lpj_fine ;
#line 45
extern void calibrate_delay(void) ;
#line 46
extern void msleep(unsigned int msecs ) ;
#line 47
extern unsigned long msleep_interruptible(unsigned int msecs ) ;
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 

  {
  {
#line 51
  msleep(seconds * 1000U);
  }
#line 52
  return;
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm.h"
extern void (*pm_idle)(void) ;
#line 30
extern void (*pm_power_off)(void) ;
#line 31
extern void (*pm_power_off_prepare)(void) ;
#line 383
extern void device_pm_lock(void) ;
#line 384
extern int sysdev_resume(void) ;
#line 385
extern void device_power_up(pm_message_t state ) ;
#line 386
extern void device_resume(pm_message_t state ) ;
#line 388
extern void device_pm_unlock(void) ;
#line 389
extern int sysdev_suspend(pm_message_t state ) ;
#line 390
extern int device_power_down(pm_message_t state ) ;
#line 391
extern int device_suspend(pm_message_t state ) ;
#line 392
extern int device_prepare_suspend(pm_message_t state ) ;
#line 394
extern void __suspend_report_result(char const   *function , void *fn , int ret ) ;
#line 427
extern unsigned int pm_flags ;
#line 4 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/numa_32.h"
extern int pxm_to_nid(int pxm ) ;
#line 5
extern void numa_remove_cpu(int cpu ) ;
#line 8
extern void set_highmem_pages_init(void) ;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/mmu.h"
extern void leave_mm(int cpu ) ;
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
extern int __acpi_acquire_global_lock(unsigned int *lock ) ;
#line 58
extern int __acpi_release_global_lock(unsigned int *lock ) ;
#line 83
extern int acpi_lapic ;
#line 84
extern int acpi_ioapic ;
#line 85
extern int acpi_noirq ;
#line 86
extern int acpi_strict ;
#line 87
extern int acpi_disabled ;
#line 88
extern int acpi_ht ;
#line 89
extern int acpi_pci_disabled ;
#line 90
extern int acpi_skip_timer_override ;
#line 91
extern int acpi_use_timer_override ;
#line 93
extern u8 acpi_sci_flags ;
#line 94
extern int acpi_sci_override_gsi ;
#line 95
extern void acpi_pic_sci_set_trigger(unsigned int  , u16  ) ;
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void disable_acpi(void) 
{ 

  {
  {
#line 99
  acpi_disabled = 1;
#line 100
  acpi_ht = 0;
#line 101
  acpi_pci_disabled = 1;
#line 102
  acpi_noirq = 1;
  }
#line 103
  return;
}
}
#line 105
extern int acpi_gsi_to_irq(u32 gsi , unsigned int *irq ) ;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_noirq_set(void) 
{ 

  {
  {
#line 107
  acpi_noirq = 1;
  }
#line 107
  return;
}
}
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_disable_pci(void) 
{ 

  {
  {
#line 110
  acpi_pci_disabled = 1;
#line 111
  acpi_noirq_set();
  }
#line 112
  return;
}
}
#line 115
extern int acpi_save_state_mem(void) ;
#line 116
extern void acpi_restore_state_mem(void) ;
#line 118
extern unsigned long acpi_wakeup_address ;
#line 121
extern void acpi_reserve_bootmem(void) ;
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static unsigned int acpi_processor_cstate_check(unsigned int max_cstate ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 134
  if ((int )boot_cpu_data.x86 == 15) {
#line 134
    if ((int )boot_cpu_data.x86_vendor == 2) {
#line 134
      if ((int )boot_cpu_data.x86_model <= 5) {
#line 134
        if ((int )boot_cpu_data.x86_mask < 10) {
#line 138
          return (1U);
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    _L___7: /* CIL Label */ 
    _L___6: /* CIL Label */ 
#line 139
    if (117 >> 5 == 0) {
#line 139
      if ((1UL << 21) & (unsigned long )(1 | (1 << 15))) {
        {
#line 139
        tmp___1 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 139
      if (117 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
#line 139
        if (117 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
#line 139
          if (117 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
#line 139
            if (117 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
#line 139
              if (117 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
#line 139
                if (117 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
#line 139
                  if (117 >> 5 == 7) {
                    {
#line 139
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 139
                    tmp___1 = tmp;
                    }
                  } else {
                    {
#line 139
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 139
                    tmp___1 = tmp;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 139
    if (tmp___1) {
#line 140
      return (1U);
    } else {
#line 142
      return (max_cstate);
    }
  }
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/acpi.h"
__inline static void acpi_fake_nodes(struct bootnode  const  *fake_nodes , int num_nodes ) 
{ 

  {
#line 169
  return;
}
}
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
extern unsigned long __FIXADDR_TOP ;
#line 139
extern void reserve_top_address(unsigned long reserve ) ;
#line 146
extern int fixmaps_set ;
#line 148
extern pte_t *kmap_pte ;
#line 149
extern pgprot_t kmap_prot ;
#line 150
extern pte_t *pkmap_page_table ;
#line 152
extern void __native_set_fixmap(enum fixed_addresses idx , pte_t pte ) ;
#line 153
extern void native_set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) ;
#line 157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
__inline static void __set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) 
{ 

  {
  {
#line 160
  native_set_fixmap(idx, phys, flags);
  }
#line 161
  return;
}
}
#line 179
extern void __this_fixmap_does_not_exist(void) ;
#line 186 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
__inline static unsigned long fix_to_virt(unsigned int idx ) 
{ 

  {
#line 197
  if (idx >= 514U) {
    {
#line 198
    __this_fixmap_does_not_exist();
    }
  }
#line 200
  return (__FIXADDR_TOP - (unsigned long )(idx << 12));
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"
__inline static unsigned long virt_to_fix(unsigned long vaddr ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
#line 205
  while (1) {
    while_23_continue: /* CIL Label */ ;
#line 205
    if (vaddr >= __FIXADDR_TOP) {
      {
#line 205
      tmp = 1;
      }
    } else {
#line 205
      if (vaddr < __FIXADDR_TOP - (unsigned long )(176 << 12)) {
        {
#line 205
        tmp = 1;
        }
      } else {
        {
#line 205
        tmp = 0;
        }
      }
    }
    {
#line 205
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
#line 205
    if (tmp___0) {
      {
#line 205
      while (1) {
        while_24_continue: /* CIL Label */ ;
        {
#line 205
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"),
                             "i" (205), "i" (sizeof(struct bug_entry )));
        }
        {
#line 205
        while (1) {
          while_25_continue: /* CIL Label */ ;
        }
        while_25_break: /* CIL Label */ ;
        }
        goto while_24_break;
      }
      while_24_break: /* CIL Label */ ;
      }
    }
    goto while_23_break;
  }
  while_23_break: /* CIL Label */ ;
  }
#line 206
  return ((__FIXADDR_TOP - (vaddr & ~ ((1UL << 12) - 1UL))) >> 12);
}
}
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
extern void generic_apic_probe(void) ;
#line 49
extern unsigned int apic_verbosity ;
#line 50
extern int local_apic_timer_c2_ok ;
#line 52
extern int disable_apic ;
#line 55
extern void __inquire_remote_apic(int apicid ) ;
#line 62 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void default_inquire_remote_apic(int apicid ) 
{ 

  {
#line 64
  if (apic_verbosity >= 2U) {
    {
#line 65
    __inquire_remote_apic(apicid);
    }
  }
#line 66
  return;
}
}
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int is_vsmp_box(void) 
{ 

  {
#line 83
  return (0);
}
}
#line 86
extern void xapic_wait_icr_idle(void) ;
#line 87
extern u32 safe_xapic_wait_icr_idle(void) ;
#line 88
extern void xapic_icr_write(u32  , u32  ) ;
#line 89
extern int setup_profiling_timer(unsigned int  ) ;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void native_apic_mem_write(u32 reg , u32 v ) 
{ u32 volatile   *addr ;
  unsigned long tmp ;

  {
  {
#line 93
  tmp = fix_to_virt(4U);
#line 93
  addr = (u32 volatile   *)(tmp + (unsigned long )reg);
#line 95
  __asm__  volatile   ("661:\n\t"
                       "movl %0, %1"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c[feat]\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "xchgl %0, %1"
                       "\n664:\n"
                       ".previous": "=r" (v), "=m" (*addr): [feat] "i" (115), "0" (v),
                       "m" (*addr));
  }
#line 98
  return;
}
}
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 native_apic_mem_read(u32 reg ) 
{ unsigned long tmp ;

  {
  {
#line 102
  tmp = fix_to_virt(4U);
  }
#line 102
  return ((unsigned int )*((u32 volatile   *)(tmp + (unsigned long )reg)));
}
}
#line 105
extern void native_apic_wait_icr_idle(void) ;
#line 106
extern u32 native_safe_apic_wait_icr_idle(void) ;
#line 107
extern void native_apic_icr_write(u32 low , u32 id ) ;
#line 108
extern u64 native_apic_icr_read(void) ;
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void check_x2apic(void) 
{ 

  {
#line 189
  return;
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void enable_x2apic(void) 
{ 

  {
#line 192
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void enable_IR_x2apic(void) 
{ 

  {
#line 195
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int x2apic_enabled(void) 
{ 

  {
#line 198
  return (0);
}
}
#line 205
extern int get_physical_broadcast(void) ;
#line 215
extern int lapic_get_maxlvt(void) ;
#line 216
extern void clear_local_APIC(void) ;
#line 217
extern void connect_bsp_APIC(void) ;
#line 218
extern void disconnect_bsp_APIC(int virt_wire_setup ) ;
#line 219
extern void disable_local_APIC(void) ;
#line 220
extern void lapic_shutdown(void) ;
#line 221
extern int verify_local_APIC(void) ;
#line 222
extern void cache_APIC_registers(void) ;
#line 223
extern void sync_Arb_IDs(void) ;
#line 224
extern void init_bsp_APIC(void) ;
#line 225
extern void setup_local_APIC(void) ;
#line 226
extern void end_local_APIC_setup(void) ;
#line 227
extern void init_apic_mappings(void) ;
#line 228
extern void setup_boot_APIC_clock(void) ;
#line 229
extern void setup_secondary_APIC_clock(void) ;
#line 230
extern int APIC_init_uniprocessor(void) ;
#line 231
extern void enable_NMI_through_LVT0(void) ;
#line 240 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int apic_is_clustered_box(void) 
{ 

  {
#line 242
  return (0);
}
}
#line 246
extern u8 setup_APIC_eilvt_mce(u8 vector , u8 msg_type , u8 mask ) ;
#line 247
extern u8 setup_APIC_eilvt_ibs(u8 vector , u8 msg_type , u8 mask ) ;
#line 355
extern struct apic *apic ;
#line 361
extern atomic_t init_deasserted ;
#line 362
extern int wakeup_secondary_cpu_via_nmi(int apicid , unsigned long start_eip ) ;
#line 365 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 apic_read(u32 reg ) 
{ u32 tmp ;

  {
  {
#line 367
  tmp = (*(apic->read))(reg);
  }
#line 367
  return (tmp);
}
}
#line 370 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_write(u32 reg , u32 val ) 
{ 

  {
  {
#line 372
  (*(apic->write))(reg, val);
  }
#line 373
  return;
}
}
#line 375 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u64 apic_icr_read(void) 
{ u64 tmp ;

  {
  {
#line 377
  tmp = (*(apic->icr_read))();
  }
#line 377
  return (tmp);
}
}
#line 380 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_icr_write(u32 low , u32 high ) 
{ 

  {
  {
#line 382
  (*(apic->icr_write))(low, high);
  }
#line 383
  return;
}
}
#line 385 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void apic_wait_icr_idle(void) 
{ 

  {
  {
#line 387
  (*(apic->wait_icr_idle))();
  }
#line 388
  return;
}
}
#line 390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static u32 safe_apic_wait_icr_idle(void) 
{ u32 tmp ;

  {
  {
#line 392
  tmp = (*(apic->safe_wait_icr_idle))();
  }
#line 392
  return (tmp);
}
}
#line 396 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void ack_APIC_irq(void) 
{ 

  {
  {
#line 405
  apic_write(176U, 0U);
  }
#line 407
  return;
}
}
#line 409 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int default_get_apic_id(unsigned long x ) 
{ unsigned int ver ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 411
  tmp = apic_read(48U);
#line 411
  ver = tmp & 255U;
  }
#line 413
  if (ver >= 20U) {
#line 414
    return ((unsigned int )((x >> 24) & 255UL));
  } else {
#line 413
    if (122 >> 5 == 0) {
#line 413
      if ((1UL << 26) & (unsigned long )(1 | (1 << 15))) {
        {
#line 413
        tmp___2 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 413
      if (122 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
#line 413
        if (122 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
#line 413
          if (122 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
#line 413
            if (122 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
#line 413
              if (122 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
#line 413
                if (122 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
#line 413
                  if (122 >> 5 == 7) {
                    {
#line 413
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 413
                    tmp___2 = tmp___0;
                    }
                  } else {
                    {
#line 413
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
#line 413
                    tmp___2 = tmp___0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 413
    if (tmp___2) {
#line 414
      return ((unsigned int )((x >> 24) & 255UL));
    } else {
#line 416
      return ((unsigned int )((x >> 24) & 15UL));
    }
  }
}
}
#line 441 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static void default_wait_for_init_deassert(atomic_t *deassert ) 
{ 

  {
  {
#line 443
  while (1) {
    while_26_continue: /* CIL Label */ ;
#line 443
    if (! (! deassert->counter)) {
      goto while_26_break;
    }
    {
#line 444
    cpu_relax();
    }
  }
  while_26_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 448
extern void generic_bigsmp_probe(void) ;
#line 457 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static struct cpumask  const  *default_target_cpus(void) 
{ 

  {
#line 460
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
#line 466
extern u16 per_cpu__x86_bios_cpu_apicid  __attribute__((__section__(".data.percpu"))) ;
#line 466
extern u16 *x86_bios_cpu_apicid_early_ptr ;
#line 466
extern u16 x86_bios_cpu_apicid_early_map[] ;
#line 469 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int read_apic_id(void) 
{ unsigned int reg ;
  unsigned int tmp ;

  {
  {
#line 473
  reg = apic_read(32U);
#line 475
  tmp = (*(apic->get_apic_id))((unsigned long )reg);
  }
#line 475
  return (tmp);
}
}
#line 478
extern void default_setup_apic_routing(void) ;
#line 488
extern void default_init_apic_ldr(void) ;
#line 490 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_apic_id_registered(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 492
  tmp___2 = read_apic_id();
#line 492
  tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
#line 492
  return (tmp___3);
}
}
#line 495 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_phys_pkg_id(int cpuid_apic , int index_msb ) 
{ 

  {
#line 497
  return (cpuid_apic >> index_msb);
}
}
#line 500
extern int default_apicid_to_node(int logical_apicid ) ;
#line 504 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int default_cpu_mask_to_apicid(struct cpumask  const  *cpumask ) 
{ 

  {
#line 507
  return ((unsigned int )(cpumask->bits[0] & 255UL));
}
}
#line 510 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned int default_cpu_mask_to_apicid_and(struct cpumask  const  *cpumask ,
                                                            struct cpumask  const  *andmask ) 
{ unsigned long mask1 ;
  unsigned long mask2 ;
  unsigned long mask3 ;

  {
  {
#line 514
  mask1 = cpumask->bits[0];
#line 515
  mask2 = andmask->bits[0];
#line 516
  mask3 = cpu_online_mask->bits[0];
  }
#line 518
  return ((unsigned int )((mask1 & mask2) & mask3));
}
}
#line 521 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned long default_check_apicid_used(physid_mask_t bitmap , int apicid ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 523
  tmp___0 = variable_test_bit(apicid, (unsigned long const volatile   *)(bitmap.mask));
  }
#line 523
  return ((unsigned long )tmp___0);
}
}
#line 526 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static unsigned long default_check_apicid_present(int bit ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 528
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
#line 528
  return ((unsigned long )tmp___0);
}
}
#line 531 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static physid_mask_t default_ioapic_phys_id_map(physid_mask_t phys_map ) 
{ 

  {
#line 533
  return (phys_map);
}
}
#line 537 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_cpu_to_logical_apicid(int cpu ) 
{ 

  {
#line 539
  return (1 << cpu);
}
}
#line 542 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int __default_cpu_present_to_apicid(int mps_cpu ) 
{ unsigned long __ptr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
#line 544
  if (mps_cpu < nr_cpu_ids) {
    {
#line 544
    tmp___2 = cpumask_check((unsigned int )mps_cpu);
#line 544
    tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(cpu_present_mask->bits));
    }
#line 544
    if (tmp___3) {
      {
#line 545
      __asm__  ("": "=r" (__ptr): "0" (& per_cpu__x86_bios_cpu_apicid));
      }
#line 545
      return ((int )*((u16 *)(__ptr + __per_cpu_offset[mps_cpu])));
    } else {
#line 547
      return (255);
    }
  } else {
#line 547
    return (255);
  }
}
}
#line 550 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int __default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 553
  tmp___0 = variable_test_bit(boot_cpu_physical_apicid___0, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
#line 553
  return (tmp___0);
}
}
#line 557 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_cpu_present_to_apicid(int mps_cpu ) 
{ int tmp ;

  {
  {
#line 559
  tmp = __default_cpu_present_to_apicid(mps_cpu);
  }
#line 559
  return (tmp);
}
}
#line 562 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static int default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;

  {
  {
#line 565
  tmp = __default_check_phys_apicid_present(boot_cpu_physical_apicid___0);
  }
#line 565
  return (tmp);
}
}
#line 572 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/apic.h"
__inline static physid_mask_t default_apicid_to_cpu_present(int phys_apicid ) 
{ physid_mask_t __physid_mask ;

  {
  {
#line 574
  __physid_mask.mask[0] = 0UL;
#line 574
  __physid_mask.mask[1] = 0UL;
#line 574
  __physid_mask.mask[2] = 0UL;
#line 574
  __physid_mask.mask[3] = 0UL;
#line 574
  set_bit((unsigned int )phys_apicid, (unsigned long volatile   *)(__physid_mask.mask));
  }
#line 574
  return (__physid_mask);
}
}
#line 580
extern u8 cpu_2_logical_apicid[8] ;
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_vectors.h"
__inline static int invalid_vm86_irq(int irq ) 
{ int tmp ;

  {
#line 136
  if (irq < 3) {
    {
#line 136
    tmp = 1;
    }
  } else {
#line 136
    if (irq > 15) {
      {
#line 136
      tmp = 1;
      }
    } else {
      {
#line 136
      tmp = 0;
      }
    }
  }
#line 136
  return (tmp);
}
}
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_apic.h"
extern int nr_ioapics ;
#line 115
extern int nr_ioapic_registers[64] ;
#line 120
extern struct mpc_ioapic mp_ioapics[64] ;
#line 123
extern int mp_irq_entries ;
#line 126
extern struct mpc_intsrc mp_irqs[256] ;
#line 132
extern int sis_apic_bug ;
#line 135
extern int skip_ioapic_setup ;
#line 138
extern int noioapicquirk ;
#line 141
extern int noioapicreroute ;
#line 144
extern int timer_through_8259 ;
#line 154
extern int io_apic_get_unique_id(int ioapic , int apic_id ) ;
#line 155
extern int io_apic_get_version(int ioapic ) ;
#line 156
extern int io_apic_get_redir_entries(int ioapic ) ;
#line 157
extern int io_apic_set_pci_routing(int ioapic , int pin , int irq , int edge_level ,
                                   int active_high_low ) ;
#line 161
extern int (*ioapic_renumber_irq)(int ioapic , int irq ) ;
#line 162
extern void ioapic_init_mappings(void) ;
#line 163
extern void ioapic_insert_resources(void) ;
#line 175
extern void probe_nr_irqs_gsi(void) ;
#line 177
extern int setup_ioapic_entry(int apic , int irq , struct IO_APIC_route_entry *entry ,
                              unsigned int destination , int trigger , int polarity ,
                              int vector , int pin ) ;
#line 181
extern void ioapic_write_entry(int apic , int pin , struct IO_APIC_route_entry e ) ;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/cpumask.h"
extern cpumask_var_t cpu_callin_mask ;
#line 7
extern cpumask_var_t cpu_callout_mask ;
#line 8
extern cpumask_var_t cpu_initialized_mask ;
#line 9
extern cpumask_var_t cpu_sibling_setup_mask ;
#line 11
extern void setup_cpu_local_masks(void) ;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
extern int smp_num_siblings ;
#line 22
extern unsigned int num_processors ;
#line 24
extern cpumask_var_t per_cpu__cpu_sibling_map  __attribute__((__section__(".data.percpu"))) ;
#line 25
extern cpumask_var_t per_cpu__cpu_core_map  __attribute__((__section__(".data.percpu"))) ;
#line 26
extern u16 per_cpu__cpu_llc_id  __attribute__((__section__(".data.percpu"))) ;
#line 27
extern int per_cpu__cpu_number  __attribute__((__section__(".data.percpu"))) ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static struct cpumask *cpu_sibling_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 31
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_sibling_map));
  }
#line 31
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static struct cpumask *cpu_core_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 36
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_core_map));
  }
#line 36
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
#line 39
extern u16 per_cpu__x86_cpu_to_apicid  __attribute__((__section__(".data.percpu"))) ;
#line 39
extern u16 *x86_cpu_to_apicid_early_ptr ;
#line 39
extern u16 x86_cpu_to_apicid_early_map[] ;
#line 43
extern struct __anonstruct_stack_start_92 stack_start ;
#line 66
extern void set_cpu_sibling_map(int cpu ) ;
#line 72
extern struct smp_ops smp_ops ;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_send_stop(void) 
{ 

  {
  {
#line 76
  (*(smp_ops.smp_send_stop))();
  }
#line 77
  return;
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_prepare_boot_cpu(void) 
{ 

  {
  {
#line 81
  (*(smp_ops.smp_prepare_boot_cpu))();
  }
#line 82
  return;
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_prepare_cpus(unsigned int max_cpus ) 
{ 

  {
  {
#line 86
  (*(smp_ops.smp_prepare_cpus))(max_cpus);
  }
#line 87
  return;
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_cpus_done(unsigned int max_cpus ) 
{ 

  {
  {
#line 91
  (*(smp_ops.smp_cpus_done))(max_cpus);
  }
#line 92
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int __cpu_up(unsigned int cpu ) 
{ int tmp ;

  {
  {
#line 96
  tmp = (*(smp_ops.cpu_up))(cpu);
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int __cpu_disable(void) 
{ int tmp ;

  {
  {
#line 101
  tmp = (*(smp_ops.cpu_disable))();
  }
#line 101
  return (tmp);
}
}
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void __cpu_die(unsigned int cpu ) 
{ 

  {
  {
#line 106
  (*(smp_ops.cpu_die))(cpu);
  }
#line 107
  return;
}
}
#line 109 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void play_dead(void) 
{ 

  {
  {
#line 111
  (*(smp_ops.play_dead))();
  }
#line 112
  return;
}
}
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void smp_send_reschedule(int cpu ) 
{ 

  {
  {
#line 116
  (*(smp_ops.smp_send_reschedule))(cpu);
  }
#line 117
  return;
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void arch_send_call_function_single_ipi(int cpu ) 
{ 

  {
  {
#line 121
  (*(smp_ops.send_call_func_single_ipi))(cpu);
  }
#line 122
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static void arch_send_call_function_ipi_mask(struct cpumask  const  *mask ) 
{ 

  {
  {
#line 127
  (*(smp_ops.send_call_func_ipi))(mask);
  }
#line 128
  return;
}
}
#line 130
extern void cpu_disable_common(void) ;
#line 131
extern void native_smp_prepare_boot_cpu(void) ;
#line 132
extern void native_smp_prepare_cpus(unsigned int max_cpus ) ;
#line 133
extern void native_smp_cpus_done(unsigned int max_cpus ) ;
#line 134
extern int native_cpu_up(unsigned int cpunum ) ;
#line 135
extern int native_cpu_disable(void) ;
#line 136
extern void native_cpu_die(unsigned int cpu ) ;
#line 137
extern void native_play_dead(void) ;
#line 138
extern void play_dead_common(void) ;
#line 140
extern void native_send_call_func_ipi(struct cpumask  const  *mask ) ;
#line 141
extern void native_send_call_func_single_ipi(int cpu ) ;
#line 143
extern void smp_store_cpu_info(int id ) ;
#line 147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int num_booting_cpus(void) 
{ unsigned int tmp ;

  {
  {
#line 149
  tmp = cpumask_weight((struct cpumask  const  *)(cpu_callout_mask));
  }
#line 149
  return ((int )tmp);
}
}
#line 153
extern unsigned int disabled_cpus  __attribute__((__section__(".cpuinit.data"))) ;
#line 162
extern int safe_smp_processor_id(void) ;
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/smp.h"
__inline static int logical_smp_processor_id(void) 
{ unsigned long tmp ;

  {
  {
#line 183
  tmp = fix_to_virt(4U);
  }
#line 183
  return ((int )((*((u32 *)(tmp + 208UL)) >> 24) & 255U));
}
}
#line 188
extern int hard_smp_processor_id(void) ;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
extern int smp_call_function(void (*func)(void *info ) , void *info , int wait ) ;
#line 73
extern void smp_call_function_many(struct cpumask  const  *mask , void (*func)(void *info ) ,
                                   void *info , bool wait ) ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp.h"
__inline static int smp_call_function_mask(cpumask_t mask , void (*func)(void *info ) ,
                                           void *info , int wait ) 
{ 

  {
  {
#line 81
  smp_call_function_many((struct cpumask  const  *)(& mask), func, info, (_Bool )wait);
  }
#line 82
  return (0);
}
}
#line 85
extern void __smp_call_function_single(int cpuid , struct call_single_data *data ,
                                       int wait ) ;
#line 92
extern void generic_smp_call_function_single_interrupt(void) ;
#line 93
extern void generic_smp_call_function_interrupt(void) ;
#line 94
extern void ipi_call_lock(void) ;
#line 95
extern void ipi_call_unlock(void) ;
#line 96
extern void ipi_call_lock_irq(void) ;
#line 97
extern void ipi_call_unlock_irq(void) ;
#line 103
extern int on_each_cpu(void (*func)(void *info ) , void *info , int wait ) ;
#line 121
extern unsigned int setup_max_cpus ;
#line 186
extern void arch_disable_smp_support(void) ;
#line 188
extern void smp_setup_processor_id(void) ;
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int numa_node_id(void) 
{ 

  {
#line 162
  return (0);
}
}
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int cpu_to_node(int cpu ) 
{ 

  {
#line 167
  return (0);
}
}
#line 170 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int early_cpu_to_node(int cpu ) 
{ 

  {
#line 172
  return (0);
}
}
#line 175 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static struct cpumask  const  *cpumask_of_node(int node ) 
{ 

  {
#line 177
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static void setup_node_to_cpumask_map(void) 
{ 

  {
#line 180
  return;
}
}
#line 186
extern struct cpumask  const  *cpu_coregroup_mask(int cpu ) ;
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static void arch_fix_phys_package_id(int num , u32 slot ) 
{ 

  {
#line 200
  return;
}
}
#line 203
extern void x86_pci_root_bus_res_quirks(struct pci_bus *b ) ;
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static int get_mp_bus_to_node(int busnum ) 
{ 

  {
#line 216
  return (0);
}
}
#line 218 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/topology.h"
__inline static void set_mp_bus_to_node(int busnum , int node ) 
{ 

  {
#line 220
  return;
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/topology.h"
extern int arch_update_cpu_topology(void) ;
#line 103 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static int allocflags_to_migratetype(gfp_t gfp_flags ) 
{ int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 105
  __ret_warn_on = ! (! ((gfp_flags & 1572864U) == 1572864U));
#line 105
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 105
  if (tmp) {
    {
#line 105
    warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h",
                       105);
    }
  }
  {
#line 105
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 107
  tmp___0 = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
#line 107
  if (tmp___0) {
#line 108
    return (0);
  }
#line 111
  return ((((gfp_flags & 1048576U) != 0U) << 1) | ((gfp_flags & 524288U) != 0U));
}
}
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static enum zone_type gfp_zone(gfp_t flags ) 
{ 

  {
#line 118
  if (flags & 1U) {
#line 119
    return ((enum zone_type )0);
  }
#line 125
  if ((flags & 1048578U) == 1048578U) {
#line 127
    return ((enum zone_type )3);
  }
#line 129
  if (flags & 2U) {
#line 130
    return ((enum zone_type )2);
  }
#line 132
  return ((enum zone_type )1);
}
}
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ long tmp ;

  {
#line 147
  return (0);
}
}
#line 159 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ int tmp ;

  {
  {
#line 161
  tmp = gfp_zonelist(flags);
  }
#line 161
  return (contig_page_data.node_zonelists + tmp);
}
}
#line 165 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static void arch_free_page(struct page *page , int order ) 
{ 

  {
#line 165
  return;
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static void arch_alloc_page(struct page *page , int order ) 
{ 

  {
#line 168
  return;
}
}
#line 171
extern struct page *__alloc_pages_internal(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ,
                                           nodemask_t *nodemask ) ;
#line 175 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ struct page *tmp ;

  {
  {
#line 179
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, (nodemask_t *)((void *)0));
  }
#line 179
  return (tmp);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct page *__alloc_pages_nodemask(gfp_t gfp_mask , unsigned int order ,
                                                    struct zonelist *zonelist , nodemask_t *nodemask ) 
{ struct page *tmp ;

  {
  {
#line 186
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, nodemask);
  }
#line 186
  return (tmp);
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ long tmp ;
  int ret__ ;
  struct zonelist *tmp___0 ;
  struct page *tmp___1 ;

  {
  {
#line 193
  tmp = __builtin_expect((long )(! (! (order >= 11U))), 0L);
  }
#line 193
  if (tmp) {
#line 194
    return ((struct page *)((void *)0));
  }
#line 197
  if (nid < 0) {
#line 198
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_27_1;
    } else {
#line 198
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_27_2;
      } else {
#line 198
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_27_4;
        } else {
#line 198
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_27_8;
          } else {
            {
            goto switch_27_default;
#line 198
            if (0) {
              switch_27_1: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_27_break;
              switch_27_2: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_27_break;
              switch_27_4: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_27_break;
              switch_27_8: /* CIL Label */ 
              {
#line 198
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_27_break;
              switch_27_default: /* CIL Label */ 
              {
#line 198
              __bad_percpu_size();
              }
            } else {
              switch_27_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 198
    nid = 0;
    }
  }
  {
#line 200
  tmp___0 = node_zonelist(nid, gfp_mask);
#line 200
  tmp___1 = __alloc_pages(gfp_mask, order, tmp___0);
  }
#line 200
  return (tmp___1);
}
}
#line 223
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 224
extern unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 226
extern void *alloc_pages_exact(size_t size , gfp_t gfp_mask ) ;
#line 227
extern void free_pages_exact(void *virt , size_t size ) ;
#line 235
extern void __free_pages(struct page *page , unsigned int order ) ;
#line 236
extern void free_pages(unsigned long addr , unsigned int order ) ;
#line 237
extern void free_hot_page(struct page *page ) ;
#line 238
extern void free_cold_page(struct page *page ) ;
#line 243
extern void page_alloc_init(void) ;
#line 244
extern void drain_zone_pages(struct zone *zone , struct per_cpu_pages *pcp ) ;
#line 245
extern void drain_all_pages(void) ;
#line 246
extern void drain_local_pages(void *dummy ) ;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
extern int ( /* format attribute */  __request_module)(bool wait , char const   *name 
                                                       , ...) ;
#line 50
extern struct subprocess_info *call_usermodehelper_setup(char *path , char **argv ,
                                                         char **envp , gfp_t gfp_mask ) ;
#line 54
extern void call_usermodehelper_setkeys(struct subprocess_info *info , struct key *session_keyring ) ;
#line 56
extern int call_usermodehelper_stdinpipe(struct subprocess_info *sub_info , struct file **filp ) ;
#line 58
extern void call_usermodehelper_setcleanup(struct subprocess_info *info , void (*cleanup)(char **argv ,
                                                                                          char **envp ) ) ;
#line 68
extern int call_usermodehelper_exec(struct subprocess_info *info , enum umh_wait wait ) ;
#line 72
extern void call_usermodehelper_freeinfo(struct subprocess_info *info ) ;
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
__inline static int call_usermodehelper(char *path , char **argv , char **envp , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 78
  if ((int )wait == -1) {
    {
#line 78
    tmp = 32U;
    }
  } else {
    {
#line 78
    tmp = 208U;
    }
  }
  {
#line 78
  gfp_mask = tmp;
#line 80
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
#line 81
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 82
    return (-12);
  }
  {
#line 83
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
#line 83
  return (tmp___0);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kmod.h"
__inline static int call_usermodehelper_keys(char *path , char **argv , char **envp ,
                                             struct key *session_keyring , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 91
  if ((int )wait == -1) {
    {
#line 91
    tmp = 32U;
    }
  } else {
    {
#line 91
    tmp = 208U;
    }
  }
  {
#line 91
  gfp_mask = tmp;
#line 93
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
#line 94
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 95
    return (-12);
  }
  {
#line 97
  call_usermodehelper_setkeys(info, session_keyring);
#line 98
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
#line 98
  return (tmp___0);
}
}
#line 101
extern void usermodehelper_init(void) ;
#line 104
extern int call_usermodehelper_pipe(char *path , char **argv , char **envp , struct file **filp ) ;
#line 107
extern int usermodehelper_disable(void) ;
#line 108
extern void usermodehelper_enable(void) ;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/vdso.h"
extern char const   VDSO32_PRELINK[] ;
#line 36
extern void __kernel_sigreturn ;
#line 37
extern void __kernel_rt_sigreturn ;
#line 43
extern char const   vdso32_int80_start ;
#line 43
extern char const   vdso32_int80_end ;
#line 44
extern char const   vdso32_syscall_start ;
#line 44
extern char const   vdso32_syscall_end ;
#line 45
extern char const   vdso32_sysenter_start ;
#line 45
extern char const   vdso32_sysenter_end ;
#line 77 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
extern unsigned int vdso_enabled ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void fill_ldt(struct desc_struct *desc , struct user_desc  const  *info ) 
{ 

  {
  {
#line 13
  desc->__annonCompField8.__annonCompField6.limit0 = (unsigned short )(info->limit & 65535U);
#line 14
  desc->__annonCompField8.__annonCompField6.base0 = (unsigned short )(info->base_addr & 65535U);
#line 16
  desc->__annonCompField8.__annonCompField6.base1 = (unsigned int )((info->base_addr & 16711680U) >> 16);
#line 17
  desc->__annonCompField8.__annonCompField6.type = (unsigned int )((info->read_exec_only ^ 1U) << 1);
#line 18
  desc->__annonCompField8.__annonCompField6.type |= (unsigned int )(info->contents << 2);
#line 19
  desc->__annonCompField8.__annonCompField6.s = 1U;
#line 20
  desc->__annonCompField8.__annonCompField6.dpl = 3U;
#line 21
  desc->__annonCompField8.__annonCompField6.p = (unsigned int )(info->seg_not_present ^ 1U);
#line 22
  desc->__annonCompField8.__annonCompField6.limit = (unsigned int )((info->limit & 983040U) >> 16);
#line 23
  desc->__annonCompField8.__annonCompField6.avl = (unsigned int )info->useable;
#line 24
  desc->__annonCompField8.__annonCompField6.d = (unsigned int )info->seg_32bit;
#line 25
  desc->__annonCompField8.__annonCompField6.g = (unsigned int )info->limit_in_pages;
#line 26
  desc->__annonCompField8.__annonCompField6.base2 = (unsigned int )((info->base_addr & 4278190080U) >> 24);
#line 31
  desc->__annonCompField8.__annonCompField6.l = 0U;
  }
#line 32
  return;
}
}
#line 34
extern struct desc_ptr idt_descr ;
#line 35
extern gate_desc idt_table[] ;
#line 40
extern struct gdt_page per_cpu__gdt_page  __attribute__((__section__(".data.percpu.page_aligned"))) ;
#line 42 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static struct desc_struct *get_cpu_gdt_table(unsigned int cpu ) 
{ unsigned long __ptr ;

  {
  {
#line 44
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__gdt_page));
  }
#line 44
  return (((struct gdt_page *)(__ptr + __per_cpu_offset[cpu]))->gdt);
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void pack_gate(gate_desc *gate , unsigned char type , unsigned long base ,
                               unsigned int dpl , unsigned int flags , unsigned short seg ) 
{ 

  {
  {
#line 69
  gate->__annonCompField8.__annonCompField7.a = (unsigned int )((unsigned long )((int )seg << 16) | (base & 65535UL));
#line 70
  gate->__annonCompField8.__annonCompField7.b = (unsigned int )((base & 4294901760UL) | (unsigned long )((((unsigned int )(128 | (int )type) | (dpl << 5)) & 255U) << 8));
  }
#line 72
  return;
}
}
#line 76 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static int desc_empty(void const   *ptr ) 
{ u32 const   *desc ;

  {
  {
#line 78
  desc = (u32 const   *)ptr;
  }
#line 79
  return (! (*(desc + 0) | *(desc + 1)));
}
}
#line 105 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void paravirt_alloc_ldt(struct desc_struct *ldt , unsigned int entries ) 
{ 

  {
#line 107
  return;
}
}
#line 109 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void paravirt_free_ldt(struct desc_struct *ldt , unsigned int entries ) 
{ 

  {
#line 111
  return;
}
}
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_write_idt_entry(gate_desc *idt , int entry , gate_desc const   *gate ) 
{ 

  {
  {
#line 119
  __constant_memcpy((void *)(idt + entry), (void const   *)gate, (unsigned int )sizeof(*gate));
  }
#line 120
  return;
}
}
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_write_ldt_entry(struct desc_struct *ldt , int entry ,
                                            void const   *desc ) 
{ 

  {
  {
#line 125
  __constant_memcpy((void *)(ldt + entry), desc, 8U);
  }
#line 126
  return;
}
}
#line 128 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_write_gdt_entry(struct desc_struct *gdt , int entry ,
                                            void const   *desc , int type ) 
{ unsigned int size ;

  {
#line 133
  if (type == 9) {
    goto switch_28_9;
  } else {
#line 136
    if (type == 2) {
      goto switch_28_2;
    } else {
      {
      goto switch_28_default;
#line 132
      if (0) {
        switch_28_9: /* CIL Label */ 
        {
#line 134
        size = (unsigned int )sizeof(tss_desc );
        }
        goto switch_28_break;
        switch_28_2: /* CIL Label */ 
        {
#line 137
        size = (unsigned int )sizeof(ldt_desc );
        }
        goto switch_28_break;
        switch_28_default: /* CIL Label */ 
        {
#line 140
        size = (unsigned int )sizeof(struct desc_struct );
        }
        goto switch_28_break;
      } else {
        switch_28_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
#line 143
  __memcpy((void *)(gdt + entry), desc, size);
  }
#line 144
  return;
}
}
#line 146 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void pack_descriptor(struct desc_struct *desc , unsigned long base ,
                                     unsigned long limit , unsigned char type , unsigned char flags ) 
{ 

  {
  {
#line 150
  desc->__annonCompField8.__annonCompField7.a = (unsigned int )(((base & 65535UL) << 16) | (limit & 65535UL));
#line 151
  desc->__annonCompField8.__annonCompField7.b = (unsigned int )(((((base & 4278190080UL) | ((base & 16711680UL) >> 16)) | (limit & 983040UL)) | (unsigned long )(((int )type & 255) << 8)) | (unsigned long )(((int )flags & 15) << 20));
#line 154
  desc->__annonCompField8.__annonCompField6.p = 1U;
  }
#line 155
  return;
}
}
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_tssldt_descriptor(void *d , unsigned long addr , unsigned int type ,
                                           unsigned int size ) 
{ 

  {
  {
#line 173
  pack_descriptor((struct desc_struct *)d, addr, (unsigned long )size, (unsigned char )(128U | type),
                  (unsigned char)0);
  }
#line 175
  return;
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void __set_tss_desc(unsigned int cpu , unsigned int entry , void *addr ) 
{ struct desc_struct *d ;
  struct desc_struct *tmp ;
  tss_desc tss ;

  {
  {
#line 179
  tmp = get_cpu_gdt_table(cpu);
#line 179
  d = tmp;
#line 189
  set_tssldt_descriptor((void *)(& tss), (unsigned long )addr, 9U, (unsigned int )(((unsigned long )((unsigned int )(& ((struct tss_struct *)0)->io_bitmap) + 8192U) + sizeof(unsigned long )) - 1UL));
#line 192
  native_write_gdt_entry(d, (int )entry, (void const   *)(& tss), 9);
  }
#line 193
  return;
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_set_ldt(void const   *addr , unsigned int entries ) 
{ unsigned int cpu ;
  int ret__ ;
  ldt_desc ldt ;
  struct desc_struct *tmp ;
  long tmp___0 ;

  {
  {
#line 199
  tmp___0 = __builtin_expect((long )(! (! (entries == 0U))), 1L);
  }
#line 199
  if (tmp___0) {
    {
#line 200
    __asm__  volatile   ("lldt %w0": : "q" (0));
    }
  } else {
#line 202
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_29_1;
    } else {
#line 202
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_29_2;
      } else {
#line 202
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_29_4;
        } else {
#line 202
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_29_8;
          } else {
            {
            goto switch_29_default;
#line 202
            if (0) {
              switch_29_1: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_29_break;
              switch_29_2: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_29_break;
              switch_29_4: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_29_break;
              switch_29_8: /* CIL Label */ 
              {
#line 202
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_29_break;
              switch_29_default: /* CIL Label */ 
              {
#line 202
              __bad_percpu_size();
              }
            } else {
              switch_29_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 202
    cpu = (unsigned int )ret__;
#line 205
    set_tssldt_descriptor((void *)(& ldt), (unsigned long )addr, 2U, entries * 8U - 1U);
#line 207
    tmp = get_cpu_gdt_table(cpu);
#line 207
    native_write_gdt_entry(tmp, 17, (void const   *)(& ldt), 2);
#line 209
    __asm__  volatile   ("lldt %w0": : "q" (136));
    }
  }
#line 211
  return;
}
}
#line 213 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_tr_desc(void) 
{ 

  {
  {
#line 215
  __asm__  volatile   ("ltr %w0": : "q" (128));
  }
#line 216
  return;
}
}
#line 218 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_gdt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
#line 220
  __asm__  volatile   ("lgdt %0": : "m" (*dtr));
  }
#line 221
  return;
}
}
#line 223 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_idt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
#line 225
  __asm__  volatile   ("lidt %0": : "m" (*dtr));
  }
#line 226
  return;
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_store_gdt(struct desc_ptr *dtr ) 
{ 

  {
  {
#line 230
  __asm__  volatile   ("sgdt %0": "=m" (*dtr));
  }
#line 231
  return;
}
}
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_store_idt(struct desc_ptr *dtr ) 
{ 

  {
  {
#line 235
  __asm__  volatile   ("sidt %0": "=m" (*dtr));
  }
#line 236
  return;
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static unsigned long native_store_tr(void) 
{ unsigned long tr ;

  {
  {
#line 241
  __asm__  volatile   ("str %0": "=r" (tr));
  }
#line 242
  return (tr);
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void native_load_tls(struct thread_struct *t , unsigned int cpu ) 
{ unsigned int i ;
  struct desc_struct *gdt ;
  struct desc_struct *tmp ;

  {
  {
#line 248
  tmp = get_cpu_gdt_table(cpu);
#line 248
  gdt = tmp;
#line 250
  i = 0U;
  }
  {
#line 250
  while (1) {
    while_30_continue: /* CIL Label */ ;
#line 250
    if (! (i < 3U)) {
      goto while_30_break;
    }
    {
#line 251
    *(gdt + (6U + i)) = t->tls_array[i];
#line 250
    i ++;
    }
  }
  while_30_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 270 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void clear_LDT(void) 
{ 

  {
  {
#line 272
  native_set_ldt((void const   *)((void *)0), 0U);
  }
#line 273
  return;
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void load_LDT_nolock(mm_context_t *pc ) 
{ 

  {
  {
#line 280
  native_set_ldt((void const   *)pc->ldt, (unsigned int )pc->size);
  }
#line 281
  return;
}
}
#line 283 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void load_LDT(mm_context_t *pc ) 
{ 

  {
  {
#line 285
  while (1) {
    while_31_continue: /* CIL Label */ ;
    goto while_31_break;
  }
  while_31_break: /* CIL Label */ ;
  }
  {
#line 286
  load_LDT_nolock(pc);
  }
  {
#line 287
  while (1) {
    while_32_continue: /* CIL Label */ ;
    goto while_32_break;
  }
  while_32_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 290 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static unsigned long get_desc_base(struct desc_struct  const  *desc ) 
{ 

  {
#line 292
  return ((unsigned long )(((unsigned int const   )desc->__annonCompField8.__annonCompField6.base0 | (desc->__annonCompField8.__annonCompField6.base1 << 16)) | (desc->__annonCompField8.__annonCompField6.base2 << 24)));
}
}
#line 295 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static unsigned long get_desc_limit(struct desc_struct  const  *desc ) 
{ 

  {
#line 297
  return ((unsigned long )((unsigned int const   )desc->__annonCompField8.__annonCompField6.limit0 | (desc->__annonCompField8.__annonCompField6.limit << 16)));
}
}
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void _set_gate(int gate , unsigned int type , void *addr , unsigned int dpl ,
                               unsigned int ist , unsigned int seg ) 
{ gate_desc s ;

  {
  {
#line 304
  pack_gate(& s, (unsigned char )type, (unsigned long )addr, dpl, ist, (unsigned short )seg);
#line 309
  native_write_idt_entry(idt_table, gate, (gate_desc const   *)(& s));
  }
#line 310
  return;
}
}
#line 318 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 320
  while (1) {
    while_33_continue: /* CIL Label */ ;
    {
#line 320
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 320
    if (tmp) {
      {
#line 320
      while (1) {
        while_34_continue: /* CIL Label */ ;
        {
#line 320
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (320), "i" (sizeof(struct bug_entry )));
        }
        {
#line 320
        while (1) {
          while_35_continue: /* CIL Label */ ;
        }
        while_35_break: /* CIL Label */ ;
        }
        goto while_34_break;
      }
      while_34_break: /* CIL Label */ ;
      }
    }
    goto while_33_break;
  }
  while_33_break: /* CIL Label */ ;
  }
  {
#line 321
  _set_gate((int )n, 14U, addr, 0U, 0U, 96U);
  }
#line 322
  return;
}
}
#line 324
extern int first_system_vector ;
#line 326
extern unsigned long used_vectors[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
#line 328 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void alloc_system_vector(int vector ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 330
  tmp___0 = variable_test_bit(vector, (unsigned long const volatile   *)(used_vectors));
  }
#line 330
  if (tmp___0) {
    {
#line 335
    while (1) {
      while_36_continue: /* CIL Label */ ;
      {
#line 335
      __asm__  volatile   ("1:\tud2\n"
                           ".pushsection __bug_table,\"a\"\n"
                           "2:\t.long 1b, %c0\n"
                           "\t.word %c1, 0\n"
                           "\t.org 2b+%c2\n"
                           ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                           "i" (335), "i" (sizeof(struct bug_entry )));
      }
      {
#line 335
      while (1) {
        while_37_continue: /* CIL Label */ ;
      }
      while_37_break: /* CIL Label */ ;
      }
      goto while_36_break;
    }
    while_36_break: /* CIL Label */ ;
    }
  } else {
    {
#line 331
    set_bit((unsigned int )vector, (unsigned long volatile   *)(used_vectors));
    }
#line 332
    if (first_system_vector > vector) {
      {
#line 333
      first_system_vector = vector;
      }
    }
  }
#line 336
  return;
}
}
#line 338 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void alloc_intr_gate(unsigned int n , void *addr ) 
{ 

  {
  {
#line 340
  alloc_system_vector((int )n);
#line 341
  set_intr_gate(n, addr);
  }
#line 342
  return;
}
}
#line 347 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_system_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 349
  while (1) {
    while_38_continue: /* CIL Label */ ;
    {
#line 349
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 349
    if (tmp) {
      {
#line 349
      while (1) {
        while_39_continue: /* CIL Label */ ;
        {
#line 349
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (349), "i" (sizeof(struct bug_entry )));
        }
        {
#line 349
        while (1) {
          while_40_continue: /* CIL Label */ ;
        }
        while_40_break: /* CIL Label */ ;
        }
        goto while_39_break;
      }
      while_39_break: /* CIL Label */ ;
      }
    }
    goto while_38_break;
  }
  while_38_break: /* CIL Label */ ;
  }
  {
#line 350
  _set_gate((int )n, 14U, addr, 3U, 0U, 96U);
  }
#line 351
  return;
}
}
#line 353 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_system_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 355
  while (1) {
    while_41_continue: /* CIL Label */ ;
    {
#line 355
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 355
    if (tmp) {
      {
#line 355
      while (1) {
        while_42_continue: /* CIL Label */ ;
        {
#line 355
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (355), "i" (sizeof(struct bug_entry )));
        }
        {
#line 355
        while (1) {
          while_43_continue: /* CIL Label */ ;
        }
        while_43_break: /* CIL Label */ ;
        }
        goto while_42_break;
      }
      while_42_break: /* CIL Label */ ;
      }
    }
    goto while_41_break;
  }
  while_41_break: /* CIL Label */ ;
  }
  {
#line 356
  _set_gate((int )n, 15U, addr, 3U, 0U, 96U);
  }
#line 357
  return;
}
}
#line 359 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
#line 361
  while (1) {
    while_44_continue: /* CIL Label */ ;
    {
#line 361
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 361
    if (tmp) {
      {
#line 361
      while (1) {
        while_45_continue: /* CIL Label */ ;
        {
#line 361
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (361), "i" (sizeof(struct bug_entry )));
        }
        {
#line 361
        while (1) {
          while_46_continue: /* CIL Label */ ;
        }
        while_46_break: /* CIL Label */ ;
        }
        goto while_45_break;
      }
      while_45_break: /* CIL Label */ ;
      }
    }
    goto while_44_break;
  }
  while_44_break: /* CIL Label */ ;
  }
  {
#line 362
  _set_gate((int )n, 15U, addr, 0U, 0U, 96U);
  }
#line 363
  return;
}
}
#line 365 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_task_gate(unsigned int n , unsigned int gdt_entry ) 
{ long tmp ;

  {
  {
#line 367
  while (1) {
    while_47_continue: /* CIL Label */ ;
    {
#line 367
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
#line 367
    if (tmp) {
      {
#line 367
      while (1) {
        while_48_continue: /* CIL Label */ ;
        {
#line 367
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (367), "i" (sizeof(struct bug_entry )));
        }
        {
#line 367
        while (1) {
          while_49_continue: /* CIL Label */ ;
        }
        while_49_break: /* CIL Label */ ;
        }
        goto while_48_break;
      }
      while_48_break: /* CIL Label */ ;
      }
    }
    goto while_47_break;
  }
  while_47_break: /* CIL Label */ ;
  }
  {
#line 368
  _set_gate((int )n, 5U, (void *)0, 0U, 0U, gdt_entry << 3);
  }
#line 369
  return;
}
}
#line 371 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
#line 373
  while (1) {
    while_50_continue: /* CIL Label */ ;
    {
#line 373
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
#line 373
    if (tmp) {
      {
#line 373
      while (1) {
        while_51_continue: /* CIL Label */ ;
        {
#line 373
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (373), "i" (sizeof(struct bug_entry )));
        }
        {
#line 373
        while (1) {
          while_52_continue: /* CIL Label */ ;
        }
        while_52_break: /* CIL Label */ ;
        }
        goto while_51_break;
      }
      while_51_break: /* CIL Label */ ;
      }
    }
    goto while_50_break;
  }
  while_50_break: /* CIL Label */ ;
  }
  {
#line 374
  _set_gate(n, 14U, addr, 0U, ist, 96U);
  }
#line 375
  return;
}
}
#line 377 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"
__inline static void set_system_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
#line 379
  while (1) {
    while_53_continue: /* CIL Label */ ;
    {
#line 379
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
#line 379
    if (tmp) {
      {
#line 379
      while (1) {
        while_54_continue: /* CIL Label */ ;
        {
#line 379
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (379), "i" (sizeof(struct bug_entry )));
        }
        {
#line 379
        while (1) {
          while_55_continue: /* CIL Label */ ;
        }
        while_55_break: /* CIL Label */ ;
        }
        goto while_54_break;
      }
      while_54_break: /* CIL Label */ ;
      }
    }
    goto while_53_break;
  }
  while_53_break: /* CIL Label */ ;
  }
  {
#line 380
  _set_gate(n, 14U, addr, 3U, ist, 96U);
  }
#line 381
  return;
}
}
#line 338 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/elf.h"
extern int arch_setup_additional_pages(struct linux_binprm *bprm , int uses_interp ) ;
#line 341
extern int syscall32_setup_pages(struct linux_binprm * , int exstack ) ;
#line 344
extern unsigned long arch_randomize_brk(struct mm_struct *mm ) ;
#line 391 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
extern Elf64_Dyn _DYNAMIC[] ;
#line 401 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
__inline static int elf_coredump_extra_notes_size(void) 
{ 

  {
#line 401
  return (0);
}
}
#line 402 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/elf.h"
__inline static int elf_coredump_extra_notes_write(struct file *file , loff_t *foffset ) 
{ 

  {
#line 403
  return (0);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysfs.h"
extern int sysfs_schedule_callback(struct kobject *kobj , void (*func)(void * ) ,
                                   void *data , struct module *owner ) ;
#line 89
extern int sysfs_create_dir(struct kobject *kobj ) ;
#line 90
extern void sysfs_remove_dir(struct kobject *kobj ) ;
#line 91
extern int sysfs_rename_dir(struct kobject *kobj , char const   *new_name ) ;
#line 92
extern int sysfs_move_dir(struct kobject *kobj , struct kobject *new_parent_kobj ) ;
#line 95
extern int sysfs_create_file(struct kobject *kobj , struct attribute  const  *attr ) ;
#line 97
extern int sysfs_chmod_file(struct kobject *kobj , struct attribute *attr , mode_t mode ) ;
#line 99
extern void sysfs_remove_file(struct kobject *kobj , struct attribute  const  *attr ) ;
#line 101
extern int sysfs_create_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
#line 103
extern void sysfs_remove_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
#line 105
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char const   *name ) ;
#line 107
extern int sysfs_create_link_nowarn(struct kobject *kobj , struct kobject *target ,
                                    char const   *name ) ;
#line 110
extern void sysfs_remove_link(struct kobject *kobj , char const   *name ) ;
#line 112
extern int sysfs_create_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 114
extern int sysfs_update_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 116
extern void sysfs_remove_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
#line 118
extern int sysfs_add_file_to_group(struct kobject *kobj , struct attribute  const  *attr ,
                                   char const   *group ) ;
#line 120
extern void sysfs_remove_file_from_group(struct kobject *kobj , struct attribute  const  *attr ,
                                         char const   *group ) ;
#line 123
extern void sysfs_notify(struct kobject *kobj , char const   *dir , char const   *attr ) ;
#line 124
extern void sysfs_notify_dirent(struct sysfs_dirent *sd ) ;
#line 125
extern struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd , unsigned char const   *name ) ;
#line 127
extern struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd ) ;
#line 128
extern void sysfs_put(struct sysfs_dirent *sd ) ;
#line 129
extern void sysfs_printk_last_file(void) ;
#line 130
extern int sysfs_init(void) ;
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kref.h"
extern void kref_set(struct kref *kref , int num ) ;
#line 26
extern void kref_init(struct kref *kref ) ;
#line 27
extern void kref_get(struct kref *kref ) ;
#line 28
extern int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) ;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
extern char uevent_helper[] ;
#line 37
extern u64 uevent_seqnum ;
#line 74
extern int ( /* format attribute */  kobject_set_name)(struct kobject *kobj , char const   *name 
                                                       , ...) ;
#line 76
extern int kobject_set_name_vargs(struct kobject *kobj , char const   *fmt , va_list vargs ) ;
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 

  {
#line 81
  return ((char const   *)kobj->name);
}
}
#line 84
extern void kobject_init(struct kobject *kobj , struct kobj_type *ktype ) ;
#line 85
extern int kobject_add(struct kobject *kobj , struct kobject *parent , char const   *fmt 
                       , ...) ;
#line 88
extern int kobject_init_and_add(struct kobject *kobj , struct kobj_type *ktype , struct kobject *parent ,
                                char const   *fmt  , ...) ;
#line 93
extern void kobject_del(struct kobject *kobj ) ;
#line 95
extern struct kobject *kobject_create(void) ;
#line 96
extern struct kobject *kobject_create_and_add(char const   *name , struct kobject *parent ) ;
#line 99
extern int kobject_rename(struct kobject * , char const   *new_name ) ;
#line 100
extern int kobject_move(struct kobject * , struct kobject * ) ;
#line 102
extern struct kobject *kobject_get(struct kobject *kobj ) ;
#line 103
extern void kobject_put(struct kobject *kobj ) ;
#line 105
extern char *kobject_get_path(struct kobject *kobj , gfp_t flag ) ;
#line 135
extern struct sysfs_ops kobj_sysfs_ops ;
#line 161
extern void kset_init(struct kset *kset ) ;
#line 162
extern int kset_register(struct kset *kset ) ;
#line 163
extern void kset_unregister(struct kset *kset ) ;
#line 164
extern struct kset *kset_create_and_add(char const   *name , struct kset_uevent_ops *u ,
                                        struct kobject *parent_kobj ) ;
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static struct kset *to_kset(struct kobject *kobj ) 
{ struct kobject  const  *__mptr ;
  struct kset *tmp ;

  {
#line 170
  if (kobj) {
    {
#line 170
    __mptr = (struct kobject  const  *)kobj;
#line 170
    tmp = (struct kset *)((char *)__mptr - (unsigned int )(& ((struct kset *)0)->kobj));
    }
  } else {
    {
#line 170
    tmp = (struct kset *)((void *)0);
    }
  }
#line 170
  return (tmp);
}
}
#line 173 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static struct kset *kset_get(struct kset *k ) 
{ struct kobject *tmp ;
  struct kset *tmp___0 ;
  struct kset *tmp___1 ;

  {
#line 175
  if (k) {
    {
#line 175
    tmp = kobject_get(& k->kobj);
#line 175
    tmp___0 = to_kset(tmp);
#line 175
    tmp___1 = tmp___0;
    }
  } else {
    {
#line 175
    tmp___1 = (struct kset *)((void *)0);
    }
  }
#line 175
  return (tmp___1);
}
}
#line 178 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static void kset_put(struct kset *k ) 
{ 

  {
  {
#line 180
  kobject_put(& k->kobj);
  }
#line 181
  return;
}
}
#line 183 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kobject.h"
__inline static struct kobj_type *get_ktype(struct kobject *kobj ) 
{ 

  {
#line 185
  return (kobj->ktype);
}
}
#line 188
extern struct kobject *kset_find_obj(struct kset * , char const   * ) ;
#line 191
extern struct kobject *kernel_kobj ;
#line 193
extern struct kobject *mm_kobj ;
#line 195
extern struct kobject *hypervisor_kobj ;
#line 197
extern struct kobject *power_kobj ;
#line 199
extern struct kobject *firmware_kobj ;
#line 202
extern int kobject_uevent(struct kobject *kobj , enum kobject_action action ) ;
#line 203
extern int kobject_uevent_env(struct kobject *kobj , enum kobject_action action ,
                              char **envp ) ;
#line 206
extern int ( /* format attribute */  add_uevent_var)(struct kobj_uevent_env *env ,
                                                     char const   *format  , ...) ;
#line 209
extern int kobject_action_type(char const   *buf , size_t count , enum kobject_action *type ) ;
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/moduleparam.h"
extern int parse_args(char const   *name , char *args , struct kernel_param *params ,
                      unsigned int num , int (*unknown)(char *param , char *val ) ) ;
#line 143
extern void destroy_params(struct kernel_param  const  *params , unsigned int num ) ;
#line 157
extern int param_set_byte(char const   *val , struct kernel_param *kp ) ;
#line 158
extern int param_get_byte(char *buffer , struct kernel_param *kp ) ;
#line 161
extern int param_set_short(char const   *val , struct kernel_param *kp ) ;
#line 162
extern int param_get_short(char *buffer , struct kernel_param *kp ) ;
#line 165
extern int param_set_ushort(char const   *val , struct kernel_param *kp ) ;
#line 166
extern int param_get_ushort(char *buffer , struct kernel_param *kp ) ;
#line 169
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
#line 170
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
#line 173
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
#line 174
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
#line 177
extern int param_set_long(char const   *val , struct kernel_param *kp ) ;
#line 178
extern int param_get_long(char *buffer , struct kernel_param *kp ) ;
#line 181
extern int param_set_ulong(char const   *val , struct kernel_param *kp ) ;
#line 182
extern int param_get_ulong(char *buffer , struct kernel_param *kp ) ;
#line 185
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
#line 186
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
#line 189
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
#line 190
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
#line 193
extern int param_set_invbool(char const   *val , struct kernel_param *kp ) ;
#line 194
extern int param_get_invbool(char *buffer , struct kernel_param *kp ) ;
#line 209
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
#line 210
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
#line 212
extern int param_set_copystring(char const   *val , struct kernel_param *kp ) ;
#line 213
extern int param_get_string(char *buffer , struct kernel_param *kp ) ;
#line 220
extern int module_param_sysfs_setup(struct module *mod , struct kernel_param *kparam ,
                                    unsigned int num_params ) ;
#line 224
extern void module_param_sysfs_remove(struct module *mod ) ;
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
extern void marker_update_probe_range(struct marker *begin , struct marker *end ) ;
#line 176 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/marker.h"
__inline static void ( /* format attribute */  ___mark_check_format)(char const   *fmt 
                                                                     , ...) 
{ 

  {
#line 178
  return;
}
}
#line 186
extern marker_probe_func __mark_empty_function ;
#line 188
extern void marker_probe_cb(struct marker  const  *mdata , void *call_private  , ...) ;
#line 195
extern int marker_probe_register(char const   *name , char const   *format , marker_probe_func *probe ,
                                 void *probe_private ) ;
#line 201
extern int marker_probe_unregister(char const   *name , marker_probe_func *probe ,
                                   void *probe_private ) ;
#line 206
extern int marker_probe_unregister_private_data(marker_probe_func *probe , void *probe_private ) ;
#line 209
extern void *marker_get_private_data(char const   *name , marker_probe_func *probe ,
                                     int num ) ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 

  {
  {
#line 75
  x->done = 0U;
#line 76
  init_waitqueue_head(& x->wait);
  }
#line 77
  return;
}
}
#line 79
extern void wait_for_completion(struct completion * ) ;
#line 80
extern int wait_for_completion_interruptible(struct completion *x ) ;
#line 81
extern int wait_for_completion_killable(struct completion *x ) ;
#line 82
extern unsigned long wait_for_completion_timeout(struct completion *x , unsigned long timeout ) ;
#line 84
extern unsigned long wait_for_completion_interruptible_timeout(struct completion *x ,
                                                               unsigned long timeout ) ;
#line 86
extern bool try_wait_for_completion(struct completion *x ) ;
#line 87
extern bool completion_done(struct completion *x ) ;
#line 89
extern void complete(struct completion * ) ;
#line 90
extern void complete_all(struct completion * ) ;
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
extern int rcu_scheduler_active ;
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
extern void rcu_qsctr_inc(int cpu ) ;
#line 238
extern void rcu_bh_qsctr_inc(int cpu ) ;
#line 240
extern int rcu_pending(int cpu ) ;
#line 241
extern int rcu_needs_cpu(int cpu ) ;
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_lock(void) 
{ 

  {
  {
#line 255
  while (1) {
    while_56_continue: /* CIL Label */ ;
    goto while_56_break;
  }
  while_56_break: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_57_continue: /* CIL Label */ ;
    goto while_57_break;
  }
  while_57_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_unlock(void) 
{ 

  {
  {
#line 261
  while (1) {
    while_58_continue: /* CIL Label */ ;
    goto while_58_break;
  }
  while_58_break: /* CIL Label */ ;
  }
  {
#line 263
  while (1) {
    while_59_continue: /* CIL Label */ ;
    goto while_59_break;
  }
  while_59_break: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 265 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_lock_bh(void) 
{ 

  {
  {
#line 267
  local_bh_disable();
  }
  {
#line 269
  while (1) {
    while_60_continue: /* CIL Label */ ;
    goto while_60_break;
  }
  while_60_break: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 271 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void __rcu_read_unlock_bh(void) 
{ 

  {
  {
#line 273
  while (1) {
    while_61_continue: /* CIL Label */ ;
    goto while_61_break;
  }
  while_61_break: /* CIL Label */ ;
  }
  {
#line 275
  local_bh_enable();
  }
#line 276
  return;
}
}
#line 282 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static void rcu_init_sched(void) 
{ 

  {
#line 284
  return;
}
}
#line 286
extern void __rcu_init(void) ;
#line 287
extern void rcu_check_callbacks(int cpu , int user ) ;
#line 288
extern void rcu_restart_cpu(int cpu ) ;
#line 290
extern long rcu_batches_completed(void) ;
#line 291
extern long rcu_batches_completed_bh(void) ;
#line 294
extern void rcu_enter_nohz(void) ;
#line 295
extern void rcu_exit_nohz(void) ;
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcutree.h"
__inline static int rcu_blocking_is_gp(void) 
{ unsigned int tmp ;

  {
  {
#line 308
  tmp = cpumask_weight((struct cpumask  const  *)cpu_online_mask);
  }
#line 308
  return (tmp == 1U);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rcupdate.h"
extern void wakeme_after_rcu(struct rcu_head *head ) ;
#line 238
extern void call_rcu(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
#line 259
extern void call_rcu_bh(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
#line 263
extern void synchronize_rcu(void) ;
#line 264
extern void rcu_barrier(void) ;
#line 265
extern void rcu_barrier_bh(void) ;
#line 266
extern void rcu_barrier_sched(void) ;
#line 269
extern void rcu_init(void) ;
#line 270
extern void rcu_scheduler_starting(void) ;
#line 91 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
extern void tracepoint_update_probe_range(struct tracepoint *begin , struct tracepoint *end ) ;
#line 122
extern int tracepoint_probe_register(char const   *name , void *probe ) ;
#line 128
extern int tracepoint_probe_unregister(char const   *name , void *probe ) ;
#line 130
extern int tracepoint_probe_register_noupdate(char const   *name , void *probe ) ;
#line 131
extern int tracepoint_probe_unregister_noupdate(char const   *name , void *probe ) ;
#line 132
extern void tracepoint_probe_update_all(void) ;
#line 139
extern void tracepoint_iter_start(struct tracepoint_iter *iter ) ;
#line 140
extern void tracepoint_iter_next(struct tracepoint_iter *iter ) ;
#line 141
extern void tracepoint_iter_stop(struct tracepoint_iter *iter ) ;
#line 142
extern void tracepoint_iter_reset(struct tracepoint_iter *iter ) ;
#line 143
extern int tracepoint_get_iter_range(struct tracepoint **tracepoint , struct tracepoint *begin ,
                                     struct tracepoint *end ) ;
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/tracepoint.h"
__inline static void tracepoint_synchronize_unregister(void) 
{ 

  {
  {
#line 153
  synchronize_rcu();
  }
#line 154
  return;
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
extern void kmem_cache_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 85
extern int slab_is_available(void) ;
#line 87
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 90
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 91
extern int kmem_cache_shrink(struct kmem_cache * ) ;
#line 92
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
#line 93
extern unsigned int kmem_cache_size(struct kmem_cache * ) ;
#line 94
extern char const   *kmem_cache_name(struct kmem_cache * ) ;
#line 95
extern int kmem_ptr_validate(struct kmem_cache *cachep , void const   *ptr ) ;
#line 127
extern void *__krealloc(void const   * , size_t  , gfp_t  ) ;
#line 128
extern void *krealloc(void const   * , size_t  , gfp_t  ) ;
#line 129
extern void kfree(void const   * ) ;
#line 130
extern void kzfree(void const   * ) ;
#line 131
extern size_t ksize(void const   * ) ;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
extern unsigned int cpu_khz ;
#line 18
extern unsigned int tsc_khz ;
#line 20
extern void disable_TSC(void) ;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles(void) 
{ unsigned long long ret ;

  {
  {
#line 24
  ret = 0ULL;
#line 30
  ret = __native_read_tsc();
  }
#line 32
  return (ret);
}
}
#line 35 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/tsc.h"
__inline static cycles_t vget_cycles(void) 
{ unsigned long long tmp ;

  {
  {
#line 45
  tmp = __native_read_tsc();
  }
#line 45
  return (tmp);
}
}
#line 48
extern void tsc_init(void) ;
#line 49
extern void mark_tsc_unstable(char *reason ) ;
#line 50
extern int unsynchronized_tsc(void) ;
#line 51
extern int check_tsc_unstable(void) ;
#line 57
extern void check_tsc_sync_source(int cpu ) ;
#line 58
extern void check_tsc_sync_target(void) ;
#line 60
extern int notsc_setup(char * ) ;
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timex.h"
extern unsigned long tick_usec ;
#line 211
extern unsigned long tick_nsec ;
#line 212
extern int tickadj ;
#line 217
extern int time_status ;
#line 218
extern long time_maxerror ;
#line 219
extern long time_esterror ;
#line 221
extern long time_adjust ;
#line 223
extern void ntp_init(void) ;
#line 224
extern void ntp_clear(void) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timex.h"
__inline static int ntp_synced(void) 
{ 

  {
#line 232
  return (! (time_status & 64));
}
}
#line 252
extern u64 tick_length ;
#line 254
extern void second_overflow(void) ;
#line 255
extern void update_ntp_one_tick(void) ;
#line 256
extern int do_adjtimex(struct timex * ) ;
#line 261
extern int read_current_timer(unsigned long *timer_val ) ;
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/jiffies.h"
extern u64 jiffies_64  __attribute__((__section__(".data"))) ;
#line 82
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
#line 85
extern u64 get_jiffies_64(void) ;
#line 183
extern unsigned long preset_lpj ;
#line 296
extern unsigned int jiffies_to_msecs(unsigned long j ) ;
#line 297
extern unsigned int jiffies_to_usecs(unsigned long j ) ;
#line 298
extern unsigned long msecs_to_jiffies(unsigned int m ) ;
#line 299
extern unsigned long usecs_to_jiffies(unsigned int u ) ;
#line 300
extern unsigned long timespec_to_jiffies(struct timespec  const  *value ) ;
#line 301
extern void jiffies_to_timespec(unsigned long jiffies , struct timespec *value ) ;
#line 303
extern unsigned long timeval_to_jiffies(struct timeval  const  *value ) ;
#line 304
extern void jiffies_to_timeval(unsigned long jiffies , struct timeval *value ) ;
#line 306
extern clock_t jiffies_to_clock_t(long x ) ;
#line 307
extern unsigned long clock_t_to_jiffies(unsigned long x ) ;
#line 308
extern u64 jiffies_64_to_clock_t(u64 x ) ;
#line 309
extern u64 nsec_to_clock_t(u64 x ) ;
#line 81 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_set(long secs , unsigned long nsecs ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 87
  __constr_expr_0.tv64 = (long long )secs * 1000000000LL + (long long )nsecs;
  }
#line 87
  return (__constr_expr_0);
}
}
#line 113 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t timespec_to_ktime(struct timespec ts ) 
{ ktime_t tmp ;

  {
  {
#line 115
  tmp = ktime_set(ts.tv_sec, (unsigned long )ts.tv_nsec);
  }
#line 115
  return (tmp);
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t timeval_to_ktime(struct timeval tv ) 
{ ktime_t tmp ;

  {
  {
#line 121
  tmp = ktime_set(tv.tv_sec, (unsigned long )(tv.tv_usec * 1000L));
  }
#line 121
  return (tmp);
}
}
#line 287 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static int ktime_equal(ktime_t cmp1 , ktime_t cmp2 ) 
{ 

  {
#line 289
  return (cmp1.tv64 == cmp2.tv64);
}
}
#line 292 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static s64 ktime_to_us(ktime_t kt ) 
{ struct timeval tv ;
  struct timeval tmp ;

  {
  {
#line 294
  tmp = ns_to_timeval(kt.tv64);
#line 294
  tv = tmp;
  }
#line 295
  return ((long long )tv.tv_sec * 1000000LL + (long long )tv.tv_usec);
}
}
#line 298 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static s64 ktime_us_delta(ktime_t later , ktime_t earlier ) 
{ ktime_t __constr_expr_0 ;
  s64 tmp ;

  {
  {
#line 300
  __constr_expr_0.tv64 = later.tv64 - earlier.tv64;
#line 300
  tmp = ktime_to_us(__constr_expr_0);
  }
#line 300
  return (tmp);
}
}
#line 303 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_add_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 305
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 + usec * 1000ULL);
  }
#line 305
  return (__constr_expr_0);
}
}
#line 308 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ktime_sub_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 310
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 - usec * 1000ULL);
  }
#line 310
  return (__constr_expr_0);
}
}
#line 313
extern ktime_t ktime_add_safe(ktime_t lhs , ktime_t rhs ) ;
#line 325
extern void ktime_get_ts(struct timespec *ts ) ;
#line 332
__inline static ktime_t ns_to_ktime(u64 ns ) ;
#line 332 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
static union ktime  const  ktime_zero  =    {(s64 )0};
#line 330 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
#line 333
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero.tv64 + ns);
  }
#line 333
  return (__constr_expr_0);
}
}
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_init(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 67
  return;
}
}
#line 68 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_init_on_stack(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 69
  return;
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_activate(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 71
  return;
}
}
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_deactivate(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 73
  return;
}
}
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_destroy(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 75
  return;
}
}
#line 76 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_object_free(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
#line 77
  return;
}
}
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_objects_early_init(void) 
{ 

  {
#line 79
  return;
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_objects_mem_init(void) 
{ 

  {
#line 80
  return;
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugobjects.h"
__inline static void debug_check_no_obj_freed(void const   *address , unsigned long size ) 
{ 

  {
#line 87
  return;
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
extern struct tvec_base boot_tvec_bases ;
#line 59
extern void init_timer_key(struct timer_list *timer , char const   *name , struct lock_class_key *key ) ;
#line 62
extern void init_timer_deferrable_key(struct timer_list *timer , char const   *name ,
                                      struct lock_class_key *key ) ;
#line 116 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void destroy_timer_on_stack(struct timer_list *timer ) 
{ 

  {
#line 116
  return;
}
}
#line 117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void init_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                             struct lock_class_key *key ) 
{ 

  {
  {
#line 121
  init_timer_key(timer, name, key);
  }
#line 122
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void setup_timer_key(struct timer_list *timer , char const   *name ,
                                     struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                     unsigned long data ) 
{ 

  {
  {
#line 131
  timer->function = function;
#line 132
  timer->data = data;
#line 133
  init_timer_key(timer, name, key);
  }
#line 134
  return;
}
}
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void setup_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                              struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                              unsigned long data ) 
{ 

  {
  {
#line 142
  timer->function = function;
#line 143
  timer->data = data;
#line 144
  init_timer_on_stack_key(timer, name, key);
  }
#line 145
  return;
}
}
#line 157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 

  {
#line 159
  return ((unsigned long )timer->entry.next != (unsigned long )((void *)0));
}
}
#line 162
extern void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 163
extern int del_timer(struct timer_list *timer ) ;
#line 164
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 165
extern int mod_timer_pending(struct timer_list *timer , unsigned long expires ) ;
#line 177
extern unsigned long next_timer_interrupt(void) ;
#line 183
extern unsigned long get_next_timer_interrupt(unsigned long now ) ;
#line 192
extern void init_timer_stats(void) ;
#line 194
extern void timer_stats_update_stats(void *timer , pid_t pid , void *startf , void *timerf ,
                                     char *comm , unsigned int timer_flag ) ;
#line 198
extern void __timer_stats_timer_set_start_info(struct timer_list *timer , void *addr ) ;
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void timer_stats_timer_set_start_info(struct timer_list *timer ) 
{ void *tmp ;

  {
  {
#line 203
  tmp = __builtin_return_address(0U);
#line 203
  __timer_stats_timer_set_start_info(timer, tmp);
  }
#line 204
  return;
}
}
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/timer.h"
__inline static void timer_stats_timer_clear_start_info(struct timer_list *timer ) 
{ 

  {
  {
#line 208
  timer->start_site = (void *)0;
  }
#line 209
  return;
}
}
#line 224
extern void add_timer(struct timer_list *timer ) ;
#line 227
extern int try_to_del_timer_sync(struct timer_list *timer ) ;
#line 228
extern int del_timer_sync(struct timer_list *timer ) ;
#line 236
extern void init_timers(void) ;
#line 237
extern void run_local_timers(void) ;
#line 239
extern enum hrtimer_restart it_real_fn(struct hrtimer * ) ;
#line 241
extern unsigned long __round_jiffies(unsigned long j , int cpu ) ;
#line 242
extern unsigned long __round_jiffies_relative(unsigned long j , int cpu ) ;
#line 243
extern unsigned long round_jiffies(unsigned long j ) ;
#line 244
extern unsigned long round_jiffies_relative(unsigned long j ) ;
#line 246
extern unsigned long __round_jiffies_up(unsigned long j , int cpu ) ;
#line 247
extern unsigned long __round_jiffies_up_relative(unsigned long j , int cpu ) ;
#line 248
extern unsigned long round_jiffies_up(unsigned long j ) ;
#line 249
extern unsigned long round_jiffies_up_relative(unsigned long j ) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static struct delayed_work *to_delayed_work(struct work_struct *work ) 
{ struct work_struct  const  *__mptr ;

  {
  {
#line 46
  __mptr = (struct work_struct  const  *)work;
  }
#line 46
  return ((struct delayed_work *)((char *)__mptr - (unsigned int )(& ((struct delayed_work *)0)->work)));
}
}
#line 167
extern struct workqueue_struct *__create_workqueue_key(char const   *name , int singlethread ,
                                                       int freezeable , int rt , struct lock_class_key *key ,
                                                       char const   *lock_name ) ;
#line 198
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
#line 200
extern int queue_work(struct workqueue_struct *wq , struct work_struct *work ) ;
#line 201
extern int queue_work_on(int cpu , struct workqueue_struct *wq , struct work_struct *work ) ;
#line 203
extern int queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *work ,
                              unsigned long delay ) ;
#line 205
extern int queue_delayed_work_on(int cpu , struct workqueue_struct *wq , struct delayed_work *work ,
                                 unsigned long delay ) ;
#line 208
extern void flush_workqueue(struct workqueue_struct *wq ) ;
#line 209
extern void flush_scheduled_work(void) ;
#line 211
extern int schedule_work(struct work_struct *work ) ;
#line 212
extern int schedule_work_on(int cpu , struct work_struct *work ) ;
#line 213
extern int schedule_delayed_work(struct delayed_work *work , unsigned long delay ) ;
#line 214
extern int schedule_delayed_work_on(int cpu , struct delayed_work *work , unsigned long delay ) ;
#line 216
extern int schedule_on_each_cpu(void (*func)(struct work_struct *work ) ) ;
#line 217
extern int current_is_keventd(void) ;
#line 218
extern int keventd_up(void) ;
#line 220
extern void init_workqueues(void) ;
#line 221
extern int execute_in_process_context(void (*fn)(struct work_struct *work ) , struct execute_work * ) ;
#line 223
extern int flush_work(struct work_struct *work ) ;
#line 225
extern int cancel_work_sync(struct work_struct *work ) ;
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static int cancel_delayed_work(struct delayed_work *work ) 
{ int ret ;

  {
  {
#line 237
  ret = del_timer_sync(& work->timer);
  }
#line 238
  if (ret) {
    {
#line 239
    clear_bit(0, (unsigned long volatile   *)((unsigned long *)(& work->work.data)));
    }
  }
#line 240
  return (ret);
}
}
#line 243
extern int cancel_delayed_work_sync(struct delayed_work *work ) ;
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static void cancel_rearming_delayed_workqueue(struct workqueue_struct *wq ,
                                                       struct delayed_work *work ) 
{ 

  {
  {
#line 250
  cancel_delayed_work_sync(work);
  }
#line 251
  return;
}
}
#line 254 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/workqueue.h"
__inline static void cancel_rearming_delayed_work(struct delayed_work *work ) 
{ 

  {
  {
#line 257
  cancel_delayed_work_sync(work);
  }
#line 258
  return;
}
}
#line 266
extern long work_on_cpu(unsigned int cpu , long (*fn)(void * ) , void *arg ) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void kmemtrace_init(void) 
{ 

  {
#line 20
  return;
}
}
#line 23
extern struct tracepoint __tracepoint_kmalloc ;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmalloc(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                                   size_t bytes_alloc , gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 23
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc.state)), 0L);
  }
#line 23
  if (tmp) {
    {
#line 23
    while (1) {
      while_62_continue: /* CIL Label */ ;
      {
#line 23
      while (1) {
        while_63_continue: /* CIL Label */ ;
        goto while_63_break;
      }
      while_63_break: /* CIL Label */ ;
      }
      {
#line 23
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc.funcs));
      }
      {
#line 23
      while (1) {
        while_64_continue: /* CIL Label */ ;
        goto while_64_break;
      }
      while_64_break: /* CIL Label */ ;
      }
      {
#line 23
      it_func = _________p1;
      }
#line 23
      if (it_func) {
        {
#line 23
        while (1) {
          while_65_continue: /* CIL Label */ ;
          {
#line 23
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
#line 23
          it_func ++;
          }
#line 23
          if (! *it_func) {
            goto while_65_break;
          }
        }
        while_65_break: /* CIL Label */ ;
        }
      }
      {
#line 23
      while (1) {
        while_66_continue: /* CIL Label */ ;
        goto while_66_break;
      }
      while_66_break: /* CIL Label */ ;
      }
      goto while_62_break;
    }
    while_62_break: /* CIL Label */ ;
    }
  }
#line 23
  return;
}
}
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr , size_t bytes_req ,
                                                         size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 23
  tmp = tracepoint_probe_register("kmalloc", (void *)probe);
  }
#line 23
  return (tmp);
}
}
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                           void const   *ptr , size_t bytes_req ,
                                                           size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 23
  tmp = tracepoint_probe_unregister("kmalloc", (void *)probe);
  }
#line 23
  return (tmp);
}
}
#line 30
extern struct tracepoint __tracepoint_kmem_cache_alloc ;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmem_cache_alloc(unsigned long call_site , void const   *ptr ,
                                            size_t bytes_req , size_t bytes_alloc ,
                                            gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 30
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc.state)), 0L);
  }
#line 30
  if (tmp) {
    {
#line 30
    while (1) {
      while_67_continue: /* CIL Label */ ;
      {
#line 30
      while (1) {
        while_68_continue: /* CIL Label */ ;
        goto while_68_break;
      }
      while_68_break: /* CIL Label */ ;
      }
      {
#line 30
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc.funcs));
      }
      {
#line 30
      while (1) {
        while_69_continue: /* CIL Label */ ;
        goto while_69_break;
      }
      while_69_break: /* CIL Label */ ;
      }
      {
#line 30
      it_func = _________p1;
      }
#line 30
      if (it_func) {
        {
#line 30
        while (1) {
          while_70_continue: /* CIL Label */ ;
          {
#line 30
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
#line 30
          it_func ++;
          }
#line 30
          if (! *it_func) {
            goto while_70_break;
          }
        }
        while_70_break: /* CIL Label */ ;
        }
      }
      {
#line 30
      while (1) {
        while_71_continue: /* CIL Label */ ;
        goto while_71_break;
      }
      while_71_break: /* CIL Label */ ;
      }
      goto while_67_break;
    }
    while_67_break: /* CIL Label */ ;
    }
  }
#line 30
  return;
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                  void const   *ptr ,
                                                                  size_t bytes_req ,
                                                                  size_t bytes_alloc ,
                                                                  gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 30
  tmp = tracepoint_probe_register("kmem_cache_alloc", (void *)probe);
  }
#line 30
  return (tmp);
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                    void const   *ptr ,
                                                                    size_t bytes_req ,
                                                                    size_t bytes_alloc ,
                                                                    gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
#line 30
  tmp = tracepoint_probe_unregister("kmem_cache_alloc", (void *)probe);
  }
#line 30
  return (tmp);
}
}
#line 37
extern struct tracepoint __tracepoint_kmalloc_node ;
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmalloc_node(unsigned long call_site , void const   *ptr ,
                                        size_t bytes_req , size_t bytes_alloc , gfp_t gfp_flags ,
                                        int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 37
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc_node.state)), 0L);
  }
#line 37
  if (tmp) {
    {
#line 37
    while (1) {
      while_72_continue: /* CIL Label */ ;
      {
#line 37
      while (1) {
        while_73_continue: /* CIL Label */ ;
        goto while_73_break;
      }
      while_73_break: /* CIL Label */ ;
      }
      {
#line 37
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc_node.funcs));
      }
      {
#line 37
      while (1) {
        while_74_continue: /* CIL Label */ ;
        goto while_74_break;
      }
      while_74_break: /* CIL Label */ ;
      }
      {
#line 37
      it_func = _________p1;
      }
#line 37
      if (it_func) {
        {
#line 37
        while (1) {
          while_75_continue: /* CIL Label */ ;
          {
#line 37
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
#line 37
          it_func ++;
          }
#line 37
          if (! *it_func) {
            goto while_75_break;
          }
        }
        while_75_break: /* CIL Label */ ;
        }
      }
      {
#line 37
      while (1) {
        while_76_continue: /* CIL Label */ ;
        goto while_76_break;
      }
      while_76_break: /* CIL Label */ ;
      }
      goto while_72_break;
    }
    while_72_break: /* CIL Label */ ;
    }
  }
#line 37
  return;
}
}
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                              void const   *ptr ,
                                                              size_t bytes_req , size_t bytes_alloc ,
                                                              gfp_t gfp_flags , int node ) ) 
{ int tmp ;

  {
  {
#line 37
  tmp = tracepoint_probe_register("kmalloc_node", (void *)probe);
  }
#line 37
  return (tmp);
}
}
#line 37 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                                void const   *ptr ,
                                                                size_t bytes_req ,
                                                                size_t bytes_alloc ,
                                                                gfp_t gfp_flags ,
                                                                int node ) ) 
{ int tmp ;

  {
  {
#line 37
  tmp = tracepoint_probe_unregister("kmalloc_node", (void *)probe);
  }
#line 37
  return (tmp);
}
}
#line 45
extern struct tracepoint __tracepoint_kmem_cache_alloc_node ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmem_cache_alloc_node(unsigned long call_site , void const   *ptr ,
                                                 size_t bytes_req , size_t bytes_alloc ,
                                                 gfp_t gfp_flags , int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 45
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc_node.state)),
                         0L);
  }
#line 45
  if (tmp) {
    {
#line 45
    while (1) {
      while_77_continue: /* CIL Label */ ;
      {
#line 45
      while (1) {
        while_78_continue: /* CIL Label */ ;
        goto while_78_break;
      }
      while_78_break: /* CIL Label */ ;
      }
      {
#line 45
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc_node.funcs));
      }
      {
#line 45
      while (1) {
        while_79_continue: /* CIL Label */ ;
        goto while_79_break;
      }
      while_79_break: /* CIL Label */ ;
      }
      {
#line 45
      it_func = _________p1;
      }
#line 45
      if (it_func) {
        {
#line 45
        while (1) {
          while_80_continue: /* CIL Label */ ;
          {
#line 45
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
#line 45
          it_func ++;
          }
#line 45
          if (! *it_func) {
            goto while_80_break;
          }
        }
        while_80_break: /* CIL Label */ ;
        }
      }
      {
#line 45
      while (1) {
        while_81_continue: /* CIL Label */ ;
        goto while_81_break;
      }
      while_81_break: /* CIL Label */ ;
      }
      goto while_77_break;
    }
    while_77_break: /* CIL Label */ ;
    }
  }
#line 45
  return;
}
}
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                       void const   *ptr ,
                                                                       size_t bytes_req ,
                                                                       size_t bytes_alloc ,
                                                                       gfp_t gfp_flags ,
                                                                       int node ) ) 
{ int tmp ;

  {
  {
#line 45
  tmp = tracepoint_probe_register("kmem_cache_alloc_node", (void *)probe);
  }
#line 45
  return (tmp);
}
}
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                         void const   *ptr ,
                                                                         size_t bytes_req ,
                                                                         size_t bytes_alloc ,
                                                                         gfp_t gfp_flags ,
                                                                         int node ) ) 
{ int tmp ;

  {
  {
#line 45
  tmp = tracepoint_probe_unregister("kmem_cache_alloc_node", (void *)probe);
  }
#line 45
  return (tmp);
}
}
#line 53
extern struct tracepoint __tracepoint_kfree ;
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kfree(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 53
  tmp = __builtin_expect((long )(! (! __tracepoint_kfree.state)), 0L);
  }
#line 53
  if (tmp) {
    {
#line 53
    while (1) {
      while_82_continue: /* CIL Label */ ;
      {
#line 53
      while (1) {
        while_83_continue: /* CIL Label */ ;
        goto while_83_break;
      }
      while_83_break: /* CIL Label */ ;
      }
      {
#line 53
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kfree.funcs));
      }
      {
#line 53
      while (1) {
        while_84_continue: /* CIL Label */ ;
        goto while_84_break;
      }
      while_84_break: /* CIL Label */ ;
      }
      {
#line 53
      it_func = _________p1;
      }
#line 53
      if (it_func) {
        {
#line 53
        while (1) {
          while_85_continue: /* CIL Label */ ;
          {
#line 53
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
#line 53
          it_func ++;
          }
#line 53
          if (! *it_func) {
            goto while_85_break;
          }
        }
        while_85_break: /* CIL Label */ ;
        }
      }
      {
#line 53
      while (1) {
        while_86_continue: /* CIL Label */ ;
        goto while_86_break;
      }
      while_86_break: /* CIL Label */ ;
      }
      goto while_82_break;
    }
    while_82_break: /* CIL Label */ ;
    }
  }
#line 53
  return;
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kfree(void (*probe)(unsigned long call_site , void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 53
  tmp = tracepoint_probe_register("kfree", (void *)probe);
  }
#line 53
  return (tmp);
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kfree(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 53
  tmp = tracepoint_probe_unregister("kfree", (void *)probe);
  }
#line 53
  return (tmp);
}
}
#line 56
extern struct tracepoint __tracepoint_kmem_cache_free ;
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static void trace_kmem_cache_free(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
#line 56
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_free.state)), 0L);
  }
#line 56
  if (tmp) {
    {
#line 56
    while (1) {
      while_87_continue: /* CIL Label */ ;
      {
#line 56
      while (1) {
        while_88_continue: /* CIL Label */ ;
        goto while_88_break;
      }
      while_88_break: /* CIL Label */ ;
      }
      {
#line 56
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_free.funcs));
      }
      {
#line 56
      while (1) {
        while_89_continue: /* CIL Label */ ;
        goto while_89_break;
      }
      while_89_break: /* CIL Label */ ;
      }
      {
#line 56
      it_func = _________p1;
      }
#line 56
      if (it_func) {
        {
#line 56
        while (1) {
          while_90_continue: /* CIL Label */ ;
          {
#line 56
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
#line 56
          it_func ++;
          }
#line 56
          if (! *it_func) {
            goto while_90_break;
          }
        }
        while_90_break: /* CIL Label */ ;
        }
      }
      {
#line 56
      while (1) {
        while_91_continue: /* CIL Label */ ;
        goto while_91_break;
      }
      while_91_break: /* CIL Label */ ;
      }
      goto while_87_break;
    }
    while_87_break: /* CIL Label */ ;
    }
  }
#line 56
  return;
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int register_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                 void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 56
  tmp = tracepoint_probe_register("kmem_cache_free", (void *)probe);
  }
#line 56
  return (tmp);
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/trace/kmemtrace.h"
__inline static int unregister_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                   void const   *ptr ) ) 
{ int tmp ;

  {
  {
#line 56
  tmp = tracepoint_probe_unregister("kmem_cache_free", (void *)probe);
  }
#line 56
  return (tmp);
}
}
#line 141 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
extern struct kmem_cache kmalloc_caches[14] ;
#line 147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static int kmalloc_index(size_t size ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;

  {
#line 149
  if (! size) {
#line 150
    return (0);
  }
#line 152
  if (size <= 8U) {
#line 153
    if (8ULL & (1ULL << 63)) {
      {
#line 153
      tmp___63 = 63;
      }
    } else {
#line 153
      if (8ULL & (1ULL << 62)) {
        {
#line 153
        tmp___62 = 62;
        }
      } else {
#line 153
        if (8ULL & (1ULL << 61)) {
          {
#line 153
          tmp___61 = 61;
          }
        } else {
#line 153
          if (8ULL & (1ULL << 60)) {
            {
#line 153
            tmp___60 = 60;
            }
          } else {
#line 153
            if (8ULL & (1ULL << 59)) {
              {
#line 153
              tmp___59 = 59;
              }
            } else {
#line 153
              if (8ULL & (1ULL << 58)) {
                {
#line 153
                tmp___58 = 58;
                }
              } else {
#line 153
                if (8ULL & (1ULL << 57)) {
                  {
#line 153
                  tmp___57 = 57;
                  }
                } else {
#line 153
                  if (8ULL & (1ULL << 56)) {
                    {
#line 153
                    tmp___56 = 56;
                    }
                  } else {
#line 153
                    if (8ULL & (1ULL << 55)) {
                      {
#line 153
                      tmp___55 = 55;
                      }
                    } else {
#line 153
                      if (8ULL & (1ULL << 54)) {
                        {
#line 153
                        tmp___54 = 54;
                        }
                      } else {
#line 153
                        if (8ULL & (1ULL << 53)) {
                          {
#line 153
                          tmp___53 = 53;
                          }
                        } else {
#line 153
                          if (8ULL & (1ULL << 52)) {
                            {
#line 153
                            tmp___52 = 52;
                            }
                          } else {
#line 153
                            if (8ULL & (1ULL << 51)) {
                              {
#line 153
                              tmp___51 = 51;
                              }
                            } else {
#line 153
                              if (8ULL & (1ULL << 50)) {
                                {
#line 153
                                tmp___50 = 50;
                                }
                              } else {
#line 153
                                if (8ULL & (1ULL << 49)) {
                                  {
#line 153
                                  tmp___49 = 49;
                                  }
                                } else {
#line 153
                                  if (8ULL & (1ULL << 48)) {
                                    {
#line 153
                                    tmp___48 = 48;
                                    }
                                  } else {
#line 153
                                    if (8ULL & (1ULL << 47)) {
                                      {
#line 153
                                      tmp___47 = 47;
                                      }
                                    } else {
#line 153
                                      if (8ULL & (1ULL << 46)) {
                                        {
#line 153
                                        tmp___46 = 46;
                                        }
                                      } else {
#line 153
                                        if (8ULL & (1ULL << 45)) {
                                          {
#line 153
                                          tmp___45 = 45;
                                          }
                                        } else {
#line 153
                                          if (8ULL & (1ULL << 44)) {
                                            {
#line 153
                                            tmp___44 = 44;
                                            }
                                          } else {
#line 153
                                            if (8ULL & (1ULL << 43)) {
                                              {
#line 153
                                              tmp___43 = 43;
                                              }
                                            } else {
#line 153
                                              if (8ULL & (1ULL << 42)) {
                                                {
#line 153
                                                tmp___42 = 42;
                                                }
                                              } else {
#line 153
                                                if (8ULL & (1ULL << 41)) {
                                                  {
#line 153
                                                  tmp___41 = 41;
                                                  }
                                                } else {
#line 153
                                                  if (8ULL & (1ULL << 40)) {
                                                    {
#line 153
                                                    tmp___40 = 40;
                                                    }
                                                  } else {
#line 153
                                                    if (8ULL & (1ULL << 39)) {
                                                      {
#line 153
                                                      tmp___39 = 39;
                                                      }
                                                    } else {
#line 153
                                                      if (8ULL & (1ULL << 38)) {
                                                        {
#line 153
                                                        tmp___38 = 38;
                                                        }
                                                      } else {
#line 153
                                                        if (8ULL & (1ULL << 37)) {
                                                          {
#line 153
                                                          tmp___37 = 37;
                                                          }
                                                        } else {
#line 153
                                                          if (8ULL & (1ULL << 36)) {
                                                            {
#line 153
                                                            tmp___36 = 36;
                                                            }
                                                          } else {
#line 153
                                                            if (8ULL & (1ULL << 35)) {
                                                              {
#line 153
                                                              tmp___35 = 35;
                                                              }
                                                            } else {
#line 153
                                                              if (8ULL & (1ULL << 34)) {
                                                                {
#line 153
                                                                tmp___34 = 34;
                                                                }
                                                              } else {
#line 153
                                                                if (8ULL & (1ULL << 33)) {
                                                                  {
#line 153
                                                                  tmp___33 = 33;
                                                                  }
                                                                } else {
#line 153
                                                                  if (8ULL & (1ULL << 32)) {
                                                                    {
#line 153
                                                                    tmp___32 = 32;
                                                                    }
                                                                  } else {
#line 153
                                                                    if (8ULL & (1ULL << 31)) {
                                                                      {
#line 153
                                                                      tmp___31 = 31;
                                                                      }
                                                                    } else {
#line 153
                                                                      if (8ULL & (1ULL << 30)) {
                                                                        {
#line 153
                                                                        tmp___30 = 30;
                                                                        }
                                                                      } else {
#line 153
                                                                        if (8ULL & (1ULL << 29)) {
                                                                          {
#line 153
                                                                          tmp___29 = 29;
                                                                          }
                                                                        } else {
#line 153
                                                                          if (8ULL & (1ULL << 28)) {
                                                                            {
#line 153
                                                                            tmp___28 = 28;
                                                                            }
                                                                          } else {
#line 153
                                                                            if (8ULL & (1ULL << 27)) {
                                                                              {
#line 153
                                                                              tmp___27 = 27;
                                                                              }
                                                                            } else {
#line 153
                                                                              if (8ULL & (1ULL << 26)) {
                                                                                {
#line 153
                                                                                tmp___26 = 26;
                                                                                }
                                                                              } else {
#line 153
                                                                                if (8ULL & (1ULL << 25)) {
                                                                                  {
#line 153
                                                                                  tmp___25 = 25;
                                                                                  }
                                                                                } else {
#line 153
                                                                                  if (8ULL & (1ULL << 24)) {
                                                                                    {
#line 153
                                                                                    tmp___24 = 24;
                                                                                    }
                                                                                  } else {
#line 153
                                                                                    if (8ULL & (1ULL << 23)) {
                                                                                      {
#line 153
                                                                                      tmp___23 = 23;
                                                                                      }
                                                                                    } else {
#line 153
                                                                                      if (8ULL & (1ULL << 22)) {
                                                                                        {
#line 153
                                                                                        tmp___22 = 22;
                                                                                        }
                                                                                      } else {
#line 153
                                                                                        if (8ULL & (1ULL << 21)) {
                                                                                          {
#line 153
                                                                                          tmp___21 = 21;
                                                                                          }
                                                                                        } else {
#line 153
                                                                                          if (8ULL & (1ULL << 20)) {
                                                                                            {
#line 153
                                                                                            tmp___20 = 20;
                                                                                            }
                                                                                          } else {
#line 153
                                                                                            if (8ULL & (1ULL << 19)) {
                                                                                              {
#line 153
                                                                                              tmp___19 = 19;
                                                                                              }
                                                                                            } else {
#line 153
                                                                                              if (8ULL & (1ULL << 18)) {
                                                                                                {
#line 153
                                                                                                tmp___18 = 18;
                                                                                                }
                                                                                              } else {
#line 153
                                                                                                if (8ULL & (1ULL << 17)) {
                                                                                                  {
#line 153
                                                                                                  tmp___17 = 17;
                                                                                                  }
                                                                                                } else {
#line 153
                                                                                                  if (8ULL & (1ULL << 16)) {
                                                                                                    {
#line 153
                                                                                                    tmp___16 = 16;
                                                                                                    }
                                                                                                  } else {
#line 153
                                                                                                    if (8ULL & (1ULL << 15)) {
                                                                                                      {
#line 153
                                                                                                      tmp___15 = 15;
                                                                                                      }
                                                                                                    } else {
#line 153
                                                                                                      if (8ULL & (1ULL << 14)) {
                                                                                                        {
#line 153
                                                                                                        tmp___14 = 14;
                                                                                                        }
                                                                                                      } else {
#line 153
                                                                                                        if (8ULL & (1ULL << 13)) {
                                                                                                          {
#line 153
                                                                                                          tmp___13 = 13;
                                                                                                          }
                                                                                                        } else {
#line 153
                                                                                                          if (8ULL & (1ULL << 12)) {
                                                                                                            {
#line 153
                                                                                                            tmp___12 = 12;
                                                                                                            }
                                                                                                          } else {
#line 153
                                                                                                            if (8ULL & (1ULL << 11)) {
                                                                                                              {
#line 153
                                                                                                              tmp___11 = 11;
                                                                                                              }
                                                                                                            } else {
#line 153
                                                                                                              if (8ULL & (1ULL << 10)) {
                                                                                                                {
#line 153
                                                                                                                tmp___10 = 10;
                                                                                                                }
                                                                                                              } else {
#line 153
                                                                                                                if (8ULL & (1ULL << 9)) {
                                                                                                                  {
#line 153
                                                                                                                  tmp___9 = 9;
                                                                                                                  }
                                                                                                                } else {
#line 153
                                                                                                                  if (8ULL & (1ULL << 8)) {
                                                                                                                    {
#line 153
                                                                                                                    tmp___8 = 8;
                                                                                                                    }
                                                                                                                  } else {
#line 153
                                                                                                                    if (8ULL & (1ULL << 7)) {
                                                                                                                      {
#line 153
                                                                                                                      tmp___7 = 7;
                                                                                                                      }
                                                                                                                    } else {
#line 153
                                                                                                                      if (8ULL & (1ULL << 6)) {
                                                                                                                        {
#line 153
                                                                                                                        tmp___6 = 6;
                                                                                                                        }
                                                                                                                      } else {
#line 153
                                                                                                                        if (8ULL & (1ULL << 5)) {
                                                                                                                          {
#line 153
                                                                                                                          tmp___5 = 5;
                                                                                                                          }
                                                                                                                        } else {
#line 153
                                                                                                                          if (8ULL & (1ULL << 4)) {
                                                                                                                            {
#line 153
                                                                                                                            tmp___4 = 4;
                                                                                                                            }
                                                                                                                          } else {
#line 153
                                                                                                                            if (8ULL & (1ULL << 3)) {
                                                                                                                              {
#line 153
                                                                                                                              tmp___3 = 3;
                                                                                                                              }
                                                                                                                            } else {
#line 153
                                                                                                                              if (8ULL & (1ULL << 2)) {
                                                                                                                                {
#line 153
                                                                                                                                tmp___2 = 2;
                                                                                                                                }
                                                                                                                              } else {
#line 153
                                                                                                                                if (8ULL & (1ULL << 1)) {
                                                                                                                                  {
#line 153
                                                                                                                                  tmp___1 = 1;
                                                                                                                                  }
                                                                                                                                } else {
                                                                                                                                  {
#line 153
                                                                                                                                  tmp___0 = ____ilog2_NaN();
#line 153
                                                                                                                                  tmp___1 = tmp___0;
                                                                                                                                  }
                                                                                                                                }
                                                                                                                                {
#line 153
                                                                                                                                tmp___2 = tmp___1;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              {
#line 153
                                                                                                                              tmp___3 = tmp___2;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            {
#line 153
                                                                                                                            tmp___4 = tmp___3;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          {
#line 153
                                                                                                                          tmp___5 = tmp___4;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        {
#line 153
                                                                                                                        tmp___6 = tmp___5;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      {
#line 153
                                                                                                                      tmp___7 = tmp___6;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    {
#line 153
                                                                                                                    tmp___8 = tmp___7;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  {
#line 153
                                                                                                                  tmp___9 = tmp___8;
                                                                                                                  }
                                                                                                                }
                                                                                                                {
#line 153
                                                                                                                tmp___10 = tmp___9;
                                                                                                                }
                                                                                                              }
                                                                                                              {
#line 153
                                                                                                              tmp___11 = tmp___10;
                                                                                                              }
                                                                                                            }
                                                                                                            {
#line 153
                                                                                                            tmp___12 = tmp___11;
                                                                                                            }
                                                                                                          }
                                                                                                          {
#line 153
                                                                                                          tmp___13 = tmp___12;
                                                                                                          }
                                                                                                        }
                                                                                                        {
#line 153
                                                                                                        tmp___14 = tmp___13;
                                                                                                        }
                                                                                                      }
                                                                                                      {
#line 153
                                                                                                      tmp___15 = tmp___14;
                                                                                                      }
                                                                                                    }
                                                                                                    {
#line 153
                                                                                                    tmp___16 = tmp___15;
                                                                                                    }
                                                                                                  }
                                                                                                  {
#line 153
                                                                                                  tmp___17 = tmp___16;
                                                                                                  }
                                                                                                }
                                                                                                {
#line 153
                                                                                                tmp___18 = tmp___17;
                                                                                                }
                                                                                              }
                                                                                              {
#line 153
                                                                                              tmp___19 = tmp___18;
                                                                                              }
                                                                                            }
                                                                                            {
#line 153
                                                                                            tmp___20 = tmp___19;
                                                                                            }
                                                                                          }
                                                                                          {
#line 153
                                                                                          tmp___21 = tmp___20;
                                                                                          }
                                                                                        }
                                                                                        {
#line 153
                                                                                        tmp___22 = tmp___21;
                                                                                        }
                                                                                      }
                                                                                      {
#line 153
                                                                                      tmp___23 = tmp___22;
                                                                                      }
                                                                                    }
                                                                                    {
#line 153
                                                                                    tmp___24 = tmp___23;
                                                                                    }
                                                                                  }
                                                                                  {
#line 153
                                                                                  tmp___25 = tmp___24;
                                                                                  }
                                                                                }
                                                                                {
#line 153
                                                                                tmp___26 = tmp___25;
                                                                                }
                                                                              }
                                                                              {
#line 153
                                                                              tmp___27 = tmp___26;
                                                                              }
                                                                            }
                                                                            {
#line 153
                                                                            tmp___28 = tmp___27;
                                                                            }
                                                                          }
                                                                          {
#line 153
                                                                          tmp___29 = tmp___28;
                                                                          }
                                                                        }
                                                                        {
#line 153
                                                                        tmp___30 = tmp___29;
                                                                        }
                                                                      }
                                                                      {
#line 153
                                                                      tmp___31 = tmp___30;
                                                                      }
                                                                    }
                                                                    {
#line 153
                                                                    tmp___32 = tmp___31;
                                                                    }
                                                                  }
                                                                  {
#line 153
                                                                  tmp___33 = tmp___32;
                                                                  }
                                                                }
                                                                {
#line 153
                                                                tmp___34 = tmp___33;
                                                                }
                                                              }
                                                              {
#line 153
                                                              tmp___35 = tmp___34;
                                                              }
                                                            }
                                                            {
#line 153
                                                            tmp___36 = tmp___35;
                                                            }
                                                          }
                                                          {
#line 153
                                                          tmp___37 = tmp___36;
                                                          }
                                                        }
                                                        {
#line 153
                                                        tmp___38 = tmp___37;
                                                        }
                                                      }
                                                      {
#line 153
                                                      tmp___39 = tmp___38;
                                                      }
                                                    }
                                                    {
#line 153
                                                    tmp___40 = tmp___39;
                                                    }
                                                  }
                                                  {
#line 153
                                                  tmp___41 = tmp___40;
                                                  }
                                                }
                                                {
#line 153
                                                tmp___42 = tmp___41;
                                                }
                                              }
                                              {
#line 153
                                              tmp___43 = tmp___42;
                                              }
                                            }
                                            {
#line 153
                                            tmp___44 = tmp___43;
                                            }
                                          }
                                          {
#line 153
                                          tmp___45 = tmp___44;
                                          }
                                        }
                                        {
#line 153
                                        tmp___46 = tmp___45;
                                        }
                                      }
                                      {
#line 153
                                      tmp___47 = tmp___46;
                                      }
                                    }
                                    {
#line 153
                                    tmp___48 = tmp___47;
                                    }
                                  }
                                  {
#line 153
                                  tmp___49 = tmp___48;
                                  }
                                }
                                {
#line 153
                                tmp___50 = tmp___49;
                                }
                              }
                              {
#line 153
                              tmp___51 = tmp___50;
                              }
                            }
                            {
#line 153
                            tmp___52 = tmp___51;
                            }
                          }
                          {
#line 153
                          tmp___53 = tmp___52;
                          }
                        }
                        {
#line 153
                        tmp___54 = tmp___53;
                        }
                      }
                      {
#line 153
                      tmp___55 = tmp___54;
                      }
                    }
                    {
#line 153
                    tmp___56 = tmp___55;
                    }
                  }
                  {
#line 153
                  tmp___57 = tmp___56;
                  }
                }
                {
#line 153
                tmp___58 = tmp___57;
                }
              }
              {
#line 153
              tmp___59 = tmp___58;
              }
            }
            {
#line 153
            tmp___60 = tmp___59;
            }
          }
          {
#line 153
          tmp___61 = tmp___60;
          }
        }
        {
#line 153
        tmp___62 = tmp___61;
        }
      }
      {
#line 153
      tmp___63 = tmp___62;
      }
    }
#line 153
    return (tmp___63);
  }
#line 156
  if (size > 64U) {
#line 156
    if (size <= 96U) {
#line 157
      return (1);
    }
  }
#line 158
  if (size > 128U) {
#line 158
    if (size <= 192U) {
#line 159
      return (2);
    }
  }
#line 161
  if (size <= 8U) {
#line 161
    return (3);
  }
#line 162
  if (size <= 16U) {
#line 162
    return (4);
  }
#line 163
  if (size <= 32U) {
#line 163
    return (5);
  }
#line 164
  if (size <= 64U) {
#line 164
    return (6);
  }
#line 165
  if (size <= 128U) {
#line 165
    return (7);
  }
#line 166
  if (size <= 256U) {
#line 166
    return (8);
  }
#line 167
  if (size <= 512U) {
#line 167
    return (9);
  }
#line 168
  if (size <= 1024U) {
#line 168
    return (10);
  }
#line 169
  if (size <= 2048U) {
#line 169
    return (11);
  }
#line 170
  if (size <= 4096U) {
#line 170
    return (12);
  }
#line 175
  if (size <= 8192U) {
#line 175
    return (13);
  }
#line 176
  if (size <= 16384U) {
#line 176
    return (14);
  }
#line 177
  if (size <= 32768U) {
#line 177
    return (15);
  }
#line 178
  if (size <= 65536U) {
#line 178
    return (16);
  }
#line 179
  if (size <= 131072U) {
#line 179
    return (17);
  }
#line 180
  if (size <= 262144U) {
#line 180
    return (18);
  }
#line 181
  if (size <= 524288U) {
#line 181
    return (19);
  }
#line 182
  if (size <= 1048576U) {
#line 182
    return (20);
  }
#line 183
  if (size <= 2097152U) {
#line 183
    return (21);
  }
#line 184
  return (-1);
}
}
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static struct kmem_cache *kmalloc_slab(size_t size ) 
{ int index ;
  int tmp ;

  {
  {
#line 203
  tmp = kmalloc_index(size);
#line 203
  index = tmp;
  }
#line 205
  if (index == 0) {
#line 206
    return ((struct kmem_cache *)((void *)0));
  }
#line 208
  return (& kmalloc_caches[index]);
}
}
#line 218
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 219
extern void *__kmalloc(size_t size , gfp_t flags ) ;
#line 224 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static void *kmem_cache_alloc_notrace(struct kmem_cache *s , gfp_t gfpflags ) 
{ void *tmp ;

  {
  {
#line 227
  tmp = kmem_cache_alloc(s, gfpflags);
  }
#line 227
  return (tmp);
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static void *kmalloc_large(size_t size , gfp_t flags ) 
{ unsigned int order ;
  int tmp ;
  void *ret ;
  unsigned long tmp___0 ;

  {
  {
#line 233
  tmp = get_order((unsigned long )size);
#line 233
  order = (unsigned int )tmp;
#line 234
  tmp___0 = __get_free_pages(flags | 16384U, order);
#line 234
  ret = (void *)tmp___0;
  }
  __here: 
  {
#line 236
  trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )((1UL << 12) << order),
                flags);
  }
#line 238
  return (ret);
}
}
#line 241 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slub_def.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *ret ;
  void *tmp ;
  struct kmem_cache *s ;
  struct kmem_cache *tmp___0 ;
  void *tmp___1 ;

  {
#line 245
  if (0) {
#line 246
    if ((unsigned long )size > 2UL * (1UL << 12)) {
      {
#line 247
      tmp = kmalloc_large(size, flags);
      }
#line 247
      return (tmp);
    }
#line 249
    if (! (flags & 1U)) {
      {
#line 250
      tmp___0 = kmalloc_slab(size);
#line 250
      s = tmp___0;
      }
#line 252
      if (! s) {
#line 253
        return ((void *)16);
      }
      {
#line 255
      ret = kmem_cache_alloc_notrace(s, flags);
      }
      __here: 
      {
#line 257
      trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )s->size,
                    flags);
      }
#line 259
      return (ret);
    }
  }
  {
#line 262
  tmp___1 = __kmalloc(size, flags);
  }
#line 262
  return (tmp___1);
}
}
#line 211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
#line 213
  if (size != 0U) {
#line 213
    if ((unsigned long )n > 0xffffffffUL / (unsigned long )size) {
#line 214
      return ((void *)0);
    }
  }
  {
#line 215
  tmp = __kmalloc(n * size, flags | 32768U);
  }
#line 215
  return (tmp);
}
}
#line 229 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
#line 231
  tmp = kmalloc(size, flags);
  }
#line 231
  return (tmp);
}
}
#line 234 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *__kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
#line 236
  tmp = __kmalloc(size, flags);
  }
#line 236
  return (tmp);
}
}
#line 241 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kmem_cache_alloc_node(struct kmem_cache *cachep , gfp_t flags ,
                                            int node ) 
{ void *tmp ;

  {
  {
#line 244
  tmp = kmem_cache_alloc(cachep, flags);
  }
#line 244
  return (tmp);
}
}
#line 257
extern void *__kmalloc_track_caller(size_t  , gfp_t  , unsigned long  ) ;
#line 294 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ void *tmp ;

  {
  {
#line 296
  tmp = kmem_cache_alloc(k, flags | 32768U);
  }
#line 296
  return (tmp);
}
}
#line 304 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
#line 306
  tmp = kmalloc(size, flags | 32768U);
  }
#line 306
  return (tmp);
}
}
#line 315 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/slab.h"
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
#line 317
  tmp = kmalloc_node(size, flags | 32768U, node);
  }
#line 317
  return (tmp);
}
}
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu.h"
extern void *pcpu_base_addr ;
#line 64
extern size_t pcpu_setup_first_chunk(struct page *(*get_page_fn)(unsigned int cpu ,
                                                                 int pageno ) , size_t static_size ,
                                     size_t reserved_size , ssize_t dyn_size , ssize_t unit_size ,
                                     void *base_addr , void (*populate_pte_fn)(unsigned long addr ) )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 70
extern ssize_t pcpu_embed_first_chunk(size_t static_size , size_t reserved_size ,
                                      ssize_t dyn_size , ssize_t unit_size )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 81
extern void *__alloc_reserved_percpu(size_t size , size_t align ) ;
#line 99
extern void *__alloc_percpu(size_t size , size_t align ) ;
#line 100
extern void free_percpu(void *__pdata ) ;
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_inc(local_t *l ) 
{ 

  {
  {
#line 21
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
#line 23
  return;
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_dec(local_t *l ) 
{ 

  {
  {
#line 27
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
#line 29
  return;
}
}
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_add(long i , local_t *l ) 
{ 

  {
  {
#line 33
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
#line 36
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static void local_sub(long i , local_t *l ) 
{ 

  {
  {
#line 40
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
#line 43
  return;
}
}
#line 54 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_sub_and_test(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
#line 58
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%2,%0; sete %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
#line 61
  return ((int )c);
}
}
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_dec_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
#line 76
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
#line 79
  return ((int )c != 0);
}
}
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_inc_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
#line 94
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
#line 97
  return ((int )c != 0);
}
}
#line 109 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static int local_add_negative(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
#line 113
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%2,%0; sets %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
#line 116
  return ((int )c);
}
}
#line 126 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static long local_add_return(long i , local_t *l ) 
{ long __i ;

  {
  {
#line 135
  __i = i;
#line 136
  __asm__  volatile   (" "
                       "xaddl"
                       " "
                       "%0, %1;": "+r" (i), "+m" (l->a.counter): : "memory");
  }
#line 139
  return (i + __i);
}
}
#line 151 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/local.h"
__inline static long local_sub_return(long i , local_t *l ) 
{ long tmp ;

  {
  {
#line 153
  tmp = local_add_return(- i, l);
  }
#line 153
  return (tmp);
}
}
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
extern int init_module(void) ;
#line 68
extern void cleanup_module(void) ;
#line 73
extern struct exception_table_entry  const  *search_extable(struct exception_table_entry  const  *first ,
                                                            struct exception_table_entry  const  *last ,
                                                            unsigned long value ) ;
#line 77
extern void sort_extable(struct exception_table_entry *start , struct exception_table_entry *finish ) ;
#line 79
extern void sort_main_extable(void) ;
#line 165
extern struct exception_table_entry  const  *search_exception_tables(unsigned long add ) ;
#line 172
extern void *__symbol_get(char const   *symbol ) ;
#line 173
extern void *__symbol_get_gpl(char const   *symbol ) ;
#line 362
extern struct mutex module_mutex ;
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int module_is_live(struct module *mod ) 
{ 

  {
#line 369
  return ((unsigned int )mod->state != 2U);
}
}
#line 372
extern struct module *__module_text_address(unsigned long addr ) ;
#line 373
extern struct module *__module_address(unsigned long addr ) ;
#line 374
extern bool is_module_address(unsigned long addr ) ;
#line 375
extern bool is_module_text_address(unsigned long addr ) ;
#line 377 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int within_module_core(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
#line 379
  if ((unsigned long )mod->module_core <= addr) {
#line 379
    if (addr < (unsigned long )mod->module_core + (unsigned long )mod->core_size) {
      {
#line 379
      tmp = 1;
      }
    } else {
      {
#line 379
      tmp = 0;
      }
    }
  } else {
    {
#line 379
    tmp = 0;
    }
  }
#line 379
  return (tmp);
}
}
#line 383 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int within_module_init(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
#line 385
  if ((unsigned long )mod->module_init <= addr) {
#line 385
    if (addr < (unsigned long )mod->module_init + (unsigned long )mod->init_size) {
      {
#line 385
      tmp = 1;
      }
    } else {
      {
#line 385
      tmp = 0;
      }
    }
  } else {
    {
#line 385
    tmp = 0;
    }
  }
#line 385
  return (tmp);
}
}
#line 390
extern struct module *find_module(char const   *name ) ;
#line 404
extern struct kernel_symbol  const  *find_symbol(char const   *name , struct module **owner ,
                                                 unsigned long const   **crc , bool gplok ,
                                                 bool warn ) ;
#line 411
extern bool each_symbol(bool (*fn)(struct symsearch  const  *arr , struct module *owner ,
                                   unsigned int symnum , void *data ) , void *data ) ;
#line 416
extern int module_get_kallsym(unsigned int symnum , unsigned long *value , char *type ,
                              char *name , char *module_name , int *exported ) ;
#line 420
extern unsigned long module_kallsyms_lookup_name(char const   *name ) ;
#line 422
extern int module_kallsyms_on_each_symbol(int (*fn)(void * , char const   * , struct module * ,
                                                    unsigned long  ) , void *data ) ;
#line 426
extern  __attribute__((__noreturn__)) void __module_put_and_exit(struct module *mod ,
                                                                 long code ) ;
#line 431
extern unsigned int module_refcount(struct module *mod ) ;
#line 432
extern void __symbol_put(char const   *symbol ) ;
#line 434
extern void symbol_put_addr(void *addr ) ;
#line 436 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static local_t *__module_ref_addr(struct module *mod , int cpu ) 
{ 

  {
#line 439
  return ((local_t *)(mod->refptr + __per_cpu_offset[cpu]));
}
}
#line 447 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static void __module_get(struct module *module ) 
{ int ret__ ;
  local_t *tmp ;

  {
#line 449
  if (module) {
    {
#line 450
    while (1) {
      while_92_continue: /* CIL Label */ ;
      goto while_92_break;
    }
    while_92_break: /* CIL Label */ ;
    }
#line 450
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_93_1;
    } else {
#line 450
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_93_2;
      } else {
#line 450
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_93_4;
        } else {
#line 450
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_93_8;
          } else {
            {
            goto switch_93_default;
#line 450
            if (0) {
              switch_93_1: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_2: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_4: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_8: /* CIL Label */ 
              {
#line 450
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_93_break;
              switch_93_default: /* CIL Label */ 
              {
#line 450
              __bad_percpu_size();
              }
            } else {
              switch_93_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 450
    tmp = __module_ref_addr(module, ret__);
#line 450
    local_inc(tmp);
    }
    {
#line 451
    while (1) {
      while_94_continue: /* CIL Label */ ;
      goto while_94_break;
    }
    while_94_break: /* CIL Label */ ;
    }
  }
#line 453
  return;
}
}
#line 455 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/module.h"
__inline static int try_module_get(struct module *module ) 
{ int ret ;
  unsigned int cpu ;
  int ret__ ;
  local_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 457
  ret = 1;
  }
#line 459
  if (module) {
    {
#line 460
    while (1) {
      while_95_continue: /* CIL Label */ ;
      goto while_95_break;
    }
    while_95_break: /* CIL Label */ ;
    }
#line 460
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_96_1;
    } else {
#line 460
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_96_2;
      } else {
#line 460
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_96_4;
        } else {
#line 460
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_96_8;
          } else {
            {
            goto switch_96_default;
#line 460
            if (0) {
              switch_96_1: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_2: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_4: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_8: /* CIL Label */ 
              {
#line 460
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_96_break;
              switch_96_default: /* CIL Label */ 
              {
#line 460
              __bad_percpu_size();
              }
            } else {
              switch_96_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
#line 460
    cpu = (unsigned int )ret__;
#line 461
    tmp___0 = module_is_live(module);
    }
#line 461
    if (tmp___0) {
      {
#line 461
      tmp___1 = 1;
      }
    } else {
      {
#line 461
      tmp___1 = 0;
      }
    }
    {
#line 461
    tmp___2 = __builtin_expect((long )tmp___1, 1L);
    }
#line 461
    if (tmp___2) {
      {
#line 462
      tmp = __module_ref_addr(module, (int )cpu);
#line 462
      local_inc(tmp);
      }
    } else {
      {
#line 464
      ret = 0;
      }
    }
    {
#line 465
    while (1) {
      while_97_continue: /* CIL Label */ ;
      goto while_97_break;
    }
    while_97_break: /* CIL Label */ ;
    }
  }
#line 467
  return (ret);
}
}
#line 470
extern void module_put(struct module *module ) ;
#line 487
extern int use_module(struct module *a , struct module *b ) ;
#line 499
extern char const   *module_address_lookup(unsigned long addr , unsigned long *symbolsize ,
                                           unsigned long *offset , char **modname ,
                                           char *namebuf ) ;
#line 504
extern int lookup_module_symbol_name(unsigned long addr , char *symname ) ;
#line 505
extern int lookup_module_symbol_attrs(unsigned long addr , unsigned long *size , unsigned long *offset ,
                                      char *modname , char *name ) ;
#line 508
extern struct exception_table_entry  const  *search_module_extables(unsigned long addr ) ;
#line 510
extern int register_module_notifier(struct notifier_block *nb ) ;
#line 511
extern int unregister_module_notifier(struct notifier_block *nb ) ;
#line 513
extern void print_modules(void) ;
#line 515
extern void module_update_markers(void) ;
#line 517
extern void module_update_tracepoints(void) ;
#line 518
extern int module_get_iter_tracepoints(struct tracepoint_iter *iter ) ;
#line 650
extern struct kset *module_kset ;
#line 651
extern struct kobj_type module_ktype ;
#line 652
extern int module_sysfs_initialized ;
#line 654
extern int mod_sysfs_init(struct module *mod ) ;
#line 655
extern int mod_sysfs_setup(struct module *mod , struct kernel_param *kparam , unsigned int num_params ) ;
#line 658
extern int module_add_modinfo_attrs(struct module *mod ) ;
#line 659
extern void module_remove_modinfo_attrs(struct module *mod ) ;
#line 108 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
extern struct resource ioport_resource ;
#line 109
extern struct resource iomem_resource ;
#line 111
extern int request_resource(struct resource *root , struct resource *new ) ;
#line 112
extern int release_resource(struct resource *new ) ;
#line 113
extern void reserve_region_with_split(struct resource *root , resource_size_t start ,
                                      resource_size_t end , char const   *name ) ;
#line 116
extern int insert_resource(struct resource *parent , struct resource *new ) ;
#line 117
extern void insert_resource_expand_to_fit(struct resource *root , struct resource *new ) ;
#line 118
extern int allocate_resource(struct resource *root , struct resource *new , resource_size_t size ,
                             resource_size_t min , resource_size_t max , resource_size_t align ,
                             void (*alignf)(void * , struct resource * , resource_size_t  ,
                                            resource_size_t  ) , void *alignf_data ) ;
#line 124
extern int adjust_resource(struct resource *res , resource_size_t start , resource_size_t size ) ;
#line 126
extern resource_size_t resource_alignment(struct resource *res ) ;
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
__inline static resource_size_t resource_size(struct resource *res ) 
{ 

  {
#line 129
  return ((res->end - res->start) + 1U);
}
}
#line 131 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
__inline static unsigned long resource_type(struct resource *res ) 
{ 

  {
#line 133
  return (res->flags & 3840UL);
}
}
#line 144
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
#line 154
extern int __check_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 155
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
#line 158 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ioport.h"
__inline static int check_region(resource_size_t s , resource_size_t n ) 
{ int tmp ;

  {
  {
#line 161
  tmp = __check_region(& ioport_resource, s, n);
  }
#line 161
  return (tmp);
}
}
#line 171
extern struct resource *__devm_request_region(struct device *dev , struct resource *parent ,
                                              resource_size_t start , resource_size_t n ,
                                              char const   *name ) ;
#line 180
extern void __devm_release_region(struct device *dev , struct resource *parent , resource_size_t start ,
                                  resource_size_t n ) ;
#line 182
extern int iomem_map_sanity_check(resource_size_t addr , unsigned long size ) ;
#line 183
extern int iomem_is_exclusive(u64 addr ) ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/klist.h"
extern void klist_init(struct klist *k , void (*get)(struct klist_node * ) , void (*put)(struct klist_node * ) ) ;
#line 45
extern void klist_add_tail(struct klist_node *n , struct klist *k ) ;
#line 46
extern void klist_add_head(struct klist_node *n , struct klist *k ) ;
#line 47
extern void klist_add_after(struct klist_node *n , struct klist_node *pos ) ;
#line 48
extern void klist_add_before(struct klist_node *n , struct klist_node *pos ) ;
#line 50
extern void klist_del(struct klist_node *n ) ;
#line 51
extern void klist_remove(struct klist_node *n ) ;
#line 53
extern int klist_node_attached(struct klist_node *n ) ;
#line 62
extern void klist_iter_init(struct klist *k , struct klist_iter *i ) ;
#line 63
extern void klist_iter_init_node(struct klist *k , struct klist_iter *i , struct klist_node *n ) ;
#line 65
extern void klist_iter_exit(struct klist_iter *i ) ;
#line 66
extern struct klist_node *klist_next(struct klist_iter *i ) ;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/semaphore.h"
static struct lock_class_key __key  ;
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/semaphore.h"
__inline static void sema_init(struct semaphore *sem , int val ) 
{ struct semaphore __constr_expr_0 ;

  {
  {
#line 35
  __constr_expr_0.lock.raw_lock.slock = 0U;
#line 35
  __constr_expr_0.lock.magic = 3735899821U;
#line 35
  __constr_expr_0.lock.owner_cpu = 4294967295U;
#line 35
  __constr_expr_0.lock.owner = (void *)-1L;
#line 35
  __constr_expr_0.count = (unsigned int )val;
#line 35
  __constr_expr_0.wait_list.next = & sem->wait_list;
#line 35
  __constr_expr_0.wait_list.prev = & sem->wait_list;
#line 35
  *sem = __constr_expr_0;
  }
  {
#line 36
  while (1) {
    while_98_continue: /* CIL Label */ ;
    goto while_98_break;
  }
  while_98_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 42
extern void down(struct semaphore *sem ) ;
#line 43
extern int down_interruptible(struct semaphore *sem ) ;
#line 44
extern int down_killable(struct semaphore *sem ) ;
#line 45
extern int down_trylock(struct semaphore *sem ) ;
#line 46
extern int down_timeout(struct semaphore *sem , long jiffies ) ;
#line 47
extern void up(struct semaphore *sem ) ;
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
extern int bus_create_file(struct bus_type * , struct bus_attribute * ) ;
#line 50
extern void bus_remove_file(struct bus_type * , struct bus_attribute * ) ;
#line 74
extern int bus_register(struct bus_type *bus ) ;
#line 75
extern void bus_unregister(struct bus_type *bus ) ;
#line 77
extern int bus_rescan_devices(struct bus_type *bus ) ;
#line 81
extern int bus_for_each_dev(struct bus_type *bus , struct device *start , void *data ,
                            int (*fn)(struct device *dev , void *data ) ) ;
#line 83
extern struct device *bus_find_device(struct bus_type *bus , struct device *start ,
                                      void *data , int (*match)(struct device *dev ,
                                                                void *data ) ) ;
#line 86
extern struct device *bus_find_device_by_name(struct bus_type *bus , struct device *start ,
                                              char const   *name ) ;
#line 90
extern int bus_for_each_drv(struct bus_type *bus , struct device_driver *start , void *data ,
                            int (*fn)(struct device_driver * , void * ) ) ;
#line 94
extern void bus_sort_breadthfirst(struct bus_type *bus , int (*compare)(struct device  const  *a ,
                                                                        struct device  const  *b ) ) ;
#line 105
extern int bus_register_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
#line 107
extern int bus_unregister_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
#line 120
extern struct kset *bus_get_kset(struct bus_type *bus ) ;
#line 121
extern struct klist *bus_get_device_klist(struct bus_type *bus ) ;
#line 143
extern int driver_register(struct device_driver *drv ) ;
#line 144
extern void driver_unregister(struct device_driver *drv ) ;
#line 146
extern struct device_driver *get_driver(struct device_driver *drv ) ;
#line 147
extern void put_driver(struct device_driver *drv ) ;
#line 148
extern struct device_driver *driver_find(char const   *name , struct bus_type *bus ) ;
#line 150
extern int driver_probe_done(void) ;
#line 151
extern void wait_for_device_probe(void) ;
#line 167
extern int driver_create_file(struct device_driver *driver , struct driver_attribute *attr ) ;
#line 169
extern void driver_remove_file(struct device_driver *driver , struct driver_attribute *attr ) ;
#line 172
extern int driver_add_kobj(struct device_driver *drv , struct kobject *kobj , char const   *fmt 
                           , ...) ;
#line 176
extern int driver_for_each_device(struct device_driver *drv , struct device *start ,
                                  void *data , int (*fn)(struct device *dev , void * ) ) ;
#line 181
extern struct device *driver_find_device(struct device_driver *drv , struct device *start ,
                                         void *data , int (*match)(struct device *dev ,
                                                                   void *data ) ) ;
#line 213
extern struct kobject *sysfs_dev_block_kobj ;
#line 214
extern struct kobject *sysfs_dev_char_kobj ;
#line 215
extern int __class_register(struct class *class , struct lock_class_key *key ) ;
#line 217
extern void class_unregister(struct class *class ) ;
#line 227
extern void class_dev_iter_init(struct class_dev_iter *iter , struct class *class ,
                                struct device *start , struct device_type  const  *type ) ;
#line 231
extern struct device *class_dev_iter_next(struct class_dev_iter *iter ) ;
#line 232
extern void class_dev_iter_exit(struct class_dev_iter *iter ) ;
#line 234
extern int class_for_each_device(struct class *class , struct device *start , void *data ,
                                 int (*fn)(struct device *dev , void *data ) ) ;
#line 237
extern struct device *class_find_device(struct class *class , struct device *start ,
                                        void *data , int (*match)(struct device * ,
                                                                  void * ) ) ;
#line 250
extern int class_create_file(struct class *class , struct class_attribute  const  *attr ) ;
#line 252
extern void class_remove_file(struct class *class , struct class_attribute  const  *attr ) ;
#line 263
extern int class_interface_register(struct class_interface * ) ;
#line 264
extern void class_interface_unregister(struct class_interface * ) ;
#line 266
extern struct class *__class_create(struct module *owner , char const   *name , struct lock_class_key *key ) ;
#line 269
extern void class_destroy(struct class *cls ) ;
#line 312
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
#line 314
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
#line 316
extern int device_create_bin_file(struct device *dev , struct bin_attribute *attr ) ;
#line 318
extern void device_remove_bin_file(struct device *dev , struct bin_attribute *attr ) ;
#line 320
extern int device_schedule_callback_owner(struct device *dev , void (*func)(struct device *dev ) ,
                                          struct module *owner ) ;
#line 332
extern void *__devres_alloc(void (*release)(struct device *dev , void *res ) , size_t size ,
                            gfp_t gfp , char const   *name ) ;
#line 339
extern void devres_free(void *res ) ;
#line 340
extern void devres_add(struct device *dev , void *res ) ;
#line 341
extern void *devres_find(struct device *dev , void (*release)(struct device *dev ,
                                                              void *res ) , int (*match)(struct device *dev ,
                                                                                         void *res ,
                                                                                         void *match_data ) ,
                         void *match_data ) ;
#line 343
extern void *devres_get(struct device *dev , void *new_res , int (*match)(struct device *dev ,
                                                                          void *res ,
                                                                          void *match_data ) ,
                        void *match_data ) ;
#line 345
extern void *devres_remove(struct device *dev , void (*release)(struct device *dev ,
                                                                void *res ) , int (*match)(struct device *dev ,
                                                                                           void *res ,
                                                                                           void *match_data ) ,
                           void *match_data ) ;
#line 347
extern int devres_destroy(struct device *dev , void (*release)(struct device *dev ,
                                                               void *res ) , int (*match)(struct device *dev ,
                                                                                          void *res ,
                                                                                          void *match_data ) ,
                          void *match_data ) ;
#line 351
extern void *devres_open_group(struct device *dev , void *id , gfp_t gfp ) ;
#line 353
extern void devres_close_group(struct device *dev , void *id ) ;
#line 354
extern void devres_remove_group(struct device *dev , void *id ) ;
#line 355
extern int devres_release_group(struct device *dev , void *id ) ;
#line 358
extern void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) ;
#line 359
extern void devm_kfree(struct device *dev , void *p ) ;
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static void device_init_wakeup(struct device *dev , int val ) 
{ unsigned int tmp ;

  {
  {
#line 35
  tmp = (unsigned int )(! (! val));
#line 35
  dev->power.should_wakeup = tmp;
#line 35
  dev->power.can_wakeup = tmp;
  }
#line 36
  return;
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static void device_set_wakeup_capable(struct device *dev , int val ) 
{ 

  {
  {
#line 40
  dev->power.can_wakeup = (unsigned int )(! (! val));
  }
#line 41
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static int device_can_wakeup(struct device *dev ) 
{ 

  {
#line 45
  return ((int )dev->power.can_wakeup);
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static void device_set_wakeup_enable(struct device *dev , int val ) 
{ 

  {
  {
#line 50
  dev->power.should_wakeup = (unsigned int )(! (! val));
  }
#line 51
  return;
}
}
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pm_wakeup.h"
__inline static int device_may_wakeup(struct device *dev ) 
{ int tmp ;

  {
#line 55
  if (dev->power.can_wakeup) {
#line 55
    if (dev->power.should_wakeup) {
      {
#line 55
      tmp = 1;
      }
    } else {
      {
#line 55
      tmp = 0;
      }
    }
  } else {
    {
#line 55
    tmp = 0;
    }
  }
#line 55
  return (tmp);
}
}
#line 425 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ char const   *tmp ;

  {
  {
#line 427
  tmp = kobject_name(& dev->kobj);
  }
#line 427
  return (tmp);
}
}
#line 430
extern int ( /* format attribute */  dev_set_name)(struct device *dev , char const   *name 
                                                   , ...) ;
#line 443 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static int dev_to_node(struct device *dev ) 
{ 

  {
#line 445
  return (-1);
}
}
#line 447 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void set_dev_node(struct device *dev , int node ) 
{ 

  {
#line 449
  return;
}
}
#line 452 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 

  {
#line 454
  return ((void *)dev->driver_data);
}
}
#line 457 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 

  {
  {
#line 459
  dev->driver_data = data;
  }
#line 460
  return;
}
}
#line 462 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static unsigned int dev_get_uevent_suppress(struct device  const  *dev ) 
{ 

  {
#line 464
  return ((unsigned int )dev->kobj.uevent_suppress);
}
}
#line 467 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static void dev_set_uevent_suppress(struct device *dev , int val ) 
{ 

  {
  {
#line 469
  dev->kobj.uevent_suppress = (unsigned int )val;
  }
#line 470
  return;
}
}
#line 472 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static int device_is_registered(struct device *dev ) 
{ 

  {
#line 474
  return ((int )dev->kobj.state_in_sysfs);
}
}
#line 477
extern void driver_init(void) ;
#line 482
extern int device_register(struct device *dev ) ;
#line 483
extern void device_unregister(struct device *dev ) ;
#line 484
extern void device_initialize(struct device *dev ) ;
#line 485
extern int device_add(struct device *dev ) ;
#line 486
extern void device_del(struct device *dev ) ;
#line 487
extern int device_for_each_child(struct device *dev , void *data , int (*fn)(struct device *dev ,
                                                                             void *data ) ) ;
#line 489
extern struct device *device_find_child(struct device *dev , void *data , int (*match)(struct device *dev ,
                                                                                       void *data ) ) ;
#line 491
extern int device_rename(struct device *dev , char *new_name ) ;
#line 492
extern int device_move(struct device *dev , struct device *new_parent , enum dpm_order dpm_order ) ;
#line 498
extern struct device *__root_device_register(char const   *name , struct module *owner ) ;
#line 500 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/device.h"
__inline static struct device *root_device_register(char const   *name ) 
{ struct device *tmp ;

  {
  {
#line 502
  tmp = __root_device_register(name, (struct module *)0);
  }
#line 502
  return (tmp);
}
}
#line 504
extern void root_device_unregister(struct device *root ) ;
#line 510
extern int device_bind_driver(struct device *dev ) ;
#line 511
extern void device_release_driver(struct device *dev ) ;
#line 512
extern int device_attach(struct device *dev ) ;
#line 513
extern int driver_attach(struct device_driver *drv ) ;
#line 514
extern int device_reprobe(struct device *dev ) ;
#line 519
extern struct device *device_create_vargs(struct class *cls , struct device *parent ,
                                          dev_t devt , void *drvdata , char const   *fmt ,
                                          va_list vargs ) ;
#line 525
extern struct device *( /* format attribute */  device_create)(struct class *cls ,
                                                               struct device *parent ,
                                                               dev_t devt , void *drvdata ,
                                                               char const   *fmt 
                                                               , ...) ;
#line 529
extern void device_destroy(struct class *cls , dev_t devt ) ;
#line 537
extern int (*platform_notify)(struct device *dev ) ;
#line 539
extern int (*platform_notify_remove)(struct device *dev ) ;
#line 546
extern struct device *get_device(struct device *dev ) ;
#line 547
extern void put_device(struct device *dev ) ;
#line 552
extern void device_shutdown(void) ;
#line 555
extern void sysdev_shutdown(void) ;
#line 558
extern char const   *dev_driver_string(struct device  const  *dev ) ;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ unsigned char ret ;

  {
  {
#line 20
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
  }
#line 20
  return (ret);
}
}
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned short readw(void const volatile   *addr ) 
{ unsigned short ret ;

  {
  {
#line 21
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
  }
#line 21
  return (ret);
}
}
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
  {
#line 22
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
  }
#line 22
  return (ret);
}
}
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned char __readb(void const volatile   *addr ) 
{ unsigned char ret ;

  {
  {
#line 24
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)));
  }
#line 24
  return (ret);
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned short __readw(void const volatile   *addr ) 
{ unsigned short ret ;

  {
  {
#line 25
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)));
  }
#line 25
  return (ret);
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int __readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
  {
#line 26
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
  }
#line 26
  return (ret);
}
}
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
  {
#line 28
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
  }
#line 28
  return;
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 

  {
  {
#line 29
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
  }
#line 29
  return;
}
}
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 

  {
  {
#line 30
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
  }
#line 30
  return;
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void __writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
  {
#line 32
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)));
  }
#line 32
  return;
}
}
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void __writew(unsigned short val , void volatile   *addr ) 
{ 

  {
  {
#line 33
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)));
  }
#line 33
  return;
}
}
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 

  {
  {
#line 34
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
  }
#line 34
  return;
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static __u64 readq(void const volatile   *addr ) 
{ u32 const volatile   *p ;
  u32 low ;
  u32 high ;

  {
  {
#line 58
  p = (u32 const volatile   *)addr;
#line 61
  low = readl((void const volatile   *)p);
#line 62
  high = readl((void const volatile   *)(p + 1));
  }
#line 64
  return ((unsigned long long )low + ((unsigned long long )high << 32));
}
}
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void writeq(__u64 val , void volatile   *addr ) 
{ 

  {
  {
#line 69
  writel((unsigned int )val, addr);
#line 70
  writel((unsigned int )(val >> 32), addr + 4);
  }
#line 71
  return;
}
}
#line 97 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static phys_addr_t virt_to_phys(void volatile   *address ) 
{ 

  {
#line 99
  return ((unsigned int )((unsigned long )address - 3221225472UL));
}
}
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void *phys_to_virt(phys_addr_t address ) 
{ 

  {
#line 117
  return ((void *)((unsigned long )address + 3221225472UL));
}
}
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static unsigned int isa_virt_to_bus(void volatile   *address ) 
{ phys_addr_t tmp ;

  {
  {
#line 132
  tmp = virt_to_phys(address);
  }
#line 132
  return (tmp);
}
}
#line 160
extern void *ioremap_nocache(resource_size_t offset , unsigned long size ) ;
#line 161
extern void *ioremap_cache(resource_size_t offset , unsigned long size ) ;
#line 162
extern void *ioremap_prot(resource_size_t offset , unsigned long size , unsigned long prot_val ) ;
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ void *tmp ;

  {
  {
#line 170
  tmp = ioremap_nocache(offset, size);
  }
#line 170
  return (tmp);
}
}
#line 173
extern void iounmap(void volatile   *addr ) ;
#line 28 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/iomap.h"
extern unsigned int ioread8(void * ) ;
#line 29
extern unsigned int ioread16(void * ) ;
#line 30
extern unsigned int ioread16be(void * ) ;
#line 31
extern unsigned int ioread32(void * ) ;
#line 32
extern unsigned int ioread32be(void * ) ;
#line 34
extern void iowrite8(u8  , void * ) ;
#line 35
extern void iowrite16(u16  , void * ) ;
#line 36
extern void iowrite16be(u16  , void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 38
extern void iowrite32be(u32  , void * ) ;
#line 51
extern void ioread8_rep(void *port , void *buf , unsigned long count ) ;
#line 52
extern void ioread16_rep(void *port , void *buf , unsigned long count ) ;
#line 53
extern void ioread32_rep(void *port , void *buf , unsigned long count ) ;
#line 55
extern void iowrite8_rep(void *port , void const   *buf , unsigned long count ) ;
#line 56
extern void iowrite16_rep(void *port , void const   *buf , unsigned long count ) ;
#line 57
extern void iowrite32_rep(void *port , void const   *buf , unsigned long count ) ;
#line 60
extern void *ioport_map(unsigned long port , unsigned int nr ) ;
#line 61
extern void ioport_unmap(void * ) ;
#line 69
extern void *pci_iomap(struct pci_dev *dev , int bar , unsigned long max ) ;
#line 70
extern void pci_iounmap(struct pci_dev *dev , void * ) ;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmalloc.h"
extern void vm_unmap_ram(void const   *mem , unsigned int count ) ;
#line 41
extern void *vm_map_ram(struct page **pages , unsigned int count , int node , pgprot_t prot ) ;
#line 43
extern void vm_unmap_aliases(void) ;
#line 46
extern void vmalloc_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 53
extern void *vmalloc(unsigned long size ) ;
#line 54
extern void *vmalloc_user(unsigned long size ) ;
#line 55
extern void *vmalloc_node(unsigned long size , int node ) ;
#line 56
extern void *vmalloc_exec(unsigned long size ) ;
#line 57
extern void *vmalloc_32(unsigned long size ) ;
#line 58
extern void *vmalloc_32_user(unsigned long size ) ;
#line 59
extern void *__vmalloc(unsigned long size , gfp_t gfp_mask , pgprot_t prot ) ;
#line 60
extern void *__vmalloc_area(struct vm_struct *area , gfp_t gfp_mask , pgprot_t prot ) ;
#line 62
extern void vfree(void const   *addr ) ;
#line 64
extern void *vmap(struct page **pages , unsigned int count , unsigned long flags ,
                  pgprot_t prot ) ;
#line 66
extern void vunmap(void const   *addr ) ;
#line 68
extern int remap_vmalloc_range(struct vm_area_struct *vma , void *addr , unsigned long pgoff ) ;
#line 70
extern void vmalloc_sync_all(void) ;
#line 76 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmalloc.h"
__inline static size_t get_vm_area_size(struct vm_struct  const  *area ) 
{ 

  {
#line 79
  return ((unsigned int )(area->size - (unsigned long const   )(1UL << 12)));
}
}
#line 82
extern struct vm_struct *get_vm_area(unsigned long size , unsigned long flags ) ;
#line 83
extern struct vm_struct *get_vm_area_caller(unsigned long size , unsigned long flags ,
                                            void *caller ) ;
#line 85
extern struct vm_struct *__get_vm_area(unsigned long size , unsigned long flags ,
                                       unsigned long start , unsigned long end ) ;
#line 87
extern struct vm_struct *__get_vm_area_caller(unsigned long size , unsigned long flags ,
                                              unsigned long start , unsigned long end ,
                                              void *caller ) ;
#line 91
extern struct vm_struct *get_vm_area_node(unsigned long size , unsigned long flags ,
                                          int node , gfp_t gfp_mask ) ;
#line 94
extern struct vm_struct *remove_vm_area(void const   *addr ) ;
#line 96
extern int map_vm_area(struct vm_struct *area , pgprot_t prot , struct page ***pages ) ;
#line 98
extern int map_kernel_range_noflush(unsigned long start , unsigned long size , pgprot_t prot ,
                                    struct page **pages ) ;
#line 100
extern void unmap_kernel_range_noflush(unsigned long addr , unsigned long size ) ;
#line 101
extern void unmap_kernel_range(unsigned long addr , unsigned long size ) ;
#line 104
extern struct vm_struct *alloc_vm_area(size_t size ) ;
#line 105
extern void free_vm_area(struct vm_struct *area ) ;
#line 108
extern long vread(char *buf , char *addr , unsigned long count ) ;
#line 109
extern long vwrite(char *buf , char *addr , unsigned long count ) ;
#line 114
extern rwlock_t vmlist_lock ;
#line 115
extern struct vm_struct *vmlist ;
#line 116
extern void vm_area_register_early(struct vm_struct *vm , size_t align )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 54 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void memset_io(void volatile   *addr , unsigned char val , int count ) 
{ 

  {
  {
#line 57
  __memset_generic((void *)addr, (char )val, (unsigned int )count);
  }
#line 58
  return;
}
}
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void memcpy_fromio(void *dst , void const volatile   *src , int count ) 
{ 

  {
  {
#line 63
  __memcpy(dst, (void const   *)src, (unsigned int )count);
  }
#line 64
  return;
}
}
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void memcpy_toio(void volatile   *dst , void const   *src , int count ) 
{ 

  {
  {
#line 69
  __memcpy((void *)dst, src, (unsigned int )count);
  }
#line 70
  return;
}
}
#line 105
extern void native_io_delay(void) ;
#line 107
extern int io_delay_type ;
#line 108
extern void io_delay_init(void) ;
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void slow_down_io(void) 
{ 

  {
  {
#line 116
  native_io_delay();
  }
#line 122
  return;
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outb_local(unsigned char value , int port ) 
{ 

  {
  {
#line 192
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
#line 192
  return;
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned char inb_local(int port ) 
{ unsigned char value ;

  {
  {
#line 192
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
  }
#line 192
  return (value);
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outb_local_p(unsigned char value , int port ) 
{ 

  {
  {
#line 192
  outb_local(value, port);
#line 192
  slow_down_io();
  }
#line 192
  return;
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned char inb_local_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  {
#line 192
  tmp = inb_local(port);
#line 192
  value = tmp;
#line 192
  slow_down_io();
  }
#line 192
  return (value);
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outb(unsigned char value , int port ) 
{ 

  {
  {
#line 192
  outb_local(value, port);
  }
#line 192
  return;
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned char inb(int port ) 
{ unsigned char tmp ;

  {
  {
#line 192
  tmp = inb_local(port);
  }
#line 192
  return (tmp);
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outb_p(unsigned char value , int port ) 
{ 

  {
  {
#line 192
  outb(value, port);
#line 192
  slow_down_io();
  }
#line 192
  return;
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned char inb_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  {
#line 192
  tmp = inb(port);
#line 192
  value = tmp;
#line 192
  slow_down_io();
  }
#line 192
  return (value);
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outsb(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
#line 192
  __asm__  volatile   ("rep; outs"
                       "b": "+S" (addr), "+c" (count): "d" (port));
  }
#line 192
  return;
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void insb(int port , void *addr , unsigned long count ) 
{ 

  {
  {
#line 192
  __asm__  volatile   ("rep; ins"
                       "b": "+D" (addr), "+c" (count): "d" (port));
  }
#line 192
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outw_local(unsigned short value , int port ) 
{ 

  {
  {
#line 193
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
#line 193
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned short inw_local(int port ) 
{ unsigned short value ;

  {
  {
#line 193
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
  }
#line 193
  return (value);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outw_local_p(unsigned short value , int port ) 
{ 

  {
  {
#line 193
  outw_local(value, port);
#line 193
  slow_down_io();
  }
#line 193
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned short inw_local_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  {
#line 193
  tmp = inw_local(port);
#line 193
  value = tmp;
#line 193
  slow_down_io();
  }
#line 193
  return (value);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outw(unsigned short value , int port ) 
{ 

  {
  {
#line 193
  outw_local(value, port);
  }
#line 193
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned short inw(int port ) 
{ unsigned short tmp ;

  {
  {
#line 193
  tmp = inw_local(port);
  }
#line 193
  return (tmp);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outw_p(unsigned short value , int port ) 
{ 

  {
  {
#line 193
  outw(value, port);
#line 193
  slow_down_io();
  }
#line 193
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned short inw_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  {
#line 193
  tmp = inw(port);
#line 193
  value = tmp;
#line 193
  slow_down_io();
  }
#line 193
  return (value);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outsw(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
#line 193
  __asm__  volatile   ("rep; outs"
                       "w": "+S" (addr), "+c" (count): "d" (port));
  }
#line 193
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void insw(int port , void *addr , unsigned long count ) 
{ 

  {
  {
#line 193
  __asm__  volatile   ("rep; ins"
                       "w": "+D" (addr), "+c" (count): "d" (port));
  }
#line 193
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outl_local(unsigned int value , int port ) 
{ 

  {
  {
#line 194
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
  }
#line 194
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned int inl_local(int port ) 
{ unsigned int value ;

  {
  {
#line 194
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
  }
#line 194
  return (value);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outl_local_p(unsigned int value , int port ) 
{ 

  {
  {
#line 194
  outl_local(value, port);
#line 194
  slow_down_io();
  }
#line 194
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned int inl_local_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  {
#line 194
  tmp = inl_local(port);
#line 194
  value = tmp;
#line 194
  slow_down_io();
  }
#line 194
  return (value);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outl(unsigned int value , int port ) 
{ 

  {
  {
#line 194
  outl_local(value, port);
  }
#line 194
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned int inl(int port ) 
{ unsigned int tmp ;

  {
  {
#line 194
  tmp = inl_local(port);
  }
#line 194
  return (tmp);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outl_p(unsigned int value , int port ) 
{ 

  {
  {
#line 194
  outl(value, port);
#line 194
  slow_down_io();
  }
#line 194
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static unsigned int inl_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  {
#line 194
  tmp = inl(port);
#line 194
  value = tmp;
#line 194
  slow_down_io();
  }
#line 194
  return (value);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void outsl(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
#line 194
  __asm__  volatile   ("rep; outs"
                       "l": "+S" (addr), "+c" (count): "d" (port));
  }
#line 194
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io_32.h"
__inline static void insl(int port , void *addr , unsigned long count ) 
{ 

  {
  {
#line 194
  __asm__  volatile   ("rep; ins"
                       "l": "+D" (addr), "+c" (count): "d" (port));
  }
#line 194
  return;
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/io.h"
extern void *xlate_dev_mem_ptr(unsigned long phys ) ;
#line 183
extern void unxlate_dev_mem_ptr(unsigned long phys , void *addr ) ;
#line 185
extern int ioremap_change_attr(unsigned long vaddr , unsigned long size , unsigned long prot_val ) ;
#line 187
extern void *ioremap_wc(resource_size_t offset , unsigned long size ) ;
#line 194
extern void early_ioremap_init(void) ;
#line 195
extern void early_ioremap_reset(void) ;
#line 196
extern void *early_ioremap(resource_size_t phys_addr , unsigned long size ) ;
#line 198
extern void *early_memremap(resource_size_t phys_addr , unsigned long size ) ;
#line 200
extern void early_iounmap(void *addr , unsigned long size ) ;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/io.h"
extern void __iowrite32_copy(void *to , void const   *from , size_t count ) ;
#line 28
extern void __iowrite64_copy(void *to , void const   *from , size_t count ) ;
#line 31
extern int ioremap_page_range(unsigned long addr , unsigned long end , unsigned long phys_addr ,
                              pgprot_t prot ) ;
#line 45
extern void *devm_ioport_map(struct device *dev , unsigned long port , unsigned int nr ) ;
#line 47
extern void devm_ioport_unmap(struct device *dev , void *addr ) ;
#line 61
extern void *devm_ioremap(struct device *dev , resource_size_t offset , unsigned long size ) ;
#line 63
extern void *devm_ioremap_nocache(struct device *dev , resource_size_t offset , unsigned long size ) ;
#line 65
extern void devm_iounmap(struct device *dev , void *addr ) ;
#line 66
extern int check_signature(void const volatile   *io_addr , unsigned char const   *signature ,
                           int length ) ;
#line 68
extern void devm_ioremap_release(struct device *dev , void *res ) ;
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static char const   *pci_slot_name(struct pci_slot  const  *slot ) 
{ char const   *tmp ;

  {
  {
#line 71
  tmp = kobject_name(& slot->kobj);
  }
#line 71
  return (tmp);
}
}
#line 291
extern struct pci_dev *alloc_pci_dev(void) ;
#line 297 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 

  {
#line 299
  return (pdev->error_state != 1U);
}
}
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static struct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *pci_dev ,
                                                               char cap ) 
{ struct pci_cap_saved_state *tmp ;
  struct hlist_node *pos ;
  struct hlist_node  const  *__mptr ;

  {
  {
#line 308
  pos = pci_dev->saved_cap_space.first;
  }
  {
#line 308
  while (1) {
    while_99_continue: /* CIL Label */ ;
#line 308
    if (pos) {
      {
#line 308
      prefetch((void const   *)pos->next);
#line 308
      __mptr = (struct hlist_node  const  *)pos;
#line 308
      tmp = (struct pci_cap_saved_state *)((char *)__mptr - (unsigned int )(& ((struct pci_cap_saved_state *)0)->next));
      }
    } else {
      goto while_99_break;
    }
#line 309
    if ((int )tmp->cap_nr == (int )cap) {
#line 310
      return (tmp);
    }
    {
#line 308
    pos = pos->next;
    }
  }
  while_99_break: /* CIL Label */ ;
  }
#line 312
  return ((struct pci_cap_saved_state *)((void *)0));
}
}
#line 315 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static void pci_add_saved_cap(struct pci_dev *pci_dev , struct pci_cap_saved_state *new_cap ) 
{ 

  {
  {
#line 318
  hlist_add_head(& new_cap->next, & pci_dev->saved_cap_space);
  }
#line 319
  return;
}
}
#line 364 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static bool pci_is_root_bus(struct pci_bus *pbus ) 
{ 

  {
#line 366
  return ((_Bool )(! pbus->parent));
}
}
#line 370 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static bool pci_dev_msi_enabled(struct pci_dev *pci_dev ) 
{ int tmp ;

  {
#line 372
  if (pci_dev->msi_enabled) {
    {
#line 372
    tmp = 1;
    }
  } else {
#line 372
    if (pci_dev->msix_enabled) {
      {
#line 372
      tmp = 1;
      }
    } else {
      {
#line 372
      tmp = 0;
      }
    }
  }
#line 372
  return ((_Bool )tmp);
}
}
#line 400
extern int raw_pci_read(unsigned int domain , unsigned int bus , unsigned int devfn ,
                        int reg , int len , u32 *val ) ;
#line 402
extern int raw_pci_write(unsigned int domain , unsigned int bus , unsigned int devfn ,
                         int reg , int len , u32 val ) ;
#line 536
extern struct bus_type pci_bus_type ;
#line 540
extern struct list_head pci_root_buses ;
#line 542
extern int no_pci_devices(void) ;
#line 544
extern void pcibios_fixup_bus(struct pci_bus * ) ;
#line 545
extern int pcibios_enable_device(struct pci_dev * , int mask ) ;
#line 546
extern char *pcibios_setup(char *str ) ;
#line 549
extern void pcibios_align_resource(void * , struct resource * , resource_size_t  ,
                                   resource_size_t  ) ;
#line 551
extern void pcibios_update_irq(struct pci_dev * , int irq ) ;
#line 555
extern struct pci_bus *pci_find_bus(int domain , int busnr ) ;
#line 556
extern void pci_bus_add_devices(struct pci_bus  const  *bus ) ;
#line 557
extern struct pci_bus *pci_scan_bus_parented(struct device *parent , int bus , struct pci_ops *ops ,
                                             void *sysdata ) ;
#line 559
__inline static struct pci_bus *pci_scan_bus(int bus , struct pci_ops *ops , void *sysdata )  __attribute__((__section__(".devinit.text"))) ;
#line 559 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static struct pci_bus *pci_scan_bus(int bus , struct pci_ops *ops , void *sysdata ) 
{ struct pci_bus *root_bus ;

  {
  {
#line 563
  root_bus = pci_scan_bus_parented((struct device *)((void *)0), bus, ops, sysdata);
  }
#line 564
  if (root_bus) {
    {
#line 565
    pci_bus_add_devices((struct pci_bus  const  *)root_bus);
    }
  }
#line 566
  return (root_bus);
}
}
#line 568
extern struct pci_bus *pci_create_bus(struct device *parent , int bus , struct pci_ops *ops ,
                                      void *sysdata ) ;
#line 570
extern struct pci_bus *pci_add_new_bus(struct pci_bus *parent , struct pci_dev *dev ,
                                       int busnr ) ;
#line 572
extern struct pci_slot *pci_create_slot(struct pci_bus *parent , int slot_nr , char const   *name ,
                                        struct hotplug_slot *hotplug ) ;
#line 575
extern void pci_destroy_slot(struct pci_slot *slot ) ;
#line 576
extern void pci_renumber_slot(struct pci_slot *slot , int slot_nr ) ;
#line 577
extern int pci_scan_slot(struct pci_bus *bus , int devfn ) ;
#line 578
extern struct pci_dev *pci_scan_single_device(struct pci_bus *bus , int devfn ) ;
#line 579
extern void pci_device_add(struct pci_dev *dev , struct pci_bus *bus ) ;
#line 580
extern unsigned int pci_scan_child_bus(struct pci_bus *bus ) ;
#line 581
extern int pci_bus_add_device(struct pci_dev *dev ) ;
#line 582
extern void pci_read_bridge_bases(struct pci_bus *child ) ;
#line 583
extern struct resource *pci_find_parent_resource(struct pci_dev  const  *dev , struct resource *res ) ;
#line 585
extern u8 pci_swizzle_interrupt_pin(struct pci_dev *dev , u8 pin ) ;
#line 586
extern int pci_get_interrupt_pin(struct pci_dev *dev , struct pci_dev **bridge ) ;
#line 587
extern u8 pci_common_swizzle(struct pci_dev *dev , u8 *pinp ) ;
#line 588
extern struct pci_dev *pci_dev_get(struct pci_dev *dev ) ;
#line 589
extern void pci_dev_put(struct pci_dev *dev ) ;
#line 590
extern void pci_remove_bus(struct pci_bus *b ) ;
#line 591
extern void pci_remove_bus_device(struct pci_dev *dev ) ;
#line 592
extern void pci_stop_bus_device(struct pci_dev *dev ) ;
#line 593
extern void pci_setup_cardbus(struct pci_bus *bus ) ;
#line 594
extern void pci_sort_breadthfirst(void) ;
#line 612
extern enum pci_lost_interrupt_reason pci_lost_interrupt(struct pci_dev *dev ) ;
#line 613
extern int pci_find_capability(struct pci_dev *dev , int cap ) ;
#line 614
extern int pci_find_next_capability(struct pci_dev *dev , u8 pos , int cap ) ;
#line 615
extern int pci_find_ext_capability(struct pci_dev *dev , int cap ) ;
#line 616
extern int pci_find_ht_capability(struct pci_dev *dev , int ht_cap ) ;
#line 617
extern int pci_find_next_ht_capability(struct pci_dev *dev , int pos , int ht_cap ) ;
#line 618
extern struct pci_bus *pci_find_next_bus(struct pci_bus  const  *from ) ;
#line 620
extern struct pci_dev *pci_get_device(unsigned int vendor , unsigned int device ,
                                      struct pci_dev *from ) ;
#line 622
extern struct pci_dev *pci_get_subsys(unsigned int vendor , unsigned int device ,
                                      unsigned int ss_vendor , unsigned int ss_device ,
                                      struct pci_dev *from ) ;
#line 625
extern struct pci_dev *pci_get_slot(struct pci_bus *bus , unsigned int devfn ) ;
#line 626
extern struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) ;
#line 627
extern struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 628
extern int pci_dev_present(struct pci_device_id  const  *ids ) ;
#line 630
extern int pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u8 *val ) ;
#line 632
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
#line 634
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
#line 636
extern int pci_bus_write_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u8 val ) ;
#line 638
extern int pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u16 val ) ;
#line 640
extern int pci_bus_write_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                      u32 val ) ;
#line 643 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev *dev , int where , u8 *val ) 
{ int tmp ;

  {
  {
#line 645
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  }
#line 645
  return (tmp);
}
}
#line 647 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val ) 
{ int tmp ;

  {
  {
#line 649
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
#line 649
  return (tmp);
}
}
#line 651 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev *dev , int where , u32 *val ) 
{ int tmp ;

  {
  {
#line 654
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 654
  return (tmp);
}
}
#line 656 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev *dev , int where , u8 val ) 
{ int tmp ;

  {
  {
#line 658
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, val);
  }
#line 658
  return (tmp);
}
}
#line 660 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev *dev , int where , u16 val ) 
{ int tmp ;

  {
  {
#line 662
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, val);
  }
#line 662
  return (tmp);
}
}
#line 664 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev *dev , int where , u32 val ) 
{ int tmp ;

  {
  {
#line 667
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 667
  return (tmp);
}
}
#line 670
extern int pci_enable_device(struct pci_dev *dev ) ;
#line 671
extern int pci_enable_device_io(struct pci_dev *dev ) ;
#line 672
extern int pci_enable_device_mem(struct pci_dev *dev ) ;
#line 673
extern int pci_reenable_device(struct pci_dev * ) ;
#line 674
extern int pcim_enable_device(struct pci_dev *pdev ) ;
#line 675
extern void pcim_pin_device(struct pci_dev *pdev ) ;
#line 677 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_is_enabled(struct pci_dev *pdev ) 
{ 

  {
#line 679
  return (pdev->enable_cnt.counter > (int volatile   )0);
}
}
#line 682 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_is_managed(struct pci_dev *pdev ) 
{ 

  {
#line 684
  return ((int )pdev->is_managed);
}
}
#line 687
extern void pci_disable_device(struct pci_dev *dev ) ;
#line 688
extern void pci_set_master(struct pci_dev *dev ) ;
#line 689
extern void pci_clear_master(struct pci_dev *dev ) ;
#line 690
extern int pci_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
#line 692
extern int pci_set_mwi(struct pci_dev *dev ) ;
#line 693
extern int pci_try_set_mwi(struct pci_dev *dev ) ;
#line 694
extern void pci_clear_mwi(struct pci_dev *dev ) ;
#line 695
extern void pci_intx(struct pci_dev *dev , int enable ) ;
#line 696
extern void pci_msi_off(struct pci_dev *dev ) ;
#line 697
extern int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) ;
#line 698
extern int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) ;
#line 699
extern int pci_set_dma_max_seg_size(struct pci_dev *dev , unsigned int size ) ;
#line 700
extern int pci_set_dma_seg_boundary(struct pci_dev *dev , unsigned long mask ) ;
#line 701
extern int pcix_get_max_mmrbc(struct pci_dev *dev ) ;
#line 702
extern int pcix_get_mmrbc(struct pci_dev *dev ) ;
#line 703
extern int pcix_set_mmrbc(struct pci_dev *dev , int mmrbc ) ;
#line 704
extern int pcie_get_readrq(struct pci_dev *dev ) ;
#line 705
extern int pcie_set_readrq(struct pci_dev *dev , int rq ) ;
#line 706
extern int pci_reset_function(struct pci_dev *dev ) ;
#line 707
extern int pci_execute_reset_function(struct pci_dev *dev ) ;
#line 708
extern void pci_update_resource(struct pci_dev *dev , int resno ) ;
#line 709
extern int pci_assign_resource(struct pci_dev *dev , int i ) ;
#line 710
extern int pci_select_bars(struct pci_dev *dev , unsigned long flags ) ;
#line 713
extern int pci_enable_rom(struct pci_dev *pdev ) ;
#line 714
extern void pci_disable_rom(struct pci_dev *pdev ) ;
#line 715
extern void *pci_map_rom(struct pci_dev *pdev , size_t *size ) ;
#line 716
extern void pci_unmap_rom(struct pci_dev *pdev , void *rom ) ;
#line 717
extern size_t pci_get_rom_size(struct pci_dev *pdev , void *rom , size_t size ) ;
#line 720
extern int pci_save_state(struct pci_dev *dev ) ;
#line 721
extern int pci_restore_state(struct pci_dev *dev ) ;
#line 722
extern int __pci_complete_power_transition(struct pci_dev *dev , pci_power_t state ) ;
#line 723
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
#line 724
extern pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) ;
#line 725
extern bool pci_pme_capable(struct pci_dev *dev , pci_power_t state ) ;
#line 726
extern void pci_pme_active(struct pci_dev *dev , bool enable ) ;
#line 727
extern int pci_enable_wake(struct pci_dev *dev , pci_power_t state , int enable ) ;
#line 728
extern int pci_wake_from_d3(struct pci_dev *dev , bool enable ) ;
#line 729
extern pci_power_t pci_target_state(struct pci_dev *dev ) ;
#line 730
extern int pci_prepare_to_sleep(struct pci_dev *dev ) ;
#line 731
extern int pci_back_from_sleep(struct pci_dev *dev ) ;
#line 734
extern int pci_bus_find_capability(struct pci_bus *bus , unsigned int devfn , int cap ) ;
#line 736
extern unsigned int pci_rescan_bus(struct pci_bus *bus ) ;
#line 740
extern ssize_t pci_read_vpd(struct pci_dev *dev , loff_t pos , size_t count , void *buf ) ;
#line 741
extern ssize_t pci_write_vpd(struct pci_dev *dev , loff_t pos , size_t count , void const   *buf ) ;
#line 742
extern int pci_vpd_truncate(struct pci_dev *dev , size_t size ) ;
#line 745
extern void pci_bus_assign_resources(struct pci_bus  const  *bus ) ;
#line 746
extern void pci_bus_size_bridges(struct pci_bus *bus ) ;
#line 747
extern int pci_claim_resource(struct pci_dev * , int  ) ;
#line 748
extern void pci_assign_unassigned_resources(void) ;
#line 749
extern void pdev_enable_device(struct pci_dev * ) ;
#line 750
extern void pdev_sort_resources(struct pci_dev * , struct resource_list * ) ;
#line 751
extern int pci_enable_resources(struct pci_dev * , int mask ) ;
#line 752
extern void pci_fixup_irqs(u8 (*)(struct pci_dev * , u8 * ) , int (*)(struct pci_dev * ,
                                                                      u8  , u8  ) ) ;
#line 755
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 756
extern int pci_request_regions_exclusive(struct pci_dev * , char const   * ) ;
#line 757
extern void pci_release_regions(struct pci_dev * ) ;
#line 758
extern int pci_request_region(struct pci_dev * , int  , char const   * ) ;
#line 759
extern int pci_request_region_exclusive(struct pci_dev * , int  , char const   * ) ;
#line 760
extern void pci_release_region(struct pci_dev * , int  ) ;
#line 761
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
#line 762
extern int pci_request_selected_regions_exclusive(struct pci_dev * , int  , char const   * ) ;
#line 763
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
#line 766
extern int pci_bus_alloc_resource(struct pci_bus *bus , struct resource *res , resource_size_t size ,
                                  resource_size_t align , resource_size_t min , unsigned int type_mask ,
                                  void (*alignf)(void * , struct resource * , resource_size_t  ,
                                                 resource_size_t  ) , void *alignf_data ) ;
#line 773
extern void pci_enable_bridges(struct pci_bus *bus ) ;
#line 776
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   *mod_name ) ;
#line 785
extern void pci_unregister_driver(struct pci_driver *dev ) ;
#line 786
extern void pci_remove_behind_bridge(struct pci_dev *dev ) ;
#line 787
extern struct pci_driver *pci_dev_driver(struct pci_dev  const  *dev ) ;
#line 788
extern struct pci_device_id  const  *pci_match_id(struct pci_device_id  const  *ids ,
                                                  struct pci_dev *dev ) ;
#line 790
extern int pci_scan_bridge(struct pci_bus *bus , struct pci_dev *dev , int max , int pass ) ;
#line 793
extern void pci_walk_bus(struct pci_bus *top , void (*cb)(struct pci_dev * , void * ) ,
                         void *userdata ) ;
#line 795
extern int pci_cfg_space_size_ext(struct pci_dev *dev ) ;
#line 796
extern int pci_cfg_space_size(struct pci_dev *dev ) ;
#line 797
extern unsigned char pci_bus_max_busnr(struct pci_bus *bus ) ;
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dmapool.h"
extern struct dma_pool *dma_pool_create(char const   *name , struct device *dev ,
                                        size_t size , size_t align , size_t allocation ) ;
#line 20
extern void dma_pool_destroy(struct dma_pool *pool ) ;
#line 22
extern void *dma_pool_alloc(struct dma_pool *pool , gfp_t mem_flags , dma_addr_t *handle ) ;
#line 25
extern void dma_pool_free(struct dma_pool *pool , void *vaddr , dma_addr_t addr ) ;
#line 30
extern struct dma_pool *dmam_pool_create(char const   *name , struct device *dev ,
                                         size_t size , size_t align , size_t allocation ) ;
#line 32
extern void dmam_pool_destroy(struct dma_pool *pool ) ;
#line 861 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
extern int pci_enable_msi_block(struct pci_dev *dev , unsigned int nvec ) ;
#line 862
extern void pci_msi_shutdown(struct pci_dev *dev ) ;
#line 863
extern void pci_disable_msi(struct pci_dev *dev ) ;
#line 864
extern int pci_msix_table_size(struct pci_dev *dev ) ;
#line 865
extern int pci_enable_msix(struct pci_dev *dev , struct msix_entry *entries , int nvec ) ;
#line 867
extern void pci_msix_shutdown(struct pci_dev *dev ) ;
#line 868
extern void pci_disable_msix(struct pci_dev *dev ) ;
#line 869
extern void msi_remove_pci_irq_vectors(struct pci_dev *dev ) ;
#line 870
extern void pci_restore_msi_state(struct pci_dev *dev ) ;
#line 871
extern int pci_msi_enabled(void) ;
#line 875 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pcie_aspm_enabled(void) 
{ 

  {
#line 877
  return (0);
}
}
#line 887
extern int ht_create_irq(struct pci_dev *dev , int idx ) ;
#line 888
extern void ht_destroy_irq(unsigned int irq ) ;
#line 891
extern void pci_block_user_cfg_access(struct pci_dev *dev ) ;
#line 892
extern void pci_unblock_user_cfg_access(struct pci_dev *dev ) ;
#line 900
extern int pci_domains_supported ;
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
__inline static void rb_set_parent(struct rb_node *rb , struct rb_node *p ) 
{ 

  {
  {
#line 125
  rb->rb_parent_color = (rb->rb_parent_color & 3UL) | (unsigned long )p;
  }
#line 126
  return;
}
}
#line 127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
__inline static void rb_set_color(struct rb_node *rb , int color ) 
{ 

  {
  {
#line 129
  rb->rb_parent_color = (rb->rb_parent_color & 0xfffffffeUL) | (unsigned long )color;
  }
#line 130
  return;
}
}
#line 139
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
#line 140
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
#line 143
extern struct rb_node *rb_next(struct rb_node  const  * ) ;
#line 144
extern struct rb_node *rb_prev(struct rb_node  const  * ) ;
#line 145
extern struct rb_node *rb_first(struct rb_root  const  * ) ;
#line 146
extern struct rb_node *rb_last(struct rb_root  const  * ) ;
#line 149
extern void rb_replace_node(struct rb_node *victim , struct rb_node *new , struct rb_root *root ) ;
#line 152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rbtree.h"
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link ) 
{ struct rb_node *tmp ;

  {
  {
#line 155
  node->rb_parent_color = (unsigned long )parent;
#line 156
  tmp = (struct rb_node *)((void *)0);
#line 156
  node->rb_right = tmp;
#line 156
  node->rb_left = tmp;
#line 158
  *rb_link = node;
  }
#line 159
  return;
}
}
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static void prio_tree_iter_init(struct prio_tree_iter *iter , struct prio_tree_root *root ,
                                         unsigned long r_index , unsigned long h_index ) 
{ 

  {
  {
#line 52
  iter->root = root;
#line 53
  iter->r_index = r_index;
#line 54
  iter->h_index = h_index;
#line 55
  iter->cur = (struct prio_tree_node *)((void *)0);
  }
#line 56
  return;
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_empty(struct prio_tree_root  const  *root ) 
{ 

  {
#line 86
  return ((unsigned long )root->prio_tree_node == (unsigned long )((void *)0));
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_root(struct prio_tree_node  const  *node ) 
{ 

  {
#line 91
  return ((unsigned long )node->parent == (unsigned long )node);
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_left_empty(struct prio_tree_node  const  *node ) 
{ 

  {
#line 96
  return ((unsigned long )node->left == (unsigned long )node);
}
}
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/prio_tree.h"
__inline static int prio_tree_right_empty(struct prio_tree_node  const  *node ) 
{ 

  {
#line 101
  return ((unsigned long )node->right == (unsigned long )node);
}
}
#line 105
extern struct prio_tree_node *prio_tree_replace(struct prio_tree_root *root , struct prio_tree_node *old ,
                                                struct prio_tree_node *node ) ;
#line 107
extern struct prio_tree_node *prio_tree_insert(struct prio_tree_root *root , struct prio_tree_node *node ) ;
#line 109
extern void prio_tree_remove(struct prio_tree_root *root , struct prio_tree_node *node ) ;
#line 110
extern struct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter ) ;
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
extern int debug_locks ;
#line 11
extern int debug_locks_silent ;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
__inline static int __debug_locks_off(void) 
{ unsigned long tmp ;

  {
  {
#line 16
  tmp = __xchg(0UL, (void volatile   *)(& debug_locks), (int )sizeof(debug_locks));
  }
#line 16
  return ((int )tmp);
}
}
#line 22
extern int debug_locks_off(void) ;
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
__inline static void debug_show_all_locks(void) 
{ 

  {
#line 59
  return;
}
}
#line 61 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
__inline static void __debug_show_held_locks(struct task_struct *task ) 
{ 

  {
#line 63
  return;
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
__inline static void debug_show_held_locks(struct task_struct *task ) 
{ 

  {
#line 67
  return;
}
}
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
__inline static void debug_check_no_locks_freed(void const   *from , unsigned long len ) 
{ 

  {
#line 72
  return;
}
}
#line 74 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debug_locks.h"
__inline static void debug_check_no_locks_held(struct task_struct *task ) 
{ 

  {
#line 77
  return;
}
}
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
extern unsigned long max_mapnr ;
#line 27
extern unsigned long num_physpages ;
#line 28
extern void *high_memory ;
#line 29
extern int page_cluster ;
#line 37
extern unsigned long mmap_min_addr ;
#line 22 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
extern unsigned long empty_zero_page[(1UL << 12) / sizeof(unsigned long )] ;
#line 25
extern spinlock_t pgd_lock ;
#line 26
extern struct list_head pgd_list ;
#line 58
__inline static void paravirt_pagetable_setup_start(pgd_t *base )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 58 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void paravirt_pagetable_setup_start(pgd_t *base ) 
{ 

  {
  {
#line 60
  native_pagetable_setup_start(base);
  }
#line 61
  return;
}
}
#line 63
__inline static void paravirt_pagetable_setup_done(pgd_t *base )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void paravirt_pagetable_setup_done(pgd_t *base ) 
{ 

  {
  {
#line 65
  native_pagetable_setup_done(base);
  }
#line 66
  return;
}
}
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_dirty(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 92
  tmp = pte_flags(pte);
  }
#line 92
  return ((int )(tmp & (1UL << 6)));
}
}
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_young(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 97
  tmp = pte_flags(pte);
  }
#line 97
  return ((int )(tmp & (1UL << 5)));
}
}
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_write(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 102
  tmp = pte_flags(pte);
  }
#line 102
  return ((int )(tmp & (1UL << 1)));
}
}
#line 105 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_file(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 107
  tmp = pte_flags(pte);
  }
#line 107
  return ((int )(tmp & (1UL << 6)));
}
}
#line 110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_huge(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 112
  tmp = pte_flags(pte);
  }
#line 112
  return ((int )(tmp & (1UL << 7)));
}
}
#line 115 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_global(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 117
  tmp = pte_flags(pte);
  }
#line 117
  return ((int )(tmp & (1UL << 8)));
}
}
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_exec(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 122
  tmp = pte_flags(pte);
  }
#line 122
  return (1);
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_special(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 127
  tmp = pte_flags(pte);
  }
#line 127
  return ((int )(tmp & (1UL << 9)));
}
}
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pte_pfn(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
#line 132
  tmp = native_pte_val(pte);
  }
#line 132
  return ((tmp & (unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))) >> 12);
}
}
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_large(pmd_t pte ) 
{ pmdval_t tmp ;

  {
  {
#line 139
  tmp = pmd_flags(pte);
  }
#line 139
  return ((tmp & ((1UL << 7) | 1UL)) == ((1UL << 7) | 1UL));
}
}
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_set_flags(pte_t pte , pteval_t set ) 
{ pteval_t v ;
  pteval_t tmp ;
  pte_t tmp___0 ;

  {
  {
#line 145
  tmp = native_pte_val(pte);
#line 145
  v = tmp;
#line 147
  tmp___0 = native_make_pte(v | set);
  }
#line 147
  return (tmp___0);
}
}
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_clear_flags(pte_t pte , pteval_t clear ) 
{ pteval_t v ;
  pteval_t tmp ;
  pte_t tmp___0 ;

  {
  {
#line 152
  tmp = native_pte_val(pte);
#line 152
  v = tmp;
#line 154
  tmp___0 = native_make_pte(v & ~ clear);
  }
#line 154
  return (tmp___0);
}
}
#line 157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkclean(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 159
  tmp = pte_clear_flags(pte, 1UL << 6);
  }
#line 159
  return (tmp);
}
}
#line 162 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkold(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 164
  tmp = pte_clear_flags(pte, 1UL << 5);
  }
#line 164
  return (tmp);
}
}
#line 167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_wrprotect(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 169
  tmp = pte_clear_flags(pte, 1UL << 1);
  }
#line 169
  return (tmp);
}
}
#line 172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkexec(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 174
  tmp = pte_clear_flags(pte, 0UL);
  }
#line 174
  return (tmp);
}
}
#line 177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkdirty(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 179
  tmp = pte_set_flags(pte, 1UL << 6);
  }
#line 179
  return (tmp);
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkyoung(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 184
  tmp = pte_set_flags(pte, 1UL << 5);
  }
#line 184
  return (tmp);
}
}
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkwrite(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 189
  tmp = pte_set_flags(pte, 1UL << 1);
  }
#line 189
  return (tmp);
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkhuge(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 194
  tmp = pte_set_flags(pte, 1UL << 7);
  }
#line 194
  return (tmp);
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_clrhuge(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 199
  tmp = pte_clear_flags(pte, 1UL << 7);
  }
#line 199
  return (tmp);
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkglobal(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 204
  tmp = pte_set_flags(pte, 1UL << 8);
  }
#line 204
  return (tmp);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_clrglobal(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 209
  tmp = pte_clear_flags(pte, 1UL << 8);
  }
#line 209
  return (tmp);
}
}
#line 212 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_mkspecial(pte_t pte ) 
{ pte_t tmp ;

  {
  {
#line 214
  tmp = pte_set_flags(pte, 1UL << 9);
  }
#line 214
  return (tmp);
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pgprotval_t massage_pgprot(pgprot_t pgprot ) 
{ pgprotval_t protval ;

  {
  {
#line 223
  protval = pgprot.pgprot;
  }
#line 225
  if (protval & 1UL) {
    {
#line 226
    protval &= __supported_pte_mask;
    }
  }
#line 228
  return (protval);
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pfn_pte(unsigned long page_nr , pgprot_t pgprot ) 
{ pgprotval_t tmp ;
  pte_t tmp___0 ;

  {
  {
#line 233
  tmp = massage_pgprot(pgprot);
#line 233
  tmp___0 = native_make_pte((unsigned long )((unsigned int )page_nr << 12) | tmp);
  }
#line 233
  return (tmp___0);
}
}
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pmd_t pfn_pmd(unsigned long page_nr , pgprot_t pgprot ) 
{ pmd_t __constr_expr_0 ;
  pgprotval_t tmp ;
  pgd_t tmp___0 ;

  {
  {
#line 239
  tmp = massage_pgprot(pgprot);
#line 239
  tmp___0 = native_make_pgd((unsigned long )((unsigned int )page_nr << 12) | tmp);
#line 239
  __constr_expr_0.pud.pgd = tmp___0;
  }
#line 239
  return (__constr_expr_0);
}
}
#line 243 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t pte_modify(pte_t pte , pgprot_t newprot ) 
{ pteval_t val ;
  pteval_t tmp ;
  pgprotval_t tmp___0 ;
  pte_t tmp___1 ;

  {
  {
#line 245
  tmp = native_pte_val(pte);
#line 245
  val = tmp;
#line 251
  val &= (((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6);
#line 252
  tmp___0 = massage_pgprot(newprot);
#line 252
  val |= tmp___0 & ~ ((((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
#line 254
  tmp___1 = native_make_pte(val);
  }
#line 254
  return (tmp___1);
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pgprot_t pgprot_modify(pgprot_t oldprot , pgprot_t newprot ) 
{ pgprotval_t preservebits ;
  pgprotval_t addbits ;
  pgprot_t __constr_expr_0 ;

  {
  {
#line 261
  preservebits = oldprot.pgprot & ((((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
#line 262
  addbits = newprot.pgprot;
#line 263
  __constr_expr_0.pgprot = preservebits | addbits;
  }
#line 263
  return (__constr_expr_0);
}
}
#line 270 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int is_new_memtype_allowed(unsigned long flags , unsigned long new_flags ) 
{ 

  {
#line 279
  if (flags == 1UL << 4) {
#line 279
    if (new_flags == 0UL) {
#line 283
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 279
    if (flags == 1UL << 3) {
#line 279
      if (new_flags == 0UL) {
#line 283
        return (0);
      }
    }
  }
#line 286
  return (1);
}
}
#line 289
extern pmd_t *populate_extra_pmd(unsigned long vaddr ) ;
#line 290
extern pte_t *populate_extra_pte(unsigned long vaddr ) ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_32.h"
extern pgd_t swapper_pg_dir[1024] ;
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_32.h"
__inline static void pgtable_cache_init(void) 
{ 

  {
#line 31
  return;
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable_32.h"
__inline static void check_pgt_cache(void) 
{ 

  {
#line 32
  return;
}
}
#line 33
extern void paging_init(void) ;
#line 35
extern void set_pmd_pfn(unsigned long  , unsigned long  , pgprot_t  ) ;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level.h"
__inline static void native_set_pte(pte_t *ptep , pte_t pte ) 
{ 

  {
  {
#line 16
  *ptep = pte;
  }
#line 17
  return;
}
}
#line 19 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level.h"
__inline static void native_set_pmd(pmd_t *pmdp , pmd_t pmd ) 
{ 

  {
  {
#line 21
  *pmdp = pmd;
  }
#line 22
  return;
}
}
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level.h"
__inline static void native_set_pte_atomic(pte_t *ptep , pte_t pte ) 
{ 

  {
  {
#line 26
  native_set_pte(ptep, pte);
  }
#line 27
  return;
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level.h"
__inline static void native_pmd_clear(pmd_t *pmdp ) 
{ pmd_t __constr_expr_0 ;
  pgd_t tmp ;

  {
  {
#line 31
  tmp = native_make_pgd(0UL);
#line 31
  __constr_expr_0.pud.pgd = tmp;
#line 31
  native_set_pmd(pmdp, __constr_expr_0);
  }
#line 32
  return;
}
}
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level.h"
__inline static void native_pte_clear(struct mm_struct *mm , unsigned long addr ,
                                      pte_t *xp ) 
{ 

  {
  {
#line 37
  *xp = native_make_pte(0UL);
  }
#line 38
  return;
}
}
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable-2level.h"
__inline static pte_t native_ptep_get_and_clear(pte_t *xp ) 
{ unsigned long tmp ;
  pte_t tmp___0 ;

  {
  {
#line 43
  tmp = __xchg(0UL, (void volatile   *)(& xp->pte_low), (int )sizeof(xp->pte_low));
#line 43
  tmp___0 = native_make_pte(tmp);
  }
#line 43
  return (tmp___0);
}
}
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_none(pte_t pte ) 
{ 

  {
#line 304
  return (! pte.pte);
}
}
#line 308 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_same(pte_t a , pte_t b ) 
{ 

  {
#line 310
  return (a.pte == b.pte);
}
}
#line 313 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pte_present(pte_t a ) 
{ pteval_t tmp ;

  {
  {
#line 315
  tmp = pte_flags(a);
  }
#line 315
  return ((int )(tmp & (1UL | (1UL << 8))));
}
}
#line 318 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_present(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
#line 320
  tmp = pmd_flags(pmd);
  }
#line 320
  return ((int )(tmp & 1UL));
}
}
#line 323 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_none(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
#line 327
  tmp = native_pmd_val(pmd);
  }
#line 327
  return (tmp == 0UL);
}
}
#line 330 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_page_vaddr(pmd_t pmd ) 
{ pgdval_t tmp ;

  {
  {
#line 332
  tmp = native_pgd_val(pmd.pud.pgd);
  }
#line 332
  return ((unsigned long )((void *)((tmp & (unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))) + 3221225472UL)));
}
}
#line 347 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned int pmd_index(unsigned long address ) 
{ 

  {
#line 349
  return (0U);
}
}
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned int pte_index(unsigned long address ) 
{ 

  {
#line 369
  return ((unsigned int )((address >> 12) & 1023UL));
}
}
#line 372 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t *pte_offset_kernel(pmd_t *pmd , unsigned long address ) 
{ unsigned long tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 374
  tmp = pmd_page_vaddr(*pmd);
#line 374
  tmp___0 = pte_index(address);
  }
#line 374
  return ((pte_t *)tmp + tmp___0);
}
}
#line 377 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pmd_bad(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
#line 379
  tmp = pmd_flags(pmd);
  }
#line 379
  return ((tmp & ~ (1UL << 2)) != (((1UL | (1UL << 1)) | (1UL << 5)) | (1UL << 6)));
}
}
#line 382 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pages_to_mb(unsigned long npg ) 
{ 

  {
#line 384
  return (npg >> 8);
}
}
#line 434 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static int pud_large(pud_t pud ) 
{ 

  {
#line 436
  return (0);
}
}
#line 507 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t native_local_ptep_get_and_clear(pte_t *ptep ) 
{ pte_t res ;

  {
  {
#line 509
  res = *ptep;
#line 512
  native_pte_clear((struct mm_struct *)((void *)0), 0UL, ptep);
  }
#line 513
  return (res);
}
}
#line 516 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void native_set_pte_at(struct mm_struct *mm , unsigned long addr ,
                                       pte_t *ptep , pte_t pte ) 
{ 

  {
  {
#line 519
  native_set_pte(ptep, pte);
  }
#line 520
  return;
}
}
#line 550
extern int ptep_set_access_flags(struct vm_area_struct *vma , unsigned long address ,
                                 pte_t *ptep , pte_t entry , int dirty ) ;
#line 555
extern int ptep_test_and_clear_young(struct vm_area_struct *vma , unsigned long addr ,
                                     pte_t *ptep ) ;
#line 559
extern int ptep_clear_flush_young(struct vm_area_struct *vma , unsigned long address ,
                                  pte_t *ptep ) ;
#line 563 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t ptep_get_and_clear(struct mm_struct *mm , unsigned long addr ,
                                         pte_t *ptep ) 
{ pte_t pte ;
  pte_t tmp ;

  {
  {
#line 566
  tmp = native_ptep_get_and_clear(ptep);
#line 566
  pte = tmp;
  }
  {
#line 567
  while (1) {
    while_100_continue: /* CIL Label */ ;
    goto while_100_break;
  }
  while_100_break: /* CIL Label */ ;
  }
#line 568
  return (pte);
}
}
#line 572 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static pte_t ptep_get_and_clear_full(struct mm_struct *mm , unsigned long addr ,
                                              pte_t *ptep , int full ) 
{ pte_t pte ;

  {
#line 577
  if (full) {
    {
#line 582
    pte = native_local_ptep_get_and_clear(ptep);
    }
  } else {
    {
#line 584
    pte = ptep_get_and_clear(mm, addr, ptep);
    }
  }
#line 586
  return (pte);
}
}
#line 590 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void ptep_set_wrprotect(struct mm_struct *mm , unsigned long addr ,
                                        pte_t *ptep ) 
{ 

  {
  {
#line 593
  clear_bit(1, (unsigned long volatile   *)(& ptep->pte));
  }
  {
#line 594
  while (1) {
    while_101_continue: /* CIL Label */ ;
    goto while_101_break;
  }
  while_101_break: /* CIL Label */ ;
  }
#line 595
  return;
}
}
#line 607 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pgtable.h"
__inline static void clone_pgd_range(pgd_t *dst , pgd_t *src , int count ) 
{ 

  {
  {
#line 609
  __memcpy((void *)dst, (void const   *)src, (unsigned int )((unsigned long )count * sizeof(pgd_t )));
  }
#line 610
  return;
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
extern void pgd_clear_bad(pgd_t * ) ;
#line 167
extern void pud_clear_bad(pud_t * ) ;
#line 168
extern void pmd_clear_bad(pmd_t * ) ;
#line 170 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
__inline static int pgd_none_or_clear_bad(pgd_t *pgd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 172
  tmp = pgd_none(*pgd);
  }
#line 172
  if (tmp) {
#line 173
    return (1);
  }
  {
#line 174
  tmp___0 = pgd_bad(*pgd);
  }
#line 174
  if (tmp___0) {
    {
#line 174
    tmp___1 = 1;
    }
  } else {
    {
#line 174
    tmp___1 = 0;
    }
  }
  {
#line 174
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 174
  if (tmp___2) {
    {
#line 175
    pgd_clear_bad(pgd);
    }
#line 176
    return (1);
  }
#line 178
  return (0);
}
}
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
__inline static int pud_none_or_clear_bad(pud_t *pud ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 183
  tmp = pud_none(*pud);
  }
#line 183
  if (tmp) {
#line 184
    return (1);
  }
  {
#line 185
  tmp___0 = pud_bad(*pud);
  }
#line 185
  if (tmp___0) {
    {
#line 185
    tmp___1 = 1;
    }
  } else {
    {
#line 185
    tmp___1 = 0;
    }
  }
  {
#line 185
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 185
  if (tmp___2) {
    {
#line 186
    pud_clear_bad(pud);
    }
#line 187
    return (1);
  }
#line 189
  return (0);
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
__inline static int pmd_none_or_clear_bad(pmd_t *pmd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 194
  tmp = pmd_none(*pmd);
  }
#line 194
  if (tmp) {
#line 195
    return (1);
  }
  {
#line 196
  tmp___0 = pmd_bad(*pmd);
  }
#line 196
  if (tmp___0) {
    {
#line 196
    tmp___1 = 1;
    }
  } else {
    {
#line 196
    tmp___1 = 0;
    }
  }
  {
#line 196
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 196
  if (tmp___2) {
    {
#line 197
    pmd_clear_bad(pmd);
    }
#line 198
    return (1);
  }
#line 200
  return (0);
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
__inline static pte_t __ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep ) 
{ pte_t tmp ;

  {
  {
#line 212
  tmp = ptep_get_and_clear(mm, addr, ptep);
  }
#line 212
  return (tmp);
}
}
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
__inline static void __ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep , pte_t pte ) 
{ 

  {
  {
#line 223
  native_set_pte_at(mm, addr, ptep, pte);
  }
#line 224
  return;
}
}
#line 241 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
__inline static pte_t ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep ) 
{ pte_t tmp ;

  {
  {
#line 245
  tmp = __ptep_modify_prot_start(mm, addr, ptep);
  }
#line 245
  return (tmp);
}
}
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pgtable.h"
__inline static void ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep , pte_t pte ) 
{ 

  {
  {
#line 256
  __ptep_modify_prot_commit(mm, addr, ptep, pte);
  }
#line 257
  return;
}
}
#line 335
extern int track_pfn_vma_new(struct vm_area_struct *vma , pgprot_t *prot , unsigned long pfn ,
                             unsigned long size ) ;
#line 337
extern int track_pfn_vma_copy(struct vm_area_struct *vma ) ;
#line 338
extern void untrack_pfn_vma(struct vm_area_struct *vma , unsigned long pfn , unsigned long size ) ;
#line 57 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
extern struct kmem_cache *vm_area_cachep ;
#line 134
extern pgprot_t protection_map[16] ;
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int is_linear_pfn_mapping(struct vm_area_struct *vma ) 
{ 

  {
#line 150
  return ((int )(vma->vm_flags & 1073741824UL));
}
}
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int is_pfn_mapping(struct vm_area_struct *vma ) 
{ 

  {
#line 155
  return ((int )(vma->vm_flags & 1024UL));
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageLocked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 192
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& page->flags));
  }
#line 192
  return (tmp);
}
}
#line 192 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestSetPageLocked(struct page *page ) 
{ int tmp ;

  {
  {
#line 192
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& page->flags));
  }
#line 192
  return (tmp);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageError(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& page->flags));
  }
#line 193
  return (tmp);
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageError(struct page *page ) 
{ 

  {
  {
#line 193
  set_bit(1U, (unsigned long volatile   *)(& page->flags));
  }
#line 193
  return;
}
}
#line 193 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageError(struct page *page ) 
{ 

  {
  {
#line 193
  clear_bit(1, (unsigned long volatile   *)(& page->flags));
  }
#line 193
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageReferenced(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 194
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& page->flags));
  }
#line 194
  return (tmp);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageReferenced(struct page *page ) 
{ 

  {
  {
#line 194
  set_bit(2U, (unsigned long volatile   *)(& page->flags));
  }
#line 194
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReferenced(struct page *page ) 
{ 

  {
  {
#line 194
  clear_bit(2, (unsigned long volatile   *)(& page->flags));
  }
#line 194
  return;
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageReferenced(struct page *page ) 
{ int tmp ;

  {
  {
#line 194
  tmp = test_and_clear_bit(2, (unsigned long volatile   *)(& page->flags));
  }
#line 194
  return (tmp);
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageDirty(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 195
  tmp = constant_test_bit(4U, (unsigned long const volatile   *)(& page->flags));
  }
#line 195
  return (tmp);
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageDirty(struct page *page ) 
{ 

  {
  {
#line 195
  set_bit(4U, (unsigned long volatile   *)(& page->flags));
  }
#line 195
  return;
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageDirty(struct page *page ) 
{ 

  {
  {
#line 195
  clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
#line 195
  return;
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestSetPageDirty(struct page *page ) 
{ int tmp ;

  {
  {
#line 195
  tmp = test_and_set_bit(4, (unsigned long volatile   *)(& page->flags));
  }
#line 195
  return (tmp);
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageDirty(struct page *page ) 
{ int tmp ;

  {
  {
#line 195
  tmp = test_and_clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
#line 195
  return (tmp);
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageDirty(struct page *page ) 
{ 

  {
  {
#line 195
  __clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
#line 195
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageLRU(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 196
  tmp = constant_test_bit(5U, (unsigned long const volatile   *)(& page->flags));
  }
#line 196
  return (tmp);
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageLRU(struct page *page ) 
{ 

  {
  {
#line 196
  set_bit(5U, (unsigned long volatile   *)(& page->flags));
  }
#line 196
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageLRU(struct page *page ) 
{ 

  {
  {
#line 196
  clear_bit(5, (unsigned long volatile   *)(& page->flags));
  }
#line 196
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageLRU(struct page *page ) 
{ 

  {
  {
#line 196
  __clear_bit(5, (unsigned long volatile   *)(& page->flags));
  }
#line 196
  return;
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageActive(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 197
  tmp = constant_test_bit(6U, (unsigned long const volatile   *)(& page->flags));
  }
#line 197
  return (tmp);
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageActive(struct page *page ) 
{ 

  {
  {
#line 197
  set_bit(6U, (unsigned long volatile   *)(& page->flags));
  }
#line 197
  return;
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageActive(struct page *page ) 
{ 

  {
  {
#line 197
  clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
#line 197
  return;
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageActive(struct page *page ) 
{ 

  {
  {
#line 197
  __clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
#line 197
  return;
}
}
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageActive(struct page *page ) 
{ int tmp ;

  {
  {
#line 198
  tmp = test_and_clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
#line 198
  return (tmp);
}
}
#line 199 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSlab(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 199
  tmp = constant_test_bit(7U, (unsigned long const volatile   *)(& page->flags));
  }
#line 199
  return (tmp);
}
}
#line 199 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSlab(struct page *page ) 
{ 

  {
  {
#line 199
  __set_bit(7, (unsigned long volatile   *)(& page->flags));
  }
#line 199
  return;
}
}
#line 199 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlab(struct page *page ) 
{ 

  {
  {
#line 199
  __clear_bit(7, (unsigned long volatile   *)(& page->flags));
  }
#line 199
  return;
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageChecked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 200
  tmp = constant_test_bit(8U, (unsigned long const volatile   *)(& page->flags));
  }
#line 200
  return (tmp);
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageChecked(struct page *page ) 
{ 

  {
  {
#line 200
  set_bit(8U, (unsigned long volatile   *)(& page->flags));
  }
#line 200
  return;
}
}
#line 200 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageChecked(struct page *page ) 
{ 

  {
  {
#line 200
  clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
#line 200
  return;
}
}
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PagePinned(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 201
  tmp = constant_test_bit(8U, (unsigned long const volatile   *)(& page->flags));
  }
#line 201
  return (tmp);
}
}
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPagePinned(struct page *page ) 
{ 

  {
  {
#line 201
  set_bit(8U, (unsigned long volatile   *)(& page->flags));
  }
#line 201
  return;
}
}
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPagePinned(struct page *page ) 
{ 

  {
  {
#line 201
  clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
#line 201
  return;
}
}
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestSetPagePinned(struct page *page ) 
{ int tmp ;

  {
  {
#line 201
  tmp = test_and_set_bit(8, (unsigned long volatile   *)(& page->flags));
  }
#line 201
  return (tmp);
}
}
#line 201 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPagePinned(struct page *page ) 
{ int tmp ;

  {
  {
#line 201
  tmp = test_and_clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
#line 201
  return (tmp);
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSavePinned(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 202
  tmp = constant_test_bit(4U, (unsigned long const volatile   *)(& page->flags));
  }
#line 202
  return (tmp);
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageSavePinned(struct page *page ) 
{ 

  {
  {
#line 202
  set_bit(4U, (unsigned long volatile   *)(& page->flags));
  }
#line 202
  return;
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageSavePinned(struct page *page ) 
{ 

  {
  {
#line 202
  clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
#line 202
  return;
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageReserved(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 203
  tmp = constant_test_bit(10U, (unsigned long const volatile   *)(& page->flags));
  }
#line 203
  return (tmp);
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageReserved(struct page *page ) 
{ 

  {
  {
#line 203
  set_bit(10U, (unsigned long volatile   *)(& page->flags));
  }
#line 203
  return;
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReserved(struct page *page ) 
{ 

  {
  {
#line 203
  clear_bit(10, (unsigned long volatile   *)(& page->flags));
  }
#line 203
  return;
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageReserved(struct page *page ) 
{ 

  {
  {
#line 203
  __clear_bit(10, (unsigned long volatile   *)(& page->flags));
  }
#line 203
  return;
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSwapBacked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 204
  tmp = constant_test_bit(20U, (unsigned long const volatile   *)(& page->flags));
  }
#line 204
  return (tmp);
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageSwapBacked(struct page *page ) 
{ 

  {
  {
#line 204
  set_bit(20U, (unsigned long volatile   *)(& page->flags));
  }
#line 204
  return;
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageSwapBacked(struct page *page ) 
{ 

  {
  {
#line 204
  clear_bit(20, (unsigned long volatile   *)(& page->flags));
  }
#line 204
  return;
}
}
#line 204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSwapBacked(struct page *page ) 
{ 

  {
  {
#line 204
  __clear_bit(20, (unsigned long volatile   *)(& page->flags));
  }
#line 204
  return;
}
}
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSlobPage(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 206
  tmp = constant_test_bit(6U, (unsigned long const volatile   *)(& page->flags));
  }
#line 206
  return (tmp);
}
}
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSlobPage(struct page *page ) 
{ 

  {
  {
#line 206
  __set_bit(6, (unsigned long volatile   *)(& page->flags));
  }
#line 206
  return;
}
}
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlobPage(struct page *page ) 
{ 

  {
  {
#line 206
  __clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
#line 206
  return;
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSlobFree(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 207
  tmp = constant_test_bit(11U, (unsigned long const volatile   *)(& page->flags));
  }
#line 207
  return (tmp);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSlobFree(struct page *page ) 
{ 

  {
  {
#line 207
  __set_bit(11, (unsigned long volatile   *)(& page->flags));
  }
#line 207
  return;
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlobFree(struct page *page ) 
{ 

  {
  {
#line 207
  __clear_bit(11, (unsigned long volatile   *)(& page->flags));
  }
#line 207
  return;
}
}
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSlubFrozen(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 209
  tmp = constant_test_bit(6U, (unsigned long const volatile   *)(& page->flags));
  }
#line 209
  return (tmp);
}
}
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSlubFrozen(struct page *page ) 
{ 

  {
  {
#line 209
  __set_bit(6, (unsigned long volatile   *)(& page->flags));
  }
#line 209
  return;
}
}
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlubFrozen(struct page *page ) 
{ 

  {
  {
#line 209
  __clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
#line 209
  return;
}
}
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSlubDebug(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 210
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& page->flags));
  }
#line 210
  return (tmp);
}
}
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageSlubDebug(struct page *page ) 
{ 

  {
  {
#line 210
  __set_bit(1, (unsigned long volatile   *)(& page->flags));
  }
#line 210
  return;
}
}
#line 210 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageSlubDebug(struct page *page ) 
{ 

  {
  {
#line 210
  __clear_bit(1, (unsigned long volatile   *)(& page->flags));
  }
#line 210
  return;
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PagePrivate(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 217
  tmp = constant_test_bit(11U, (unsigned long const volatile   *)(& page->flags));
  }
#line 217
  return (tmp);
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPagePrivate(struct page *page ) 
{ 

  {
  {
#line 217
  set_bit(11U, (unsigned long volatile   *)(& page->flags));
  }
#line 217
  return;
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPagePrivate(struct page *page ) 
{ 

  {
  {
#line 217
  clear_bit(11, (unsigned long volatile   *)(& page->flags));
  }
#line 217
  return;
}
}
#line 217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPagePrivate(struct page *page ) 
{ 

  {
  {
#line 217
  __set_bit(11, (unsigned long volatile   *)(& page->flags));
  }
#line 217
  return;
}
}
#line 218 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPagePrivate(struct page *page ) 
{ 

  {
  {
#line 218
  __clear_bit(11, (unsigned long volatile   *)(& page->flags));
  }
#line 218
  return;
}
}
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PagePrivate2(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 219
  tmp = constant_test_bit(12U, (unsigned long const volatile   *)(& page->flags));
  }
#line 219
  return (tmp);
}
}
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPagePrivate2(struct page *page ) 
{ 

  {
  {
#line 219
  set_bit(12U, (unsigned long volatile   *)(& page->flags));
  }
#line 219
  return;
}
}
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPagePrivate2(struct page *page ) 
{ 

  {
  {
#line 219
  clear_bit(12, (unsigned long volatile   *)(& page->flags));
  }
#line 219
  return;
}
}
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestSetPagePrivate2(struct page *page ) 
{ int tmp ;

  {
  {
#line 219
  tmp = test_and_set_bit(12, (unsigned long volatile   *)(& page->flags));
  }
#line 219
  return (tmp);
}
}
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPagePrivate2(struct page *page ) 
{ int tmp ;

  {
  {
#line 219
  tmp = test_and_clear_bit(12, (unsigned long volatile   *)(& page->flags));
  }
#line 219
  return (tmp);
}
}
#line 220 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageOwnerPriv1(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 220
  tmp = constant_test_bit(8U, (unsigned long const volatile   *)(& page->flags));
  }
#line 220
  return (tmp);
}
}
#line 220 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageOwnerPriv1(struct page *page ) 
{ 

  {
  {
#line 220
  set_bit(8U, (unsigned long volatile   *)(& page->flags));
  }
#line 220
  return;
}
}
#line 220 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageOwnerPriv1(struct page *page ) 
{ 

  {
  {
#line 220
  clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
#line 220
  return;
}
}
#line 220 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageOwnerPriv1(struct page *page ) 
{ int tmp ;

  {
  {
#line 220
  tmp = test_and_clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
#line 220
  return (tmp);
}
}
#line 226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageWriteback(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 226
  tmp = constant_test_bit(13U, (unsigned long const volatile   *)(& page->flags));
  }
#line 226
  return (tmp);
}
}
#line 226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestSetPageWriteback(struct page *page ) 
{ int tmp ;

  {
  {
#line 226
  tmp = test_and_set_bit(13, (unsigned long volatile   *)(& page->flags));
  }
#line 226
  return (tmp);
}
}
#line 226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageWriteback(struct page *page ) 
{ int tmp ;

  {
  {
#line 226
  tmp = test_and_clear_bit(13, (unsigned long volatile   *)(& page->flags));
  }
#line 226
  return (tmp);
}
}
#line 227 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageBuddy(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 227
  tmp = constant_test_bit(19U, (unsigned long const volatile   *)(& page->flags));
  }
#line 227
  return (tmp);
}
}
#line 227 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageBuddy(struct page *page ) 
{ 

  {
  {
#line 227
  __set_bit(19, (unsigned long volatile   *)(& page->flags));
  }
#line 227
  return;
}
}
#line 227 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageBuddy(struct page *page ) 
{ 

  {
  {
#line 227
  __clear_bit(19, (unsigned long volatile   *)(& page->flags));
  }
#line 227
  return;
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageMappedToDisk(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 228
  tmp = constant_test_bit(17U, (unsigned long const volatile   *)(& page->flags));
  }
#line 228
  return (tmp);
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageMappedToDisk(struct page *page ) 
{ 

  {
  {
#line 228
  set_bit(17U, (unsigned long volatile   *)(& page->flags));
  }
#line 228
  return;
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageMappedToDisk(struct page *page ) 
{ 

  {
  {
#line 228
  clear_bit(17, (unsigned long volatile   *)(& page->flags));
  }
#line 228
  return;
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageReclaim(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 231
  tmp = constant_test_bit(18U, (unsigned long const volatile   *)(& page->flags));
  }
#line 231
  return (tmp);
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageReclaim(struct page *page ) 
{ 

  {
  {
#line 231
  set_bit(18U, (unsigned long volatile   *)(& page->flags));
  }
#line 231
  return;
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReclaim(struct page *page ) 
{ 

  {
  {
#line 231
  clear_bit(18, (unsigned long volatile   *)(& page->flags));
  }
#line 231
  return;
}
}
#line 231 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageReclaim(struct page *page ) 
{ int tmp ;

  {
  {
#line 231
  tmp = test_and_clear_bit(18, (unsigned long volatile   *)(& page->flags));
  }
#line 231
  return (tmp);
}
}
#line 232 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageReadahead(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 232
  tmp = constant_test_bit(18U, (unsigned long const volatile   *)(& page->flags));
  }
#line 232
  return (tmp);
}
}
#line 232 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageReadahead(struct page *page ) 
{ 

  {
  {
#line 232
  set_bit(18U, (unsigned long volatile   *)(& page->flags));
  }
#line 232
  return;
}
}
#line 232 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageReadahead(struct page *page ) 
{ 

  {
  {
#line 232
  clear_bit(18, (unsigned long volatile   *)(& page->flags));
  }
#line 232
  return;
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageSwapCache(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 245
  tmp = constant_test_bit(16U, (unsigned long const volatile   *)(& page->flags));
  }
#line 245
  return (tmp);
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageSwapCache(struct page *page ) 
{ 

  {
  {
#line 245
  set_bit(16U, (unsigned long volatile   *)(& page->flags));
  }
#line 245
  return;
}
}
#line 245 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageSwapCache(struct page *page ) 
{ 

  {
  {
#line 245
  clear_bit(16, (unsigned long volatile   *)(& page->flags));
  }
#line 245
  return;
}
}
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageUnevictable(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 252
  tmp = constant_test_bit(21U, (unsigned long const volatile   *)(& page->flags));
  }
#line 252
  return (tmp);
}
}
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageUnevictable(struct page *page ) 
{ 

  {
  {
#line 252
  set_bit(21U, (unsigned long volatile   *)(& page->flags));
  }
#line 252
  return;
}
}
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageUnevictable(struct page *page ) 
{ 

  {
  {
#line 252
  clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
#line 252
  return;
}
}
#line 252 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageUnevictable(struct page *page ) 
{ 

  {
  {
#line 252
  __clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
#line 252
  return;
}
}
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageUnevictable(struct page *page ) 
{ int tmp ;

  {
  {
#line 253
  tmp = test_and_clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
#line 253
  return (tmp);
}
}
#line 262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageMlocked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  tmp = constant_test_bit(22U, (unsigned long const volatile   *)(& page->flags));
  }
#line 262
  return (tmp);
}
}
#line 262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageMlocked(struct page *page ) 
{ 

  {
  {
#line 262
  set_bit(22U, (unsigned long volatile   *)(& page->flags));
  }
#line 262
  return;
}
}
#line 262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageMlocked(struct page *page ) 
{ 

  {
  {
#line 262
  clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
#line 262
  return;
}
}
#line 262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageMlocked(struct page *page ) 
{ 

  {
  {
#line 262
  __clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
#line 262
  return;
}
}
#line 263 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestSetPageMlocked(struct page *page ) 
{ int tmp ;

  {
  {
#line 263
  tmp = test_and_set_bit(22, (unsigned long volatile   *)(& page->flags));
  }
#line 263
  return (tmp);
}
}
#line 263 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int TestClearPageMlocked(struct page *page ) 
{ int tmp ;

  {
  {
#line 263
  tmp = test_and_clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
#line 263
  return (tmp);
}
}
#line 273 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageUncached(struct page *page ) 
{ 

  {
#line 273
  return (0);
}
}
#line 276 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageUptodate(struct page *page ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 278
  tmp = constant_test_bit(3U, (unsigned long const volatile   *)(& page->flags));
#line 278
  ret = tmp;
  }
#line 288
  if (ret) {
    {
#line 289
    __asm__  volatile   ("": : : "memory");
    }
  }
#line 291
  return (ret);
}
}
#line 294 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageUptodate(struct page *page ) 
{ 

  {
  {
#line 296
  __asm__  volatile   ("": : : "memory");
#line 297
  __set_bit(3, (unsigned long volatile   *)(& page->flags));
  }
#line 298
  return;
}
}
#line 300 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void SetPageUptodate(struct page *page ) 
{ 

  {
  {
#line 314
  __asm__  volatile   ("": : : "memory");
#line 315
  set_bit(3U, (unsigned long volatile   *)(& page->flags));
  }
#line 317
  return;
}
}
#line 319 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void ClearPageUptodate(struct page *page ) 
{ 

  {
  {
#line 319
  clear_bit(3, (unsigned long volatile   *)(& page->flags));
  }
#line 319
  return;
}
}
#line 321
extern void cancel_dirty_page(struct page *page , unsigned int account_size ) ;
#line 323
extern int test_clear_page_writeback(struct page *page ) ;
#line 324
extern int test_set_page_writeback(struct page *page ) ;
#line 326 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void set_page_writeback(struct page *page ) 
{ 

  {
  {
#line 328
  test_set_page_writeback(page);
  }
#line 329
  return;
}
}
#line 338 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageHead(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 338
  tmp = constant_test_bit(14U, (unsigned long const volatile   *)(& page->flags));
  }
#line 338
  return (tmp);
}
}
#line 338 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageHead(struct page *page ) 
{ 

  {
  {
#line 338
  __set_bit(14, (unsigned long volatile   *)(& page->flags));
  }
#line 338
  return;
}
}
#line 338 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageHead(struct page *page ) 
{ 

  {
  {
#line 338
  __clear_bit(14, (unsigned long volatile   *)(& page->flags));
  }
#line 338
  return;
}
}
#line 339 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageTail(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 339
  tmp = constant_test_bit(15U, (unsigned long const volatile   *)(& page->flags));
  }
#line 339
  return (tmp);
}
}
#line 339 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __SetPageTail(struct page *page ) 
{ 

  {
  {
#line 339
  __set_bit(15, (unsigned long volatile   *)(& page->flags));
  }
#line 339
  return;
}
}
#line 339 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static void __ClearPageTail(struct page *page ) 
{ 

  {
  {
#line 339
  __clear_bit(15, (unsigned long volatile   *)(& page->flags));
  }
#line 339
  return;
}
}
#line 341 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/page-flags.h"
__inline static int PageCompound(struct page *page ) 
{ 

  {
#line 343
  return ((int )(page->flags & (unsigned long )((1L << 14) | (1L << 15))));
}
}
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int put_page_testzero(struct page *page ) 
{ int tmp ;

  {
  {
#line 255
  while (1) {
    while_102_continue: /* CIL Label */ ;
    goto while_102_break;
  }
  while_102_break: /* CIL Label */ ;
  }
  {
#line 256
  tmp = atomic_dec_and_test(& page->_count);
  }
#line 256
  return (tmp);
}
}
#line 263 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int get_page_unless_zero(struct page *page ) 
{ int tmp ;

  {
  {
#line 265
  tmp = atomic_add_unless(& page->_count, 1, 0);
  }
#line 265
  return (tmp);
}
}
#line 269
extern struct page *vmalloc_to_page(void const   *addr ) ;
#line 270
extern unsigned long vmalloc_to_pfn(void const   *addr ) ;
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int is_vmalloc_addr(void const   *x ) 
{ unsigned long addr ;
  int tmp ;

  {
  {
#line 281
  addr = (unsigned long )x;
  }
#line 283
  if (addr >= (unsigned long )high_memory + 8388608UL) {
#line 283
    if (addr < (((__FIXADDR_TOP - (unsigned long )(514 << 12)) - (1UL << 12) * 1025UL) & ~ ((1UL << 22) - 1UL)) - 2UL * (1UL << 12)) {
      {
#line 283
      tmp = 1;
      }
    } else {
      {
#line 283
      tmp = 0;
      }
    }
  } else {
    {
#line 283
    tmp = 0;
    }
  }
#line 283
  return (tmp);
}
}
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static struct page *compound_head(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 291
  tmp = PageTail(page);
  }
#line 291
  if (tmp) {
    {
#line 291
    tmp___0 = 1;
    }
  } else {
    {
#line 291
    tmp___0 = 0;
    }
  }
  {
#line 291
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 291
  if (tmp___1) {
#line 292
    return (page->__annonCompField18.first_page);
  }
#line 293
  return (page);
}
}
#line 296 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int page_count(struct page *page ) 
{ struct page *tmp ;

  {
  {
#line 298
  tmp = compound_head(page);
  }
#line 298
  return ((int )tmp->_count.counter);
}
}
#line 301 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 

  {
  {
#line 303
  page = compound_head(page);
  }
  {
#line 304
  while (1) {
    while_103_continue: /* CIL Label */ ;
    goto while_103_break;
  }
  while_103_break: /* CIL Label */ ;
  }
  {
#line 305
  atomic_inc(& page->_count);
  }
#line 306
  return;
}
}
#line 308 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static struct page *virt_to_head_page(void const   *x ) 
{ struct page *page ;
  struct page *tmp ;

  {
  {
#line 310
  page = mem_map + (((unsigned long )x - 3221225472UL) >> 12);
#line 311
  tmp = compound_head(page);
  }
#line 311
  return (tmp);
}
}
#line 318 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void init_page_count(struct page *page ) 
{ 

  {
  {
#line 320
  page->_count.counter = (int volatile   )1;
  }
#line 321
  return;
}
}
#line 323
extern void put_page(struct page *page ) ;
#line 324
extern void put_pages_list(struct list_head *pages ) ;
#line 326
extern void split_page(struct page *page , unsigned int order ) ;
#line 335 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void set_compound_page_dtor(struct page *page , compound_page_dtor *dtor ) 
{ 

  {
  {
#line 338
  (page + 1)->lru.next = (struct list_head *)((void *)dtor);
  }
#line 339
  return;
}
}
#line 341 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static compound_page_dtor *get_compound_page_dtor(struct page *page ) 
{ 

  {
#line 343
  return ((compound_page_dtor *)(page + 1)->lru.next);
}
}
#line 346 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int compound_order(struct page *page ) 
{ int tmp ;

  {
  {
#line 348
  tmp = PageHead(page);
  }
#line 348
  if (! tmp) {
#line 349
    return (0);
  }
#line 350
  return ((int )((unsigned long )(page + 1)->lru.prev));
}
}
#line 353 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void set_compound_order(struct page *page , unsigned long order ) 
{ 

  {
  {
#line 355
  (page + 1)->lru.prev = (struct list_head *)((void *)order);
  }
#line 356
  return;
}
}
#line 503 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static enum zone_type page_zonenum(struct page *page ) 
{ 

  {
#line 505
  return ((enum zone_type )((page->flags >> (sizeof(unsigned long ) * 8UL - 2UL)) & ((1UL << 2) - 1UL)));
}
}
#line 516 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int page_zone_id(struct page *page ) 
{ unsigned long tmp ;

  {
#line 518
  if (sizeof(unsigned long ) * 8UL < sizeof(unsigned long ) * 8UL - 2UL) {
    {
#line 518
    tmp = sizeof(unsigned long ) * 8UL;
    }
  } else {
    {
#line 518
    tmp = sizeof(unsigned long ) * 8UL - 2UL;
    }
  }
#line 518
  return ((int )((page->flags >> tmp) & ((1UL << 2) - 1UL)));
}
}
#line 521 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int zone_to_nid(struct zone *zone ) 
{ 

  {
#line 526
  return (0);
}
}
#line 533 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int page_to_nid(struct page *page ) 
{ 

  {
#line 535
  return (0);
}
}
#line 539 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static struct zone *page_zone(struct page *page ) 
{ enum zone_type tmp ;

  {
  {
#line 541
  tmp = page_zonenum(page);
  }
#line 541
  return (& contig_page_data.node_zones[tmp]);
}
}
#line 551 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void set_page_zone(struct page *page , enum zone_type zone ) 
{ 

  {
  {
#line 553
  page->flags &= ~ (((1UL << 2) - 1UL) << (sizeof(unsigned long ) * 8UL - 2UL));
#line 554
  page->flags |= ((unsigned long )zone & ((1UL << 2) - 1UL)) << (sizeof(unsigned long ) * 8UL - 2UL);
  }
#line 555
  return;
}
}
#line 557 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void set_page_node(struct page *page , unsigned long node ) 
{ 

  {
  {
#line 559
  page->flags &= 0xffffffffUL;
#line 560
  page->flags = page->flags;
  }
#line 561
  return;
}
}
#line 563 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void set_page_section(struct page *page , unsigned long section ) 
{ 

  {
  {
#line 565
  page->flags &= 0xffffffffUL;
#line 566
  page->flags = page->flags;
  }
#line 567
  return;
}
}
#line 569 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void set_page_links(struct page *page , enum zone_type zone , unsigned long node ,
                                    unsigned long pfn ) 
{ 

  {
  {
#line 572
  set_page_zone(page, zone);
#line 573
  set_page_node(page, node);
#line 574
  set_page_section(page, pfn);
  }
#line 575
  return;
}
}
#line 581 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static unsigned long round_hint_to_min(unsigned long hint ) 
{ 

  {
  {
#line 583
  hint &= ~ ((1UL << 12) - 1UL);
  }
#line 584
  if ((unsigned long )((void *)hint) != (unsigned long )((void *)0)) {
#line 584
    if (hint < mmap_min_addr) {
#line 586
      return ((mmap_min_addr + ((1UL << 12) - 1UL)) & ~ ((1UL << 12) - 1UL));
    }
  }
#line 587
  return (hint);
}
}
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
extern int sysctl_stat_interval ;
#line 77
extern struct vm_event_state per_cpu__vm_event_states  __attribute__((__section__(".data.percpu"))) ;
#line 79 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static void __count_vm_event(enum vm_event_item item ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
#line 81
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
#line 81
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_104_1;
  } else {
#line 81
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_104_2;
    } else {
#line 81
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_104_4;
      } else {
#line 81
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_104_8;
        } else {
          {
          goto switch_104_default;
#line 81
          if (0) {
            switch_104_1: /* CIL Label */ 
            {
#line 81
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_2: /* CIL Label */ 
            {
#line 81
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_4: /* CIL Label */ 
            {
#line 81
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_8: /* CIL Label */ 
            {
#line 81
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_default: /* CIL Label */ 
            {
#line 81
            __bad_percpu_size();
            }
          } else {
            switch_104_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
#line 81
  (((struct vm_event_state *)(__ptr + ret__))->event[item]) ++;
  }
#line 82
  return;
}
}
#line 86
extern int simple_identifier_vm_event_states(void) ;
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static void count_vm_event(enum vm_event_item item ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
#line 86
  while (1) {
    while_105_continue: /* CIL Label */ ;
    goto while_105_break;
  }
  while_105_break: /* CIL Label */ ;
  }
  {
#line 86
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
#line 86
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_106_1;
  } else {
#line 86
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_106_2;
    } else {
#line 86
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_106_4;
      } else {
#line 86
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_106_8;
        } else {
          {
          goto switch_106_default;
#line 86
          if (0) {
            switch_106_1: /* CIL Label */ 
            {
#line 86
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_2: /* CIL Label */ 
            {
#line 86
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_4: /* CIL Label */ 
            {
#line 86
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_8: /* CIL Label */ 
            {
#line 86
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_default: /* CIL Label */ 
            {
#line 86
            __bad_percpu_size();
            }
          } else {
            switch_106_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
#line 86
  (((struct vm_event_state *)(__ptr + ret__))->event[item]) ++;
  }
  {
#line 87
  while (1) {
    while_107_continue: /* CIL Label */ ;
    goto while_107_break;
  }
  while_107_break: /* CIL Label */ ;
  }
#line 88
  return;
}
}
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static void __count_vm_events(enum vm_event_item item , long delta ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
#line 92
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
#line 92
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_108_1;
  } else {
#line 92
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_108_2;
    } else {
#line 92
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_108_4;
      } else {
#line 92
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_108_8;
        } else {
          {
          goto switch_108_default;
#line 92
          if (0) {
            switch_108_1: /* CIL Label */ 
            {
#line 92
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_2: /* CIL Label */ 
            {
#line 92
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_4: /* CIL Label */ 
            {
#line 92
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_8: /* CIL Label */ 
            {
#line 92
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_default: /* CIL Label */ 
            {
#line 92
            __bad_percpu_size();
            }
          } else {
            switch_108_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
#line 92
  ((struct vm_event_state *)(__ptr + ret__))->event[item] += (unsigned long )delta;
  }
#line 93
  return;
}
}
#line 95 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static void count_vm_events(enum vm_event_item item , long delta ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
#line 97
  while (1) {
    while_109_continue: /* CIL Label */ ;
    goto while_109_break;
  }
  while_109_break: /* CIL Label */ ;
  }
  {
#line 97
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
#line 97
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_110_1;
  } else {
#line 97
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_110_2;
    } else {
#line 97
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_110_4;
      } else {
#line 97
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_110_8;
        } else {
          {
          goto switch_110_default;
#line 97
          if (0) {
            switch_110_1: /* CIL Label */ 
            {
#line 97
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_110_break;
            switch_110_2: /* CIL Label */ 
            {
#line 97
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_110_break;
            switch_110_4: /* CIL Label */ 
            {
#line 97
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_110_break;
            switch_110_8: /* CIL Label */ 
            {
#line 97
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_110_break;
            switch_110_default: /* CIL Label */ 
            {
#line 97
            __bad_percpu_size();
            }
          } else {
            switch_110_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
#line 97
  ((struct vm_event_state *)(__ptr + ret__))->event[item] += (unsigned long )delta;
  }
  {
#line 98
  while (1) {
    while_111_continue: /* CIL Label */ ;
    goto while_111_break;
  }
  while_111_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101
extern void all_vm_events(unsigned long * ) ;
#line 103
extern void vm_events_fold_cpu(int cpu ) ;
#line 141
extern atomic_long_t vm_stat[19] ;
#line 143 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static void zone_page_state_add(long x , struct zone *zone , enum zone_stat_item item ) 
{ 

  {
  {
#line 146
  atomic_long_add(x, & zone->vm_stat[item]);
#line 147
  atomic_long_add(x, & vm_stat[item]);
  }
#line 148
  return;
}
}
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static unsigned long global_page_state(enum zone_stat_item item ) 
{ long x ;
  long tmp ;

  {
  {
#line 152
  tmp = atomic_long_read(& vm_stat[item]);
#line 152
  x = tmp;
  }
#line 154
  if (x < 0L) {
    {
#line 155
    x = 0L;
    }
  }
#line 157
  return ((unsigned long )x);
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static unsigned long zone_page_state(struct zone *zone , enum zone_stat_item item ) 
{ long x ;
  long tmp ;

  {
  {
#line 163
  tmp = atomic_long_read(& zone->vm_stat[item]);
#line 163
  x = tmp;
  }
#line 165
  if (x < 0L) {
    {
#line 166
    x = 0L;
    }
  }
#line 168
  return ((unsigned long )x);
}
}
#line 171
extern unsigned long global_lru_pages(void) ;
#line 173 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static unsigned long zone_lru_pages(struct zone *zone ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 175
  tmp = zone_page_state(zone, (enum zone_stat_item )2);
#line 175
  tmp___0 = zone_page_state(zone, (enum zone_stat_item )4);
#line 175
  tmp___1 = zone_page_state(zone, (enum zone_stat_item )1);
#line 175
  tmp___2 = zone_page_state(zone, (enum zone_stat_item )3);
  }
#line 175
  return (((tmp + tmp___0) + tmp___1) + tmp___2);
}
}
#line 223 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/vmstat.h"
__inline static void zap_zone_vm_stats(struct zone *zone ) 
{ 

  {
  {
#line 225
  __constant_c_and_count_memset((void *)(zone->vm_stat), 0UL, (unsigned int )sizeof(zone->vm_stat));
  }
#line 226
  return;
}
}
#line 228
extern void inc_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 231
extern void __mod_zone_page_state(struct zone * , enum zone_stat_item item , int  ) ;
#line 232
extern void __inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 233
extern void __dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 235
extern void mod_zone_page_state(struct zone * , enum zone_stat_item  , int  ) ;
#line 236
extern void inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 237
extern void dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
#line 240
extern void __inc_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 241
extern void dec_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 242
extern void __dec_zone_state(struct zone * , enum zone_stat_item  ) ;
#line 244
extern void refresh_cpu_vm_stats(int  ) ;
#line 595 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page *page ) 
{ 

  {
#line 597
  return ((void *)(((unsigned long )(page - mem_map) << 12) + 3221225472UL));
}
}
#line 614
extern void *page_address(struct page *page ) ;
#line 615
extern void set_page_address(struct page *page , void *virtual ) ;
#line 616
extern void page_address_init(void) ;
#line 636
extern struct address_space swapper_space ;
#line 637 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static struct address_space *page_mapping(struct page *page ) 
{ struct address_space *mapping ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 639
  mapping = page->__annonCompField18.__annonCompField17.mapping;
  }
  {
#line 641
  while (1) {
    while_112_continue: /* CIL Label */ ;
    goto while_112_break;
  }
  while_112_break: /* CIL Label */ ;
  }
  {
#line 643
  tmp___0 = PageSwapCache(page);
  }
#line 643
  if (tmp___0) {
    {
#line 643
    tmp___1 = 1;
    }
  } else {
    {
#line 643
    tmp___1 = 0;
    }
  }
  {
#line 643
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 643
  if (tmp___2) {
    {
#line 644
    mapping = & swapper_space;
    }
  } else {
    {
#line 647
    tmp = __builtin_expect((long )(! (! ((unsigned long )mapping & 1UL))), 0L);
    }
#line 647
    if (tmp) {
      {
#line 648
      mapping = (struct address_space *)((void *)0);
      }
    }
  }
#line 649
  return (mapping);
}
}
#line 652 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int PageAnon(struct page *page ) 
{ 

  {
#line 654
  return (((unsigned long )page->__annonCompField18.__annonCompField17.mapping & 1UL) != 0UL);
}
}
#line 661 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static unsigned long page_index(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 663
  tmp = PageSwapCache(page);
  }
#line 663
  if (tmp) {
    {
#line 663
    tmp___0 = 1;
    }
  } else {
    {
#line 663
    tmp___0 = 0;
    }
  }
  {
#line 663
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 663
  if (tmp___1) {
#line 664
    return (page->__annonCompField18.__annonCompField17.private);
  }
#line 665
  return (page->__annonCompField16.index);
}
}
#line 673 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void reset_page_mapcount(struct page *page ) 
{ 

  {
  {
#line 675
  page->__annonCompField20._mapcount.counter = (int volatile   )-1;
  }
#line 676
  return;
}
}
#line 678 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int page_mapcount(struct page *page ) 
{ 

  {
#line 680
  return ((int )(page->__annonCompField20._mapcount.counter + (int volatile   )1));
}
}
#line 686 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int page_mapped(struct page *page ) 
{ 

  {
#line 688
  return (page->__annonCompField20._mapcount.counter >= (int volatile   )0);
}
}
#line 712
extern void pagefault_out_of_memory(void) ;
#line 716
extern void show_free_areas(void) ;
#line 719
extern int shmem_lock(struct file *file , int lock , struct user_struct *user ) ;
#line 727
extern struct file *shmem_file_setup(char *name , loff_t size , unsigned long flags ) ;
#line 729
extern int shmem_zero_setup(struct vm_area_struct * ) ;
#line 739
extern int can_do_mlock(void) ;
#line 740
extern int user_shm_lock(size_t  , struct user_struct * ) ;
#line 741
extern void user_shm_unlock(size_t  , struct user_struct * ) ;
#line 755
extern struct page *vm_normal_page(struct vm_area_struct *vma , unsigned long addr ,
                                   pte_t pte ) ;
#line 758
extern int zap_vma_ptes(struct vm_area_struct *vma , unsigned long address , unsigned long size ) ;
#line 760
extern unsigned long zap_page_range(struct vm_area_struct *vma , unsigned long address ,
                                    unsigned long size , struct zap_details * ) ;
#line 762
extern unsigned long unmap_vmas(struct mmu_gather **tlb , struct vm_area_struct *start_vma ,
                                unsigned long start_addr , unsigned long end_addr ,
                                unsigned long *nr_accounted , struct zap_details * ) ;
#line 787
extern int walk_page_range(unsigned long addr , unsigned long end , struct mm_walk *walk ) ;
#line 789
extern void free_pgd_range(struct mmu_gather *tlb , unsigned long addr , unsigned long end ,
                           unsigned long floor , unsigned long ceiling ) ;
#line 791
extern int copy_page_range(struct mm_struct *dst , struct mm_struct *src , struct vm_area_struct *vma ) ;
#line 793
extern void unmap_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                loff_t holelen , int even_cows ) ;
#line 795
extern int follow_phys(struct vm_area_struct *vma , unsigned long address , unsigned int flags ,
                       unsigned long *prot , resource_size_t *phys ) ;
#line 797
extern int generic_access_phys(struct vm_area_struct *vma , unsigned long addr , void *buf ,
                               int len , int write ) ;
#line 800 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void unmap_shared_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                                loff_t holelen ) 
{ 

  {
  {
#line 803
  unmap_mapping_range(mapping, holebegin, holelen, 0);
  }
#line 804
  return;
}
}
#line 806
extern int vmtruncate(struct inode *inode , loff_t offset ) ;
#line 807
extern int vmtruncate_range(struct inode *inode , loff_t offset , loff_t end ) ;
#line 810
extern int handle_mm_fault(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long address ,
                           int write_access ) ;
#line 823
extern int make_pages_present(unsigned long addr , unsigned long end ) ;
#line 824
extern int access_process_vm(struct task_struct *tsk , unsigned long addr , void *buf ,
                             int len , int write ) ;
#line 826
extern int get_user_pages(struct task_struct *tsk , struct mm_struct *mm , unsigned long start ,
                          int len , int write , int force , struct page **pages ,
                          struct vm_area_struct **vmas ) ;
#line 829
extern int try_to_release_page(struct page *page , gfp_t gfp_mask ) ;
#line 830
extern void do_invalidatepage(struct page *page , unsigned long offset ) ;
#line 832
extern int __set_page_dirty_nobuffers(struct page *page ) ;
#line 833
extern int __set_page_dirty_no_writeback(struct page *page ) ;
#line 834
extern int redirty_page_for_writepage(struct writeback_control *wbc , struct page *page ) ;
#line 836
extern void account_page_dirtied(struct page *page , struct address_space *mapping ) ;
#line 837
extern int set_page_dirty(struct page *page ) ;
#line 838
extern int set_page_dirty_lock(struct page *page ) ;
#line 839
extern int clear_page_dirty_for_io(struct page *page ) ;
#line 841
extern unsigned long move_page_tables(struct vm_area_struct *vma , unsigned long old_addr ,
                                      struct vm_area_struct *new_vma , unsigned long new_addr ,
                                      unsigned long len ) ;
#line 844
extern unsigned long do_mremap(unsigned long addr , unsigned long old_len , unsigned long new_len ,
                               unsigned long flags , unsigned long new_addr ) ;
#line 847
extern int mprotect_fixup(struct vm_area_struct *vma , struct vm_area_struct **pprev ,
                          unsigned long start , unsigned long end , unsigned long newflags ) ;
#line 861
extern int get_user_pages_fast(unsigned long start , int nr_pages , int write , struct page **pages ) ;
#line 888
extern void register_shrinker(struct shrinker * ) ;
#line 889
extern void unregister_shrinker(struct shrinker * ) ;
#line 891
extern int vma_wants_writenotify(struct vm_area_struct *vma ) ;
#line 893
extern pte_t *get_locked_pte(struct mm_struct *mm , unsigned long addr , spinlock_t **ptl ) ;
#line 896 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int __pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) 
{ 

  {
#line 899
  return (0);
}
}
#line 906 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static int __pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) 
{ 

  {
#line 909
  return (0);
}
}
#line 915
extern int __pte_alloc(struct mm_struct *mm , pmd_t *pmd , unsigned long address ) ;
#line 916
extern int __pte_alloc_kernel(pmd_t *pmd , unsigned long address ) ;
#line 923 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static pud_t *pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  pud_t *tmp___3 ;
  pud_t *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
  {
#line 925
  tmp___5 = pgd_none(*pgd);
  }
#line 925
  if (tmp___5) {
    {
#line 925
    tmp___6 = 1;
    }
  } else {
    {
#line 925
    tmp___6 = 0;
    }
  }
  {
#line 925
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
#line 925
  if (tmp___7) {
    {
#line 925
    tmp___8 = __pud_alloc(mm, pgd, address);
    }
#line 925
    if (tmp___8) {
      {
#line 925
      tmp___4 = (pud_t *)((void *)0);
      }
    } else {
      {
#line 925
      tmp___3 = pud_offset(pgd, address);
#line 925
      tmp___4 = tmp___3;
      }
    }
  } else {
    {
#line 925
    tmp___3 = pud_offset(pgd, address);
#line 925
    tmp___4 = tmp___3;
    }
  }
#line 925
  return (tmp___4);
}
}
#line 929 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static pmd_t *pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  pmd_t *tmp___3 ;
  pmd_t *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
  {
#line 931
  tmp___5 = pud_none(*pud);
  }
#line 931
  if (tmp___5) {
    {
#line 931
    tmp___6 = 1;
    }
  } else {
    {
#line 931
    tmp___6 = 0;
    }
  }
  {
#line 931
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
#line 931
  if (tmp___7) {
    {
#line 931
    tmp___8 = __pmd_alloc(mm, pud, address);
    }
#line 931
    if (tmp___8) {
      {
#line 931
      tmp___4 = (pmd_t *)((void *)0);
      }
    } else {
      {
#line 931
      tmp___3 = pmd_offset(pud, address);
#line 931
      tmp___4 = tmp___3;
      }
    }
  } else {
    {
#line 931
    tmp___3 = pmd_offset(pud, address);
#line 931
    tmp___4 = tmp___3;
    }
  }
#line 931
  return (tmp___4);
}
}
#line 960 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
static struct lock_class_key __key___0  ;
#line 958 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void pgtable_page_ctor(struct page *page ) 
{ 

  {
  {
#line 960
  while (1) {
    while_113_continue: /* CIL Label */ ;
    {
#line 960
    while (1) {
      while_114_continue: /* CIL Label */ ;
      {
#line 960
      __spin_lock_init(& page->__annonCompField18.ptl, "__pte_lockptr(page)", & __key___0);
      }
      goto while_114_break;
    }
    while_114_break: /* CIL Label */ ;
    }
    goto while_113_break;
  }
  while_113_break: /* CIL Label */ ;
  }
  {
#line 961
  inc_zone_page_state(page, (enum zone_stat_item )14);
  }
#line 962
  return;
}
}
#line 964 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void pgtable_page_dtor(struct page *page ) 
{ 

  {
  {
#line 966
  page->__annonCompField18.__annonCompField17.mapping = (struct address_space *)((void *)0);
#line 967
  dec_zone_page_state(page, (enum zone_stat_item )14);
  }
#line 968
  return;
}
}
#line 996
extern void free_area_init(unsigned long *zones_size ) ;
#line 997
extern void free_area_init_node(int nid , unsigned long *zones_size , unsigned long zone_start_pfn ,
                                unsigned long *zholes_size ) ;
#line 1027
extern void free_area_init_nodes(unsigned long *max_zone_pfn ) ;
#line 1028
extern void add_active_range(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
#line 1030
extern void remove_active_range(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
#line 1032
extern void push_node_boundaries(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
#line 1034
extern void remove_all_active_ranges(void) ;
#line 1035
extern unsigned long absent_pages_in_range(unsigned long start_pfn , unsigned long end_pfn ) ;
#line 1037
extern void get_pfn_range_for_nid(unsigned int nid , unsigned long *start_pfn , unsigned long *end_pfn ) ;
#line 1039
extern unsigned long find_min_pfn_with_active_regions(void) ;
#line 1040
extern void free_bootmem_with_active_regions(int nid , unsigned long max_low_pfn ) ;
#line 1043
extern void work_with_active_regions(int nid , int (*work_fn)(unsigned long  , unsigned long  ,
                                                              void * ) , void *data ) ;
#line 1044
extern void sparse_memory_present_with_active_regions(int nid ) ;
#line 1055
extern int early_pfn_to_nid(unsigned long pfn )  __attribute__((__section__(".meminit.text"))) ;
#line 1062
extern void set_dma_reserve(unsigned long new_dma_reserve ) ;
#line 1063
extern void memmap_init_zone(unsigned long  , int  , unsigned long  , unsigned long  ,
                             enum memmap_context  ) ;
#line 1065
extern void setup_per_zone_pages_min(void) ;
#line 1066
extern void mem_init(void) ;
#line 1067
extern void mmap_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 1068
extern void show_mem(void) ;
#line 1069
extern void si_meminfo(struct sysinfo *val ) ;
#line 1070
extern void si_meminfo_node(struct sysinfo *val , int nid ) ;
#line 1071
extern int after_bootmem ;
#line 1076 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void setup_per_cpu_pageset(void) 
{ 

  {
#line 1076
  return;
}
}
#line 1080
extern atomic_long_t mmap_pages_allocated ;
#line 1083
extern void vma_prio_tree_add(struct vm_area_struct * , struct vm_area_struct *old ) ;
#line 1084
extern void vma_prio_tree_insert(struct vm_area_struct * , struct prio_tree_root * ) ;
#line 1085
extern void vma_prio_tree_remove(struct vm_area_struct * , struct prio_tree_root * ) ;
#line 1086
extern struct vm_area_struct *vma_prio_tree_next(struct vm_area_struct *vma , struct prio_tree_iter *iter ) ;
#line 1093 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void vma_nonlinear_insert(struct vm_area_struct *vma , struct list_head *list ) 
{ 

  {
  {
#line 1096
  vma->shared.vm_set.parent = (void *)0;
#line 1097
  list_add_tail(& vma->shared.vm_set.list, list);
  }
#line 1098
  return;
}
}
#line 1101
extern int __vm_enough_memory(struct mm_struct *mm , long pages , int cap_sys_admin ) ;
#line 1102
extern void vma_adjust(struct vm_area_struct *vma , unsigned long start , unsigned long end ,
                       unsigned long pgoff , struct vm_area_struct *insert ) ;
#line 1104
extern struct vm_area_struct *vma_merge(struct mm_struct * , struct vm_area_struct *prev ,
                                        unsigned long addr , unsigned long end , unsigned long vm_flags ,
                                        struct anon_vma * , struct file * , unsigned long  ,
                                        struct mempolicy * ) ;
#line 1108
extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct * ) ;
#line 1109
extern int split_vma(struct mm_struct * , struct vm_area_struct * , unsigned long addr ,
                     int new_below ) ;
#line 1111
extern int insert_vm_struct(struct mm_struct * , struct vm_area_struct * ) ;
#line 1112
extern void __vma_link_rb(struct mm_struct * , struct vm_area_struct * , struct rb_node ** ,
                          struct rb_node * ) ;
#line 1114
extern void unlink_file_vma(struct vm_area_struct * ) ;
#line 1115
extern struct vm_area_struct *copy_vma(struct vm_area_struct ** , unsigned long addr ,
                                       unsigned long len , unsigned long pgoff ) ;
#line 1117
extern void exit_mmap(struct mm_struct * ) ;
#line 1119
extern int mm_take_all_locks(struct mm_struct *mm ) ;
#line 1120
extern void mm_drop_all_locks(struct mm_struct *mm ) ;
#line 1124
extern void added_exe_file_vma(struct mm_struct *mm ) ;
#line 1125
extern void removed_exe_file_vma(struct mm_struct *mm ) ;
#line 1134
extern int may_expand_vm(struct mm_struct *mm , unsigned long npages ) ;
#line 1135
extern int install_special_mapping(struct mm_struct *mm , unsigned long addr , unsigned long len ,
                                   unsigned long flags , struct page **pages ) ;
#line 1139
extern unsigned long get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                       unsigned long  , unsigned long  ) ;
#line 1141
extern unsigned long do_mmap_pgoff(struct file *file , unsigned long addr , unsigned long len ,
                                   unsigned long prot , unsigned long flag , unsigned long pgoff ) ;
#line 1144
extern unsigned long mmap_region(struct file *file , unsigned long addr , unsigned long len ,
                                 unsigned long flags , unsigned int vm_flags , unsigned long pgoff ) ;
#line 1148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static unsigned long do_mmap(struct file *file , unsigned long addr , unsigned long len ,
                                      unsigned long prot , unsigned long flag , unsigned long offset ) 
{ unsigned long ret ;

  {
  {
#line 1152
  ret = 0xffffffeaUL;
  }
#line 1153
  if (offset + ((len + ((1UL << 12) - 1UL)) & ~ ((1UL << 12) - 1UL)) < offset) {
    goto out;
  }
#line 1155
  if (! (offset & ~ (~ ((1UL << 12) - 1UL)))) {
    {
#line 1156
    ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 12);
    }
  }
  out: 
#line 1158
  return (ret);
}
}
#line 1161
extern int do_munmap(struct mm_struct * , unsigned long  , size_t  ) ;
#line 1163
extern unsigned long do_brk(unsigned long  , unsigned long  ) ;
#line 1166
extern unsigned long page_unuse(struct page * ) ;
#line 1167
extern void truncate_inode_pages(struct address_space * , loff_t  ) ;
#line 1168
extern void truncate_inode_pages_range(struct address_space * , loff_t lstart , loff_t lend ) ;
#line 1172
extern int filemap_fault(struct vm_area_struct * , struct vm_fault * ) ;
#line 1175
extern int write_one_page(struct page *page , int wait ) ;
#line 1176
extern void task_dirty_inc(struct task_struct *tsk ) ;
#line 1182
extern int do_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                   unsigned long offset , unsigned long nr_to_read ) ;
#line 1184
extern int force_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                      unsigned long offset , unsigned long nr_to_read ) ;
#line 1187
extern void page_cache_sync_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                      struct file *filp , unsigned long offset , unsigned long size ) ;
#line 1193
extern void page_cache_async_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                       struct file *filp , struct page *pg , unsigned long offset ,
                                       unsigned long size ) ;
#line 1200
extern unsigned long max_sane_readahead(unsigned long nr ) ;
#line 1203
extern int expand_stack(struct vm_area_struct *vma , unsigned long address ) ;
#line 1207
extern int expand_stack_downwards(struct vm_area_struct *vma , unsigned long address ) ;
#line 1211
extern struct vm_area_struct *find_vma(struct mm_struct *mm , unsigned long addr ) ;
#line 1212
extern struct vm_area_struct *find_vma_prev(struct mm_struct *mm , unsigned long addr ,
                                            struct vm_area_struct **pprev ) ;
#line 1217 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static struct vm_area_struct *find_vma_intersection(struct mm_struct *mm ,
                                                             unsigned long start_addr ,
                                                             unsigned long end_addr ) 
{ struct vm_area_struct *vma ;
  struct vm_area_struct *tmp ;

  {
  {
#line 1219
  tmp = find_vma(mm, start_addr);
#line 1219
  vma = tmp;
  }
#line 1221
  if (vma) {
#line 1221
    if (end_addr <= vma->vm_start) {
      {
#line 1222
      vma = (struct vm_area_struct *)((void *)0);
      }
    }
  }
#line 1223
  return (vma);
}
}
#line 1226 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static unsigned long vma_pages(struct vm_area_struct *vma ) 
{ 

  {
#line 1228
  return ((vma->vm_end - vma->vm_start) >> 12);
}
}
#line 1231
extern pgprot_t vm_get_page_prot(unsigned long vm_flags ) ;
#line 1232
extern struct vm_area_struct *find_extend_vma(struct mm_struct * , unsigned long addr ) ;
#line 1233
extern int remap_pfn_range(struct vm_area_struct * , unsigned long addr , unsigned long pfn ,
                           unsigned long size , pgprot_t  ) ;
#line 1235
extern int vm_insert_page(struct vm_area_struct * , unsigned long addr , struct page * ) ;
#line 1236
extern int vm_insert_pfn(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
#line 1238
extern int vm_insert_mixed(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
#line 1241
extern struct page *follow_page(struct vm_area_struct * , unsigned long address ,
                                unsigned int foll_flags ) ;
#line 1250
extern int apply_to_page_range(struct mm_struct *mm , unsigned long address , unsigned long size ,
                               int (*fn)(pte_t *pte , pgtable_t token , unsigned long addr ,
                                         void *data ) , void *data ) ;
#line 1254
extern void vm_stat_account(struct mm_struct * , unsigned long  , struct file * ,
                            long  ) ;
#line 1275 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void kernel_map_pages(struct page *page , int numpages , int enable ) 
{ 

  {
#line 1276
  return;
}
}
#line 1277 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static void enable_debug_pagealloc(void) 
{ 

  {
#line 1279
  return;
}
}
#line 1281 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/mm.h"
__inline static bool kernel_page_present(struct page *page ) 
{ 

  {
#line 1281
  return ((_Bool)1);
}
}
#line 1285
extern struct vm_area_struct *get_gate_vma(struct task_struct *tsk ) ;
#line 1287
extern int in_gate_area_no_task(unsigned long addr ) ;
#line 1288
extern int in_gate_area(struct task_struct *task , unsigned long addr ) ;
#line 1294
extern int drop_caches_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                      void * , size_t * , loff_t * ) ;
#line 1296
extern unsigned long shrink_slab(unsigned long scanned , gfp_t gfp_mask , unsigned long lru_pages ) ;
#line 1302
extern int randomize_va_space ;
#line 1305
extern char const   *arch_vma_name(struct vm_area_struct *vma ) ;
#line 1306
extern void print_vma_addr(char *prefix , unsigned long rip ) ;
#line 1308
extern struct page *sparse_mem_map_populate(unsigned long pnum , int nid ) ;
#line 1309
extern pgd_t *vmemmap_pgd_populate(unsigned long addr , int node ) ;
#line 1310
extern pud_t *vmemmap_pud_populate(pgd_t *pgd , unsigned long addr , int node ) ;
#line 1311
extern pmd_t *vmemmap_pmd_populate(pud_t *pud , unsigned long addr , int node ) ;
#line 1312
extern pte_t *vmemmap_pte_populate(pmd_t *pmd , unsigned long addr , int node ) ;
#line 1313
extern void *vmemmap_alloc_block(unsigned long size , int node ) ;
#line 1314
extern void vmemmap_verify(pte_t * , int  , unsigned long  , unsigned long  ) ;
#line 1315
extern int vmemmap_populate_basepages(struct page *start_page , unsigned long pages ,
                                      int node ) ;
#line 1317
extern int vmemmap_populate(struct page *start_page , unsigned long pages , int node ) ;
#line 1318
extern void vmemmap_populate_print_last(void) ;
#line 1320
extern void *alloc_locked_buffer(size_t size ) ;
#line 1321
extern void free_locked_buffer(void *buffer , size_t size ) ;
#line 1322
extern void release_locked_buffer(void *buffer , size_t size ) ;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pci.h"
extern int pci_routeirq ;
#line 26
extern struct pci_bus *pci_scan_bus_on_node(int busno , struct pci_ops *ops , int node ) ;
#line 28
extern struct pci_bus *pci_scan_bus_with_sysdata(int busno ) ;
#line 30 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pci.h"
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ struct pci_sysdata *sd ;

  {
  {
#line 32
  sd = (struct pci_sysdata *)bus->sysdata;
  }
#line 33
  return (sd->domain);
}
}
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pci.h"
__inline static int pci_proc_domain(struct pci_bus *bus ) 
{ int tmp ;

  {
  {
#line 38
  tmp = pci_domain_nr(bus);
  }
#line 38
  return (tmp);
}
}
#line 47
extern unsigned int pcibios_assign_all_busses(void) ;
#line 53
extern unsigned long pci_mem_start ;
#line 59
extern void pcibios_config_init(void) ;
#line 60
extern struct pci_bus *pcibios_scan_root(int bus ) ;
#line 62
extern void pcibios_set_master(struct pci_dev *dev ) ;
#line 63
extern void pcibios_penalize_isa_irq(int irq , int active ) ;
#line 64
extern struct irq_routing_table *pcibios_get_irq_routing_table(void) ;
#line 65
extern int pcibios_set_irq_routing(struct pci_dev *dev , int pin , int irq ) ;
#line 69
extern int pci_mmap_page_range(struct pci_dev *dev , struct vm_area_struct *vma ,
                               enum pci_mmap_state mmap_state , int write_combine ) ;
#line 75
extern void early_quirks(void) ;
#line 76 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/pci.h"
__inline static void pci_dma_burst_advice(struct pci_dev *pdev , enum pci_dma_burst_strategy *strat ,
                                          unsigned long *strategy_parameter ) 
{ 

  {
  {
#line 80
  *strat = (enum pci_dma_burst_strategy )0;
#line 81
  *strategy_parameter = ~ 0UL;
  }
#line 82
  return;
}
}
#line 87
extern void pci_iommu_alloc(void) ;
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/bug.h"
__inline static int is_warning_bug(struct bug_entry  const  *bug ) 
{ 

  {
#line 20
  return ((int )((int const   )bug->flags & 1));
}
}
#line 23
extern struct bug_entry  const  *find_bug(unsigned long bugaddr ) ;
#line 25
extern enum bug_trap_type report_bug(unsigned long bug_addr , struct pt_regs *regs ) ;
#line 27
extern int module_bug_finalize(Elf32_Ehdr const   * , Elf32_Shdr const   * , struct module * ) ;
#line 29
extern void module_bug_cleanup(struct module * ) ;
#line 32
extern int is_valid_bugaddr(unsigned long addr ) ;
#line 34 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-attrs.h"
__inline static void init_dma_attrs(struct dma_attrs *attrs ) 
{ 

  {
  {
#line 36
  bitmap_zero(attrs->flags, (int )(((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))));
  }
#line 37
  return;
}
}
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-attrs.h"
__inline static void dma_set_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 

  {
#line 68
  return;
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-attrs.h"
__inline static int dma_get_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 

  {
#line 72
  return (0);
}
}
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ unsigned long page_link ;
  long tmp ;

  {
  {
#line 57
  page_link = sg->page_link & 3UL;
  }
  {
#line 63
  while (1) {
    while_115_continue: /* CIL Label */ ;
    {
#line 63
    tmp = __builtin_expect((long )(! (! ((unsigned long )page & 3UL))), 0L);
    }
#line 63
    if (tmp) {
      {
#line 63
      while (1) {
        while_116_continue: /* CIL Label */ ;
        {
#line 63
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"),
                             "i" (63), "i" (sizeof(struct bug_entry )));
        }
        {
#line 63
        while (1) {
          while_117_continue: /* CIL Label */ ;
        }
        while_117_break: /* CIL Label */ ;
        }
        goto while_116_break;
      }
      while_116_break: /* CIL Label */ ;
      }
    }
    goto while_115_break;
  }
  while_115_break: /* CIL Label */ ;
  }
  {
#line 68
  sg->page_link = page_link | (unsigned long )page;
  }
#line 69
  return;
}
}
#line 85 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 

  {
  {
#line 88
  sg_assign_page(sg, page);
#line 89
  sg->offset = offset;
#line 90
  sg->length = len;
  }
#line 91
  return;
}
}
#line 93 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 

  {
#line 99
  return ((struct page *)(sg->page_link & 0xfffffffcUL));
}
}
#line 109 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static void sg_set_buf(struct scatterlist *sg , void const   *buf , unsigned int buflen ) 
{ 

  {
  {
#line 112
  sg_set_page(sg, mem_map + (((unsigned long )buf - 3221225472UL) >> 12), buflen,
              (unsigned int )((unsigned long )buf & ~ (~ ((1UL << 12) - 1UL))));
  }
#line 113
  return;
}
}
#line 131 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static void sg_chain(struct scatterlist *prv , unsigned int prv_nents , struct scatterlist *sgl ) 
{ 

  {
  {
#line 141
  (prv + (prv_nents - 1U))->offset = 0U;
#line 142
  (prv + (prv_nents - 1U))->length = 0U;
#line 148
  (prv + (prv_nents - 1U))->page_link = ((unsigned long )sgl | 1UL) & 0xfffffffdUL;
  }
#line 149
  return;
}
}
#line 160 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static void sg_mark_end(struct scatterlist *sg ) 
{ 

  {
  {
#line 168
  sg->page_link |= 2UL;
#line 169
  sg->page_link &= 0xfffffffeUL;
  }
#line 170
  return;
}
}
#line 182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static dma_addr_t sg_phys(struct scatterlist *sg ) 
{ struct page *tmp ;

  {
  {
#line 184
  tmp = sg_page(sg);
  }
#line 184
  return (((unsigned int )((unsigned long )(tmp - mem_map)) << 12) + sg->offset);
}
}
#line 197 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ struct page *tmp ;
  void *tmp___0 ;

  {
  {
#line 199
  tmp = sg_page(sg);
#line 199
  tmp___0 = page_address(tmp);
  }
#line 199
  return (tmp___0 + sg->offset);
}
}
#line 202
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 203
extern struct scatterlist *sg_last(struct scatterlist *s , unsigned int  ) ;
#line 204
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 205
extern void sg_init_one(struct scatterlist * , void const   * , unsigned int  ) ;
#line 210
extern void __sg_free_table(struct sg_table * , unsigned int  , sg_free_fn * ) ;
#line 211
extern void sg_free_table(struct sg_table * ) ;
#line 212
extern int __sg_alloc_table(struct sg_table * , unsigned int  , unsigned int  , gfp_t  ,
                            sg_alloc_fn * ) ;
#line 214
extern int sg_alloc_table(struct sg_table * , unsigned int  , gfp_t  ) ;
#line 216
extern size_t sg_copy_from_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                  size_t buflen ) ;
#line 218
extern size_t sg_copy_to_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                size_t buflen ) ;
#line 260
extern void sg_miter_start(struct sg_mapping_iter *miter , struct scatterlist *sgl ,
                           unsigned int nents , unsigned int flags ) ;
#line 262
extern bool sg_miter_next(struct sg_mapping_iter *miter ) ;
#line 263
extern void sg_miter_stop(struct sg_mapping_iter *miter ) ;
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ int tmp ;

  {
#line 89
  if (dma_direction == 0) {
    {
#line 89
    tmp = 1;
    }
  } else {
#line 89
    if (dma_direction == 1) {
      {
#line 89
      tmp = 1;
      }
    } else {
#line 89
      if (dma_direction == 2) {
        {
#line 89
        tmp = 1;
        }
      } else {
        {
#line 89
        tmp = 0;
        }
      }
    }
  }
#line 89
  return (tmp);
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ int tmp ;

  {
#line 96
  if ((unsigned long )dev->dma_mask != (unsigned long )((void *)0)) {
#line 96
    if (*(dev->dma_mask) != 0ULL) {
      {
#line 96
      tmp = 1;
      }
    } else {
      {
#line 96
      tmp = 0;
      }
    }
  } else {
    {
#line 96
    tmp = 0;
    }
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static int is_buffer_dma_capable(u64 mask , dma_addr_t addr , size_t size ) 
{ 

  {
#line 101
  return ((u64 )(addr + size) <= mask);
}
}
#line 86 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void dma_debug_add_bus(struct bus_type *bus ) 
{ 

  {
#line 88
  return;
}
}
#line 90 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void dma_debug_init(u32 num_entries ) 
{ 

  {
#line 92
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , int direction , dma_addr_t dma_addr ,
                                        bool map_single ) 
{ 

  {
#line 99
  return;
}
}
#line 101 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                          int direction , bool map_single ) 
{ 

  {
#line 105
  return;
}
}
#line 107 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_map_sg(struct device *dev , struct scatterlist *sg ,
                                      int nents , int mapped_ents , int direction ) 
{ 

  {
#line 110
  return;
}
}
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_unmap_sg(struct device *dev , struct scatterlist *sglist ,
                                        int nelems , int dir ) 
{ 

  {
#line 116
  return;
}
}
#line 118 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t dma_addr ,
                                              void *virt ) 
{ 

  {
#line 121
  return;
}
}
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_free_coherent(struct device *dev , size_t size , void *virt ,
                                             dma_addr_t addr ) 
{ 

  {
#line 126
  return;
}
}
#line 128 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                   size_t size , int direction ) 
{ 

  {
#line 132
  return;
}
}
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_for_device(struct device *dev , dma_addr_t dma_handle ,
                                                      size_t size , int direction ) 
{ 

  {
#line 138
  return;
}
}
#line 140 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                         unsigned long offset , size_t size ,
                                                         int direction ) 
{ 

  {
#line 146
  return;
}
}
#line 148 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_single_range_for_device(struct device *dev , dma_addr_t dma_handle ,
                                                            unsigned long offset ,
                                                            size_t size , int direction ) 
{ 

  {
#line 154
  return;
}
}
#line 156 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_sg_for_cpu(struct device *dev , struct scatterlist *sg ,
                                               int nelems , int direction ) 
{ 

  {
#line 160
  return;
}
}
#line 162 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_sync_sg_for_device(struct device *dev , struct scatterlist *sg ,
                                                  int nelems , int direction ) 
{ 

  {
#line 166
  return;
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-debug.h"
__inline static void debug_dma_dump_mappings(struct device *dev ) 
{ 

  {
#line 170
  return;
}
}
#line 24 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/swiotlb.h"
extern void swiotlb_init(void) ;
#line 27
extern void *swiotlb_alloc_boot(size_t bytes , unsigned long nslabs ) ;
#line 28
extern void *swiotlb_alloc(unsigned int order , unsigned long nslabs ) ;
#line 30
extern dma_addr_t swiotlb_phys_to_bus(struct device *hwdev , phys_addr_t address ) ;
#line 32
extern phys_addr_t swiotlb_bus_to_phys(dma_addr_t address ) ;
#line 34
extern int swiotlb_arch_range_needs_mapping(phys_addr_t paddr , size_t size ) ;
#line 36
extern void *swiotlb_alloc_coherent(struct device *hwdev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t flags ) ;
#line 40
extern void swiotlb_free_coherent(struct device *hwdev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
#line 44
extern dma_addr_t swiotlb_map_page(struct device *dev , struct page *page , unsigned long offset ,
                                   size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 48
extern void swiotlb_unmap_page(struct device *hwdev , dma_addr_t dev_addr , size_t size ,
                               enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 52
extern int swiotlb_map_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                          int direction ) ;
#line 56
extern void swiotlb_unmap_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                             int direction ) ;
#line 60
extern int swiotlb_map_sg_attrs(struct device *hwdev , struct scatterlist *sgl , int nelems ,
                                enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 64
extern void swiotlb_unmap_sg_attrs(struct device *hwdev , struct scatterlist *sgl ,
                                   int nelems , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
#line 69
extern void swiotlb_sync_single_for_cpu(struct device *hwdev , dma_addr_t dev_addr ,
                                        size_t size , enum dma_data_direction dir ) ;
#line 73
extern void swiotlb_sync_sg_for_cpu(struct device *hwdev , struct scatterlist *sg ,
                                    int nelems , enum dma_data_direction dir ) ;
#line 77
extern void swiotlb_sync_single_for_device(struct device *hwdev , dma_addr_t dev_addr ,
                                           size_t size , enum dma_data_direction dir ) ;
#line 81
extern void swiotlb_sync_sg_for_device(struct device *hwdev , struct scatterlist *sg ,
                                       int nelems , enum dma_data_direction dir ) ;
#line 85
extern void swiotlb_sync_single_range_for_cpu(struct device *hwdev , dma_addr_t dev_addr ,
                                              unsigned long offset , size_t size ,
                                              enum dma_data_direction dir ) ;
#line 90
extern void swiotlb_sync_single_range_for_device(struct device *hwdev , dma_addr_t dev_addr ,
                                                 unsigned long offset , size_t size ,
                                                 enum dma_data_direction dir ) ;
#line 95
extern int swiotlb_dma_mapping_error(struct device *hwdev , dma_addr_t dma_addr ) ;
#line 98
extern int swiotlb_dma_supported(struct device *hwdev , u64 mask ) ;
#line 8 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swiotlb.h"
extern int swiotlb_force ;
#line 15 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swiotlb.h"
__inline static void pci_swiotlb_init(void) 
{ 

  {
#line 17
  return;
}
}
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/swiotlb.h"
__inline static void dma_mark_clean(void *addr , size_t size ) 
{ 

  {
#line 20
  return;
}
}
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/dma-coherent.h"
extern int dma_alloc_from_coherent(struct device *dev , ssize_t size , dma_addr_t *dma_handle ,
                                   void **ret ) ;
#line 11
extern int dma_release_from_coherent(struct device *dev , int order , void *vaddr ) ;
#line 17
extern int dma_declare_coherent_memory(struct device *dev , dma_addr_t bus_addr ,
                                       dma_addr_t device_addr , size_t size , int flags ) ;
#line 21
extern void dma_release_declared_memory(struct device *dev ) ;
#line 24
extern void *dma_mark_declared_memory_occupied(struct device *dev , dma_addr_t device_addr ,
                                               size_t size ) ;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
extern dma_addr_t bad_dma_address ;
#line 17
extern int iommu_merge ;
#line 18
extern struct device x86_dma_fallback_dev ;
#line 19
extern int panic_on_overflow ;
#line 21
extern struct dma_map_ops *dma_ops ;
#line 23 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 

  {
#line 26
  return (dma_ops);
}
}
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
  {
#line 38
  tmp = get_dma_ops(dev);
#line 38
  ops = tmp;
  }
#line 39
  if (ops->mapping_error) {
    {
#line 40
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
    }
#line 40
    return (tmp___0);
  }
#line 42
  return (dma_addr == bad_dma_address);
}
}
#line 49
extern int dma_supported(struct device *hwdev , u64 mask ) ;
#line 50
extern int dma_set_mask(struct device *dev , u64 mask ) ;
#line 52
extern void *dma_generic_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_addr ,
                                        gfp_t flag ) ;
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static dma_addr_t dma_map_single(struct device *hwdev , void *ptr , size_t size ,
                                          enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 59
  tmp = get_dma_ops(hwdev);
#line 59
  ops = tmp;
  }
  {
#line 62
  while (1) {
    while_118_continue: /* CIL Label */ ;
    {
#line 62
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 62
    if (tmp___0) {
      {
#line 62
      tmp___1 = 0;
      }
    } else {
      {
#line 62
      tmp___1 = 1;
      }
    }
    {
#line 62
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 62
    if (tmp___2) {
      {
#line 62
      while (1) {
        while_119_continue: /* CIL Label */ ;
        {
#line 62
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (62), "i" (sizeof(struct bug_entry )));
        }
        {
#line 62
        while (1) {
          while_120_continue: /* CIL Label */ ;
        }
        while_120_break: /* CIL Label */ ;
        }
        goto while_119_break;
      }
      while_119_break: /* CIL Label */ ;
      }
    }
    goto while_118_break;
  }
  while_118_break: /* CIL Label */ ;
  }
  {
#line 63
  addr = (*(ops->map_page))(hwdev, mem_map + (((unsigned long )ptr - 3221225472UL) >> 12),
                            (unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL)), size,
                            dir, (struct dma_attrs *)((void *)0));
#line 66
  debug_dma_map_page(hwdev, mem_map + (((unsigned long )ptr - 3221225472UL) >> 12),
                     (unsigned int )((unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL))),
                     size, (int )dir, addr, (_Bool)1);
  }
#line 69
  return (addr);
}
}
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_unmap_single(struct device *dev , dma_addr_t addr , size_t size ,
                                      enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 76
  tmp = get_dma_ops(dev);
#line 76
  ops = tmp;
  }
  {
#line 78
  while (1) {
    while_121_continue: /* CIL Label */ ;
    {
#line 78
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 78
    if (tmp___0) {
      {
#line 78
      tmp___1 = 0;
      }
    } else {
      {
#line 78
      tmp___1 = 1;
      }
    }
    {
#line 78
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 78
    if (tmp___2) {
      {
#line 78
      while (1) {
        while_122_continue: /* CIL Label */ ;
        {
#line 78
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (78), "i" (sizeof(struct bug_entry )));
        }
        {
#line 78
        while (1) {
          while_123_continue: /* CIL Label */ ;
        }
        while_123_break: /* CIL Label */ ;
        }
        goto while_122_break;
      }
      while_122_break: /* CIL Label */ ;
      }
    }
    goto while_121_break;
  }
  while_121_break: /* CIL Label */ ;
  }
#line 79
  if (ops->unmap_page) {
    {
#line 80
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)((void *)0));
    }
  }
  {
#line 81
  debug_dma_unmap_page(dev, addr, size, (int )dir, (_Bool)1);
  }
#line 82
  return;
}
}
#line 84 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_map_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                               enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int ents ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 88
  tmp = get_dma_ops(hwdev);
#line 88
  ops = tmp;
  }
  {
#line 91
  while (1) {
    while_124_continue: /* CIL Label */ ;
    {
#line 91
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 91
    if (tmp___0) {
      {
#line 91
      tmp___1 = 0;
      }
    } else {
      {
#line 91
      tmp___1 = 1;
      }
    }
    {
#line 91
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 91
    if (tmp___2) {
      {
#line 91
      while (1) {
        while_125_continue: /* CIL Label */ ;
        {
#line 91
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (91), "i" (sizeof(struct bug_entry )));
        }
        {
#line 91
        while (1) {
          while_126_continue: /* CIL Label */ ;
        }
        while_126_break: /* CIL Label */ ;
        }
        goto while_125_break;
      }
      while_125_break: /* CIL Label */ ;
      }
    }
    goto while_124_break;
  }
  while_124_break: /* CIL Label */ ;
  }
  {
#line 92
  ents = (*(ops->map_sg))(hwdev, sg, nents, dir, (struct dma_attrs *)((void *)0));
#line 93
  debug_dma_map_sg(hwdev, sg, nents, ents, (int )dir);
  }
#line 95
  return (ents);
}
}
#line 98 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_unmap_sg(struct device *hwdev , struct scatterlist *sg ,
                                  int nents , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 102
  tmp = get_dma_ops(hwdev);
#line 102
  ops = tmp;
  }
  {
#line 104
  while (1) {
    while_127_continue: /* CIL Label */ ;
    {
#line 104
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 104
    if (tmp___0) {
      {
#line 104
      tmp___1 = 0;
      }
    } else {
      {
#line 104
      tmp___1 = 1;
      }
    }
    {
#line 104
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 104
    if (tmp___2) {
      {
#line 104
      while (1) {
        while_128_continue: /* CIL Label */ ;
        {
#line 104
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (104), "i" (sizeof(struct bug_entry )));
        }
        {
#line 104
        while (1) {
          while_129_continue: /* CIL Label */ ;
        }
        while_129_break: /* CIL Label */ ;
        }
        goto while_128_break;
      }
      while_128_break: /* CIL Label */ ;
      }
    }
    goto while_127_break;
  }
  while_127_break: /* CIL Label */ ;
  }
  {
#line 105
  debug_dma_unmap_sg(hwdev, sg, nents, (int )dir);
  }
#line 106
  if (ops->unmap_sg) {
    {
#line 107
    (*(ops->unmap_sg))(hwdev, sg, nents, dir, (struct dma_attrs *)((void *)0));
    }
  }
#line 108
  return;
}
}
#line 110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_sync_single_for_cpu(struct device *hwdev , dma_addr_t dma_handle ,
                                             size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 114
  tmp = get_dma_ops(hwdev);
#line 114
  ops = tmp;
  }
  {
#line 116
  while (1) {
    while_130_continue: /* CIL Label */ ;
    {
#line 116
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 116
    if (tmp___0) {
      {
#line 116
      tmp___1 = 0;
      }
    } else {
      {
#line 116
      tmp___1 = 1;
      }
    }
    {
#line 116
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 116
    if (tmp___2) {
      {
#line 116
      while (1) {
        while_131_continue: /* CIL Label */ ;
        {
#line 116
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (116), "i" (sizeof(struct bug_entry )));
        }
        {
#line 116
        while (1) {
          while_132_continue: /* CIL Label */ ;
        }
        while_132_break: /* CIL Label */ ;
        }
        goto while_131_break;
      }
      while_131_break: /* CIL Label */ ;
      }
    }
    goto while_130_break;
  }
  while_130_break: /* CIL Label */ ;
  }
#line 117
  if (ops->sync_single_for_cpu) {
    {
#line 118
    (*(ops->sync_single_for_cpu))(hwdev, dma_handle, size, dir);
    }
  }
  {
#line 119
  debug_dma_sync_single_for_cpu(hwdev, dma_handle, size, (int )dir);
  }
  {
#line 120
  while (1) {
    while_133_continue: /* CIL Label */ ;
    goto while_133_break;
  }
  while_133_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_sync_single_for_device(struct device *hwdev , dma_addr_t dma_handle ,
                                                size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 127
  tmp = get_dma_ops(hwdev);
#line 127
  ops = tmp;
  }
  {
#line 129
  while (1) {
    while_134_continue: /* CIL Label */ ;
    {
#line 129
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 129
    if (tmp___0) {
      {
#line 129
      tmp___1 = 0;
      }
    } else {
      {
#line 129
      tmp___1 = 1;
      }
    }
    {
#line 129
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 129
    if (tmp___2) {
      {
#line 129
      while (1) {
        while_135_continue: /* CIL Label */ ;
        {
#line 129
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (129), "i" (sizeof(struct bug_entry )));
        }
        {
#line 129
        while (1) {
          while_136_continue: /* CIL Label */ ;
        }
        while_136_break: /* CIL Label */ ;
        }
        goto while_135_break;
      }
      while_135_break: /* CIL Label */ ;
      }
    }
    goto while_134_break;
  }
  while_134_break: /* CIL Label */ ;
  }
#line 130
  if (ops->sync_single_for_device) {
    {
#line 131
    (*(ops->sync_single_for_device))(hwdev, dma_handle, size, dir);
    }
  }
  {
#line 132
  debug_dma_sync_single_for_device(hwdev, dma_handle, size, (int )dir);
  }
  {
#line 133
  while (1) {
    while_137_continue: /* CIL Label */ ;
    goto while_137_break;
  }
  while_137_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_sync_single_range_for_cpu(struct device *hwdev , dma_addr_t dma_handle ,
                                                   unsigned long offset , size_t size ,
                                                   enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 141
  tmp = get_dma_ops(hwdev);
#line 141
  ops = tmp;
  }
  {
#line 143
  while (1) {
    while_138_continue: /* CIL Label */ ;
    {
#line 143
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 143
    if (tmp___0) {
      {
#line 143
      tmp___1 = 0;
      }
    } else {
      {
#line 143
      tmp___1 = 1;
      }
    }
    {
#line 143
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 143
    if (tmp___2) {
      {
#line 143
      while (1) {
        while_139_continue: /* CIL Label */ ;
        {
#line 143
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (143), "i" (sizeof(struct bug_entry )));
        }
        {
#line 143
        while (1) {
          while_140_continue: /* CIL Label */ ;
        }
        while_140_break: /* CIL Label */ ;
        }
        goto while_139_break;
      }
      while_139_break: /* CIL Label */ ;
      }
    }
    goto while_138_break;
  }
  while_138_break: /* CIL Label */ ;
  }
#line 144
  if (ops->sync_single_range_for_cpu) {
    {
#line 145
    (*(ops->sync_single_range_for_cpu))(hwdev, dma_handle, offset, size, dir);
    }
  }
  {
#line 147
  debug_dma_sync_single_range_for_cpu(hwdev, dma_handle, offset, size, (int )dir);
  }
  {
#line 149
  while (1) {
    while_141_continue: /* CIL Label */ ;
    goto while_141_break;
  }
  while_141_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_sync_single_range_for_device(struct device *hwdev , dma_addr_t dma_handle ,
                                                      unsigned long offset , size_t size ,
                                                      enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 157
  tmp = get_dma_ops(hwdev);
#line 157
  ops = tmp;
  }
  {
#line 159
  while (1) {
    while_142_continue: /* CIL Label */ ;
    {
#line 159
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 159
    if (tmp___0) {
      {
#line 159
      tmp___1 = 0;
      }
    } else {
      {
#line 159
      tmp___1 = 1;
      }
    }
    {
#line 159
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 159
    if (tmp___2) {
      {
#line 159
      while (1) {
        while_143_continue: /* CIL Label */ ;
        {
#line 159
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (159), "i" (sizeof(struct bug_entry )));
        }
        {
#line 159
        while (1) {
          while_144_continue: /* CIL Label */ ;
        }
        while_144_break: /* CIL Label */ ;
        }
        goto while_143_break;
      }
      while_143_break: /* CIL Label */ ;
      }
    }
    goto while_142_break;
  }
  while_142_break: /* CIL Label */ ;
  }
#line 160
  if (ops->sync_single_range_for_device) {
    {
#line 161
    (*(ops->sync_single_range_for_device))(hwdev, dma_handle, offset, size, dir);
    }
  }
  {
#line 163
  debug_dma_sync_single_range_for_device(hwdev, dma_handle, offset, size, (int )dir);
  }
  {
#line 165
  while (1) {
    while_145_continue: /* CIL Label */ ;
    goto while_145_break;
  }
  while_145_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_sync_sg_for_cpu(struct device *hwdev , struct scatterlist *sg ,
                                         int nelems , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 172
  tmp = get_dma_ops(hwdev);
#line 172
  ops = tmp;
  }
  {
#line 174
  while (1) {
    while_146_continue: /* CIL Label */ ;
    {
#line 174
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 174
    if (tmp___0) {
      {
#line 174
      tmp___1 = 0;
      }
    } else {
      {
#line 174
      tmp___1 = 1;
      }
    }
    {
#line 174
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 174
    if (tmp___2) {
      {
#line 174
      while (1) {
        while_147_continue: /* CIL Label */ ;
        {
#line 174
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (174), "i" (sizeof(struct bug_entry )));
        }
        {
#line 174
        while (1) {
          while_148_continue: /* CIL Label */ ;
        }
        while_148_break: /* CIL Label */ ;
        }
        goto while_147_break;
      }
      while_147_break: /* CIL Label */ ;
      }
    }
    goto while_146_break;
  }
  while_146_break: /* CIL Label */ ;
  }
#line 175
  if (ops->sync_sg_for_cpu) {
    {
#line 176
    (*(ops->sync_sg_for_cpu))(hwdev, sg, nelems, dir);
    }
  }
  {
#line 177
  debug_dma_sync_sg_for_cpu(hwdev, sg, nelems, (int )dir);
  }
  {
#line 178
  while (1) {
    while_149_continue: /* CIL Label */ ;
    goto while_149_break;
  }
  while_149_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_sync_sg_for_device(struct device *hwdev , struct scatterlist *sg ,
                                            int nelems , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 185
  tmp = get_dma_ops(hwdev);
#line 185
  ops = tmp;
  }
  {
#line 187
  while (1) {
    while_150_continue: /* CIL Label */ ;
    {
#line 187
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 187
    if (tmp___0) {
      {
#line 187
      tmp___1 = 0;
      }
    } else {
      {
#line 187
      tmp___1 = 1;
      }
    }
    {
#line 187
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 187
    if (tmp___2) {
      {
#line 187
      while (1) {
        while_151_continue: /* CIL Label */ ;
        {
#line 187
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (187), "i" (sizeof(struct bug_entry )));
        }
        {
#line 187
        while (1) {
          while_152_continue: /* CIL Label */ ;
        }
        while_152_break: /* CIL Label */ ;
        }
        goto while_151_break;
      }
      while_151_break: /* CIL Label */ ;
      }
    }
    goto while_150_break;
  }
  while_150_break: /* CIL Label */ ;
  }
#line 188
  if (ops->sync_sg_for_device) {
    {
#line 189
    (*(ops->sync_sg_for_device))(hwdev, sg, nelems, dir);
    }
  }
  {
#line 190
  debug_dma_sync_sg_for_device(hwdev, sg, nelems, (int )dir);
  }
  {
#line 192
  while (1) {
    while_153_continue: /* CIL Label */ ;
    goto while_153_break;
  }
  while_153_break: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 199
  tmp = get_dma_ops(dev);
#line 199
  ops = tmp;
  }
  {
#line 202
  while (1) {
    while_154_continue: /* CIL Label */ ;
    {
#line 202
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 202
    if (tmp___0) {
      {
#line 202
      tmp___1 = 0;
      }
    } else {
      {
#line 202
      tmp___1 = 1;
      }
    }
    {
#line 202
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 202
    if (tmp___2) {
      {
#line 202
      while (1) {
        while_155_continue: /* CIL Label */ ;
        {
#line 202
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (202), "i" (sizeof(struct bug_entry )));
        }
        {
#line 202
        while (1) {
          while_156_continue: /* CIL Label */ ;
        }
        while_156_break: /* CIL Label */ ;
        }
        goto while_155_break;
      }
      while_155_break: /* CIL Label */ ;
      }
    }
    goto while_154_break;
  }
  while_154_break: /* CIL Label */ ;
  }
  {
#line 203
  addr = (*(ops->map_page))(dev, page, (unsigned long )offset, size, dir, (struct dma_attrs *)((void *)0));
#line 204
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, (_Bool)0);
  }
#line 206
  return (addr);
}
}
#line 209 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 212
  tmp = get_dma_ops(dev);
#line 212
  ops = tmp;
  }
  {
#line 214
  while (1) {
    while_157_continue: /* CIL Label */ ;
    {
#line 214
    tmp___0 = valid_dma_direction((int )dir);
    }
#line 214
    if (tmp___0) {
      {
#line 214
      tmp___1 = 0;
      }
    } else {
      {
#line 214
      tmp___1 = 1;
      }
    }
    {
#line 214
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 214
    if (tmp___2) {
      {
#line 214
      while (1) {
        while_158_continue: /* CIL Label */ ;
        {
#line 214
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (214), "i" (sizeof(struct bug_entry )));
        }
        {
#line 214
        while (1) {
          while_159_continue: /* CIL Label */ ;
        }
        while_159_break: /* CIL Label */ ;
        }
        goto while_158_break;
      }
      while_158_break: /* CIL Label */ ;
      }
    }
    goto while_157_break;
  }
  while_157_break: /* CIL Label */ ;
  }
#line 215
  if (ops->unmap_page) {
    {
#line 216
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)((void *)0));
    }
  }
  {
#line 217
  debug_dma_unmap_page(dev, addr, size, (int )dir, (_Bool)0);
  }
#line 218
  return;
}
}
#line 220 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_cache_sync(struct device *dev , void *vaddr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 

  {
  {
#line 224
  while (1) {
    while_160_continue: /* CIL Label */ ;
    goto while_160_break;
  }
  while_160_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 227 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_get_cache_alignment(void) 
{ 

  {
#line 231
  return ((int )boot_cpu_data.x86_clflush_size);
}
}
#line 234 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;

  {
  {
#line 237
  dma_mask = 0UL;
#line 239
  dma_mask = (unsigned long )dev->coherent_dma_mask;
  }
#line 240
  if (! dma_mask) {
#line 241
    if (gfp & 1U) {
      {
#line 241
      dma_mask = (unsigned long )((1ULL << 24) - 1ULL);
      }
    } else {
      {
#line 241
      dma_mask = (unsigned long )((1ULL << 32) - 1ULL);
      }
    }
  }
#line 243
  return (dma_mask);
}
}
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;
  unsigned long tmp ;

  {
  {
#line 248
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 248
  dma_mask = tmp;
  }
#line 250
  if ((unsigned long long )dma_mask <= (1ULL << 24) - 1ULL) {
    {
#line 251
    gfp |= 1U;
    }
  }
#line 256
  return (gfp);
}
}
#line 259 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                         gfp_t gfp ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  int tmp___1 ;
  gfp_t tmp___2 ;

  {
  {
#line 263
  tmp = get_dma_ops(dev);
#line 263
  ops = tmp;
#line 266
  gfp &= 4294967288U;
#line 268
  tmp___0 = dma_alloc_from_coherent(dev, (int )size, dma_handle, & memory);
  }
#line 268
  if (tmp___0) {
#line 269
    return (memory);
  }
#line 271
  if (! dev) {
    {
#line 272
    dev = & x86_dma_fallback_dev;
#line 273
    gfp |= 1U;
    }
  }
  {
#line 276
  tmp___1 = is_device_dma_capable(dev);
  }
#line 276
  if (! tmp___1) {
#line 277
    return ((void *)0);
  }
#line 279
  if (! ops->alloc_coherent) {
#line 280
    return ((void *)0);
  }
  {
#line 282
  tmp___2 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 282
  memory = (*(ops->alloc_coherent))(dev, size, dma_handle, tmp___2);
#line 284
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
#line 286
  return (memory);
}
}
#line 289 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_coherent(struct device *dev , size_t size , void *vaddr ,
                                       dma_addr_t bus ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 292
  tmp = get_dma_ops(dev);
#line 292
  ops = tmp;
  }
  {
#line 294
  while (1) {
    while_161_continue: /* CIL Label */ ;
    {
#line 294
    _flags = __raw_local_save_flags();
    }
    goto while_161_break;
  }
  while_161_break: /* CIL Label */ ;
  }
  {
#line 294
  tmp___0 = raw_irqs_disabled_flags(_flags);
  }
#line 294
  if (tmp___0) {
    {
#line 294
    tmp___1 = 1;
    }
  } else {
    {
#line 294
    tmp___1 = 0;
    }
  }
  {
#line 294
  __ret_warn_on = tmp___1;
#line 294
  tmp___2 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 294
  if (tmp___2) {
    {
#line 294
    warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h",
                       294);
    }
  }
  {
#line 294
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 296
  tmp___3 = get_order((unsigned long )size);
#line 296
  tmp___4 = dma_release_from_coherent(dev, tmp___3, vaddr);
  }
#line 296
  if (tmp___4) {
#line 297
    return;
  }
  {
#line 299
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
#line 300
  if (ops->free_coherent) {
    {
#line 301
    (*(ops->free_coherent))(dev, size, vaddr, bus);
    }
  }
#line 302
  return;
}
}
#line 114 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static u64 dma_get_mask(struct device *dev ) 
{ 

  {
#line 116
  if (dev) {
#line 116
    if (dev->dma_mask) {
#line 116
      if (*(dev->dma_mask)) {
#line 117
        return (*(dev->dma_mask));
      }
    }
  }
#line 118
  return ((1ULL << 32) - 1ULL);
}
}
#line 121
extern u64 dma_get_required_mask(struct device *dev ) ;
#line 123 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static unsigned int dma_get_max_seg_size(struct device *dev ) 
{ unsigned int tmp ;

  {
#line 125
  if (dev->dma_parms) {
    {
#line 125
    tmp = (dev->dma_parms)->max_segment_size;
    }
  } else {
    {
#line 125
    tmp = 65536U;
    }
  }
#line 125
  return (tmp);
}
}
#line 128 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static unsigned int dma_set_max_seg_size(struct device *dev , unsigned int size ) 
{ 

  {
#line 131
  if (dev->dma_parms) {
    {
#line 132
    (dev->dma_parms)->max_segment_size = size;
    }
#line 133
    return (0U);
  } else {
#line 135
    return (4294967291U);
  }
}
}
#line 138 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static unsigned long dma_get_seg_boundary(struct device *dev ) 
{ unsigned long tmp ;

  {
#line 140
  if (dev->dma_parms) {
    {
#line 140
    tmp = (dev->dma_parms)->segment_boundary_mask;
    }
  } else {
    {
#line 140
    tmp = 4294967295UL;
    }
  }
#line 140
  return (tmp);
}
}
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dma-mapping.h"
__inline static int dma_set_seg_boundary(struct device *dev , unsigned long mask ) 
{ 

  {
#line 146
  if (dev->dma_parms) {
    {
#line 147
    (dev->dma_parms)->segment_boundary_mask = mask;
    }
#line 148
    return (0);
  } else {
#line 150
    return (-5);
  }
}
}
#line 183
extern void *dmam_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                 gfp_t gfp ) ;
#line 185
extern void dmam_free_coherent(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
#line 187
extern void *dmam_alloc_noncoherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t gfp ) ;
#line 189
extern void dmam_free_noncoherent(struct device *dev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
#line 192
extern int dmam_declare_coherent_memory(struct device *dev , dma_addr_t bus_addr ,
                                        dma_addr_t device_addr , size_t size , int flags ) ;
#line 195
extern void dmam_release_declared_memory(struct device *dev ) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_supported(struct pci_dev *hwdev , u64 mask ) 
{ struct device *tmp ;
  int tmp___0 ;

  {
#line 15
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 15
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 15
    tmp = & hwdev->dev;
    }
  }
  {
#line 15
  tmp___0 = dma_supported(tmp, mask);
  }
#line 15
  return (tmp___0);
}
}
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ struct device *tmp ;
  void *tmp___0 ;

  {
#line 22
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 22
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 22
    tmp = & hwdev->dev;
    }
  }
  {
#line 22
  tmp___0 = dma_alloc_coherent(tmp, size, dma_handle, 32U);
  }
#line 22
  return (tmp___0);
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ struct device *tmp ;

  {
#line 29
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 29
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 29
    tmp = & hwdev->dev;
    }
  }
  {
#line 29
  dma_free_coherent(tmp, size, vaddr, dma_handle);
  }
#line 30
  return;
}
}
#line 32 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 35
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 35
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 35
    tmp = & hwdev->dev;
    }
  }
  {
#line 35
  tmp___0 = dma_map_single(tmp, ptr, size, (enum dma_data_direction )direction);
  }
#line 35
  return (tmp___0);
}
}
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ struct device *tmp ;

  {
#line 42
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 42
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 42
    tmp = & hwdev->dev;
    }
  }
  {
#line 42
  dma_unmap_single(tmp, dma_addr, size, (enum dma_data_direction )direction);
  }
#line 43
  return;
}
}
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
#line 49
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 49
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 49
    tmp = & hwdev->dev;
    }
  }
  {
#line 49
  tmp___0 = dma_map_page(tmp, page, (unsigned int )offset, size, (enum dma_data_direction )direction);
  }
#line 49
  return (tmp___0);
}
}
#line 52 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
#line 56
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 56
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 56
    tmp = & hwdev->dev;
    }
  }
  {
#line 56
  dma_unmap_page(tmp, dma_address, size, (enum dma_data_direction )direction);
  }
#line 57
  return;
}
}
#line 59 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ struct device *tmp ;
  int tmp___0 ;

  {
#line 63
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 63
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 63
    tmp = & hwdev->dev;
    }
  }
  {
#line 63
  tmp___0 = dma_map_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  }
#line 63
  return (tmp___0);
}
}
#line 66 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ struct device *tmp ;

  {
#line 70
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 70
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 70
    tmp = & hwdev->dev;
    }
  }
  {
#line 70
  dma_unmap_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  }
#line 71
  return;
}
}
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction ) 
{ struct device *tmp ;

  {
#line 77
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 77
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 77
    tmp = & hwdev->dev;
    }
  }
  {
#line 77
  dma_sync_single_for_cpu(tmp, dma_handle, size, (enum dma_data_direction )direction);
  }
#line 78
  return;
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
#line 84
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 84
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 84
    tmp = & hwdev->dev;
    }
  }
  {
#line 84
  dma_sync_single_for_device(tmp, dma_handle, size, (enum dma_data_direction )direction);
  }
#line 85
  return;
}
}
#line 87 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev , struct scatterlist *sg ,
                                             int nelems , int direction ) 
{ struct device *tmp ;

  {
#line 91
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 91
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 91
    tmp = & hwdev->dev;
    }
  }
  {
#line 91
  dma_sync_sg_for_cpu(tmp, sg, nelems, (enum dma_data_direction )direction);
  }
#line 92
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static void pci_dma_sync_sg_for_device(struct pci_dev *hwdev , struct scatterlist *sg ,
                                                int nelems , int direction ) 
{ struct device *tmp ;

  {
#line 98
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
#line 98
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
#line 98
    tmp = & hwdev->dev;
    }
  }
  {
#line 98
  dma_sync_sg_for_device(tmp, sg, nelems, (enum dma_data_direction )direction);
  }
#line 99
  return;
}
}
#line 101 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci-dma-compat.h"
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr ) 
{ int tmp ;

  {
  {
#line 104
  tmp = dma_mapping_error(& pdev->dev, dma_addr);
  }
#line 104
  return (tmp);
}
}
#line 17 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci.h"
__inline static void pcibios_resource_to_bus(struct pci_dev *dev , struct pci_bus_region *region ,
                                             struct resource *res ) 
{ 

  {
  {
#line 21
  region->start = res->start;
#line 22
  region->end = res->end;
  }
#line 23
  return;
}
}
#line 25 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci.h"
__inline static void pcibios_bus_to_resource(struct pci_dev *dev , struct resource *res ,
                                             struct pci_bus_region *region ) 
{ 

  {
  {
#line 29
  res->start = region->start;
#line 30
  res->end = region->end;
  }
#line 31
  return;
}
}
#line 33 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci.h"
__inline static struct resource *pcibios_select_root(struct pci_dev *pdev , struct resource *res ) 
{ struct resource *root ;

  {
  {
#line 36
  root = (struct resource *)((void *)0);
  }
#line 38
  if (res->flags & 256UL) {
    {
#line 39
    root = & ioport_resource;
    }
  }
#line 40
  if (res->flags & 512UL) {
    {
#line 41
    root = & iomem_resource;
    }
  }
#line 43
  return (root);
}
}
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/pci.h"
__inline static int pci_get_legacy_ide_irq(struct pci_dev *dev , int channel ) 
{ int tmp ;

  {
#line 51
  if (channel) {
    {
#line 51
    tmp = 15;
    }
  } else {
    {
#line 51
    tmp = 14;
    }
  }
#line 51
  return (tmp);
}
}
#line 1117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;

  {
  {
#line 1119
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
#line 1119
  return (tmp);
}
}
#line 1122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 

  {
  {
#line 1124
  dev_set_drvdata(& pdev->dev, data);
  }
#line 1125
  return;
}
}
#line 1130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev *pdev ) 
{ char const   *tmp ;

  {
  {
#line 1132
  tmp = dev_name((struct device  const  *)(& pdev->dev));
  }
#line 1132
  return (tmp);
}
}
#line 1140 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static void pci_resource_to_user(struct pci_dev  const  *dev , int bar ,
                                          struct resource  const  *rsrc , resource_size_t *start ,
                                          resource_size_t *end ) 
{ 

  {
  {
#line 1144
  *start = (unsigned int )rsrc->start;
#line 1145
  *end = (unsigned int )rsrc->end;
  }
#line 1146
  return;
}
}
#line 1199
extern void pci_fixup_device(enum pci_fixup_pass pass , struct pci_dev *dev ) ;
#line 1201
extern void *pcim_iomap(struct pci_dev *pdev , int bar , unsigned long maxlen ) ;
#line 1202
extern void pcim_iounmap(struct pci_dev *pdev , void *addr ) ;
#line 1203
extern void * const  *pcim_iomap_table(struct pci_dev *pdev ) ;
#line 1204
extern int pcim_iomap_regions(struct pci_dev *pdev , u16 mask , char const   *name ) ;
#line 1205
extern int pcim_iomap_regions_request_all(struct pci_dev *pdev , u16 mask , char const   *name ) ;
#line 1207
extern void pcim_iounmap_regions(struct pci_dev *pdev , u16 mask ) ;
#line 1209
extern int pci_pci_problems ;
#line 1218
extern unsigned long pci_cardbus_io_size ;
#line 1219
extern unsigned long pci_cardbus_mem_size ;
#line 1221
extern int pcibios_add_platform_entries(struct pci_dev *dev ) ;
#line 1222
extern void pcibios_disable_device(struct pci_dev *dev ) ;
#line 1223
extern int pcibios_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
#line 1227
extern void pci_mmcfg_early_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1228
extern void pci_mmcfg_late_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 1234
extern int pci_ext_cfg_avail(struct pci_dev *dev ) ;
#line 1236
extern void *pci_ioremap_bar(struct pci_dev *pdev , int bar ) ;
#line 1243 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static int pci_enable_sriov(struct pci_dev *dev , int nr_virtfn ) 
{ 

  {
#line 1245
  return (-19);
}
}
#line 1247 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static void pci_disable_sriov(struct pci_dev *dev ) 
{ 

  {
#line 1249
  return;
}
}
#line 1250 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pci.h"
__inline static irqreturn_t pci_sriov_migration(struct pci_dev *dev ) 
{ 

  {
#line 1252
  return ((enum irqreturn )0);
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irqnr.h"
extern int nr_irqs ;
#line 27
extern struct irq_desc *irq_to_desc(unsigned int irq ) ;
#line 96 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
extern int file_caps_enabled ;
#line 444 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_combine(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 448
  while (1) {
    while_162_continue: /* CIL Label */ ;
    {
#line 448
    __capi = 0U;
    }
    {
#line 448
    while (1) {
      while_163_continue: /* CIL Label */ ;
#line 448
      if (! (__capi < 2U)) {
        goto while_163_break;
      }
      {
#line 448
      dest.cap[__capi] = a.cap[__capi] | b.cap[__capi];
#line 448
      __capi ++;
      }
    }
    while_163_break: /* CIL Label */ ;
    }
    goto while_162_break;
  }
  while_162_break: /* CIL Label */ ;
  }
#line 449
  return (dest);
}
}
#line 452 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_intersect(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 456
  while (1) {
    while_164_continue: /* CIL Label */ ;
    {
#line 456
    __capi = 0U;
    }
    {
#line 456
    while (1) {
      while_165_continue: /* CIL Label */ ;
#line 456
      if (! (__capi < 2U)) {
        goto while_165_break;
      }
      {
#line 456
      dest.cap[__capi] = a.cap[__capi] & b.cap[__capi];
#line 456
      __capi ++;
      }
    }
    while_165_break: /* CIL Label */ ;
    }
    goto while_164_break;
  }
  while_164_break: /* CIL Label */ ;
  }
#line 457
  return (dest);
}
}
#line 460 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop(kernel_cap_t a , kernel_cap_t drop ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 464
  while (1) {
    while_166_continue: /* CIL Label */ ;
    {
#line 464
    __capi = 0U;
    }
    {
#line 464
    while (1) {
      while_167_continue: /* CIL Label */ ;
#line 464
      if (! (__capi < 2U)) {
        goto while_167_break;
      }
      {
#line 464
      dest.cap[__capi] = a.cap[__capi] & ~ drop.cap[__capi];
#line 464
      __capi ++;
      }
    }
    while_167_break: /* CIL Label */ ;
    }
    goto while_166_break;
  }
  while_166_break: /* CIL Label */ ;
  }
#line 465
  return (dest);
}
}
#line 468 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_invert(kernel_cap_t c ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
#line 471
  while (1) {
    while_168_continue: /* CIL Label */ ;
    {
#line 471
    __capi = 0U;
    }
    {
#line 471
    while (1) {
      while_169_continue: /* CIL Label */ ;
#line 471
      if (! (__capi < 2U)) {
        goto while_169_break;
      }
      {
#line 471
      dest.cap[__capi] = ~ c.cap[__capi];
#line 471
      __capi ++;
      }
    }
    while_169_break: /* CIL Label */ ;
    }
    goto while_168_break;
  }
  while_168_break: /* CIL Label */ ;
  }
#line 472
  return (dest);
}
}
#line 475 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static int cap_isclear(kernel_cap_t a ) 
{ unsigned int __capi ;

  {
  {
#line 478
  __capi = 0U;
  }
  {
#line 478
  while (1) {
    while_170_continue: /* CIL Label */ ;
#line 478
    if (! (__capi < 2U)) {
      goto while_170_break;
    }
#line 479
    if (a.cap[__capi] != 0U) {
#line 480
      return (0);
    }
    {
#line 478
    __capi ++;
    }
  }
  while_170_break: /* CIL Label */ ;
  }
#line 482
  return (1);
}
}
#line 492 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static int cap_issubset(kernel_cap_t a , kernel_cap_t set ) 
{ kernel_cap_t dest ;
  int tmp ;

  {
  {
#line 495
  dest = cap_drop(a, set);
#line 496
  tmp = cap_isclear(dest);
  }
#line 496
  return (tmp);
}
}
#line 501 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static int cap_is_fs_cap(int cap ) 
{ kernel_cap_t __cap_fs_set ;

  {
  {
#line 503
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 503
  __cap_fs_set.cap[1] = (__u32 )1;
  }
#line 504
  return (! (! ((unsigned int )(1 << (cap & 31)) & __cap_fs_set.cap[cap >> 5])));
}
}
#line 507 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop_fs_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
#line 509
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 509
  __cap_fs_set.cap[1] = (__u32 )1;
#line 510
  tmp = cap_drop(a, __cap_fs_set);
  }
#line 510
  return (tmp);
}
}
#line 513 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_raise_fs_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
#line 516
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
#line 516
  __cap_fs_set.cap[1] = (__u32 )1;
#line 517
  tmp = cap_intersect(permitted, __cap_fs_set);
#line 517
  tmp___0 = cap_combine(a, tmp);
  }
#line 517
  return (tmp___0);
}
}
#line 521 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_drop_nfsd_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
#line 523
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
#line 523
  __cap_fs_set.cap[1] = (__u32 )1;
#line 524
  tmp = cap_drop(a, __cap_fs_set);
  }
#line 524
  return (tmp);
}
}
#line 527 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/capability.h"
__inline static kernel_cap_t cap_raise_nfsd_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_nfsd_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
#line 530
  __cap_nfsd_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
#line 530
  __cap_nfsd_set.cap[1] = (__u32 )1;
#line 531
  tmp = cap_intersect(permitted, __cap_nfsd_set);
#line 531
  tmp___0 = cap_combine(a, tmp);
  }
#line 531
  return (tmp___0);
}
}
#line 535
extern kernel_cap_t const   __cap_empty_set ;
#line 536
extern kernel_cap_t const   __cap_full_set ;
#line 537
extern kernel_cap_t const   __cap_init_eff_set ;
#line 565
extern int capable(int cap ) ;
#line 569
extern int get_vfs_caps_from_disk(struct dentry  const  *dentry , struct cpu_vfs_cap_data *cpu_caps ) ;
#line 142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sem.h"
extern int copy_semundo(unsigned long clone_flags , struct task_struct *tsk ) ;
#line 143
extern void exit_sem(struct task_struct *tsk ) ;
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/signal.h"
extern void do_notify_resume(struct pt_regs * , void * , __u32  ) ;
#line 275 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
extern void do_schedule_next_timer(struct siginfo *info ) ;
#line 281 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/siginfo.h"
__inline static void copy_siginfo(struct siginfo *to , struct siginfo *from ) 
{ 

  {
#line 283
  if (from->si_code < 0) {
    {
#line 284
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )sizeof(*to));
    }
  } else {
    {
#line 287
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )(4UL * sizeof(int ) + sizeof(from->_sifields._sigchld)));
    }
  }
#line 288
  return;
}
}
#line 292
extern int copy_siginfo_to_user(struct siginfo *to , struct siginfo *from ) ;
#line 38 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigaddset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
#line 40
  sig = (unsigned long )(_sig - 1);
#line 42
  set->sig[0] |= 1UL << sig;
  }
#line 45
  return;
}
}
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigdelset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
#line 49
  sig = (unsigned long )(_sig - 1);
#line 51
  set->sig[0] &= ~ (1UL << sig);
  }
#line 54
  return;
}
}
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigismember(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
#line 58
  sig = (unsigned long )(_sig - 1);
  }
#line 60
  return ((int )(1UL & (set->sig[0] >> sig)));
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigfindinword(unsigned long word ) 
{ unsigned long tmp ;

  {
  {
#line 67
  tmp = ffz(~ word);
  }
#line 67
  return ((int )tmp);
}
}
#line 74
extern void _NSIG_WORDS_is_unsupported_size(void) ;
#line 72 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigisemptyset(sigset_t *set ) 
{ 

  {
#line 76
  if (1 == 4) {
    goto switch_171_4;
  } else {
#line 79
    if (1 == 2) {
      goto switch_171_2;
    } else {
#line 81
      if (1 == 1) {
        goto switch_171_1;
      } else {
        {
        goto switch_171_default;
#line 75
        if (0) {
          switch_171_4: /* CIL Label */ 
#line 77
          return ((((set->sig[3] | set->sig[2]) | set->sig[1]) | set->sig[0]) == 0UL);
          switch_171_2: /* CIL Label */ 
#line 80
          return ((set->sig[1] | set->sig[0]) == 0UL);
          switch_171_1: /* CIL Label */ 
#line 82
          return (set->sig[0] == 0UL);
          switch_171_default: /* CIL Label */ 
          {
#line 84
          _NSIG_WORDS_is_unsupported_size();
          }
#line 85
          return (0);
        } else {
          switch_171_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
#line 119 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigorsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
#line 119
  if (1 == 4) {
    goto switch_172_4;
  } else {
#line 119
    if (1 == 2) {
      goto switch_172_2;
    } else {
#line 119
      if (1 == 1) {
        goto switch_172_1;
      } else {
        {
        goto switch_172_default;
#line 119
        if (0) {
          switch_172_4: /* CIL Label */ 
          {
#line 119
          a3 = a->sig[3];
#line 119
          a2 = a->sig[2];
#line 119
          b3 = b->sig[3];
#line 119
          b2 = b->sig[2];
#line 119
          r->sig[3] = a3 | b3;
#line 119
          r->sig[2] = a2 | b2;
          }
          switch_172_2: /* CIL Label */ 
          {
#line 119
          a1 = a->sig[1];
#line 119
          b1 = b->sig[1];
#line 119
          r->sig[1] = a1 | b1;
          }
          switch_172_1: /* CIL Label */ 
          {
#line 119
          a0 = a->sig[0];
#line 119
          b0 = b->sig[0];
#line 119
          r->sig[0] = a0 | b0;
          }
          goto switch_172_break;
          switch_172_default: /* CIL Label */ 
          {
#line 119
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_172_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 119
  return;
}
}
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
#line 122
  if (1 == 4) {
    goto switch_173_4;
  } else {
#line 122
    if (1 == 2) {
      goto switch_173_2;
    } else {
#line 122
      if (1 == 1) {
        goto switch_173_1;
      } else {
        {
        goto switch_173_default;
#line 122
        if (0) {
          switch_173_4: /* CIL Label */ 
          {
#line 122
          a3 = a->sig[3];
#line 122
          a2 = a->sig[2];
#line 122
          b3 = b->sig[3];
#line 122
          b2 = b->sig[2];
#line 122
          r->sig[3] = a3 & b3;
#line 122
          r->sig[2] = a2 & b2;
          }
          switch_173_2: /* CIL Label */ 
          {
#line 122
          a1 = a->sig[1];
#line 122
          b1 = b->sig[1];
#line 122
          r->sig[1] = a1 & b1;
          }
          switch_173_1: /* CIL Label */ 
          {
#line 122
          a0 = a->sig[0];
#line 122
          b0 = b->sig[0];
#line 122
          r->sig[0] = a0 & b0;
          }
          goto switch_173_break;
          switch_173_default: /* CIL Label */ 
          {
#line 122
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_173_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 122
  return;
}
}
#line 125 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void signandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
#line 125
  if (1 == 4) {
    goto switch_174_4;
  } else {
#line 125
    if (1 == 2) {
      goto switch_174_2;
    } else {
#line 125
      if (1 == 1) {
        goto switch_174_1;
      } else {
        {
        goto switch_174_default;
#line 125
        if (0) {
          switch_174_4: /* CIL Label */ 
          {
#line 125
          a3 = a->sig[3];
#line 125
          a2 = a->sig[2];
#line 125
          b3 = b->sig[3];
#line 125
          b2 = b->sig[2];
#line 125
          r->sig[3] = a3 & ~ b3;
#line 125
          r->sig[2] = a2 & ~ b2;
          }
          switch_174_2: /* CIL Label */ 
          {
#line 125
          a1 = a->sig[1];
#line 125
          b1 = b->sig[1];
#line 125
          r->sig[1] = a1 & ~ b1;
          }
          switch_174_1: /* CIL Label */ 
          {
#line 125
          a0 = a->sig[0];
#line 125
          b0 = b->sig[0];
#line 125
          r->sig[0] = a0 & ~ b0;
          }
          goto switch_174_break;
          switch_174_default: /* CIL Label */ 
          {
#line 125
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_174_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 125
  return;
}
}
#line 149 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void signotset(sigset_t *set ) 
{ 

  {
#line 149
  if (1 == 4) {
    goto switch_175_4;
  } else {
#line 149
    if (1 == 2) {
      goto switch_175_2;
    } else {
#line 149
      if (1 == 1) {
        goto switch_175_1;
      } else {
        {
        goto switch_175_default;
#line 149
        if (0) {
          switch_175_4: /* CIL Label */ 
          {
#line 149
          set->sig[3] = ~ set->sig[3];
#line 149
          set->sig[2] = ~ set->sig[2];
          }
          switch_175_2: /* CIL Label */ 
          {
#line 149
          set->sig[1] = ~ set->sig[1];
          }
          switch_175_1: /* CIL Label */ 
          {
#line 149
          set->sig[0] = ~ set->sig[0];
          }
          goto switch_175_break;
          switch_175_default: /* CIL Label */ 
          {
#line 149
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_175_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
#line 149
  return;
}
}
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigemptyset(sigset_t *set ) 
{ 

  {
#line 160
  if (1 == 2) {
    goto switch_176_2;
  } else {
#line 161
    if (1 == 1) {
      goto switch_176_1;
    } else {
      {
      goto switch_176_default;
#line 156
      if (0) {
        switch_176_default: /* CIL Label */ 
        {
#line 158
        __constant_c_and_count_memset((void *)set, 0UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_176_break;
        switch_176_2: /* CIL Label */ 
        {
#line 160
        set->sig[1] = 0UL;
        }
        switch_176_1: /* CIL Label */ 
        {
#line 161
        set->sig[0] = 0UL;
        }
        goto switch_176_break;
      } else {
        switch_176_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 164
  return;
}
}
#line 166 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigfillset(sigset_t *set ) 
{ 

  {
#line 172
  if (1 == 2) {
    goto switch_177_2;
  } else {
#line 173
    if (1 == 1) {
      goto switch_177_1;
    } else {
      {
      goto switch_177_default;
#line 168
      if (0) {
        switch_177_default: /* CIL Label */ 
        {
#line 170
        __constant_c_and_count_memset((void *)set, 4294967295UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_177_break;
        switch_177_2: /* CIL Label */ 
        {
#line 172
        set->sig[1] = 0xffffffffUL;
        }
        switch_177_1: /* CIL Label */ 
        {
#line 173
        set->sig[0] = 0xffffffffUL;
        }
        goto switch_177_break;
      } else {
        switch_177_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 176
  return;
}
}
#line 180 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigaddsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 182
  set->sig[0] |= mask;
  }
#line 183
  return;
}
}
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void sigdelsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 187
  set->sig[0] &= ~ mask;
  }
#line 188
  return;
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int sigtestsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
#line 192
  return ((set->sig[0] & mask) != 0UL);
}
}
#line 195 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void siginitset(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 197
  set->sig[0] = mask;
  }
#line 202
  if (1 == 2) {
    goto switch_178_2;
  } else {
#line 203
    if (1 == 1) {
      goto switch_178_1;
    } else {
      {
      goto switch_178_default;
#line 198
      if (0) {
        switch_178_default: /* CIL Label */ 
        {
#line 200
        __constant_c_and_count_memset((void *)(& set->sig[1]), 0UL, 0U);
        }
        goto switch_178_break;
        switch_178_2: /* CIL Label */ 
        {
#line 202
        set->sig[1] = 0UL;
        }
        switch_178_1: /* CIL Label */ 
        {

        }
      } else {
        switch_178_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 205
  return;
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void siginitsetinv(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
#line 209
  set->sig[0] = ~ mask;
  }
#line 214
  if (1 == 2) {
    goto switch_179_2;
  } else {
#line 215
    if (1 == 1) {
      goto switch_179_1;
    } else {
      {
      goto switch_179_default;
#line 210
      if (0) {
        switch_179_default: /* CIL Label */ 
        {
#line 212
        __constant_c_and_count_memset((void *)(& set->sig[1]), 4294967295UL, 0U);
        }
        goto switch_179_break;
        switch_179_2: /* CIL Label */ 
        {
#line 214
        set->sig[1] = 0xffffffffUL;
        }
        switch_179_1: /* CIL Label */ 
        {

        }
      } else {
        switch_179_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 217
  return;
}
}
#line 221 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static void init_sigpending(struct sigpending *sig ) 
{ 

  {
  {
#line 223
  sigemptyset(& sig->signal);
#line 224
  INIT_LIST_HEAD(& sig->list);
  }
#line 225
  return;
}
}
#line 227
extern void flush_sigqueue(struct sigpending *queue ) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/signal.h"
__inline static int valid_signal(unsigned long sig ) 
{ int tmp ;

  {
#line 232
  if (sig <= 64UL) {
    {
#line 232
    tmp = 1;
    }
  } else {
    {
#line 232
    tmp = 0;
    }
  }
#line 232
  return (tmp);
}
}
#line 235
extern int next_signal(struct sigpending *pending , sigset_t *mask ) ;
#line 236
extern int group_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ) ;
#line 237
extern int __group_send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 238
extern long do_sigpending(void * , unsigned long  ) ;
#line 239
extern int sigprocmask(int  , sigset_t * , sigset_t * ) ;
#line 240
extern int show_unhandled_signals ;
#line 243
extern int get_signal_to_deliver(siginfo_t *info , struct k_sigaction *return_ka ,
                                 struct pt_regs *regs , void *cookie ) ;
#line 244
extern void exit_signals(struct task_struct *tsk ) ;
#line 246
extern struct kmem_cache *sighand_cachep ;
#line 248
extern int unhandled_signal(struct task_struct *tsk , int sig ) ;
#line 373
extern void signals_init(void) ;
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/path.h"
extern void path_get(struct path * ) ;
#line 13
extern void path_put(struct path * ) ;
#line 67 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
extern struct pid init_struct_pid ;
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
__inline static struct pid *get_pid(struct pid *pid ) 
{ 

  {
#line 77
  if (pid) {
    {
#line 78
    atomic_inc(& pid->count);
    }
  }
#line 79
  return (pid);
}
}
#line 82
extern void put_pid(struct pid *pid ) ;
#line 83
extern struct task_struct *pid_task(struct pid *pid , enum pid_type  ) ;
#line 84
extern struct task_struct *get_pid_task(struct pid *pid , enum pid_type  ) ;
#line 86
extern struct pid *get_task_pid(struct task_struct *task , enum pid_type type ) ;
#line 92
extern void attach_pid(struct task_struct *task , enum pid_type type , struct pid *pid ) ;
#line 94
extern void detach_pid(struct task_struct *task , enum pid_type  ) ;
#line 95
extern void change_pid(struct task_struct *task , enum pid_type  , struct pid *pid ) ;
#line 97
extern void transfer_pid(struct task_struct *old , struct task_struct *new , enum pid_type  ) ;
#line 101
extern struct pid_namespace init_pid_ns ;
#line 112
extern struct pid *find_pid_ns(int nr , struct pid_namespace *ns ) ;
#line 113
extern struct pid *find_vpid(int nr ) ;
#line 118
extern struct pid *find_get_pid(int nr ) ;
#line 119
extern struct pid *find_ge_pid(int nr , struct pid_namespace * ) ;
#line 120
extern int next_pidmap(struct pid_namespace *pid_ns , int last ) ;
#line 122
extern struct pid *alloc_pid(struct pid_namespace *ns ) ;
#line 123
extern void free_pid(struct pid *pid ) ;
#line 135 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
__inline static struct pid_namespace *ns_of_pid(struct pid *pid ) 
{ struct pid_namespace *ns ;

  {
  {
#line 137
  ns = (struct pid_namespace *)((void *)0);
  }
#line 138
  if (pid) {
    {
#line 139
    ns = pid->numbers[pid->level].ns;
    }
  }
#line 140
  return (ns);
}
}
#line 154 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/pid.h"
__inline static pid_t pid_nr(struct pid *pid ) 
{ pid_t nr ;

  {
  {
#line 156
  nr = 0;
  }
#line 157
  if (pid) {
    {
#line 158
    nr = pid->numbers[0].nr;
    }
  }
#line 159
  return (nr);
}
}
#line 162
extern pid_t pid_nr_ns(struct pid *pid , struct pid_namespace *ns ) ;
#line 163
extern pid_t pid_vnr(struct pid *pid ) ;
#line 27 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
extern int percpu_counter_batch ;
#line 29
extern int __percpu_counter_init(struct percpu_counter *fbc , s64 amount , struct lock_class_key *key ) ;
#line 39
extern void percpu_counter_destroy(struct percpu_counter *fbc ) ;
#line 40
extern void percpu_counter_set(struct percpu_counter *fbc , s64 amount ) ;
#line 41
extern void __percpu_counter_add(struct percpu_counter *fbc , s64 amount , s32 batch ) ;
#line 42
extern s64 __percpu_counter_sum(struct percpu_counter *fbc ) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_add(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
#line 46
  __percpu_counter_add(fbc, amount, percpu_counter_batch);
  }
#line 47
  return;
}
}
#line 49 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_sum_positive(struct percpu_counter *fbc ) 
{ s64 ret ;
  s64 tmp ;
  s64 tmp___0 ;

  {
  {
#line 51
  tmp = __percpu_counter_sum(fbc);
#line 51
  ret = tmp;
  }
#line 52
  if (ret < 0LL) {
    {
#line 52
    tmp___0 = 0LL;
    }
  } else {
    {
#line 52
    tmp___0 = ret;
    }
  }
#line 52
  return (tmp___0);
}
}
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_sum(struct percpu_counter *fbc ) 
{ s64 tmp ;

  {
  {
#line 57
  tmp = __percpu_counter_sum(fbc);
  }
#line 57
  return (tmp);
}
}
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_read(struct percpu_counter *fbc ) 
{ 

  {
#line 62
  return (fbc->count);
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static s64 percpu_counter_read_positive(struct percpu_counter *fbc ) 
{ s64 ret ;

  {
  {
#line 72
  ret = fbc->count;
#line 74
  __asm__  volatile   ("": : : "memory");
  }
#line 75
  if (ret >= 0LL) {
#line 76
    return (ret);
  }
#line 77
  return (1LL);
}
}
#line 134 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_inc(struct percpu_counter *fbc ) 
{ 

  {
  {
#line 136
  percpu_counter_add(fbc, 1LL);
  }
#line 137
  return;
}
}
#line 139 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_dec(struct percpu_counter *fbc ) 
{ 

  {
  {
#line 141
  percpu_counter_add(fbc, -1LL);
  }
#line 142
  return;
}
}
#line 144 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/percpu_counter.h"
__inline static void percpu_counter_sub(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
#line 146
  percpu_counter_add(fbc, - amount);
  }
#line 147
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
extern int prop_descriptor_init(struct prop_descriptor *pd , int shift ) ;
#line 44
extern void prop_change_shift(struct prop_descriptor *pd , int new_shift ) ;
#line 64
extern int prop_local_init_percpu(struct prop_local_percpu *pl ) ;
#line 65
extern void prop_local_destroy_percpu(struct prop_local_percpu *pl ) ;
#line 66
extern void __prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) ;
#line 67
extern void prop_fraction_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                 long *numerator , long *denominator ) ;
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
__inline static void prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
#line 75
  while (1) {
    while_180_continue: /* CIL Label */ ;
    {
#line 75
    while (1) {
      while_181_continue: /* CIL Label */ ;
      {
#line 75
      flags = __raw_local_irq_save();
      }
      goto while_181_break;
    }
    while_181_break: /* CIL Label */ ;
    }
    {
#line 75
    while (1) {
      while_182_continue: /* CIL Label */ ;
      goto while_182_break;
    }
    while_182_break: /* CIL Label */ ;
    }
    goto while_180_break;
  }
  while_180_break: /* CIL Label */ ;
  }
  {
#line 76
  __prop_inc_percpu(pd, pl);
  }
  {
#line 77
  while (1) {
    while_183_continue: /* CIL Label */ ;
    {
#line 77
    tmp = raw_irqs_disabled_flags(flags);
    }
#line 77
    if (tmp) {
      {
#line 77
      raw_local_irq_restore(flags);
      }
      {
#line 77
      while (1) {
        while_184_continue: /* CIL Label */ ;
        goto while_184_break;
      }
      while_184_break: /* CIL Label */ ;
      }
    } else {
      {
#line 77
      while (1) {
        while_185_continue: /* CIL Label */ ;
        goto while_185_break;
      }
      while_185_break: /* CIL Label */ ;
      }
      {
#line 77
      raw_local_irq_restore(flags);
      }
    }
    goto while_183_break;
  }
  while_183_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 89
extern void __prop_inc_percpu_max(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                  long frac ) ;
#line 116
extern int prop_local_init_single(struct prop_local_single *pl ) ;
#line 117
extern void prop_local_destroy_single(struct prop_local_single *pl ) ;
#line 118
extern void __prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) ;
#line 119
extern void prop_fraction_single(struct prop_descriptor *pd , struct prop_local_single *pl ,
                                 long *numerator , long *denominator ) ;
#line 122 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/proportions.h"
__inline static void prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
#line 127
  while (1) {
    while_186_continue: /* CIL Label */ ;
    {
#line 127
    while (1) {
      while_187_continue: /* CIL Label */ ;
      {
#line 127
      flags = __raw_local_irq_save();
      }
      goto while_187_break;
    }
    while_187_break: /* CIL Label */ ;
    }
    {
#line 127
    while (1) {
      while_188_continue: /* CIL Label */ ;
      goto while_188_break;
    }
    while_188_break: /* CIL Label */ ;
    }
    goto while_186_break;
  }
  while_186_break: /* CIL Label */ ;
  }
  {
#line 128
  __prop_inc_single(pd, pl);
  }
  {
#line 129
  while (1) {
    while_189_continue: /* CIL Label */ ;
    {
#line 129
    tmp = raw_irqs_disabled_flags(flags);
    }
#line 129
    if (tmp) {
      {
#line 129
      raw_local_irq_restore(flags);
      }
      {
#line 129
      while (1) {
        while_190_continue: /* CIL Label */ ;
        goto while_190_break;
      }
      while_190_break: /* CIL Label */ ;
      }
    } else {
      {
#line 129
      while (1) {
        while_191_continue: /* CIL Label */ ;
        goto while_191_break;
      }
      while_191_break: /* CIL Label */ ;
      }
      {
#line 129
      raw_local_irq_restore(flags);
      }
    }
    goto while_189_break;
  }
  while_189_break: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 12 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
extern void __secure_computing(int  ) ;
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/seccomp.h"
__inline static void secure_computing(int this_syscall ) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 15
  tmp = current_thread_info();
#line 15
  tmp___0 = test_ti_thread_flag(tmp, 8);
  }
#line 15
  if (tmp___0) {
    {
#line 15
    tmp___1 = 1;
    }
  } else {
    {
#line 15
    tmp___1 = 0;
    }
  }
  {
#line 15
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 15
  if (tmp___2) {
    {
#line 16
    __secure_computing(this_syscall);
    }
  }
#line 17
  return;
}
}
#line 19
extern long prctl_get_seccomp(void) ;
#line 20
extern long prctl_set_seccomp(unsigned long  ) ;
#line 130 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static void plist_head_init(struct plist_head *head , spinlock_t *lock ) 
{ 

  {
  {
#line 133
  INIT_LIST_HEAD(& head->prio_list);
#line 134
  INIT_LIST_HEAD(& head->node_list);
  }
#line 138
  return;
}
}
#line 145 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static void plist_node_init(struct plist_node *node , int prio ) 
{ 

  {
  {
#line 147
  node->prio = prio;
#line 148
  plist_head_init(& node->plist, (spinlock_t *)((void *)0));
  }
#line 149
  return;
}
}
#line 151
extern void plist_add(struct plist_node *node , struct plist_head *head ) ;
#line 152
extern void plist_del(struct plist_node *node , struct plist_head *head ) ;
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static int plist_head_empty(struct plist_head  const  *head ) 
{ int tmp ;

  {
  {
#line 200
  tmp = list_empty(& head->node_list);
  }
#line 200
  return (tmp);
}
}
#line 207 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static int plist_node_empty(struct plist_node  const  *node ) 
{ int tmp ;

  {
  {
#line 209
  tmp = plist_head_empty(& node->plist);
  }
#line 209
  return (tmp);
}
}
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/plist.h"
__inline static struct plist_node *plist_first(struct plist_head  const  *head ) 
{ struct list_head  const  *__mptr ;

  {
  {
#line 239
  __mptr = (struct list_head  const  *)head->node_list.next;
  }
#line 239
  return ((struct plist_node *)((char *)__mptr - (unsigned int )(& ((struct plist_node *)0)->plist.node_list)));
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rtmutex.h"
__inline static int rt_mutex_debug_check_no_locks_freed(void const   *from , unsigned long len ) 
{ 

  {
#line 49
  return (0);
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rtmutex.h"
__inline static int rt_mutex_is_locked(struct rt_mutex *lock ) 
{ 

  {
#line 82
  return ((unsigned long )lock->owner != (unsigned long )((void *)0));
}
}
#line 85
extern void __rt_mutex_init(struct rt_mutex *lock , char const   *name ) ;
#line 86
extern void rt_mutex_destroy(struct rt_mutex *lock ) ;
#line 88
extern void rt_mutex_lock(struct rt_mutex *lock ) ;
#line 89
extern int rt_mutex_lock_interruptible(struct rt_mutex *lock , int detect_deadlock ) ;
#line 91
extern int rt_mutex_timed_lock(struct rt_mutex *lock , struct hrtimer_sleeper *timeout ,
                               int detect_deadlock ) ;
#line 95
extern int rt_mutex_trylock(struct rt_mutex *lock ) ;
#line 97
extern void rt_mutex_unlock(struct rt_mutex *lock ) ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/resource.h"
extern int getrusage(struct task_struct *p , int who , struct rusage *ru ) ;
#line 178 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
#line 180
  timer->_expires = time;
#line 181
  timer->_softexpires = time;
  }
#line 182
  return;
}
}
#line 184 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_range(struct hrtimer *timer , ktime_t time ,
                                               ktime_t delta ) 
{ 

  {
  {
#line 186
  timer->_softexpires = time;
#line 187
  timer->_expires = ktime_add_safe(time, delta);
  }
#line 188
  return;
}
}
#line 190 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_range_ns(struct hrtimer *timer , ktime_t time ,
                                                  unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
#line 192
  timer->_softexpires = time;
#line 193
  tmp = ns_to_ktime((unsigned long long )delta);
#line 193
  timer->_expires = ktime_add_safe(time, tmp);
  }
#line 194
  return;
}
}
#line 196 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_set_expires_tv64(struct hrtimer *timer , s64 tv64 ) 
{ 

  {
  {
#line 198
  timer->_expires.tv64 = tv64;
#line 199
  timer->_softexpires.tv64 = tv64;
  }
#line 200
  return;
}
}
#line 202 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_add_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
#line 204
  timer->_expires = ktime_add_safe(timer->_expires, time);
#line 205
  timer->_softexpires = ktime_add_safe(timer->_softexpires, time);
  }
#line 206
  return;
}
}
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_add_expires_ns(struct hrtimer *timer , u64 ns ) 
{ ktime_t __constr_expr_0 ;
  ktime_t __constr_expr_1 ;

  {
  {
#line 210
  __constr_expr_0.tv64 = (s64 )((u64 )timer->_expires.tv64 + ns);
#line 210
  timer->_expires = __constr_expr_0;
#line 211
  __constr_expr_1.tv64 = (s64 )((u64 )timer->_softexpires.tv64 + ns);
#line 211
  timer->_softexpires = __constr_expr_1;
  }
#line 212
  return;
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_get_expires(struct hrtimer  const  *timer ) 
{ 

  {
#line 216
  return (timer->_expires);
}
}
#line 219 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_get_softexpires(struct hrtimer  const  *timer ) 
{ 

  {
#line 221
  return (timer->_softexpires);
}
}
#line 224 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_expires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
#line 226
  return ((long long )timer->_expires.tv64);
}
}
#line 228 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_softexpires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
#line 230
  return ((long long )timer->_softexpires.tv64);
}
}
#line 233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static s64 hrtimer_get_expires_ns(struct hrtimer  const  *timer ) 
{ 

  {
#line 235
  return ((long long )timer->_expires.tv64);
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_expires_remaining(struct hrtimer  const  *timer ) 
{ ktime_t __constr_expr_0 ;
  ktime_t tmp ;

  {
  {
#line 240
  tmp = (*((timer->base)->get_time))();
#line 240
  __constr_expr_0.tv64 = (s64 )(timer->_expires.tv64 - (s64 const   )tmp.tv64);
  }
#line 240
  return (__constr_expr_0);
}
}
#line 246
extern void clock_was_set(void) ;
#line 247
extern void hres_timers_resume(void) ;
#line 248
extern void hrtimer_interrupt(struct clock_event_device *dev ) ;
#line 253 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static ktime_t hrtimer_cb_get_time(struct hrtimer *timer ) 
{ ktime_t tmp ;

  {
  {
#line 255
  tmp = (*((timer->base)->get_time))();
  }
#line 255
  return (tmp);
}
}
#line 258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_is_hres_active(struct hrtimer *timer ) 
{ 

  {
#line 260
  return (((timer->base)->cpu_base)->hres_active);
}
}
#line 263
extern void hrtimer_peek_ahead_timers(void) ;
#line 306
extern ktime_t ktime_get(void) ;
#line 307
extern ktime_t ktime_get_real(void) ;
#line 310
extern struct tick_device per_cpu__tick_cpu_device  __attribute__((__section__(".data.percpu"))) ;
#line 316
extern void hrtimer_init(struct hrtimer *timer , clockid_t which_clock , enum hrtimer_mode mode ) ;
#line 325 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void hrtimer_init_on_stack(struct hrtimer *timer , clockid_t which_clock ,
                                           enum hrtimer_mode mode ) 
{ 

  {
  {
#line 329
  hrtimer_init(timer, which_clock, mode);
  }
#line 330
  return;
}
}
#line 331 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void destroy_hrtimer_on_stack(struct hrtimer *timer ) 
{ 

  {
#line 331
  return;
}
}
#line 335
extern int hrtimer_start(struct hrtimer *timer , ktime_t tim , enum hrtimer_mode mode ) ;
#line 337
extern int hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long range_ns ,
                                  enum hrtimer_mode mode ) ;
#line 339
extern int __hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long delta_ns ,
                                    enum hrtimer_mode mode , int wakeup ) ;
#line 344
extern int hrtimer_cancel(struct hrtimer *timer ) ;
#line 345
extern int hrtimer_try_to_cancel(struct hrtimer *timer ) ;
#line 347 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_start_expires(struct hrtimer *timer , enum hrtimer_mode mode ) 
{ unsigned long delta ;
  ktime_t soft ;
  ktime_t hard ;
  ktime_t __constr_expr_0 ;
  int tmp ;

  {
  {
#line 352
  soft = hrtimer_get_softexpires((struct hrtimer  const  *)timer);
#line 353
  hard = hrtimer_get_expires((struct hrtimer  const  *)timer);
#line 354
  __constr_expr_0.tv64 = hard.tv64 - soft.tv64;
#line 354
  delta = (unsigned long )__constr_expr_0.tv64;
#line 355
  tmp = hrtimer_start_range_ns(timer, soft, delta, mode);
  }
#line 355
  return (tmp);
}
}
#line 358 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_restart(struct hrtimer *timer ) 
{ int tmp ;

  {
  {
#line 360
  tmp = hrtimer_start_expires(timer, (enum hrtimer_mode )0);
  }
#line 360
  return (tmp);
}
}
#line 364
extern ktime_t hrtimer_get_remaining(struct hrtimer  const  *timer ) ;
#line 365
extern int hrtimer_get_res(clockid_t which_clock , struct timespec *tp ) ;
#line 367
extern ktime_t hrtimer_get_next_event(void) ;
#line 373 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_active(struct hrtimer  const  *timer ) 
{ 

  {
#line 375
  return (timer->state != 0UL);
}
}
#line 381 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_is_queued(struct hrtimer *timer ) 
{ 

  {
#line 383
  return ((int )(timer->state & 1UL));
}
}
#line 390 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static int hrtimer_callback_running(struct hrtimer *timer ) 
{ 

  {
#line 392
  return ((int )(timer->state & 2UL));
}
}
#line 396
extern u64 hrtimer_forward(struct hrtimer *timer , ktime_t now , ktime_t interval ) ;
#line 400 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static u64 hrtimer_forward_now(struct hrtimer *timer , ktime_t interval ) 
{ ktime_t tmp ;
  u64 tmp___0 ;

  {
  {
#line 403
  tmp = (*((timer->base)->get_time))();
#line 403
  tmp___0 = hrtimer_forward(timer, tmp, interval);
  }
#line 403
  return (tmp___0);
}
}
#line 407
extern long hrtimer_nanosleep(struct timespec *rqtp , struct timespec *rmtp , enum hrtimer_mode mode ,
                              clockid_t clockid ) ;
#line 411
extern long hrtimer_nanosleep_restart(struct restart_block *restart_block ) ;
#line 413
extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl , struct task_struct *tsk ) ;
#line 416
extern int schedule_hrtimeout_range(ktime_t *expires , unsigned long delta , enum hrtimer_mode mode ) ;
#line 418
extern int schedule_hrtimeout(ktime_t *expires , enum hrtimer_mode mode ) ;
#line 421
extern void hrtimer_run_queues(void) ;
#line 422
extern void hrtimer_run_pending(void) ;
#line 425
extern void hrtimers_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 428
extern u64 ktime_divns(ktime_t kt , s64 div ) ;
#line 434
extern void sysrq_timer_list_show(void) ;
#line 445 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void timer_stats_account_hrtimer(struct hrtimer *timer ) 
{ 

  {
  {
#line 447
  timer_stats_update_stats((void *)timer, timer->start_pid, timer->start_site, (void *)timer->function,
                           timer->start_comm, 0U);
  }
#line 449
  return;
}
}
#line 451
extern void __timer_stats_hrtimer_set_start_info(struct hrtimer *timer , void *addr ) ;
#line 454 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void timer_stats_hrtimer_set_start_info(struct hrtimer *timer ) 
{ void *tmp ;

  {
  {
#line 456
  tmp = __builtin_return_address(0U);
#line 456
  __timer_stats_hrtimer_set_start_info(timer, tmp);
  }
#line 457
  return;
}
}
#line 459 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hrtimer.h"
__inline static void timer_stats_hrtimer_clear_start_info(struct hrtimer *timer ) 
{ 

  {
  {
#line 461
  timer->start_site = (void *)0;
  }
#line 462
  return;
}
}
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/latencytop.h"
__inline static void account_scheduler_latency(struct task_struct *task , int usecs ,
                                               int inter ) 
{ 

  {
#line 44
  return;
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/latencytop.h"
__inline static void clear_all_latency_tracing(struct task_struct *p ) 
{ 

  {
#line 48
  return;
}
}
#line 957 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sysctl.h"
extern void setup_sysctl_set(struct ctl_table_set *p , struct ctl_table_set *parent ,
                             int (*is_seen)(struct ctl_table_set * ) ) ;
#line 963
extern void sysctl_head_get(struct ctl_table_header * ) ;
#line 964
extern void sysctl_head_put(struct ctl_table_header * ) ;
#line 965
extern int sysctl_is_seen(struct ctl_table_header * ) ;
#line 966
extern struct ctl_table_header *sysctl_head_grab(struct ctl_table_header * ) ;
#line 967
extern struct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev ) ;
#line 968
extern struct ctl_table_header *__sysctl_head_next(struct nsproxy *namespaces , struct ctl_table_header *prev ) ;
#line 970
extern void sysctl_head_finish(struct ctl_table_header *prev ) ;
#line 971
extern int sysctl_perm(struct ctl_table_root *root , struct ctl_table *table , int op ) ;
#line 983
extern int proc_dostring(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
#line 985
extern int proc_dointvec(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
#line 987
extern int proc_dointvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                size_t * , loff_t * ) ;
#line 989
extern int proc_dointvec_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                 size_t * , loff_t * ) ;
#line 991
extern int proc_dointvec_userhz_jiffies(struct ctl_table * , int  , struct file * ,
                                        void * , size_t * , loff_t * ) ;
#line 993
extern int proc_dointvec_ms_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                    size_t * , loff_t * ) ;
#line 995
extern int proc_doulongvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                  size_t * , loff_t * ) ;
#line 997
extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table , int  , struct file * ,
                                             void * , size_t * , loff_t * ) ;
#line 1000
extern int do_sysctl(int *name , int nlen , void *oldval , size_t *oldlenp , void *newval ,
                     size_t newlen ) ;
#line 1004
extern ctl_handler sysctl_data ;
#line 1005
extern ctl_handler sysctl_string ;
#line 1006
extern ctl_handler sysctl_intvec ;
#line 1007
extern ctl_handler sysctl_jiffies ;
#line 1008
extern ctl_handler sysctl_ms_jiffies ;
#line 1099
extern void register_sysctl_root(struct ctl_table_root *root ) ;
#line 1100
extern struct ctl_table_header *__register_sysctl_paths(struct ctl_table_root *root ,
                                                        struct nsproxy *namespaces ,
                                                        struct ctl_path  const  *path ,
                                                        struct ctl_table *table ) ;
#line 1103
extern struct ctl_table_header *register_sysctl_table(struct ctl_table *table ) ;
#line 1104
extern struct ctl_table_header *register_sysctl_paths(struct ctl_path  const  *path ,
                                                      struct ctl_table *table ) ;
#line 1107
extern void unregister_sysctl_table(struct ctl_table_header *table ) ;
#line 1108
extern int sysctl_check_table(struct nsproxy *namespaces , struct ctl_table *table ) ;
#line 100 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static key_ref_t make_key_ref(struct key  const  *key , unsigned long possession ) 
{ 

  {
#line 103
  return ((struct __key_reference_with_attributes *)((unsigned long )key | possession));
}
}
#line 106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static struct key *key_ref_to_ptr(key_ref_t key_ref ) 
{ 

  {
#line 108
  return ((struct key *)((unsigned long )key_ref & 0xfffffffeUL));
}
}
#line 111 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static unsigned long is_key_possessed(key_ref_t key_ref ) 
{ 

  {
#line 113
  return ((unsigned long )key_ref & 1UL);
}
}
#line 183
extern struct key *key_alloc(struct key_type *type , char const   *desc , uid_t uid ,
                             gid_t gid , struct cred  const  *cred , key_perm_t perm ,
                             unsigned long flags ) ;
#line 195
extern void key_revoke(struct key *key ) ;
#line 196
extern void key_put(struct key *key ) ;
#line 198 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static struct key *key_get(struct key *key ) 
{ 

  {
#line 200
  if (key) {
    {
#line 201
    atomic_inc(& key->usage);
    }
  }
#line 202
  return (key);
}
}
#line 205 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static void key_ref_put(key_ref_t key_ref ) 
{ struct key *tmp ;

  {
  {
#line 207
  tmp = key_ref_to_ptr(key_ref);
#line 207
  key_put(tmp);
  }
#line 208
  return;
}
}
#line 210
extern struct key *request_key(struct key_type *type , char const   *description ,
                               char const   *callout_info ) ;
#line 214
extern struct key *request_key_with_auxdata(struct key_type *type , char const   *description ,
                                            void const   *callout_info , size_t callout_len ,
                                            void *aux ) ;
#line 220
extern struct key *request_key_async(struct key_type *type , char const   *description ,
                                     void const   *callout_info , size_t callout_len ) ;
#line 225
extern struct key *request_key_async_with_auxdata(struct key_type *type , char const   *description ,
                                                  void const   *callout_info , size_t callout_len ,
                                                  void *aux ) ;
#line 231
extern int wait_for_key_construction(struct key *key , bool intr ) ;
#line 233
extern int key_validate(struct key *key ) ;
#line 235
extern key_ref_t key_create_or_update(key_ref_t keyring , char const   *type , char const   *description ,
                                      void const   *payload , size_t plen , key_perm_t perm ,
                                      unsigned long flags ) ;
#line 243
extern int key_update(key_ref_t key , void const   *payload , size_t plen ) ;
#line 247
extern int key_link(struct key *keyring , struct key *key ) ;
#line 250
extern int key_unlink(struct key *keyring , struct key *key ) ;
#line 253
extern struct key *keyring_alloc(char const   *description , uid_t uid , gid_t gid ,
                                 struct cred  const  *cred , unsigned long flags ,
                                 struct key *dest ) ;
#line 258
extern int keyring_clear(struct key *keyring ) ;
#line 260
extern key_ref_t keyring_search(key_ref_t keyring , struct key_type *type , char const   *description ) ;
#line 264
extern int keyring_add_key(struct key *keyring , struct key *key ) ;
#line 267
extern struct key *key_lookup(key_serial_t id ) ;
#line 269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/key.h"
__inline static key_serial_t key_serial(struct key *key ) 
{ key_serial_t tmp ;

  {
#line 271
  if (key) {
    {
#line 271
    tmp = key->serial;
    }
  } else {
    {
#line 271
    tmp = 0;
    }
  }
#line 271
  return (tmp);
}
}
#line 275
extern ctl_table key_sysctls[] ;
#line 281
extern int install_thread_keyring_to_cred(struct cred *cred ) ;
#line 282
extern void key_fsuid_changed(struct task_struct *tsk ) ;
#line 283
extern void key_fsgid_changed(struct task_struct *tsk ) ;
#line 284
extern void key_init(void) ;
#line 47 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static struct group_info *get_group_info(struct group_info *gi ) 
{ 

  {
  {
#line 49
  atomic_inc(& gi->usage);
  }
#line 50
  return (gi);
}
}
#line 63
extern struct group_info *groups_alloc(int  ) ;
#line 64
extern struct group_info init_groups ;
#line 65
extern void groups_free(struct group_info * ) ;
#line 66
extern int set_current_groups(struct group_info * ) ;
#line 67
extern int set_groups(struct cred * , struct group_info * ) ;
#line 68
extern int groups_search(struct group_info  const  * , gid_t  ) ;
#line 74
extern int in_group_p(gid_t  ) ;
#line 75
extern int in_egroup_p(gid_t  ) ;
#line 145
extern void __put_cred(struct cred * ) ;
#line 146
extern int copy_creds(struct task_struct * , unsigned long  ) ;
#line 147
extern struct cred *prepare_creds(void) ;
#line 148
extern struct cred *prepare_exec_creds(void) ;
#line 149
extern struct cred *prepare_usermodehelper_creds(void) ;
#line 150
extern int commit_creds(struct cred * ) ;
#line 151
extern void abort_creds(struct cred * ) ;
#line 152
extern struct cred  const  *override_creds(struct cred  const  * ) ;
#line 153
extern void revert_creds(struct cred  const  * ) ;
#line 154
extern struct cred *prepare_kernel_cred(struct task_struct * ) ;
#line 155
extern int change_create_files_as(struct cred * , struct inode * ) ;
#line 156
extern int set_security_override(struct cred * , u32  ) ;
#line 157
extern int set_security_override_from_ctx(struct cred * , char const   * ) ;
#line 158
extern int set_create_files_as(struct cred * , struct inode * ) ;
#line 159
extern void cred_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 168 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static struct cred *get_new_cred(struct cred *cred ) 
{ 

  {
  {
#line 170
  atomic_inc(& cred->usage);
  }
#line 171
  return (cred);
}
}
#line 187 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static struct cred  const  *get_cred(struct cred  const  *cred ) 
{ struct cred *tmp ;

  {
  {
#line 189
  tmp = get_new_cred((struct cred *)cred);
  }
#line 189
  return ((struct cred  const  *)tmp);
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"
__inline static void put_cred(struct cred  const  *_cred ) 
{ struct cred *cred ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 205
  cred = (struct cred *)_cred;
  }
  {
#line 207
  while (1) {
    while_192_continue: /* CIL Label */ ;
    {
#line 207
    tmp = __builtin_expect((long )(! (! (cred->usage.counter <= (int volatile   )0))),
                           0L);
    }
#line 207
    if (tmp) {
      {
#line 207
      while (1) {
        while_193_continue: /* CIL Label */ ;
        {
#line 207
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"),
                             "i" (207), "i" (sizeof(struct bug_entry )));
        }
        {
#line 207
        while (1) {
          while_194_continue: /* CIL Label */ ;
        }
        while_194_break: /* CIL Label */ ;
        }
        goto while_193_break;
      }
      while_193_break: /* CIL Label */ ;
      }
    }
    goto while_192_break;
  }
  while_192_break: /* CIL Label */ ;
  }
  {
#line 208
  tmp___0 = atomic_dec_and_test(& cred->usage);
  }
#line 208
  if (tmp___0) {
    {
#line 209
    __put_cred(cred);
    }
  }
#line 210
  return;
}
}
#line 118 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
extern unsigned long avenrun[] ;
#line 132
extern unsigned long total_forks ;
#line 133
extern int nr_threads ;
#line 134
extern unsigned long per_cpu__process_counts  __attribute__((__section__(".data.percpu"))) ;
#line 135
extern int nr_processes(void) ;
#line 136
extern unsigned long nr_running(void) ;
#line 137
extern unsigned long nr_uninterruptible(void) ;
#line 138
extern unsigned long nr_active(void) ;
#line 139
extern unsigned long nr_iowait(void) ;
#line 141
extern unsigned long get_parent_ip(unsigned long addr ) ;
#line 152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void proc_sched_show_task(struct task_struct *p , struct seq_file *m ) 
{ 

  {
#line 155
  return;
}
}
#line 156 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void proc_sched_set_task(struct task_struct *p ) 
{ 

  {
#line 158
  return;
}
}
#line 159 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void print_cfs_rq(struct seq_file *m , int cpu , struct cfs_rq *cfs_rq ) 
{ 

  {
#line 162
  return;
}
}
#line 165
extern unsigned long long time_sync_thresh ;
#line 243
extern rwlock_t tasklist_lock ;
#line 244
extern spinlock_t mmlist_lock ;
#line 248
extern void sched_init(void) ;
#line 249
extern void sched_init_smp(void) ;
#line 250
extern void ( __attribute__((__regparm__(0))) schedule_tail)(struct task_struct *prev ) ;
#line 251
extern void init_idle(struct task_struct *idle , int cpu ) ;
#line 252
extern void init_idle_bootup_task(struct task_struct *idle ) ;
#line 254
extern int runqueue_is_locked(void) ;
#line 255
extern void task_rq_unlock_wait(struct task_struct *p ) ;
#line 257
extern cpumask_var_t nohz_cpu_mask ;
#line 259
extern int select_nohz_load_balancer(int cpu ) ;
#line 270
extern void show_state_filter(unsigned long state_filter ) ;
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void show_state(void) 
{ 

  {
  {
#line 274
  show_state_filter(0UL);
  }
#line 275
  return;
}
}
#line 277
extern void show_regs(struct pt_regs * ) ;
#line 284
extern void show_stack(struct task_struct *task , unsigned long *sp ) ;
#line 286
extern void io_schedule(void) ;
#line 287
extern long io_schedule_timeout(long timeout ) ;
#line 290
extern void trap_init(void) ;
#line 291
extern void update_process_times(int user ) ;
#line 292
extern void scheduler_tick(void) ;
#line 294
extern void sched_show_task(struct task_struct *p ) ;
#line 306 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void softlockup_tick(void) 
{ 

  {
#line 308
  return;
}
}
#line 309 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void touch_softlockup_watchdog(void) 
{ 

  {
#line 311
  return;
}
}
#line 312 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void touch_all_softlockup_watchdogs(void) 
{ 

  {
#line 314
  return;
}
}
#line 331
extern char __sched_text_start[] ;
#line 331
extern char __sched_text_end[] ;
#line 334
extern int in_sched_functions(unsigned long addr ) ;
#line 337
extern long schedule_timeout(long timeout ) ;
#line 338
extern long schedule_timeout_interruptible(long timeout ) ;
#line 339
extern long schedule_timeout_killable(long timeout ) ;
#line 340
extern long schedule_timeout_uninterruptible(long timeout ) ;
#line 341
extern void ( __attribute__((__regparm__(0))) __schedule)(void) ;
#line 342
extern void ( __attribute__((__regparm__(0))) schedule)(void) ;
#line 343
extern int mutex_spin_on_owner(struct mutex *lock , struct thread_info *owner ) ;
#line 351
extern int sysctl_max_map_count ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/uio.h"
__inline static size_t iov_length(struct iovec  const  *iov , unsigned long nr_segs ) 
{ unsigned long seg ;
  size_t ret ;

  {
  {
#line 48
  ret = (size_t )0;
#line 50
  seg = 0UL;
  }
  {
#line 50
  while (1) {
    while_195_continue: /* CIL Label */ ;
#line 50
    if (! (seg < nr_segs)) {
      goto while_195_break;
    }
    {
#line 51
    ret += (size_t )(iov + seg)->iov_len;
#line 50
    seg ++;
    }
  }
  while_195_break: /* CIL Label */ ;
  }
#line 52
  return (ret);
}
}
#line 55
extern unsigned long iov_shorten(struct iovec *iov , unsigned long nr_segs , size_t to ) ;
#line 208 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
extern unsigned int aio_max_size ;
#line 211
extern ssize_t wait_on_sync_kiocb(struct kiocb *iocb ) ;
#line 212
extern int aio_put_req(struct kiocb *iocb ) ;
#line 213
extern void kick_iocb(struct kiocb *iocb ) ;
#line 214
extern int aio_complete(struct kiocb *iocb , long res , long res2 ) ;
#line 216
extern void exit_aio(struct mm_struct *mm ) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/aio.h"
__inline static struct kiocb *list_kiocb(struct list_head *h ) 
{ struct list_head  const  *__mptr ;

  {
  {
#line 232
  __mptr = (struct list_head  const  *)h;
  }
#line 232
  return ((struct kiocb *)((char *)__mptr - (unsigned int )(& ((struct kiocb *)0)->ki_list)));
}
}
#line 236
extern unsigned long aio_nr ;
#line 237
extern unsigned long aio_max_nr ;
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
extern unsigned long arch_get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                            unsigned long  , unsigned long  ) ;
#line 358
extern unsigned long arch_get_unmapped_area_topdown(struct file *filp , unsigned long addr ,
                                                    unsigned long len , unsigned long pgoff ,
                                                    unsigned long flags ) ;
#line 362
extern void arch_unmap_area(struct mm_struct * , unsigned long  ) ;
#line 363
extern void arch_unmap_area_topdown(struct mm_struct * , unsigned long  ) ;
#line 401 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long get_mm_hiwater_rss(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  long tmp ;
  long tmp___0 ;
  unsigned long _max2 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 403
  _max1 = mm->hiwater_rss;
#line 403
  tmp___1 = atomic_long_read(& mm->_file_rss);
#line 403
  tmp___2 = atomic_long_read(& mm->_anon_rss);
#line 403
  _max2 = (unsigned long )tmp___1 + (unsigned long )tmp___2;
  }
#line 403
  if (_max1 > _max2) {
    {
#line 403
    tmp___3 = _max1;
    }
  } else {
    {
#line 403
    tmp___3 = _max2;
    }
  }
#line 403
  return (tmp___3);
}
}
#line 406 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long get_mm_hiwater_vm(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp ;

  {
  {
#line 408
  _max1 = mm->hiwater_vm;
#line 408
  _max2 = mm->total_vm;
  }
#line 408
  if (_max1 > _max2) {
    {
#line 408
    tmp = _max1;
    }
  } else {
    {
#line 408
    tmp = _max2;
    }
  }
#line 408
  return (tmp);
}
}
#line 411
extern void set_dumpable(struct mm_struct *mm , int value ) ;
#line 412
extern int get_dumpable(struct mm_struct *mm ) ;
#line 631 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int signal_group_exit(struct signal_struct  const  *sig ) 
{ int tmp ;

  {
#line 633
  if (sig->flags & 8U) {
    {
#line 633
    tmp = 1;
    }
  } else {
#line 633
    if ((unsigned long )sig->group_exit_task != (unsigned long )((void *)0)) {
      {
#line 633
      tmp = 1;
      }
    } else {
      {
#line 633
      tmp = 0;
      }
    }
  }
#line 633
  return (tmp);
}
}
#line 677
extern int uids_sysfs_init(void) ;
#line 679
extern struct user_struct *find_user(uid_t  ) ;
#line 681
extern struct user_struct root_user ;
#line 738 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sched_info_on(void) 
{ 

  {
#line 741
  return (1);
}
}
#line 794
extern int sched_mc_power_savings ;
#line 794
extern int sched_smt_power_savings ;
#line 796 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sd_balance_for_mc_power(void) 
{ 

  {
#line 798
  if (sched_smt_power_savings) {
#line 799
    return (256);
  }
#line 801
  return (0);
}
}
#line 804 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sd_balance_for_package_power(void) 
{ 

  {
#line 806
  if (sched_mc_power_savings | sched_smt_power_savings) {
#line 807
    return (256);
  }
#line 809
  return (0);
}
}
#line 818 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sd_power_saving_flags(void) 
{ 

  {
#line 820
  if (sched_mc_power_savings | sched_smt_power_savings) {
#line 821
    return (2);
  }
#line 823
  return (0);
}
}
#line 844 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct cpumask *sched_group_cpus(struct sched_group *sg ) 
{ int tmp ;

  {
#line 846
  return ((struct cpumask *)(sg->cpumask));
}
}
#line 931 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct cpumask *sched_domain_span(struct sched_domain *sd ) 
{ int tmp ;

  {
#line 933
  return ((struct cpumask *)(sd->span));
}
}
#line 936
extern void partition_sched_domains(int ndoms_new , struct cpumask *doms_new , struct sched_domain_attr *dattr_new ) ;
#line 940 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_sd_parent(struct sched_domain *sd , int flag ) 
{ 

  {
#line 942
  if (sd->parent) {
#line 942
    if ((sd->parent)->flags & flag) {
#line 943
      return (1);
    }
  }
#line 945
  return (0);
}
}
#line 965 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void prefetch_stack(struct task_struct *t ) 
{ 

  {
#line 965
  return;
}
}
#line 1456 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int rt_prio(int prio ) 
{ long tmp ;

  {
  {
#line 1458
  tmp = __builtin_expect((long )(! (! (prio < 100))), 0L);
  }
#line 1458
  if (tmp) {
#line 1459
    return (1);
  }
#line 1460
  return (0);
}
}
#line 1463 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int rt_task(struct task_struct *p ) 
{ int tmp ;

  {
  {
#line 1465
  tmp = rt_prio(p->prio);
  }
#line 1465
  return (tmp);
}
}
#line 1468 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_pid(struct task_struct *task ) 
{ 

  {
#line 1470
  return (task->pids[0].pid);
}
}
#line 1473 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_tgid(struct task_struct *task ) 
{ 

  {
#line 1475
  return ((task->group_leader)->pids[0].pid);
}
}
#line 1483 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_pgrp(struct task_struct *task ) 
{ 

  {
#line 1485
  return ((task->group_leader)->pids[1].pid);
}
}
#line 1488 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct pid *task_session(struct task_struct *task ) 
{ 

  {
#line 1490
  return ((task->group_leader)->pids[2].pid);
}
}
#line 1508
extern pid_t __task_pid_nr_ns(struct task_struct *task , enum pid_type type , struct pid_namespace *ns ) ;
#line 1511 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_nr(struct task_struct *tsk ) 
{ 

  {
#line 1513
  return (tsk->pid);
}
}
#line 1516 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
#line 1519
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, ns);
  }
#line 1519
  return (tmp);
}
}
#line 1522 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pid_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1524
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, (struct pid_namespace *)((void *)0));
  }
#line 1524
  return (tmp);
}
}
#line 1528 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_tgid_nr(struct task_struct *tsk ) 
{ 

  {
#line 1530
  return (tsk->tgid);
}
}
#line 1533
extern pid_t task_tgid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) ;
#line 1535 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_tgid_vnr(struct task_struct *tsk ) 
{ struct pid *tmp ;
  pid_t tmp___0 ;

  {
  {
#line 1537
  tmp = task_tgid(tsk);
#line 1537
  tmp___0 = pid_vnr(tmp);
  }
#line 1537
  return (tmp___0);
}
}
#line 1541 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
#line 1544
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, ns);
  }
#line 1544
  return (tmp);
}
}
#line 1547 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1549
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, (struct pid_namespace *)((void *)0));
  }
#line 1549
  return (tmp);
}
}
#line 1553 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_session_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
#line 1556
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, ns);
  }
#line 1556
  return (tmp);
}
}
#line 1559 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_session_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1561
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, (struct pid_namespace *)((void *)0));
  }
#line 1561
  return (tmp);
}
}
#line 1565 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static pid_t task_pgrp_nr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
#line 1567
  tmp = task_pgrp_nr_ns(tsk, & init_pid_ns);
  }
#line 1567
  return (tmp);
}
}
#line 1578 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int pid_alive(struct task_struct *p ) 
{ 

  {
#line 1580
  return ((unsigned long )p->pids[0].pid != (unsigned long )((void *)0));
}
}
#line 1589 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int is_global_init(struct task_struct *tsk ) 
{ 

  {
#line 1591
  return (tsk->pid == 1);
}
}
#line 1598
extern int is_container_init(struct task_struct *tsk ) ;
#line 1600
extern struct pid *cad_pid ;
#line 1602
extern void free_task(struct task_struct *tsk ) ;
#line 1605
extern void __put_task_struct(struct task_struct *t ) ;
#line 1607 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void put_task_struct(struct task_struct *t ) 
{ int tmp ;

  {
  {
#line 1609
  tmp = atomic_dec_and_test(& t->usage);
  }
#line 1609
  if (tmp) {
    {
#line 1610
    __put_task_struct(t);
    }
  }
#line 1611
  return;
}
}
#line 1613
extern cputime_t task_utime(struct task_struct *p ) ;
#line 1614
extern cputime_t task_stime(struct task_struct *p ) ;
#line 1615
extern cputime_t task_gtime(struct task_struct *p ) ;
#line 1677
extern int set_cpus_allowed_ptr(struct task_struct *p , struct cpumask  const  *new_mask ) ;
#line 1688 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int set_cpus_allowed(struct task_struct *p , cpumask_t new_mask ) 
{ int tmp ;

  {
  {
#line 1690
  tmp = set_cpus_allowed_ptr(p, (struct cpumask  const  *)(& new_mask));
  }
#line 1690
  return (tmp);
}
}
#line 1700
extern int sched_clock_stable ;
#line 1703
extern unsigned long long sched_clock(void) ;
#line 1705
extern void sched_clock_init(void) ;
#line 1706
extern u64 sched_clock_cpu(int cpu ) ;
#line 1721
extern void sched_clock_tick(void) ;
#line 1722
extern void sched_clock_idle_sleep_event(void) ;
#line 1723
extern void sched_clock_idle_wakeup_event(u64 delta_ns ) ;
#line 1730
extern unsigned long long cpu_clock(int cpu ) ;
#line 1732
extern unsigned long long task_sched_runtime(struct task_struct *task ) ;
#line 1734
extern unsigned long long thread_group_sched_runtime(struct task_struct *task ) ;
#line 1738
extern void sched_exec(void) ;
#line 1747
extern void idle_task_exit(void) ;
#line 1752
extern void sched_idle_next(void) ;
#line 1755
extern void wake_up_idle_cpu(int cpu ) ;
#line 1760
extern unsigned int sysctl_sched_latency ;
#line 1761
extern unsigned int sysctl_sched_min_granularity ;
#line 1762
extern unsigned int sysctl_sched_wakeup_granularity ;
#line 1763
extern unsigned int sysctl_sched_shares_ratelimit ;
#line 1764
extern unsigned int sysctl_sched_shares_thresh ;
#line 1775
extern unsigned int sysctl_sched_rt_period ;
#line 1776
extern int sysctl_sched_rt_runtime ;
#line 1778
extern int sched_rt_handler(struct ctl_table *table , int write , struct file *filp ,
                            void *buffer , size_t *lenp , loff_t *ppos ) ;
#line 1782
extern unsigned int sysctl_sched_compat_yield ;
#line 1785
extern int rt_mutex_getprio(struct task_struct *p ) ;
#line 1786
extern void rt_mutex_setprio(struct task_struct *p , int prio ) ;
#line 1787
extern void rt_mutex_adjust_pi(struct task_struct *p ) ;
#line 1796
extern void set_user_nice(struct task_struct *p , long nice ) ;
#line 1797
extern int task_prio(struct task_struct  const  *p ) ;
#line 1798
extern int task_nice(struct task_struct  const  *p ) ;
#line 1799
extern int can_nice(struct task_struct  const  *p , int nice ) ;
#line 1800
extern int task_curr(struct task_struct  const  *p ) ;
#line 1801
extern int idle_cpu(int cpu ) ;
#line 1802
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param * ) ;
#line 1803
extern int sched_setscheduler_nocheck(struct task_struct * , int  , struct sched_param * ) ;
#line 1805
extern struct task_struct *idle_task(int cpu ) ;
#line 1806
extern struct task_struct *curr_task(int cpu ) ;
#line 1807
extern void set_curr_task(int cpu , struct task_struct *p ) ;
#line 1809
extern void yield(void) ;
#line 1814
extern struct exec_domain default_exec_domain ;
#line 1822 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int kstack_end(void *addr ) 
{ 

  {
#line 1827
  return (! ((((unsigned long )addr + sizeof(void *)) - 1UL) & (((1UL << 12) << 1) - sizeof(void *))));
}
}
#line 1831
extern union thread_union init_thread_union ;
#line 1832
extern struct task_struct init_task ;
#line 1834
extern struct mm_struct init_mm ;
#line 1852
extern struct task_struct *find_task_by_pid_type_ns(int type , int pid , struct pid_namespace *ns ) ;
#line 1855
extern struct task_struct *find_task_by_vpid(pid_t nr ) ;
#line 1856
extern struct task_struct *find_task_by_pid_ns(pid_t nr , struct pid_namespace *ns ) ;
#line 1859
extern void __set_special_pids(struct pid *pid ) ;
#line 1862
extern struct user_struct *alloc_uid(struct user_namespace * , uid_t  ) ;
#line 1863 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct user_struct *get_uid(struct user_struct *u ) 
{ 

  {
  {
#line 1865
  atomic_inc(& u->__count);
  }
#line 1866
  return (u);
}
}
#line 1868
extern void free_uid(struct user_struct * ) ;
#line 1869
extern void release_uids(struct user_namespace *ns ) ;
#line 1873
extern void do_timer(unsigned long ticks ) ;
#line 1875
extern int wake_up_state(struct task_struct *tsk , unsigned int state ) ;
#line 1876
extern int wake_up_process(struct task_struct *tsk ) ;
#line 1877
extern void wake_up_new_task(struct task_struct *tsk , unsigned long clone_flags ) ;
#line 1880
extern void kick_process(struct task_struct *tsk ) ;
#line 1884
extern void sched_fork(struct task_struct *p , int clone_flags ) ;
#line 1885
extern void sched_dead(struct task_struct *p ) ;
#line 1887
extern void proc_caches_init(void) ;
#line 1888
extern void flush_signals(struct task_struct * ) ;
#line 1889
extern void ignore_signals(struct task_struct * ) ;
#line 1890
extern void flush_signal_handlers(struct task_struct * , int force_default ) ;
#line 1891
extern int dequeue_signal(struct task_struct *tsk , sigset_t *mask , siginfo_t *info ) ;
#line 1893 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int dequeue_signal_lock(struct task_struct *tsk , sigset_t *mask ,
                                        siginfo_t *info ) 
{ unsigned long flags ;
  int ret ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
#line 1898
  while (1) {
    while_196_continue: /* CIL Label */ ;
    {
#line 1898
    flags = _spin_lock_irqsave(& (tsk->sighand)->siglock);
    }
    goto while_196_break;
  }
  while_196_break: /* CIL Label */ ;
  }
  {
#line 1899
  ret = dequeue_signal(tsk, mask, info);
  }
  {
#line 1900
  while (1) {
    while_197_continue: /* CIL Label */ ;
    {
#line 1900
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, flags);
    }
    goto while_197_break;
  }
  while_197_break: /* CIL Label */ ;
  }
#line 1902
  return (ret);
}
}
#line 1905
extern void block_all_signals(int (*notifier)(void *priv ) , void *priv , sigset_t *mask ) ;
#line 1907
extern void unblock_all_signals(void) ;
#line 1908
extern void release_task(struct task_struct *p ) ;
#line 1909
extern int send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 1910
extern int force_sigsegv(int  , struct task_struct * ) ;
#line 1911
extern int force_sig_info(int  , struct siginfo * , struct task_struct * ) ;
#line 1912
extern int __kill_pgrp_info(int sig , struct siginfo *info , struct pid *pgrp ) ;
#line 1913
extern int kill_pid_info(int sig , struct siginfo *info , struct pid *pid ) ;
#line 1914
extern int kill_pid_info_as_uid(int  , struct siginfo * , struct pid * , uid_t  ,
                                uid_t  , u32  ) ;
#line 1915
extern int kill_pgrp(struct pid *pid , int sig , int priv ) ;
#line 1916
extern int kill_pid(struct pid *pid , int sig , int priv ) ;
#line 1917
extern int kill_proc_info(int  , struct siginfo * , pid_t  ) ;
#line 1918
extern int do_notify_parent(struct task_struct * , int  ) ;
#line 1919
extern void force_sig(int  , struct task_struct * ) ;
#line 1920
extern void force_sig_specific(int  , struct task_struct * ) ;
#line 1921
extern int send_sig(int  , struct task_struct * , int  ) ;
#line 1922
extern void zap_other_threads(struct task_struct *p ) ;
#line 1923
extern struct sigqueue *sigqueue_alloc(void) ;
#line 1924
extern void sigqueue_free(struct sigqueue * ) ;
#line 1925
extern int send_sigqueue(struct sigqueue * , struct task_struct * , int group ) ;
#line 1926
extern int do_sigaction(int  , struct k_sigaction * , struct k_sigaction * ) ;
#line 1927
extern int do_sigaltstack(stack_t const   * , stack_t * , unsigned long  ) ;
#line 1929 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int kill_cad_pid(int sig , int priv ) 
{ int tmp ;

  {
  {
#line 1931
  tmp = kill_pid(cad_pid, sig, priv);
  }
#line 1931
  return (tmp);
}
}
#line 1939 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int is_si_special(struct siginfo  const  *info ) 
{ 

  {
#line 1941
  return ((unsigned long )info <= (unsigned long )((struct siginfo *)2));
}
}
#line 1946 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int on_sig_stack(unsigned long sp ) 
{ struct task_struct *tmp ;
  struct task_struct *tmp___0 ;

  {
  {
#line 1948
  tmp = get_current();
#line 1948
  tmp___0 = get_current();
  }
#line 1948
  return (sp - tmp->sas_ss_sp < (unsigned long )tmp___0->sas_ss_size);
}
}
#line 1951 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int sas_ss_flags(unsigned long sp ) 
{ struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;

  {
  {
#line 1953
  tmp___4 = get_current();
  }
#line 1953
  if (tmp___4->sas_ss_size == 0U) {
    {
#line 1953
    tmp___3 = 2;
    }
  } else {
    {
#line 1953
    tmp___2 = on_sig_stack(sp);
    }
#line 1953
    if (tmp___2) {
      {
#line 1953
      tmp___1 = 1;
      }
    } else {
      {
#line 1953
      tmp___1 = 0;
      }
    }
    {
#line 1953
    tmp___3 = tmp___1;
    }
  }
#line 1953
  return (tmp___3);
}
}
#line 1960
extern struct mm_struct *mm_alloc(void) ;
#line 1963
extern void __mmdrop(struct mm_struct * ) ;
#line 1964 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void mmdrop(struct mm_struct *mm ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1966
  tmp = atomic_dec_and_test(& mm->mm_count);
  }
#line 1966
  if (tmp) {
    {
#line 1966
    tmp___0 = 1;
    }
  } else {
    {
#line 1966
    tmp___0 = 0;
    }
  }
  {
#line 1966
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1966
  if (tmp___1) {
    {
#line 1967
    __mmdrop(mm);
    }
  }
#line 1968
  return;
}
}
#line 1971
extern void mmput(struct mm_struct * ) ;
#line 1973
extern struct mm_struct *get_task_mm(struct task_struct *task ) ;
#line 1975
extern void mm_release(struct task_struct * , struct mm_struct * ) ;
#line 1977
extern struct mm_struct *dup_mm(struct task_struct *tsk ) ;
#line 1979
extern int copy_thread(unsigned long  , unsigned long  , unsigned long  , struct task_struct * ,
                       struct pt_regs * ) ;
#line 1981
extern void flush_thread(void) ;
#line 1982
extern void exit_thread(void) ;
#line 1984
extern void exit_files(struct task_struct * ) ;
#line 1985
extern void __cleanup_signal(struct signal_struct * ) ;
#line 1986
extern void __cleanup_sighand(struct sighand_struct * ) ;
#line 1988
extern void exit_itimers(struct signal_struct * ) ;
#line 1989
extern void flush_itimer_signals(void) ;
#line 1991
extern void do_group_exit(int  ) ;
#line 1993
extern void daemonize(char const   *  , ...) ;
#line 1994
extern int allow_signal(int  ) ;
#line 1995
extern int disallow_signal(int  ) ;
#line 1997
extern int do_execve(char * , char ** , char ** , struct pt_regs * ) ;
#line 1998
extern long do_fork(unsigned long  , unsigned long  , struct pt_regs * , unsigned long  ,
                    int * , int * ) ;
#line 1999
extern struct task_struct *fork_idle(int  ) ;
#line 2001
extern void set_task_comm(struct task_struct *tsk , char *from ) ;
#line 2002
extern char *get_task_comm(char *to , struct task_struct *tsk ) ;
#line 2005
extern unsigned long wait_task_inactive(struct task_struct * , long match_state ) ;
#line 2019
extern bool is_single_threaded(struct task_struct * ) ;
#line 2040 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int has_group_leader_pid(struct task_struct *p ) 
{ 

  {
#line 2042
  return (p->pid == p->tgid);
}
}
#line 2045 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int same_thread_group(struct task_struct *p1 , struct task_struct *p2 ) 
{ 

  {
#line 2048
  return (p1->tgid == p2->tgid);
}
}
#line 2051 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static struct task_struct *next_thread(struct task_struct  const  *p ) 
{ struct list_head  const  *__mptr ;
  struct list_head *_________p1 ;

  {
  {
#line 2053
  _________p1 = (struct list_head *)*((struct list_head * const volatile  *)(& p->thread_group.next));
  }
  {
#line 2053
  while (1) {
    while_198_continue: /* CIL Label */ ;
    goto while_198_break;
  }
  while_198_break: /* CIL Label */ ;
  }
  {
#line 2053
  __mptr = (struct list_head  const  *)_________p1;
  }
#line 2053
  return ((struct task_struct *)((char *)__mptr - (unsigned int )(& ((struct task_struct *)0)->thread_group)));
}
}
#line 2057 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int thread_group_empty(struct task_struct *p ) 
{ int tmp ;

  {
  {
#line 2059
  tmp = list_empty((struct list_head  const  *)(& p->thread_group));
  }
#line 2059
  return (tmp);
}
}
#line 2065 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int task_detached(struct task_struct *p ) 
{ 

  {
#line 2067
  return (p->exit_signal == -1);
}
}
#line 2080 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void task_lock(struct task_struct *p ) 
{ 

  {
  {
#line 2082
  _spin_lock(& p->alloc_lock);
  }
#line 2083
  return;
}
}
#line 2085 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void task_unlock(struct task_struct *p ) 
{ 

  {
  {
#line 2087
  _spin_unlock(& p->alloc_lock);
  }
#line 2088
  return;
}
}
#line 2090
extern struct sighand_struct *lock_task_sighand(struct task_struct *tsk , unsigned long *flags ) ;
#line 2093 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void unlock_task_sighand(struct task_struct *tsk , unsigned long *flags ) 
{ unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
#line 2096
  while (1) {
    while_199_continue: /* CIL Label */ ;
    {
#line 2096
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, *flags);
    }
    goto while_199_break;
  }
  while_199_break: /* CIL Label */ ;
  }
#line 2097
  return;
}
}
#line 2104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void setup_thread_stack(struct task_struct *p , struct task_struct *org ) 
{ 

  {
  {
#line 2106
  *((struct thread_info *)p->stack) = *((struct thread_info *)org->stack);
#line 2107
  ((struct thread_info *)p->stack)->task = p;
  }
#line 2108
  return;
}
}
#line 2110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long *end_of_stack(struct task_struct *p ) 
{ 

  {
#line 2112
  return ((unsigned long *)((struct thread_info *)p->stack + 1));
}
}
#line 2117 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int object_is_on_stack(void *obj ) 
{ void *stack ;
  struct task_struct *tmp ;
  int tmp___0 ;

  {
  {
#line 2119
  tmp = get_current();
#line 2119
  stack = tmp->stack;
  }
#line 2121
  if ((unsigned long )obj >= (unsigned long )stack) {
#line 2121
    if ((unsigned long )obj < (unsigned long )(stack + ((1UL << 12) << 1))) {
      {
#line 2121
      tmp___0 = 1;
      }
    } else {
      {
#line 2121
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 2121
    tmp___0 = 0;
    }
  }
#line 2121
  return (tmp___0);
}
}
#line 2124
extern void thread_info_cache_init(void) ;
#line 2127 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned long stack_not_used(struct task_struct *p ) 
{ unsigned long *n ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;

  {
  {
#line 2129
  tmp = end_of_stack(p);
#line 2129
  n = tmp;
  }
  {
#line 2131
  while (1) {
    while_200_continue: /* CIL Label */ ;
    {
#line 2132
    n ++;
    }
#line 2131
    if (! (! *n)) {
      goto while_200_break;
    }
  }
  while_200_break: /* CIL Label */ ;
  }
  {
#line 2135
  tmp___0 = end_of_stack(p);
  }
#line 2135
  return ((unsigned long )n - (unsigned long )tmp___0);
}
}
#line 2142 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
#line 2144
  set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2145
  return;
}
}
#line 2147 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
#line 2149
  clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2150
  return;
}
}
#line 2152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_and_set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
#line 2154
  tmp = test_and_set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2154
  return (tmp);
}
}
#line 2157 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_and_clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
#line 2159
  tmp = test_and_clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2159
  return (tmp);
}
}
#line 2162 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
#line 2164
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
#line 2164
  return (tmp);
}
}
#line 2167 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void set_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
#line 2169
  set_tsk_thread_flag(tsk, 3);
  }
#line 2170
  return;
}
}
#line 2172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void clear_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
#line 2174
  clear_tsk_thread_flag(tsk, 3);
  }
#line 2175
  return;
}
}
#line 2177 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int test_tsk_need_resched(struct task_struct *tsk ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 2179
  tmp = test_tsk_thread_flag(tsk, 3);
  }
#line 2179
  if (tmp) {
    {
#line 2179
    tmp___0 = 1;
    }
  } else {
    {
#line 2179
    tmp___0 = 0;
    }
  }
  {
#line 2179
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 2179
  return ((int )tmp___1);
}
}
#line 2182 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 2184
  tmp = test_tsk_thread_flag(p, 2);
  }
#line 2184
  if (tmp) {
    {
#line 2184
    tmp___0 = 1;
    }
  } else {
    {
#line 2184
    tmp___0 = 0;
    }
  }
  {
#line 2184
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 2184
  return ((int )tmp___1);
}
}
#line 2187
extern int __fatal_signal_pending(struct task_struct *p ) ;
#line 2189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int fatal_signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2191
  tmp = signal_pending(p);
  }
#line 2191
  if (tmp) {
    {
#line 2191
    tmp___0 = __fatal_signal_pending(p);
    }
#line 2191
    if (tmp___0) {
      {
#line 2191
      tmp___1 = 1;
      }
    } else {
      {
#line 2191
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 2191
    tmp___1 = 0;
    }
  }
#line 2191
  return (tmp___1);
}
}
#line 2194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int signal_pending_state(long state , struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2196
  if (! (state & 129L)) {
#line 2197
    return (0);
  }
  {
#line 2198
  tmp = signal_pending(p);
  }
#line 2198
  if (! tmp) {
#line 2199
    return (0);
  }
#line 2201
  if (state & 1L) {
    {
#line 2201
    tmp___1 = 1;
    }
  } else {
    {
#line 2201
    tmp___0 = __fatal_signal_pending(p);
    }
#line 2201
    if (tmp___0) {
      {
#line 2201
      tmp___1 = 1;
      }
    } else {
      {
#line 2201
      tmp___1 = 0;
      }
    }
  }
#line 2201
  return (tmp___1);
}
}
#line 2204 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int need_resched(void) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2206
  tmp = current_thread_info();
#line 2206
  tmp___0 = test_ti_thread_flag(tmp, 3);
  }
#line 2206
  if (tmp___0) {
    {
#line 2206
    tmp___1 = 1;
    }
  } else {
    {
#line 2206
    tmp___1 = 0;
    }
  }
  {
#line 2206
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2206
  return ((int )tmp___2);
}
}
#line 2223 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int cond_resched(void) 
{ int tmp ;

  {
  {
#line 2225
  tmp = _cond_resched();
  }
#line 2225
  return (tmp);
}
}
#line 2228
extern int cond_resched_lock(spinlock_t *lock ) ;
#line 2229
extern int cond_resched_softirq(void) ;
#line 2230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int cond_resched_bkl(void) 
{ int tmp ;

  {
  {
#line 2232
  tmp = _cond_resched();
  }
#line 2232
  return (tmp);
}
}
#line 2240 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static int spin_needbreak(spinlock_t *lock ) 
{ 

  {
#line 2245
  return (0);
}
}
#line 2252
extern void thread_group_cputime(struct task_struct *tsk , struct task_cputime *times ) ;
#line 2253
extern void thread_group_cputimer(struct task_struct *tsk , struct task_cputime *times ) ;
#line 2258 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
static struct lock_class_key __key___1  ;
#line 2255 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void thread_group_cputime_init(struct signal_struct *sig ) 
{ struct task_cputime __constr_expr_0 ;

  {
  {
#line 2257
  __constr_expr_0.utime = 0UL;
#line 2257
  __constr_expr_0.stime = 0UL;
#line 2257
  __constr_expr_0.sum_exec_runtime = 0ULL;
#line 2257
  sig->cputimer.cputime = __constr_expr_0;
  }
  {
#line 2258
  while (1) {
    while_201_continue: /* CIL Label */ ;
    {
#line 2258
    __spin_lock_init(& sig->cputimer.lock, "&sig->cputimer.lock", & __key___1);
    }
    goto while_201_break;
  }
  while_201_break: /* CIL Label */ ;
  }
  {
#line 2259
  sig->cputimer.running = 0;
  }
#line 2260
  return;
}
}
#line 2262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void thread_group_cputime_free(struct signal_struct *sig ) 
{ 

  {
#line 2264
  return;
}
}
#line 2272
extern void recalc_sigpending_and_wake(struct task_struct *t ) ;
#line 2273
extern void recalc_sigpending(void) ;
#line 2275
extern void signal_wake_up(struct task_struct *t , int resume_stopped ) ;
#line 2282 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static unsigned int task_cpu(struct task_struct  const  *p ) 
{ 

  {
#line 2284
  return (((struct thread_info *)p->stack)->cpu);
}
}
#line 2287
extern void set_task_cpu(struct task_struct *p , unsigned int cpu ) ;
#line 2302
extern void arch_pick_mmap_layout(struct mm_struct *mm ) ;
#line 2305
extern void __trace_special(void *__tr , void *__data , unsigned long arg1 , unsigned long arg2 ,
                            unsigned long arg3 ) ;
#line 2316
extern long sched_setaffinity(pid_t pid , struct cpumask  const  *new_mask ) ;
#line 2317
extern long sched_getaffinity(pid_t pid , struct cpumask *mask ) ;
#line 2319
extern void normalize_rt_tasks(void) ;
#line 2323
extern struct task_group init_task_group ;
#line 2329
extern struct task_group *sched_create_group(struct task_group *parent ) ;
#line 2330
extern void sched_destroy_group(struct task_group *tg ) ;
#line 2331
extern void sched_move_task(struct task_struct *tsk ) ;
#line 2333
extern int sched_group_set_shares(struct task_group *tg , unsigned long shares ) ;
#line 2334
extern unsigned long sched_group_shares(struct task_group *tg ) ;
#line 2347
extern int task_can_switch_user(struct user_struct *up , struct task_struct *tsk ) ;
#line 2351 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void add_rchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
#line 2353
  tsk->ioac.rchar += (u64 )amt;
  }
#line 2354
  return;
}
}
#line 2356 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void add_wchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
#line 2358
  tsk->ioac.wchar += (u64 )amt;
  }
#line 2359
  return;
}
}
#line 2361 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void inc_syscr(struct task_struct *tsk ) 
{ 

  {
  {
#line 2363
  (tsk->ioac.syscr) ++;
  }
#line 2364
  return;
}
}
#line 2366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void inc_syscw(struct task_struct *tsk ) 
{ 

  {
  {
#line 2368
  (tsk->ioac.syscw) ++;
  }
#line 2369
  return;
}
}
#line 2396 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void mm_update_next_owner(struct mm_struct *mm ) 
{ 

  {
#line 2398
  return;
}
}
#line 2400 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/sched.h"
__inline static void mm_init_owner(struct mm_struct *mm , struct task_struct *p ) 
{ 

  {
#line 2402
  return;
}
}
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp_lock.h"
extern int __reacquire_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 10
extern void __release_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 20 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp_lock.h"
__inline static int reacquire_kernel_lock(struct task_struct *task ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
#line 22
  tmp___0 = __builtin_expect((long )(! (! (task->lock_depth >= 0))), 0L);
  }
#line 22
  if (tmp___0) {
    {
#line 23
    tmp = __reacquire_kernel_lock();
    }
#line 23
    return (tmp);
  }
#line 24
  return (0);
}
}
#line 27
extern void lock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 28
extern void unlock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/smp_lock.h"
__inline static void cycle_kernel_lock(void) 
{ 

  {
  {
#line 38
  lock_kernel();
#line 39
  unlock_kernel();
  }
#line 40
  return;
}
}
#line 9 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ftrace_irq.h"
__inline static void ftrace_nmi_enter(void) 
{ 

  {
#line 9
  return;
}
}
#line 10 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/ftrace_irq.h"
__inline static void ftrace_nmi_exit(void) 
{ 

  {
#line 10
  return;
}
}
#line 13 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq.h"
__inline static int irq_canonicalize(int irq ) 
{ int tmp ;

  {
#line 15
  if (irq == 2) {
    {
#line 15
    tmp = 9;
    }
  } else {
    {
#line 15
    tmp = irq;
    }
  }
#line 15
  return (tmp);
}
}
#line 36
extern void fixup_irqs(void) ;
#line 39
extern void (*generic_interrupt_extension)(void) ;
#line 40
extern void init_IRQ(void) ;
#line 41
extern void native_init_IRQ(void) ;
#line 42
extern bool handle_irq(unsigned int irq , struct pt_regs *regs ) ;
#line 44
extern unsigned int do_IRQ(struct pt_regs *regs ) ;
#line 48
extern int vector_used_by_percpu_irq(unsigned int vector ) ;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
extern struct pt_regs *per_cpu__irq_regs  __attribute__((__section__(".data.percpu"))) ;
#line 16 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
__inline static struct pt_regs *get_irq_regs(void) 
{ struct pt_regs *ret__ ;

  {
#line 18
  if ((int )sizeof(per_cpu__irq_regs) == 1) {
    goto switch_202_1;
  } else {
#line 18
    if ((int )sizeof(per_cpu__irq_regs) == 2) {
      goto switch_202_2;
    } else {
#line 18
      if ((int )sizeof(per_cpu__irq_regs) == 4) {
        goto switch_202_4;
      } else {
#line 18
        if ((int )sizeof(per_cpu__irq_regs) == 8) {
          goto switch_202_8;
        } else {
          {
          goto switch_202_default;
#line 18
          if (0) {
            switch_202_1: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_202_break;
            switch_202_2: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_202_break;
            switch_202_4: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_202_break;
            switch_202_8: /* CIL Label */ 
            {
#line 18
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_202_break;
            switch_202_default: /* CIL Label */ 
            {
#line 18
            __bad_percpu_size();
            }
          } else {
            switch_202_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
#line 18
  return (ret__);
}
}
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/irq_regs.h"
__inline static struct pt_regs *set_irq_regs(struct pt_regs *new_regs ) 
{ struct pt_regs *old_regs ;
  T__ tmp__ ;

  {
  {
#line 25
  old_regs = get_irq_regs();
  }
  {
#line 26
  while (1) {
    while_203_continue: /* CIL Label */ ;
#line 26
    if ((int )sizeof(per_cpu__irq_regs) == 1) {
      goto switch_204_1;
    } else {
#line 26
      if ((int )sizeof(per_cpu__irq_regs) == 2) {
        goto switch_204_2;
      } else {
#line 26
        if ((int )sizeof(per_cpu__irq_regs) == 4) {
          goto switch_204_4;
        } else {
#line 26
          if ((int )sizeof(per_cpu__irq_regs) == 8) {
            goto switch_204_8;
          } else {
            {
            goto switch_204_default;
#line 26
            if (0) {
              switch_204_1: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "b %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "qi" (new_regs));
              }
              goto switch_204_break;
              switch_204_2: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "w %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_204_break;
              switch_204_4: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "l %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_204_break;
              switch_204_8: /* CIL Label */ 
              {
#line 26
              __asm__  ("mov"
                        "q %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "re" (new_regs));
              }
              goto switch_204_break;
              switch_204_default: /* CIL Label */ 
              {
#line 26
              __bad_percpu_size();
              }
            } else {
              switch_204_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_203_break;
  }
  while_203_break: /* CIL Label */ ;
  }
#line 28
  return (old_regs);
}
}
#line 203 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
extern void arch_init_copy_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ,
                                     int cpu ) ;
#line 205
extern void arch_free_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ) ;
#line 210
extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc , int cpu ) ;
#line 213
extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq , int cpu ) ;
#line 215 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static struct irq_desc *irq_remap_to_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
#line 221
  return (desc);
}
}
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/profile.h"
extern void create_prof_cpu_mask(struct proc_dir_entry *de ) ;
#line 22
extern int create_proc_profile(void) ;
#line 41
extern int prof_on  __attribute__((__section__(".data.read_mostly"))) ;
#line 44
extern int profile_init(void) ;
#line 45
extern int profile_setup(char *str ) ;
#line 46
extern void profile_tick(int type ) ;
#line 51
extern void profile_hits(int type , void *ip , unsigned int nr_hits ) ;
#line 56 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/profile.h"
__inline static void profile_hit(int type , void *ip ) 
{ long tmp ;

  {
  {
#line 61
  tmp = __builtin_expect((long )(! (! (prof_on == type))), 0L);
  }
#line 61
  if (tmp) {
    {
#line 62
    profile_hits(type, ip, 1U);
    }
  }
#line 63
  return;
}
}
#line 69
extern void profile_task_exit(struct task_struct *task ) ;
#line 74
extern int profile_handoff_task(struct task_struct *task ) ;
#line 77
extern void profile_munmap(unsigned long addr ) ;
#line 79
extern int task_handoff_register(struct notifier_block *n ) ;
#line 80
extern int task_handoff_unregister(struct notifier_block *n ) ;
#line 82
extern int profile_event_register(enum profile_type  , struct notifier_block *n ) ;
#line 83
extern int profile_event_unregister(enum profile_type  , struct notifier_block *n ) ;
#line 85
extern int register_timer_hook(int (*hook)(struct pt_regs * ) ) ;
#line 86
extern void unregister_timer_hook(int (*hook)(struct pt_regs * ) ) ;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/sections.h"
extern char _text[] ;
#line 6
extern char _stext[] ;
#line 6
extern char _etext[] ;
#line 7
extern char _data[] ;
#line 7
extern char _sdata[] ;
#line 7
extern char _edata[] ;
#line 8
extern char __bss_start[] ;
#line 8
extern char __bss_stop[] ;
#line 9
extern char __init_begin[] ;
#line 9
extern char __init_end[] ;
#line 10
extern char _sinittext[] ;
#line 10
extern char _einittext[] ;
#line 11
extern char _end[] ;
#line 12
extern char __per_cpu_load[] ;
#line 12
extern char __per_cpu_start[] ;
#line 12
extern char __per_cpu_end[] ;
#line 13
extern char __kprobes_text_start[] ;
#line 13
extern char __kprobes_text_end[] ;
#line 14
extern char __initdata_begin[] ;
#line 14
extern char __initdata_end[] ;
#line 15
extern char __start_rodata[] ;
#line 15
extern char __end_rodata[] ;
#line 6 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/sections.h"
extern char __brk_base[] ;
#line 6
extern char __brk_limit[] ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hw_irq.h"
extern void apic_timer_interrupt(void) ;
#line 30
extern void generic_interrupt(void) ;
#line 31
extern void error_interrupt(void) ;
#line 32
extern void spurious_interrupt(void) ;
#line 33
extern void thermal_interrupt(void) ;
#line 34
extern void reschedule_interrupt(void) ;
#line 36
extern void invalidate_interrupt(void) ;
#line 37
extern void invalidate_interrupt0(void) ;
#line 38
extern void invalidate_interrupt1(void) ;
#line 39
extern void invalidate_interrupt2(void) ;
#line 40
extern void invalidate_interrupt3(void) ;
#line 41
extern void invalidate_interrupt4(void) ;
#line 42
extern void invalidate_interrupt5(void) ;
#line 43
extern void invalidate_interrupt6(void) ;
#line 44
extern void invalidate_interrupt7(void) ;
#line 46
extern void irq_move_cleanup_interrupt(void) ;
#line 47
extern void threshold_interrupt(void) ;
#line 49
extern void call_function_interrupt(void) ;
#line 50
extern void call_function_single_interrupt(void) ;
#line 53
extern void disable_8259A_irq(unsigned int irq ) ;
#line 54
extern void enable_8259A_irq(unsigned int irq ) ;
#line 55
extern int i8259A_irq_pending(unsigned int irq ) ;
#line 56
extern void make_8259A_irq(unsigned int irq ) ;
#line 57
extern void init_8259A(int aeoi ) ;
#line 61
extern unsigned long io_apic_irqs ;
#line 63
extern void init_VISWS_APIC_irqs(void) ;
#line 64
extern void setup_IO_APIC(void) ;
#line 65
extern void disable_IO_APIC(void) ;
#line 66
extern int IO_APIC_get_PCI_irq_vector(int bus , int slot , int fn ) ;
#line 67
extern void setup_ioapic_dest(void) ;
#line 69
extern void enable_IO_APIC(void) ;
#line 72
extern atomic_t irq_err_count ;
#line 73
extern atomic_t irq_mis_count ;
#line 76
extern void eisa_set_level_irq(unsigned int irq ) ;
#line 79
extern void smp_apic_timer_interrupt(struct pt_regs * ) ;
#line 80
extern void smp_spurious_interrupt(struct pt_regs * ) ;
#line 81
extern void smp_error_interrupt(struct pt_regs * ) ;
#line 83
extern void smp_reschedule_interrupt(struct pt_regs * ) ;
#line 84
extern void smp_call_function_interrupt(struct pt_regs * ) ;
#line 85
extern void smp_call_function_single_interrupt(struct pt_regs * ) ;
#line 87
extern void smp_invalidate_interrupt(struct pt_regs * ) ;
#line 93
extern void (*interrupt[224])(void)  __attribute__((__section__(".init.rodata"))) ;
#line 96
extern vector_irq_t per_cpu__vector_irq  __attribute__((__section__(".data.percpu"))) ;
#line 99
extern void lock_vector_lock(void) ;
#line 100
extern void unlock_vector_lock(void) ;
#line 101
extern void __setup_vector_irq(int cpu ) ;
#line 237 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
extern int setup_irq(unsigned int irq , struct irqaction *new ) ;
#line 238
extern void remove_irq(unsigned int irq , struct irqaction *act ) ;
#line 246
extern void move_native_irq(int irq ) ;
#line 247
extern void move_masked_irq(int irq ) ;
#line 272
extern int no_irq_affinity ;
#line 274 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static int irq_balancing_disabled(unsigned int irq ) 
{ struct irq_desc *desc ;

  {
  {
#line 278
  desc = irq_to_desc(irq);
  }
#line 279
  return ((int )(desc->status & 4194304U));
}
}
#line 283
extern irqreturn_t handle_IRQ_event(unsigned int irq , struct irqaction *action ) ;
#line 289
extern void handle_level_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 290
extern void handle_fasteoi_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 291
extern void handle_edge_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 292
extern void handle_simple_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 293
extern void handle_percpu_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 294
extern void handle_bad_irq(unsigned int irq , struct irq_desc *desc ) ;
#line 309 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void generic_handle_irq_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
  {
#line 312
  (*(desc->handle_irq))(irq, desc);
  }
#line 319
  return;
}
}
#line 321 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void generic_handle_irq(unsigned int irq ) 
{ struct irq_desc *tmp ;

  {
  {
#line 323
  tmp = irq_to_desc(irq);
#line 323
  generic_handle_irq_desc(irq, tmp);
  }
#line 324
  return;
}
}
#line 327
extern void note_interrupt(unsigned int irq , struct irq_desc *desc , irqreturn_t action_ret ) ;
#line 331
extern void check_irq_resend(struct irq_desc *desc , unsigned int irq ) ;
#line 334
extern int noirqdebug_setup(char *str ) ;
#line 337
extern int can_request_irq(unsigned int irq , unsigned long irqflags ) ;
#line 340
extern struct irq_chip no_irq_chip ;
#line 341
extern struct irq_chip dummy_irq_chip ;
#line 343
extern void set_irq_chip_and_handler(unsigned int irq , struct irq_chip *chip , void (*handle)(unsigned int irq ,
                                                                                               struct irq_desc *desc ) ) ;
#line 346
extern void set_irq_chip_and_handler_name(unsigned int irq , struct irq_chip *chip ,
                                          void (*handle)(unsigned int irq , struct irq_desc *desc ) ,
                                          char const   *name ) ;
#line 350
extern void __set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                struct irq_desc *desc ) ,
                              int is_chained , char const   *name ) ;
#line 355 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void __set_irq_handler_unlocked(int irq , void (*handler)(unsigned int irq ,
                                                                          struct irq_desc *desc ) ) 
{ struct irq_desc *desc ;

  {
  {
#line 360
  desc = irq_to_desc((unsigned int )irq);
#line 361
  desc->handle_irq = handler;
  }
#line 362
  return;
}
}
#line 367 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                       struct irq_desc *desc ) ) 
{ 

  {
  {
#line 370
  __set_irq_handler(irq, handle, 0, (char const   *)((void *)0));
  }
#line 371
  return;
}
}
#line 378 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void set_irq_chained_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                               struct irq_desc *desc ) ) 
{ 

  {
  {
#line 382
  __set_irq_handler(irq, handle, 1, (char const   *)((void *)0));
  }
#line 383
  return;
}
}
#line 385
extern void set_irq_noprobe(unsigned int irq ) ;
#line 386
extern void set_irq_probe(unsigned int irq ) ;
#line 389
extern unsigned int create_irq_nr(unsigned int irq_want ) ;
#line 390
extern int create_irq(void) ;
#line 391
extern void destroy_irq(unsigned int irq ) ;
#line 394 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static int irq_has_action(unsigned int irq ) 
{ struct irq_desc *desc ;
  struct irq_desc *tmp ;

  {
  {
#line 396
  tmp = irq_to_desc(irq);
#line 396
  desc = tmp;
  }
#line 397
  return ((unsigned long )desc->action != (unsigned long )((void *)0));
}
}
#line 401
extern void dynamic_irq_init(unsigned int irq ) ;
#line 402
extern void dynamic_irq_cleanup(unsigned int irq ) ;
#line 405
extern int set_irq_chip(unsigned int irq , struct irq_chip *chip ) ;
#line 406
extern int set_irq_data(unsigned int irq , void *data ) ;
#line 407
extern int set_irq_chip_data(unsigned int irq , void *data ) ;
#line 408
extern int set_irq_type(unsigned int irq , unsigned int type ) ;
#line 409
extern int set_irq_msi(unsigned int irq , struct msi_desc *entry ) ;
#line 436 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static bool init_alloc_desc_masks(struct irq_desc *desc , int cpu , bool boot ) 
{ int node ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 441
  if (boot) {
    {
#line 442
    alloc_bootmem_cpumask_var(& desc->affinity);
#line 443
    cpumask_setall(desc->affinity);
#line 446
    alloc_bootmem_cpumask_var(& desc->pending_mask);
#line 447
    cpumask_clear(desc->pending_mask);
    }
#line 449
    return ((_Bool)1);
  }
  {
#line 452
  node = 0;
#line 454
  tmp = alloc_cpumask_var_node(& desc->affinity, 32U, node);
  }
#line 454
  if (! tmp) {
#line 455
    return ((_Bool)0);
  }
  {
#line 456
  cpumask_setall(desc->affinity);
#line 459
  tmp___0 = alloc_cpumask_var_node(& desc->pending_mask, 32U, node);
  }
#line 459
  if (! tmp___0) {
    {
#line 460
    free_cpumask_var((struct cpumask *)(desc->affinity));
    }
#line 461
    return ((_Bool)0);
  }
  {
#line 463
  cpumask_clear(desc->pending_mask);
  }
#line 465
  return ((_Bool)1);
}
}
#line 478 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void init_copy_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
#line 488
  return;
}
}
#line 490 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/irq.h"
__inline static void free_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
  {
#line 493
  free_cpumask_var((struct cpumask *)(old_desc->affinity));
#line 496
  free_cpumask_var((struct cpumask *)(old_desc->pending_mask));
  }
#line 498
  return;
}
}
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/hardirq.h"
extern irq_cpustat_t per_cpu__irq_stat  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
#line 45
extern void ack_bad_irq(unsigned int irq ) ;
#line 47
extern u64 arch_irq_stat_cpu(unsigned int cpu ) ;
#line 50
extern u64 arch_irq_stat(void) ;
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hardirq.h"
extern void synchronize_irq(unsigned int irq ) ;
#line 128 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/hardirq.h"
__inline static void account_system_vtime(struct task_struct *tsk ) 
{ 

  {
#line 130
  return;
}
}
#line 134
extern void rcu_irq_enter(void) ;
#line 135
extern void rcu_irq_exit(void) ;
#line 136
extern void rcu_nmi_enter(void) ;
#line 137
extern void rcu_nmi_exit(void) ;
#line 161
extern void irq_enter(void) ;
#line 176
extern void irq_exit(void) ;
#line 104 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
extern irqreturn_t no_action(int cpl , void *dev_id ) ;
#line 107
extern int request_threaded_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                irqreturn_t (*thread_fn)(int  , void * ) , unsigned long flags ,
                                char const   *name , void *dev ) ;
#line 112 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ int tmp ;

  {
  {
#line 116
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                             flags, name, dev);
  }
#line 116
  return (tmp);
}
}
#line 119
extern void exit_irq_thread(void) ;
#line 143
extern void free_irq(unsigned int  , void * ) ;
#line 147
extern int devm_request_threaded_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     irqreturn_t (*thread_fn)(int  , void * ) , unsigned long irqflags ,
                                     char const   *devname , void *dev_id ) ;
#line 153 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int devm_request_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     unsigned long irqflags , char const   *devname ,
                                     void *dev_id ) 
{ int tmp ;

  {
  {
#line 157
  tmp = devm_request_threaded_irq(dev, irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                                  irqflags, devname, dev_id);
  }
#line 157
  return (tmp);
}
}
#line 161
extern void devm_free_irq(struct device *dev , unsigned int irq , void *dev_id ) ;
#line 181
extern void disable_irq_nosync(unsigned int irq ) ;
#line 182
extern void disable_irq(unsigned int irq ) ;
#line 183
extern void enable_irq(unsigned int irq ) ;
#line 186
extern void suspend_device_irqs(void) ;
#line 187
extern void resume_device_irqs(void) ;
#line 189
extern int check_wakeup_irqs(void) ;
#line 196
extern cpumask_var_t irq_default_affinity ;
#line 198
extern int irq_set_affinity(unsigned int irq , struct cpumask  const  *cpumask ) ;
#line 199
extern int irq_can_set_affinity(unsigned int irq ) ;
#line 200
extern int irq_select_affinity(unsigned int irq ) ;
#line 230 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_nosync_lockdep(unsigned int irq ) 
{ 

  {
  {
#line 232
  disable_irq_nosync(irq);
  }
#line 236
  return;
}
}
#line 238 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_nosync_lockdep_irqsave(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
#line 240
  disable_irq_nosync(irq);
  }
#line 244
  return;
}
}
#line 246 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void disable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
#line 248
  disable_irq(irq);
  }
#line 252
  return;
}
}
#line 254 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void enable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
#line 259
  enable_irq(irq);
  }
#line 260
  return;
}
}
#line 262 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void enable_irq_lockdep_irqrestore(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
#line 267
  enable_irq(irq);
  }
#line 268
  return;
}
}
#line 271
extern int set_irq_wake(unsigned int irq , unsigned int on ) ;
#line 273 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int enable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
#line 275
  tmp = set_irq_wake(irq, 1U);
  }
#line 275
  return (tmp);
}
}
#line 278 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int disable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
#line 280
  tmp = set_irq_wake(irq, 0U);
  }
#line 280
  return (tmp);
}
}
#line 349
extern char *softirq_to_name[9] ;
#line 360
extern void ( __attribute__((__regparm__(0))) do_softirq)(void) ;
#line 361
extern void ( __attribute__((__regparm__(0))) __do_softirq)(void) ;
#line 362
extern void open_softirq(int nr , void (*action)(struct softirq_action * ) ) ;
#line 363
extern void softirq_init(void) ;
#line 365
extern void raise_softirq_irqoff(unsigned int nr ) ;
#line 366
extern void raise_softirq(unsigned int nr ) ;
#line 367
extern void wakeup_softirqd(void) ;
#line 376
extern struct list_head per_cpu__softirq_work_list[9]  __attribute__((__section__(".data.percpu"))) ;
#line 381
extern void send_remote_softirq(struct call_single_data *cp , int cpu , int softirq ) ;
#line 386
extern void __send_remote_softirq(struct call_single_data *cp , int cpu , int this_cpu ,
                                  int softirq ) ;
#line 432 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static int tasklet_trylock(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 434
  tmp = test_and_set_bit(1, (unsigned long volatile   *)(& t->state));
  }
#line 434
  if (tmp) {
    {
#line 434
    tmp___0 = 0;
    }
  } else {
    {
#line 434
    tmp___0 = 1;
    }
  }
#line 434
  return (tmp___0);
}
}
#line 437 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_unlock(struct tasklet_struct *t ) 
{ 

  {
  {
#line 439
  __asm__  volatile   ("": : : "memory");
#line 440
  clear_bit(1, (unsigned long volatile   *)(& t->state));
  }
#line 441
  return;
}
}
#line 443 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_unlock_wait(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 445
  while (1) {
    while_205_continue: /* CIL Label */ ;
    {
#line 445
    tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& t->state));
    }
#line 445
    if (! tmp) {
      goto while_205_break;
    }
    {
#line 445
    __asm__  volatile   ("": : : "memory");
    }
  }
  while_205_break: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 453
extern void __tasklet_schedule(struct tasklet_struct *t ) ;
#line 455 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
#line 457
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
#line 457
  if (! tmp) {
    {
#line 458
    __tasklet_schedule(t);
    }
  }
#line 459
  return;
}
}
#line 461
extern void __tasklet_hi_schedule(struct tasklet_struct *t ) ;
#line 463 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
#line 465
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
#line 465
  if (! tmp) {
    {
#line 466
    __tasklet_hi_schedule(t);
    }
  }
#line 467
  return;
}
}
#line 470 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_disable_nosync(struct tasklet_struct *t ) 
{ 

  {
  {
#line 472
  atomic_inc(& t->count);
#line 473
  __asm__  volatile   ("": : : "memory");
  }
#line 474
  return;
}
}
#line 476 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_disable(struct tasklet_struct *t ) 
{ 

  {
  {
#line 478
  tasklet_disable_nosync(t);
#line 479
  tasklet_unlock_wait(t);
#line 480
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
#line 481
  return;
}
}
#line 483 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_enable(struct tasklet_struct *t ) 
{ 

  {
  {
#line 485
  __asm__  volatile   ("": : : "memory");
#line 486
  atomic_dec(& t->count);
  }
#line 487
  return;
}
}
#line 489 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void tasklet_hi_enable(struct tasklet_struct *t ) 
{ 

  {
  {
#line 491
  __asm__  volatile   ("": : : "memory");
#line 492
  atomic_dec(& t->count);
  }
#line 493
  return;
}
}
#line 495
extern void tasklet_kill(struct tasklet_struct *t ) ;
#line 496
extern void tasklet_kill_immediate(struct tasklet_struct *t , unsigned int cpu ) ;
#line 497
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
#line 542
extern unsigned long probe_irq_on(void) ;
#line 543
extern int probe_irq_off(unsigned long  ) ;
#line 544
extern unsigned int probe_irq_mask(unsigned long  ) ;
#line 549
extern void init_irq_proc(void) ;
#line 559 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/interrupt.h"
__inline static void debug_poll_all_shared_irqs(void) 
{ 

  {
#line 559
  return;
}
}
#line 562
extern int show_interrupts(struct seq_file *p , void *v ) ;
#line 566
extern int early_irq_init(void) ;
#line 567
extern int arch_probe_nr_irqs(void) ;
#line 568
extern int arch_early_irq_init(void) ;
#line 569
extern int arch_init_chip_data(struct irq_desc *desc , int cpu ) ;
#line 73 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 21 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int old_valid_dev(dev_t dev ) 
{ int tmp ;

  {
#line 23
  if (dev >> 20 < 256U) {
#line 23
    if ((dev & ((1U << 20) - 1U)) < 256U) {
      {
#line 23
      tmp = 1;
      }
    } else {
      {
#line 23
      tmp = 0;
      }
    }
  } else {
    {
#line 23
    tmp = 0;
    }
  }
#line 23
  return (tmp);
}
}
#line 26 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u16 old_encode_dev(dev_t dev ) 
{ 

  {
#line 28
  return ((unsigned short )(((dev >> 20) << 8) | (dev & ((1U << 20) - 1U))));
}
}
#line 31 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static dev_t old_decode_dev(u16 val ) 
{ 

  {
#line 33
  return ((unsigned int )(((((int )val >> 8) & 255) << 20) | ((int )val & 255)));
}
}
#line 36 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int new_valid_dev(dev_t dev ) 
{ 

  {
#line 38
  return (1);
}
}
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u32 new_encode_dev(dev_t dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
#line 43
  major = dev >> 20;
#line 44
  minor = dev & ((1U << 20) - 1U);
  }
#line 45
  return (((minor & 255U) | (major << 8)) | ((minor & 4294967040U) << 12));
}
}
#line 48 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static dev_t new_decode_dev(u32 dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
#line 50
  major = (dev & 1048320U) >> 8;
#line 51
  minor = (dev & 255U) | ((dev >> 12) & 1048320U);
  }
#line 52
  return ((major << 20) | minor);
}
}
#line 55 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int huge_valid_dev(dev_t dev ) 
{ 

  {
#line 57
  return (1);
}
}
#line 60 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u64 huge_encode_dev(dev_t dev ) 
{ u32 tmp ;

  {
  {
#line 62
  tmp = new_encode_dev(dev);
  }
#line 62
  return ((unsigned long long )tmp);
}
}
#line 65 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static dev_t huge_decode_dev(u64 dev ) 
{ dev_t tmp ;

  {
  {
#line 67
  tmp = new_decode_dev((unsigned int )dev);
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static int sysv_valid_dev(dev_t dev ) 
{ int tmp ;

  {
#line 72
  if (dev >> 20 < (unsigned int )(1 << 14)) {
#line 72
    if ((dev & ((1U << 20) - 1U)) < (unsigned int )(1 << 18)) {
      {
#line 72
      tmp = 1;
      }
    } else {
      {
#line 72
      tmp = 0;
      }
    }
  } else {
    {
#line 72
    tmp = 0;
    }
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static u32 sysv_encode_dev(dev_t dev ) 
{ 

  {
#line 77
  return ((dev & ((1U << 20) - 1U)) | ((dev >> 20) << 18));
}
}
#line 80 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static unsigned int sysv_major(u32 dev ) 
{ 

  {
#line 82
  return ((dev >> 18) & 16383U);
}
}
#line 85 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/kdev_t.h"
__inline static unsigned int sysv_minor(u32 dev ) 
{ 

  {
#line 87
  return (dev & 262143U);
}
}
#line 18 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void __list_add_rcu(struct list_head *new , struct list_head *prev ,
                                    struct list_head *next ) 
{ 

  {
  {
#line 21
  new->next = next;
#line 22
  new->prev = prev;
#line 23
  __asm__  volatile   ("": : : "memory");
#line 23
  prev->next = new;
#line 24
  next->prev = new;
  }
#line 25
  return;
}
}
#line 43 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 45
  __list_add_rcu(new, head, head->next);
  }
#line 46
  return;
}
}
#line 64 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_add_tail_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
#line 67
  __list_add_rcu(new, head->prev, head);
  }
#line 68
  return;
}
}
#line 94 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_del_rcu(struct list_head *entry ) 
{ 

  {
  {
#line 96
  __list_del(entry->prev, entry->next);
#line 97
  entry->prev = (struct list_head *)((void *)2097664);
  }
#line 98
  return;
}
}
#line 120 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_del_init_rcu(struct hlist_node *n ) 
{ int tmp ;

  {
  {
#line 122
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
#line 122
  if (! tmp) {
    {
#line 123
    __hlist_del(n);
#line 124
    n->pprev = (struct hlist_node **)((void *)0);
    }
  }
#line 126
  return;
}
}
#line 136 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_replace_rcu(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
#line 139
  new->next = old->next;
#line 140
  new->prev = old->prev;
#line 141
  __asm__  volatile   ("": : : "memory");
#line 141
  (new->prev)->next = new;
#line 142
  (new->next)->prev = new;
#line 143
  old->prev = (struct list_head *)((void *)2097664);
  }
#line 144
  return;
}
}
#line 163 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *at ;
  int tmp ;

  {
  {
#line 167
  first = list->next;
#line 168
  last = list->prev;
#line 169
  at = head->next;
#line 171
  tmp = list_empty((struct list_head  const  *)head);
  }
#line 171
  if (tmp) {
#line 172
    return;
  }
  {
#line 176
  INIT_LIST_HEAD(list);
#line 185
  (*sync)();
#line 195
  last->next = at;
#line 196
  __asm__  volatile   ("": : : "memory");
#line 196
  head->next = first;
#line 197
  first->prev = head;
#line 198
  at->prev = last;
  }
#line 199
  return;
}
}
#line 257 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_del_rcu(struct hlist_node *n ) 
{ 

  {
  {
#line 259
  __hlist_del(n);
#line 260
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
#line 261
  return;
}
}
#line 270 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_replace_rcu(struct hlist_node *old , struct hlist_node *new ) 
{ struct hlist_node *next ;

  {
  {
#line 273
  next = old->next;
#line 275
  new->next = next;
#line 276
  new->pprev = old->pprev;
#line 277
  __asm__  volatile   ("": : : "memory");
#line 277
  *(new->pprev) = new;
  }
#line 278
  if (next) {
    {
#line 279
    (new->next)->pprev = & new->next;
    }
  }
  {
#line 280
  old->pprev = (struct hlist_node **)((void *)2097664);
  }
#line 281
  return;
}
}
#line 302 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_add_head_rcu(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
#line 305
  first = h->first;
#line 307
  n->next = first;
#line 308
  n->pprev = & h->first;
#line 309
  __asm__  volatile   ("": : : "memory");
#line 309
  h->first = n;
  }
#line 310
  if (first) {
    {
#line 311
    first->pprev = & n->next;
    }
  }
#line 312
  return;
}
}
#line 332 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_add_before_rcu(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
#line 335
  n->pprev = next->pprev;
#line 336
  n->next = next;
#line 337
  __asm__  volatile   ("": : : "memory");
#line 337
  *(n->pprev) = n;
#line 338
  next->pprev = & n->next;
  }
#line 339
  return;
}
}
#line 359 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/rculist.h"
__inline static void hlist_add_after_rcu(struct hlist_node *prev , struct hlist_node *n ) 
{ 

  {
  {
#line 362
  n->next = prev->next;
#line 363
  n->pprev = & prev->next;
#line 364
  __asm__  volatile   ("": : : "memory");
#line 364
  prev->next = n;
  }
#line 365
  if (n->next) {
    {
#line 366
    (n->next)->pprev = & n->next;
    }
  }
#line 367
  return;
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
extern struct dentry_stat_t dentry_stat ;
#line 53 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static unsigned long partial_name_hash(unsigned long c , unsigned long prevhash ) 
{ 

  {
#line 56
  return (((prevhash + (c << 4)) + (c >> 4)) * 11UL);
}
}
#line 63 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static unsigned long end_name_hash(unsigned long hash ) 
{ 

  {
#line 65
  return ((unsigned long )((unsigned int )hash));
}
}
#line 69 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static unsigned int full_name_hash(unsigned char const   *name , unsigned int len ) 
{ unsigned long hash ;
  unsigned char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 72
  hash = 0UL;
  }
  {
#line 73
  while (1) {
    while_206_continue: /* CIL Label */ ;
    {
#line 73
    tmp___0 = len;
#line 73
    len --;
    }
#line 73
    if (! tmp___0) {
      goto while_206_break;
    }
    {
#line 74
    tmp = name;
#line 74
    name ++;
#line 74
    hash = partial_name_hash((unsigned long )*tmp, hash);
    }
  }
  while_206_break: /* CIL Label */ ;
  }
  {
#line 75
  tmp___1 = end_name_hash(hash);
  }
#line 75
  return ((unsigned int )tmp___1);
}
}
#line 187
extern spinlock_t dcache_lock ;
#line 188
extern seqlock_t rename_lock ;
#line 206 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static void __d_drop(struct dentry *dentry ) 
{ 

  {
#line 208
  if (! (dentry->d_flags & 16U)) {
    {
#line 209
    dentry->d_flags |= 16U;
#line 210
    hlist_del_rcu(& dentry->d_hash);
    }
  }
#line 212
  return;
}
}
#line 214 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static void d_drop(struct dentry *dentry ) 
{ 

  {
  {
#line 216
  _spin_lock(& dcache_lock);
#line 217
  _spin_lock(& dentry->d_lock);
#line 218
  __d_drop(dentry);
#line 219
  _spin_unlock(& dentry->d_lock);
#line 220
  _spin_unlock(& dcache_lock);
  }
#line 221
  return;
}
}
#line 223 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static int dname_external(struct dentry *dentry ) 
{ 

  {
#line 225
  return ((unsigned long )dentry->d_name.name != (unsigned long )(dentry->d_iname));
}
}
#line 231
extern void d_instantiate(struct dentry * , struct inode * ) ;
#line 232
extern struct dentry *d_instantiate_unique(struct dentry * , struct inode * ) ;
#line 233
extern struct dentry *d_materialise_unique(struct dentry * , struct inode * ) ;
#line 234
extern void d_delete(struct dentry * ) ;
#line 237
extern struct dentry *d_alloc(struct dentry * , struct qstr  const  * ) ;
#line 238
extern struct dentry *d_splice_alias(struct inode * , struct dentry * ) ;
#line 239
extern struct dentry *d_add_ci(struct dentry * , struct inode * , struct qstr * ) ;
#line 240
extern struct dentry *d_obtain_alias(struct inode * ) ;
#line 241
extern void shrink_dcache_sb(struct super_block * ) ;
#line 242
extern void shrink_dcache_parent(struct dentry * ) ;
#line 243
extern void shrink_dcache_for_umount(struct super_block * ) ;
#line 244
extern int d_invalidate(struct dentry * ) ;
#line 247
extern struct dentry *d_alloc_root(struct inode * ) ;
#line 250
extern void d_genocide(struct dentry * ) ;
#line 252
extern struct dentry *d_find_alias(struct inode * ) ;
#line 253
extern void d_prune_aliases(struct inode * ) ;
#line 256
extern int have_submounts(struct dentry * ) ;
#line 261
extern void d_rehash(struct dentry * ) ;
#line 272 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static void d_add(struct dentry *entry , struct inode *inode ) 
{ 

  {
  {
#line 274
  d_instantiate(entry, inode);
#line 275
  d_rehash(entry);
  }
#line 276
  return;
}
}
#line 286 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static struct dentry *d_add_unique(struct dentry *entry , struct inode *inode ) 
{ struct dentry *res ;
  struct dentry *tmp ;

  {
  {
#line 290
  res = d_instantiate_unique(entry, inode);
  }
#line 291
  if ((unsigned long )res != (unsigned long )((void *)0)) {
    {
#line 291
    tmp = res;
    }
  } else {
    {
#line 291
    tmp = entry;
    }
  }
  {
#line 291
  d_rehash(tmp);
  }
#line 292
  return (res);
}
}
#line 296
extern void d_move(struct dentry * , struct dentry * ) ;
#line 297
extern struct dentry *d_ancestor(struct dentry * , struct dentry * ) ;
#line 300
extern struct dentry *d_lookup(struct dentry * , struct qstr * ) ;
#line 301
extern struct dentry *__d_lookup(struct dentry * , struct qstr * ) ;
#line 302
extern struct dentry *d_hash_and_lookup(struct dentry * , struct qstr * ) ;
#line 305
extern int d_validate(struct dentry * , struct dentry * ) ;
#line 310
extern char *dynamic_dname(struct dentry * , char * , int  , char const   *  , ...) ;
#line 312
extern char *__d_path(struct path  const  *path , struct path *root , char * , int  ) ;
#line 313
extern char *d_path(struct path  const  * , char * , int  ) ;
#line 314
extern char *dentry_path(struct dentry * , char * , int  ) ;
#line 331 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static struct dentry *dget(struct dentry *dentry ) 
{ long tmp ;

  {
#line 333
  if (dentry) {
    {
#line 334
    while (1) {
      while_207_continue: /* CIL Label */ ;
      {
#line 334
      tmp = __builtin_expect((long )(! (! (! dentry->d_count.counter))), 0L);
      }
#line 334
      if (tmp) {
        {
#line 334
        while (1) {
          while_208_continue: /* CIL Label */ ;
          {
#line 334
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b, %c0\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"),
                               "i" (334), "i" (sizeof(struct bug_entry )));
          }
          {
#line 334
          while (1) {
            while_209_continue: /* CIL Label */ ;
          }
          while_209_break: /* CIL Label */ ;
          }
          goto while_208_break;
        }
        while_208_break: /* CIL Label */ ;
        }
      }
      goto while_207_break;
    }
    while_207_break: /* CIL Label */ ;
    }
    {
#line 335
    atomic_inc(& dentry->d_count);
    }
  }
#line 337
  return (dentry);
}
}
#line 340
extern struct dentry *dget_locked(struct dentry * ) ;
#line 349 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static int d_unhashed(struct dentry *dentry ) 
{ 

  {
#line 351
  return ((int )(dentry->d_flags & 16U));
}
}
#line 354 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static struct dentry *dget_parent(struct dentry *dentry ) 
{ struct dentry *ret ;

  {
  {
#line 358
  _spin_lock(& dentry->d_lock);
#line 359
  ret = dget(dentry->d_parent);
#line 360
  _spin_unlock(& dentry->d_lock);
  }
#line 361
  return (ret);
}
}
#line 364
extern void dput(struct dentry * ) ;
#line 366 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"
__inline static int d_mountpoint(struct dentry *dentry ) 
{ 

  {
#line 368
  return (dentry->d_mounted);
}
}
#line 371
extern struct vfsmount *lookup_mnt(struct vfsmount * , struct dentry * ) ;
#line 372
extern struct dentry *lookup_create(struct nameidata *nd , int is_dir ) ;
#line 374
extern int sysctl_vfs_cache_pressure ;
#line 41 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_ptr_to_indirect(void *ptr ) 
{ 

  {
#line 43
  return ((void *)((unsigned long )ptr | 1UL));
}
}
#line 46 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_indirect_to_ptr(void *ptr ) 
{ 

  {
#line 48
  return ((void *)((unsigned long )ptr & 0xfffffffeUL));
}
}
#line 51 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static int radix_tree_is_indirect_ptr(void *ptr ) 
{ 

  {
#line 53
  return ((int )((unsigned long )ptr & 1UL));
}
}
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void *radix_tree_deref_slot(void **pslot ) 
{ void *ret ;
  void *_________p1 ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 139
  _________p1 = (void *)*((void * volatile  *)pslot);
  }
  {
#line 139
  while (1) {
    while_210_continue: /* CIL Label */ ;
    goto while_210_break;
  }
  while_210_break: /* CIL Label */ ;
  }
  {
#line 139
  ret = _________p1;
#line 140
  tmp = radix_tree_is_indirect_ptr(ret);
  }
#line 140
  if (tmp) {
    {
#line 140
    tmp___0 = 1;
    }
  } else {
    {
#line 140
    tmp___0 = 0;
    }
  }
  {
#line 140
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 140
  if (tmp___1) {
    {
#line 141
    ret = (void *)0xffffffffUL;
    }
  }
#line 142
  return (ret);
}
}
#line 152 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void radix_tree_replace_slot(void **pslot , void *item ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 154
  while (1) {
    while_211_continue: /* CIL Label */ ;
    {
#line 154
    tmp = radix_tree_is_indirect_ptr(item);
    }
#line 154
    if (tmp) {
      {
#line 154
      tmp___0 = 1;
      }
    } else {
      {
#line 154
      tmp___0 = 0;
      }
    }
    {
#line 154
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 154
    if (tmp___1) {
      {
#line 154
      while (1) {
        while_212_continue: /* CIL Label */ ;
        {
#line 154
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"),
                             "i" (154), "i" (sizeof(struct bug_entry )));
        }
        {
#line 154
        while (1) {
          while_213_continue: /* CIL Label */ ;
        }
        while_213_break: /* CIL Label */ ;
        }
        goto while_212_break;
      }
      while_212_break: /* CIL Label */ ;
      }
    }
    goto while_211_break;
  }
  while_211_break: /* CIL Label */ ;
  }
  {
#line 155
  __asm__  volatile   ("": : : "memory");
#line 155
  *pslot = item;
  }
#line 156
  return;
}
}
#line 158
extern int radix_tree_insert(struct radix_tree_root * , unsigned long  , void * ) ;
#line 159
extern void *radix_tree_lookup(struct radix_tree_root * , unsigned long  ) ;
#line 160
extern void **radix_tree_lookup_slot(struct radix_tree_root * , unsigned long  ) ;
#line 161
extern void *radix_tree_delete(struct radix_tree_root * , unsigned long  ) ;
#line 162
extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root , void **results ,
                                           unsigned long first_index , unsigned int max_items ) ;
#line 165
extern unsigned int radix_tree_gang_lookup_slot(struct radix_tree_root *root , void ***results ,
                                                unsigned long first_index , unsigned int max_items ) ;
#line 168
extern unsigned long radix_tree_next_hole(struct radix_tree_root *root , unsigned long index ,
                                          unsigned long max_scan ) ;
#line 170
extern int radix_tree_preload(gfp_t gfp_mask ) ;
#line 171
extern void radix_tree_init(void) ;
#line 172
extern void *radix_tree_tag_set(struct radix_tree_root *root , unsigned long index ,
                                unsigned int tag ) ;
#line 174
extern void *radix_tree_tag_clear(struct radix_tree_root *root , unsigned long index ,
                                  unsigned int tag ) ;
#line 176
extern int radix_tree_tag_get(struct radix_tree_root *root , unsigned long index ,
                              unsigned int tag ) ;
#line 178
extern unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *root , void **results ,
                                               unsigned long first_index , unsigned int max_items ,
                                               unsigned int tag ) ;
#line 182
extern unsigned int radix_tree_gang_lookup_tag_slot(struct radix_tree_root *root ,
                                                    void ***results , unsigned long first_index ,
                                                    unsigned int max_items , unsigned int tag ) ;
#line 186
extern int radix_tree_tagged(struct radix_tree_root *root , unsigned int tag ) ;
#line 188 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"
__inline static void radix_tree_preload_end(void) 
{ 

  {
  {
#line 190
  while (1) {
    while_214_continue: /* CIL Label */ ;
    goto while_214_break;
  }
  while_214_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 392 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
extern void inode_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 393
extern void inode_init_early(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 394
extern void files_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 396
extern struct files_stat_struct files_stat ;
#line 397
extern int get_max_files(void) ;
#line 398
extern int sysctl_nr_open ;
#line 399
extern struct inodes_stat_t inodes_stat ;
#line 400
extern int leases_enable ;
#line 400
extern int lease_break_time ;
#line 402
extern int dir_notify_enable ;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
extern int qtree_write_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 41
extern int qtree_read_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 42
extern int qtree_delete_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 43
extern int qtree_release_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
#line 44
extern int qtree_entry_unused(struct qtree_mem_dqinfo *info , char *disk ) ;
#line 45 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dqblk_qtree.h"
__inline static int qtree_depth(struct qtree_mem_dqinfo *info ) 
{ unsigned int epb ;
  unsigned long long entries ;
  int i ;

  {
  {
#line 47
  epb = info->dqi_usable_bs >> 2;
#line 48
  entries = (unsigned long long )epb;
#line 51
  i = 1;
  }
  {
#line 51
  while (1) {
    while_215_continue: /* CIL Label */ ;
#line 51
    if (! (entries < 1ULL << 32)) {
      goto while_215_break;
    }
    {
#line 52
    entries *= (unsigned long long )epb;
#line 51
    i ++;
    }
  }
  while_215_break: /* CIL Label */ ;
  }
#line 53
  return (i);
}
}
#line 185 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
extern spinlock_t dq_data_lock ;
#line 233
extern void mark_info_dirty(struct super_block *sb , int type ) ;
#line 234 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
__inline static int info_dirty(struct mem_dqinfo *info ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 236
  tmp = constant_test_bit(16U, (unsigned long const volatile   *)(& info->dqi_flags));
  }
#line 236
  return (tmp);
}
}
#line 250
extern struct dqstats dqstats ;
#line 365 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
__inline static unsigned int dquot_state_flag(unsigned int flags , int type ) 
{ 

  {
#line 367
  if (type == 0) {
#line 368
    return (flags);
  }
#line 369
  return (flags << 3);
}
}
#line 372 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/quota.h"
__inline static unsigned int dquot_generic_flag(unsigned int flags , int type ) 
{ 

  {
#line 374
  if (type == 0) {
#line 375
    return (flags);
  }
#line 376
  return (flags >> 3);
}
}
#line 389
extern int register_quota_format(struct quota_format_type *fmt ) ;
#line 390
extern void unregister_quota_format(struct quota_format_type *fmt ) ;
#line 516 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
extern size_t iov_iter_copy_from_user_atomic(struct page *page , struct iov_iter *i ,
                                             unsigned long offset , size_t bytes ) ;
#line 518
extern size_t iov_iter_copy_from_user(struct page *page , struct iov_iter *i , unsigned long offset ,
                                      size_t bytes ) ;
#line 520
extern void iov_iter_advance(struct iov_iter *i , size_t bytes ) ;
#line 521
extern int iov_iter_fault_in_readable(struct iov_iter *i , size_t bytes ) ;
#line 522
extern size_t iov_iter_single_seg_count(struct iov_iter *i ) ;
#line 524 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void iov_iter_init(struct iov_iter *i , struct iovec  const  *iov ,
                                   unsigned long nr_segs , size_t count , size_t written ) 
{ 

  {
  {
#line 528
  i->iov = iov;
#line 529
  i->nr_segs = nr_segs;
#line 530
  i->iov_offset = 0U;
#line 531
  i->count = count + written;
#line 533
  iov_iter_advance(i, written);
  }
#line 534
  return;
}
}
#line 536 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static size_t iov_iter_count(struct iov_iter *i ) 
{ 

  {
#line 538
  return (i->count);
}
}
#line 604
extern int pagecache_write_begin(struct file * , struct address_space *mapping , loff_t pos ,
                                 unsigned int len , unsigned int flags , struct page **pagep ,
                                 void **fsdata ) ;
#line 608
extern int pagecache_write_end(struct file * , struct address_space *mapping , loff_t pos ,
                               unsigned int len , unsigned int copied , struct page *page ,
                               void *fsdata ) ;
#line 680
extern int mapping_tagged(struct address_space *mapping , int tag ) ;
#line 685 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int mapping_mapped(struct address_space *mapping ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 687
  tmp = prio_tree_empty((struct prio_tree_root  const  *)(& mapping->i_mmap));
  }
#line 687
  if (tmp) {
    {
#line 687
    tmp___0 = list_empty((struct list_head  const  *)(& mapping->i_mmap_nonlinear));
    }
#line 687
    if (tmp___0) {
      {
#line 687
      tmp___1 = 0;
      }
    } else {
      {
#line 687
      tmp___1 = 1;
      }
    }
  } else {
    {
#line 687
    tmp___1 = 1;
    }
  }
#line 687
  return (tmp___1);
}
}
#line 697 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int mapping_writably_mapped(struct address_space *mapping ) 
{ 

  {
#line 699
  return (mapping->i_mmap_writable != 0U);
}
}
#line 810 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static loff_t i_size_read(struct inode  const  *inode ) 
{ loff_t i_size ;
  unsigned int seq ;
  int tmp ;

  {
  {
#line 816
  while (1) {
    while_216_continue: /* CIL Label */ ;
    {
#line 817
    seq = read_seqcount_begin(& inode->i_size_seqcount);
#line 818
    i_size = (long long )inode->i_size;
#line 816
    tmp = read_seqcount_retry(& inode->i_size_seqcount, seq);
    }
#line 816
    if (! tmp) {
      goto while_216_break;
    }
  }
  while_216_break: /* CIL Label */ ;
  }
#line 820
  return (i_size);
}
}
#line 838 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void i_size_write(struct inode *inode , loff_t i_size ) 
{ 

  {
  {
#line 841
  write_seqcount_begin(& inode->i_size_seqcount);
#line 842
  inode->i_size = i_size;
#line 843
  write_seqcount_end(& inode->i_size_seqcount);
  }
#line 851
  return;
}
}
#line 853 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static unsigned int iminor(struct inode  const  *inode ) 
{ 

  {
#line 855
  return ((unsigned int )(inode->i_rdev & (unsigned int const   )((1U << 20) - 1U)));
}
}
#line 858 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static unsigned int imajor(struct inode  const  *inode ) 
{ 

  {
#line 860
  return ((unsigned int )(inode->i_rdev >> 20));
}
}
#line 863
extern struct block_device *I_BDEV(struct inode *inode ) ;
#line 890 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int ra_has_index(struct file_ra_state *ra , unsigned long index ) 
{ int tmp ;

  {
#line 892
  if (index >= ra->start) {
#line 892
    if (index < ra->start + (unsigned long )ra->size) {
      {
#line 892
      tmp = 1;
      }
    } else {
      {
#line 892
      tmp = 0;
      }
    }
  } else {
    {
#line 892
    tmp = 0;
    }
  }
#line 892
  return (tmp);
}
}
#line 937
extern spinlock_t files_lock ;
#line 977 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_take_write(struct file *filp ) 
{ 

  {
#line 977
  return;
}
}
#line 978 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_release_write(struct file *filp ) 
{ 

  {
#line 978
  return;
}
}
#line 979 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_reset_write(struct file *filp ) 
{ 

  {
#line 979
  return;
}
}
#line 980 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_check_state(struct file *filp ) 
{ 

  {
#line 980
  return;
}
}
#line 981 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int file_check_writeable(struct file *filp ) 
{ 

  {
#line 983
  return (0);
}
}
#line 1040
extern void locks_start_grace(struct lock_manager * ) ;
#line 1041
extern void locks_end_grace(struct lock_manager * ) ;
#line 1042
extern int locks_in_grace(void) ;
#line 145 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
__inline static int nfs_compare_fh(struct nfs_fh  const  *a , struct nfs_fh  const  *b ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 147
  if ((int const   )a->size != (int const   )b->size) {
    {
#line 147
    tmp___0 = 1;
    }
  } else {
    {
#line 147
    tmp = __builtin_memcmp((void const   *)(a->data), (void const   *)(b->data), (unsigned int )a->size);
    }
#line 147
    if (tmp != 0) {
      {
#line 147
      tmp___0 = 1;
      }
    } else {
      {
#line 147
      tmp___0 = 0;
      }
    }
  }
#line 147
  return (tmp___0);
}
}
#line 150 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/nfs.h"
__inline static void nfs_copy_fh(struct nfs_fh *target , struct nfs_fh  const  *source ) 
{ 

  {
  {
#line 152
  target->size = (unsigned short )source->size;
#line 153
  __memcpy((void *)(target->data), (void const   *)(source->data), (unsigned int )source->size);
  }
#line 154
  return;
}
}
#line 1085 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
extern void send_sigio(struct fown_struct *fown , int fd , int band ) ;
#line 1088
extern int do_sync_mapping_range(struct address_space *mapping , loff_t offset , loff_t endbyte ,
                                 unsigned int flags ) ;
#line 1092
extern int fcntl_getlk(struct file * , struct flock * ) ;
#line 1093
extern int fcntl_setlk(unsigned int  , struct file * , unsigned int  , struct flock * ) ;
#line 1097
extern int fcntl_getlk64(struct file * , struct flock64 * ) ;
#line 1098
extern int fcntl_setlk64(unsigned int  , struct file * , unsigned int  , struct flock64 * ) ;
#line 1102
extern int fcntl_setlease(unsigned int fd , struct file *filp , long arg ) ;
#line 1103
extern int fcntl_getlease(struct file *filp ) ;
#line 1106
extern void locks_init_lock(struct file_lock * ) ;
#line 1107
extern void locks_copy_lock(struct file_lock * , struct file_lock * ) ;
#line 1108
extern void __locks_copy_lock(struct file_lock * , struct file_lock  const  * ) ;
#line 1109
extern void locks_remove_posix(struct file * , fl_owner_t  ) ;
#line 1110
extern void locks_remove_flock(struct file * ) ;
#line 1111
extern void posix_test_lock(struct file * , struct file_lock * ) ;
#line 1112
extern int posix_lock_file(struct file * , struct file_lock * , struct file_lock * ) ;
#line 1113
extern int posix_lock_file_wait(struct file * , struct file_lock * ) ;
#line 1114
extern int posix_unblock_lock(struct file * , struct file_lock * ) ;
#line 1115
extern int vfs_test_lock(struct file * , struct file_lock * ) ;
#line 1116
extern int vfs_lock_file(struct file * , unsigned int  , struct file_lock * , struct file_lock * ) ;
#line 1117
extern int vfs_cancel_lock(struct file *filp , struct file_lock *fl ) ;
#line 1118
extern int flock_lock_file_wait(struct file *filp , struct file_lock *fl ) ;
#line 1119
extern int __break_lease(struct inode *inode , unsigned int flags ) ;
#line 1120
extern void lease_get_mtime(struct inode * , struct timespec *time ) ;
#line 1121
extern int generic_setlease(struct file * , long  , struct file_lock ** ) ;
#line 1122
extern int vfs_setlease(struct file * , long  , struct file_lock ** ) ;
#line 1123
extern int lease_modify(struct file_lock ** , int  ) ;
#line 1124
extern int lock_may_read(struct inode * , loff_t start , unsigned long count ) ;
#line 1125
extern int lock_may_write(struct inode * , loff_t start , unsigned long count ) ;
#line 1281
extern int fasync_helper(int  , struct file * , int  , struct fasync_struct ** ) ;
#line 1283
extern void kill_fasync(struct fasync_struct ** , int  , int  ) ;
#line 1285
extern void __kill_fasync(struct fasync_struct * , int  , int  ) ;
#line 1287
extern int __f_setown(struct file *filp , struct pid * , enum pid_type  , int force ) ;
#line 1288
extern int f_setown(struct file *filp , unsigned long arg , int force ) ;
#line 1289
extern void f_delown(struct file *filp ) ;
#line 1290
extern pid_t f_getown(struct file *filp ) ;
#line 1291
extern int send_sigurg(struct fown_struct *fown ) ;
#line 1301
extern struct list_head super_blocks ;
#line 1302
extern spinlock_t sb_lock ;
#line 1382
extern struct timespec current_fs_time(struct super_block *sb ) ;
#line 1404
extern void lock_super(struct super_block * ) ;
#line 1405
extern void unlock_super(struct super_block * ) ;
#line 1410
extern int vfs_create(struct inode * , struct dentry * , int  , struct nameidata * ) ;
#line 1411
extern int vfs_mkdir(struct inode * , struct dentry * , int  ) ;
#line 1412
extern int vfs_mknod(struct inode * , struct dentry * , int  , dev_t  ) ;
#line 1413
extern int vfs_symlink(struct inode * , struct dentry * , char const   * ) ;
#line 1414
extern int vfs_link(struct dentry * , struct inode * , struct dentry * ) ;
#line 1415
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
#line 1416
extern int vfs_unlink(struct inode * , struct dentry * ) ;
#line 1417
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
#line 1422
extern void dentry_unhash(struct dentry *dentry ) ;
#line 1427
extern int file_permission(struct file * , int  ) ;
#line 1439
extern int fiemap_fill_next_extent(struct fiemap_extent_info *info , u64 logical ,
                                   u64 phys , u64 len , u32 flags ) ;
#line 1441
extern int fiemap_check_flags(struct fiemap_extent_info *fieinfo , u32 fs_flags ) ;
#line 1462
extern int generic_osync_inode(struct inode * , struct address_space * , int  ) ;
#line 1544
extern ssize_t rw_copy_check_uvector(int type , struct iovec  const  *uvector , unsigned long nr_segs ,
                                     unsigned long fast_segs , struct iovec *fast_pointer ,
                                     struct iovec **ret_pointer ) ;
#line 1549
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
#line 1550
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
#line 1551
extern ssize_t vfs_readv(struct file * , struct iovec  const  * , unsigned long  ,
                         loff_t * ) ;
#line 1553
extern ssize_t vfs_writev(struct file * , struct iovec  const  * , unsigned long  ,
                          loff_t * ) ;
#line 1650
extern void __mark_inode_dirty(struct inode * , int  ) ;
#line 1651 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void mark_inode_dirty(struct inode *inode ) 
{ 

  {
  {
#line 1653
  __mark_inode_dirty(inode, 7);
  }
#line 1654
  return;
}
}
#line 1656 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void mark_inode_dirty_sync(struct inode *inode ) 
{ 

  {
  {
#line 1658
  __mark_inode_dirty(inode, 1);
  }
#line 1659
  return;
}
}
#line 1669 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inc_nlink(struct inode *inode ) 
{ 

  {
  {
#line 1671
  (inode->i_nlink) ++;
  }
#line 1672
  return;
}
}
#line 1674 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inode_inc_link_count(struct inode *inode ) 
{ 

  {
  {
#line 1676
  inc_nlink(inode);
#line 1677
  mark_inode_dirty(inode);
  }
#line 1678
  return;
}
}
#line 1691 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void drop_nlink(struct inode *inode ) 
{ 

  {
  {
#line 1693
  (inode->i_nlink) --;
  }
#line 1694
  return;
}
}
#line 1704 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void clear_nlink(struct inode *inode ) 
{ 

  {
  {
#line 1706
  inode->i_nlink = 0U;
  }
#line 1707
  return;
}
}
#line 1709 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inode_dec_link_count(struct inode *inode ) 
{ 

  {
  {
#line 1711
  drop_nlink(inode);
#line 1712
  mark_inode_dirty(inode);
  }
#line 1713
  return;
}
}
#line 1723 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void inode_inc_iversion(struct inode *inode ) 
{ 

  {
  {
#line 1725
  _spin_lock(& inode->i_lock);
#line 1726
  (inode->i_version) ++;
#line 1727
  _spin_unlock(& inode->i_lock);
  }
#line 1728
  return;
}
}
#line 1730
extern void touch_atime(struct vfsmount *mnt , struct dentry *dentry ) ;
#line 1731 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void file_accessed(struct file *file ) 
{ 

  {
#line 1733
  if (! (file->f_flags & 262144U)) {
    {
#line 1734
    touch_atime(file->f_path.mnt, file->f_path.dentry);
    }
  }
#line 1735
  return;
}
}
#line 1737
extern int sync_inode(struct inode *inode , struct writeback_control *wbc ) ;
#line 1758
extern int get_sb_ns(struct file_system_type *fs_type , int flags , void *data , int (*fill_super)(struct super_block * ,
                                                                                                   void * ,
                                                                                                   int  ) ,
                     struct vfsmount *mnt ) ;
#line 1761
extern int get_sb_bdev(struct file_system_type *fs_type , int flags , char const   *dev_name ,
                       void *data , int (*fill_super)(struct super_block * , void * ,
                                                      int  ) , struct vfsmount *mnt ) ;
#line 1765
extern int get_sb_single(struct file_system_type *fs_type , int flags , void *data ,
                         int (*fill_super)(struct super_block * , void * , int  ) ,
                         struct vfsmount *mnt ) ;
#line 1769
extern int get_sb_nodev(struct file_system_type *fs_type , int flags , void *data ,
                        int (*fill_super)(struct super_block * , void * , int  ) ,
                        struct vfsmount *mnt ) ;
#line 1773
extern void generic_shutdown_super(struct super_block *sb ) ;
#line 1774
extern void kill_block_super(struct super_block *sb ) ;
#line 1775
extern void kill_anon_super(struct super_block *sb ) ;
#line 1776
extern void kill_litter_super(struct super_block *sb ) ;
#line 1777
extern void deactivate_super(struct super_block *sb ) ;
#line 1778
extern void deactivate_locked_super(struct super_block *sb ) ;
#line 1779
extern int set_anon_super(struct super_block *s , void *data ) ;
#line 1780
extern struct super_block *sget(struct file_system_type *type , int (*test)(struct super_block * ,
                                                                            void * ) ,
                                int (*set)(struct super_block * , void * ) , void *data ) ;
#line 1784
extern int get_sb_pseudo(struct file_system_type * , char * , struct super_operations  const  *ops ,
                         unsigned long  , struct vfsmount *mnt ) ;
#line 1787
extern void simple_set_mnt(struct vfsmount *mnt , struct super_block *sb ) ;
#line 1788
extern int __put_super_and_need_restart(struct super_block *sb ) ;
#line 1796
extern int register_filesystem(struct file_system_type * ) ;
#line 1797
extern int unregister_filesystem(struct file_system_type * ) ;
#line 1798
extern struct vfsmount *kern_mount_data(struct file_system_type * , void *data ) ;
#line 1800
extern int may_umount_tree(struct vfsmount * ) ;
#line 1801
extern int may_umount(struct vfsmount * ) ;
#line 1802
extern long do_mount(char * , char * , char * , unsigned long  , void * ) ;
#line 1803
extern struct vfsmount *collect_mounts(struct vfsmount * , struct dentry * ) ;
#line 1804
extern void drop_collected_mounts(struct vfsmount * ) ;
#line 1806
extern int vfs_statfs(struct dentry * , struct kstatfs * ) ;
#line 1808
extern int current_umask(void) ;
#line 1811
extern struct kobject *fs_kobj ;
#line 1813
extern int rw_verify_area(int  , struct file * , loff_t * , size_t  ) ;
#line 1819
extern int locks_mandatory_locked(struct inode * ) ;
#line 1820
extern int locks_mandatory_area(int  , struct inode * , struct file * , loff_t  ,
                                size_t  ) ;
#line 1827 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int __mandatory_lock(struct inode *ino ) 
{ 

  {
#line 1829
  return (((int )ino->i_mode & 1032) == 1024);
}
}
#line 1837 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int mandatory_lock(struct inode *ino ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 1839
  if ((ino->i_sb)->s_flags & 64UL) {
    {
#line 1839
    tmp = __mandatory_lock(ino);
    }
#line 1839
    if (tmp) {
      {
#line 1839
      tmp___0 = 1;
      }
    } else {
      {
#line 1839
      tmp___0 = 0;
      }
    }
  } else {
    {
#line 1839
    tmp___0 = 0;
    }
  }
#line 1839
  return (tmp___0);
}
}
#line 1842 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int locks_verify_locked(struct inode *inode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 1844
  tmp___0 = mandatory_lock(inode);
  }
#line 1844
  if (tmp___0) {
    {
#line 1845
    tmp = locks_mandatory_locked(inode);
    }
#line 1845
    return (tmp);
  }
#line 1846
  return (0);
}
}
#line 1849 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int locks_verify_truncate(struct inode *inode , struct file *filp ,
                                          loff_t size ) 
{ loff_t tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1853
  if (inode->i_flock) {
    {
#line 1853
    tmp___2 = mandatory_lock(inode);
    }
#line 1853
    if (tmp___2) {
#line 1854
      if (size < inode->i_size) {
        {
#line 1854
        tmp = inode->i_size - size;
        }
      } else {
        {
#line 1854
        tmp = size - inode->i_size;
        }
      }
#line 1854
      if (size < inode->i_size) {
        {
#line 1854
        tmp___0 = size;
        }
      } else {
        {
#line 1854
        tmp___0 = inode->i_size;
        }
      }
      {
#line 1854
      tmp___1 = locks_mandatory_area(2, inode, filp, tmp___0, (unsigned int )tmp);
      }
#line 1854
      return (tmp___1);
    }
  }
#line 1860
  return (0);
}
}
#line 1863 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int break_lease(struct inode *inode , unsigned int mode ) 
{ int tmp ;

  {
#line 1865
  if (inode->i_flock) {
    {
#line 1866
    tmp = __break_lease(inode, mode);
    }
#line 1866
    return (tmp);
  }
#line 1867
  return (0);
}
}
#line 1912
extern int do_truncate(struct dentry * , loff_t start , unsigned int time_attrs ,
                       struct file *filp ) ;
#line 1914
extern long do_sys_open(int dfd , char const   *filename , int flags , int mode ) ;
#line 1916
extern struct file *filp_open(char const   * , int  , int  ) ;
#line 1917
extern struct file *dentry_open(struct dentry * , struct vfsmount * , int  , struct cred  const  * ) ;
#line 1919
extern int filp_close(struct file * , fl_owner_t id ) ;
#line 1920
extern char *getname(char const   * ) ;
#line 1923
extern void vfs_caches_init_early(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1924
extern void vfs_caches_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 1926
extern struct kmem_cache *names_cachep ;
#line 1933
extern void putname(char const   *name ) ;
#line 1937
extern int register_blkdev(unsigned int  , char const   * ) ;
#line 1938
extern void unregister_blkdev(unsigned int  , char const   * ) ;
#line 1939
extern struct block_device *bdget(dev_t  ) ;
#line 1940
extern void bd_set_size(struct block_device * , loff_t size ) ;
#line 1941
extern void bd_forget(struct inode *inode ) ;
#line 1942
extern void bdput(struct block_device * ) ;
#line 1943
extern struct block_device *open_by_devnum(dev_t  , fmode_t  ) ;
#line 1944
extern void invalidate_bdev(struct block_device * ) ;
#line 1945
extern int sync_blockdev(struct block_device *bdev ) ;
#line 1946
extern struct super_block *freeze_bdev(struct block_device * ) ;
#line 1947
extern void emergency_thaw_all(void) ;
#line 1948
extern int thaw_bdev(struct block_device *bdev , struct super_block *sb ) ;
#line 1949
extern int fsync_bdev(struct block_device * ) ;
#line 1950
extern int fsync_super(struct super_block * ) ;
#line 1951
extern int fsync_no_super(struct block_device * ) ;
#line 1967
extern struct file_operations  const  def_blk_fops ;
#line 1968
extern struct file_operations  const  def_chr_fops ;
#line 1969
extern struct file_operations  const  bad_sock_fops ;
#line 1970
extern struct file_operations  const  def_fifo_fops ;
#line 1972
extern int ioctl_by_bdev(struct block_device * , unsigned int  , unsigned long  ) ;
#line 1973
extern int blkdev_ioctl(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
#line 1974
extern long compat_blkdev_ioctl(struct file * , unsigned int  , unsigned long  ) ;
#line 1975
extern int blkdev_get(struct block_device * , fmode_t  ) ;
#line 1976
extern int blkdev_put(struct block_device * , fmode_t  ) ;
#line 1977
extern int bd_claim(struct block_device * , void * ) ;
#line 1978
extern void bd_release(struct block_device * ) ;
#line 1980
extern int bd_claim_by_disk(struct block_device * , void * , struct gendisk * ) ;
#line 1981
extern void bd_release_from_disk(struct block_device * , struct gendisk * ) ;
#line 1990
extern int alloc_chrdev_region(dev_t * , unsigned int  , unsigned int  , char const   * ) ;
#line 1991
extern int register_chrdev_region(dev_t  , unsigned int  , char const   * ) ;
#line 1992
extern int register_chrdev(unsigned int  , char const   * , struct file_operations  const  * ) ;
#line 1994
extern void unregister_chrdev(unsigned int  , char const   * ) ;
#line 1995
extern void unregister_chrdev_region(dev_t  , unsigned int  ) ;
#line 1996
extern void chrdev_show(struct seq_file * , off_t  ) ;
#line 2004
extern char const   *__bdevname(dev_t  , char *buffer ) ;
#line 2005
extern char const   *bdevname(struct block_device *bdev , char *buffer ) ;
#line 2006
extern struct block_device *lookup_bdev(char const   * ) ;
#line 2007
extern struct block_device *open_bdev_exclusive(char const   * , fmode_t  , void * ) ;
#line 2008
extern void close_bdev_exclusive(struct block_device * , fmode_t  ) ;
#line 2009
extern void blkdev_show(struct seq_file * , off_t  ) ;
#line 2015
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
#line 2018
extern void make_bad_inode(struct inode * ) ;
#line 2019
extern int is_bad_inode(struct inode * ) ;
#line 2021
extern struct file_operations  const  read_pipefifo_fops ;
#line 2022
extern struct file_operations  const  write_pipefifo_fops ;
#line 2023
extern struct file_operations  const  rdwr_pipefifo_fops ;
#line 2025
extern int fs_may_remount_ro(struct super_block * ) ;
#line 2038
extern void check_disk_size_change(struct gendisk *disk , struct block_device *bdev ) ;
#line 2040
extern int revalidate_disk(struct gendisk * ) ;
#line 2041
extern int check_disk_change(struct block_device * ) ;
#line 2042
extern int __invalidate_device(struct block_device * ) ;
#line 2043
extern int invalidate_partition(struct gendisk * , int  ) ;
#line 2045
extern int invalidate_inodes(struct super_block * ) ;
#line 2046
extern unsigned long __invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                                unsigned long end , bool be_atomic ) ;
#line 2049
extern unsigned long invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                              unsigned long end ) ;
#line 2052 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static unsigned long invalidate_inode_pages(struct address_space *mapping ) 
{ unsigned long tmp ;

  {
  {
#line 2055
  tmp = invalidate_mapping_pages(mapping, 0UL, ~ 0UL);
  }
#line 2055
  return (tmp);
}
}
#line 2058 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void invalidate_remote_inode(struct inode *inode ) 
{ 

  {
#line 2060
  if (((int )inode->i_mode & 61440) == 32768) {
    {
#line 2062
    invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
    }
  } else {
#line 2060
    if (((int )inode->i_mode & 61440) == 16384) {
      {
#line 2062
      invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
      }
    } else {
#line 2060
      if (((int )inode->i_mode & 61440) == 40960) {
        {
#line 2062
        invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
        }
      }
    }
  }
#line 2063
  return;
}
}
#line 2064
extern int invalidate_inode_pages2(struct address_space *mapping ) ;
#line 2065
extern int invalidate_inode_pages2_range(struct address_space *mapping , unsigned long start ,
                                         unsigned long end ) ;
#line 2067
extern void generic_sync_sb_inodes(struct super_block *sb , struct writeback_control *wbc ) ;
#line 2069
extern int write_inode_now(struct inode * , int  ) ;
#line 2070
extern int filemap_fdatawrite(struct address_space * ) ;
#line 2071
extern int filemap_flush(struct address_space * ) ;
#line 2072
extern int filemap_fdatawait(struct address_space * ) ;
#line 2073
extern int filemap_write_and_wait(struct address_space *mapping ) ;
#line 2074
extern int filemap_write_and_wait_range(struct address_space *mapping , loff_t lstart ,
                                        loff_t lend ) ;
#line 2076
extern int wait_on_page_writeback_range(struct address_space *mapping , unsigned long start ,
                                        unsigned long end ) ;
#line 2078
extern int __filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                      loff_t end , int sync_mode ) ;
#line 2080
extern int filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                    loff_t end ) ;
#line 2083
extern int vfs_fsync(struct file *file , struct dentry *dentry , int datasync ) ;
#line 2084
extern void sync_supers(void) ;
#line 2085
extern void sync_filesystems(int wait ) ;
#line 2086
extern void __fsync_super(struct super_block *sb ) ;
#line 2087
extern void emergency_sync(void) ;
#line 2088
extern void emergency_remount(void) ;
#line 2089
extern int do_remount_sb(struct super_block *sb , int flags , void *data , int force ) ;
#line 2092
extern sector_t bmap(struct inode * , sector_t  ) ;
#line 2094
extern int notify_change(struct dentry * , struct iattr * ) ;
#line 2095
extern int inode_permission(struct inode * , int  ) ;
#line 2096
extern int generic_permission(struct inode * , int  , int (*check_acl)(struct inode * ,
                                                                       int  ) ) ;
#line 2099 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static bool execute_ok(struct inode *inode ) 
{ int tmp ;

  {
#line 2101
  if ((int )inode->i_mode & 73) {
    {
#line 2101
    tmp = 1;
    }
  } else {
#line 2101
    if (((int )inode->i_mode & 61440) == 16384) {
      {
#line 2101
      tmp = 1;
      }
    } else {
      {
#line 2101
      tmp = 0;
      }
    }
  }
#line 2101
  return ((_Bool )tmp);
}
}
#line 2104
extern int get_write_access(struct inode * ) ;
#line 2105
extern int deny_write_access(struct file * ) ;
#line 2106 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void put_write_access(struct inode *inode ) 
{ 

  {
  {
#line 2108
  atomic_dec(& inode->i_writecount);
  }
#line 2109
  return;
}
}
#line 2110 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void allow_write_access(struct file *file ) 
{ 

  {
#line 2112
  if (file) {
    {
#line 2113
    atomic_inc(& ((file->f_path.dentry)->d_inode)->i_writecount);
    }
  }
#line 2114
  return;
}
}
#line 2115
extern int do_pipe_flags(int * , int  ) ;
#line 2116
extern struct file *create_read_pipe(struct file *f , int flags ) ;
#line 2117
extern struct file *create_write_pipe(int flags ) ;
#line 2118
extern void free_write_pipe(struct file * ) ;
#line 2120
extern struct file *do_filp_open(int dfd , char const   *pathname , int open_flag ,
                                 int mode , int acc_mode ) ;
#line 2122
extern int may_open(struct path * , int  , int  ) ;
#line 2124
extern int kernel_read(struct file * , loff_t  , char * , unsigned long  ) ;
#line 2125
extern struct file *open_exec(char const   * ) ;
#line 2128
extern int is_subdir(struct dentry * , struct dentry * ) ;
#line 2129
extern ino_t find_inode_number(struct dentry * , struct qstr * ) ;
#line 2134
extern loff_t default_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2136
extern loff_t vfs_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2138
extern int inode_init_always(struct super_block * , struct inode * ) ;
#line 2139
extern void inode_init_once(struct inode * ) ;
#line 2140
extern void inode_add_to_lists(struct super_block * , struct inode * ) ;
#line 2141
extern void iput(struct inode * ) ;
#line 2142
extern struct inode *igrab(struct inode * ) ;
#line 2143
extern ino_t iunique(struct super_block * , ino_t  ) ;
#line 2144
extern int inode_needs_sync(struct inode *inode ) ;
#line 2145
extern void generic_delete_inode(struct inode *inode ) ;
#line 2146
extern void generic_drop_inode(struct inode *inode ) ;
#line 2148
extern struct inode *ilookup5_nowait(struct super_block *sb , unsigned long hashval ,
                                     int (*test)(struct inode * , void * ) , void *data ) ;
#line 2151
extern struct inode *ilookup5(struct super_block *sb , unsigned long hashval , int (*test)(struct inode * ,
                                                                                           void * ) ,
                              void *data ) ;
#line 2153
extern struct inode *ilookup(struct super_block *sb , unsigned long ino ) ;
#line 2155
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*test)(struct inode * ,
                                                                                      void * ) ,
                                  int (*set)(struct inode * , void * ) , void * ) ;
#line 2156
extern struct inode *iget_locked(struct super_block * , unsigned long  ) ;
#line 2157
extern int insert_inode_locked4(struct inode * , unsigned long  , int (*test)(struct inode * ,
                                                                              void * ) ,
                                void * ) ;
#line 2158
extern int insert_inode_locked(struct inode * ) ;
#line 2159
extern void unlock_new_inode(struct inode * ) ;
#line 2161
extern void __iget(struct inode *inode ) ;
#line 2162
extern void iget_failed(struct inode * ) ;
#line 2163
extern void clear_inode(struct inode * ) ;
#line 2164
extern void destroy_inode(struct inode * ) ;
#line 2165
extern void __destroy_inode(struct inode * ) ;
#line 2166
extern struct inode *new_inode(struct super_block * ) ;
#line 2167
extern int should_remove_suid(struct dentry * ) ;
#line 2168
extern int file_remove_suid(struct file * ) ;
#line 2170
extern void __insert_inode_hash(struct inode * , unsigned long hashval ) ;
#line 2171
extern void remove_inode_hash(struct inode * ) ;
#line 2172 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void insert_inode_hash(struct inode *inode ) 
{ 

  {
  {
#line 2173
  __insert_inode_hash(inode, inode->i_ino);
  }
#line 2174
  return;
}
}
#line 2176
extern struct file *get_empty_filp(void) ;
#line 2177
extern void file_move(struct file *f , struct list_head *list ) ;
#line 2178
extern void file_kill(struct file *f ) ;
#line 2181
extern void submit_bio(int  , struct bio * ) ;
#line 2182
extern int bdev_read_only(struct block_device * ) ;
#line 2184
extern int set_blocksize(struct block_device * , int  ) ;
#line 2185
extern int sb_set_blocksize(struct super_block * , int  ) ;
#line 2186
extern int sb_min_blocksize(struct super_block * , int  ) ;
#line 2187
extern int sb_has_dirty_inodes(struct super_block * ) ;
#line 2189
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
#line 2190
extern int generic_file_readonly_mmap(struct file * , struct vm_area_struct * ) ;
#line 2191
extern int file_read_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
#line 2192
extern int generic_write_checks(struct file *file , loff_t *pos , size_t *count ,
                                int isblk ) ;
#line 2193
extern ssize_t generic_file_aio_read(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                     loff_t  ) ;
#line 2194
extern ssize_t generic_file_aio_write(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                      loff_t  ) ;
#line 2195
extern ssize_t generic_file_aio_write_nolock(struct kiocb * , struct iovec  const  * ,
                                             unsigned long  , loff_t  ) ;
#line 2197
extern ssize_t generic_file_direct_write(struct kiocb * , struct iovec  const  * ,
                                         unsigned long * , loff_t  , loff_t * , size_t  ,
                                         size_t  ) ;
#line 2199
extern ssize_t generic_file_buffered_write(struct kiocb * , struct iovec  const  * ,
                                           unsigned long  , loff_t  , loff_t * , size_t  ,
                                           ssize_t  ) ;
#line 2201
extern ssize_t do_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
#line 2202
extern ssize_t do_sync_write(struct file *filp , char const   *buf , size_t len ,
                             loff_t *ppos ) ;
#line 2203
extern int generic_segment_checks(struct iovec  const  *iov , unsigned long *nr_segs ,
                                  size_t *count , int access_flags ) ;
#line 2207
extern ssize_t generic_file_splice_read(struct file * , loff_t * , struct pipe_inode_info * ,
                                        size_t  , unsigned int  ) ;
#line 2209
extern ssize_t generic_file_splice_write(struct pipe_inode_info * , struct file * ,
                                         loff_t * , size_t  , unsigned int  ) ;
#line 2211
extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe , struct file *out ,
                                       loff_t * , size_t len , unsigned int flags ) ;
#line 2213
extern long do_splice_direct(struct file *in , loff_t *ppos , struct file *out , size_t len ,
                             unsigned int flags ) ;
#line 2216
extern void file_ra_state_init(struct file_ra_state *ra , struct address_space *mapping ) ;
#line 2218
extern loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2219
extern loff_t generic_file_llseek(struct file *file , loff_t offset , int origin ) ;
#line 2220
extern loff_t generic_file_llseek_unlocked(struct file *file , loff_t offset , int origin ) ;
#line 2222
extern int generic_file_open(struct inode *inode , struct file *filp ) ;
#line 2223
extern int nonseekable_open(struct inode *inode , struct file *filp ) ;
#line 2233 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static int xip_truncate_page(struct address_space *mapping , loff_t from ) 
{ 

  {
#line 2235
  return (0);
}
}
#line 2240
extern ssize_t __blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                    struct block_device *bdev , struct iovec  const  *iov ,
                                    loff_t offset , unsigned long nr_segs , get_block_t *get_block ,
                                    dio_iodone_t *end_io , int lock_type ) ;
#line 2251 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ssize_t blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                           struct block_device *bdev , struct iovec  const  *iov ,
                                           loff_t offset , unsigned long nr_segs ,
                                           get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
#line 2256
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 1);
  }
#line 2256
  return (tmp);
}
}
#line 2260 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ssize_t blockdev_direct_IO_no_locking(int rw , struct kiocb *iocb ,
                                                      struct inode *inode , struct block_device *bdev ,
                                                      struct iovec  const  *iov ,
                                                      loff_t offset , unsigned long nr_segs ,
                                                      get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
#line 2265
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 2);
  }
#line 2265
  return (tmp);
}
}
#line 2269 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ssize_t blockdev_direct_IO_own_locking(int rw , struct kiocb *iocb ,
                                                       struct inode *inode , struct block_device *bdev ,
                                                       struct iovec  const  *iov ,
                                                       loff_t offset , unsigned long nr_segs ,
                                                       get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
#line 2274
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 3);
  }
#line 2274
  return (tmp);
}
}
#line 2279
extern struct file_operations  const  generic_ro_fops ;
#line 2283
extern int vfs_readlink(struct dentry * , char * , int  , char const   * ) ;
#line 2284
extern int vfs_follow_link(struct nameidata * , char const   * ) ;
#line 2285
extern int page_readlink(struct dentry * , char * , int  ) ;
#line 2286
extern void *page_follow_link_light(struct dentry * , struct nameidata * ) ;
#line 2287
extern void page_put_link(struct dentry * , struct nameidata * , void * ) ;
#line 2288
extern int __page_symlink(struct inode *inode , char const   *symname , int len ,
                          int nofs ) ;
#line 2290
extern int page_symlink(struct inode *inode , char const   *symname , int len ) ;
#line 2291
extern struct inode_operations  const  page_symlink_inode_operations ;
#line 2292
extern int generic_readlink(struct dentry * , char * , int  ) ;
#line 2293
extern void generic_fillattr(struct inode * , struct kstat * ) ;
#line 2294
extern int vfs_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
#line 2295
extern void inode_add_bytes(struct inode *inode , loff_t bytes ) ;
#line 2296
extern void inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
#line 2297
extern loff_t inode_get_bytes(struct inode *inode ) ;
#line 2298
extern void inode_set_bytes(struct inode *inode , loff_t bytes ) ;
#line 2300
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               u64  , unsigned int  ) , void * ) ;
#line 2302
extern int vfs_stat(char * , struct kstat * ) ;
#line 2303
extern int vfs_lstat(char * , struct kstat * ) ;
#line 2304
extern int vfs_fstat(unsigned int  , struct kstat * ) ;
#line 2305
extern int vfs_fstatat(int  , char * , struct kstat * , int  ) ;
#line 2307
extern int do_vfs_ioctl(struct file *filp , unsigned int fd , unsigned int cmd , unsigned long arg ) ;
#line 2309
extern int __generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                  u64 start , u64 len , get_block_t *get_block ) ;
#line 2312
extern int generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                u64 start , u64 len , get_block_t *get_block ) ;
#line 2316
extern void get_filesystem(struct file_system_type *fs ) ;
#line 2317
extern void put_filesystem(struct file_system_type *fs ) ;
#line 2318
extern struct file_system_type *get_fs_type(char const   *name ) ;
#line 2319
extern struct super_block *get_super(struct block_device * ) ;
#line 2320
extern struct super_block *user_get_super(dev_t  ) ;
#line 2321
extern void drop_super(struct super_block *sb ) ;
#line 2323
extern int dcache_dir_open(struct inode * , struct file * ) ;
#line 2324
extern int dcache_dir_close(struct inode * , struct file * ) ;
#line 2325
extern loff_t dcache_dir_lseek(struct file * , loff_t  , int  ) ;
#line 2326
extern int dcache_readdir(struct file * , void * , int (*)(void * , char const   * ,
                                                           int  , loff_t  , u64  ,
                                                           unsigned int  ) ) ;
#line 2327
extern int simple_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
#line 2328
extern int simple_statfs(struct dentry * , struct kstatfs * ) ;
#line 2329
extern int simple_link(struct dentry * , struct inode * , struct dentry * ) ;
#line 2330
extern int simple_unlink(struct inode * , struct dentry * ) ;
#line 2331
extern int simple_rmdir(struct inode * , struct dentry * ) ;
#line 2332
extern int simple_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
#line 2333
extern int simple_sync_file(struct file * , struct dentry * , int  ) ;
#line 2334
extern int simple_empty(struct dentry * ) ;
#line 2335
extern int simple_readpage(struct file *file , struct page *page ) ;
#line 2336
extern int simple_prepare_write(struct file *file , struct page *page , unsigned int offset ,
                                unsigned int to ) ;
#line 2338
extern int simple_write_begin(struct file *file , struct address_space *mapping ,
                              loff_t pos , unsigned int len , unsigned int flags ,
                              struct page **pagep , void **fsdata ) ;
#line 2341
extern int simple_write_end(struct file *file , struct address_space *mapping , loff_t pos ,
                            unsigned int len , unsigned int copied , struct page *page ,
                            void *fsdata ) ;
#line 2345
extern struct dentry *simple_lookup(struct inode * , struct dentry * , struct nameidata * ) ;
#line 2346
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
#line 2347
extern struct file_operations  const  simple_dir_operations ;
#line 2348
extern struct inode_operations  const  simple_dir_inode_operations ;
#line 2350
extern struct dentry *d_alloc_name(struct dentry * , char const   * ) ;
#line 2351
extern int simple_fill_super(struct super_block * , int  , struct tree_descr * ) ;
#line 2352
extern int simple_pin_fs(struct file_system_type * , struct vfsmount **mount , int *count ) ;
#line 2353
extern void simple_release_fs(struct vfsmount **mount , int *count ) ;
#line 2355
extern ssize_t simple_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
#line 2365
extern int inode_change_ok(struct inode * , struct iattr * ) ;
#line 2366
extern int inode_setattr(struct inode * , struct iattr * ) ;
#line 2368
extern void file_update_time(struct file *file ) ;
#line 2370
extern int generic_show_options(struct seq_file *m , struct vfsmount *mnt ) ;
#line 2371
extern void save_mount_options(struct super_block *sb , char *options ) ;
#line 2372
extern void replace_mount_options(struct super_block *sb , char *options ) ;
#line 2374 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static ino_t parent_ino(struct dentry *dentry ) 
{ ino_t res ;

  {
  {
#line 2378
  _spin_lock(& dentry->d_lock);
#line 2379
  res = ((dentry->d_parent)->d_inode)->i_ino;
#line 2380
  _spin_unlock(& dentry->d_lock);
  }
#line 2381
  return (res);
}
}
#line 2397
extern char *simple_transaction_get(struct file *file , char const   *buf , size_t size ) ;
#line 2399
extern ssize_t simple_transaction_read(struct file *file , char *buf , size_t size ,
                                       loff_t *pos ) ;
#line 2401
extern int simple_transaction_release(struct inode *inode , struct file *file ) ;
#line 2403
extern void simple_transaction_set(struct file *file , size_t n ) ;
#line 2435 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/fs.h"
__inline static void ( /* format attribute */  __simple_attr_check_format)(char const   *fmt 
                                                                           , ...) 
{ 

  {
#line 2439
  return;
}
}
#line 2441
extern int simple_attr_open(struct inode *inode , struct file *file , int (*get)(void * ,
                                                                                 u64 * ) ,
                            int (*set)(void * , u64  ) , char const   *fmt ) ;
#line 2444
extern int simple_attr_release(struct inode *inode , struct file *file ) ;
#line 2445
extern ssize_t simple_attr_read(struct file *file , char *buf , size_t len , loff_t *ppos ) ;
#line 2447
extern ssize_t simple_attr_write(struct file *file , char const   *buf , size_t len ,
                                 loff_t *ppos ) ;
#line 2451
extern int proc_nr_files(struct ctl_table *table , int write , struct file *filp ,
                         void *buffer , size_t *lenp , loff_t *ppos ) ;
#line 2454
extern int get_filesystem_list(char *buf )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
#line 29 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/debugfs.h"
extern struct dentry *arch_debugfs_dir ;
#line 34
extern struct file_operations  const  debugfs_file_operations ;
#line 35
extern struct inode_operations  const  debugfs_link_operations ;
#line 37
extern struct dentry *debugfs_create_file(char const   *name , mode_t mode , struct dentry *parent ,
                                          void *data , struct file_operations  const  *fops ) ;
#line 41
extern struct dentry *debugfs_create_dir(char const   *name , struct dentry *parent ) ;
#line 43
extern struct dentry *debugfs_create_symlink(char const   *name , struct dentry *parent ,
                                             char const   *dest ) ;
#line 46
extern void debugfs_remove(struct dentry *dentry ) ;
#line 47
extern void debugfs_remove_recursive(struct dentry *dentry ) ;
#line 49
extern struct dentry *debugfs_rename(struct dentry *old_dir , struct dentry *old_dentry ,
                                     struct dentry *new_dir , char const   *new_name ) ;
#line 52
extern struct dentry *debugfs_create_u8(char const   *name , mode_t mode , struct dentry *parent ,
                                        u8 *value ) ;
#line 54
extern struct dentry *debugfs_create_u16(char const   *name , mode_t mode , struct dentry *parent ,
                                         u16 *value ) ;
#line 56
extern struct dentry *debugfs_create_u32(char const   *name , mode_t mode , struct dentry *parent ,
                                         u32 *value ) ;
#line 58
extern struct dentry *debugfs_create_u64(char const   *name , mode_t mode , struct dentry *parent ,
                                         u64 *value ) ;
#line 60
extern struct dentry *debugfs_create_x8(char const   *name , mode_t mode , struct dentry *parent ,
                                        u8 *value ) ;
#line 62
extern struct dentry *debugfs_create_x16(char const   *name , mode_t mode , struct dentry *parent ,
                                         u16 *value ) ;
#line 64
extern struct dentry *debugfs_create_x32(char const   *name , mode_t mode , struct dentry *parent ,
                                         u32 *value ) ;
#line 66
extern struct dentry *debugfs_create_size_t(char const   *name , mode_t mode , struct dentry *parent ,
                                            size_t *value ) ;
#line 68
extern struct dentry *debugfs_create_bool(char const   *name , mode_t mode , struct dentry *parent ,
                                          u32 *value ) ;
#line 71
extern struct dentry *debugfs_create_blob(char const   *name , mode_t mode , struct dentry *parent ,
                                          struct debugfs_blob_wrapper *blob ) ;
#line 75
extern bool debugfs_initialized(void) ;
#line 364 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_num(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 366
  return ((int )((int const   )epd->bEndpointAddress & 15));
}
}
#line 376 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_type(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 378
  return ((int )((int const   )epd->bmAttributes & 3));
}
}
#line 387 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 389
  return (((int const   )epd->bEndpointAddress & 128) == 128);
}
}
#line 398 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_out(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 401
  return (((int const   )epd->bEndpointAddress & 128) == 0);
}
}
#line 410 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_bulk(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 413
  return (((int const   )epd->bmAttributes & 3) == 2);
}
}
#line 423 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_control(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 426
  return (((int const   )epd->bmAttributes & 3) == 0);
}
}
#line 437 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_int(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 440
  return (((int const   )epd->bmAttributes & 3) == 3);
}
}
#line 451 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_isoc(struct usb_endpoint_descriptor  const  *epd ) 
{ 

  {
#line 454
  return (((int const   )epd->bmAttributes & 3) == 1);
}
}
#line 465 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_bulk_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 468
  tmp = usb_endpoint_xfer_bulk(epd);
  }
#line 468
  if (tmp) {
    {
#line 468
    tmp___0 = usb_endpoint_dir_in(epd);
    }
#line 468
    if (tmp___0) {
      {
#line 468
      tmp___1 = 1;
      }
    } else {
      {
#line 468
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 468
    tmp___1 = 0;
    }
  }
#line 468
  return (tmp___1);
}
}
#line 478 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_bulk_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 481
  tmp = usb_endpoint_xfer_bulk(epd);
  }
#line 481
  if (tmp) {
    {
#line 481
    tmp___0 = usb_endpoint_dir_out(epd);
    }
#line 481
    if (tmp___0) {
      {
#line 481
      tmp___1 = 1;
      }
    } else {
      {
#line 481
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 481
    tmp___1 = 0;
    }
  }
#line 481
  return (tmp___1);
}
}
#line 491 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_int_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 494
  tmp = usb_endpoint_xfer_int(epd);
  }
#line 494
  if (tmp) {
    {
#line 494
    tmp___0 = usb_endpoint_dir_in(epd);
    }
#line 494
    if (tmp___0) {
      {
#line 494
      tmp___1 = 1;
      }
    } else {
      {
#line 494
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 494
    tmp___1 = 0;
    }
  }
#line 494
  return (tmp___1);
}
}
#line 504 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_int_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 507
  tmp = usb_endpoint_xfer_int(epd);
  }
#line 507
  if (tmp) {
    {
#line 507
    tmp___0 = usb_endpoint_dir_out(epd);
    }
#line 507
    if (tmp___0) {
      {
#line 507
      tmp___1 = 1;
      }
    } else {
      {
#line 507
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 507
    tmp___1 = 0;
    }
  }
#line 507
  return (tmp___1);
}
}
#line 517 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_isoc_in(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 520
  tmp = usb_endpoint_xfer_isoc(epd);
  }
#line 520
  if (tmp) {
    {
#line 520
    tmp___0 = usb_endpoint_dir_in(epd);
    }
#line 520
    if (tmp___0) {
      {
#line 520
      tmp___1 = 1;
      }
    } else {
      {
#line 520
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 520
    tmp___1 = 0;
    }
  }
#line 520
  return (tmp___1);
}
}
#line 530 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb/ch9.h"
__inline static int usb_endpoint_is_isoc_out(struct usb_endpoint_descriptor  const  *epd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 533
  tmp = usb_endpoint_xfer_isoc(epd);
  }
#line 533
  if (tmp) {
    {
#line 533
    tmp___0 = usb_endpoint_dir_out(epd);
    }
#line 533
    if (tmp___0) {
      {
#line 533
      tmp___1 = 1;
      }
    } else {
      {
#line 533
      tmp___1 = 0;
      }
    }
  } else {
    {
#line 533
    tmp___1 = 0;
    }
  }
#line 533
  return (tmp___1);
}
}
#line 189 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ void *tmp ;

  {
  {
#line 191
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
  }
#line 191
  return (tmp);
}
}
#line 194 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 

  {
  {
#line 196
  dev_set_drvdata(& intf->dev, data);
  }
#line 197
  return;
}
}
#line 199
extern struct usb_interface *usb_get_intf(struct usb_interface *intf ) ;
#line 200
extern void usb_put_intf(struct usb_interface *intf ) ;
#line 293
extern int __usb_get_extra_descriptor(char *buffer , unsigned int size , unsigned char type ,
                                      void **ptr ) ;
#line 509
extern struct usb_device *usb_get_dev(struct usb_device *dev ) ;
#line 510
extern void usb_put_dev(struct usb_device *dev ) ;
#line 516
extern int usb_lock_device_for_reset(struct usb_device *udev , struct usb_interface  const  *iface ) ;
#line 520
extern int usb_reset_device(struct usb_device *dev ) ;
#line 521
extern void usb_queue_reset_device(struct usb_interface *dev ) ;
#line 523
extern struct usb_device *usb_find_device(u16 vendor_id , u16 product_id ) ;
#line 527
extern int usb_autopm_set_interface(struct usb_interface *intf ) ;
#line 528
extern int usb_autopm_get_interface(struct usb_interface *intf ) ;
#line 529
extern void usb_autopm_put_interface(struct usb_interface *intf ) ;
#line 530
extern int usb_autopm_get_interface_async(struct usb_interface *intf ) ;
#line 531
extern void usb_autopm_put_interface_async(struct usb_interface *intf ) ;
#line 533 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_autopm_enable(struct usb_interface *intf ) 
{ 

  {
  {
#line 535
  intf->pm_usage_cnt = 0;
#line 536
  usb_autopm_set_interface(intf);
  }
#line 537
  return;
}
}
#line 539 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_autopm_disable(struct usb_interface *intf ) 
{ 

  {
  {
#line 541
  intf->pm_usage_cnt = 1;
#line 542
  usb_autopm_set_interface(intf);
  }
#line 543
  return;
}
}
#line 545 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_mark_last_busy(struct usb_device *udev ) 
{ 

  {
  {
#line 547
  udev->last_busy = (unsigned long )jiffies;
  }
#line 548
  return;
}
}
#line 576
extern int usb_get_current_frame_number(struct usb_device *usb_dev ) ;
#line 579
extern int usb_driver_claim_interface(struct usb_driver *driver , struct usb_interface *iface ,
                                      void *priv ) ;
#line 592 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_interface_claimed(struct usb_interface *iface ) 
{ 

  {
#line 594
  return ((unsigned long )iface->dev.driver != (unsigned long )((void *)0));
}
}
#line 597
extern void usb_driver_release_interface(struct usb_driver *driver , struct usb_interface *iface ) ;
#line 599
extern struct usb_device_id  const  *usb_match_id(struct usb_interface *interface ,
                                                  struct usb_device_id  const  *id ) ;
#line 601
extern int usb_match_one_id(struct usb_interface *interface , struct usb_device_id  const  *id ) ;
#line 604
extern struct usb_interface *usb_find_interface(struct usb_driver *drv , int minor ) ;
#line 606
extern struct usb_interface *usb_ifnum_to_if(struct usb_device  const  *dev , unsigned int ifnum ) ;
#line 608
extern struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface  const  *intf ,
                                                           unsigned int altnum ) ;
#line 636 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ int actual ;
  int tmp ;

  {
  {
#line 639
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, dev->devpath);
  }
#line 641
  if (actual >= (int )size) {
    {
#line 641
    tmp = -1;
    }
  } else {
    {
#line 641
    tmp = actual;
    }
  }
#line 641
  return (tmp);
}
}
#line 772
extern ssize_t usb_store_new_id(struct usb_dynids *dynids , struct device_driver *driver ,
                                char const   *buf , size_t count ) ;
#line 901
extern struct bus_type usb_bus_type ;
#line 923
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 925 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_register(struct usb_driver *driver ) 
{ int tmp ;

  {
  {
#line 927
  tmp = usb_register_driver(driver, (struct module *)0, "SomeModule");
  }
#line 927
  return (tmp);
}
}
#line 929
extern void usb_deregister(struct usb_driver * ) ;
#line 931
extern int usb_register_device_driver(struct usb_device_driver * , struct module * ) ;
#line 933
extern void usb_deregister_device_driver(struct usb_device_driver * ) ;
#line 935
extern int usb_register_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) ;
#line 937
extern void usb_deregister_dev(struct usb_interface *intf , struct usb_class_driver *class_driver ) ;
#line 940
extern int usb_disabled(void) ;
#line 988 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
static struct lock_class_key __key___2  ;
#line 984 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void init_usb_anchor(struct usb_anchor *anchor ) 
{ 

  {
  {
#line 986
  INIT_LIST_HEAD(& anchor->urb_list);
#line 987
  init_waitqueue_head(& anchor->wait);
  }
  {
#line 988
  while (1) {
    while_217_continue: /* CIL Label */ ;
    {
#line 988
    __spin_lock_init(& anchor->lock, "&anchor->lock", & __key___2);
    }
    goto while_217_break;
  }
  while_217_break: /* CIL Label */ ;
  }
#line 989
  return;
}
}
#line 1211 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_fill_control_urb(struct urb *urb , struct usb_device *dev ,
                                          unsigned int pipe , unsigned char *setup_packet ,
                                          void *transfer_buffer , int buffer_length ,
                                          void (*complete_fn)(struct urb * ) , void *context ) 
{ 

  {
  {
#line 1220
  urb->dev = dev;
#line 1221
  urb->pipe = pipe;
#line 1222
  urb->setup_packet = setup_packet;
#line 1223
  urb->transfer_buffer = transfer_buffer;
#line 1224
  urb->transfer_buffer_length = (unsigned int )buffer_length;
#line 1225
  urb->complete = complete_fn;
#line 1226
  urb->context = context;
  }
#line 1227
  return;
}
}
#line 1242 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 

  {
  {
#line 1250
  urb->dev = dev;
#line 1251
  urb->pipe = pipe;
#line 1252
  urb->transfer_buffer = transfer_buffer;
#line 1253
  urb->transfer_buffer_length = (unsigned int )buffer_length;
#line 1254
  urb->complete = complete_fn;
#line 1255
  urb->context = context;
  }
#line 1256
  return;
}
}
#line 1276 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval ) 
{ 

  {
  {
#line 1285
  urb->dev = dev;
#line 1286
  urb->pipe = pipe;
#line 1287
  urb->transfer_buffer = transfer_buffer;
#line 1288
  urb->transfer_buffer_length = (unsigned int )buffer_length;
#line 1289
  urb->complete = complete_fn;
#line 1290
  urb->context = context;
  }
#line 1291
  if ((unsigned int )dev->speed == 3U) {
    {
#line 1292
    urb->interval = 1 << (interval - 1);
    }
  } else {
    {
#line 1294
    urb->interval = interval;
    }
  }
  {
#line 1295
  urb->start_frame = -1;
  }
#line 1296
  return;
}
}
#line 1298
extern void usb_init_urb(struct urb *urb ) ;
#line 1299
extern struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) ;
#line 1300
extern void usb_free_urb(struct urb *urb ) ;
#line 1302
extern struct urb *usb_get_urb(struct urb *urb ) ;
#line 1303
extern int usb_submit_urb(struct urb *urb , gfp_t mem_flags ) ;
#line 1304
extern int usb_unlink_urb(struct urb *urb ) ;
#line 1305
extern void usb_kill_urb(struct urb *urb ) ;
#line 1306
extern void usb_poison_urb(struct urb *urb ) ;
#line 1307
extern void usb_unpoison_urb(struct urb *urb ) ;
#line 1308
extern void usb_kill_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1309
extern void usb_poison_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1310
extern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1311
extern void usb_unlink_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1312
extern void usb_anchor_urb(struct urb *urb , struct usb_anchor *anchor ) ;
#line 1313
extern void usb_unanchor_urb(struct urb *urb ) ;
#line 1314
extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor , unsigned int timeout ) ;
#line 1316
extern struct urb *usb_get_from_anchor(struct usb_anchor *anchor ) ;
#line 1317
extern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor ) ;
#line 1318
extern int usb_anchor_empty(struct usb_anchor *anchor ) ;
#line 1327 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_urb_dir_in(struct urb *urb ) 
{ 

  {
#line 1329
  return ((urb->transfer_flags & 512U) == 512U);
}
}
#line 1339 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static int usb_urb_dir_out(struct urb *urb ) 
{ 

  {
#line 1341
  return ((urb->transfer_flags & 512U) == 0U);
}
}
#line 1344
extern void *usb_buffer_alloc(struct usb_device *dev , size_t size , gfp_t mem_flags ,
                              dma_addr_t *dma ) ;
#line 1346
extern void usb_buffer_free(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) ;
#line 1356
extern int usb_buffer_map_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                             int nents ) ;
#line 1362
extern void usb_buffer_unmap_sg(struct usb_device  const  *dev , int is_in , struct scatterlist *sg ,
                                int n_hw_ents ) ;
#line 1369
extern int usb_control_msg(struct usb_device *dev , unsigned int pipe , __u8 request ,
                           __u8 requesttype , __u16 value , __u16 index , void *data ,
                           __u16 size , int timeout ) ;
#line 1372
extern int usb_interrupt_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                             int len , int *actual_length , int timeout ) ;
#line 1374
extern int usb_bulk_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                        int len , int *actual_length , int timeout ) ;
#line 1379
extern int usb_get_descriptor(struct usb_device *dev , unsigned char desctype , unsigned char descindex ,
                              void *buf , int size ) ;
#line 1381
extern int usb_get_status(struct usb_device *dev , int type , int target , void *data ) ;
#line 1383
extern int usb_string(struct usb_device *dev , int index , char *buf , size_t size ) ;
#line 1387
extern int usb_clear_halt(struct usb_device *dev , int pipe ) ;
#line 1388
extern int usb_reset_configuration(struct usb_device *dev ) ;
#line 1389
extern int usb_set_interface(struct usb_device *dev , int ifnum , int alternate ) ;
#line 1390
extern void usb_reset_endpoint(struct usb_device *dev , unsigned int epaddr ) ;
#line 1393
extern int usb_driver_set_configuration(struct usb_device *udev , int config ) ;
#line 1443
extern int usb_sg_init(struct usb_sg_request *io , struct usb_device *dev , unsigned int pipe ,
                       unsigned int period , struct scatterlist *sg , int nents ,
                       size_t length , gfp_t mem_flags ) ;
#line 1453
extern void usb_sg_cancel(struct usb_sg_request *io ) ;
#line 1454
extern void usb_sg_wait(struct usb_sg_request *io ) ;
#line 1495 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 

  {
#line 1498
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 1521 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h"
__inline static __u16 usb_maxpacket(struct usb_device *udev , int pipe , int is_out ) 
{ struct usb_host_endpoint *ep ;
  unsigned int epnum ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  {
#line 1525
  epnum = (unsigned int )((pipe >> 15) & 15);
  }
#line 1527
  if (is_out) {
    {
#line 1528
    __ret_warn_on = ! (! (pipe & 128));
#line 1528
    tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 1528
    if (tmp) {
      {
#line 1528
      warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h",
                         1528);
      }
    }
    {
#line 1528
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 1529
    ep = udev->ep_out[epnum];
    }
  } else {
    {
#line 1531
    __ret_warn_on___0 = ! (! (! (pipe & 128)));
#line 1531
    tmp___0 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
#line 1531
    if (tmp___0) {
      {
#line 1531
      warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/usb.h",
                         1531);
      }
    }
    {
#line 1531
    __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
#line 1532
    ep = udev->ep_in[epnum];
    }
  }
#line 1534
  if (! ep) {
#line 1535
    return ((unsigned short)0);
  }
#line 1538
  return (ep->desc.wMaxPacketSize);
}
}
#line 1548
extern void usb_register_notify(struct notifier_block *nb ) ;
#line 1549
extern void usb_unregister_notify(struct notifier_block *nb ) ;
#line 40 "/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dmi.h"
extern int dmi_check_system(struct dmi_system_id  const  *list ) ;
#line 41
extern struct dmi_system_id  const  *dmi_first_match(struct dmi_system_id  const  *list ) ;
#line 42
extern char const   *dmi_get_system_info(int field ) ;
#line 43
extern struct dmi_device  const  *dmi_find_device(int type , char const   *name ,
                                                  struct dmi_device  const  *from ) ;
#line 45
extern void dmi_scan_machine(void) ;
#line 46
extern int dmi_get_year(int field ) ;
#line 47
extern int dmi_name_in_vendors(char const   *str ) ;
#line 48
extern int dmi_name_in_serial(char const   *str ) ;
#line 49
extern int dmi_available ;
#line 50
extern int dmi_walk(void (*decode)(struct dmi_header  const  * , void * ) , void *private_data ) ;
#line 52
extern bool dmi_match(enum dmi_field f , char const   *str ) ;
#line 99 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess.h"
extern int fixup_exception(struct pt_regs *regs ) ;
#line 116
extern int __get_user_1(void) ;
#line 117
extern int __get_user_2(void) ;
#line 118
extern int __get_user_4(void) ;
#line 119
extern int __get_user_8(void) ;
#line 120
extern int __get_user_bad(void) ;
#line 221
extern void __put_user_bad(void) ;
#line 227
extern void __put_user_1(void) ;
#line 228
extern void __put_user_2(void) ;
#line 229
extern void __put_user_4(void) ;
#line 230
extern void __put_user_8(void) ;
#line 563
extern struct movsl_mask movsl_mask ;
#line 14 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
extern unsigned long __copy_to_user_ll(void *to , void const   *from , unsigned long n ) ;
#line 16
extern unsigned long __copy_from_user_ll(void *to , void const   *from , unsigned long n ) ;
#line 18
extern unsigned long __copy_from_user_ll_nozero(void *to , void const   *from , unsigned long n ) ;
#line 20
extern unsigned long __copy_from_user_ll_nocache(void *to , void const   *from , unsigned long n ) ;
#line 22
extern unsigned long __copy_from_user_ll_nocache_nozero(void *to , void const   *from ,
                                                        unsigned long n ) ;
#line 44 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_to_user_inatomic(void *to , void const   *from ,
                                                      unsigned long n ) 
{ unsigned long ret ;
  unsigned long tmp ;

  {
#line 47
  if (0) {
#line 51
    if ((int )n == 1) {
      goto switch_218_1;
    } else {
#line 55
      if ((int )n == 2) {
        goto switch_218_2;
      } else {
#line 59
        if ((int )n == 4) {
          goto switch_218_4;
        } else {
#line 50
          if (0) {
            switch_218_1: /* CIL Label */ 
            {
#line 52
            while (1) {
              while_219_continue: /* CIL Label */ ;
              {
#line 52
              ret = 0UL;
              }
#line 52
              if (1 == 1) {
                goto switch_220_1;
              } else {
#line 52
                if (1 == 2) {
                  goto switch_220_2;
                } else {
#line 52
                  if (1 == 4) {
                    goto switch_220_4;
                  } else {
#line 52
                    if (1 == 8) {
                      goto switch_220_8;
                    } else {
                      {
                      goto switch_220_default;
#line 52
                      if (0) {
                        switch_220_1: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_220_break;
                        switch_220_2: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_220_break;
                        switch_220_4: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_220_break;
                        switch_220_8: /* CIL Label */ 
                        {
#line 52
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u8 *)from)),
                                             "r" ((u8 *)to), "i" (1), "0" (ret));
                        }
                        goto switch_220_break;
                        switch_220_default: /* CIL Label */ 
                        {
#line 52
                        __put_user_bad();
                        }
                      } else {
                        switch_220_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_219_break;
            }
            while_219_break: /* CIL Label */ ;
            }
#line 54
            return (ret);
            switch_218_2: /* CIL Label */ 
            {
#line 56
            while (1) {
              while_221_continue: /* CIL Label */ ;
              {
#line 56
              ret = 0UL;
              }
#line 56
              if (2 == 1) {
                goto switch_222_1;
              } else {
#line 56
                if (2 == 2) {
                  goto switch_222_2;
                } else {
#line 56
                  if (2 == 4) {
                    goto switch_222_4;
                  } else {
#line 56
                    if (2 == 8) {
                      goto switch_222_8;
                    } else {
                      {
                      goto switch_222_default;
#line 56
                      if (0) {
                        switch_222_1: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_222_break;
                        switch_222_2: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_222_break;
                        switch_222_4: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_222_break;
                        switch_222_8: /* CIL Label */ 
                        {
#line 56
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u16 *)from)),
                                             "r" ((u16 *)to), "i" (2), "0" (ret));
                        }
                        goto switch_222_break;
                        switch_222_default: /* CIL Label */ 
                        {
#line 56
                        __put_user_bad();
                        }
                      } else {
                        switch_222_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_221_break;
            }
            while_221_break: /* CIL Label */ ;
            }
#line 58
            return (ret);
            switch_218_4: /* CIL Label */ 
            {
#line 60
            while (1) {
              while_223_continue: /* CIL Label */ ;
              {
#line 60
              ret = 0UL;
              }
#line 60
              if (4 == 1) {
                goto switch_224_1;
              } else {
#line 60
                if (4 == 2) {
                  goto switch_224_2;
                } else {
#line 60
                  if (4 == 4) {
                    goto switch_224_4;
                  } else {
#line 60
                    if (4 == 8) {
                      goto switch_224_8;
                    } else {
                      {
                      goto switch_224_default;
#line 60
                      if (0) {
                        switch_224_1: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_224_break;
                        switch_224_2: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_224_break;
                        switch_224_4: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_224_break;
                        switch_224_8: /* CIL Label */ 
                        {
#line 60
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u32 *)from)),
                                             "r" ((u32 *)to), "i" (4), "0" (ret));
                        }
                        goto switch_224_break;
                        switch_224_default: /* CIL Label */ 
                        {
#line 60
                        __put_user_bad();
                        }
                      } else {
                        switch_224_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_223_break;
            }
            while_223_break: /* CIL Label */ ;
            }
#line 62
            return (ret);
          } else {
            switch_218_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 65
  tmp = __copy_to_user_ll(to, from, n);
  }
#line 65
  return (tmp);
}
}
#line 82 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_to_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
#line 85
  might_fault();
#line 86
  tmp = __copy_to_user_inatomic(to, from, n);
  }
#line 86
  return (tmp);
}
}
#line 89 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user_inatomic(void *to , void const   *from ,
                                                        unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 97
  if (0) {
#line 101
    if ((int )n == 1) {
      goto switch_225_1;
    } else {
#line 104
      if ((int )n == 2) {
        goto switch_225_2;
      } else {
#line 107
        if ((int )n == 4) {
          goto switch_225_4;
        } else {
#line 100
          if (0) {
            switch_225_1: /* CIL Label */ 
            {
#line 102
            while (1) {
              while_226_continue: /* CIL Label */ ;
              {
#line 102
              ret = 0UL;
              }
#line 102
              if (1 == 1) {
                goto switch_227_1;
              } else {
#line 102
                if (1 == 2) {
                  goto switch_227_2;
                } else {
#line 102
                  if (1 == 4) {
                    goto switch_227_4;
                  } else {
#line 102
                    if (1 == 8) {
                      goto switch_227_8;
                    } else {
                      {
                      goto switch_227_default;
#line 102
                      if (0) {
                        switch_227_1: /* CIL Label */ 
                        {
#line 102
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_227_break;
                        switch_227_2: /* CIL Label */ 
                        {
#line 102
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_227_break;
                        switch_227_4: /* CIL Label */ 
                        {
#line 102
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_227_break;
                        switch_227_8: /* CIL Label */ 
                        {
#line 102
                        tmp = __get_user_bad();
#line 102
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_227_break;
                        switch_227_default: /* CIL Label */ 
                        {
#line 102
                        tmp___0 = __get_user_bad();
#line 102
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_227_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_226_break;
            }
            while_226_break: /* CIL Label */ ;
            }
#line 103
            return (ret);
            switch_225_2: /* CIL Label */ 
            {
#line 105
            while (1) {
              while_228_continue: /* CIL Label */ ;
              {
#line 105
              ret = 0UL;
              }
#line 105
              if (2 == 1) {
                goto switch_229_1;
              } else {
#line 105
                if (2 == 2) {
                  goto switch_229_2;
                } else {
#line 105
                  if (2 == 4) {
                    goto switch_229_4;
                  } else {
#line 105
                    if (2 == 8) {
                      goto switch_229_8;
                    } else {
                      {
                      goto switch_229_default;
#line 105
                      if (0) {
                        switch_229_1: /* CIL Label */ 
                        {
#line 105
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_229_break;
                        switch_229_2: /* CIL Label */ 
                        {
#line 105
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_229_break;
                        switch_229_4: /* CIL Label */ 
                        {
#line 105
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_229_break;
                        switch_229_8: /* CIL Label */ 
                        {
#line 105
                        tmp___1 = __get_user_bad();
#line 105
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_229_break;
                        switch_229_default: /* CIL Label */ 
                        {
#line 105
                        tmp___2 = __get_user_bad();
#line 105
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_229_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_228_break;
            }
            while_228_break: /* CIL Label */ ;
            }
#line 106
            return (ret);
            switch_225_4: /* CIL Label */ 
            {
#line 108
            while (1) {
              while_230_continue: /* CIL Label */ ;
              {
#line 108
              ret = 0UL;
              }
#line 108
              if (4 == 1) {
                goto switch_231_1;
              } else {
#line 108
                if (4 == 2) {
                  goto switch_231_2;
                } else {
#line 108
                  if (4 == 4) {
                    goto switch_231_4;
                  } else {
#line 108
                    if (4 == 8) {
                      goto switch_231_8;
                    } else {
                      {
                      goto switch_231_default;
#line 108
                      if (0) {
                        switch_231_1: /* CIL Label */ 
                        {
#line 108
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_231_break;
                        switch_231_2: /* CIL Label */ 
                        {
#line 108
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_231_break;
                        switch_231_4: /* CIL Label */ 
                        {
#line 108
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_231_break;
                        switch_231_8: /* CIL Label */ 
                        {
#line 108
                        tmp___3 = __get_user_bad();
#line 108
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_231_break;
                        switch_231_default: /* CIL Label */ 
                        {
#line 108
                        tmp___4 = __get_user_bad();
#line 108
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_231_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_230_break;
            }
            while_230_break: /* CIL Label */ ;
            }
#line 109
            return (ret);
          } else {
            switch_225_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 112
  tmp___5 = __copy_from_user_ll_nozero(to, from, n);
  }
#line 112
  return (tmp___5);
}
}
#line 137 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 140
  might_fault();
  }
#line 141
  if (0) {
#line 145
    if ((int )n == 1) {
      goto switch_232_1;
    } else {
#line 148
      if ((int )n == 2) {
        goto switch_232_2;
      } else {
#line 151
        if ((int )n == 4) {
          goto switch_232_4;
        } else {
#line 144
          if (0) {
            switch_232_1: /* CIL Label */ 
            {
#line 146
            while (1) {
              while_233_continue: /* CIL Label */ ;
              {
#line 146
              ret = 0UL;
              }
#line 146
              if (1 == 1) {
                goto switch_234_1;
              } else {
#line 146
                if (1 == 2) {
                  goto switch_234_2;
                } else {
#line 146
                  if (1 == 4) {
                    goto switch_234_4;
                  } else {
#line 146
                    if (1 == 8) {
                      goto switch_234_8;
                    } else {
                      {
                      goto switch_234_default;
#line 146
                      if (0) {
                        switch_234_1: /* CIL Label */ 
                        {
#line 146
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_234_break;
                        switch_234_2: /* CIL Label */ 
                        {
#line 146
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_234_break;
                        switch_234_4: /* CIL Label */ 
                        {
#line 146
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_234_break;
                        switch_234_8: /* CIL Label */ 
                        {
#line 146
                        tmp = __get_user_bad();
#line 146
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_234_break;
                        switch_234_default: /* CIL Label */ 
                        {
#line 146
                        tmp___0 = __get_user_bad();
#line 146
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_234_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_233_break;
            }
            while_233_break: /* CIL Label */ ;
            }
#line 147
            return (ret);
            switch_232_2: /* CIL Label */ 
            {
#line 149
            while (1) {
              while_235_continue: /* CIL Label */ ;
              {
#line 149
              ret = 0UL;
              }
#line 149
              if (2 == 1) {
                goto switch_236_1;
              } else {
#line 149
                if (2 == 2) {
                  goto switch_236_2;
                } else {
#line 149
                  if (2 == 4) {
                    goto switch_236_4;
                  } else {
#line 149
                    if (2 == 8) {
                      goto switch_236_8;
                    } else {
                      {
                      goto switch_236_default;
#line 149
                      if (0) {
                        switch_236_1: /* CIL Label */ 
                        {
#line 149
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_236_break;
                        switch_236_2: /* CIL Label */ 
                        {
#line 149
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_236_break;
                        switch_236_4: /* CIL Label */ 
                        {
#line 149
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_236_break;
                        switch_236_8: /* CIL Label */ 
                        {
#line 149
                        tmp___1 = __get_user_bad();
#line 149
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_236_break;
                        switch_236_default: /* CIL Label */ 
                        {
#line 149
                        tmp___2 = __get_user_bad();
#line 149
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_236_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_235_break;
            }
            while_235_break: /* CIL Label */ ;
            }
#line 150
            return (ret);
            switch_232_4: /* CIL Label */ 
            {
#line 152
            while (1) {
              while_237_continue: /* CIL Label */ ;
              {
#line 152
              ret = 0UL;
              }
#line 152
              if (4 == 1) {
                goto switch_238_1;
              } else {
#line 152
                if (4 == 2) {
                  goto switch_238_2;
                } else {
#line 152
                  if (4 == 4) {
                    goto switch_238_4;
                  } else {
#line 152
                    if (4 == 8) {
                      goto switch_238_8;
                    } else {
                      {
                      goto switch_238_default;
#line 152
                      if (0) {
                        switch_238_1: /* CIL Label */ 
                        {
#line 152
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_238_break;
                        switch_238_2: /* CIL Label */ 
                        {
#line 152
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_238_break;
                        switch_238_4: /* CIL Label */ 
                        {
#line 152
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_238_break;
                        switch_238_8: /* CIL Label */ 
                        {
#line 152
                        tmp___3 = __get_user_bad();
#line 152
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_238_break;
                        switch_238_default: /* CIL Label */ 
                        {
#line 152
                        tmp___4 = __get_user_bad();
#line 152
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_238_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_237_break;
            }
            while_237_break: /* CIL Label */ ;
            }
#line 153
            return (ret);
          } else {
            switch_232_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 156
  tmp___5 = __copy_from_user_ll(to, from, n);
  }
#line 156
  return (tmp___5);
}
}
#line 159 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user_nocache(void *to , void const   *from ,
                                                       unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 162
  might_fault();
  }
#line 163
  if (0) {
#line 167
    if ((int )n == 1) {
      goto switch_239_1;
    } else {
#line 170
      if ((int )n == 2) {
        goto switch_239_2;
      } else {
#line 173
        if ((int )n == 4) {
          goto switch_239_4;
        } else {
#line 166
          if (0) {
            switch_239_1: /* CIL Label */ 
            {
#line 168
            while (1) {
              while_240_continue: /* CIL Label */ ;
              {
#line 168
              ret = 0UL;
              }
#line 168
              if (1 == 1) {
                goto switch_241_1;
              } else {
#line 168
                if (1 == 2) {
                  goto switch_241_2;
                } else {
#line 168
                  if (1 == 4) {
                    goto switch_241_4;
                  } else {
#line 168
                    if (1 == 8) {
                      goto switch_241_8;
                    } else {
                      {
                      goto switch_241_default;
#line 168
                      if (0) {
                        switch_241_1: /* CIL Label */ 
                        {
#line 168
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_241_break;
                        switch_241_2: /* CIL Label */ 
                        {
#line 168
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_241_break;
                        switch_241_4: /* CIL Label */ 
                        {
#line 168
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_241_break;
                        switch_241_8: /* CIL Label */ 
                        {
#line 168
                        tmp = __get_user_bad();
#line 168
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_241_break;
                        switch_241_default: /* CIL Label */ 
                        {
#line 168
                        tmp___0 = __get_user_bad();
#line 168
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_241_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_240_break;
            }
            while_240_break: /* CIL Label */ ;
            }
#line 169
            return (ret);
            switch_239_2: /* CIL Label */ 
            {
#line 171
            while (1) {
              while_242_continue: /* CIL Label */ ;
              {
#line 171
              ret = 0UL;
              }
#line 171
              if (2 == 1) {
                goto switch_243_1;
              } else {
#line 171
                if (2 == 2) {
                  goto switch_243_2;
                } else {
#line 171
                  if (2 == 4) {
                    goto switch_243_4;
                  } else {
#line 171
                    if (2 == 8) {
                      goto switch_243_8;
                    } else {
                      {
                      goto switch_243_default;
#line 171
                      if (0) {
                        switch_243_1: /* CIL Label */ 
                        {
#line 171
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_243_break;
                        switch_243_2: /* CIL Label */ 
                        {
#line 171
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_243_break;
                        switch_243_4: /* CIL Label */ 
                        {
#line 171
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_243_break;
                        switch_243_8: /* CIL Label */ 
                        {
#line 171
                        tmp___1 = __get_user_bad();
#line 171
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_243_break;
                        switch_243_default: /* CIL Label */ 
                        {
#line 171
                        tmp___2 = __get_user_bad();
#line 171
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_243_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_242_break;
            }
            while_242_break: /* CIL Label */ ;
            }
#line 172
            return (ret);
            switch_239_4: /* CIL Label */ 
            {
#line 174
            while (1) {
              while_244_continue: /* CIL Label */ ;
              {
#line 174
              ret = 0UL;
              }
#line 174
              if (4 == 1) {
                goto switch_245_1;
              } else {
#line 174
                if (4 == 2) {
                  goto switch_245_2;
                } else {
#line 174
                  if (4 == 4) {
                    goto switch_245_4;
                  } else {
#line 174
                    if (4 == 8) {
                      goto switch_245_8;
                    } else {
                      {
                      goto switch_245_default;
#line 174
                      if (0) {
                        switch_245_1: /* CIL Label */ 
                        {
#line 174
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_245_break;
                        switch_245_2: /* CIL Label */ 
                        {
#line 174
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_245_break;
                        switch_245_4: /* CIL Label */ 
                        {
#line 174
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_245_break;
                        switch_245_8: /* CIL Label */ 
                        {
#line 174
                        tmp___3 = __get_user_bad();
#line 174
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_245_break;
                        switch_245_default: /* CIL Label */ 
                        {
#line 174
                        tmp___4 = __get_user_bad();
#line 174
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_245_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_244_break;
            }
            while_244_break: /* CIL Label */ ;
            }
#line 175
            return (ret);
          } else {
            switch_239_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 178
  tmp___5 = __copy_from_user_ll_nocache(to, from, n);
  }
#line 178
  return (tmp___5);
}
}
#line 181 "/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/uaccess_32.h"
__inline static unsigned long __copy_from_user_inatomic_nocache(void *to , void const   *from ,
                                                                unsigned long n ) 
{ unsigned long tmp ;

  {
  {
#line 185
  tmp = __copy_from_user_ll_nocache_nozero(to, from, n);
  }
#line 185
  return (tmp);
}
}
#line 188
extern unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 190
extern unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) ;
#line 193
extern long strncpy_from_user(char *dst , char const   *src , long count ) ;
#line 195
extern long __strncpy_from_user(char *dst , char const   *src , long count ) ;
#line 214
extern long strnlen_user(char const   *str , long n ) ;
#line 215
extern unsigned long clear_user(void *mem , unsigned long len ) ;
#line 216
extern unsigned long __clear_user(void *mem , unsigned long len ) ;
#line 145 "../core/hcd.h"
__inline static struct usb_bus *hcd_to_bus(struct usb_hcd *hcd ) 
{ 

  {
#line 147
  return (& hcd->self);
}
}
#line 150 "../core/hcd.h"
__inline static struct usb_hcd *bus_to_hcd(struct usb_bus *bus ) 
{ struct usb_bus  const  *__mptr ;

  {
  {
#line 152
  __mptr = (struct usb_bus  const  *)bus;
  }
#line 152
  return ((struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->self)));
}
}
#line 233
extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd , struct urb *urb ) ;
#line 234
extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd , struct urb *urb , int status ) ;
#line 236
extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd , struct urb *urb ) ;
#line 238
extern int usb_hcd_submit_urb(struct urb *urb , gfp_t mem_flags ) ;
#line 239
extern int usb_hcd_unlink_urb(struct urb *urb , int status ) ;
#line 240
extern void usb_hcd_giveback_urb(struct usb_hcd *hcd , struct urb *urb , int status ) ;
#line 242
extern void usb_hcd_flush_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) ;
#line 244
extern void usb_hcd_disable_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) ;
#line 246
extern void usb_hcd_reset_endpoint(struct usb_device *udev , struct usb_host_endpoint *ep ) ;
#line 248
extern void usb_hcd_synchronize_unlinks(struct usb_device *udev ) ;
#line 249
extern int usb_hcd_get_frame_number(struct usb_device *udev ) ;
#line 251
extern struct usb_hcd *usb_create_hcd(struct hc_driver  const  *driver , struct device *dev ,
                                      char const   *bus_name ) ;
#line 253
extern struct usb_hcd *usb_get_hcd(struct usb_hcd *hcd ) ;
#line 254
extern void usb_put_hcd(struct usb_hcd *hcd ) ;
#line 255
extern int usb_add_hcd(struct usb_hcd *hcd , unsigned int irqnum , unsigned long irqflags ) ;
#line 257
extern void usb_remove_hcd(struct usb_hcd *hcd ) ;
#line 260
extern void usb_hcd_platform_shutdown(struct platform_device *dev ) ;
#line 265
extern int usb_hcd_pci_probe(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
#line 267
extern void usb_hcd_pci_remove(struct pci_dev *dev ) ;
#line 270
extern int usb_hcd_pci_suspend(struct pci_dev *dev , pm_message_t msg ) ;
#line 271
extern int usb_hcd_pci_resume(struct pci_dev *dev ) ;
#line 274
extern void usb_hcd_pci_shutdown(struct pci_dev *dev ) ;
#line 279
extern int hcd_buffer_create(struct usb_hcd *hcd ) ;
#line 280
extern void hcd_buffer_destroy(struct usb_hcd *hcd ) ;
#line 282
extern void *hcd_buffer_alloc(struct usb_bus *bus , size_t size , gfp_t mem_flags ,
                              dma_addr_t *dma ) ;
#line 284
extern void hcd_buffer_free(struct usb_bus *bus , size_t size , void *addr , dma_addr_t dma ) ;
#line 288
extern irqreturn_t usb_hcd_irq(int irq , void *__hcd ) ;
#line 290
extern void usb_hc_died(struct usb_hcd *hcd ) ;
#line 291
extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd ) ;
#line 303
extern struct usb_device *usb_alloc_dev(struct usb_device *parent , struct usb_bus * ,
                                        unsigned int port ) ;
#line 305
extern int usb_new_device(struct usb_device *dev ) ;
#line 306
extern void usb_disconnect(struct usb_device ** ) ;
#line 308
extern int usb_get_configuration(struct usb_device *dev ) ;
#line 309
extern void usb_destroy_configuration(struct usb_device *dev ) ;
#line 199 "../core/hub.h"
extern int usb_hub_clear_tt_buffer(struct urb *urb ) ;
#line 200
extern void usb_ep0_reinit(struct usb_device * ) ;
#line 385 "../core/hcd.h"
extern long usb_calc_bus_time(int speed , int is_input , int isoc , int bytecount ) ;
#line 390
extern void usb_set_device_state(struct usb_device *udev , enum usb_device_state new_state ) ;
#line 397
extern struct list_head usb_bus_list ;
#line 398
extern struct mutex usb_bus_list_lock ;
#line 399
extern wait_queue_head_t usb_kill_urb_queue ;
#line 401
extern int usb_find_interface_driver(struct usb_device *dev , struct usb_interface *interface ) ;
#line 407
extern void usb_hcd_resume_root_hub(struct usb_hcd *hcd ) ;
#line 408
extern void usb_root_hub_lost_power(struct usb_device *rhdev ) ;
#line 409
extern int hcd_bus_suspend(struct usb_device *rhdev , pm_message_t msg ) ;
#line 410
extern int hcd_bus_resume(struct usb_device *rhdev , pm_message_t msg ) ;
#line 428
extern void usbfs_update_special(void) ;
#line 429
extern int usbfs_init(void) ;
#line 430
extern void usbfs_cleanup(void) ;
#line 451
extern struct usb_mon_operations *mon_ops ;
#line 453 "../core/hcd.h"
__inline static void usbmon_urb_submit(struct usb_bus *bus , struct urb *urb ) 
{ 

  {
#line 455
  if (bus->monitored) {
    {
#line 456
    (*(mon_ops->urb_submit))(bus, urb);
    }
  }
#line 457
  return;
}
}
#line 459 "../core/hcd.h"
__inline static void usbmon_urb_submit_error(struct usb_bus *bus , struct urb *urb ,
                                             int error ) 
{ 

  {
#line 462
  if (bus->monitored) {
    {
#line 463
    (*(mon_ops->urb_submit_error))(bus, urb, error);
    }
  }
#line 464
  return;
}
}
#line 466 "../core/hcd.h"
__inline static void usbmon_urb_complete(struct usb_bus *bus , struct urb *urb , int status ) 
{ 

  {
#line 469
  if (bus->monitored) {
    {
#line 470
    (*(mon_ops->urb_complete))(bus, urb, status);
    }
  }
#line 471
  return;
}
}
#line 473
extern int usb_mon_register(struct usb_mon_operations *ops ) ;
#line 474
extern void usb_mon_deregister(void) ;
#line 504
extern struct rw_semaphore ehci_cf_port_reset_rwsem ;
#line 510
extern unsigned long usb_hcds_loaded ;
#line 166 "uhci-hcd.h"
__inline static __le32 qh_element(struct uhci_qh *qh ) 
{ __le32 element ;

  {
  {
#line 167
  element = qh->element;
#line 169
  __asm__  volatile   ("": : : "memory");
  }
#line 170
  return (element);
}
}
#line 261 "uhci-hcd.h"
__inline static u32 td_status(struct uhci_td *td ) 
{ __le32 status ;

  {
  {
#line 262
  status = td->status;
#line 264
  __asm__  volatile   ("": : : "memory");
  }
#line 265
  return (status);
}
}
#line 430 "uhci-hcd.h"
__inline static struct uhci_hcd *hcd_to_uhci(struct usb_hcd *hcd ) 
{ 

  {
#line 432
  return ((struct uhci_hcd *)(hcd->hcd_priv));
}
}
#line 434 "uhci-hcd.h"
__inline static struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci ) 
{ unsigned long (*__mptr)[0] ;

  {
  {
#line 436
  __mptr = (unsigned long (*)[0])((void *)uhci);
  }
#line 436
  return ((struct usb_hcd *)((char *)__mptr - (unsigned int )(& ((struct usb_hcd *)0)->hcd_priv)));
}
}
#line 4 "pci-quirks.h"
extern void uhci_reset_hc(struct pci_dev *pdev , unsigned long base ) ;
#line 5
extern int uhci_check_and_reset_hc(struct pci_dev *pdev , unsigned long base ) ;
#line 62 "uhci-hcd.c"
static int ignore_oc  ;
#line 63 "uhci-hcd.c"
__inline static int *__check_ignore_oc(void) 
{ 

  {
#line 63
  return (& ignore_oc);
}
}
#line 63 "uhci-hcd.c"
static int __param_perm_check_ignore_oc  __attribute__((__unused__))  =    (int )((sizeof(char [1]) - 1UL) + (sizeof(char [1]) - 1UL));
#line 63 "uhci-hcd.c"
static char const   __param_str_ignore_oc[21]  = 
#line 63
  {      (char const   )'S',      (char const   )'o',      (char const   )'m',      (char const   )'e', 
        (char const   )'M',      (char const   )'o',      (char const   )'d',      (char const   )'u', 
        (char const   )'l',      (char const   )'e',      (char const   )'.',      (char const   )'i', 
        (char const   )'g',      (char const   )'n',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )'_',      (char const   )'o',      (char const   )'c', 
        (char const   )'\000'};
#line 63 "uhci-hcd.c"
static struct kernel_param  const  __param_ignore_oc  __attribute__((__unused__, __section__("__param"),
__aligned__(sizeof(void *))))  =    {__param_str_ignore_oc, 292U, & param_set_bool, & param_get_bool, {(void *)(& ignore_oc)}};
#line 84 "uhci-hcd.c"
static char *errbuf  ;
#line 87 "uhci-hcd.c"
static struct kmem_cache *uhci_up_cachep  ;
#line 89
static void suspend_rh(struct uhci_hcd *uhci , enum uhci_rh_state new_state ) ;
#line 90
static void wakeup_rh(struct uhci_hcd *uhci ) ;
#line 91
static void uhci_get_current_frame_number(struct uhci_hcd *uhci ) ;
#line 96 "uhci-hcd.c"
static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci , int frame ) 
{ int skelnum ;
  unsigned long tmp ;

  {
  {
#line 115
  tmp = __ffs((unsigned long )(frame | 1024));
#line 115
  skelnum = 8 - (int )tmp;
  }
#line 116
  if (skelnum <= 1) {
    {
#line 117
    skelnum = 9;
    }
  }
#line 118
  return (2U | (uhci->skelqh[skelnum])->dma_handle);
}
}
#line 20 "uhci-debug.c"
static struct dentry *uhci_debugfs_root  ;
#line 579 "uhci-debug.c"
__inline static void lprintk(char *buf ) 
{ 

  {
#line 580
  return;
}
}
#line 582 "uhci-debug.c"
__inline static int uhci_show_qh(struct uhci_hcd *uhci , struct uhci_qh *qh , char *buf ,
                                 int len , int space ) 
{ 

  {
#line 585
  return (0);
}
}
#line 588 "uhci-debug.c"
__inline static int uhci_sprint_schedule(struct uhci_hcd *uhci , char *buf , int len ) 
{ 

  {
#line 591
  return (0);
}
}
#line 28 "uhci-q.c"
static void uhci_set_next_interrupt(struct uhci_hcd *uhci ) 
{ struct usb_hcd *tmp ;

  {
#line 30
  if (uhci->is_stopped) {
    {
#line 31
    tmp = uhci_to_hcd(uhci);
#line 31
    mod_timer(& tmp->rh_timer, (unsigned long )jiffies);
    }
  }
  {
#line 32
  (uhci->term_td)->status |= (unsigned int )(1 << 24);
  }
#line 33
  return;
}
}
#line 35 "uhci-q.c"
__inline static void uhci_clear_next_interrupt(struct uhci_hcd *uhci ) 
{ 

  {
  {
#line 37
  (uhci->term_td)->status &= ~ ((unsigned int )(1 << 24));
  }
#line 38
  return;
}
}
#line 46 "uhci-q.c"
static void uhci_fsbr_on(struct uhci_hcd *uhci ) 
{ struct uhci_qh *lqh ;
  struct list_head  const  *__mptr ;

  {
  {
#line 53
  uhci->fsbr_is_on = 1U;
#line 54
  __mptr = (struct list_head  const  *)(uhci->skelqh[9])->node.prev;
#line 54
  lqh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
#line 56
  lqh->link = 2U | (uhci->skelqh[10])->dma_handle;
  }
#line 57
  return;
}
}
#line 59 "uhci-q.c"
static void uhci_fsbr_off(struct uhci_hcd *uhci ) 
{ struct uhci_qh *lqh ;
  struct list_head  const  *__mptr ;

  {
  {
#line 65
  uhci->fsbr_is_on = 0U;
#line 66
  __mptr = (struct list_head  const  *)(uhci->skelqh[9])->node.prev;
#line 66
  lqh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
#line 68
  lqh->link = 1U;
  }
#line 69
  return;
}
}
#line 71 "uhci-q.c"
static void uhci_add_fsbr(struct uhci_hcd *uhci , struct urb *urb ) 
{ struct urb_priv *urbp ;

  {
  {
#line 73
  urbp = (struct urb_priv *)urb->hcpriv;
  }
#line 75
  if (! (urb->transfer_flags & 32U)) {
    {
#line 76
    urbp->fsbr = 1U;
    }
  }
#line 77
  return;
}
}
#line 79 "uhci-q.c"
static void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci , struct urb_priv *urbp ) 
{ 

  {
#line 81
  if (urbp->fsbr) {
    {
#line 82
    uhci->fsbr_is_wanted = 1U;
    }
#line 83
    if (! uhci->fsbr_is_on) {
      {
#line 84
      uhci_fsbr_on(uhci);
      }
    } else {
#line 85
      if (uhci->fsbr_expiring) {
        {
#line 86
        uhci->fsbr_expiring = 0U;
#line 87
        del_timer(& uhci->fsbr_timer);
        }
      }
    }
  }
#line 90
  return;
}
}
#line 92 "uhci-q.c"
static void uhci_fsbr_timeout(unsigned long _uhci ) 
{ struct uhci_hcd *uhci ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
#line 94
  uhci = (struct uhci_hcd *)_uhci;
  }
  {
#line 97
  while (1) {
    while_246_continue: /* CIL Label */ ;
    {
#line 97
    flags = _spin_lock_irqsave(& uhci->lock);
    }
    goto while_246_break;
  }
  while_246_break: /* CIL Label */ ;
  }
#line 98
  if (uhci->fsbr_expiring) {
    {
#line 99
    uhci->fsbr_expiring = 0U;
#line 100
    uhci_fsbr_off(uhci);
    }
  }
  {
#line 102
  while (1) {
    while_247_continue: /* CIL Label */ ;
    {
#line 102
    _spin_unlock_irqrestore(& uhci->lock, flags);
    }
    goto while_247_break;
  }
  while_247_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 106 "uhci-q.c"
static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci ) 
{ dma_addr_t dma_handle ;
  struct uhci_td *td ;
  void *tmp ;

  {
  {
#line 111
  tmp = dma_pool_alloc(uhci->td_pool, 32U, & dma_handle);
#line 111
  td = (struct uhci_td *)tmp;
  }
#line 112
  if (! td) {
#line 113
    return ((struct uhci_td *)((void *)0));
  }
  {
#line 115
  td->dma_handle = dma_handle;
#line 116
  td->frame = -1;
#line 118
  INIT_LIST_HEAD(& td->list);
#line 119
  INIT_LIST_HEAD(& td->fl_list);
  }
#line 121
  return (td);
}
}
#line 124 "uhci-q.c"
static void uhci_free_td(struct uhci_hcd *uhci , struct uhci_td *td ) 
{ int __ret_warn_on ;
  struct usb_hcd *tmp ;
  char const   *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int __ret_warn_on___0 ;
  struct usb_hcd *tmp___3 ;
  char const   *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 126
  tmp___2 = list_empty((struct list_head  const  *)(& td->list));
  }
#line 126
  if (! tmp___2) {
    {
#line 127
    __ret_warn_on = 1;
#line 127
    tmp___1 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 127
    if (tmp___1) {
      {
#line 127
      tmp = uhci_to_hcd(uhci);
#line 127
      tmp___0 = dev_driver_string((struct device  const  *)tmp->self.controller);
#line 127
      warn_slowpath_fmt("uhci-q.c", 127, "Device: %s\ntd %p still in list!\n", tmp___0,
                        td);
      }
    }
    {
#line 127
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
  }
  {
#line 128
  tmp___6 = list_empty((struct list_head  const  *)(& td->fl_list));
  }
#line 128
  if (! tmp___6) {
    {
#line 129
    __ret_warn_on___0 = 1;
#line 129
    tmp___5 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
#line 129
    if (tmp___5) {
      {
#line 129
      tmp___3 = uhci_to_hcd(uhci);
#line 129
      tmp___4 = dev_driver_string((struct device  const  *)tmp___3->self.controller);
#line 129
      warn_slowpath_fmt("uhci-q.c", 129, "Device: %s\ntd %p still in fl_list!\n",
                        tmp___4, td);
      }
    }
    {
#line 129
    __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
  }
  {
#line 131
  dma_pool_free(uhci->td_pool, (void *)td, td->dma_handle);
  }
#line 132
  return;
}
}
#line 134 "uhci-q.c"
__inline static void uhci_fill_td(struct uhci_td *td , u32 status , u32 token , u32 buffer ) 
{ 

  {
  {
#line 137
  td->status = status;
#line 138
  td->token = token;
#line 139
  td->buffer = buffer;
  }
#line 140
  return;
}
}
#line 142 "uhci-q.c"
static void uhci_add_td_to_urbp(struct uhci_td *td , struct urb_priv *urbp ) 
{ 

  {
  {
#line 144
  list_add_tail(& td->list, & urbp->td_list);
  }
#line 145
  return;
}
}
#line 147 "uhci-q.c"
static void uhci_remove_td_from_urbp(struct uhci_td *td ) 
{ 

  {
  {
#line 149
  list_del_init(& td->list);
  }
#line 150
  return;
}
}
#line 155 "uhci-q.c"
__inline static void uhci_insert_td_in_frame_list(struct uhci_hcd *uhci , struct uhci_td *td ,
                                                  unsigned int framenum ) 
{ struct uhci_td *ftd ;
  struct uhci_td *ltd ;
  struct list_head  const  *__mptr ;

  {
  {
#line 158
  framenum &= 1023U;
#line 160
  td->frame = (int )framenum;
  }
#line 163
  if (*(uhci->frame_cpu + framenum)) {
    {
#line 166
    ftd = (struct uhci_td *)*(uhci->frame_cpu + framenum);
#line 167
    __mptr = (struct list_head  const  *)ftd->fl_list.prev;
#line 167
    ltd = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->fl_list));
#line 169
    list_add_tail(& td->fl_list, & ftd->fl_list);
#line 171
    td->link = ltd->link;
#line 172
    __asm__  volatile   ("661:\n\t"
                         "lock; addl $0,0(%%esp)"
                         "\n662:\n"
                         ".section .altinstructions,\"a\"\n"
                         " "
                         ".balign 4"
                         " "
                         "\n"
                         " "
                         ".long"
                         " "
                         "661b\n"
                         " "
                         ".long"
                         " "
                         "663f\n"
                         "\t .byte %c0\n"
                         "\t .byte 662b-661b\n"
                         "\t .byte 664f-663f\n"
                         ".previous\n"
                         ".section .altinstr_replacement,\"ax\"\n"
                         "663:\n\t"
                         "sfence"
                         "\n664:\n"
                         ".previous": : "i" (25): "memory");
#line 173
    ltd->link = td->dma_handle;
    }
  } else {
    {
#line 175
    td->link = *(uhci->frame + framenum);
#line 176
    __asm__  volatile   ("661:\n\t"
                         "lock; addl $0,0(%%esp)"
                         "\n662:\n"
                         ".section .altinstructions,\"a\"\n"
                         " "
                         ".balign 4"
                         " "
                         "\n"
                         " "
                         ".long"
                         " "
                         "661b\n"
                         " "
                         ".long"
                         " "
                         "663f\n"
                         "\t .byte %c0\n"
                         "\t .byte 662b-661b\n"
                         "\t .byte 664f-663f\n"
                         ".previous\n"
                         ".section .altinstr_replacement,\"ax\"\n"
                         "663:\n\t"
                         "sfence"
                         "\n664:\n"
                         ".previous": : "i" (25): "memory");
#line 177
    *(uhci->frame + framenum) = td->dma_handle;
#line 178
    *(uhci->frame_cpu + framenum) = (void *)td;
    }
  }
#line 180
  return;
}
}
#line 182 "uhci-q.c"
__inline static void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci , struct uhci_td *td ) 
{ int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct uhci_td *ntd ;
  struct list_head  const  *__mptr ;
  int tmp___2 ;
  struct uhci_td *ptd ;
  struct list_head  const  *__mptr___0 ;

  {
#line 186
  if (td->frame == -1) {
    {
#line 187
    tmp = list_empty((struct list_head  const  *)(& td->fl_list));
    }
#line 187
    if (tmp) {
      {
#line 187
      tmp___0 = 0;
      }
    } else {
      {
#line 187
      tmp___0 = 1;
      }
    }
    {
#line 187
    __ret_warn_on = tmp___0;
#line 187
    tmp___1 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 187
    if (tmp___1) {
      {
#line 187
      warn_slowpath_null("uhci-q.c", 187);
      }
    }
    {
#line 187
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 188
    return;
  }
#line 191
  if ((unsigned long )*(uhci->frame_cpu + td->frame) == (unsigned long )td) {
    {
#line 192
    tmp___2 = list_empty((struct list_head  const  *)(& td->fl_list));
    }
#line 192
    if (tmp___2) {
      {
#line 193
      *(uhci->frame + td->frame) = td->link;
#line 194
      *(uhci->frame_cpu + td->frame) = (void *)0;
      }
    } else {
      {
#line 198
      __mptr = (struct list_head  const  *)td->fl_list.next;
#line 198
      ntd = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->fl_list));
#line 199
      *(uhci->frame + td->frame) = ntd->dma_handle;
#line 200
      *(uhci->frame_cpu + td->frame) = (void *)ntd;
      }
    }
  } else {
    {
#line 205
    __mptr___0 = (struct list_head  const  *)td->fl_list.prev;
#line 205
    ptd = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->fl_list));
#line 206
    ptd->link = td->link;
    }
  }
  {
#line 209
  list_del_init(& td->fl_list);
#line 210
  td->frame = -1;
  }
#line 211
  return;
}
}
#line 213 "uhci-q.c"
__inline static void uhci_remove_tds_from_frame(struct uhci_hcd *uhci , unsigned int framenum ) 
{ struct uhci_td *ftd ;
  struct uhci_td *ltd ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  {
#line 218
  framenum &= 1023U;
#line 220
  ftd = (struct uhci_td *)*(uhci->frame_cpu + framenum);
  }
#line 221
  if (ftd) {
    {
#line 222
    __mptr = (struct list_head  const  *)ftd->fl_list.prev;
#line 222
    ltd = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->fl_list));
#line 223
    *(uhci->frame + framenum) = ltd->link;
#line 224
    *(uhci->frame_cpu + framenum) = (void *)0;
    }
    {
#line 226
    while (1) {
      while_248_continue: /* CIL Label */ ;
      {
#line 226
      tmp = list_empty((struct list_head  const  *)(& ftd->fl_list));
      }
#line 226
      if (tmp) {
        goto while_248_break;
      }
      {
#line 227
      list_del_init(ftd->fl_list.prev);
      }
    }
    while_248_break: /* CIL Label */ ;
    }
  }
#line 229
  return;
}
}
#line 234 "uhci-q.c"
static void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci , struct urb *urb ) 
{ struct urb_priv *urbp ;
  struct uhci_td *td ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 236
  urbp = (struct urb_priv *)urb->hcpriv;
#line 239
  __mptr = (struct list_head  const  *)urbp->td_list.next;
#line 239
  td = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->list));
  }
  {
#line 239
  while (1) {
    while_249_continue: /* CIL Label */ ;
    {
#line 239
    prefetch((void const   *)td->list.next);
    }
#line 239
    if (! ((unsigned long )(& td->list) != (unsigned long )(& urbp->td_list))) {
      goto while_249_break;
    }
    {
#line 240
    uhci_remove_td_from_frame_list(uhci, td);
#line 239
    __mptr___0 = (struct list_head  const  *)td->list.next;
#line 239
    td = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
    }
  }
  while_249_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 243 "uhci-q.c"
static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci , struct usb_device *udev ,
                                     struct usb_host_endpoint *hep ) 
{ dma_addr_t dma_handle ;
  struct uhci_qh *qh ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 249
  tmp = dma_pool_alloc(uhci->qh_pool, 32U, & dma_handle);
#line 249
  qh = (struct uhci_qh *)tmp;
  }
#line 250
  if (! qh) {
#line 251
    return ((struct uhci_qh *)((void *)0));
  }
  {
#line 253
  __constant_c_and_count_memset((void *)qh, 0UL, (unsigned int )sizeof(*qh));
#line 254
  qh->dma_handle = dma_handle;
#line 256
  qh->element = 1U;
#line 257
  qh->link = 1U;
#line 259
  INIT_LIST_HEAD(& qh->queue);
#line 260
  INIT_LIST_HEAD(& qh->node);
  }
#line 262
  if (udev) {
    {
#line 263
    qh->type = (int )hep->desc.bmAttributes & 3;
    }
#line 264
    if (qh->type != 1) {
      {
#line 265
      qh->dummy_td = uhci_alloc_td(uhci);
      }
#line 266
      if (! qh->dummy_td) {
        {
#line 267
        dma_pool_free(uhci->qh_pool, (void *)qh, dma_handle);
        }
#line 268
        return ((struct uhci_qh *)((void *)0));
      }
    }
    {
#line 271
    qh->state = 1;
#line 272
    qh->hep = hep;
#line 273
    qh->udev = udev;
#line 274
    hep->hcpriv = (void *)qh;
    }
#line 276
    if (qh->type == 3) {
      {
#line 278
      tmp___0 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)(& hep->desc));
#line 278
      tmp___1 = usb_calc_bus_time((int )udev->speed, tmp___0, qh->type == 1, (int )hep->desc.wMaxPacketSize);
#line 278
      qh->load = (short )(tmp___1 / 1000L + 1L);
      }
    } else {
#line 276
      if (qh->type == 1) {
        {
#line 278
        tmp___0 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)(& hep->desc));
#line 278
        tmp___1 = usb_calc_bus_time((int )udev->speed, tmp___0, qh->type == 1, (int )hep->desc.wMaxPacketSize);
#line 278
        qh->load = (short )(tmp___1 / 1000L + 1L);
        }
      }
    }
  } else {
    {
#line 285
    qh->state = 3;
#line 286
    qh->type = -1;
    }
  }
#line 288
  return (qh);
}
}
#line 291 "uhci-q.c"
static void uhci_free_qh(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  struct usb_hcd *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 293
  if (qh->state != 1) {
#line 293
    if (qh->udev) {
      {
#line 293
      tmp = 1;
      }
    } else {
      {
#line 293
      tmp = 0;
      }
    }
  } else {
    {
#line 293
    tmp = 0;
    }
  }
  {
#line 293
  __ret_warn_on = tmp;
#line 293
  tmp___0 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 293
  if (tmp___0) {
    {
#line 293
    warn_slowpath_null("uhci-q.c", 293);
    }
  }
  {
#line 293
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 294
  tmp___4 = list_empty((struct list_head  const  *)(& qh->queue));
  }
#line 294
  if (! tmp___4) {
    {
#line 295
    __ret_warn_on___0 = 1;
#line 295
    tmp___3 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
#line 295
    if (tmp___3) {
      {
#line 295
      tmp___1 = uhci_to_hcd(uhci);
#line 295
      tmp___2 = dev_driver_string((struct device  const  *)tmp___1->self.controller);
#line 295
      warn_slowpath_fmt("uhci-q.c", 295, "Device: %s\nqh %p list not empty!\n", tmp___2,
                        qh);
      }
    }
    {
#line 295
    __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
  }
  {
#line 297
  list_del(& qh->node);
  }
#line 298
  if (qh->udev) {
    {
#line 299
    (qh->hep)->hcpriv = (void *)0;
    }
#line 300
    if (qh->dummy_td) {
      {
#line 301
      uhci_free_td(uhci, qh->dummy_td);
      }
    }
  }
  {
#line 303
  dma_pool_free(uhci->qh_pool, (void *)qh, qh->dma_handle);
  }
#line 304
  return;
}
}
#line 313 "uhci-q.c"
static int uhci_cleanup_queue(struct uhci_hcd *uhci , struct uhci_qh *qh , struct urb *urb ) 
{ struct urb_priv *urbp ;
  struct uhci_td *td ;
  int ret ;
  struct urb_priv *purbp ;
  struct uhci_td *ptd ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  __le32 tmp___2 ;
  int __ret_warn_on___0 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  struct list_head  const  *__mptr___2 ;

  {
  {
#line 316
  urbp = (struct urb_priv *)urb->hcpriv;
#line 318
  ret = 1;
  }
#line 324
  if (qh->type == 1) {
    {
#line 325
    ret = uhci->frame_number + uhci->is_stopped != qh->unlink_frame;
    }
    goto done;
  }
#line 333
  if ((unsigned long )qh->queue.next != (unsigned long )(& urbp->node)) {
    {
#line 337
    __mptr = (struct list_head  const  *)urbp->node.prev;
#line 337
    purbp = (struct urb_priv *)((char *)__mptr - (unsigned int )(& ((struct urb_priv *)0)->node));
#line 338
    tmp = list_empty((struct list_head  const  *)(& purbp->td_list));
    }
#line 338
    if (tmp) {
      {
#line 338
      tmp___0 = 1;
      }
    } else {
      {
#line 338
      tmp___0 = 0;
      }
    }
    {
#line 338
    __ret_warn_on = tmp___0;
#line 338
    tmp___1 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 338
    if (tmp___1) {
      {
#line 338
      warn_slowpath_null("uhci-q.c", 338);
      }
    }
    {
#line 338
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 339
    __mptr___0 = (struct list_head  const  *)purbp->td_list.prev;
#line 339
    ptd = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 341
    __mptr___1 = (struct list_head  const  *)urbp->td_list.prev;
#line 341
    td = (struct uhci_td *)((char *)__mptr___1 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 343
    ptd->link = td->link;
    }
    goto done;
  }
  {
#line 349
  tmp___2 = qh_element(qh);
  }
#line 349
  if (tmp___2 == 1U) {
    goto done;
  }
  {
#line 351
  qh->element = 1U;
  }
#line 354
  if (qh->type == 0) {
    goto done;
  }
  {
#line 358
  tmp___3 = list_empty((struct list_head  const  *)(& urbp->td_list));
  }
#line 358
  if (tmp___3) {
    {
#line 358
    tmp___4 = 1;
    }
  } else {
    {
#line 358
    tmp___4 = 0;
    }
  }
  {
#line 358
  __ret_warn_on___0 = tmp___4;
#line 358
  tmp___5 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
  }
#line 358
  if (tmp___5) {
    {
#line 358
    warn_slowpath_null("uhci-q.c", 358);
    }
  }
  {
#line 358
  __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
#line 359
  __mptr___2 = (struct list_head  const  *)urbp->td_list.next;
#line 359
  td = (struct uhci_td *)((char *)__mptr___2 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 360
  qh->needs_fixup = 1U;
#line 361
  qh->initial_toggle = (td->token >> 19) & 1U;
  }
  done: 
#line 364
  return (ret);
}
}
#line 371 "uhci-q.c"
static void uhci_fixup_toggles(struct uhci_qh *qh , int skip_first ) 
{ struct urb_priv *urbp ;
  struct uhci_td *td ;
  unsigned int toggle ;
  unsigned int pipe ;
  struct list_head  const  *__mptr ;
  __le32 tmp ;
  struct list_head  const  *__mptr___0 ;
  struct urb_priv *tmp___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  struct list_head  const  *__mptr___7 ;

  {
  {
#line 373
  urbp = (struct urb_priv *)((void *)0);
#line 375
  toggle = qh->initial_toggle;
  }
#line 380
  if (skip_first) {
    {
#line 381
    __mptr = (struct list_head  const  *)qh->queue.next;
#line 381
    urbp = (struct urb_priv *)((char *)__mptr - (unsigned int )(& ((struct urb_priv *)0)->node));
    }
  } else {
    {
#line 385
    tmp = qh_element(qh);
    }
#line 385
    if (tmp != 1U) {
      {
#line 386
      toggle = 2U;
      }
    }
  }
  {
#line 391
  tmp___0 = urbp;
  }
#line 391
  if (! tmp___0) {
    {
#line 391
    __mptr___0 = (struct list_head  const  *)(& qh->queue);
#line 391
    tmp___0 = (struct urb_priv *)((char *)__mptr___0 - (unsigned int )(& ((struct urb_priv *)0)->node));
    }
  }
  {
#line 391
  urbp = tmp___0;
#line 392
  __mptr___1 = (struct list_head  const  *)urbp->node.next;
#line 392
  urbp = (struct urb_priv *)((char *)__mptr___1 - (unsigned int )(& ((struct urb_priv *)0)->node));
  }
  {
#line 392
  while (1) {
    while_250_continue: /* CIL Label */ ;
    {
#line 392
    prefetch((void const   *)urbp->node.next);
    }
#line 392
    if (! ((unsigned long )(& urbp->node) != (unsigned long )(& qh->queue))) {
      goto while_250_break;
    }
    {
#line 396
    __mptr___3 = (struct list_head  const  *)urbp->td_list.next;
#line 396
    td = (struct uhci_td *)((char *)__mptr___3 - (unsigned int )(& ((struct uhci_td *)0)->list));
    }
#line 397
    if (toggle > 1U) {
      {
#line 398
      __mptr___4 = (struct list_head  const  *)urbp->td_list.prev;
#line 398
      td = (struct uhci_td *)((char *)__mptr___4 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 400
      toggle = ((td->token >> 19) & 1U) ^ 1U;
      }
    } else {
#line 397
      if (((td->token >> 19) & 1U) == toggle) {
        {
#line 398
        __mptr___4 = (struct list_head  const  *)urbp->td_list.prev;
#line 398
        td = (struct uhci_td *)((char *)__mptr___4 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 400
        toggle = ((td->token >> 19) & 1U) ^ 1U;
        }
      } else {
        {
#line 404
        __mptr___5 = (struct list_head  const  *)urbp->td_list.next;
#line 404
        td = (struct uhci_td *)((char *)__mptr___5 - (unsigned int )(& ((struct uhci_td *)0)->list));
        }
        {
#line 404
        while (1) {
          while_251_continue: /* CIL Label */ ;
          {
#line 404
          prefetch((void const   *)td->list.next);
          }
#line 404
          if (! ((unsigned long )(& td->list) != (unsigned long )(& urbp->td_list))) {
            goto while_251_break;
          }
          {
#line 405
          td->token ^= (unsigned int )(1 << 19);
#line 407
          toggle ^= 1U;
#line 404
          __mptr___6 = (struct list_head  const  *)td->list.next;
#line 404
          td = (struct uhci_td *)((char *)__mptr___6 - (unsigned int )(& ((struct uhci_td *)0)->list));
          }
        }
        while_251_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 392
    __mptr___2 = (struct list_head  const  *)urbp->node.next;
#line 392
    urbp = (struct urb_priv *)((char *)__mptr___2 - (unsigned int )(& ((struct urb_priv *)0)->node));
    }
  }
  while_250_break: /* CIL Label */ ;
  }
  {
#line 412
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "sfence"
                       "\n664:\n"
                       ".previous": : "i" (25): "memory");
#line 413
  __mptr___7 = (struct list_head  const  *)qh->queue.next;
#line 413
  pipe = (((struct urb_priv *)((char *)__mptr___7 - (unsigned int )(& ((struct urb_priv *)0)->node)))->urb)->pipe;
#line 414
  (qh->udev)->toggle[! (pipe & 128U)] = ((qh->udev)->toggle[! (pipe & 128U)] & (unsigned int )(~ (1 << ((pipe >> 15) & 15U)))) | (toggle << ((pipe >> 15) & 15U));
#line 416
  qh->needs_fixup = 0U;
  }
#line 417
  return;
}
}
#line 422 "uhci-q.c"
__inline static void link_iso(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ 

  {
  {
#line 424
  list_add_tail(& qh->node, & (uhci->skelqh[1])->node);
  }
#line 427
  return;
}
}
#line 433 "uhci-q.c"
static void link_interrupt(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ struct uhci_qh *pqh ;
  struct list_head  const  *__mptr ;

  {
  {
#line 437
  list_add_tail(& qh->node, & (uhci->skelqh[qh->skel])->node);
#line 439
  __mptr = (struct list_head  const  *)qh->node.prev;
#line 439
  pqh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
#line 440
  qh->link = pqh->link;
#line 441
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "sfence"
                       "\n664:\n"
                       ".previous": : "i" (25): "memory");
#line 442
  pqh->link = 2U | qh->dma_handle;
  }
#line 443
  return;
}
}
#line 449 "uhci-q.c"
static void link_async(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ struct uhci_qh *pqh ;
  __le32 link_to_new_qh ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 457
  __mptr = (struct list_head  const  *)(uhci->skelqh[9])->node.prev;
#line 457
  pqh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
  }
  {
#line 457
  while (1) {
    while_252_continue: /* CIL Label */ ;
    {
#line 457
    prefetch((void const   *)pqh->node.prev);
    }
#line 457
    if (! ((unsigned long )(& pqh->node) != (unsigned long )(& (uhci->skelqh[9])->node))) {
      goto while_252_break;
    }
#line 458
    if (pqh->skel <= qh->skel) {
      goto while_252_break;
    }
    {
#line 457
    __mptr___0 = (struct list_head  const  *)pqh->node.prev;
#line 457
    pqh = (struct uhci_qh *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_qh *)0)->node));
    }
  }
  while_252_break: /* CIL Label */ ;
  }
  {
#line 461
  list_add(& qh->node, & pqh->node);
#line 464
  qh->link = pqh->link;
#line 465
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "sfence"
                       "\n664:\n"
                       ".previous": : "i" (25): "memory");
#line 466
  link_to_new_qh = 2U | qh->dma_handle;
#line 467
  pqh->link = link_to_new_qh;
  }
#line 471
  if (pqh->skel < 21) {
#line 471
    if (qh->skel >= 21) {
      {
#line 472
      (uhci->skelqh[10])->link = link_to_new_qh;
      }
    }
  }
#line 473
  return;
}
}
#line 478 "uhci-q.c"
static void uhci_activate_qh(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct urb_priv *urbp ;
  struct list_head  const  *__mptr ;
  struct uhci_td *td ;
  struct list_head  const  *__mptr___0 ;
  __le32 tmp___2 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
#line 480
  tmp = list_empty((struct list_head  const  *)(& qh->queue));
  }
#line 480
  if (tmp) {
    {
#line 480
    tmp___0 = 1;
    }
  } else {
    {
#line 480
    tmp___0 = 0;
    }
  }
  {
#line 480
  __ret_warn_on = tmp___0;
#line 480
  tmp___1 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 480
  if (tmp___1) {
    {
#line 480
    warn_slowpath_null("uhci-q.c", 480);
    }
  }
  {
#line 480
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 484
  tmp___2 = qh_element(qh);
  }
#line 484
  if (tmp___2 == 1U) {
    {
#line 485
    __mptr = (struct list_head  const  *)qh->queue.next;
#line 485
    urbp = (struct urb_priv *)((char *)__mptr - (unsigned int )(& ((struct urb_priv *)0)->node));
#line 487
    __mptr___0 = (struct list_head  const  *)urbp->td_list.next;
#line 487
    td = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 490
    qh->element = td->dma_handle;
    }
  }
  {
#line 494
  qh->wait_expired = 0U;
#line 495
  qh->advance_jiffies = (unsigned long )jiffies;
  }
#line 497
  if (qh->state == 3) {
#line 498
    return;
  }
  {
#line 499
  qh->state = 3;
  }
#line 503
  if ((unsigned long )qh == (unsigned long )uhci->next_qh) {
    {
#line 504
    __mptr___1 = (struct list_head  const  *)qh->node.next;
#line 504
    uhci->next_qh = (struct uhci_qh *)((char *)__mptr___1 - (unsigned int )(& ((struct uhci_qh *)0)->node));
    }
  }
  {
#line 506
  list_del(& qh->node);
  }
#line 508
  if (qh->skel == 1) {
    {
#line 509
    link_iso(uhci, qh);
    }
  } else {
#line 510
    if (qh->skel < 9) {
      {
#line 511
      link_interrupt(uhci, qh);
      }
    } else {
      {
#line 513
      link_async(uhci, qh);
      }
    }
  }
#line 514
  return;
}
}
#line 519 "uhci-q.c"
static void unlink_interrupt(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ struct uhci_qh *pqh ;
  struct list_head  const  *__mptr ;

  {
  {
#line 523
  __mptr = (struct list_head  const  *)qh->node.prev;
#line 523
  pqh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
#line 524
  pqh->link = qh->link;
#line 525
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
#line 526
  return;
}
}
#line 531 "uhci-q.c"
static void unlink_async(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ struct uhci_qh *pqh ;
  __le32 link_to_next_qh ;
  struct list_head  const  *__mptr ;

  {
  {
#line 534
  link_to_next_qh = qh->link;
#line 536
  __mptr = (struct list_head  const  *)qh->node.prev;
#line 536
  pqh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
#line 537
  pqh->link = link_to_next_qh;
  }
#line 541
  if (pqh->skel < 21) {
#line 541
    if (qh->skel >= 21) {
      {
#line 542
      (uhci->skelqh[10])->link = link_to_next_qh;
      }
    }
  }
  {
#line 543
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
#line 544
  return;
}
}
#line 549 "uhci-q.c"
static void uhci_unlink_qh(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;

  {
#line 551
  if (qh->state == 2) {
#line 552
    return;
  }
#line 553
  if (qh->state != 3) {
    {
#line 553
    tmp = 1;
    }
  } else {
#line 553
    if (! qh->udev) {
      {
#line 553
      tmp = 1;
      }
    } else {
      {
#line 553
      tmp = 0;
      }
    }
  }
  {
#line 553
  __ret_warn_on = tmp;
#line 553
  tmp___0 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 553
  if (tmp___0) {
    {
#line 553
    warn_slowpath_null("uhci-q.c", 553);
    }
  }
  {
#line 553
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 554
  qh->state = 2;
  }
#line 557
  if (! (qh->skel == 1)) {
#line 559
    if (qh->skel < 9) {
      {
#line 560
      unlink_interrupt(uhci, qh);
      }
    } else {
      {
#line 562
      unlink_async(uhci, qh);
      }
    }
  }
  {
#line 564
  uhci_get_current_frame_number(uhci);
#line 565
  qh->unlink_frame = uhci->frame_number;
#line 568
  tmp___1 = list_empty((struct list_head  const  *)(& (uhci->skelqh[0])->node));
  }
#line 568
  if (tmp___1) {
    {
#line 569
    uhci_set_next_interrupt(uhci);
    }
  }
#line 572
  if ((unsigned long )qh == (unsigned long )uhci->next_qh) {
    {
#line 573
    __mptr = (struct list_head  const  *)qh->node.next;
#line 573
    uhci->next_qh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
    }
  }
  {
#line 575
  list_move_tail(& qh->node, & (uhci->skelqh[0])->node);
  }
#line 576
  return;
}
}
#line 584 "uhci-q.c"
static void uhci_make_qh_idle(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ int __ret_warn_on ;
  long tmp ;
  struct list_head  const  *__mptr ;

  {
  {
#line 586
  __ret_warn_on = ! (! (qh->state == 3));
#line 586
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 586
  if (tmp) {
    {
#line 586
    warn_slowpath_null("uhci-q.c", 586);
    }
  }
  {
#line 586
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
#line 588
  if ((unsigned long )qh == (unsigned long )uhci->next_qh) {
    {
#line 589
    __mptr = (struct list_head  const  *)qh->node.next;
#line 589
    uhci->next_qh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
    }
  }
  {
#line 591
  list_move(& qh->node, & uhci->idle_qh_list);
#line 592
  qh->state = 1;
  }
#line 595
  if (qh->post_td) {
    {
#line 596
    uhci_free_td(uhci, qh->post_td);
#line 597
    qh->post_td = (struct uhci_td *)((void *)0);
    }
  }
#line 601
  if (uhci->num_waiting) {
    {
#line 602
    __wake_up(& uhci->waitqh, 3U, 0, (void *)0);
    }
  }
#line 603
  return;
}
}
#line 608 "uhci-q.c"
static int uhci_highest_load(struct uhci_hcd *uhci , int phase , int period ) 
{ int highest_load ;
  int __max1 ;
  int __max2 ;
  int tmp ;

  {
  {
#line 610
  highest_load = (int )uhci->load[phase];
#line 612
  phase += period;
  }
  {
#line 612
  while (1) {
    while_253_continue: /* CIL Label */ ;
#line 612
    if (! (phase < 32)) {
      goto while_253_break;
    }
    {
#line 613
    __max1 = highest_load;
#line 613
    __max2 = (int )uhci->load[phase];
    }
#line 613
    if (__max1 > __max2) {
      {
#line 613
      tmp = __max1;
      }
    } else {
      {
#line 613
      tmp = __max2;
      }
    }
    {
#line 613
    highest_load = tmp;
#line 612
    phase += period;
    }
  }
  while_253_break: /* CIL Label */ ;
  }
#line 614
  return (highest_load);
}
}
#line 621 "uhci-q.c"
static int uhci_check_bandwidth(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ int minimax_load ;
  int phase ;
  int load ;
  int max_phase ;
  int __min1 ;
  int __min2 ;
  int tmp ;
  struct usb_hcd *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 627
  if ((int )qh->phase >= 0) {
    {
#line 628
    minimax_load = uhci_highest_load(uhci, (int )qh->phase, (int )qh->period);
    }
  } else {
    {
#line 631
    __min1 = 32;
#line 631
    __min2 = (int )qh->period;
    }
#line 631
    if (__min1 < __min2) {
      {
#line 631
      tmp = __min1;
      }
    } else {
      {
#line 631
      tmp = __min2;
      }
    }
    {
#line 631
    max_phase = tmp;
#line 633
    qh->phase = (short)0;
#line 634
    minimax_load = uhci_highest_load(uhci, (int )qh->phase, (int )qh->period);
#line 635
    phase = 1;
    }
    {
#line 635
    while (1) {
      while_254_continue: /* CIL Label */ ;
#line 635
      if (! (phase < max_phase)) {
        goto while_254_break;
      }
      {
#line 636
      load = uhci_highest_load(uhci, phase, (int )qh->period);
      }
#line 637
      if (load < minimax_load) {
        {
#line 638
        minimax_load = load;
#line 639
        qh->phase = (short )phase;
        }
      }
      {
#line 635
      phase ++;
      }
    }
    while_254_break: /* CIL Label */ ;
    }
  }
#line 645
  if (minimax_load + (int )qh->load > 900) {
#line 649
    return (-28);
  }
#line 651
  return (0);
}
}
#line 657 "uhci-q.c"
static void uhci_reserve_bandwidth(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ int i ;
  int load ;
  char *p ;
  struct usb_hcd *tmp ;
  struct usb_hcd *tmp___0 ;
  struct usb_hcd *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;
  struct usb_hcd *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 660
  load = (int )qh->load;
#line 661
  p = (char *)"??";
#line 663
  i = (int )qh->phase;
  }
  {
#line 663
  while (1) {
    while_255_continue: /* CIL Label */ ;
#line 663
    if (! (i < 32)) {
      goto while_255_break;
    }
    {
#line 664
    uhci->load[i] = (short )((int )uhci->load[i] + load);
#line 665
    uhci->total_load += load;
#line 663
    i = (int )((unsigned int )i + qh->period);
    }
  }
  while_255_break: /* CIL Label */ ;
  }
  {
#line 667
  tmp = uhci_to_hcd(uhci);
#line 667
  tmp->self.bandwidth_allocated = uhci->total_load / 32;
  }
#line 670
  if (qh->type == 3) {
    goto switch_256_3;
  } else {
#line 674
    if (qh->type == 1) {
      goto switch_256_1;
    } else {
#line 669
      if (0) {
        switch_256_3: /* CIL Label */ 
        {
#line 671
        tmp___0 = uhci_to_hcd(uhci);
#line 671
        (tmp___0->self.bandwidth_int_reqs) ++;
#line 672
        p = (char *)"INT";
        }
        goto switch_256_break;
        switch_256_1: /* CIL Label */ 
        {
#line 675
        tmp___1 = uhci_to_hcd(uhci);
#line 675
        (tmp___1->self.bandwidth_isoc_reqs) ++;
#line 676
        p = (char *)"ISO";
        }
        goto switch_256_break;
      } else {
        switch_256_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 679
  qh->bandwidth_reserved = 1U;
  }
#line 685
  return;
}
}
#line 690 "uhci-q.c"
static void uhci_release_bandwidth(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ int i ;
  int load ;
  char *p ;
  struct usb_hcd *tmp ;
  struct usb_hcd *tmp___0 ;
  struct usb_hcd *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;
  struct usb_hcd *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 693
  load = (int )qh->load;
#line 694
  p = (char *)"??";
#line 696
  i = (int )qh->phase;
  }
  {
#line 696
  while (1) {
    while_257_continue: /* CIL Label */ ;
#line 696
    if (! (i < 32)) {
      goto while_257_break;
    }
    {
#line 697
    uhci->load[i] = (short )((int )uhci->load[i] - load);
#line 698
    uhci->total_load -= load;
#line 696
    i = (int )((unsigned int )i + qh->period);
    }
  }
  while_257_break: /* CIL Label */ ;
  }
  {
#line 700
  tmp = uhci_to_hcd(uhci);
#line 700
  tmp->self.bandwidth_allocated = uhci->total_load / 32;
  }
#line 703
  if (qh->type == 3) {
    goto switch_258_3;
  } else {
#line 707
    if (qh->type == 1) {
      goto switch_258_1;
    } else {
#line 702
      if (0) {
        switch_258_3: /* CIL Label */ 
        {
#line 704
        tmp___0 = uhci_to_hcd(uhci);
#line 704
        (tmp___0->self.bandwidth_int_reqs) --;
#line 705
        p = (char *)"INT";
        }
        goto switch_258_break;
        switch_258_1: /* CIL Label */ 
        {
#line 708
        tmp___1 = uhci_to_hcd(uhci);
#line 708
        (tmp___1->self.bandwidth_isoc_reqs) --;
#line 709
        p = (char *)"ISO";
        }
        goto switch_258_break;
      } else {
        switch_258_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 712
  qh->bandwidth_reserved = 0U;
  }
#line 718
  return;
}
}
#line 720 "uhci-q.c"
__inline static struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci , struct urb *urb ) 
{ struct urb_priv *urbp ;
  void *tmp ;

  {
  {
#line 725
  tmp = kmem_cache_zalloc(uhci_up_cachep, 32U);
#line 725
  urbp = (struct urb_priv *)tmp;
  }
#line 726
  if (! urbp) {
#line 727
    return ((struct urb_priv *)((void *)0));
  }
  {
#line 729
  urbp->urb = urb;
#line 730
  urb->hcpriv = (void *)urbp;
#line 732
  INIT_LIST_HEAD(& urbp->node);
#line 733
  INIT_LIST_HEAD(& urbp->td_list);
  }
#line 735
  return (urbp);
}
}
#line 738 "uhci-q.c"
static void uhci_free_urb_priv(struct uhci_hcd *uhci , struct urb_priv *urbp ) 
{ struct uhci_td *td ;
  struct uhci_td *tmp ;
  int __ret_warn_on ;
  struct usb_hcd *tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
#line 743
  tmp___3 = list_empty((struct list_head  const  *)(& urbp->node));
  }
#line 743
  if (! tmp___3) {
    {
#line 744
    __ret_warn_on = 1;
#line 744
    tmp___2 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 744
    if (tmp___2) {
      {
#line 744
      tmp___0 = uhci_to_hcd(uhci);
#line 744
      tmp___1 = dev_driver_string((struct device  const  *)tmp___0->self.controller);
#line 744
      warn_slowpath_fmt("uhci-q.c", 745, "Device: %s\nurb %p still on QH\'s list!\n",
                        tmp___1, urbp->urb);
      }
    }
    {
#line 744
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
  }
  {
#line 747
  __mptr = (struct list_head  const  *)urbp->td_list.next;
#line 747
  td = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 747
  __mptr___0 = (struct list_head  const  *)td->list.next;
#line 747
  tmp = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
  }
  {
#line 747
  while (1) {
    while_259_continue: /* CIL Label */ ;
#line 747
    if (! ((unsigned long )(& td->list) != (unsigned long )(& urbp->td_list))) {
      goto while_259_break;
    }
    {
#line 748
    uhci_remove_td_from_urbp(td);
#line 749
    uhci_free_td(uhci, td);
#line 747
    td = tmp;
#line 747
    __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 747
    tmp = (struct uhci_td *)((char *)__mptr___1 - (unsigned int )(& ((struct uhci_td *)0)->list));
    }
  }
  while_259_break: /* CIL Label */ ;
  }
  {
#line 752
  kmem_cache_free(uhci_up_cachep, (void *)urbp);
  }
#line 753
  return;
}
}
#line 763 "uhci-q.c"
static int uhci_map_status(int status , int dir_out ) 
{ 

  {
#line 765
  if (! status) {
#line 766
    return (0);
  }
#line 767
  if (status & (1 << 17)) {
#line 768
    return (-71);
  }
#line 769
  if (status & (1 << 18)) {
#line 770
    if (dir_out) {
#line 771
      return (-71);
    } else {
#line 773
      return (-84);
    }
  }
#line 775
  if (status & (1 << 20)) {
#line 776
    return (-75);
  }
#line 777
  if (status & (1 << 21)) {
#line 778
    return (-63);
  }
#line 779
  if (status & (1 << 22)) {
#line 780
    return (-32);
  }
#line 781
  return (0);
}
}
#line 787 "uhci-q.c"
static int uhci_submit_control(struct uhci_hcd *uhci , struct urb *urb , struct uhci_qh *qh ) 
{ struct uhci_td *td ;
  unsigned long destination ;
  unsigned long status ;
  int maxsze ;
  int len ;
  dma_addr_t data ;
  __le32 *plink ;
  struct urb_priv *urbp ;
  int skel ;
  int pktsze ;

  {
  {
#line 792
  maxsze = (int )(qh->hep)->desc.wMaxPacketSize;
#line 793
  len = (int )urb->transfer_buffer_length;
#line 794
  data = urb->transfer_dma;
#line 796
  urbp = (struct urb_priv *)urb->hcpriv;
#line 800
  destination = (unsigned long )((urb->pipe & 524032U) | 45U);
#line 803
  status = (unsigned long )(3 << 27);
  }
#line 804
  if ((unsigned int )(urb->dev)->speed == 1U) {
    {
#line 805
    status |= (unsigned long )(1 << 26);
    }
  }
  {
#line 810
  td = qh->dummy_td;
#line 811
  uhci_add_td_to_urbp(td, urbp);
#line 812
  uhci_fill_td(td, (unsigned int )status, (unsigned int )(destination | (unsigned long )(7 << 21)),
               urb->setup_dma);
#line 814
  plink = & td->link;
#line 815
  status |= (unsigned long )(1 << 23);
  }
#line 824
  if (! (urb->pipe & 128U)) {
    {
#line 825
    destination ^= 204UL;
    }
  } else {
#line 824
    if (len == 0) {
      {
#line 825
      destination ^= 204UL;
      }
    } else {
      {
#line 827
      destination ^= 68UL;
#line 828
      status |= (unsigned long )(1 << 29);
      }
    }
  }
  {
#line 834
  while (1) {
    while_260_continue: /* CIL Label */ ;
#line 834
    if (! (len > 0)) {
      goto while_260_break;
    }
    {
#line 835
    pktsze = maxsze;
    }
#line 837
    if (len <= pktsze) {
      {
#line 838
      pktsze = len;
#line 839
      status &= (unsigned long )(~ (1 << 29));
      }
    }
    {
#line 842
    td = uhci_alloc_td(uhci);
    }
#line 843
    if (! td) {
      goto nomem;
    }
    {
#line 845
    *plink = td->dma_handle;
#line 848
    destination ^= (unsigned long )(1 << 19);
#line 850
    uhci_add_td_to_urbp(td, urbp);
#line 851
    uhci_fill_td(td, (unsigned int )status, (unsigned int )(destination | (unsigned long )(((pktsze - 1) & 2047) << 21)),
                 data);
#line 853
    plink = & td->link;
#line 855
    data += (dma_addr_t )pktsze;
#line 856
    len -= pktsze;
    }
  }
  while_260_break: /* CIL Label */ ;
  }
  {
#line 862
  td = uhci_alloc_td(uhci);
  }
#line 863
  if (! td) {
    goto nomem;
  }
  {
#line 865
  *plink = td->dma_handle;
#line 868
  destination ^= 136UL;
#line 869
  destination |= (unsigned long )(1 << 19);
#line 871
  uhci_add_td_to_urbp(td, urbp);
#line 872
  uhci_fill_td(td, (unsigned int )(status | (unsigned long )(1 << 24)), (unsigned int )(destination | (unsigned long )(2047 << 21)),
               0U);
#line 874
  plink = & td->link;
#line 879
  td = uhci_alloc_td(uhci);
  }
#line 880
  if (! td) {
    goto nomem;
  }
  {
#line 882
  *plink = td->dma_handle;
#line 884
  uhci_fill_td(td, 0U, (unsigned int )(225 | (2047 << 21)), 0U);
#line 885
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "sfence"
                       "\n664:\n"
                       ".previous": : "i" (25): "memory");
#line 886
  (qh->dummy_td)->status |= (unsigned int )(1 << 23);
#line 887
  qh->dummy_td = td;
  }
#line 893
  if ((unsigned int )(urb->dev)->speed == 1U) {
    {
#line 895
    skel = 20;
    }
  } else {
#line 893
    if ((unsigned int )(urb->dev)->state != 7U) {
      {
#line 895
      skel = 20;
      }
    } else {
      {
#line 897
      skel = 21;
#line 898
      uhci_add_fsbr(uhci, urb);
      }
    }
  }
#line 900
  if (qh->state != 3) {
    {
#line 901
    qh->skel = skel;
    }
  }
#line 902
  return (0);
  nomem: 
  {
#line 906
  uhci_remove_td_from_urbp(qh->dummy_td);
  }
#line 907
  return (-12);
}
}
#line 913 "uhci-q.c"
static int uhci_submit_common(struct uhci_hcd *uhci , struct urb *urb , struct uhci_qh *qh ) 
{ struct uhci_td *td ;
  unsigned long destination ;
  unsigned long status ;
  int maxsze ;
  int len ;
  dma_addr_t data ;
  __le32 *plink ;
  struct urb_priv *urbp ;
  unsigned int toggle ;
  int tmp ;
  int pktsze ;

  {
  {
#line 918
  maxsze = (int )(qh->hep)->desc.wMaxPacketSize;
#line 919
  len = (int )urb->transfer_buffer_length;
#line 920
  data = urb->transfer_dma;
#line 922
  urbp = (struct urb_priv *)urb->hcpriv;
  }
#line 925
  if (len < 0) {
#line 926
    return (-22);
  }
#line 929
  if (urb->pipe & 128U) {
    {
#line 929
    tmp = 105;
    }
  } else {
    {
#line 929
    tmp = 225;
    }
  }
  {
#line 929
  destination = (unsigned long )((urb->pipe & 524032U) | (unsigned int )tmp);
#line 930
  toggle = ((urb->dev)->toggle[! (urb->pipe & 128U)] >> ((urb->pipe >> 15) & 15U)) & 1U;
#line 934
  status = (unsigned long )(3 << 27);
  }
#line 935
  if ((unsigned int )(urb->dev)->speed == 1U) {
    {
#line 936
    status |= (unsigned long )(1 << 26);
    }
  }
#line 937
  if (urb->pipe & 128U) {
    {
#line 938
    status |= (unsigned long )(1 << 29);
    }
  }
  {
#line 943
  plink = (__le32 *)((void *)0);
#line 944
  td = qh->dummy_td;
  }
  {
#line 945
  while (1) {
    while_261_continue: /* CIL Label */ ;
    {
#line 946
    pktsze = maxsze;
    }
#line 948
    if (len <= pktsze) {
      {
#line 949
      pktsze = len;
      }
#line 950
      if (! (urb->transfer_flags & 1U)) {
        {
#line 951
        status &= (unsigned long )(~ (1 << 29));
        }
      }
    }
#line 954
    if (plink) {
      {
#line 955
      td = uhci_alloc_td(uhci);
      }
#line 956
      if (! td) {
        goto nomem;
      }
      {
#line 958
      *plink = td->dma_handle;
      }
    }
    {
#line 960
    uhci_add_td_to_urbp(td, urbp);
#line 961
    uhci_fill_td(td, (unsigned int )status, (unsigned int )((destination | (unsigned long )(((pktsze - 1) & 2047) << 21)) | (unsigned long )(toggle << 19)),
                 data);
#line 965
    plink = & td->link;
#line 966
    status |= (unsigned long )(1 << 23);
#line 968
    data += (dma_addr_t )pktsze;
#line 969
    len -= maxsze;
#line 970
    toggle ^= 1U;
    }
#line 945
    if (! (len > 0)) {
      goto while_261_break;
    }
  }
  while_261_break: /* CIL Label */ ;
  }
#line 980
  if (urb->transfer_flags & 64U) {
#line 980
    if (! (urb->pipe & 128U)) {
#line 980
      if (len == 0) {
#line 980
        if (urb->transfer_buffer_length > 0U) {
          {
#line 983
          td = uhci_alloc_td(uhci);
          }
#line 984
          if (! td) {
            goto nomem;
          }
          {
#line 986
          *plink = td->dma_handle;
#line 988
          uhci_add_td_to_urbp(td, urbp);
#line 989
          uhci_fill_td(td, (unsigned int )status, (unsigned int )((destination | (unsigned long )(2047 << 21)) | (unsigned long )(toggle << 19)),
                       data);
#line 993
          plink = & td->link;
#line 995
          toggle ^= 1U;
          }
        }
      }
    }
  }
  {
#line 1004
  td->status |= (unsigned int )(1 << 24);
#line 1009
  td = uhci_alloc_td(uhci);
  }
#line 1010
  if (! td) {
    goto nomem;
  }
  {
#line 1012
  *plink = td->dma_handle;
#line 1014
  uhci_fill_td(td, 0U, (unsigned int )(225 | (2047 << 21)), 0U);
#line 1015
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "sfence"
                       "\n664:\n"
                       ".previous": : "i" (25): "memory");
#line 1016
  (qh->dummy_td)->status |= (unsigned int )(1 << 23);
#line 1017
  qh->dummy_td = td;
#line 1019
  (urb->dev)->toggle[! (urb->pipe & 128U)] = ((urb->dev)->toggle[! (urb->pipe & 128U)] & (unsigned int )(~ (1 << ((urb->pipe >> 15) & 15U)))) | (toggle << ((urb->pipe >> 15) & 15U));
  }
#line 1021
  return (0);
  nomem: 
  {
#line 1025
  uhci_remove_td_from_urbp(qh->dummy_td);
  }
#line 1026
  return (-12);
}
}
#line 1029 "uhci-q.c"
static int uhci_submit_bulk(struct uhci_hcd *uhci , struct urb *urb , struct uhci_qh *qh ) 
{ int ret ;

  {
#line 1035
  if ((unsigned int )(urb->dev)->speed == 1U) {
#line 1036
    return (-22);
  }
#line 1038
  if (qh->state != 3) {
    {
#line 1039
    qh->skel = 22;
    }
  }
  {
#line 1040
  ret = uhci_submit_common(uhci, urb, qh);
  }
#line 1041
  if (ret == 0) {
    {
#line 1042
    uhci_add_fsbr(uhci, urb);
    }
  }
#line 1043
  return (ret);
}
}
#line 1046 "uhci-q.c"
static int uhci_submit_interrupt(struct uhci_hcd *uhci , struct urb *urb , struct uhci_qh *qh ) 
{ int ret ;
  int exponent ;

  {
#line 1056
  if (! qh->bandwidth_reserved) {
    {
#line 1060
    exponent = 7;
    }
    {
#line 1060
    while (1) {
      while_262_continue: /* CIL Label */ ;
#line 1060
      if (! (exponent >= 0)) {
        goto while_262_break;
      }
#line 1061
      if (1 << exponent <= urb->interval) {
        goto while_262_break;
      }
      {
#line 1060
      exponent --;
      }
    }
    while_262_break: /* CIL Label */ ;
    }
#line 1064
    if (exponent < 0) {
#line 1065
      return (-22);
    }
    {
#line 1068
    while (1) {
      while_263_continue: /* CIL Label */ ;
      {
#line 1069
      qh->period = (unsigned int )(1 << exponent);
#line 1070
      qh->skel = 9 - exponent;
#line 1075
      qh->phase = (short )(qh->period / 2U & 31U);
#line 1076
      ret = uhci_check_bandwidth(uhci, qh);
      }
#line 1068
      if (ret != 0) {
        {
#line 1068
        exponent --;
        }
#line 1068
        if (! (exponent >= 0)) {
          goto while_263_break;
        }
      } else {
        goto while_263_break;
      }
    }
    while_263_break: /* CIL Label */ ;
    }
#line 1078
    if (ret) {
#line 1079
      return (ret);
    }
  } else {
#line 1080
    if (qh->period > (unsigned int )urb->interval) {
#line 1081
      return (-22);
    }
  }
  {
#line 1083
  ret = uhci_submit_common(uhci, urb, qh);
  }
#line 1084
  if (ret == 0) {
    {
#line 1085
    urb->interval = (int )qh->period;
    }
#line 1086
    if (! qh->bandwidth_reserved) {
      {
#line 1087
      uhci_reserve_bandwidth(uhci, qh);
      }
    }
  }
#line 1089
  return (ret);
}
}
#line 1095 "uhci-q.c"
static int uhci_fixup_short_transfer(struct uhci_hcd *uhci , struct uhci_qh *qh ,
                                     struct urb_priv *urbp ) 
{ struct uhci_td *td ;
  struct list_head *tmp ;
  int ret ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 1102
  __mptr = (struct list_head  const  *)urbp->td_list.prev;
#line 1102
  td = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->list));
  }
#line 1103
  if (qh->type == 0) {
    {
#line 1108
    tmp___0 = list_empty((struct list_head  const  *)(& urbp->td_list));
    }
#line 1108
    if (tmp___0) {
      {
#line 1108
      tmp___1 = 1;
      }
    } else {
      {
#line 1108
      tmp___1 = 0;
      }
    }
    {
#line 1108
    __ret_warn_on = tmp___1;
#line 1108
    tmp___2 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
#line 1108
    if (tmp___2) {
      {
#line 1108
      warn_slowpath_null("uhci-q.c", 1108);
      }
    }
    {
#line 1108
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
#line 1109
    qh->element = td->dma_handle;
#line 1110
    tmp = td->list.prev;
#line 1111
    ret = -115;
    }
  } else {
    {
#line 1118
    qh->initial_toggle = (((qh->post_td)->token >> 19) & 1U) ^ 1U;
#line 1119
    uhci_fixup_toggles(qh, 1);
#line 1121
    tmp___3 = list_empty((struct list_head  const  *)(& urbp->td_list));
    }
#line 1121
    if (tmp___3) {
      {
#line 1122
      td = qh->post_td;
      }
    }
    {
#line 1123
    qh->element = td->link;
#line 1124
    tmp = urbp->td_list.prev;
#line 1125
    ret = 0;
    }
  }
  {
#line 1129
  while (1) {
    while_264_continue: /* CIL Label */ ;
#line 1129
    if (! ((unsigned long )tmp != (unsigned long )(& urbp->td_list))) {
      goto while_264_break;
    }
    {
#line 1130
    __mptr___0 = (struct list_head  const  *)tmp;
#line 1130
    td = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 1131
    tmp = tmp->prev;
#line 1133
    uhci_remove_td_from_urbp(td);
#line 1134
    uhci_free_td(uhci, td);
    }
  }
  while_264_break: /* CIL Label */ ;
  }
#line 1136
  return (ret);
}
}
#line 1142 "uhci-q.c"
static int uhci_result_common(struct uhci_hcd *uhci , struct urb *urb ) 
{ struct urb_priv *urbp ;
  struct uhci_qh *qh ;
  struct uhci_td *td ;
  struct uhci_td *tmp ;
  unsigned int status ;
  int ret ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  unsigned int ctrlstat ;
  int len ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1144
  urbp = (struct urb_priv *)urb->hcpriv;
#line 1145
  qh = urbp->qh;
#line 1148
  ret = 0;
#line 1150
  __mptr = (struct list_head  const  *)urbp->td_list.next;
#line 1150
  td = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 1150
  __mptr___0 = (struct list_head  const  *)td->list.next;
#line 1150
  tmp = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
  }
  {
#line 1150
  while (1) {
    while_265_continue: /* CIL Label */ ;
#line 1150
    if (! ((unsigned long )(& td->list) != (unsigned long )(& urbp->td_list))) {
      goto while_265_break;
    }
    {
#line 1154
    ctrlstat = td_status(td);
#line 1155
    status = ctrlstat & 16121856U;
    }
#line 1156
    if (status & (unsigned int )(1 << 23)) {
#line 1157
      return (-115);
    }
    {
#line 1159
    len = (int )((ctrlstat + 1U) & 2047U);
#line 1160
    urb->actual_length += (u32 )len;
    }
#line 1162
    if (status) {
      {
#line 1163
      ret = uhci_map_status((int )status, (td->token & 255U) != 105U);
      }
    } else {
#line 1180
      if ((unsigned int )len < (((td->token >> 21) + 1U) & 2047U)) {
#line 1184
        if (qh->type == 0) {
#line 1185
          if ((unsigned long )td->list.next != (unsigned long )urbp->td_list.prev) {
            {
#line 1186
            ret = 1;
            }
          }
        } else {
#line 1190
          if (urb->transfer_flags & 1U) {
            {
#line 1191
            ret = -121;
            }
          } else {
#line 1194
            if ((unsigned long )(& td->list) != (unsigned long )urbp->td_list.prev) {
              {
#line 1195
              ret = 1;
              }
            }
          }
        }
      }
    }
    {
#line 1198
    uhci_remove_td_from_urbp(td);
    }
#line 1199
    if (qh->post_td) {
      {
#line 1200
      uhci_free_td(uhci, qh->post_td);
      }
    }
    {
#line 1201
    qh->post_td = td;
    }
#line 1203
    if (ret != 0) {
      goto err;
    }
    {
#line 1150
    td = tmp;
#line 1150
    __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 1150
    tmp = (struct uhci_td *)((char *)__mptr___1 - (unsigned int )(& ((struct uhci_td *)0)->list));
    }
  }
  while_265_break: /* CIL Label */ ;
  }
#line 1206
  return (ret);
  err: 
#line 1209
  if (ret < 0) {
    {
#line 1212
    qh->element = 1U;
#line 1213
    qh->is_stopped = 1U;
#line 1214
    qh->needs_fixup = (unsigned int )(qh->type != 0);
#line 1215
    qh->initial_toggle = ((td->token >> 19) & 1U) ^ (unsigned int )(ret == -121);
    }
  } else {
    {
#line 1219
    ret = uhci_fixup_short_transfer(uhci, qh, urbp);
    }
  }
#line 1220
  return (ret);
}
}
#line 1226 "uhci-q.c"
static int uhci_submit_isochronous(struct uhci_hcd *uhci , struct urb *urb , struct uhci_qh *qh ) 
{ struct uhci_td *td ;
  int i ;
  int frame ;
  unsigned long destination ;
  unsigned long status ;
  struct urb_priv *urbp ;
  struct urb *lurb ;
  struct list_head  const  *__mptr ;
  int tmp ;
  int tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___1 ;

  {
  {
#line 1229
  td = (struct uhci_td *)((void *)0);
#line 1232
  urbp = (struct urb_priv *)urb->hcpriv;
  }
#line 1235
  if (urb->interval >= 1024) {
#line 1237
    return (-27);
  } else {
#line 1235
    if (urb->number_of_packets >= 1024) {
#line 1237
      return (-27);
    }
  }
#line 1240
  if (! qh->bandwidth_reserved) {
    {
#line 1241
    qh->period = (unsigned int )urb->interval;
    }
#line 1242
    if (urb->transfer_flags & 2U) {
      {
#line 1243
      qh->phase = (short)-1;
#line 1244
      i = uhci_check_bandwidth(uhci, qh);
      }
#line 1245
      if (i) {
#line 1246
        return (i);
      }
      {
#line 1249
      uhci_get_current_frame_number(uhci);
#line 1250
      frame = (int )(uhci->frame_number + 10U);
#line 1254
      urb->start_frame = (int )((unsigned int )frame + ((unsigned int )((int )qh->phase - frame) & (qh->period - 1U)));
      }
    } else {
      {
#line 1257
      i = (int )((unsigned int )urb->start_frame - uhci->last_iso_frame);
      }
#line 1258
      if (i <= 0) {
#line 1259
        return (-22);
      } else {
#line 1258
        if (i >= 1024) {
#line 1259
          return (-22);
        }
      }
      {
#line 1260
      qh->phase = (short )((unsigned int )urb->start_frame & (qh->period - 1U));
#line 1261
      i = uhci_check_bandwidth(uhci, qh);
      }
#line 1262
      if (i) {
#line 1263
        return (i);
      }
    }
  } else {
#line 1266
    if (qh->period != (unsigned int )urb->interval) {
#line 1267
      return (-22);
    } else {
      {
#line 1271
      tmp = list_empty((struct list_head  const  *)(& qh->queue));
      }
#line 1271
      if (tmp) {
        {
#line 1272
        frame = (int )qh->iso_frame;
        }
      } else {
        {
#line 1276
        __mptr = (struct list_head  const  *)qh->queue.prev;
#line 1276
        lurb = ((struct urb_priv *)((char *)__mptr - (unsigned int )(& ((struct urb_priv *)0)->node)))->urb;
#line 1278
        frame = lurb->start_frame + lurb->number_of_packets * lurb->interval;
        }
      }
#line 1282
      if (urb->transfer_flags & 2U) {
        {
#line 1286
        uhci_get_current_frame_number(uhci);
        }
#line 1287
        if (0 <= (int )(uhci->frame_number - (unsigned int )frame)) {
          {
#line 1288
          frame = (int )(uhci->frame_number + 1U);
#line 1289
          frame = (int )((unsigned int )frame + ((unsigned int )((int )qh->phase - frame) & (qh->period - 1U)));
          }
        }
      }
      {
#line 1293
      urb->start_frame = frame;
      }
    }
  }
#line 1297
  if (0 <= (int )((unsigned int )(urb->start_frame + urb->number_of_packets * urb->interval) - (uhci->last_iso_frame + 1024U))) {
#line 1300
    return (-27);
  }
  {
#line 1302
  status = (unsigned long )((1 << 23) | (1 << 25));
  }
#line 1303
  if (urb->pipe & 128U) {
    {
#line 1303
    tmp___0 = 105;
    }
  } else {
    {
#line 1303
    tmp___0 = 225;
    }
  }
  {
#line 1303
  destination = (unsigned long )((urb->pipe & 524032U) | (unsigned int )tmp___0);
#line 1305
  i = 0;
  }
  {
#line 1305
  while (1) {
    while_266_continue: /* CIL Label */ ;
#line 1305
    if (! (i < urb->number_of_packets)) {
      goto while_266_break;
    }
    {
#line 1306
    td = uhci_alloc_td(uhci);
    }
#line 1307
    if (! td) {
#line 1308
      return (-12);
    }
    {
#line 1310
    uhci_add_td_to_urbp(td, urbp);
#line 1311
    uhci_fill_td(td, (unsigned int )status, (unsigned int )(destination | (unsigned long )(((urb->iso_frame_desc[i].length - 1U) & 2047U) << 21)),
                 urb->transfer_dma + urb->iso_frame_desc[i].offset);
#line 1305
    i ++;
    }
  }
  while_266_break: /* CIL Label */ ;
  }
  {
#line 1318
  td->status |= (unsigned int )(1 << 24);
#line 1321
  frame = urb->start_frame;
#line 1322
  __mptr___0 = (struct list_head  const  *)urbp->td_list.next;
#line 1322
  td = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
  }
  {
#line 1322
  while (1) {
    while_267_continue: /* CIL Label */ ;
    {
#line 1322
    prefetch((void const   *)td->list.next);
    }
#line 1322
    if (! ((unsigned long )(& td->list) != (unsigned long )(& urbp->td_list))) {
      goto while_267_break;
    }
    {
#line 1323
    uhci_insert_td_in_frame_list(uhci, td, (unsigned int )frame);
#line 1324
    frame = (int )((unsigned int )frame + qh->period);
#line 1322
    __mptr___1 = (struct list_head  const  *)td->list.next;
#line 1322
    td = (struct uhci_td *)((char *)__mptr___1 - (unsigned int )(& ((struct uhci_td *)0)->list));
    }
  }
  while_267_break: /* CIL Label */ ;
  }
  {
#line 1327
  tmp___1 = list_empty((struct list_head  const  *)(& qh->queue));
  }
#line 1327
  if (tmp___1) {
    {
#line 1328
    qh->iso_packet_desc = & urb->iso_frame_desc[0];
#line 1329
    qh->iso_frame = (unsigned int )urb->start_frame;
    }
  }
  {
#line 1332
  qh->skel = 1;
  }
#line 1333
  if (! qh->bandwidth_reserved) {
    {
#line 1334
    uhci_reserve_bandwidth(uhci, qh);
    }
  }
#line 1335
  return (0);
}
}
#line 1338 "uhci-q.c"
static int uhci_result_isochronous(struct uhci_hcd *uhci , struct urb *urb ) 
{ struct uhci_td *td ;
  struct uhci_td *tmp ;
  struct urb_priv *urbp ;
  struct uhci_qh *qh ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  unsigned int ctrlstat ;
  int status ;
  int actlength ;

  {
  {
#line 1341
  urbp = (struct urb_priv *)urb->hcpriv;
#line 1342
  qh = urbp->qh;
#line 1344
  __mptr = (struct list_head  const  *)urbp->td_list.next;
#line 1344
  td = (struct uhci_td *)((char *)__mptr - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 1344
  __mptr___0 = (struct list_head  const  *)td->list.next;
#line 1344
  tmp = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
  }
  {
#line 1344
  while (1) {
    while_268_continue: /* CIL Label */ ;
#line 1344
    if (! ((unsigned long )(& td->list) != (unsigned long )(& urbp->td_list))) {
      goto while_268_break;
    }
#line 1349
    if (0 <= (int )(qh->iso_frame - uhci->cur_iso_frame)) {
#line 1350
      return (-115);
    }
    {
#line 1352
    uhci_remove_tds_from_frame(uhci, qh->iso_frame);
#line 1354
    ctrlstat = td_status(td);
    }
#line 1355
    if (ctrlstat & (unsigned int )(1 << 23)) {
      {
#line 1356
      status = -18;
      }
    } else {
      {
#line 1358
      status = uhci_map_status((int )(ctrlstat & 16121856U), ! (urb->pipe & 128U));
#line 1360
      actlength = (int )((ctrlstat + 1U) & 2047U);
#line 1362
      urb->actual_length += (u32 )actlength;
#line 1363
      (qh->iso_packet_desc)->actual_length = (unsigned int )actlength;
#line 1364
      (qh->iso_packet_desc)->status = status;
      }
    }
#line 1366
    if (status) {
      {
#line 1367
      (urb->error_count) ++;
      }
    }
    {
#line 1369
    uhci_remove_td_from_urbp(td);
#line 1370
    uhci_free_td(uhci, td);
#line 1371
    qh->iso_frame += qh->period;
#line 1372
    (qh->iso_packet_desc) ++;
#line 1344
    td = tmp;
#line 1344
    __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 1344
    tmp = (struct uhci_td *)((char *)__mptr___1 - (unsigned int )(& ((struct uhci_td *)0)->list));
    }
  }
  while_268_break: /* CIL Label */ ;
  }
#line 1374
  return (0);
}
}
#line 1377 "uhci-q.c"
static int uhci_urb_enqueue(struct usb_hcd *hcd , struct urb *urb , gfp_t mem_flags ) 
{ int ret ;
  struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  unsigned long flags ;
  struct urb_priv *urbp ;
  struct uhci_qh *qh ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
#line 1381
  tmp = hcd_to_uhci(hcd);
#line 1381
  uhci = tmp;
  }
  {
#line 1386
  while (1) {
    while_269_continue: /* CIL Label */ ;
    {
#line 1386
    flags = _spin_lock_irqsave(& uhci->lock);
    }
    goto while_269_break;
  }
  while_269_break: /* CIL Label */ ;
  }
  {
#line 1388
  ret = usb_hcd_link_urb_to_ep(hcd, urb);
  }
#line 1389
  if (ret) {
    goto done_not_linked;
  }
  {
#line 1392
  ret = -12;
#line 1393
  urbp = uhci_alloc_urb_priv(uhci, urb);
  }
#line 1394
  if (! urbp) {
    goto done;
  }
#line 1397
  if ((urb->ep)->hcpriv) {
    {
#line 1398
    qh = (struct uhci_qh *)(urb->ep)->hcpriv;
    }
  } else {
    {
#line 1400
    qh = uhci_alloc_qh(uhci, urb->dev, urb->ep);
    }
#line 1401
    if (! qh) {
      goto err_no_qh;
    }
  }
  {
#line 1404
  urbp->qh = qh;
  }
#line 1407
  if (qh->type == 0) {
    goto switch_270_0;
  } else {
#line 1410
    if (qh->type == 2) {
      goto switch_270_2;
    } else {
#line 1413
      if (qh->type == 3) {
        goto switch_270_3;
      } else {
#line 1416
        if (qh->type == 1) {
          goto switch_270_1;
        } else {
#line 1406
          if (0) {
            switch_270_0: /* CIL Label */ 
            {
#line 1408
            ret = uhci_submit_control(uhci, urb, qh);
            }
            goto switch_270_break;
            switch_270_2: /* CIL Label */ 
            {
#line 1411
            ret = uhci_submit_bulk(uhci, urb, qh);
            }
            goto switch_270_break;
            switch_270_3: /* CIL Label */ 
            {
#line 1414
            ret = uhci_submit_interrupt(uhci, urb, qh);
            }
            goto switch_270_break;
            switch_270_1: /* CIL Label */ 
            {
#line 1417
            urb->error_count = 0;
#line 1418
            ret = uhci_submit_isochronous(uhci, urb, qh);
            }
            goto switch_270_break;
          } else {
            switch_270_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 1421
  if (ret != 0) {
    goto err_submit_failed;
  }
  {
#line 1425
  urbp->qh = qh;
#line 1426
  list_add_tail(& urbp->node, & qh->queue);
  }
#line 1432
  if ((unsigned long )qh->queue.next == (unsigned long )(& urbp->node)) {
#line 1432
    if (! qh->is_stopped) {
      {
#line 1433
      uhci_activate_qh(uhci, qh);
#line 1434
      uhci_urbp_wants_fsbr(uhci, urbp);
      }
    }
  }
  goto done;
  err_submit_failed: 
#line 1439
  if (qh->state == 1) {
    {
#line 1440
    uhci_make_qh_idle(uhci, qh);
    }
  }
  err_no_qh: 
  {
#line 1442
  uhci_free_urb_priv(uhci, urbp);
  }
  done: 
#line 1444
  if (ret) {
    {
#line 1445
    usb_hcd_unlink_urb_from_ep(hcd, urb);
    }
  }
  done_not_linked: 
  {
#line 1447
  while (1) {
    while_271_continue: /* CIL Label */ ;
    {
#line 1447
    _spin_unlock_irqrestore(& uhci->lock, flags);
    }
    goto while_271_break;
  }
  while_271_break: /* CIL Label */ ;
  }
#line 1448
  return (ret);
}
}
#line 1451 "uhci-q.c"
static int uhci_urb_dequeue(struct usb_hcd *hcd , struct urb *urb , int status ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  unsigned long flags ;
  struct uhci_qh *qh ;
  int rc ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
#line 1453
  tmp = hcd_to_uhci(hcd);
#line 1453
  uhci = tmp;
  }
  {
#line 1458
  while (1) {
    while_272_continue: /* CIL Label */ ;
    {
#line 1458
    flags = _spin_lock_irqsave(& uhci->lock);
    }
    goto while_272_break;
  }
  while_272_break: /* CIL Label */ ;
  }
  {
#line 1459
  rc = usb_hcd_check_unlink_urb(hcd, urb, status);
  }
#line 1460
  if (rc) {
    goto done;
  }
  {
#line 1463
  qh = ((struct urb_priv *)urb->hcpriv)->qh;
  }
#line 1466
  if (qh->type == 1) {
    {
#line 1467
    uhci_unlink_isochronous_tds(uhci, urb);
#line 1468
    __asm__  volatile   ("661:\n\t"
                         "lock; addl $0,0(%%esp)"
                         "\n662:\n"
                         ".section .altinstructions,\"a\"\n"
                         " "
                         ".balign 4"
                         " "
                         "\n"
                         " "
                         ".long"
                         " "
                         "661b\n"
                         " "
                         ".long"
                         " "
                         "663f\n"
                         "\t .byte %c0\n"
                         "\t .byte 662b-661b\n"
                         "\t .byte 664f-663f\n"
                         ".previous\n"
                         ".section .altinstr_replacement,\"ax\"\n"
                         "663:\n\t"
                         "mfence"
                         "\n664:\n"
                         ".previous": : "i" (26): "memory");
#line 1471
    uhci_get_current_frame_number(uhci);
    }
#line 1472
    if (0 <= (int )(uhci->frame_number - (unsigned int )urb->start_frame)) {
      {
#line 1473
      qh->unlink_frame = uhci->frame_number;
      }
    }
  }
  {
#line 1476
  uhci_unlink_qh(uhci, qh);
  }
  done: 
  {
#line 1479
  while (1) {
    while_273_continue: /* CIL Label */ ;
    {
#line 1479
    _spin_unlock_irqrestore(& uhci->lock, flags);
    }
    goto while_273_break;
  }
  while_273_break: /* CIL Label */ ;
  }
#line 1480
  return (rc);
}
}
#line 1486 "uhci-q.c"
static void uhci_giveback_urb(struct uhci_hcd *uhci , struct uhci_qh *qh , struct urb *urb ,
                              int status ) 
{ struct urb_priv *urbp ;
  u32 __min1 ;
  u32 __min2 ;
  u32 tmp ;
  struct urb *nurb ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct usb_hcd *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1491
  urbp = (struct urb_priv *)urb->hcpriv;
  }
#line 1493
  if (qh->type == 0) {
    {
#line 1498
    __min1 = (u32 )8;
#line 1498
    __min2 = urb->actual_length;
    }
#line 1498
    if (__min1 < __min2) {
      {
#line 1498
      tmp = __min1;
      }
    } else {
      {
#line 1498
      tmp = __min2;
      }
    }
    {
#line 1498
    urb->actual_length -= tmp;
    }
  } else {
#line 1503
    if (qh->type == 1) {
#line 1503
      if ((unsigned long )urbp->node.prev == (unsigned long )(& qh->queue)) {
#line 1503
        if ((unsigned long )urbp->node.next != (unsigned long )(& qh->queue)) {
          {
#line 1506
          __mptr = (struct list_head  const  *)urbp->node.next;
#line 1506
          nurb = ((struct urb_priv *)((char *)__mptr - (unsigned int )(& ((struct urb_priv *)0)->node)))->urb;
#line 1509
          qh->iso_packet_desc = & nurb->iso_frame_desc[0];
#line 1510
          qh->iso_frame = (unsigned int )nurb->start_frame;
          }
        }
      }
    }
  }
  {
#line 1515
  list_del_init(& urbp->node);
#line 1516
  tmp___0 = list_empty((struct list_head  const  *)(& qh->queue));
  }
#line 1516
  if (tmp___0) {
#line 1516
    if (qh->needs_fixup) {
      {
#line 1517
      (urb->dev)->toggle[! (urb->pipe & 128U)] = ((urb->dev)->toggle[! (urb->pipe & 128U)] & (unsigned int )(~ (1 << ((urb->pipe >> 15) & 15U)))) | (qh->initial_toggle << ((urb->pipe >> 15) & 15U));
#line 1519
      qh->needs_fixup = 0U;
      }
    }
  }
  {
#line 1522
  uhci_free_urb_priv(uhci, urbp);
#line 1523
  tmp___1 = uhci_to_hcd(uhci);
#line 1523
  usb_hcd_unlink_urb_from_ep(tmp___1, urb);
#line 1525
  _spin_unlock(& uhci->lock);
#line 1526
  tmp___2 = uhci_to_hcd(uhci);
#line 1526
  usb_hcd_giveback_urb(tmp___2, urb, status);
#line 1527
  _spin_lock(& uhci->lock);
#line 1531
  tmp___3 = list_empty((struct list_head  const  *)(& qh->queue));
  }
#line 1531
  if (tmp___3) {
    {
#line 1532
    uhci_unlink_qh(uhci, qh);
    }
#line 1533
    if (qh->bandwidth_reserved) {
      {
#line 1534
      uhci_release_bandwidth(uhci, qh);
      }
    }
  }
#line 1536
  return;
}
}
#line 1545 "uhci-q.c"
static void uhci_scan_qh(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ struct urb_priv *urbp ;
  struct urb *urb ;
  int status ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___0 ;
  struct list_head  const  *__mptr___2 ;
  struct uhci_td *td ;
  struct list_head  const  *__mptr___3 ;
  int tmp___1 ;

  {
  {
#line 1551
  while (1) {
    while_274_continue: /* CIL Label */ ;
    {
#line 1551
    tmp = list_empty((struct list_head  const  *)(& qh->queue));
    }
#line 1551
    if (tmp) {
      goto while_274_break;
    }
    {
#line 1552
    __mptr = (struct list_head  const  *)qh->queue.next;
#line 1552
    urbp = (struct urb_priv *)((char *)__mptr - (unsigned int )(& ((struct urb_priv *)0)->node));
#line 1553
    urb = urbp->urb;
    }
#line 1555
    if (qh->type == 1) {
      {
#line 1556
      status = uhci_result_isochronous(uhci, urb);
      }
    } else {
      {
#line 1558
      status = uhci_result_common(uhci, urb);
      }
    }
#line 1559
    if (status == -115) {
      goto while_274_break;
    }
#line 1564
    if (urb->unlinked) {
#line 1565
      if (qh->state == 2) {
#line 1565
        if (uhci->frame_number + uhci->is_stopped != qh->unlink_frame) {
          {
#line 1566
          qh->is_stopped = 1U;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1567
        if (! qh->is_stopped) {
#line 1568
          return;
        }
      }
    }
    {
#line 1571
    uhci_giveback_urb(uhci, qh, urb, status);
    }
#line 1572
    if (status < 0) {
      goto while_274_break;
    }
  }
  while_274_break: /* CIL Label */ ;
  }
#line 1578
  if (qh->state == 2) {
#line 1578
    if (uhci->frame_number + uhci->is_stopped != qh->unlink_frame) {
      {
#line 1579
      qh->is_stopped = 1U;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1580
    if (! qh->is_stopped) {
#line 1581
      return;
    }
  }
  restart: 
  {
#line 1585
  __mptr___0 = (struct list_head  const  *)qh->queue.next;
#line 1585
  urbp = (struct urb_priv *)((char *)__mptr___0 - (unsigned int )(& ((struct urb_priv *)0)->node));
  }
  {
#line 1585
  while (1) {
    while_275_continue: /* CIL Label */ ;
    {
#line 1585
    prefetch((void const   *)urbp->node.next);
    }
#line 1585
    if (! ((unsigned long )(& urbp->node) != (unsigned long )(& qh->queue))) {
      goto while_275_break;
    }
    {
#line 1586
    urb = urbp->urb;
    }
#line 1587
    if (urb->unlinked) {
      {
#line 1592
      tmp___0 = uhci_cleanup_queue(uhci, qh, urb);
      }
#line 1592
      if (! tmp___0) {
        {
#line 1593
        qh->is_stopped = 0U;
        }
#line 1594
        return;
      }
      {
#line 1596
      uhci_giveback_urb(uhci, qh, urb, 0);
      }
      goto restart;
    }
    {
#line 1585
    __mptr___1 = (struct list_head  const  *)urbp->node.next;
#line 1585
    urbp = (struct urb_priv *)((char *)__mptr___1 - (unsigned int )(& ((struct urb_priv *)0)->node));
    }
  }
  while_275_break: /* CIL Label */ ;
  }
  {
#line 1600
  qh->is_stopped = 0U;
#line 1604
  tmp___1 = list_empty((struct list_head  const  *)(& qh->queue));
  }
#line 1604
  if (tmp___1) {
#line 1624
    if (qh->state == 2) {
#line 1624
      if (uhci->frame_number + uhci->is_stopped != qh->unlink_frame) {
        {
#line 1625
        uhci_make_qh_idle(uhci, qh);
        }
      }
    }
  } else {
#line 1605
    if (qh->needs_fixup) {
      {
#line 1606
      uhci_fixup_toggles(qh, 0);
      }
    }
    {
#line 1611
    __mptr___2 = (struct list_head  const  *)qh->queue.next;
#line 1611
    urbp = (struct urb_priv *)((char *)__mptr___2 - (unsigned int )(& ((struct urb_priv *)0)->node));
    }
#line 1612
    if (urbp->fsbr) {
#line 1612
      if (qh->wait_expired) {
        {
#line 1613
        __mptr___3 = (struct list_head  const  *)urbp->td_list.next;
#line 1613
        td = (struct uhci_td *)((char *)__mptr___3 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 1616
        td->status |= (unsigned int )(1 << 24);
        }
      }
    }
    {
#line 1619
    uhci_activate_qh(uhci, qh);
    }
  }
#line 1626
  return;
}
}
#line 1638 "uhci-q.c"
static int uhci_advance_check(struct uhci_hcd *uhci , struct uhci_qh *qh ) 
{ struct urb_priv *urbp ;
  struct uhci_td *td ;
  int ret ;
  unsigned int status ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  __le32 tmp ;
  unsigned long __dummy ;
  unsigned long volatile   __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long tmp___0 ;
  unsigned long __dummy2___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 1640
  urbp = (struct urb_priv *)((void *)0);
#line 1642
  ret = 1;
  }
#line 1645
  if (qh->type == 1) {
    goto done;
  }
#line 1656
  if (qh->state != 3) {
    {
#line 1657
    urbp = (struct urb_priv *)((void *)0);
#line 1658
    status = 0U;
    }
  } else {
    {
#line 1661
    __mptr = (struct list_head  const  *)qh->queue.next;
#line 1661
    urbp = (struct urb_priv *)((char *)__mptr - (unsigned int )(& ((struct urb_priv *)0)->node));
#line 1662
    __mptr___0 = (struct list_head  const  *)urbp->td_list.next;
#line 1662
    td = (struct uhci_td *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_td *)0)->list));
#line 1663
    status = td_status(td);
    }
#line 1664
    if (! (status & (unsigned int )(1 << 23))) {
      {
#line 1667
      qh->wait_expired = 0U;
#line 1668
      qh->advance_jiffies = (unsigned long )jiffies;
      }
      goto done;
    }
    {
#line 1671
    ret = 0;
    }
  }
#line 1675
  if (qh->wait_expired) {
    goto done;
  }
  {
#line 1678
  tmp___1 = msecs_to_jiffies(200U);
  }
#line 1678
  if ((long )(qh->advance_jiffies + tmp___1) - (long )jiffies < 0L) {
#line 1681
    if (qh->post_td) {
      {
#line 1681
      tmp = qh_element(qh);
      }
#line 1681
      if (tmp == (qh->post_td)->dma_handle) {
        {
#line 1682
        qh->element = (qh->post_td)->link;
#line 1683
        qh->advance_jiffies = (unsigned long )jiffies;
#line 1684
        ret = 1;
        }
        goto done;
      }
    }
    {
#line 1688
    qh->wait_expired = 1U;
    }
#line 1694
    if (urbp) {
#line 1694
      if (urbp->fsbr) {
#line 1694
        if (! (status & (unsigned int )(1 << 24))) {
          {
#line 1695
          uhci_unlink_qh(uhci, qh);
          }
        }
      }
    }
  } else {
#line 1699
    if (urbp) {
      {
#line 1700
      uhci_urbp_wants_fsbr(uhci, urbp);
      }
    }
  }
  done: 
#line 1704
  return (ret);
}
}
#line 1710 "uhci-q.c"
static void uhci_scan_schedule(struct uhci_hcd *uhci ) 
{ int i ;
  struct uhci_qh *qh ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 1716
  if (uhci->scan_in_progress) {
    {
#line 1717
    uhci->need_rescan = 1U;
    }
#line 1718
    return;
  }
  {
#line 1720
  uhci->scan_in_progress = 1U;
  }
  rescan: 
  {
#line 1722
  uhci->need_rescan = 0U;
#line 1723
  uhci->fsbr_is_wanted = 0U;
#line 1725
  uhci_clear_next_interrupt(uhci);
#line 1726
  uhci_get_current_frame_number(uhci);
#line 1727
  uhci->cur_iso_frame = uhci->frame_number;
#line 1730
  i = 0;
  }
  {
#line 1730
  while (1) {
    while_276_continue: /* CIL Label */ ;
#line 1730
    if (! (i < 10)) {
      goto while_276_break;
    }
    {
#line 1731
    __mptr = (struct list_head  const  *)(uhci->skelqh[i])->node.next;
#line 1731
    uhci->next_qh = (struct uhci_qh *)((char *)__mptr - (unsigned int )(& ((struct uhci_qh *)0)->node));
    }
    {
#line 1733
    while (1) {
      while_277_continue: /* CIL Label */ ;
      {
#line 1733
      qh = uhci->next_qh;
      }
#line 1733
      if (! ((unsigned long )qh != (unsigned long )uhci->skelqh[i])) {
        goto while_277_break;
      }
      {
#line 1734
      __mptr___0 = (struct list_head  const  *)qh->node.next;
#line 1734
      uhci->next_qh = (struct uhci_qh *)((char *)__mptr___0 - (unsigned int )(& ((struct uhci_qh *)0)->node));
#line 1737
      tmp = uhci_advance_check(uhci, qh);
      }
#line 1737
      if (tmp) {
        {
#line 1738
        uhci_scan_qh(uhci, qh);
        }
#line 1739
        if (qh->state == 3) {
          {
#line 1741
          __mptr___1 = (struct list_head  const  *)qh->queue.next;
#line 1741
          uhci_urbp_wants_fsbr(uhci, (struct urb_priv *)((char *)__mptr___1 - (unsigned int )(& ((struct urb_priv *)0)->node)));
          }
        }
      }
    }
    while_277_break: /* CIL Label */ ;
    }
    {
#line 1730
    i ++;
    }
  }
  while_276_break: /* CIL Label */ ;
  }
  {
#line 1747
  uhci->last_iso_frame = uhci->cur_iso_frame;
  }
#line 1748
  if (uhci->need_rescan) {
    goto rescan;
  }
  {
#line 1750
  uhci->scan_in_progress = 0U;
  }
#line 1752
  if (uhci->fsbr_is_on) {
#line 1752
    if (! uhci->fsbr_is_wanted) {
#line 1752
      if (! uhci->fsbr_expiring) {
        {
#line 1754
        uhci->fsbr_expiring = 1U;
#line 1755
        tmp___0 = msecs_to_jiffies(10U);
#line 1755
        mod_timer(& uhci->fsbr_timer, (unsigned long )(jiffies + (unsigned long volatile   )tmp___0));
        }
      }
    }
  }
  {
#line 1758
  tmp___1 = list_empty((struct list_head  const  *)(& (uhci->skelqh[0])->node));
  }
#line 1758
  if (tmp___1) {
    {
#line 1759
    uhci_clear_next_interrupt(uhci);
    }
  } else {
    {
#line 1761
    uhci_set_next_interrupt(uhci);
    }
  }
#line 1762
  return;
}
}
#line 15 "uhci-hub.c"
static __u8 const   root_hub_hub_des[9]  = 
#line 15 "uhci-hub.c"
  {      (__u8 const   )9,      (__u8 const   )41,      (__u8 const   )2,      (__u8 const   )10, 
        (__u8 const   )0,      (__u8 const   )1,      (__u8 const   )0,      (__u8 const   )0, 
        (__u8 const   )255};
#line 42 "uhci-hub.c"
static int any_ports_active(struct uhci_hcd *uhci ) 
{ int port ;
  unsigned short tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 46
  port = 0;
  }
  {
#line 46
  while (1) {
    while_278_continue: /* CIL Label */ ;
#line 46
    if (! (port < uhci->rh_numports)) {
      goto while_278_break;
    }
    {
#line 47
    tmp = inw((int )((uhci->io_addr + 16UL) + (unsigned long )(port * 2)));
    }
#line 47
    if ((int )tmp & 2059) {
#line 50
      return (1);
    } else {
      {
#line 47
      tmp___1 = variable_test_bit(port, (unsigned long const volatile   *)(& uhci->port_c_suspend));
      }
#line 47
      if (tmp___1) {
#line 50
        return (1);
      }
    }
    {
#line 46
    port ++;
    }
  }
  while_278_break: /* CIL Label */ ;
  }
#line 52
  return (0);
}
}
#line 55 "uhci-hub.c"
__inline static int get_hub_status_data(struct uhci_hcd *uhci , char *buf ) 
{ int port ;
  int mask ;
  unsigned short tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 58
  mask = 2058;
  }
#line 66
  if (ignore_oc) {
    {
#line 67
    mask &= -2049;
    }
  }
  {
#line 69
  *buf = (char)0;
#line 70
  port = 0;
  }
  {
#line 70
  while (1) {
    while_279_continue: /* CIL Label */ ;
#line 70
    if (! (port < uhci->rh_numports)) {
      goto while_279_break;
    }
    {
#line 71
    tmp = inw((int )((uhci->io_addr + 16UL) + (unsigned long )(port * 2)));
    }
#line 71
    if ((int )tmp & mask) {
      {
#line 73
      *buf = (char )((int )*buf | (1 << (port + 1)));
      }
    } else {
      {
#line 71
      tmp___1 = variable_test_bit(port, (unsigned long const volatile   *)(& uhci->port_c_suspend));
      }
#line 71
      if (tmp___1) {
        {
#line 73
        *buf = (char )((int )*buf | (1 << (port + 1)));
        }
      }
    }
    {
#line 70
    port ++;
    }
  }
  while_279_break: /* CIL Label */ ;
  }
#line 75
  return (! (! *buf));
}
}
#line 96 "uhci-hub.c"
static void uhci_finish_suspend(struct uhci_hcd *uhci , int port , unsigned long port_addr ) 
{ int status ;
  int i ;
  unsigned short tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;

  {
  {
#line 102
  tmp___3 = inw((int )port_addr);
  }
#line 102
  if ((int )tmp___3 & 4160) {
    {
#line 103
    tmp = inw((int )port_addr);
#line 103
    status = (int )tmp;
#line 103
    status &= -59403;
#line 103
    status &= -4161;
#line 103
    status = status;
#line 103
    outw((unsigned short )status, (int )port_addr);
#line 104
    tmp___1 = variable_test_bit(port, (unsigned long const volatile   *)(& uhci->resuming_ports));
    }
#line 104
    if (tmp___1) {
      {
#line 105
      set_bit((unsigned int )port, (unsigned long volatile   *)(& uhci->port_c_suspend));
      }
    }
    {
#line 112
    i = 0;
    }
    {
#line 112
    while (1) {
      while_280_continue: /* CIL Label */ ;
#line 112
      if (! (i < 10)) {
        goto while_280_break;
      }
      {
#line 113
      tmp___2 = inw((int )port_addr);
      }
#line 113
      if (! ((int )tmp___2 & 4160)) {
        goto while_280_break;
      }
      {
#line 115
      __const_udelay(4295UL);
#line 112
      i ++;
      }
    }
    while_280_break: /* CIL Label */ ;
    }
  }
  {
#line 118
  clear_bit(port, (unsigned long volatile   *)(& uhci->resuming_ports));
  }
#line 119
  return;
}
}
#line 124 "uhci-hub.c"
static void wait_for_HP(unsigned long port_addr ) 
{ int i ;
  unsigned short tmp ;

  {
  {
#line 128
  i = 10;
  }
  {
#line 128
  while (1) {
    while_281_continue: /* CIL Label */ ;
#line 128
    if (! (i < 250)) {
      goto while_281_break;
    }
    {
#line 129
    tmp = inw((int )port_addr);
    }
#line 129
    if ((int )tmp & 2) {
#line 130
      return;
    }
    {
#line 131
    __const_udelay(42950UL);
#line 128
    i += 10;
    }
  }
  while_281_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "uhci-hub.c"
static void uhci_check_ports(struct uhci_hcd *uhci ) 
{ unsigned int port ;
  unsigned long port_addr ;
  int status ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  struct device  const  *__mptr ;
  struct usb_hcd *tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned long __dummy ;
  unsigned long volatile   __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  long tmp___4 ;
  unsigned long tmp___5 ;
  struct usb_hcd *tmp___6 ;
  unsigned long __dummy___1 ;
  unsigned long volatile   __dummy2___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;

  {
  {
#line 142
  port = 0U;
  }
  {
#line 142
  while (1) {
    while_282_continue: /* CIL Label */ ;
#line 142
    if (! (port < (unsigned int )uhci->rh_numports)) {
      goto while_282_break;
    }
    {
#line 143
    port_addr = (uhci->io_addr + 16UL) + (unsigned long )(2U * port);
#line 144
    tmp = inw((int )port_addr);
#line 144
    status = (int )tmp;
#line 145
    tmp___4 = __builtin_expect((long )(! (! (status & 512))), 0L);
    }
#line 145
    if (tmp___4) {
#line 146
      if ((long )jiffies - (long )uhci->ports_timeout >= 0L) {
        {
#line 147
        tmp___0 = inw((int )port_addr);
#line 147
        status = (int )tmp___0;
#line 147
        status &= -59403;
#line 147
        status &= -513;
#line 147
        status = status;
#line 147
        outw((unsigned short )status, (int )port_addr);
#line 148
        __const_udelay(42950UL);
#line 152
        tmp___1 = uhci_to_hcd(uhci);
#line 152
        __mptr = (struct device  const  *)tmp___1->self.controller;
        }
#line 152
        if ((int )((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)))->vendor == 4156) {
          {
#line 154
          wait_for_HP(port_addr);
          }
        }
        {
#line 160
        tmp___2 = inw((int )port_addr);
#line 160
        status = (int )tmp___2;
#line 160
        status &= -59403;
#line 160
        status &= -11;
#line 160
        status |= 10;
#line 160
        outw((unsigned short )status, (int )port_addr);
#line 161
        tmp___3 = inw((int )port_addr);
#line 161
        status = (int )tmp___3;
#line 161
        status |= 4;
#line 161
        status &= -59403;
#line 161
        outw((unsigned short )status, (int )port_addr);
        }
      }
    }
    {
#line 164
    tmp___9 = __builtin_expect((long )(! (! (status & 64))), 0L);
    }
#line 164
    if (tmp___9) {
      {
#line 165
      tmp___8 = variable_test_bit((int )port, (unsigned long const volatile   *)(& uhci->resuming_ports));
      }
#line 165
      if (tmp___8) {
#line 176
        if ((long )jiffies - (long )uhci->ports_timeout >= 0L) {
          {
#line 178
          uhci_finish_suspend(uhci, (int )port, port_addr);
          }
        }
      } else {
        {
#line 168
        set_bit(port, (unsigned long volatile   *)(& uhci->resuming_ports));
#line 169
        tmp___5 = msecs_to_jiffies(20U);
#line 169
        uhci->ports_timeout = (unsigned long )(jiffies + (unsigned long volatile   )tmp___5);
#line 174
        tmp___6 = uhci_to_hcd(uhci);
#line 174
        mod_timer(& tmp___6->rh_timer, uhci->ports_timeout);
        }
      }
    }
    {
#line 142
    port ++;
    }
  }
  while_282_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 184 "uhci-hub.c"
static int uhci_hub_status_data(struct usb_hcd *hcd , char *buf ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  unsigned long flags ;
  int status ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long __dummy___0 ;
  unsigned long volatile   __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;
  int tmp___3 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;

  {
  {
#line 186
  tmp = hcd_to_uhci(hcd);
#line 186
  uhci = tmp;
#line 188
  status = 0;
  }
  {
#line 190
  while (1) {
    while_283_continue: /* CIL Label */ ;
    {
#line 190
    flags = _spin_lock_irqsave(& uhci->lock);
    }
    goto while_283_break;
  }
  while_283_break: /* CIL Label */ ;
  }
  {
#line 192
  uhci_scan_schedule(uhci);
#line 193
  tmp___0 = constant_test_bit(1U, (unsigned long const volatile   *)(& hcd->flags));
  }
#line 193
  if (tmp___0) {
#line 193
    if (uhci->dead) {
      goto done;
    }
  } else {
    goto done;
  }
  {
#line 195
  uhci_check_ports(uhci);
#line 197
  status = get_hub_status_data(uhci, buf);
  }
#line 200
  if ((int )uhci->rh_state == 4) {
    goto switch_284_4;
  } else {
#line 201
    if ((int )uhci->rh_state == 1) {
      goto switch_284_4;
    } else {
#line 207
      if ((int )uhci->rh_state == 2) {
        goto switch_284_2;
      } else {
#line 213
        if ((int )uhci->rh_state == 5) {
          goto switch_284_5;
        } else {
#line 221
          if ((int )uhci->rh_state == 6) {
            goto switch_284_6;
          } else {
            {
            goto switch_284_default;
#line 199
            if (0) {
              switch_284_4: /* CIL Label */ 
              switch_284_1: /* CIL Label */ 
#line 203
              if (status) {
                {
#line 204
                usb_hcd_resume_root_hub(hcd);
                }
              }
              goto switch_284_break;
              switch_284_2: /* CIL Label */ 
#line 209
              if (status) {
                {
#line 210
                wakeup_rh(uhci);
                }
              }
              goto switch_284_break;
              switch_284_5: /* CIL Label */ 
              {
#line 215
              tmp___2 = any_ports_active(uhci);
              }
#line 215
              if (! tmp___2) {
                {
#line 216
                uhci->rh_state = (enum uhci_rh_state )6;
#line 217
                uhci->auto_stop_time = (unsigned long )(jiffies + (unsigned long volatile   )1000);
                }
              }
              goto switch_284_break;
              switch_284_6: /* CIL Label */ 
              {
#line 223
              tmp___3 = any_ports_active(uhci);
              }
#line 223
              if (tmp___3) {
                {
#line 224
                uhci->rh_state = (enum uhci_rh_state )5;
                }
              } else {
#line 225
                if ((long )jiffies - (long )uhci->auto_stop_time >= 0L) {
                  {
#line 226
                  suspend_rh(uhci, (enum uhci_rh_state )2);
                  }
                }
              }
              goto switch_284_break;
              switch_284_default: /* CIL Label */ 
              {

              }
              goto switch_284_break;
            } else {
              switch_284_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
  }
  done: 
  {
#line 234
  while (1) {
    while_285_continue: /* CIL Label */ ;
    {
#line 234
    _spin_unlock_irqrestore(& uhci->lock, flags);
    }
    goto while_285_break;
  }
  while_285_break: /* CIL Label */ ;
  }
#line 235
  return (status);
}
}
#line 239 "uhci-hub.c"
static int uhci_hub_control(struct usb_hcd *hcd , u16 typeReq , u16 wValue , u16 wIndex ,
                            char *buf , u16 wLength ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  int status ;
  int lstatus ;
  int retval ;
  int len ;
  unsigned int port ;
  unsigned long port_addr ;
  u16 wPortChange ;
  u16 wPortStatus ;
  unsigned long flags ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned short tmp___2 ;
  struct device  const  *__mptr ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct usb_hcd *tmp___7 ;
  char const   *tmp___8 ;
  struct usb_hcd *tmp___9 ;
  char const   *tmp___10 ;
  unsigned short tmp___11 ;
  unsigned short tmp___12 ;
  unsigned long tmp___13 ;
  unsigned short tmp___14 ;
  unsigned short tmp___15 ;
  unsigned short tmp___16 ;
  unsigned long tmp___17 ;
  unsigned short tmp___18 ;
  int tmp___19 ;
  unsigned short tmp___20 ;
  unsigned short tmp___21 ;
  unsigned short tmp___22 ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  unsigned int tmp___23 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
#line 242
  tmp = hcd_to_uhci(hcd);
#line 242
  uhci = tmp;
#line 243
  retval = 0;
#line 243
  len = 0;
#line 244
  port = (unsigned int )((int )wIndex - 1);
#line 245
  port_addr = (uhci->io_addr + 16UL) + (unsigned long )(2U * port);
#line 249
  tmp___0 = constant_test_bit(1U, (unsigned long const volatile   *)(& hcd->flags));
  }
#line 249
  if (tmp___0) {
#line 249
    if (uhci->dead) {
#line 250
      return (-110);
    }
  } else {
#line 250
    return (-110);
  }
  {
#line 252
  while (1) {
    while_286_continue: /* CIL Label */ ;
    {
#line 252
    flags = _spin_lock_irqsave(& uhci->lock);
    }
    goto while_286_break;
  }
  while_286_break: /* CIL Label */ ;
  }
#line 255
  if ((int )typeReq == 40960) {
    goto switch_287_40960;
  } else {
#line 258
    if ((int )typeReq == 41728) {
      goto switch_287_41728;
    } else {
#line 312
      if ((int )typeReq == 8195) {
        goto switch_287_8195;
      } else {
#line 313
        if ((int )typeReq == 8193) {
          goto switch_287_8195;
        } else {
#line 322
          if ((int )typeReq == 8963) {
            goto switch_287_8963;
          } else {
#line 346
            if ((int )typeReq == 8961) {
              goto switch_287_8961;
            } else {
#line 401
              if ((int )typeReq == 40966) {
                goto switch_287_40966;
              } else {
                {
                goto switch_287_default;
#line 253
                if (0) {
                  switch_287_40960: /* CIL Label */ 
                  {
#line 256
                  *((__le32 *)buf) = 0U;
#line 257
                  len = 4;
                  }
                  goto switch_287_break;
                  switch_287_41728: /* CIL Label */ 
#line 259
                  if (port >= (unsigned int )uhci->rh_numports) {
                    goto err;
                  }
                  {
#line 262
                  uhci_check_ports(uhci);
#line 263
                  tmp___2 = inw((int )port_addr);
#line 263
                  status = (int )tmp___2;
#line 269
                  __mptr = (struct device  const  *)hcd->self.controller;
                  }
#line 269
                  if ((int )((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)))->vendor == 4358) {
                    {
#line 271
                    status ^= 1024;
                    }
                  }
                  {
#line 274
                  lstatus = 0;
#line 274
                  wPortChange = (unsigned short )lstatus;
                  }
#line 275
                  if (status & 2) {
                    {
#line 276
                    wPortChange = (unsigned short )((int )wPortChange | 1);
                    }
                  }
#line 277
                  if (status & 8) {
                    {
#line 278
                    wPortChange = (unsigned short )((int )wPortChange | 2);
                    }
                  }
#line 279
                  if (status & 2048) {
#line 279
                    if (! ignore_oc) {
                      {
#line 280
                      wPortChange = (unsigned short )((int )wPortChange | 8);
                      }
                    }
                  }
                  {
#line 282
                  tmp___4 = variable_test_bit((int )port, (unsigned long const volatile   *)(& uhci->port_c_suspend));
                  }
#line 282
                  if (tmp___4) {
                    {
#line 283
                    wPortChange = (unsigned short )((int )wPortChange | 4);
#line 284
                    lstatus |= 1;
                    }
                  }
                  {
#line 286
                  tmp___6 = variable_test_bit((int )port, (unsigned long const volatile   *)(& uhci->resuming_ports));
                  }
#line 286
                  if (tmp___6) {
                    {
#line 287
                    lstatus |= 4;
                    }
                  }
                  {
#line 290
                  wPortStatus = (unsigned short)256;
                  }
#line 291
                  if (status & 1) {
                    {
#line 292
                    wPortStatus = (unsigned short )((int )wPortStatus | 1);
                    }
                  }
#line 293
                  if (status & 4) {
                    {
#line 294
                    wPortStatus = (unsigned short )((int )wPortStatus | 2);
                    }
#line 295
                    if (status & 4160) {
                      {
#line 296
                      wPortStatus = (unsigned short )((int )wPortStatus | 4);
                      }
                    }
                  }
#line 298
                  if (status & 1024) {
                    {
#line 299
                    wPortStatus = (unsigned short )((int )wPortStatus | 8);
                    }
                  }
#line 300
                  if (status & 512) {
                    {
#line 301
                    wPortStatus = (unsigned short )((int )wPortStatus | 16);
                    }
                  }
#line 302
                  if (status & 256) {
                    {
#line 303
                    wPortStatus = (unsigned short )((int )wPortStatus | 512);
                    }
                  }
#line 305
                  if (wPortChange) {

                  }
                  {
#line 309
                  *((__le16 *)buf) = wPortStatus;
#line 310
                  *((__le16 *)(buf + 2)) = wPortChange;
#line 311
                  len = 4;
                  }
                  goto switch_287_break;
                  switch_287_8195: /* CIL Label */ 
                  switch_287_8193: /* CIL Label */ 
#line 315
                  if ((int )wValue == 1) {
                    goto switch_288_1;
                  } else {
#line 316
                    if ((int )wValue == 0) {
                      goto switch_288_1;
                    } else {
                      {
                      goto switch_288_default;
#line 314
                      if (0) {
                        switch_288_1: /* CIL Label */ 
                        switch_288_0: /* CIL Label */ 
                        {
#line 317
                        len = 0;
                        }
                        goto switch_288_break;
                        switch_288_default: /* CIL Label */ 
                        {

                        }
                        goto err;
                      } else {
                        switch_288_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                  goto switch_287_break;
                  switch_287_8963: /* CIL Label */ 
#line 323
                  if (port >= (unsigned int )uhci->rh_numports) {
                    goto err;
                  }
#line 327
                  if ((int )wValue == 2) {
                    goto switch_289_2;
                  } else {
#line 330
                    if ((int )wValue == 4) {
                      goto switch_289_4;
                    } else {
#line 339
                      if ((int )wValue == 8) {
                        goto switch_289_8;
                      } else {
                        {
                        goto switch_289_default;
#line 326
                        if (0) {
                          switch_289_2: /* CIL Label */ 
                          {
#line 328
                          tmp___11 = inw((int )port_addr);
#line 328
                          status = (int )tmp___11;
#line 328
                          status |= 4096;
#line 328
                          status &= -59403;
#line 328
                          outw((unsigned short )status, (int )port_addr);
#line 329
                          len = 0;
                          }
                          goto switch_289_break;
                          switch_289_4: /* CIL Label */ 
                          {
#line 331
                          tmp___12 = inw((int )port_addr);
#line 331
                          status = (int )tmp___12;
#line 331
                          status |= 512;
#line 331
                          status &= -59403;
#line 331
                          outw((unsigned short )status, (int )port_addr);
#line 334
                          uhci_finish_suspend(uhci, (int )port, port_addr);
#line 337
                          tmp___13 = msecs_to_jiffies(50U);
#line 337
                          uhci->ports_timeout = (unsigned long )(jiffies + (unsigned long volatile   )tmp___13);
#line 338
                          len = 0;
                          }
                          goto switch_289_break;
                          switch_289_8: /* CIL Label */ 
                          {
#line 341
                          len = 0;
                          }
                          goto switch_289_break;
                          switch_289_default: /* CIL Label */ 
                          {

                          }
                          goto err;
                        } else {
                          switch_289_break: /* CIL Label */ ;
                        }
                        }
                      }
                    }
                  }
                  goto switch_287_break;
                  switch_287_8961: /* CIL Label */ 
#line 347
                  if (port >= (unsigned int )uhci->rh_numports) {
                    goto err;
                  }
#line 351
                  if ((int )wValue == 1) {
                    goto switch_290_1;
                  } else {
#line 357
                    if ((int )wValue == 17) {
                      goto switch_290_17;
                    } else {
#line 360
                      if ((int )wValue == 2) {
                        goto switch_290_2;
                      } else {
#line 382
                        if ((int )wValue == 18) {
                          goto switch_290_18;
                        } else {
#line 385
                          if ((int )wValue == 8) {
                            goto switch_290_8;
                          } else {
#line 388
                            if ((int )wValue == 16) {
                              goto switch_290_16;
                            } else {
#line 391
                              if ((int )wValue == 19) {
                                goto switch_290_19;
                              } else {
#line 394
                                if ((int )wValue == 20) {
                                  goto switch_290_20;
                                } else {
                                  {
                                  goto switch_290_default;
#line 350
                                  if (0) {
                                    switch_290_1: /* CIL Label */ 
                                    {
#line 352
                                    tmp___14 = inw((int )port_addr);
#line 352
                                    status = (int )tmp___14;
#line 352
                                    status &= -59403;
#line 352
                                    status &= -5;
#line 352
                                    status = status;
#line 352
                                    outw((unsigned short )status, (int )port_addr);
#line 355
                                    uhci_finish_suspend(uhci, (int )port, port_addr);
#line 356
                                    len = 0;
                                    }
                                    goto switch_290_break;
                                    switch_290_17: /* CIL Label */ 
                                    {
#line 358
                                    tmp___15 = inw((int )port_addr);
#line 358
                                    status = (int )tmp___15;
#line 358
                                    status &= -59403;
#line 358
                                    status &= -9;
#line 358
                                    status |= 8;
#line 358
                                    outw((unsigned short )status, (int )port_addr);
#line 359
                                    len = 0;
                                    }
                                    goto switch_290_break;
                                    switch_290_2: /* CIL Label */ 
                                    {
#line 361
                                    tmp___20 = inw((int )port_addr);
                                    }
#line 361
                                    if ((int )tmp___20 & 4096) {
                                      {
#line 365
                                      tmp___19 = test_and_set_bit((int )port, (unsigned long volatile   *)(& uhci->resuming_ports));
                                      }
#line 365
                                      if (! tmp___19) {
                                        {
#line 367
                                        tmp___16 = inw((int )port_addr);
#line 367
                                        status = (int )tmp___16;
#line 367
                                        status |= 64;
#line 367
                                        status &= -59403;
#line 367
                                        outw((unsigned short )status, (int )port_addr);
#line 373
                                        tmp___18 = inw((int )port_addr);
                                        }
#line 373
                                        if ((int )tmp___18 & 64) {
                                          {
#line 378
                                          tmp___17 = msecs_to_jiffies(20U);
#line 378
                                          uhci->ports_timeout = (unsigned long )(jiffies + (unsigned long volatile   )tmp___17);
                                          }
                                        } else {
                                          {
#line 374
                                          uhci_finish_suspend(uhci, (int )port, port_addr);
                                          }
                                        }
                                      }
                                    } else {
                                      {
#line 364
                                      uhci_finish_suspend(uhci, (int )port, port_addr);
                                      }
                                    }
                                    {
#line 381
                                    len = 0;
                                    }
                                    goto switch_290_break;
                                    switch_290_18: /* CIL Label */ 
                                    {
#line 383
                                    clear_bit((int )port, (unsigned long volatile   *)(& uhci->port_c_suspend));
#line 384
                                    len = 0;
                                    }
                                    goto switch_290_break;
                                    switch_290_8: /* CIL Label */ 
                                    goto err;
                                    switch_290_16: /* CIL Label */ 
                                    {
#line 389
                                    tmp___21 = inw((int )port_addr);
#line 389
                                    status = (int )tmp___21;
#line 389
                                    status &= -59403;
#line 389
                                    status &= -3;
#line 389
                                    status |= 2;
#line 389
                                    outw((unsigned short )status, (int )port_addr);
#line 390
                                    len = 0;
                                    }
                                    goto switch_290_break;
                                    switch_290_19: /* CIL Label */ 
                                    {
#line 392
                                    tmp___22 = inw((int )port_addr);
#line 392
                                    status = (int )tmp___22;
#line 392
                                    status &= -59403;
#line 392
                                    status &= -2049;
#line 392
                                    status |= 2048;
#line 392
                                    outw((unsigned short )status, (int )port_addr);
#line 393
                                    len = 0;
                                    }
                                    goto switch_290_break;
                                    switch_290_20: /* CIL Label */ 
                                    {
#line 396
                                    len = 0;
                                    }
                                    goto switch_290_break;
                                    switch_290_default: /* CIL Label */ 
                                    {

                                    }
                                    goto err;
                                  } else {
                                    switch_290_break: /* CIL Label */ ;
                                  }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  goto switch_287_break;
                  switch_287_40966: /* CIL Label */ 
                  {
#line 402
                  __min1 = (unsigned int )sizeof(root_hub_hub_des);
#line 402
                  __min2 = (unsigned int )wLength;
                  }
#line 402
                  if (__min1 < __min2) {
                    {
#line 402
                    tmp___23 = __min1;
                    }
                  } else {
                    {
#line 402
                    tmp___23 = __min2;
                    }
                  }
                  {
#line 402
                  len = (int )tmp___23;
#line 403
                  __memcpy((void *)buf, (void const   *)(root_hub_hub_des), (unsigned int )len);
                  }
#line 404
                  if (len > 2) {
                    {
#line 405
                    *(buf + 2) = (char )uhci->rh_numports;
                    }
                  }
                  {
#line 406
                  len = len;
                  }
                  goto switch_287_break;
                  switch_287_default: /* CIL Label */ 
                  {

                  }
                  err: 
                  {
#line 409
                  retval = -32;
                  }
                } else {
                  switch_287_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 411
  while (1) {
    while_291_continue: /* CIL Label */ ;
    {
#line 411
    _spin_unlock_irqrestore(& uhci->lock, flags);
    }
    goto while_291_break;
  }
  while_291_break: /* CIL Label */ ;
  }
#line 413
  return (retval);
}
}
#line 128 "uhci-hcd.c"
static void finish_reset(struct uhci_hcd *uhci ) 
{ int port ;
  unsigned long tmp ;
  struct usb_hcd *tmp___0 ;
  struct usb_hcd *tmp___1 ;

  {
  {
#line 136
  port = 0;
  }
  {
#line 136
  while (1) {
    while_292_continue: /* CIL Label */ ;
#line 136
    if (! (port < uhci->rh_numports)) {
      goto while_292_break;
    }
    {
#line 137
    outw((unsigned short)0, (int )((uhci->io_addr + 16UL) + (unsigned long )(port * 2)));
#line 136
    port ++;
    }
  }
  while_292_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp = 0UL;
#line 139
  uhci->resuming_ports = tmp;
#line 139
  uhci->port_c_suspend = tmp;
#line 140
  uhci->rh_state = (enum uhci_rh_state )0;
#line 141
  uhci->is_stopped = 9999U;
#line 142
  tmp___0 = uhci_to_hcd(uhci);
#line 142
  tmp___0->state = 0;
#line 143
  tmp___1 = uhci_to_hcd(uhci);
#line 143
  tmp___1->poll_rh = 0U;
#line 145
  uhci->dead = 0U;
  }
#line 146
  return;
}
}
#line 152 "uhci-hcd.c"
static void uhci_hc_died(struct uhci_hcd *uhci ) 
{ struct device  const  *__mptr ;
  struct usb_hcd *tmp ;

  {
  {
#line 154
  uhci_get_current_frame_number(uhci);
#line 155
  tmp = uhci_to_hcd(uhci);
#line 155
  __mptr = (struct device  const  *)tmp->self.controller;
#line 155
  uhci_reset_hc((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)),
                uhci->io_addr);
#line 156
  finish_reset(uhci);
#line 157
  uhci->dead = 1U;
#line 160
  (uhci->frame_number) ++;
  }
#line 161
  return;
}
}
#line 168 "uhci-hcd.c"
static void check_and_reset_hc(struct uhci_hcd *uhci ) 
{ struct device  const  *__mptr ;
  struct usb_hcd *tmp ;
  int tmp___0 ;

  {
  {
#line 170
  tmp = uhci_to_hcd(uhci);
#line 170
  __mptr = (struct device  const  *)tmp->self.controller;
#line 170
  tmp___0 = uhci_check_and_reset_hc((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)),
                                    uhci->io_addr);
  }
#line 170
  if (tmp___0) {
    {
#line 171
    finish_reset(uhci);
    }
  }
#line 172
  return;
}
}
#line 177 "uhci-hcd.c"
static void configure_hc(struct uhci_hcd *uhci ) 
{ struct usb_hcd *tmp ;
  struct device  const  *__mptr ;
  struct usb_hcd *tmp___0 ;

  {
  {
#line 180
  outb((unsigned char)64, (int )(uhci->io_addr + 12UL));
#line 183
  outl(uhci->frame_dma_handle, (int )(uhci->io_addr + 8UL));
#line 186
  outw((unsigned short )(uhci->frame_number & 2047U), (int )(uhci->io_addr + 6UL));
#line 190
  tmp = uhci_to_hcd(uhci);
#line 190
  tmp->state = 4;
#line 191
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
#line 194
  tmp___0 = uhci_to_hcd(uhci);
#line 194
  __mptr = (struct device  const  *)tmp___0->self.controller;
#line 194
  pci_write_config_word((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)),
                        192, (unsigned short)8192);
  }
#line 196
  return;
}
}
#line 199 "uhci-hcd.c"
static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci ) 
{ int port ;
  struct device  const  *__mptr ;
  struct usb_hcd *tmp ;
  unsigned short tmp___0 ;

  {
#line 205
  if (ignore_oc) {
#line 206
    return (1);
  }
  {
#line 208
  tmp = uhci_to_hcd(uhci);
#line 208
  __mptr = (struct device  const  *)tmp->self.controller;
  }
#line 212
  if ((int )((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)))->vendor == 6048) {
    goto switch_293_6048;
  } else {
#line 218
    if ((int )((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)))->vendor == 32902) {
      goto switch_293_32902;
    } else {
      {
      goto switch_293_default;
#line 208
      if (0) {
        switch_293_default: /* CIL Label */ 
        {

        }
        goto switch_293_break;
        switch_293_6048: /* CIL Label */ 
#line 216
        return (1);
        switch_293_32902: /* CIL Label */ 
        {
#line 226
        port = 0;
        }
        {
#line 226
        while (1) {
          while_294_continue: /* CIL Label */ ;
#line 226
          if (! (port < uhci->rh_numports)) {
            goto while_294_break;
          }
          {
#line 227
          tmp___0 = inw((int )((uhci->io_addr + 16UL) + (unsigned long )(port * 2)));
          }
#line 227
          if ((int )tmp___0 & 1024) {
#line 229
            return (1);
          }
          {
#line 226
          port ++;
          }
        }
        while_294_break: /* CIL Label */ ;
        }
        goto switch_293_break;
      } else {
        switch_293_break: /* CIL Label */ ;
      }
      }
    }
  }
#line 233
  return (0);
}
}
#line 240
static int global_suspend_mode_is_broken(struct uhci_hcd *uhci ) ;
#line 240 "uhci-hcd.c"
static char bad_Asus_board[6]  = {      (char )'A',      (char )'7',      (char )'V',      (char )'8', 
        (char )'X',      (char )'\000'};
#line 236 "uhci-hcd.c"
static int global_suspend_mode_is_broken(struct uhci_hcd *uhci ) 
{ int port ;
  char const   *sys_info ;
  unsigned short tmp ;
  int tmp___0 ;

  {
  {
#line 246
  sys_info = dmi_get_system_info(10);
  }
#line 247
  if (sys_info) {
    {
#line 247
    tmp___0 = strcmp(sys_info, (char const   *)(bad_Asus_board));
    }
#line 247
    if (! tmp___0) {
      {
#line 248
      port = 0;
      }
      {
#line 248
      while (1) {
        while_295_continue: /* CIL Label */ ;
#line 248
        if (! (port < uhci->rh_numports)) {
          goto while_295_break;
        }
        {
#line 249
        tmp = inw((int )((uhci->io_addr + 16UL) + (unsigned long )(port * 2)));
        }
#line 249
        if ((int )tmp & 1) {
#line 251
          return (1);
        }
        {
#line 248
        port ++;
        }
      }
      while_295_break: /* CIL Label */ ;
      }
    }
  }
#line 255
  return (0);
}
}
#line 258 "uhci-hcd.c"
static void suspend_rh(struct uhci_hcd *uhci , enum uhci_rh_state new_state ) 
{ int auto_stop ;
  int int_enable ;
  int egsm_enable ;
  int wakeup_enable ;
  struct usb_device *rhdev ;
  struct usb_hcd *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short tmp___6 ;
  struct usb_hcd *tmp___7 ;
  char const   *tmp___8 ;
  struct usb_hcd *tmp___9 ;
  char const   *tmp___10 ;
  unsigned short tmp___11 ;
  struct usb_hcd *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 264
  tmp = uhci_to_hcd(uhci);
#line 264
  rhdev = tmp->self.root_hub;
#line 266
  auto_stop = (unsigned int )new_state == 2U;
#line 273
  egsm_enable = 8;
#line 274
  uhci->RD_enable = 1U;
#line 275
  int_enable = 2;
#line 276
  wakeup_enable = 1;
  }
#line 282
  if (auto_stop) {
    {
#line 283
    tmp___3 = device_may_wakeup(& rhdev->dev);
    }
#line 283
    if (! tmp___3) {
      {
#line 284
      int_enable = 0;
      }
    }
  } else {
#line 291
    if (! rhdev->do_remote_wakeup) {
      {
#line 292
      wakeup_enable = 0;
      }
    }
  }
#line 302
  if (! wakeup_enable) {
    {
#line 303
    egsm_enable = 0;
    }
  } else {
    {
#line 302
    tmp___4 = global_suspend_mode_is_broken(uhci);
    }
#line 302
    if (tmp___4) {
      {
#line 303
      egsm_enable = 0;
      }
    }
  }
#line 314
  if (! wakeup_enable) {
    {
#line 316
    int_enable = 0;
#line 316
    uhci->RD_enable = (unsigned int )int_enable;
    }
  } else {
    {
#line 314
    tmp___5 = resume_detect_interrupts_are_broken(uhci);
    }
#line 314
    if (tmp___5) {
      {
#line 316
      int_enable = 0;
#line 316
      uhci->RD_enable = (unsigned int )int_enable;
      }
    } else {
#line 314
      if (! int_enable) {
        {
#line 316
        int_enable = 0;
#line 316
        uhci->RD_enable = (unsigned int )int_enable;
        }
      }
    }
  }
  {
#line 318
  outw((unsigned short )int_enable, (int )(uhci->io_addr + 4UL));
#line 319
  outw((unsigned short )(egsm_enable | 64), (int )uhci->io_addr);
#line 320
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
#line 321
  __const_udelay(21475UL);
  }
#line 328
  if (! auto_stop) {
    {
#line 328
    tmp___6 = inw((int )(uhci->io_addr + 2UL));
    }
#line 328
    if (! ((int )tmp___6 & 32)) {
      {
#line 329
      uhci->rh_state = (enum uhci_rh_state )4;
#line 330
      _spin_unlock_irq(& uhci->lock);
#line 331
      msleep(1U);
#line 332
      _spin_lock_irq(& uhci->lock);
      }
#line 333
      if (uhci->dead) {
#line 334
        return;
      }
    }
  }
  {
#line 336
  tmp___11 = inw((int )(uhci->io_addr + 2UL));
  }
#line 336
  if (! ((int )tmp___11 & 32)) {
    {
#line 337
    tmp___7 = uhci_to_hcd(uhci);
#line 337
    tmp___8 = dev_name((struct device  const  *)tmp___7->self.controller);
#line 337
    tmp___9 = uhci_to_hcd(uhci);
#line 337
    tmp___10 = dev_driver_string((struct device  const  *)tmp___9->self.controller);
#line 337
    printk("<4>%s %s: Controller not stopped yet!\n", tmp___10, tmp___8);
    }
  }
  {
#line 339
  uhci_get_current_frame_number(uhci);
#line 341
  uhci->rh_state = new_state;
#line 342
  uhci->is_stopped = 9999U;
#line 347
  tmp___12 = uhci_to_hcd(uhci);
  }
#line 347
  if (! int_enable) {
#line 347
    if (wakeup_enable) {
      {
#line 347
      tmp___13 = 1;
      }
    } else {
      {
#line 347
      tmp___13 = 0;
      }
    }
  } else {
    {
#line 347
    tmp___13 = 0;
    }
  }
  {
#line 347
  tmp___12->poll_rh = (unsigned int )tmp___13;
#line 349
  uhci_scan_schedule(uhci);
#line 350
  uhci_fsbr_off(uhci);
  }
#line 351
  return;
}
}
#line 353 "uhci-hcd.c"
static void start_rh(struct uhci_hcd *uhci ) 
{ struct usb_hcd *tmp ;
  struct usb_hcd *tmp___0 ;

  {
  {
#line 355
  tmp = uhci_to_hcd(uhci);
#line 355
  tmp->state = 1;
#line 356
  uhci->is_stopped = 0U;
#line 361
  outw((unsigned short)193, (int )uhci->io_addr);
#line 362
  outw((unsigned short)15, (int )(uhci->io_addr + 4UL));
#line 364
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
#line 365
  uhci->rh_state = (enum uhci_rh_state )5;
#line 366
  tmp___0 = uhci_to_hcd(uhci);
#line 366
  tmp___0->poll_rh = 1U;
  }
#line 367
  return;
}
}
#line 369 "uhci-hcd.c"
static void wakeup_rh(struct uhci_hcd *uhci ) 
{ char const   *tmp ;
  struct usb_hcd *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;
  unsigned int egsm ;
  unsigned short tmp___4 ;
  struct usb_hcd *tmp___5 ;
  char const   *tmp___6 ;
  struct usb_hcd *tmp___7 ;
  char const   *tmp___8 ;
  unsigned short tmp___9 ;
  struct usb_hcd *tmp___10 ;

  {
#line 382
  if ((unsigned int )uhci->rh_state == 1U) {
    {
#line 386
    tmp___4 = inw((int )uhci->io_addr);
#line 386
    egsm = (unsigned int )((int )tmp___4 & 8);
#line 387
    uhci->rh_state = (enum uhci_rh_state )3;
#line 388
    outw((unsigned short )(80U | egsm), (int )uhci->io_addr);
#line 389
    _spin_unlock_irq(& uhci->lock);
#line 390
    msleep(20U);
#line 391
    _spin_lock_irq(& uhci->lock);
    }
#line 392
    if (uhci->dead) {
#line 393
      return;
    }
    {
#line 396
    outw((unsigned short)64, (int )uhci->io_addr);
#line 397
    __asm__  volatile   ("661:\n\t"
                         "lock; addl $0,0(%%esp)"
                         "\n662:\n"
                         ".section .altinstructions,\"a\"\n"
                         " "
                         ".balign 4"
                         " "
                         "\n"
                         " "
                         ".long"
                         " "
                         "661b\n"
                         " "
                         ".long"
                         " "
                         "663f\n"
                         "\t .byte %c0\n"
                         "\t .byte 662b-661b\n"
                         "\t .byte 664f-663f\n"
                         ".previous\n"
                         ".section .altinstr_replacement,\"ax\"\n"
                         "663:\n\t"
                         "mfence"
                         "\n664:\n"
                         ".previous": : "i" (26): "memory");
#line 398
    __const_udelay(17180UL);
#line 399
    tmp___9 = inw((int )uhci->io_addr);
    }
#line 399
    if ((int )tmp___9 & 16) {
      {
#line 400
      tmp___5 = uhci_to_hcd(uhci);
#line 400
      tmp___6 = dev_name((struct device  const  *)tmp___5->self.controller);
#line 400
      tmp___7 = uhci_to_hcd(uhci);
#line 400
      tmp___8 = dev_driver_string((struct device  const  *)tmp___7->self.controller);
#line 400
      printk("<4>%s %s: FGR not stopped yet!\n", tmp___8, tmp___6);
      }
    }
  }
  {
#line 403
  start_rh(uhci);
#line 406
  tmp___10 = uhci_to_hcd(uhci);
#line 406
  mod_timer(& tmp___10->rh_timer, (unsigned long )jiffies);
  }
#line 407
  return;
}
}
#line 409 "uhci-hcd.c"
static irqreturn_t uhci_irq(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  unsigned short status ;
  struct usb_hcd *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;
  struct usb_hcd *tmp___4 ;
  char const   *tmp___5 ;
  struct usb_hcd *tmp___6 ;
  char const   *tmp___7 ;
  struct usb_hcd *tmp___8 ;
  char const   *tmp___9 ;
  struct usb_hcd *tmp___10 ;
  char const   *tmp___11 ;

  {
  {
#line 411
  tmp = hcd_to_uhci(hcd);
#line 411
  uhci = tmp;
#line 419
  status = inw((int )(uhci->io_addr + 2UL));
  }
#line 420
  if (! ((int )status & -33)) {
#line 421
    return ((enum irqreturn )0);
  }
  {
#line 422
  outw(status, (int )(uhci->io_addr + 2UL));
  }
#line 424
  if ((int )status & -8) {
#line 425
    if ((int )status & 8) {
      {
#line 426
      tmp___0 = uhci_to_hcd(uhci);
#line 426
      tmp___1 = dev_name((struct device  const  *)tmp___0->self.controller);
#line 426
      tmp___2 = uhci_to_hcd(uhci);
#line 426
      tmp___3 = dev_driver_string((struct device  const  *)tmp___2->self.controller);
#line 426
      printk("<3>%s %s: host system error, PCI problems?\n", tmp___3, tmp___1);
      }
    }
#line 428
    if ((int )status & 16) {
      {
#line 429
      tmp___4 = uhci_to_hcd(uhci);
#line 429
      tmp___5 = dev_name((struct device  const  *)tmp___4->self.controller);
#line 429
      tmp___6 = uhci_to_hcd(uhci);
#line 429
      tmp___7 = dev_driver_string((struct device  const  *)tmp___6->self.controller);
#line 429
      printk("<3>%s %s: host controller process error, something bad happened!\n",
             tmp___7, tmp___5);
      }
    }
#line 431
    if ((int )status & 32) {
      {
#line 432
      _spin_lock(& uhci->lock);
      }
#line 433
      if ((unsigned int )uhci->rh_state >= 5U) {
        {
#line 434
        tmp___8 = uhci_to_hcd(uhci);
#line 434
        tmp___9 = dev_name((struct device  const  *)tmp___8->self.controller);
#line 434
        tmp___10 = uhci_to_hcd(uhci);
#line 434
        tmp___11 = dev_driver_string((struct device  const  *)tmp___10->self.controller);
#line 434
        printk("<3>%s %s: host controller halted, very bad!\n", tmp___11, tmp___9);
#line 443
        uhci_hc_died(uhci);
#line 447
        mod_timer(& hcd->rh_timer, (unsigned long )jiffies);
        }
      }
      {
#line 449
      _spin_unlock(& uhci->lock);
      }
    }
  }
#line 453
  if ((int )status & 4) {
    {
#line 454
    usb_hcd_poll_rh_status(hcd);
    }
  } else {
    {
#line 456
    _spin_lock(& uhci->lock);
#line 457
    uhci_scan_schedule(uhci);
#line 458
    _spin_unlock(& uhci->lock);
    }
  }
#line 461
  return ((enum irqreturn )1);
}
}
#line 472 "uhci-hcd.c"
static void uhci_get_current_frame_number(struct uhci_hcd *uhci ) 
{ unsigned int delta ;
  unsigned short tmp ;

  {
#line 474
  if (! uhci->is_stopped) {
    {
#line 477
    tmp = inw((int )(uhci->io_addr + 6UL));
#line 477
    delta = ((unsigned int )tmp - uhci->frame_number) & 1023U;
#line 479
    uhci->frame_number += delta;
    }
  }
#line 481
  return;
}
}
#line 486 "uhci-hcd.c"
static void release_uhci(struct uhci_hcd *uhci ) 
{ int i ;
  struct usb_hcd *tmp ;

  {
  {
#line 498
  i = 0;
  }
  {
#line 498
  while (1) {
    while_296_continue: /* CIL Label */ ;
#line 498
    if (! (i < 11)) {
      goto while_296_break;
    }
    {
#line 499
    uhci_free_qh(uhci, uhci->skelqh[i]);
#line 498
    i ++;
    }
  }
  while_296_break: /* CIL Label */ ;
  }
  {
#line 501
  uhci_free_td(uhci, uhci->term_td);
#line 503
  dma_pool_destroy(uhci->qh_pool);
#line 505
  dma_pool_destroy(uhci->td_pool);
#line 507
  kfree((void const   *)uhci->frame_cpu);
#line 509
  tmp = uhci_to_hcd(uhci);
#line 509
  dma_free_coherent(tmp->self.controller, (unsigned int )(1024UL * sizeof(*(uhci->frame))),
                    (void *)uhci->frame, uhci->frame_dma_handle);
  }
#line 512
  return;
}
}
#line 514 "uhci-hcd.c"
static int uhci_init(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  unsigned int io_size ;
  int port ;
  unsigned int portstatus ;
  unsigned short tmp___0 ;
  struct usb_hcd *tmp___1 ;
  char const   *tmp___2 ;
  struct usb_hcd *tmp___3 ;
  char const   *tmp___4 ;
  struct usb_hcd *tmp___5 ;
  char const   *tmp___6 ;
  struct usb_hcd *tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 516
  tmp = hcd_to_uhci(hcd);
#line 516
  uhci = tmp;
#line 517
  io_size = (unsigned int )hcd->rsrc_len;
#line 520
  uhci->io_addr = (unsigned long )hcd->rsrc_start;
#line 530
  port = 0;
  }
  {
#line 530
  while (1) {
    while_297_continue: /* CIL Label */ ;
#line 530
    if (! ((unsigned int )port < (io_size - 16U) / 2U)) {
      goto while_297_break;
    }
    {
#line 533
    tmp___0 = inw((int )((uhci->io_addr + 16UL) + (unsigned long )(port * 2)));
#line 533
    portstatus = (unsigned int )tmp___0;
    }
#line 534
    if (! (portstatus & 128U)) {
      goto while_297_break;
    } else {
#line 534
      if (portstatus == 65535U) {
        goto while_297_break;
      }
    }
    {
#line 530
    port ++;
    }
  }
  while_297_break: /* CIL Label */ ;
  }
#line 541
  if (port > 7) {
    {
#line 542
    tmp___5 = uhci_to_hcd(uhci);
#line 542
    tmp___6 = dev_name((struct device  const  *)tmp___5->self.controller);
#line 542
    tmp___7 = uhci_to_hcd(uhci);
#line 542
    tmp___8 = dev_driver_string((struct device  const  *)tmp___7->self.controller);
#line 542
    printk("<6>%s %s: port count misdetected? forcing to 2 ports\n", tmp___8, tmp___6);
#line 544
    port = 2;
    }
  }
  {
#line 546
  uhci->rh_numports = port;
#line 551
  check_and_reset_hc(uhci);
  }
#line 552
  return (0);
}
}
#line 562 "uhci-hcd.c"
static void uhci_shutdown(struct pci_dev *pdev ) 
{ struct usb_hcd *hcd ;
  void *tmp ;
  struct uhci_hcd *tmp___0 ;

  {
  {
#line 564
  tmp = pci_get_drvdata(pdev);
#line 564
  hcd = (struct usb_hcd *)tmp;
#line 566
  tmp___0 = hcd_to_uhci(hcd);
#line 566
  uhci_hc_died(tmp___0);
  }
#line 567
  return;
}
}
#line 596 "uhci-hcd.c"
static struct lock_class_key __key___3  ;
#line 587 "uhci-hcd.c"
static int uhci_start(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  int retval ;
  int i ;
  struct dentry *dentry ;
  struct usb_hcd *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;
  struct usb_hcd *tmp___4 ;
  void *tmp___5 ;
  struct usb_hcd *tmp___6 ;
  char const   *tmp___7 ;
  struct usb_hcd *tmp___8 ;
  char const   *tmp___9 ;
  void *tmp___10 ;
  struct usb_hcd *tmp___11 ;
  char const   *tmp___12 ;
  struct usb_hcd *tmp___13 ;
  char const   *tmp___14 ;
  struct usb_hcd *tmp___15 ;
  struct usb_hcd *tmp___16 ;
  char const   *tmp___17 ;
  struct usb_hcd *tmp___18 ;
  char const   *tmp___19 ;
  struct usb_hcd *tmp___20 ;
  struct usb_hcd *tmp___21 ;
  char const   *tmp___22 ;
  struct usb_hcd *tmp___23 ;
  char const   *tmp___24 ;
  struct usb_hcd *tmp___25 ;
  char const   *tmp___26 ;
  struct usb_hcd *tmp___27 ;
  char const   *tmp___28 ;
  struct usb_hcd *tmp___29 ;
  char const   *tmp___30 ;
  struct usb_hcd *tmp___31 ;
  char const   *tmp___32 ;
  __le32 tmp___33 ;
  struct usb_hcd *tmp___34 ;

  {
  {
#line 589
  tmp = hcd_to_uhci(hcd);
#line 589
  uhci = tmp;
#line 590
  retval = -16;
#line 594
  hcd->uses_new_polling = 1U;
  }
  {
#line 596
  while (1) {
    while_298_continue: /* CIL Label */ ;
    {
#line 596
    __spin_lock_init(& uhci->lock, "&uhci->lock", & __key___3);
    }
    goto while_298_break;
  }
  while_298_break: /* CIL Label */ ;
  }
  {
#line 597
  setup_timer_key(& uhci->fsbr_timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0),
                  & uhci_fsbr_timeout, (unsigned long )uhci);
#line 599
  INIT_LIST_HEAD(& uhci->idle_qh_list);
#line 600
  init_waitqueue_head(& uhci->waitqh);
#line 615
  tmp___4 = uhci_to_hcd(uhci);
#line 615
  tmp___5 = dma_alloc_coherent(tmp___4->self.controller, (unsigned int )(1024UL * sizeof(*(uhci->frame))),
                               & uhci->frame_dma_handle, 0U);
#line 615
  uhci->frame = (__le32 *)tmp___5;
  }
#line 618
  if (! uhci->frame) {
    {
#line 619
    tmp___6 = uhci_to_hcd(uhci);
#line 619
    tmp___7 = dev_name((struct device  const  *)tmp___6->self.controller);
#line 619
    tmp___8 = uhci_to_hcd(uhci);
#line 619
    tmp___9 = dev_driver_string((struct device  const  *)tmp___8->self.controller);
#line 619
    printk("<3>%s %s: unable to allocate consistent memory for frame list\n", tmp___9,
           tmp___7);
    }
    goto err_alloc_frame;
  }
  {
#line 623
  __constant_c_and_count_memset((void *)uhci->frame, 0UL, (unsigned int )(1024UL * sizeof(*(uhci->frame))));
#line 625
  tmp___10 = kcalloc(1024U, (unsigned int )sizeof(*(uhci->frame_cpu)), 208U);
#line 625
  uhci->frame_cpu = (void **)tmp___10;
  }
#line 627
  if (! uhci->frame_cpu) {
    {
#line 628
    tmp___11 = uhci_to_hcd(uhci);
#line 628
    tmp___12 = dev_name((struct device  const  *)tmp___11->self.controller);
#line 628
    tmp___13 = uhci_to_hcd(uhci);
#line 628
    tmp___14 = dev_driver_string((struct device  const  *)tmp___13->self.controller);
#line 628
    printk("<3>%s %s: unable to allocate memory for frame pointers\n", tmp___14, tmp___12);
    }
    goto err_alloc_frame_cpu;
  }
  {
#line 633
  tmp___15 = uhci_to_hcd(uhci);
#line 633
  uhci->td_pool = dma_pool_create("uhci_td", tmp___15->self.controller, (unsigned int )sizeof(struct uhci_td ),
                                  16U, 0U);
  }
#line 635
  if (! uhci->td_pool) {
    {
#line 636
    tmp___16 = uhci_to_hcd(uhci);
#line 636
    tmp___17 = dev_name((struct device  const  *)tmp___16->self.controller);
#line 636
    tmp___18 = uhci_to_hcd(uhci);
#line 636
    tmp___19 = dev_driver_string((struct device  const  *)tmp___18->self.controller);
#line 636
    printk("<3>%s %s: unable to create td dma_pool\n", tmp___19, tmp___17);
    }
    goto err_create_td_pool;
  }
  {
#line 640
  tmp___20 = uhci_to_hcd(uhci);
#line 640
  uhci->qh_pool = dma_pool_create("uhci_qh", tmp___20->self.controller, (unsigned int )sizeof(struct uhci_qh ),
                                  16U, 0U);
  }
#line 642
  if (! uhci->qh_pool) {
    {
#line 643
    tmp___21 = uhci_to_hcd(uhci);
#line 643
    tmp___22 = dev_name((struct device  const  *)tmp___21->self.controller);
#line 643
    tmp___23 = uhci_to_hcd(uhci);
#line 643
    tmp___24 = dev_driver_string((struct device  const  *)tmp___23->self.controller);
#line 643
    printk("<3>%s %s: unable to create qh dma_pool\n", tmp___24, tmp___22);
    }
    goto err_create_qh_pool;
  }
  {
#line 647
  uhci->term_td = uhci_alloc_td(uhci);
  }
#line 648
  if (! uhci->term_td) {
    {
#line 649
    tmp___25 = uhci_to_hcd(uhci);
#line 649
    tmp___26 = dev_name((struct device  const  *)tmp___25->self.controller);
#line 649
    tmp___27 = uhci_to_hcd(uhci);
#line 649
    tmp___28 = dev_driver_string((struct device  const  *)tmp___27->self.controller);
#line 649
    printk("<3>%s %s: unable to allocate terminating TD\n", tmp___28, tmp___26);
    }
    goto err_alloc_term_td;
  }
  {
#line 653
  i = 0;
  }
  {
#line 653
  while (1) {
    while_299_continue: /* CIL Label */ ;
#line 653
    if (! (i < 11)) {
      goto while_299_break;
    }
    {
#line 654
    uhci->skelqh[i] = uhci_alloc_qh(uhci, (struct usb_device *)((void *)0), (struct usb_host_endpoint *)((void *)0));
    }
#line 655
    if (! uhci->skelqh[i]) {
      {
#line 656
      tmp___29 = uhci_to_hcd(uhci);
#line 656
      tmp___30 = dev_name((struct device  const  *)tmp___29->self.controller);
#line 656
      tmp___31 = uhci_to_hcd(uhci);
#line 656
      tmp___32 = dev_driver_string((struct device  const  *)tmp___31->self.controller);
#line 656
      printk("<3>%s %s: unable to allocate QH\n", tmp___32, tmp___30);
      }
      goto err_alloc_skelqh;
    }
    {
#line 653
    i ++;
    }
  }
  while_299_break: /* CIL Label */ ;
  }
  {
#line 664
  i = 2;
  }
  {
#line 664
  while (1) {
    while_300_continue: /* CIL Label */ ;
#line 664
    if (! (i < 9)) {
      goto while_300_break;
    }
    {
#line 665
    (uhci->skelqh[i])->link = 2U | (uhci->skelqh[9])->dma_handle;
#line 664
    i ++;
    }
  }
  while_300_break: /* CIL Label */ ;
  }
  {
#line 666
  (uhci->skelqh[9])->link = 1U;
#line 667
  (uhci->skelqh[10])->link = 2U | (uhci->skelqh[10])->dma_handle;
#line 670
  uhci_fill_td(uhci->term_td, 0U, (unsigned int )(((2047 << 21) | (127 << 8)) | 105),
               0U);
#line 672
  (uhci->term_td)->link = 1U;
#line 673
  tmp___33 = (uhci->term_td)->dma_handle;
#line 673
  (uhci->skelqh[10])->element = tmp___33;
#line 673
  (uhci->skelqh[9])->element = tmp___33;
#line 680
  i = 0;
  }
  {
#line 680
  while (1) {
    while_301_continue: /* CIL Label */ ;
#line 680
    if (! (i < 1024)) {
      goto while_301_break;
    }
    {
#line 683
    *(uhci->frame + i) = uhci_frame_skel_link(uhci, i);
#line 680
    i ++;
    }
  }
  while_301_break: /* CIL Label */ ;
  }
  {
#line 690
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
#line 692
  configure_hc(uhci);
#line 693
  uhci->is_initialized = 1U;
#line 694
  start_rh(uhci);
  }
#line 695
  return (0);
  err_alloc_skelqh: 
  {
#line 701
  i = 0;
  }
  {
#line 701
  while (1) {
    while_302_continue: /* CIL Label */ ;
#line 701
    if (! (i < 11)) {
      goto while_302_break;
    }
#line 702
    if (uhci->skelqh[i]) {
      {
#line 703
      uhci_free_qh(uhci, uhci->skelqh[i]);
      }
    }
    {
#line 701
    i ++;
    }
  }
  while_302_break: /* CIL Label */ ;
  }
  {
#line 706
  uhci_free_td(uhci, uhci->term_td);
  }
  err_alloc_term_td: 
  {
#line 709
  dma_pool_destroy(uhci->qh_pool);
  }
  err_create_qh_pool: 
  {
#line 712
  dma_pool_destroy(uhci->td_pool);
  }
  err_create_td_pool: 
  {
#line 715
  kfree((void const   *)uhci->frame_cpu);
  }
  err_alloc_frame_cpu: 
  {
#line 718
  tmp___34 = uhci_to_hcd(uhci);
#line 718
  dma_free_coherent(tmp___34->self.controller, (unsigned int )(1024UL * sizeof(*(uhci->frame))),
                    (void *)uhci->frame, uhci->frame_dma_handle);
  }
  err_alloc_frame: 
  {
#line 723
  debugfs_remove(uhci->dentry);
  }
  err_create_debug_entry: 
#line 726
  return (retval);
}
}
#line 729 "uhci-hcd.c"
static void uhci_stop(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 731
  tmp = hcd_to_uhci(hcd);
#line 731
  uhci = tmp;
#line 733
  _spin_lock_irq(& uhci->lock);
#line 734
  tmp___0 = constant_test_bit(1U, (unsigned long const volatile   *)(& hcd->flags));
  }
#line 734
  if (tmp___0) {
#line 734
    if (! uhci->dead) {
      {
#line 735
      uhci_hc_died(uhci);
      }
    }
  }
  {
#line 736
  uhci_scan_schedule(uhci);
#line 737
  _spin_unlock_irq(& uhci->lock);
#line 739
  del_timer_sync(& uhci->fsbr_timer);
#line 740
  release_uhci(uhci);
  }
#line 741
  return;
}
}
#line 744 "uhci-hcd.c"
static int uhci_rh_suspend(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 746
  tmp = hcd_to_uhci(hcd);
#line 746
  uhci = tmp;
#line 747
  rc = 0;
#line 749
  _spin_lock_irq(& uhci->lock);
#line 750
  tmp___0 = constant_test_bit(1U, (unsigned long const volatile   *)(& hcd->flags));
  }
#line 750
  if (tmp___0) {
#line 752
    if (! uhci->dead) {
      {
#line 753
      suspend_rh(uhci, (enum uhci_rh_state )1);
      }
    }
  } else {
    {
#line 751
    rc = -108;
    }
  }
  {
#line 754
  _spin_unlock_irq(& uhci->lock);
  }
#line 755
  return (rc);
}
}
#line 758 "uhci-hcd.c"
static int uhci_rh_resume(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 760
  tmp = hcd_to_uhci(hcd);
#line 760
  uhci = tmp;
#line 761
  rc = 0;
#line 763
  _spin_lock_irq(& uhci->lock);
#line 764
  tmp___0 = constant_test_bit(1U, (unsigned long const volatile   *)(& hcd->flags));
  }
#line 764
  if (tmp___0) {
#line 766
    if (! uhci->dead) {
      {
#line 767
      wakeup_rh(uhci);
      }
    }
  } else {
    {
#line 765
    rc = -108;
    }
  }
  {
#line 768
  _spin_unlock_irq(& uhci->lock);
  }
#line 769
  return (rc);
}
}
#line 772 "uhci-hcd.c"
static int uhci_pci_suspend(struct usb_hcd *hcd , pm_message_t message ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  int rc ;
  struct usb_hcd *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct usb_hcd *tmp___6 ;
  char const   *tmp___7 ;
  struct usb_hcd *tmp___8 ;
  char const   *tmp___9 ;
  struct device  const  *__mptr ;
  struct usb_hcd *tmp___10 ;

  {
  {
#line 774
  tmp = hcd_to_uhci(hcd);
#line 774
  uhci = tmp;
#line 775
  rc = 0;
#line 779
  _spin_lock_irq(& uhci->lock);
#line 780
  tmp___4 = constant_test_bit(1U, (unsigned long const volatile   *)(& hcd->flags));
  }
#line 780
  if (tmp___4) {
#line 780
    if (uhci->dead) {
      goto done_okay;
    }
  } else {
    goto done_okay;
  }
#line 783
  if ((unsigned int )uhci->rh_state > 1U) {
    {
#line 784
    tmp___6 = uhci_to_hcd(uhci);
#line 784
    tmp___7 = dev_name((struct device  const  *)tmp___6->self.controller);
#line 784
    tmp___8 = uhci_to_hcd(uhci);
#line 784
    tmp___9 = dev_driver_string((struct device  const  *)tmp___8->self.controller);
#line 784
    printk("<4>%s %s: Root hub isn\'t suspended!\n", tmp___9, tmp___7);
#line 785
    rc = -16;
    }
    goto done;
  }
  {
#line 792
  tmp___10 = uhci_to_hcd(uhci);
#line 792
  __mptr = (struct device  const  *)tmp___10->self.controller;
#line 792
  pci_write_config_word((struct pci_dev *)((char *)__mptr - (unsigned int )(& ((struct pci_dev *)0)->dev)),
                        192, (unsigned short)0);
#line 793
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
#line 794
  hcd->poll_rh = 0U;
  }
#line 799
  if (message.event == 8) {
    {
#line 800
    uhci_hc_died(uhci);
    }
  }
  done_okay: 
  {
#line 803
  clear_bit(1, (unsigned long volatile   *)(& hcd->flags));
  }
  done: 
  {
#line 805
  _spin_unlock_irq(& uhci->lock);
  }
#line 806
  return (rc);
}
}
#line 809 "uhci-hcd.c"
static int uhci_pci_resume(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  struct usb_hcd *tmp___0 ;
  char const   *tmp___1 ;
  struct usb_hcd *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 811
  tmp = hcd_to_uhci(hcd);
#line 811
  uhci = tmp;
#line 818
  set_bit(1U, (unsigned long volatile   *)(& hcd->flags));
#line 819
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
#line 821
  _spin_lock_irq(& uhci->lock);
#line 829
  check_and_reset_hc(uhci);
#line 832
  configure_hc(uhci);
  }
#line 834
  if ((unsigned int )uhci->rh_state == 0U) {
    {
#line 837
    usb_root_hub_lost_power(hcd->self.root_hub);
#line 838
    suspend_rh(uhci, (enum uhci_rh_state )1);
    }
  }
  {
#line 841
  _spin_unlock_irq(& uhci->lock);
  }
#line 846
  if (! uhci->RD_enable) {
#line 846
    if ((hcd->self.root_hub)->do_remote_wakeup) {
      {
#line 847
      hcd->poll_rh = 1U;
#line 848
      usb_hcd_poll_rh_status(hcd);
      }
    }
  }
#line 850
  return (0);
}
}
#line 855 "uhci-hcd.c"
static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd , struct usb_host_endpoint *hep ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  struct uhci_qh *qh ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 858
  tmp = hcd_to_uhci(hcd);
#line 858
  uhci = tmp;
#line 861
  _spin_lock_irq(& uhci->lock);
#line 862
  qh = (struct uhci_qh *)hep->hcpriv;
  }
#line 863
  if ((unsigned long )qh == (unsigned long )((void *)0)) {
    goto done;
  }
  {
#line 866
  while (1) {
    while_303_continue: /* CIL Label */ ;
#line 866
    if (! (qh->state != 1)) {
      goto while_303_break;
    }
    {
#line 867
    (uhci->num_waiting) ++;
#line 868
    _spin_unlock_irq(& uhci->lock);
#line 869
    __ret = 0;
    }
#line 869
    if (! (qh->state == 1)) {
      {
#line 869
      while (1) {
        while_304_continue: /* CIL Label */ ;
        {
#line 869
        tmp___0 = get_current();
#line 869
        __wait.flags = 0U;
#line 869
        __wait.private = (void *)tmp___0;
#line 869
        __wait.func = & autoremove_wake_function;
#line 869
        __wait.task_list.next = & __wait.task_list;
#line 869
        __wait.task_list.prev = & __wait.task_list;
        }
        {
#line 869
        while (1) {
          while_305_continue: /* CIL Label */ ;
          {
#line 869
          prepare_to_wait(& uhci->waitqh, & __wait, 1);
          }
#line 869
          if (qh->state == 1) {
            goto while_305_break;
          }
          {
#line 869
          tmp___1 = get_current();
#line 869
          tmp___2 = signal_pending(tmp___1);
          }
#line 869
          if (! tmp___2) {
            {
#line 869
            schedule();
            }
            goto __Cont;
          }
          {
#line 869
          __ret = -512;
          }
          goto while_305_break;
          __Cont: /* CIL Label */ 
          {

          }
        }
        while_305_break: /* CIL Label */ ;
        }
        {
#line 869
        finish_wait(& uhci->waitqh, & __wait);
        }
        goto while_304_break;
      }
      while_304_break: /* CIL Label */ ;
      }
    }
    {
#line 871
    _spin_lock_irq(& uhci->lock);
#line 872
    (uhci->num_waiting) --;
    }
  }
  while_303_break: /* CIL Label */ ;
  }
  {
#line 875
  uhci_free_qh(uhci, qh);
  }
  done: 
  {
#line 877
  _spin_unlock_irq(& uhci->lock);
  }
#line 878
  return;
}
}
#line 880 "uhci-hcd.c"
static int uhci_hcd_get_frame_number(struct usb_hcd *hcd ) 
{ struct uhci_hcd *uhci ;
  struct uhci_hcd *tmp ;
  unsigned int frame_number ;
  unsigned int delta ;
  unsigned short tmp___0 ;

  {
  {
#line 882
  tmp = hcd_to_uhci(hcd);
#line 882
  uhci = tmp;
#line 887
  frame_number = uhci->frame_number;
#line 888
  __asm__  volatile   ("": : : "memory");
#line 889
  tmp___0 = inw((int )(uhci->io_addr + 6UL));
#line 889
  delta = ((unsigned int )tmp___0 - frame_number) & 1023U;
  }
#line 891
  return ((int )(frame_number + delta));
}
}
#line 894 "uhci-hcd.c"
static char const   hcd_name[9]  = 
#line 894
  {      (char const   )'u',      (char const   )'h',      (char const   )'c',      (char const   )'i', 
        (char const   )'_',      (char const   )'h',      (char const   )'c',      (char const   )'d', 
        (char const   )'\000'};
#line 896 "uhci-hcd.c"
static struct hc_driver  const  uhci_driver  = 
#line 896
     {hcd_name, "UHCI Host Controller", (size_t )sizeof(struct uhci_hcd ), & uhci_irq,
    16, & uhci_init, & uhci_start, & uhci_pci_suspend, & uhci_pci_resume, & uhci_stop,
    (void (*)(struct usb_hcd *hcd ))0, & uhci_hcd_get_frame_number, & uhci_urb_enqueue,
    & uhci_urb_dequeue, & uhci_hcd_endpoint_disable, (void (*)(struct usb_hcd *hcd ,
                                                               struct usb_host_endpoint *ep ))0,
    & uhci_hub_status_data, & uhci_hub_control, & uhci_rh_suspend, & uhci_rh_resume,
    (int (*)(struct usb_hcd * , unsigned int port_num ))0, (void (*)(struct usb_hcd * ,
                                                                     int  ))0, (int (*)(struct usb_hcd * ,
                                                                                        int  ))0,
    (void (*)(struct usb_hcd * , struct usb_host_endpoint * ))0};
#line 926 "uhci-hcd.c"
static struct pci_device_id  const  uhci_pci_ids[1]  = {      {(__u32 )(~ 0), (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )787200,
      (__u32 )(~ 0), (unsigned long )(& uhci_driver)}};
#line 935 "uhci-hcd.c"
static struct pci_driver uhci_pci_driver  = 
#line 935
     {{(struct list_head *)0, (struct list_head *)0}, (char *)(hcd_name), uhci_pci_ids,
    & usb_hcd_pci_probe, & usb_hcd_pci_remove, & usb_hcd_pci_suspend, (int (*)(struct pci_dev *dev ,
                                                                               pm_message_t state ))0,
    (int (*)(struct pci_dev *dev ))0, & usb_hcd_pci_resume, & uhci_shutdown, (struct pci_error_handlers *)0,
    {(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
     (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
     (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
     (struct attribute_group **)0, (struct dev_pm_ops *)0, (struct driver_private *)0},
    {{{0U}, 0U, 0U, (void *)0}, {(struct list_head *)0, (struct list_head *)0}}};
#line 949
static int uhci_hcd_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
#line 949 "uhci-hcd.c"
static int uhci_hcd_init(void) 
{ int retval ;
  int tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 951
  retval = -12;
#line 953
  tmp = 0 ;//usb_disabled();
  }
#line 953
  if (tmp) {
#line 954
    return (-19);
  }
#line 956
  if (ignore_oc) {
    {
#line 956
    tmp___0 = ", overcurrent ignored";
    }
  } else {
    {
#line 956
    tmp___0 = "";
    }
  }
  {
#line 956
  printk("<6>uhci_hcd: USB Universal Host Controller Interface driver%s\n", tmp___0);
#line 958
  set_bit(0U, (unsigned long volatile   *)(& usb_hcds_loaded));
#line 969
  uhci_up_cachep = kmem_cache_create("uhci_urb_priv", (unsigned int )sizeof(struct urb_priv ),
                                     0U, 0UL, (void (*)(void * ))((void *)0));
  }
#line 971
  if (! uhci_up_cachep) {
    goto up_failed;
  }
  {
#line 974
  retval = __pci_register_driver(& uhci_pci_driver, (struct module *)0, "SomeModule");
  }
#line 975
  if (retval) {
    goto init_failed;
  }
#line 978
  return (0);
  init_failed: 
  {
#line 981
  kmem_cache_destroy(uhci_up_cachep);
  }
  up_failed: 
  {
#line 984
  debugfs_remove(uhci_debugfs_root);
  }
  debug_failed: 
  {
#line 987
  kfree((void const   *)errbuf);
  }
  errbuf_failed: 
  {
#line 991
  clear_bit(0, (unsigned long volatile   *)(& usb_hcds_loaded));
  }
#line 992
  return (retval);
}
}
#line 995
static void uhci_hcd_cleanup(void)  __attribute__((__section__(".exit.text"))) ;
#line 995 "uhci-hcd.c"
static void uhci_hcd_cleanup(void) 
{ 

  {
  {
#line 997
  pci_unregister_driver(& uhci_pci_driver);
#line 998
  kmem_cache_destroy(uhci_up_cachep);
#line 999
  debugfs_remove(uhci_debugfs_root);
#line 1000
  kfree((void const   *)errbuf);
#line 1001
  clear_bit(0, (unsigned long volatile   *)(& usb_hcds_loaded));
  }
#line 1002
  return;
}
}
#line 1004 "uhci-hcd.c"
static int (*__initcall_uhci_hcd_init6)(void)  __attribute__((__section__(".initcall6.init")))  =    & uhci_hcd_init;
#line 1005 "uhci-hcd.c"
static void (*__exitcall_uhci_hcd_cleanup)(void)  __attribute__((__section__(".exitcall.exit")))  =    & uhci_hcd_cleanup;
