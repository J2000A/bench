/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

struct __anonstruct____missing_field_name_2 {
   unsigned long correct ;
   unsigned long incorrect ;
};
struct __anonstruct____missing_field_name_3 {
   unsigned long miss ;
   unsigned long hit ;
};
union __anonunion____missing_field_name_1 {
   struct __anonstruct____missing_field_name_2 __annonCompField1 ;
   struct __anonstruct____missing_field_name_3 __annonCompField2 ;
   unsigned long miss_hit[2] ;
};
struct ftrace_branch_data {
   char const   *func ;
   char const   *file ;
   unsigned int line ;
   union __anonunion____missing_field_name_1 __annonCompField3 ;
};
enum __anonenum_4 {
    false = 0,
    true = 1
} ;
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef unsigned short umode_t;
typedef u64 dma64_addr_t;
typedef u32 dma_addr_t;
struct __anonstruct___kernel_fd_set_5 {
   unsigned long fds_bits[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___kernel_fd_set_5 __kernel_fd_set;
typedef void (*__kernel_sighandler_t)(int  );
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char *__kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;
typedef long long __kernel_loff_t;
struct __anonstruct___kernel_fsid_t_6 {
   int val[2] ;
};
typedef struct __anonstruct___kernel_fsid_t_6 __kernel_fsid_t;
typedef __u32 __kernel_dev_t;
typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_mqd_t mqd_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
typedef unsigned long uintptr_t;
typedef __kernel_old_uid_t old_uid_t;
typedef __kernel_old_gid_t old_gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_ptrdiff_t ptrdiff_t;
typedef __kernel_time_t time_t;
typedef __kernel_clock_t clock_t;
typedef __kernel_caddr_t caddr_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
typedef unsigned long sector_t;
typedef unsigned long blkcnt_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;
typedef unsigned int gfp_t;
typedef unsigned int fmode_t;
typedef u32 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
typedef struct __anonstruct_atomic_t_7 atomic_t;
struct ustat {
   __kernel_daddr_t f_tfree ;
   __kernel_ino_t f_tinode ;
   char f_fname[6] ;
   char f_fpack[6] ;
};
struct task_struct;
struct mm_struct;
struct vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct revectored_struct {
   unsigned long __map[8] ;
};
struct vm86_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
};
struct vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
struct vm86plus_struct {
   struct vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
};
struct ptrace_bts_config {
   __u32 size ;
   __u32 flags ;
   __u32 signal ;
   __u32 bts_size ;
};
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);
struct obs_kernel_param {
   char const   *str ;
   int (*setup_func)(char * ) ;
   int early ;
};
struct cpuinfo_x86;
struct user_desc;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct kernel_vm86_struct {
   struct kernel_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct revectored_struct int_revectored ;
   struct revectored_struct int21_revectored ;
   struct vm86plus_info_struct vm86plus ;
   struct pt_regs *regs32 ;
};
union __anonunion____missing_field_name_8 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
struct _fpx_sw_bytes {
   __u32 magic1 ;
   __u32 extended_size ;
   __u64 xstate_bv ;
   __u32 xstate_size ;
   __u32 padding[7] ;
};
union __anonunion____missing_field_name_9 {
   __u32 reserved3[12] ;
   struct _fpx_sw_bytes sw_reserved ;
};
struct _fpstate {
   __u16 cwd ;
   __u16 swd ;
   __u16 twd ;
   __u16 fop ;
   __u64 rip ;
   __u64 rdp ;
   __u32 mxcsr ;
   __u32 mxcsr_mask ;
   __u32 st_space[32] ;
   __u32 xmm_space[64] ;
   __u32 reserved2[12] ;
   union __anonunion____missing_field_name_9 __annonCompField5 ;
};
struct sigcontext {
   unsigned long r8 ;
   unsigned long r9 ;
   unsigned long r10 ;
   unsigned long r11 ;
   unsigned long r12 ;
   unsigned long r13 ;
   unsigned long r14 ;
   unsigned long r15 ;
   unsigned long di ;
   unsigned long si ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long dx ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long sp ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   unsigned long err ;
   unsigned long trapno ;
   unsigned long oldmask ;
   unsigned long cr2 ;
   void *fpstate ;
   unsigned long reserved1[8] ;
};
struct _xsave_hdr {
   __u64 xstate_bv ;
   __u64 reserved1[2] ;
   __u64 reserved2[5] ;
};
struct _ymmh_state {
   __u32 ymmh_space[64] ;
};
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
struct alt_instr {
   u8 *instr ;
   u8 *replacement ;
   u8 cpuid ;
   u8 instrlen ;
   u8 replacementlen ;
   u8 pad1 ;
};
struct module;
struct paravirt_patch_site;
struct __xchg_dummy {
   unsigned long a[100] ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct ratelimit_state {
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   char primary_hash ;
   char secondary_hash ;
   unsigned int lineno : 24 ;
   unsigned int flags : 8 ;
} __attribute__((__aligned__(8))) ;
struct bug_entry {
   unsigned long bug_addr ;
   char const   *file ;
   unsigned short line ;
   unsigned short flags ;
};
struct completion;
struct user;
struct atomic_notifier_head;
struct pid;
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4,
    SYSTEM_SUSPEND_DISK = 5
} ;
enum __anonenum_10 {
    DUMP_PREFIX_NONE = 0,
    DUMP_PREFIX_ADDRESS = 1,
    DUMP_PREFIX_OFFSET = 2
} ;
struct sysinfo;
struct sysinfo {
   long uptime ;
   unsigned long loads[3] ;
   unsigned long totalram ;
   unsigned long freeram ;
   unsigned long sharedram ;
   unsigned long bufferram ;
   unsigned long totalswap ;
   unsigned long freeswap ;
   unsigned short procs ;
   unsigned short pad ;
   unsigned long totalhigh ;
   unsigned long freehigh ;
   unsigned int mem_unit ;
   char _f[(20UL - 2UL * sizeof(long )) - sizeof(int )] ;
};
struct tss_struct;
struct page;
typedef unsigned long pteval_t;
typedef unsigned long pmdval_t;
typedef unsigned long pudval_t;
typedef unsigned long pgdval_t;
typedef unsigned long pgprotval_t;
union __anonunion_pte_t_11 {
   pteval_t pte ;
   pteval_t pte_low ;
};
typedef union __anonunion_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct __anonstruct_pud_t_13 {
   pgd_t pgd ;
};
typedef struct __anonstruct_pud_t_13 pud_t;
struct __anonstruct_pmd_t_14 {
   pud_t pud ;
};
typedef struct __anonstruct_pmd_t_14 pmd_t;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
enum __anonenum_15 {
    PG_LEVEL_NONE = 0,
    PG_LEVEL_4K = 1,
    PG_LEVEL_2M = 2,
    PG_LEVEL_1G = 3,
    PG_LEVEL_NUM = 4
} ;
struct __anonstruct____missing_field_name_17 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct____missing_field_name_18 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
union __anonunion____missing_field_name_16 {
   struct __anonstruct____missing_field_name_17 __annonCompField6 ;
   struct __anonstruct____missing_field_name_18 __annonCompField7 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_16 __annonCompField8 ;
} __attribute__((__packed__)) ;
enum __anonenum_19 {
    GATE_INTERRUPT = 14,
    GATE_TRAP = 15,
    GATE_CALL = 12,
    GATE_TASK = 5
} ;
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned int ist : 3 ;
   unsigned int zero0 : 5 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
enum __anonenum_20 {
    DESC_TSS = 9,
    DESC_LDT = 2,
    DESCTYPE_S = 16
} ;
struct ldttss_desc64 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 5 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit1 : 4 ;
   unsigned int zero0 : 3 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
   u32 base3 ;
   u32 zero1 ;
} __attribute__((__packed__)) ;
typedef struct desc_struct gate_desc;
typedef struct desc_struct ldt_desc;
typedef struct desc_struct tss_desc;
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
} __attribute__((__packed__)) ;
struct exec_domain;
enum __anonenum_21 {
    ADDR_NO_RANDOMIZE = 262144,
    FDPIC_FUNCPTRS = 524288,
    MMAP_PAGE_ZERO = 1048576,
    ADDR_COMPAT_LAYOUT = 2097152,
    READ_IMPLIES_EXEC = 4194304,
    ADDR_LIMIT_32BIT = 8388608,
    SHORT_INODE = 16777216,
    WHOLE_SECONDS = 33554432,
    STICKY_TIMEOUTS = 67108864,
    ADDR_LIMIT_3GB = 134217728
} ;
enum __anonenum_22 {
    PER_LINUX = 0,
    PER_LINUX_32BIT = 8388608,
    PER_LINUX_FDPIC = 524288,
    PER_SVR4 = 68157441,
    PER_SVR3 = 83886082,
    PER_SCOSVR3 = 117440515,
    PER_OSR5 = 100663299,
    PER_WYSEV386 = 83886084,
    PER_ISCR4 = 67108869,
    PER_BSD = 6,
    PER_SUNOS = 67108870,
    PER_XENIX = 83886087,
    PER_LINUX32 = 8,
    PER_LINUX32_3GB = 134217736,
    PER_IRIX32 = 67108873,
    PER_IRIXN32 = 67108874,
    PER_IRIX64 = 67108875,
    PER_RISCOS = 12,
    PER_SOLARIS = 67108877,
    PER_UW7 = 68157454,
    PER_OSF4 = 15,
    PER_HPUX = 16,
    PER_MASK = 255
} ;
typedef void (*handler_t)(int  , struct pt_regs * );
struct map_segment;
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
struct cpumask {
   unsigned long bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask cpumask_var_t[1];
struct cpuinfo_x86 {
   __u8 x86 ;
   __u8 x86_vendor ;
   __u8 x86_model ;
   __u8 x86_mask ;
   char wp_works_ok ;
   char hlt_works_ok ;
   char hard_math ;
   char rfu ;
   char fdiv_bug ;
   char f00f_bug ;
   char coma_bug ;
   char pad0 ;
   __u8 x86_virt_bits ;
   __u8 x86_phys_bits ;
   __u8 x86_coreid_bits ;
   __u32 extended_cpuid_level ;
   int cpuid_level ;
   __u32 x86_capability[9] ;
   char x86_vendor_id[16] ;
   char x86_model_id[64] ;
   int x86_cache_size ;
   int x86_cache_alignment ;
   int x86_power ;
   unsigned long loops_per_jiffy ;
   cpumask_var_t llc_shared_map ;
   u16 x86_max_cores ;
   u16 apicid ;
   u16 initial_apicid ;
   u16 x86_clflush_size ;
   u16 booted_cores ;
   u16 phys_proc_id ;
   u16 cpu_core_id ;
   u16 cpu_index ;
   unsigned int x86_hyper_vendor ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct seq_operations;
struct x86_hw_tss {
   unsigned short back_link ;
   unsigned short __blh ;
   unsigned long sp0 ;
   unsigned short ss0 ;
   unsigned short __ss0h ;
   unsigned long sp1 ;
   unsigned short ss1 ;
   unsigned short __ss1h ;
   unsigned long sp2 ;
   unsigned short ss2 ;
   unsigned short __ss2h ;
   unsigned long __cr3 ;
   unsigned long ip ;
   unsigned long flags ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long bx ;
   unsigned long sp ;
   unsigned long bp ;
   unsigned long si ;
   unsigned long di ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short ldt ;
   unsigned short __ldth ;
   unsigned short trace ;
   unsigned short io_bitmap_base ;
} __attribute__((__packed__)) ;
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[8192UL / sizeof(long ) + 1UL] ;
   unsigned long stack[64] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct orig_ist {
   unsigned long ist[7] ;
};
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_24 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_25 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_23 {
   struct __anonstruct____missing_field_name_24 __annonCompField9 ;
   struct __anonstruct____missing_field_name_25 __annonCompField10 ;
};
union __anonunion____missing_field_name_26 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_23 __annonCompField11 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_26 __annonCompField12 ;
} __attribute__((__aligned__(16))) ;
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct ymmh_struct {
   u32 ymmh_space[64] ;
};
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
} __attribute__((__packed__, __aligned__(64))) ;
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
struct kmem_cache;
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long sysenter_cs ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   struct vm86_struct *vm86_info ;
   unsigned long screen_bitmap ;
   unsigned long v86flags ;
   unsigned long v86mask ;
   unsigned long saved_sp0 ;
   unsigned int saved_fs ;
   unsigned int saved_gs ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
};
struct __anonstruct_mm_segment_t_27 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_27 mm_segment_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct timespec;
struct compat_timespec;
struct __anonstruct____missing_field_name_29 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
struct __anonstruct_futex_30 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
struct __anonstruct_nanosleep_31 {
   clockid_t index ;
   struct timespec *rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_32 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField13 ;
   struct __anonstruct_futex_30 futex ;
   struct __anonstruct_nanosleep_31 nanosleep ;
   struct __anonstruct_poll_32 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
};
typedef atomic_t atomic_long_t;
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
   unsigned long previous_esp ;
   __u8 supervisor_stack[0] ;
   int uaccess_err ;
};
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct_raw_rwlock_t_33 {
   unsigned int lock ;
};
typedef struct __anonstruct_raw_rwlock_t_33 raw_rwlock_t;
struct lockdep_map;
struct lock_class_key {

};
struct __anonstruct_spinlock_t_34 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_34 spinlock_t;
struct __anonstruct_rwlock_t_35 {
   raw_rwlock_t raw_lock ;
};
typedef struct __anonstruct_rwlock_t_35 rwlock_t;
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key );
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
struct wait_bit_key {
   void *flags ;
   int bit_nr ;
};
struct wait_bit_queue {
   struct wait_bit_key key ;
   wait_queue_t wait ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct resource_list {
   struct resource_list *next ;
   struct resource *res ;
   struct pci_dev *dev ;
};
struct device;
struct kobject;
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
struct vm_area_struct;
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct sysfs_dirent;
struct kref {
   atomic_t refcount ;
};
enum kobject_action {
    KOBJ_ADD = 0,
    KOBJ_REMOVE = 1,
    KOBJ_CHANGE = 2,
    KOBJ_MOVE = 3,
    KOBJ_ONLINE = 4,
    KOBJ_OFFLINE = 5,
    KOBJ_MAX = 6
} ;
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
struct kobj_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct kobject *kobj , struct kobj_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct kobject *kobj , struct kobj_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct klist_iter {
   struct klist *i_klist ;
   struct klist_node *i_cur ;
};
struct stat {
   unsigned long st_dev ;
   unsigned long st_ino ;
   unsigned long st_nlink ;
   unsigned int st_mode ;
   unsigned int st_uid ;
   unsigned int st_gid ;
   unsigned int __pad0 ;
   unsigned long st_rdev ;
   long st_size ;
   long st_blksize ;
   long st_blocks ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned long st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   long __unused[3] ;
};
struct __old_kernel_stat {
   unsigned short st_dev ;
   unsigned short st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned short st_rdev ;
   unsigned int st_size ;
   unsigned int st_atime ;
   unsigned int st_mtime ;
   unsigned int st_ctime ;
};
struct __anonstruct_seqlock_t_36 {
   unsigned int sequence ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_36 seqlock_t;
struct seqcount {
   unsigned int sequence ;
};
typedef struct seqcount seqcount_t;
union __anonunion_d_37 {
   u64 v64 ;
   u32 v32[2] ;
};
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
struct itimerval;
struct tms;
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
struct __anonstruct_nodemask_t_38 {
   unsigned long bits[((1UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct __anonstruct_nodemask_t_38 nodemask_t;
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
} ;
enum pageblock_bits {
    PB_migrate = 0,
    PB_migrate_end = 2,
    NR_PAGEBLOCK_BITS = 3
} ;
struct free_area {
   struct list_head free_list[5] ;
   unsigned long nr_free ;
};
struct pglist_data;
struct zone_padding {
   char x[0] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum zone_stat_item {
    NR_FREE_PAGES = 0,
    NR_LRU_BASE = 1,
    NR_INACTIVE_ANON = 1,
    NR_ACTIVE_ANON = 2,
    NR_INACTIVE_FILE = 3,
    NR_ACTIVE_FILE = 4,
    NR_UNEVICTABLE = 5,
    NR_MLOCK = 6,
    NR_ANON_PAGES = 7,
    NR_FILE_MAPPED = 8,
    NR_FILE_PAGES = 9,
    NR_FILE_DIRTY = 10,
    NR_WRITEBACK = 11,
    NR_SLAB_RECLAIMABLE = 12,
    NR_SLAB_UNRECLAIMABLE = 13,
    NR_PAGETABLE = 14,
    NR_UNSTABLE_NFS = 15,
    NR_BOUNCE = 16,
    NR_VMSCAN_WRITE = 17,
    NR_WRITEBACK_TEMP = 18,
    NR_VM_ZONE_STAT_ITEMS = 19
} ;
enum lru_list {
    LRU_INACTIVE_ANON = 0,
    LRU_ACTIVE_ANON = 1,
    LRU_INACTIVE_FILE = 2,
    LRU_ACTIVE_FILE = 3,
    LRU_UNEVICTABLE = 4,
    NR_LRU_LISTS = 5
} ;
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head list ;
};
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 stat_threshold ;
   s8 vm_stat_diff[19] ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum zone_type {
    ZONE_DMA = 0,
    ZONE_NORMAL = 1,
    ZONE_HIGHMEM = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
struct zone_reclaim_stat {
   unsigned long recent_rotated[2] ;
   unsigned long recent_scanned[2] ;
};
struct __anonstruct_lru_39 {
   struct list_head list ;
   unsigned long nr_scan ;
};
struct zone {
   unsigned long pages_min ;
   unsigned long pages_low ;
   unsigned long pages_high ;
   unsigned long lowmem_reserve[4] ;
   struct per_cpu_pageset pageset[8] ;
   spinlock_t lock ;
   struct free_area free_area[11] ;
   unsigned long *pageblock_flags ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   struct __anonstruct_lru_39 lru[5] ;
   struct zone_reclaim_stat reclaim_stat ;
   unsigned long pages_scanned ;
   unsigned long flags ;
   atomic_long_t vm_stat[19] ;
   int prev_priority ;
   unsigned int inactive_ratio ;
   struct zone_padding _pad2_ ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct pglist_data *zone_pgdat ;
   unsigned long zone_start_pfn ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
enum __anonenum_zone_flags_t_40 {
    ZONE_ALL_UNRECLAIMABLE = 0,
    ZONE_RECLAIM_LOCKED = 1,
    ZONE_OOM_LOCKED = 2
} ;
typedef enum __anonenum_zone_flags_t_40 zone_flags_t;
struct zonelist_cache;
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[5] ;
};
struct node_active_region {
   unsigned long start_pfn ;
   unsigned long end_pfn ;
   int nid ;
};
struct bootmem_data;
struct pglist_data {
   struct zone node_zones[4] ;
   struct zonelist node_zonelists[1] ;
   int nr_zones ;
   struct page *node_mem_map ;
   struct bootmem_data *bdata ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
};
typedef struct pglist_data pg_data_t;
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
};
struct rw_semaphore;
struct rwsem_waiter;
struct rw_semaphore {
   long count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
struct srcu_struct_array {
   int c[2] ;
};
struct srcu_struct {
   int completed ;
   struct srcu_struct_array *per_cpu_ref ;
   struct mutex mutex ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
struct atomic_notifier_head {
   spinlock_t lock ;
   struct notifier_block *head ;
};
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
struct raw_notifier_head {
   struct notifier_block *head ;
};
struct srcu_notifier_head {
   struct mutex mutex ;
   struct srcu_struct srcu ;
   struct notifier_block *head ;
};
struct mem_section;
enum memmap_context {
    MEMMAP_EARLY = 0,
    MEMMAP_HOTPLUG = 1
} ;
struct ctl_table;
struct call_single_data {
   struct list_head list ;
   void (*func)(void *info ) ;
   void *info ;
   u16 flags ;
   u16 priv ;
};
struct mpf_intel {
   char signature[4] ;
   unsigned int physptr ;
   unsigned char length ;
   unsigned char specification ;
   unsigned char checksum ;
   unsigned char feature1 ;
   unsigned char feature2 ;
   unsigned char feature3 ;
   unsigned char feature4 ;
   unsigned char feature5 ;
};
struct mpc_table {
   char signature[4] ;
   unsigned short length ;
   char spec ;
   char checksum ;
   char oem[8] ;
   char productid[12] ;
   unsigned int oemptr ;
   unsigned short oemsize ;
   unsigned short oemcount ;
   unsigned int lapic ;
   unsigned int reserved ;
};
struct mpc_cpu {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char cpuflag ;
   unsigned int cpufeature ;
   unsigned int featureflag ;
   unsigned int reserved[2] ;
};
struct mpc_bus {
   unsigned char type ;
   unsigned char busid ;
   unsigned char bustype[6] ;
};
struct mpc_ioapic {
   unsigned char type ;
   unsigned char apicid ;
   unsigned char apicver ;
   unsigned char flags ;
   unsigned int apicaddr ;
};
struct mpc_intsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbus ;
   unsigned char srcbusirq ;
   unsigned char dstapic ;
   unsigned char dstirq ;
};
enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3
} ;
struct mpc_lintsrc {
   unsigned char type ;
   unsigned char irqtype ;
   unsigned short irqflag ;
   unsigned char srcbusid ;
   unsigned char srcbusirq ;
   unsigned char destapic ;
   unsigned char destapiclint ;
};
struct mpc_oemtable {
   char signature[4] ;
   unsigned short length ;
   char rev ;
   char checksum ;
   char mpc[8] ;
};
enum mp_bustype {
    MP_BUS_ISA = 1,
    MP_BUS_EISA = 2,
    MP_BUS_PCI = 3,
    MP_BUS_MCA = 4
} ;
struct physid_mask {
   unsigned long mask[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct physid_mask physid_mask_t;
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3
} ;
struct __anonstruct___reserved_01_41 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_02_42 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_id_43 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_apic_id : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_version_44 {
   unsigned int version : 8 ;
   unsigned int __reserved_1 : 8 ;
   unsigned int max_lvt : 8 ;
   unsigned int __reserved_2 : 8 ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_03_45 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_04_46 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_05_47 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_06_48 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_tpr_49 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_apr_50 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_ppr_51 {
   unsigned int priority : 8 ;
   unsigned int __reserved_1 : 24 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_eoi_52 {
   unsigned int eoi ;
   unsigned int __reserved[3] ;
};
struct __anonstruct___reserved_07_53 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_ldr_54 {
   unsigned int __reserved_1 : 24 ;
   unsigned int logical_dest : 8 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_dfr_55 {
   unsigned int __reserved_1 : 28 ;
   unsigned int model : 4 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_svr_56 {
   unsigned int spurious_vector : 8 ;
   unsigned int apic_enabled : 1 ;
   unsigned int focus_cpu : 1 ;
   unsigned int __reserved_2 : 22 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_isr_57 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_tmr_58 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_irr_59 {
   unsigned int bitfield ;
   unsigned int __reserved[3] ;
};
struct __anonstruct_error_bits_61 {
   unsigned int send_cs_error : 1 ;
   unsigned int receive_cs_error : 1 ;
   unsigned int send_accept_error : 1 ;
   unsigned int receive_accept_error : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int send_illegal_vector : 1 ;
   unsigned int receive_illegal_vector : 1 ;
   unsigned int illegal_register_address : 1 ;
   unsigned int __reserved_2 : 24 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_all_errors_62 {
   unsigned int errors ;
   unsigned int __reserved_3[3] ;
};
union __anonunion_esr_60 {
   struct __anonstruct_error_bits_61 error_bits ;
   struct __anonstruct_all_errors_62 all_errors ;
};
struct __anonstruct___reserved_08_63 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_09_64 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_10_65 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_11_66 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_12_67 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_13_68 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_14_69 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_icr1_70 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int destination_mode : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int level : 1 ;
   unsigned int trigger : 1 ;
   unsigned int __reserved_2 : 2 ;
   unsigned int shorthand : 2 ;
   unsigned int __reserved_3 : 12 ;
   unsigned int __reserved_4[3] ;
};
union __anonunion_dest_72 {
   unsigned int __reserved_1 : 24 ;
   unsigned int phys_dest : 4 ;
   unsigned int __reserved_2 : 4 ;
   unsigned int __reserved_3 : 24 ;
   unsigned int logical_dest : 8 ;
};
struct __anonstruct_icr2_71 {
   union __anonunion_dest_72 dest ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_timer_73 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int timer_mode : 1 ;
   unsigned int __reserved_3 : 14 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_thermal_74 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_pc_75 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_lvt_lint0_76 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_lint1_77 {
   unsigned int vector : 8 ;
   unsigned int delivery_mode : 3 ;
   unsigned int __reserved_1 : 1 ;
   unsigned int delivery_status : 1 ;
   unsigned int polarity : 1 ;
   unsigned int remote_irr : 1 ;
   unsigned int trigger : 1 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_2 : 15 ;
   unsigned int __reserved_3[3] ;
};
struct __anonstruct_lvt_error_78 {
   unsigned int vector : 8 ;
   unsigned int __reserved_1 : 4 ;
   unsigned int delivery_status : 1 ;
   unsigned int __reserved_2 : 3 ;
   unsigned int mask : 1 ;
   unsigned int __reserved_3 : 15 ;
   unsigned int __reserved_4[3] ;
};
struct __anonstruct_timer_icr_79 {
   unsigned int initial_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct_timer_ccr_80 {
   unsigned int curr_count ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_16_81 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_17_82 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_18_83 {
   unsigned int __reserved[4] ;
};
struct __anonstruct___reserved_19_84 {
   unsigned int __reserved[4] ;
};
struct __anonstruct_timer_dcr_85 {
   unsigned int divisor : 4 ;
   unsigned int __reserved_1 : 28 ;
   unsigned int __reserved_2[3] ;
};
struct __anonstruct___reserved_20_86 {
   unsigned int __reserved[4] ;
};
struct local_apic {
   struct __anonstruct___reserved_01_41 __reserved_01 ;
   struct __anonstruct___reserved_02_42 __reserved_02 ;
   struct __anonstruct_id_43 id ;
   struct __anonstruct_version_44  const  version ;
   struct __anonstruct___reserved_03_45 __reserved_03 ;
   struct __anonstruct___reserved_04_46 __reserved_04 ;
   struct __anonstruct___reserved_05_47 __reserved_05 ;
   struct __anonstruct___reserved_06_48 __reserved_06 ;
   struct __anonstruct_tpr_49 tpr ;
   struct __anonstruct_apr_50  const  apr ;
   struct __anonstruct_ppr_51  const  ppr ;
   struct __anonstruct_eoi_52 eoi ;
   struct __anonstruct___reserved_07_53 __reserved_07 ;
   struct __anonstruct_ldr_54 ldr ;
   struct __anonstruct_dfr_55 dfr ;
   struct __anonstruct_svr_56 svr ;
   struct __anonstruct_isr_57 isr[8] ;
   struct __anonstruct_tmr_58 tmr[8] ;
   struct __anonstruct_irr_59 irr[8] ;
   union __anonunion_esr_60 esr ;
   struct __anonstruct___reserved_08_63 __reserved_08 ;
   struct __anonstruct___reserved_09_64 __reserved_09 ;
   struct __anonstruct___reserved_10_65 __reserved_10 ;
   struct __anonstruct___reserved_11_66 __reserved_11 ;
   struct __anonstruct___reserved_12_67 __reserved_12 ;
   struct __anonstruct___reserved_13_68 __reserved_13 ;
   struct __anonstruct___reserved_14_69 __reserved_14 ;
   struct __anonstruct_icr1_70 icr1 ;
   struct __anonstruct_icr2_71 icr2 ;
   struct __anonstruct_lvt_timer_73 lvt_timer ;
   struct __anonstruct_lvt_thermal_74 lvt_thermal ;
   struct __anonstruct_lvt_pc_75 lvt_pc ;
   struct __anonstruct_lvt_lint0_76 lvt_lint0 ;
   struct __anonstruct_lvt_lint1_77 lvt_lint1 ;
   struct __anonstruct_lvt_error_78 lvt_error ;
   struct __anonstruct_timer_icr_79 timer_icr ;
   struct __anonstruct_timer_ccr_80  const  timer_ccr ;
   struct __anonstruct___reserved_16_81 __reserved_16 ;
   struct __anonstruct___reserved_17_82 __reserved_17 ;
   struct __anonstruct___reserved_18_83 __reserved_18 ;
   struct __anonstruct___reserved_19_84 __reserved_19 ;
   struct __anonstruct_timer_dcr_85 timer_dcr ;
   struct __anonstruct___reserved_20_86 __reserved_20 ;
} __attribute__((__packed__)) ;
struct __anonstruct_mm_context_t_87 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_87 mm_context_t;
struct bootnode;
enum km_type {
    KM_BOUNCE_READ = 0,
    KM_SKB_SUNRPC_DATA = 1,
    KM_SKB_DATA_SOFTIRQ = 2,
    KM_USER0 = 3,
    KM_USER1 = 4,
    KM_BIO_SRC_IRQ = 5,
    KM_BIO_DST_IRQ = 6,
    KM_PTE0 = 7,
    KM_PTE1 = 8,
    KM_IRQ0 = 9,
    KM_IRQ1 = 10,
    KM_SOFTIRQ0 = 11,
    KM_SOFTIRQ1 = 12,
    KM_TYPE_NR = 13
} ;
enum fixed_addresses {
    FIX_HOLE = 0,
    FIX_VDSO = 1,
    FIX_DBGP_BASE = 2,
    FIX_EARLYCON_MEM_BASE = 3,
    FIX_APIC_BASE = 4,
    FIX_IO_APIC_BASE_0 = 5,
    FIX_IO_APIC_BASE_END = 68,
    FIX_KMAP_BEGIN = 69,
    FIX_KMAP_END = 172,
    FIX_PCIE_MCFG = 173,
    FIX_TEXT_POKE0 = 174,
    FIX_TEXT_POKE1 = 175,
    __end_of_permanent_fixed_addresses = 176,
    FIX_OHCI1394_BASE = 177,
    FIX_BTMAP_END = 256,
    FIX_BTMAP_BEGIN = 511,
    FIX_WP_TEST = 512,
    __end_of_fixed_addresses = 513
} ;
struct apic {
   char *name ;
   int (*probe)(void) ;
   int (*acpi_madt_oem_check)(char *oem_id , char *oem_table_id ) ;
   int (*apic_id_registered)(void) ;
   u32 irq_delivery_mode ;
   u32 irq_dest_mode ;
   struct cpumask  const  *(*target_cpus)(void) ;
   int disable_esr ;
   int dest_logical ;
   unsigned long (*check_apicid_used)(physid_mask_t bitmap , int apicid ) ;
   unsigned long (*check_apicid_present)(int apicid ) ;
   void (*vector_allocation_domain)(int cpu , struct cpumask *retmask ) ;
   void (*init_apic_ldr)(void) ;
   physid_mask_t (*ioapic_phys_id_map)(physid_mask_t map ) ;
   void (*setup_apic_routing)(void) ;
   int (*multi_timer_check)(int apic , int irq ) ;
   int (*apicid_to_node)(int logical_apicid ) ;
   int (*cpu_to_logical_apicid)(int cpu ) ;
   int (*cpu_present_to_apicid)(int mps_cpu ) ;
   physid_mask_t (*apicid_to_cpu_present)(int phys_apicid ) ;
   void (*setup_portio_remap)(void) ;
   int (*check_phys_apicid_present)(int boot_cpu_physical_apicid ) ;
   void (*enable_apic_mode)(void) ;
   int (*phys_pkg_id)(int cpuid_apic , int index_msb ) ;
   int (*mps_oem_check)(struct mpc_table *mpc , char *oem , char *productid ) ;
   unsigned int (*get_apic_id)(unsigned long x ) ;
   unsigned long (*set_apic_id)(unsigned int id ) ;
   unsigned long apic_id_mask ;
   unsigned int (*cpu_mask_to_apicid)(struct cpumask  const  *cpumask ) ;
   unsigned int (*cpu_mask_to_apicid_and)(struct cpumask  const  *cpumask , struct cpumask  const  *andmask ) ;
   void (*send_IPI_mask)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_mask_allbutself)(struct cpumask  const  *mask , int vector ) ;
   void (*send_IPI_allbutself)(int vector ) ;
   void (*send_IPI_all)(int vector ) ;
   void (*send_IPI_self)(int vector ) ;
   int (*wakeup_secondary_cpu)(int apicid , unsigned long start_eip ) ;
   int trampoline_phys_low ;
   int trampoline_phys_high ;
   void (*wait_for_init_deassert)(atomic_t *deassert ) ;
   void (*smp_callin_clear_local_apic)(void) ;
   void (*inquire_remote_apic)(int apicid ) ;
   u32 (*read)(u32 reg ) ;
   void (*write)(u32 reg , u32 v ) ;
   u64 (*icr_read)(void) ;
   void (*icr_write)(u32 low , u32 high ) ;
   void (*wait_icr_idle)(void) ;
   u32 (*safe_wait_icr_idle)(void) ;
};
struct __anonstruct_bits_88 {
   u32 __reserved_2 : 14 ;
   u32 LTS : 1 ;
   u32 delivery_type : 1 ;
   u32 __reserved_1 : 8 ;
   u32 ID : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_00 {
   u32 raw ;
   struct __anonstruct_bits_88 bits ;
};
struct __anonstruct_bits_89 {
   u32 version : 8 ;
   u32 __reserved_2 : 7 ;
   u32 PRQ : 1 ;
   u32 entries : 8 ;
   u32 __reserved_1 : 8 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_01 {
   u32 raw ;
   struct __anonstruct_bits_89 bits ;
};
struct __anonstruct_bits_90 {
   u32 __reserved_2 : 24 ;
   u32 arbitration : 4 ;
   u32 __reserved_1 : 4 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_02 {
   u32 raw ;
   struct __anonstruct_bits_90 bits ;
};
struct __anonstruct_bits_91 {
   u32 boot_DT : 1 ;
   u32 __reserved_1 : 31 ;
} __attribute__((__packed__)) ;
union IO_APIC_reg_03 {
   u32 raw ;
   struct __anonstruct_bits_91 bits ;
};
enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7
} ;
struct IO_APIC_route_entry {
   __u32 vector : 8 ;
   __u32 delivery_mode : 3 ;
   __u32 dest_mode : 1 ;
   __u32 delivery_status : 1 ;
   __u32 polarity : 1 ;
   __u32 irr : 1 ;
   __u32 trigger : 1 ;
   __u32 mask : 1 ;
   __u32 __reserved_2 : 15 ;
   __u32 __reserved_3 : 24 ;
   __u32 dest : 8 ;
} __attribute__((__packed__)) ;
struct IR_IO_APIC_route_entry {
   __u64 vector : 8 ;
   __u64 zero : 3 ;
   __u64 index2 : 1 ;
   __u64 delivery_status : 1 ;
   __u64 polarity : 1 ;
   __u64 irr : 1 ;
   __u64 trigger : 1 ;
   __u64 mask : 1 ;
   __u64 reserved : 31 ;
   __u64 format : 1 ;
   __u64 index : 15 ;
} __attribute__((__packed__)) ;
struct __anonstruct_stack_start_92 {
   void *sp ;
   unsigned short ss ;
};
struct smp_ops {
   void (*smp_prepare_boot_cpu)(void) ;
   void (*smp_prepare_cpus)(unsigned int max_cpus ) ;
   void (*smp_cpus_done)(unsigned int max_cpus ) ;
   void (*smp_send_stop)(void) ;
   void (*smp_send_reschedule)(int cpu ) ;
   int (*cpu_up)(unsigned int cpu ) ;
   int (*cpu_disable)(void) ;
   void (*cpu_die)(unsigned int cpu ) ;
   void (*play_dead)(void) ;
   void (*send_call_func_ipi)(struct cpumask  const  *mask ) ;
   void (*send_call_func_single_ipi)(int cpu ) ;
};
struct pci_bus;
struct key;
struct subprocess_info;
enum umh_wait {
    UMH_NO_WAIT = -1,
    UMH_WAIT_EXEC = 0,
    UMH_WAIT_PROC = 1
} ;
struct user_i387_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
};
struct user_fxsr_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long reserved ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
};
struct user_regs_struct {
   unsigned long bx ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long bp ;
   unsigned long ax ;
   unsigned long ds ;
   unsigned long es ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   struct user_i387_struct i387 ;
   unsigned long u_tsize ;
   unsigned long u_dsize ;
   unsigned long u_ssize ;
   unsigned long start_code ;
   unsigned long start_stack ;
   long signal ;
   int reserved ;
   unsigned long u_ar0 ;
   struct user_i387_struct *u_fpstate ;
   unsigned long magic ;
   char u_comm[32] ;
   int u_debugreg[8] ;
};
typedef unsigned long elf_greg_t;
typedef elf_greg_t elf_gregset_t[sizeof(struct user_regs_struct ) / sizeof(elf_greg_t )];
typedef struct user_i387_struct elf_fpregset_t;
struct user_desc {
   unsigned int entry_number ;
   unsigned int base_addr ;
   unsigned int limit ;
   unsigned int seg_32bit : 1 ;
   unsigned int contents : 2 ;
   unsigned int read_exec_only : 1 ;
   unsigned int limit_in_pages : 1 ;
   unsigned int seg_not_present : 1 ;
   unsigned int useable : 1 ;
   unsigned int lm : 1 ;
};
struct gdt_page {
   struct desc_struct gdt[32] ;
} __attribute__((__aligned__((1) <<  (12) ))) ;
struct linux_binprm;
typedef __u32 Elf32_Addr;
typedef __u16 Elf32_Half;
typedef __u32 Elf32_Off;
typedef __s32 Elf32_Sword;
typedef __u32 Elf32_Word;
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __s16 Elf64_SHalf;
typedef __u64 Elf64_Off;
typedef __s32 Elf64_Sword;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
typedef __s64 Elf64_Sxword;
union __anonunion_d_un_93 {
   Elf32_Sword d_val ;
   Elf32_Addr d_ptr ;
};
struct dynamic {
   Elf32_Sword d_tag ;
   union __anonunion_d_un_93 d_un ;
};
typedef struct dynamic Elf32_Dyn;
union __anonunion_d_un_95 {
   Elf64_Xword d_val ;
   Elf64_Addr d_ptr ;
};
struct __anonstruct_Elf64_Dyn_94 {
   Elf64_Sxword d_tag ;
   union __anonunion_d_un_95 d_un ;
};
typedef struct __anonstruct_Elf64_Dyn_94 Elf64_Dyn;
struct elf32_rel {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
typedef struct elf32_rel Elf32_Rel;
struct elf64_rel {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
};
typedef struct elf64_rel Elf64_Rel;
struct elf32_rela {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
   Elf32_Sword r_addend ;
};
typedef struct elf32_rela Elf32_Rela;
struct elf64_rela {
   Elf64_Addr r_offset ;
   Elf64_Xword r_info ;
   Elf64_Sxword r_addend ;
};
typedef struct elf64_rela Elf64_Rela;
struct elf32_sym {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct elf32_sym Elf32_Sym;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct elf32_hdr {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
typedef struct elf32_hdr Elf32_Ehdr;
struct elf64_hdr {
   unsigned char e_ident[16] ;
   Elf64_Half e_type ;
   Elf64_Half e_machine ;
   Elf64_Word e_version ;
   Elf64_Addr e_entry ;
   Elf64_Off e_phoff ;
   Elf64_Off e_shoff ;
   Elf64_Word e_flags ;
   Elf64_Half e_ehsize ;
   Elf64_Half e_phentsize ;
   Elf64_Half e_phnum ;
   Elf64_Half e_shentsize ;
   Elf64_Half e_shnum ;
   Elf64_Half e_shstrndx ;
};
typedef struct elf64_hdr Elf64_Ehdr;
struct elf32_phdr {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
typedef struct elf32_phdr Elf32_Phdr;
struct elf64_phdr {
   Elf64_Word p_type ;
   Elf64_Word p_flags ;
   Elf64_Off p_offset ;
   Elf64_Addr p_vaddr ;
   Elf64_Addr p_paddr ;
   Elf64_Xword p_filesz ;
   Elf64_Xword p_memsz ;
   Elf64_Xword p_align ;
};
typedef struct elf64_phdr Elf64_Phdr;
struct __anonstruct_Elf32_Shdr_96 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
typedef struct __anonstruct_Elf32_Shdr_96 Elf32_Shdr;
struct elf64_shdr {
   Elf64_Word sh_name ;
   Elf64_Word sh_type ;
   Elf64_Xword sh_flags ;
   Elf64_Addr sh_addr ;
   Elf64_Off sh_offset ;
   Elf64_Xword sh_size ;
   Elf64_Word sh_link ;
   Elf64_Word sh_info ;
   Elf64_Xword sh_addralign ;
   Elf64_Xword sh_entsize ;
};
typedef struct elf64_shdr Elf64_Shdr;
struct elf32_note {
   Elf32_Word n_namesz ;
   Elf32_Word n_descsz ;
   Elf32_Word n_type ;
};
typedef struct elf32_note Elf32_Nhdr;
struct elf64_note {
   Elf64_Word n_namesz ;
   Elf64_Word n_descsz ;
   Elf64_Word n_type ;
};
typedef struct elf64_note Elf64_Nhdr;
struct kernel_param;
typedef int (*param_set_fn)(char const   *val , struct kernel_param *kp );
typedef int (*param_get_fn)(char *buffer , struct kernel_param *kp );
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_97 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_97 __annonCompField15 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
struct marker;
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
struct rcu_dynticks {
   int dynticks_nesting ;
   int dynticks ;
   int dynticks_nmi ;
};
struct rcu_node {
   spinlock_t lock ;
   unsigned long qsmask ;
   unsigned long qsmaskinit ;
   unsigned long grpmask ;
   int grplo ;
   int grphi ;
   u8 grpnum ;
   u8 level ;
   struct rcu_node *parent ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
struct rcu_data {
   long completed ;
   long gpnum ;
   long passed_quiesc_completed ;
   bool passed_quiesc ;
   bool qs_pending ;
   bool beenonline ;
   struct rcu_node *mynode ;
   unsigned long grpmask ;
   struct rcu_head *nxtlist ;
   struct rcu_head **nxttail[4] ;
   long qlen ;
   long blimit ;
   struct rcu_dynticks *dynticks ;
   int dynticks_snap ;
   int dynticks_nmi_snap ;
   unsigned long dynticks_fqs ;
   unsigned long offline_fqs ;
   unsigned long resched_ipi ;
   long n_rcu_pending ;
   int cpu ;
};
struct rcu_state {
   struct rcu_node node[1] ;
   struct rcu_node *level[1] ;
   u32 levelcnt[4] ;
   u8 levelspread[1] ;
   struct rcu_data *rda[8] ;
   u8 signaled  __attribute__((__aligned__((1) <<  (5) ))) ;
   long gpnum ;
   long completed ;
   spinlock_t onofflock ;
   spinlock_t fqslock ;
   unsigned long jiffies_force_qs ;
   unsigned long n_force_qs ;
   unsigned long n_force_qs_lh ;
   unsigned long n_force_qs_ngp ;
   long dynticks_completed ;
};
struct rcu_synchronize {
   struct rcu_head head ;
   struct completion completion ;
};
struct tracepoint;
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
struct tracepoint_iter {
   struct module *module ;
   struct tracepoint *tracepoint ;
};
struct timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int tai ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
typedef unsigned long long cycles_t;
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
enum debug_obj_state {
    ODEBUG_STATE_NONE = 0,
    ODEBUG_STATE_INIT = 1,
    ODEBUG_STATE_INACTIVE = 2,
    ODEBUG_STATE_ACTIVE = 3,
    ODEBUG_STATE_DESTROYED = 4,
    ODEBUG_STATE_NOTAVAILABLE = 5,
    ODEBUG_STATE_MAX = 6
} ;
struct debug_obj_descr;
struct debug_obj {
   struct hlist_node node ;
   enum debug_obj_state state ;
   void *object ;
   struct debug_obj_descr *descr ;
};
struct debug_obj_descr {
   char const   *name ;
   int (*fixup_init)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_activate)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_destroy)(void *addr , enum debug_obj_state state ) ;
   int (*fixup_free)(void *addr , enum debug_obj_state state ) ;
};
struct tvec_base;
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
   void *start_site ;
   char start_comm[16] ;
   int start_pid ;
};
struct hrtimer;
enum hrtimer_restart;
struct workqueue_struct;
struct work_struct;
typedef void (*work_func_t)(struct work_struct *work );
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
struct execute_work {
   struct work_struct work ;
};
enum stat_item {
    ALLOC_FASTPATH = 0,
    ALLOC_SLOWPATH = 1,
    FREE_FASTPATH = 2,
    FREE_SLOWPATH = 3,
    FREE_FROZEN = 4,
    FREE_ADD_PARTIAL = 5,
    FREE_REMOVE_PARTIAL = 6,
    ALLOC_FROM_PARTIAL = 7,
    ALLOC_SLAB = 8,
    ALLOC_REFILL = 9,
    FREE_SLAB = 10,
    CPUSLAB_FLUSH = 11,
    DEACTIVATE_FULL = 12,
    DEACTIVATE_EMPTY = 13,
    DEACTIVATE_TO_HEAD = 14,
    DEACTIVATE_TO_TAIL = 15,
    DEACTIVATE_REMOTE_FREES = 16,
    ORDER_FALLBACK = 17,
    NR_SLUB_STAT_ITEMS = 18
} ;
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
struct kmem_cache_order_objects {
   unsigned long x ;
};
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   unsigned long min_partial ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct kmem_cache_cpu *cpu_slab[8] ;
};
typedef struct page *(*pcpu_get_page_fn_t)(unsigned int cpu , int pageno );
typedef void (*pcpu_populate_pte_fn_t)(unsigned long addr );
struct __anonstruct_local_t_98 {
   atomic_long_t a ;
};
typedef struct __anonstruct_local_t_98 local_t;
struct mod_arch_specific {

};
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
struct modversion_info {
   unsigned long crc ;
   char name[64UL - sizeof(unsigned long )] ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf32_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   char const   **trace_bprintk_fmt_start ;
   unsigned int num_trace_bprintk_fmt ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
enum __anonenum_licence_99 {
    NOT_GPL_ONLY = 0,
    GPL_ONLY = 1,
    WILL_BE_GPL_ONLY = 2
} ;
struct symsearch {
   struct kernel_symbol  const  *start ;
   struct kernel_symbol  const  *stop ;
   unsigned long const   *crcs ;
   enum __anonenum_licence_99 licence ;
   bool unused ;
};
struct device_driver;
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
struct dev_archdata {
   void *acpi_handle ;
};
struct device_private;
struct driver_private;
struct class;
struct class_private;
struct bus_type;
struct bus_type_private;
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
struct device_type;
struct class_dev_iter {
   struct klist_iter ki ;
   struct device_type  const  *type ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
struct class_interface {
   struct list_head node ;
   struct class *class ;
   int (*add_dev)(struct device * , struct class_interface * ) ;
   void (*remove_dev)(struct device * , struct class_interface * ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
typedef void (*dr_release_t)(struct device *dev , void *res );
typedef int (*dr_match_t)(struct device *dev , void *res , void *match_data );
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
struct dma_coherent_mem;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
enum bug_trap_type {
    BUG_TRAP_TYPE_NONE = 0,
    BUG_TRAP_TYPE_WARN = 1,
    BUG_TRAP_TYPE_BUG = 2
} ;
enum dma_attr {
    DMA_ATTR_WRITE_BARRIER = 0,
    DMA_ATTR_WEAK_ORDERING = 1,
    DMA_ATTR_MAX = 2
} ;
struct dma_attrs {
   unsigned long flags[((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct rb_root {
   struct rb_node *rb_node ;
};
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
struct prio_tree_iter {
   struct prio_tree_node *cur ;
   unsigned long mask ;
   unsigned long value ;
   int size_level ;
   struct prio_tree_root *root ;
   unsigned long r_index ;
   unsigned long h_index ;
};
enum page_debug_flags {
    PAGE_DEBUG_FLAG_POISON = 0
} ;
struct address_space;
typedef atomic_long_t mm_counter_t;
struct __anonstruct____missing_field_name_101 {
   u16 inuse ;
   u16 objects ;
};
union __anonunion____missing_field_name_100 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_101 __annonCompField16 ;
};
struct __anonstruct____missing_field_name_103 {
   unsigned long private ;
   struct address_space *mapping ;
};
union __anonunion____missing_field_name_102 {
   struct __anonstruct____missing_field_name_103 __annonCompField18 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
union __anonunion____missing_field_name_104 {
   unsigned long index ;
   void *freelist ;
};
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_100 __annonCompField17 ;
   union __anonunion____missing_field_name_102 __annonCompField19 ;
   union __anonunion____missing_field_name_104 __annonCompField20 ;
   struct list_head lru ;
};
struct vm_region {
   struct rb_node vm_rb ;
   unsigned long vm_flags ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   unsigned long vm_top ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   atomic_t vm_usage ;
};
struct __anonstruct_vm_set_106 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_105 {
   struct __anonstruct_vm_set_106 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct vm_operations_struct;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_105 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[42] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
struct mempolicy;
struct file_ra_state;
struct user_struct;
struct writeback_control;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
};
struct mmu_gather;
struct inode;
enum pageflags {
    PG_locked = 0,
    PG_error = 1,
    PG_referenced = 2,
    PG_uptodate = 3,
    PG_dirty = 4,
    PG_lru = 5,
    PG_active = 6,
    PG_slab = 7,
    PG_owner_priv_1 = 8,
    PG_arch_1 = 9,
    PG_reserved = 10,
    PG_private = 11,
    PG_private_2 = 12,
    PG_writeback = 13,
    PG_head = 14,
    PG_tail = 15,
    PG_swapcache = 16,
    PG_mappedtodisk = 17,
    PG_reclaim = 18,
    PG_buddy = 19,
    PG_swapbacked = 20,
    PG_unevictable = 21,
    PG_mlocked = 22,
    __NR_PAGEFLAGS = 23,
    PG_checked = 8,
    PG_fscache = 12,
    PG_pinned = 8,
    PG_savepinned = 4,
    PG_slob_page = 6,
    PG_slob_free = 11,
    PG_slub_frozen = 6,
    PG_slub_debug = 1
} ;
typedef void compound_page_dtor(struct page * );
enum vm_event_item {
    PGPGIN = 0,
    PGPGOUT = 1,
    PSWPIN = 2,
    PSWPOUT = 3,
    PGALLOC_DMA = 4,
    PGALLOC_NORMAL = 5,
    PGALLOC_HIGH = 6,
    PGALLOC_MOVABLE = 7,
    PGFREE = 8,
    PGACTIVATE = 9,
    PGDEACTIVATE = 10,
    PGFAULT = 11,
    PGMAJFAULT = 12,
    PGREFILL_DMA = 13,
    PGREFILL_NORMAL = 14,
    PGREFILL_HIGH = 15,
    PGREFILL_MOVABLE = 16,
    PGSTEAL_DMA = 17,
    PGSTEAL_NORMAL = 18,
    PGSTEAL_HIGH = 19,
    PGSTEAL_MOVABLE = 20,
    PGSCAN_KSWAPD_DMA = 21,
    PGSCAN_KSWAPD_NORMAL = 22,
    PGSCAN_KSWAPD_HIGH = 23,
    PGSCAN_KSWAPD_MOVABLE = 24,
    PGSCAN_DIRECT_DMA = 25,
    PGSCAN_DIRECT_NORMAL = 26,
    PGSCAN_DIRECT_HIGH = 27,
    PGSCAN_DIRECT_MOVABLE = 28,
    PGINODESTEAL = 29,
    SLABS_SCANNED = 30,
    KSWAPD_STEAL = 31,
    KSWAPD_INODESTEAL = 32,
    PAGEOUTRUN = 33,
    ALLOCSTALL = 34,
    PGROTATED = 35,
    HTLB_BUDDY_PGALLOC = 36,
    HTLB_BUDDY_PGALLOC_FAIL = 37,
    UNEVICTABLE_PGCULLED = 38,
    UNEVICTABLE_PGSCANNED = 39,
    UNEVICTABLE_PGRESCUED = 40,
    UNEVICTABLE_PGMLOCKED = 41,
    UNEVICTABLE_PGMUNLOCKED = 42,
    UNEVICTABLE_PGCLEARED = 43,
    UNEVICTABLE_PGSTRANDED = 44,
    UNEVICTABLE_MLOCKFREED = 45,
    NR_VM_EVENT_ITEMS = 46
} ;
struct vm_event_state {
   unsigned long event[46] ;
};
struct zap_details {
   struct vm_area_struct *nonlinear_vma ;
   struct address_space *check_mapping ;
   unsigned long first_index ;
   unsigned long last_index ;
   spinlock_t *i_mmap_lock ;
   unsigned long truncate_count ;
};
struct mm_walk {
   int (*pgd_entry)(pgd_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pud_entry)(pud_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pmd_entry)(pmd_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pte_entry)(pte_t * , unsigned long  , unsigned long  , struct mm_walk * ) ;
   int (*pte_hole)(unsigned long  , unsigned long  , struct mm_walk * ) ;
   struct mm_struct *mm ;
   void *private ;
};
struct shrinker {
   int (*shrink)(int nr_to_scan , gfp_t gfp_mask ) ;
   int seeks ;
   struct list_head list ;
   long nr ;
};
typedef int (*work_fn_t)(unsigned long  , unsigned long  , void * );
typedef int (*pte_fn_t)(pte_t *pte , pgtable_t token , unsigned long addr , void *data );
struct vm_struct {
   struct vm_struct *next ;
   void *addr ;
   unsigned long size ;
   unsigned long flags ;
   struct page **pages ;
   unsigned int nr_pages ;
   unsigned long phys_addr ;
   void *caller ;
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
typedef struct scatterlist *sg_alloc_fn(unsigned int  , gfp_t  );
typedef void sg_free_fn(struct scatterlist * , unsigned int  );
struct sg_mapping_iter {
   struct page *page ;
   void *addr ;
   size_t length ;
   size_t consumed ;
   struct scatterlist *__sg ;
   unsigned int __nents ;
   unsigned int __offset ;
   unsigned int __flags ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc_coherent)(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                           gfp_t gfp ) ;
   void (*free_coherent)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
   dma_addr_t (*map_page)(struct device *dev , struct page *page , unsigned long offset ,
                          size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
   void (*unmap_page)(struct device *dev , dma_addr_t dma_handle , size_t size , enum dma_data_direction dir ,
                      struct dma_attrs *attrs ) ;
   int (*map_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                 struct dma_attrs *attrs ) ;
   void (*unmap_sg)(struct device *dev , struct scatterlist *sg , int nents , enum dma_data_direction dir ,
                    struct dma_attrs *attrs ) ;
   void (*sync_single_for_cpu)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                               enum dma_data_direction dir ) ;
   void (*sync_single_for_device)(struct device *dev , dma_addr_t dma_handle , size_t size ,
                                  enum dma_data_direction dir ) ;
   void (*sync_single_range_for_cpu)(struct device *dev , dma_addr_t dma_handle ,
                                     unsigned long offset , size_t size , enum dma_data_direction dir ) ;
   void (*sync_single_range_for_device)(struct device *dev , dma_addr_t dma_handle ,
                                        unsigned long offset , size_t size , enum dma_data_direction dir ) ;
   void (*sync_sg_for_cpu)(struct device *dev , struct scatterlist *sg , int nents ,
                           enum dma_data_direction dir ) ;
   void (*sync_sg_for_device)(struct device *dev , struct scatterlist *sg , int nents ,
                              enum dma_data_direction dir ) ;
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   int (*dma_supported)(struct device *dev , u64 mask ) ;
   int is_phys ;
};
struct fw_card;
struct fw_packet;
struct fw_node;
struct fw_request;
struct fw_descriptor {
   struct list_head link ;
   size_t length ;
   u32 immediate ;
   u32 key ;
   u32 const   *data ;
};
typedef void (*fw_packet_callback_t)(struct fw_packet *packet , struct fw_card *card ,
                                     int status );
typedef void (*fw_transaction_callback_t)(struct fw_card *card , int rcode , void *data ,
                                          size_t length , void *callback_data );
typedef void (*fw_address_callback_t)(struct fw_card *card , struct fw_request *request ,
                                      int tcode , int destination , int source , int generation ,
                                      int speed , unsigned long long offset , void *data ,
                                      size_t length , void *callback_data );
struct fw_packet {
   int speed ;
   int generation ;
   u32 header[4] ;
   size_t header_length ;
   void *payload ;
   size_t payload_length ;
   dma_addr_t payload_bus ;
   u32 timestamp ;
   void (*callback)(struct fw_packet *packet , struct fw_card *card , int status ) ;
   int ack ;
   struct list_head link ;
   void *driver_data ;
};
struct fw_transaction {
   int node_id ;
   int tlabel ;
   int timestamp ;
   struct list_head link ;
   struct fw_packet packet ;
   void (*callback)(struct fw_card *card , int rcode , void *data , size_t length ,
                    void *callback_data ) ;
   void *callback_data ;
};
struct fw_address_handler {
   u64 offset ;
   size_t length ;
   void (*address_callback)(struct fw_card *card , struct fw_request *request , int tcode ,
                            int destination , int source , int generation , int speed ,
                            unsigned long long offset , void *data , size_t length ,
                            void *callback_data ) ;
   void *callback_data ;
   struct list_head link ;
};
struct fw_address_region {
   u64 start ;
   u64 end ;
};
struct fw_card_driver;
struct fw_card {
   struct fw_card_driver  const  *driver ;
   struct device *device ;
   struct kref kref ;
   struct completion done ;
   int node_id ;
   int generation ;
   int current_tlabel ;
   int tlabel_mask ;
   struct list_head transaction_list ;
   struct timer_list flush_timer ;
   unsigned long reset_jiffies ;
   unsigned long long guid ;
   unsigned int max_receive ;
   int link_speed ;
   int config_rom_generation ;
   spinlock_t lock ;
   struct fw_node *local_node ;
   struct fw_node *root_node ;
   struct fw_node *irm_node ;
   u8 color ;
   int gap_count ;
   bool beta_repeaters_present ;
   int index ;
   struct list_head link ;
   struct delayed_work work ;
   int bm_retries ;
   int bm_generation ;
   bool broadcast_channel_allocated ;
   u32 broadcast_channel ;
   u32 topology_map[256] ;
};
struct fw_iso_packet {
   u16 payload_length ;
   u32 interrupt : 1 ;
   u32 skip : 1 ;
   u32 tag : 2 ;
   u32 sy : 4 ;
   u32 header_length : 8 ;
   u32 header[0] ;
};
struct fw_iso_context;
typedef void (*fw_iso_callback_t)(struct fw_iso_context *context , u32 cycle , size_t header_length ,
                                  void *header , void *data );
struct fw_iso_buffer {
   enum dma_data_direction direction ;
   struct page **pages ;
   int page_count ;
};
struct fw_iso_context {
   struct fw_card *card ;
   int type ;
   int channel ;
   int speed ;
   size_t header_size ;
   void (*callback)(struct fw_iso_context *context , u32 cycle , size_t header_length ,
                    void *header , void *data ) ;
   void *callback_data ;
};
struct fw_card_driver {
   int (*enable)(struct fw_card *card , u32 *config_rom , size_t length ) ;
   int (*update_phy_reg)(struct fw_card *card , int address , int clear_bits , int set_bits ) ;
   int (*set_config_rom)(struct fw_card *card , u32 *config_rom , size_t length ) ;
   void (*send_request)(struct fw_card *card , struct fw_packet *packet ) ;
   void (*send_response)(struct fw_card *card , struct fw_packet *packet ) ;
   int (*cancel_packet)(struct fw_card *card , struct fw_packet *packet ) ;
   int (*enable_phys_dma)(struct fw_card *card , int node_id , int generation ) ;
   u64 (*get_bus_time)(struct fw_card *card ) ;
   struct fw_iso_context *(*allocate_iso_context)(struct fw_card *card , int type ,
                                                  int channel , size_t header_size ) ;
   void (*free_iso_context)(struct fw_iso_context *ctx ) ;
   int (*start_iso)(struct fw_iso_context *ctx , s32 cycle , u32 sync , u32 tags ) ;
   int (*queue_iso)(struct fw_iso_context *ctx , struct fw_iso_packet *packet , struct fw_iso_buffer *buffer ,
                    unsigned long payload ) ;
   int (*stop_iso)(struct fw_iso_context *ctx ) ;
};
enum __anonenum_107 {
    FW_NODE_CREATED = 0,
    FW_NODE_UPDATED = 1,
    FW_NODE_DESTROYED = 2,
    FW_NODE_LINK_ON = 3,
    FW_NODE_LINK_OFF = 4,
    FW_NODE_INITIATED_RESET = 5
} ;
struct fw_node {
   u16 node_id ;
   u8 color ;
   u8 port_count ;
   u8 link_on : 1 ;
   u8 initiated_reset : 1 ;
   u8 b_path : 1 ;
   u8 phy_speed : 2 ;
   u8 max_speed : 2 ;
   u8 max_depth : 4 ;
   u8 max_hops : 4 ;
   atomic_t ref_count ;
   struct list_head link ;
   void *data ;
   struct fw_node *ports[0] ;
};
struct files_stat_struct {
   int nr_files ;
   int nr_free_files ;
   int max_files ;
};
struct inodes_stat_t {
   int nr_inodes ;
   int nr_unused ;
   int dummy[5] ;
};
struct nameidata;
struct path;
struct vfsmount;
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
struct dentry_stat_t {
   int nr_dentry ;
   int nr_unused ;
   int age_limit ;
   int want_pages ;
   int dummy[2] ;
};
union __anonunion_d_u_108 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry_operations;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_108 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[40] ;
};
enum dentry_d_lock_class {
    DENTRY_D_LOCK_NORMAL = 0,
    DENTRY_D_LOCK_NESTED = 1
} ;
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
typedef struct __user_cap_header_struct *cap_user_header_t;
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
typedef struct __user_cap_data_struct *cap_user_data_t;
struct __anonstruct_data_109 {
   __le32 permitted ;
   __le32 inheritable ;
};
struct vfs_cap_data {
   __le32 magic_etc ;
   struct __anonstruct_data_109 data[2] ;
};
struct kernel_cap_struct {
   __u32 cap[2] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct cpu_vfs_cap_data {
   __u32 magic_etc ;
   kernel_cap_t permitted ;
   kernel_cap_t inheritable ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
struct fiemap {
   __u64 fm_start ;
   __u64 fm_length ;
   __u32 fm_flags ;
   __u32 fm_mapped_extents ;
   __u32 fm_extent_count ;
   __u32 fm_reserved ;
   struct fiemap_extent fm_extents[0] ;
};
struct export_operations;
struct hd_geometry;
struct iovec;
struct kiocb;
struct pipe_inode_info;
struct poll_table_struct;
struct kstatfs;
struct cred;
struct buffer_head;
typedef int get_block_t(struct inode *inode , sector_t iblock , struct buffer_head *bh_result ,
                        int create );
typedef void dio_iodone_t(struct kiocb *iocb , loff_t offset , ssize_t bytes , void *private );
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
enum __anonenum_110 {
    QIF_BLIMITS_B = 0,
    QIF_SPACE_B = 1,
    QIF_ILIMITS_B = 2,
    QIF_INODES_B = 3,
    QIF_BTIME_B = 4,
    QIF_ITIME_B = 5
} ;
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
enum __anonenum_111 {
    QUOTA_NL_C_UNSPEC = 0,
    QUOTA_NL_C_WARNING = 1,
    __QUOTA_NL_C_MAX = 2
} ;
enum __anonenum_112 {
    QUOTA_NL_A_UNSPEC = 0,
    QUOTA_NL_A_QTYPE = 1,
    QUOTA_NL_A_EXCESS_ID = 2,
    QUOTA_NL_A_WARNING = 3,
    QUOTA_NL_A_DEV_MAJOR = 4,
    QUOTA_NL_A_DEV_MINOR = 5,
    QUOTA_NL_A_CAUSED_ID = 6,
    __QUOTA_NL_A_MAX = 7
} ;
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
typedef struct fs_disk_quota fs_disk_quota_t;
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
typedef struct fs_quota_stat fs_quota_stat_t;
struct dquot;
struct qtree_fmt_operations {
   void (*mem2disk_dqblk)(void *disk , struct dquot *dquot ) ;
   void (*disk2mem_dqblk)(struct dquot *dquot , void *disk ) ;
   int (*is_id)(void *disk , struct dquot *dquot ) ;
};
struct qtree_mem_dqinfo {
   struct super_block *dqi_sb ;
   int dqi_type ;
   unsigned int dqi_blocks ;
   unsigned int dqi_free_blk ;
   unsigned int dqi_free_entry ;
   unsigned int dqi_blocksize_bits ;
   unsigned int dqi_entry_size ;
   unsigned int dqi_usable_bs ;
   unsigned int dqi_qtree_depth ;
   struct qtree_fmt_operations *dqi_ops ;
};
typedef __kernel_uid32_t qid_t;
typedef long long qsize_t;
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
struct dqstats {
   int lookups ;
   int drops ;
   int reads ;
   int writes ;
   int cache_hits ;
   int allocated_dquots ;
   int free_dquots ;
   int syncs ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   int (*reserve_space)(struct inode * , qsize_t  , int  ) ;
   int (*claim_space)(struct inode * , qsize_t  ) ;
   void (*release_rsv)(struct inode * , qsize_t  ) ;
   qsize_t (*get_reserved_space)(struct inode * ) ;
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
enum __anonenum_113 {
    _DQUOT_USAGE_ENABLED = 0,
    _DQUOT_LIMITS_ENABLED = 1,
    _DQUOT_SUSPENDED = 2,
    _DQUOT_STATE_FLAGS = 3
} ;
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
struct quota_module_name {
   int qm_fmt_id ;
   char *qm_mod_name ;
};
enum positive_aop_returns {
    AOP_WRITEPAGE_ACTIVATE = 524288,
    AOP_TRUNCATED_PAGE = 524289
} ;
struct iov_iter {
   struct iovec  const  *iov ;
   unsigned long nr_segs ;
   size_t iov_offset ;
   size_t count ;
};
union __anonunion_arg_115 {
   char *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_114 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_115 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_114 read_descriptor_t;
typedef int (*read_actor_t)(read_descriptor_t * , struct page * , unsigned long  ,
                            unsigned long  );
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
struct backing_dev_info;
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
struct inode_operations;
struct file_operations;
struct file_lock;
struct cdev;
union __anonunion____missing_field_name_116 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct dnotify_struct;
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   seqcount_t i_size_seqcount ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_116 __annonCompField21 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
enum inode_i_mutex_lock_class {
    I_MUTEX_NORMAL = 0,
    I_MUTEX_PARENT = 1,
    I_MUTEX_CHILD = 2,
    I_MUTEX_XATTR = 3,
    I_MUTEX_QUOTA = 4
} ;
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
union __anonunion_f_u_117 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_117 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct address_space *f_mapping ;
};
struct files_struct;
typedef struct files_struct *fl_owner_t;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
struct lock_manager {
   struct list_head list ;
};
enum nfs_stat {
    NFS_OK = 0,
    NFSERR_PERM = 1,
    NFSERR_NOENT = 2,
    NFSERR_IO = 5,
    NFSERR_NXIO = 6,
    NFSERR_EAGAIN = 11,
    NFSERR_ACCES = 13,
    NFSERR_EXIST = 17,
    NFSERR_XDEV = 18,
    NFSERR_NODEV = 19,
    NFSERR_NOTDIR = 20,
    NFSERR_ISDIR = 21,
    NFSERR_INVAL = 22,
    NFSERR_FBIG = 27,
    NFSERR_NOSPC = 28,
    NFSERR_ROFS = 30,
    NFSERR_MLINK = 31,
    NFSERR_OPNOTSUPP = 45,
    NFSERR_NAMETOOLONG = 63,
    NFSERR_NOTEMPTY = 66,
    NFSERR_DQUOT = 69,
    NFSERR_STALE = 70,
    NFSERR_REMOTE = 71,
    NFSERR_WFLUSH = 99,
    NFSERR_BADHANDLE = 10001,
    NFSERR_NOT_SYNC = 10002,
    NFSERR_BAD_COOKIE = 10003,
    NFSERR_NOTSUPP = 10004,
    NFSERR_TOOSMALL = 10005,
    NFSERR_SERVERFAULT = 10006,
    NFSERR_BADTYPE = 10007,
    NFSERR_JUKEBOX = 10008,
    NFSERR_SAME = 10009,
    NFSERR_DENIED = 10010,
    NFSERR_EXPIRED = 10011,
    NFSERR_LOCKED = 10012,
    NFSERR_GRACE = 10013,
    NFSERR_FHEXPIRED = 10014,
    NFSERR_SHARE_DENIED = 10015,
    NFSERR_WRONGSEC = 10016,
    NFSERR_CLID_INUSE = 10017,
    NFSERR_RESOURCE = 10018,
    NFSERR_MOVED = 10019,
    NFSERR_NOFILEHANDLE = 10020,
    NFSERR_MINOR_VERS_MISMATCH = 10021,
    NFSERR_STALE_CLIENTID = 10022,
    NFSERR_STALE_STATEID = 10023,
    NFSERR_OLD_STATEID = 10024,
    NFSERR_BAD_STATEID = 10025,
    NFSERR_BAD_SEQID = 10026,
    NFSERR_NOT_SAME = 10027,
    NFSERR_LOCK_RANGE = 10028,
    NFSERR_SYMLINK = 10029,
    NFSERR_RESTOREFH = 10030,
    NFSERR_LEASE_MOVED = 10031,
    NFSERR_ATTRNOTSUPP = 10032,
    NFSERR_NO_GRACE = 10033,
    NFSERR_RECLAIM_BAD = 10034,
    NFSERR_RECLAIM_CONFLICT = 10035,
    NFSERR_BAD_XDR = 10036,
    NFSERR_LOCKS_HELD = 10037,
    NFSERR_OPENMODE = 10038,
    NFSERR_BADOWNER = 10039,
    NFSERR_BADCHAR = 10040,
    NFSERR_BADNAME = 10041,
    NFSERR_BAD_RANGE = 10042,
    NFSERR_LOCK_NOTSUPP = 10043,
    NFSERR_OP_ILLEGAL = 10044,
    NFSERR_DEADLOCK = 10045,
    NFSERR_FILE_OPEN = 10046,
    NFSERR_ADMIN_REVOKED = 10047,
    NFSERR_CB_PATH_DOWN = 10048
} ;
enum nfs_ftype {
    NFNON = 0,
    NFREG = 1,
    NFDIR = 2,
    NFBLK = 3,
    NFCHR = 4,
    NFLNK = 5,
    NFSOCK = 6,
    NFBAD = 7,
    NFFIFO = 8
} ;
typedef u32 rpc_authflavor_t;
enum rpc_auth_flavors {
    RPC_AUTH_NULL = 0,
    RPC_AUTH_UNIX = 1,
    RPC_AUTH_SHORT = 2,
    RPC_AUTH_DES = 3,
    RPC_AUTH_KRB = 4,
    RPC_AUTH_GSS = 6,
    RPC_AUTH_MAXFLAVOR = 8,
    RPC_AUTH_GSS_KRB5 = 390003,
    RPC_AUTH_GSS_KRB5I = 390004,
    RPC_AUTH_GSS_KRB5P = 390005,
    RPC_AUTH_GSS_LKEY = 390006,
    RPC_AUTH_GSS_LKEYI = 390007,
    RPC_AUTH_GSS_LKEYP = 390008,
    RPC_AUTH_GSS_SPKM = 390009,
    RPC_AUTH_GSS_SPKMI = 390010,
    RPC_AUTH_GSS_SPKMP = 390011
} ;
enum rpc_msg_type {
    RPC_CALL = 0,
    RPC_REPLY = 1
} ;
enum rpc_reply_stat {
    RPC_MSG_ACCEPTED = 0,
    RPC_MSG_DENIED = 1
} ;
enum rpc_accept_stat {
    RPC_SUCCESS = 0,
    RPC_PROG_UNAVAIL = 1,
    RPC_PROG_MISMATCH = 2,
    RPC_PROC_UNAVAIL = 3,
    RPC_GARBAGE_ARGS = 4,
    RPC_SYSTEM_ERR = 5,
    RPC_DROP_REPLY = 60000
} ;
enum rpc_reject_stat {
    RPC_MISMATCH = 0,
    RPC_AUTH_ERROR = 1
} ;
enum rpc_auth_stat {
    RPC_AUTH_OK = 0,
    RPC_AUTH_BADCRED = 1,
    RPC_AUTH_REJECTEDCRED = 2,
    RPC_AUTH_BADVERF = 3,
    RPC_AUTH_REJECTEDVERF = 4,
    RPC_AUTH_TOOWEAK = 5,
    RPCSEC_GSS_CREDPROBLEM = 13,
    RPCSEC_GSS_CTXPROBLEM = 14
} ;
typedef __be32 rpc_fraghdr;
struct nfs_fh {
   unsigned short size ;
   unsigned char data[128] ;
};
enum nfs3_stable_how {
    NFS_UNSTABLE = 0,
    NFS_DATA_SYNC = 1,
    NFS_FILE_SYNC = 2
} ;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_119 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_118 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_119 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_118 fl_u ;
};
struct flock {
   short l_type ;
   short l_whence ;
   __kernel_off_t l_start ;
   __kernel_off_t l_len ;
   __kernel_pid_t l_pid ;
};
struct flock64 {
   short l_type ;
   short l_whence ;
   __kernel_loff_t l_start ;
   __kernel_loff_t l_len ;
   __kernel_pid_t l_pid ;
};
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
struct file_system_type;
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
enum __anonenum_120 {
    SB_UNFROZEN = 0,
    SB_FREEZE_WRITE = 1,
    SB_FREEZE_TRANS = 2
} ;
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
typedef int (*filldir_t)(void * , char const   * , int  , loff_t  , u64  , unsigned int  );
struct block_device_operations;
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
struct bio;
enum __anonenum_121 {
    DIO_LOCKING = 1,
    DIO_NO_LOCKING = 2,
    DIO_OWN_LOCKING = 3
} ;
struct tree_descr {
   char *name ;
   struct file_operations  const  *ops ;
   int mode ;
};
struct simple_transaction_argresp {
   ssize_t size ;
   char data[0] ;
};
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[1 << 5] ;
   int count ;
   int layer ;
   struct rcu_head rcu_head ;
};
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[128UL / sizeof(long ) - 1UL] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
enum fw_device_state {
    FW_DEVICE_INITIALIZING = 0,
    FW_DEVICE_RUNNING = 1,
    FW_DEVICE_GONE = 2,
    FW_DEVICE_SHUTDOWN = 3
} ;
struct fw_attribute_group {
   struct attribute_group *groups[2] ;
   struct attribute_group group ;
   struct attribute *attrs[11] ;
};
struct fw_device {
   atomic_t state ;
   struct fw_node *node ;
   int node_id ;
   int generation ;
   unsigned int max_speed ;
   struct fw_card *card ;
   struct device device ;
   struct mutex client_list_mutex ;
   struct list_head client_list ;
   u32 *config_rom ;
   size_t config_rom_length ;
   int config_rom_retries ;
   unsigned int cmc : 1 ;
   unsigned int bc_implemented : 2 ;
   struct delayed_work work ;
   struct fw_attribute_group attribute_group ;
};
struct fw_unit {
   struct device device ;
   u32 *directory ;
   struct fw_attribute_group attribute_group ;
};
struct fw_csr_iterator {
   u32 *p ;
   u32 *end ;
};
struct fw_device_id {
   u32 match_flags ;
   u32 vendor ;
   u32 model ;
   u32 specifier_id ;
   u32 version ;
   void *driver_data ;
};
struct fw_driver {
   struct device_driver driver ;
   void (*update)(struct fw_unit *unit ) ;
   struct fw_device_id  const  *id_table ;
};
enum __anonenum_4___0 {
    false___0 = 0,
    true___0 = 1
} ;
enum __anonenum_8 {
    DUMP_PREFIX_NONE___0 = 0,
    DUMP_PREFIX_ADDRESS___0 = 1,
    DUMP_PREFIX_OFFSET___0 = 2
} ;
enum __anonenum_15___0 {
    PG_LEVEL_NONE___0 = 0,
    PG_LEVEL_4K___0 = 1,
    PG_LEVEL_2M___0 = 2,
    PG_LEVEL_1G___0 = 3,
    PG_LEVEL_NUM___0 = 4
} ;
enum __anonenum_19___0 {
    GATE_INTERRUPT___0 = 14,
    GATE_TRAP___0 = 15,
    GATE_CALL___0 = 12,
    GATE_TASK___0 = 5
} ;
enum __anonenum_20___0 {
    DESC_TSS___0 = 9,
    DESC_LDT___0 = 2,
    DESCTYPE_S___0 = 16
} ;
enum __anonenum_21___0 {
    ADDR_NO_RANDOMIZE___0 = 262144,
    FDPIC_FUNCPTRS___0 = 524288,
    MMAP_PAGE_ZERO___0 = 1048576,
    ADDR_COMPAT_LAYOUT___0 = 2097152,
    READ_IMPLIES_EXEC___0 = 4194304,
    ADDR_LIMIT_32BIT___0 = 8388608,
    SHORT_INODE___0 = 16777216,
    WHOLE_SECONDS___0 = 33554432,
    STICKY_TIMEOUTS___0 = 67108864,
    ADDR_LIMIT_3GB___0 = 134217728
} ;
enum __anonenum_22___0 {
    PER_LINUX___0 = 0,
    PER_LINUX_32BIT___0 = 8388608,
    PER_LINUX_FDPIC___0 = 524288,
    PER_SVR4___0 = 68157441,
    PER_SVR3___0 = 83886082,
    PER_SCOSVR3___0 = 117440515,
    PER_OSR5___0 = 100663299,
    PER_WYSEV386___0 = 83886084,
    PER_ISCR4___0 = 67108869,
    PER_BSD___0 = 6,
    PER_SUNOS___0 = 67108870,
    PER_XENIX___0 = 83886087,
    PER_LINUX32___0 = 8,
    PER_LINUX32_3GB___0 = 134217736,
    PER_IRIX32___0 = 67108873,
    PER_IRIXN32___0 = 67108874,
    PER_IRIX64___0 = 67108875,
    PER_RISCOS___0 = 12,
    PER_SOLARIS___0 = 67108877,
    PER_UW7___0 = 68157454,
    PER_OSF4___0 = 15,
    PER_HPUX___0 = 16,
    PER_MASK___0 = 255
} ;
union __anonunion_d_37___0 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
struct fw_cdev_event_common {
   __u64 closure ;
   __u32 type ;
};
struct fw_cdev_event_bus_reset {
   __u64 closure ;
   __u32 type ;
   __u32 node_id ;
   __u32 local_node_id ;
   __u32 bm_node_id ;
   __u32 irm_node_id ;
   __u32 root_node_id ;
   __u32 generation ;
};
struct fw_cdev_event_response {
   __u64 closure ;
   __u32 type ;
   __u32 rcode ;
   __u32 length ;
   __u32 data[0] ;
};
struct fw_cdev_event_request {
   __u64 closure ;
   __u32 type ;
   __u32 tcode ;
   __u64 offset ;
   __u32 handle ;
   __u32 length ;
   __u32 data[0] ;
};
struct fw_cdev_event_iso_interrupt {
   __u64 closure ;
   __u32 type ;
   __u32 cycle ;
   __u32 header_length ;
   __u32 header[0] ;
};
struct fw_cdev_event_iso_resource {
   __u64 closure ;
   __u32 type ;
   __u32 handle ;
   __s32 channel ;
   __s32 bandwidth ;
};
union fw_cdev_event {
   struct fw_cdev_event_common common ;
   struct fw_cdev_event_bus_reset bus_reset ;
   struct fw_cdev_event_response response ;
   struct fw_cdev_event_request request ;
   struct fw_cdev_event_iso_interrupt iso_interrupt ;
   struct fw_cdev_event_iso_resource iso_resource ;
};
struct fw_cdev_get_info {
   __u32 version ;
   __u32 rom_length ;
   __u64 rom ;
   __u64 bus_reset ;
   __u64 bus_reset_closure ;
   __u32 card ;
};
struct fw_cdev_send_request {
   __u32 tcode ;
   __u32 length ;
   __u64 offset ;
   __u64 closure ;
   __u64 data ;
   __u32 generation ;
};
struct fw_cdev_send_response {
   __u32 rcode ;
   __u32 length ;
   __u64 data ;
   __u32 handle ;
};
struct fw_cdev_allocate {
   __u64 offset ;
   __u64 closure ;
   __u32 length ;
   __u32 handle ;
};
struct fw_cdev_deallocate {
   __u32 handle ;
};
struct fw_cdev_initiate_bus_reset {
   __u32 type ;
};
struct fw_cdev_add_descriptor {
   __u32 immediate ;
   __u32 key ;
   __u64 data ;
   __u32 length ;
   __u32 handle ;
};
struct fw_cdev_remove_descriptor {
   __u32 handle ;
};
struct fw_cdev_create_iso_context {
   __u32 type ;
   __u32 header_size ;
   __u32 channel ;
   __u32 speed ;
   __u64 closure ;
   __u32 handle ;
};
struct fw_cdev_iso_packet {
   __u32 control ;
   __u32 header[0] ;
};
struct fw_cdev_queue_iso {
   __u64 packets ;
   __u64 data ;
   __u32 size ;
   __u32 handle ;
};
struct fw_cdev_start_iso {
   __s32 cycle ;
   __u32 sync ;
   __u32 tags ;
   __u32 handle ;
};
struct fw_cdev_stop_iso {
   __u32 handle ;
};
struct fw_cdev_get_cycle_timer {
   __u64 local_time ;
   __u32 cycle_timer ;
};
struct fw_cdev_allocate_iso_resource {
   __u64 closure ;
   __u64 channels ;
   __u32 bandwidth ;
   __u32 handle ;
};
struct fw_cdev_send_stream_packet {
   __u32 length ;
   __u32 tag ;
   __u32 channel ;
   __u32 sy ;
   __u64 closure ;
   __u64 data ;
   __u32 generation ;
   __u32 speed ;
};
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
enum __anonenum_109 {
    QIF_BLIMITS_B___0 = 0,
    QIF_SPACE_B___0 = 1,
    QIF_ILIMITS_B___0 = 2,
    QIF_INODES_B___0 = 3,
    QIF_BTIME_B___0 = 4,
    QIF_ITIME_B___0 = 5
} ;
enum __anonenum_110___0 {
    QUOTA_NL_C_UNSPEC___0 = 0,
    QUOTA_NL_C_WARNING___0 = 1,
    __QUOTA_NL_C_MAX___0 = 2
} ;
enum __anonenum_111___0 {
    QUOTA_NL_A_UNSPEC___0 = 0,
    QUOTA_NL_A_QTYPE___0 = 1,
    QUOTA_NL_A_EXCESS_ID___0 = 2,
    QUOTA_NL_A_WARNING___0 = 3,
    QUOTA_NL_A_DEV_MAJOR___0 = 4,
    QUOTA_NL_A_DEV_MINOR___0 = 5,
    QUOTA_NL_A_CAUSED_ID___0 = 6,
    __QUOTA_NL_A_MAX___0 = 7
} ;
enum __anonenum_112___0 {
    _DQUOT_USAGE_ENABLED___0 = 0,
    _DQUOT_LIMITS_ENABLED___0 = 1,
    _DQUOT_SUSPENDED___0 = 2,
    _DQUOT_STATE_FLAGS___0 = 3
} ;
enum __anonenum_119 {
    SB_UNFROZEN___0 = 0,
    SB_FREEZE_WRITE___0 = 1,
    SB_FREEZE_TRANS___0 = 2
} ;
enum __anonenum_120___0 {
    DIO_LOCKING___0 = 1,
    DIO_NO_LOCKING___0 = 2,
    DIO_OWN_LOCKING___0 = 3
} ;
struct sched_param {
   int sched_priority ;
};
typedef unsigned long cputime_t;
typedef u64 cputime64_t;
struct ipc_perm {
   __kernel_key_t key ;
   __kernel_uid_t uid ;
   __kernel_gid_t gid ;
   __kernel_uid_t cuid ;
   __kernel_gid_t cgid ;
   __kernel_mode_t mode ;
   unsigned short seq ;
};
struct ipc64_perm {
   __kernel_key_t key ;
   __kernel_uid32_t uid ;
   __kernel_gid32_t gid ;
   __kernel_uid32_t cuid ;
   __kernel_gid32_t cgid ;
   __kernel_mode_t mode ;
   unsigned short __pad1 ;
   unsigned short seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
struct msgbuf;
struct ipc_kludge {
   struct msgbuf *msgp ;
   long msgtyp ;
};
struct kern_ipc_perm {
   spinlock_t lock ;
   int deleted ;
   int id ;
   key_t key ;
   uid_t uid ;
   gid_t gid ;
   uid_t cuid ;
   gid_t cgid ;
   mode_t mode ;
   unsigned long seq ;
   void *security ;
};
struct sem;
struct sem_queue;
struct sem_undo;
struct semid_ds {
   struct ipc_perm sem_perm ;
   __kernel_time_t sem_otime ;
   __kernel_time_t sem_ctime ;
   struct sem *sem_base ;
   struct sem_queue *sem_pending ;
   struct sem_queue **sem_pending_last ;
   struct sem_undo *undo ;
   unsigned short sem_nsems ;
};
struct semid64_ds {
   struct ipc64_perm sem_perm ;
   __kernel_time_t sem_otime ;
   unsigned long __unused1 ;
   __kernel_time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
struct seminfo;
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
   void *__pad ;
};
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
struct sem {
   int semval ;
   int sempid ;
};
struct sem_array {
   struct kern_ipc_perm sem_perm ;
   time_t sem_otime ;
   time_t sem_ctime ;
   struct sem *sem_base ;
   struct list_head sem_pending ;
   struct list_head list_id ;
   unsigned long sem_nsems ;
};
struct sem_queue {
   struct list_head list ;
   struct task_struct *sleeper ;
   struct sem_undo *undo ;
   int pid ;
   int status ;
   struct sembuf *sops ;
   int nsops ;
   int alter ;
};
struct sem_undo_list;
struct sem_undo {
   struct list_head list_proc ;
   struct rcu_head rcu ;
   struct sem_undo_list *ulp ;
   struct list_head list_id ;
   int semid ;
   short *semadj ;
};
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct siginfo;
typedef unsigned long old_sigset_t;
struct __anonstruct_sigset_t_121 {
   unsigned long sig[1] ;
};
typedef struct __anonstruct_sigset_t_121 sigset_t;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
typedef struct sigaltstack stack_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_123 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_124 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(__kernel_uid32_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_125 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_126 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__sigfault_127 {
   void *_addr ;
};
struct __anonstruct__sigpoll_128 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_122 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_123 _kill ;
   struct __anonstruct__timer_124 _timer ;
   struct __anonstruct__rt_125 _rt ;
   struct __anonstruct__sigchld_126 _sigchld ;
   struct __anonstruct__sigfault_127 _sigfault ;
   struct __anonstruct__sigpoll_128 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_122 _sifields ;
};
typedef struct siginfo siginfo_t;
struct __anonstruct__sigev_thread_130 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
union __anonunion__sigev_un_129 {
   int _pad[(64UL - (sizeof(int ) * 2UL + sizeof(sigval_t ))) / sizeof(int )] ;
   int _tid ;
   struct __anonstruct__sigev_thread_130 _sigev_thread ;
};
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_129 _sigev_un ;
};
typedef struct sigevent sigevent_t;
struct sigqueue {
   struct list_head list ;
   int flags ;
   siginfo_t info ;
   struct user_struct *user ;
};
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct percpu_counter {
   spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct prop_global {
   int shift ;
   struct percpu_counter events ;
};
struct prop_descriptor {
   int index ;
   struct prop_global pg[2] ;
   struct mutex mutex ;
};
struct prop_local_percpu {
   struct percpu_counter events ;
   int shift ;
   unsigned long period ;
   spinlock_t lock ;
};
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
struct __anonstruct_seccomp_t_131 {
   int mode ;
};
typedef struct __anonstruct_seccomp_t_131 seccomp_t;
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct plist_node {
   int prio ;
   struct plist_head plist ;
};
struct rt_mutex {
   spinlock_t wait_lock ;
   struct plist_head wait_list ;
   struct task_struct *owner ;
};
struct rt_mutex_waiter;
struct hrtimer_sleeper;
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_mode {
    HRTIMER_MODE_ABS = 0,
    HRTIMER_MODE_REL = 1
} ;
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   int (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
   int start_pid ;
   void *start_site ;
   char start_comm[16] ;
};
struct hrtimer_sleeper {
   struct hrtimer timer ;
   struct task_struct *task ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
   ktime_t expires_next ;
   int hres_active ;
   unsigned long nr_events ;
};
struct clock_event_device;
struct tick_device;
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct __sysctl_args {
   int *name ;
   int nlen ;
   void *oldval ;
   size_t *oldlenp ;
   void *newval ;
   size_t newlen ;
   unsigned long __unused[4] ;
};
enum __anonenum_132 {
    CTL_KERN = 1,
    CTL_VM = 2,
    CTL_NET = 3,
    CTL_PROC = 4,
    CTL_FS = 5,
    CTL_DEBUG = 6,
    CTL_DEV = 7,
    CTL_BUS = 8,
    CTL_ABI = 9,
    CTL_CPU = 10,
    CTL_ARLAN = 254,
    CTL_S390DBF = 5677,
    CTL_SUNRPC = 7249,
    CTL_PM = 9899,
    CTL_FRV = 9898
} ;
enum __anonenum_133 {
    CTL_BUS_ISA = 1
} ;
enum __anonenum_134 {
    INOTIFY_MAX_USER_INSTANCES = 1,
    INOTIFY_MAX_USER_WATCHES = 2,
    INOTIFY_MAX_QUEUED_EVENTS = 3
} ;
enum __anonenum_135 {
    KERN_OSTYPE = 1,
    KERN_OSRELEASE = 2,
    KERN_OSREV = 3,
    KERN_VERSION = 4,
    KERN_SECUREMASK = 5,
    KERN_PROF = 6,
    KERN_NODENAME = 7,
    KERN_DOMAINNAME = 8,
    KERN_PANIC = 15,
    KERN_REALROOTDEV = 16,
    KERN_SPARC_REBOOT = 21,
    KERN_CTLALTDEL = 22,
    KERN_PRINTK = 23,
    KERN_NAMETRANS = 24,
    KERN_PPC_HTABRECLAIM = 25,
    KERN_PPC_ZEROPAGED = 26,
    KERN_PPC_POWERSAVE_NAP = 27,
    KERN_MODPROBE = 28,
    KERN_SG_BIG_BUFF = 29,
    KERN_ACCT = 30,
    KERN_PPC_L2CR = 31,
    KERN_RTSIGNR = 32,
    KERN_RTSIGMAX = 33,
    KERN_SHMMAX = 34,
    KERN_MSGMAX = 35,
    KERN_MSGMNB = 36,
    KERN_MSGPOOL = 37,
    KERN_SYSRQ = 38,
    KERN_MAX_THREADS = 39,
    KERN_RANDOM = 40,
    KERN_SHMALL = 41,
    KERN_MSGMNI = 42,
    KERN_SEM = 43,
    KERN_SPARC_STOP_A = 44,
    KERN_SHMMNI = 45,
    KERN_OVERFLOWUID = 46,
    KERN_OVERFLOWGID = 47,
    KERN_SHMPATH = 48,
    KERN_HOTPLUG = 49,
    KERN_IEEE_EMULATION_WARNINGS = 50,
    KERN_S390_USER_DEBUG_LOGGING = 51,
    KERN_CORE_USES_PID = 52,
    KERN_TAINTED = 53,
    KERN_CADPID = 54,
    KERN_PIDMAX = 55,
    KERN_CORE_PATTERN = 56,
    KERN_PANIC_ON_OOPS = 57,
    KERN_HPPA_PWRSW = 58,
    KERN_HPPA_UNALIGNED = 59,
    KERN_PRINTK_RATELIMIT = 60,
    KERN_PRINTK_RATELIMIT_BURST = 61,
    KERN_PTY = 62,
    KERN_NGROUPS_MAX = 63,
    KERN_SPARC_SCONS_PWROFF = 64,
    KERN_HZ_TIMER = 65,
    KERN_UNKNOWN_NMI_PANIC = 66,
    KERN_BOOTLOADER_TYPE = 67,
    KERN_RANDOMIZE = 68,
    KERN_SETUID_DUMPABLE = 69,
    KERN_SPIN_RETRY = 70,
    KERN_ACPI_VIDEO_FLAGS = 71,
    KERN_IA64_UNALIGNED = 72,
    KERN_COMPAT_LOG = 73,
    KERN_MAX_LOCK_DEPTH = 74,
    KERN_NMI_WATCHDOG = 75,
    KERN_PANIC_ON_NMI = 76
} ;
enum __anonenum_136 {
    VM_UNUSED1 = 1,
    VM_UNUSED2 = 2,
    VM_UNUSED3 = 3,
    VM_UNUSED4 = 4,
    VM_OVERCOMMIT_MEMORY = 5,
    VM_UNUSED5 = 6,
    VM_UNUSED7 = 7,
    VM_UNUSED8 = 8,
    VM_UNUSED9 = 9,
    VM_PAGE_CLUSTER = 10,
    VM_DIRTY_BACKGROUND = 11,
    VM_DIRTY_RATIO = 12,
    VM_DIRTY_WB_CS = 13,
    VM_DIRTY_EXPIRE_CS = 14,
    VM_NR_PDFLUSH_THREADS = 15,
    VM_OVERCOMMIT_RATIO = 16,
    VM_PAGEBUF = 17,
    VM_HUGETLB_PAGES = 18,
    VM_SWAPPINESS = 19,
    VM_LOWMEM_RESERVE_RATIO = 20,
    VM_MIN_FREE_KBYTES = 21,
    VM_MAX_MAP_COUNT = 22,
    VM_LAPTOP_MODE = 23,
    VM_BLOCK_DUMP = 24,
    VM_HUGETLB_GROUP = 25,
    VM_VFS_CACHE_PRESSURE = 26,
    VM_LEGACY_VA_LAYOUT = 27,
    VM_SWAP_TOKEN_TIMEOUT = 28,
    VM_DROP_PAGECACHE = 29,
    VM_PERCPU_PAGELIST_FRACTION = 30,
    VM_ZONE_RECLAIM_MODE = 31,
    VM_MIN_UNMAPPED = 32,
    VM_PANIC_ON_OOM = 33,
    VM_VDSO_ENABLED = 34,
    VM_MIN_SLAB = 35
} ;
enum __anonenum_137 {
    NET_CORE = 1,
    NET_ETHER = 2,
    NET_802 = 3,
    NET_UNIX = 4,
    NET_IPV4 = 5,
    NET_IPX = 6,
    NET_ATALK = 7,
    NET_NETROM = 8,
    NET_AX25 = 9,
    NET_BRIDGE = 10,
    NET_ROSE = 11,
    NET_IPV6 = 12,
    NET_X25 = 13,
    NET_TR = 14,
    NET_DECNET = 15,
    NET_ECONET = 16,
    NET_SCTP = 17,
    NET_LLC = 18,
    NET_NETFILTER = 19,
    NET_DCCP = 20,
    NET_IRDA = 412
} ;
enum __anonenum_138 {
    RANDOM_POOLSIZE = 1,
    RANDOM_ENTROPY_COUNT = 2,
    RANDOM_READ_THRESH = 3,
    RANDOM_WRITE_THRESH = 4,
    RANDOM_BOOT_ID = 5,
    RANDOM_UUID = 6
} ;
enum __anonenum_139 {
    PTY_MAX = 1,
    PTY_NR = 2
} ;
enum __anonenum_140 {
    BUS_ISA_MEM_BASE = 1,
    BUS_ISA_PORT_BASE = 2,
    BUS_ISA_PORT_SHIFT = 3
} ;
enum __anonenum_141 {
    NET_CORE_WMEM_MAX = 1,
    NET_CORE_RMEM_MAX = 2,
    NET_CORE_WMEM_DEFAULT = 3,
    NET_CORE_RMEM_DEFAULT = 4,
    NET_CORE_MAX_BACKLOG = 6,
    NET_CORE_FASTROUTE = 7,
    NET_CORE_MSG_COST = 8,
    NET_CORE_MSG_BURST = 9,
    NET_CORE_OPTMEM_MAX = 10,
    NET_CORE_HOT_LIST_LENGTH = 11,
    NET_CORE_DIVERT_VERSION = 12,
    NET_CORE_NO_CONG_THRESH = 13,
    NET_CORE_NO_CONG = 14,
    NET_CORE_LO_CONG = 15,
    NET_CORE_MOD_CONG = 16,
    NET_CORE_DEV_WEIGHT = 17,
    NET_CORE_SOMAXCONN = 18,
    NET_CORE_BUDGET = 19,
    NET_CORE_AEVENT_ETIME = 20,
    NET_CORE_AEVENT_RSEQTH = 21,
    NET_CORE_WARNINGS = 22
} ;
enum __anonenum_142 {
    NET_UNIX_DESTROY_DELAY = 1,
    NET_UNIX_DELETE_DELAY = 2,
    NET_UNIX_MAX_DGRAM_QLEN = 3
} ;
enum __anonenum_143 {
    NET_NF_CONNTRACK_MAX = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_NF_CONNTRACK_BUCKETS = 14,
    NET_NF_CONNTRACK_LOG_INVALID = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_NF_CONNTRACK_COUNT = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
    NET_NF_CONNTRACK_CHECKSUM = 32
} ;
enum __anonenum_144 {
    NET_IPV4_FORWARD = 8,
    NET_IPV4_DYNADDR = 9,
    NET_IPV4_CONF = 16,
    NET_IPV4_NEIGH = 17,
    NET_IPV4_ROUTE = 18,
    NET_IPV4_FIB_HASH = 19,
    NET_IPV4_NETFILTER = 20,
    NET_IPV4_TCP_TIMESTAMPS = 33,
    NET_IPV4_TCP_WINDOW_SCALING = 34,
    NET_IPV4_TCP_SACK = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
    NET_IPV4_DEFAULT_TTL = 37,
    NET_IPV4_AUTOCONFIG = 38,
    NET_IPV4_NO_PMTU_DISC = 39,
    NET_IPV4_TCP_SYN_RETRIES = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH = 41,
    NET_IPV4_IPFRAG_LOW_THRESH = 42,
    NET_IPV4_IPFRAG_TIME = 43,
    NET_IPV4_TCP_MAX_KA_PROBES = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
    NET_IPV4_TCP_RETRIES1 = 47,
    NET_IPV4_TCP_RETRIES2 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT = 49,
    NET_IPV4_IP_MASQ_DEBUG = 50,
    NET_TCP_SYNCOOKIES = 51,
    NET_TCP_STDURG = 52,
    NET_TCP_RFC1337 = 53,
    NET_TCP_SYN_TAILDROP = 54,
    NET_TCP_MAX_SYN_BACKLOG = 55,
    NET_IPV4_LOCAL_PORT_RANGE = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
    NET_TCP_TW_RECYCLE = 66,
    NET_IPV4_ALWAYS_DEFRAG = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
    NET_IPV4_INET_PEER_THRESHOLD = 69,
    NET_IPV4_INET_PEER_MINTTL = 70,
    NET_IPV4_INET_PEER_MAXTTL = 71,
    NET_IPV4_INET_PEER_GC_MINTIME = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME = 73,
    NET_TCP_ORPHAN_RETRIES = 74,
    NET_TCP_ABORT_ON_OVERFLOW = 75,
    NET_TCP_SYNACK_RETRIES = 76,
    NET_TCP_MAX_ORPHANS = 77,
    NET_TCP_MAX_TW_BUCKETS = 78,
    NET_TCP_FACK = 79,
    NET_TCP_REORDERING = 80,
    NET_TCP_ECN = 81,
    NET_TCP_DSACK = 82,
    NET_TCP_MEM = 83,
    NET_TCP_WMEM = 84,
    NET_TCP_RMEM = 85,
    NET_TCP_APP_WIN = 86,
    NET_TCP_ADV_WIN_SCALE = 87,
    NET_IPV4_NONLOCAL_BIND = 88,
    NET_IPV4_ICMP_RATELIMIT = 89,
    NET_IPV4_ICMP_RATEMASK = 90,
    NET_TCP_TW_REUSE = 91,
    NET_TCP_FRTO = 92,
    NET_TCP_LOW_LATENCY = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
    NET_IPV4_IGMP_MAX_MSF = 96,
    NET_TCP_NO_METRICS_SAVE = 97,
    NET_TCP_DEFAULT_WIN_SCALE = 105,
    NET_TCP_MODERATE_RCVBUF = 106,
    NET_TCP_TSO_WIN_DIVISOR = 107,
    NET_TCP_BIC_BETA = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
    NET_TCP_CONG_CONTROL = 110,
    NET_TCP_ABC = 111,
    NET_IPV4_IPFRAG_MAX_DIST = 112,
    NET_TCP_MTU_PROBING = 113,
    NET_TCP_BASE_MSS = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
    NET_TCP_DMA_COPYBREAK = 116,
    NET_TCP_SLOW_START_AFTER_IDLE = 117,
    NET_CIPSOV4_CACHE_ENABLE = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
    NET_CIPSOV4_RBM_OPTFMT = 120,
    NET_CIPSOV4_RBM_STRICTVALID = 121,
    NET_TCP_AVAIL_CONG_CONTROL = 122,
    NET_TCP_ALLOWED_CONG_CONTROL = 123,
    NET_TCP_MAX_SSTHRESH = 124,
    NET_TCP_FRTO_RESPONSE = 125
} ;
enum __anonenum_145 {
    NET_IPV4_ROUTE_FLUSH = 1,
    NET_IPV4_ROUTE_MIN_DELAY = 2,
    NET_IPV4_ROUTE_MAX_DELAY = 3,
    NET_IPV4_ROUTE_GC_THRESH = 4,
    NET_IPV4_ROUTE_MAX_SIZE = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT = 7,
    NET_IPV4_ROUTE_GC_INTERVAL = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
    NET_IPV4_ROUTE_ERROR_COST = 12,
    NET_IPV4_ROUTE_ERROR_BURST = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES = 15,
    NET_IPV4_ROUTE_MIN_PMTU = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19
} ;
enum __anonenum_146 {
    NET_PROTO_CONF_ALL = -2,
    NET_PROTO_CONF_DEFAULT = -3
} ;
enum __anonenum_147 {
    NET_IPV4_CONF_FORWARDING = 1,
    NET_IPV4_CONF_MC_FORWARDING = 2,
    NET_IPV4_CONF_PROXY_ARP = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS = 5,
    NET_IPV4_CONF_SEND_REDIRECTS = 6,
    NET_IPV4_CONF_SHARED_MEDIA = 7,
    NET_IPV4_CONF_RP_FILTER = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
    NET_IPV4_CONF_BOOTP_RELAY = 10,
    NET_IPV4_CONF_LOG_MARTIANS = 11,
    NET_IPV4_CONF_TAG = 12,
    NET_IPV4_CONF_ARPFILTER = 13,
    NET_IPV4_CONF_MEDIUM_ID = 14,
    NET_IPV4_CONF_NOXFRM = 15,
    NET_IPV4_CONF_NOPOLICY = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE = 18,
    NET_IPV4_CONF_ARP_IGNORE = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
    NET_IPV4_CONF_ARP_ACCEPT = 21,
    NET_IPV4_CONF_ARP_NOTIFY = 22,
    __NET_IPV4_CONF_MAX = 23
} ;
enum __anonenum_148 {
    NET_IPV4_NF_CONNTRACK_MAX = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_IPV4_NF_CONNTRACK_COUNT = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM = 28
} ;
enum __anonenum_149 {
    NET_IPV6_CONF = 16,
    NET_IPV6_NEIGH = 17,
    NET_IPV6_ROUTE = 18,
    NET_IPV6_ICMP = 19,
    NET_IPV6_BINDV6ONLY = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH = 22,
    NET_IPV6_IP6FRAG_TIME = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
    NET_IPV6_MLD_MAX_MSF = 25
} ;
enum __anonenum_150 {
    NET_IPV6_ROUTE_FLUSH = 1,
    NET_IPV6_ROUTE_GC_THRESH = 2,
    NET_IPV6_ROUTE_MAX_SIZE = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT = 5,
    NET_IPV6_ROUTE_GC_INTERVAL = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10
} ;
enum __anonenum_151 {
    NET_IPV6_FORWARDING = 1,
    NET_IPV6_HOP_LIMIT = 2,
    NET_IPV6_MTU = 3,
    NET_IPV6_ACCEPT_RA = 4,
    NET_IPV6_ACCEPT_REDIRECTS = 5,
    NET_IPV6_AUTOCONF = 6,
    NET_IPV6_DAD_TRANSMITS = 7,
    NET_IPV6_RTR_SOLICITS = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
    NET_IPV6_RTR_SOLICIT_DELAY = 10,
    NET_IPV6_USE_TEMPADDR = 11,
    NET_IPV6_TEMP_VALID_LFT = 12,
    NET_IPV6_TEMP_PREFERED_LFT = 13,
    NET_IPV6_REGEN_MAX_RETRY = 14,
    NET_IPV6_MAX_DESYNC_FACTOR = 15,
    NET_IPV6_MAX_ADDRESSES = 16,
    NET_IPV6_FORCE_MLD_VERSION = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR = 18,
    NET_IPV6_ACCEPT_RA_PINFO = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
    NET_IPV6_RTR_PROBE_INTERVAL = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
    NET_IPV6_PROXY_NDP = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
    __NET_IPV6_MAX = 26
} ;
enum __anonenum_152 {
    NET_IPV6_ICMP_RATELIMIT = 1
} ;
enum __anonenum_153 {
    NET_NEIGH_MCAST_SOLICIT = 1,
    NET_NEIGH_UCAST_SOLICIT = 2,
    NET_NEIGH_APP_SOLICIT = 3,
    NET_NEIGH_RETRANS_TIME = 4,
    NET_NEIGH_REACHABLE_TIME = 5,
    NET_NEIGH_DELAY_PROBE_TIME = 6,
    NET_NEIGH_GC_STALE_TIME = 7,
    NET_NEIGH_UNRES_QLEN = 8,
    NET_NEIGH_PROXY_QLEN = 9,
    NET_NEIGH_ANYCAST_DELAY = 10,
    NET_NEIGH_PROXY_DELAY = 11,
    NET_NEIGH_LOCKTIME = 12,
    NET_NEIGH_GC_INTERVAL = 13,
    NET_NEIGH_GC_THRESH1 = 14,
    NET_NEIGH_GC_THRESH2 = 15,
    NET_NEIGH_GC_THRESH3 = 16,
    NET_NEIGH_RETRANS_TIME_MS = 17,
    NET_NEIGH_REACHABLE_TIME_MS = 18,
    __NET_NEIGH_MAX = 19
} ;
enum __anonenum_154 {
    NET_DCCP_DEFAULT = 1
} ;
enum __anonenum_155 {
    NET_IPX_PPROP_BROADCASTING = 1,
    NET_IPX_FORWARDING = 2
} ;
enum __anonenum_156 {
    NET_LLC2 = 1,
    NET_LLC_STATION = 2
} ;
enum __anonenum_157 {
    NET_LLC2_TIMEOUT = 1
} ;
enum __anonenum_158 {
    NET_LLC_STATION_ACK_TIMEOUT = 1
} ;
enum __anonenum_159 {
    NET_LLC2_ACK_TIMEOUT = 1,
    NET_LLC2_P_TIMEOUT = 2,
    NET_LLC2_REJ_TIMEOUT = 3,
    NET_LLC2_BUSY_TIMEOUT = 4
} ;
enum __anonenum_160 {
    NET_ATALK_AARP_EXPIRY_TIME = 1,
    NET_ATALK_AARP_TICK_TIME = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
    NET_ATALK_AARP_RESOLVE_TIME = 4
} ;
enum __anonenum_161 {
    NET_NETROM_DEFAULT_PATH_QUALITY = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER = 3,
    NET_NETROM_TRANSPORT_TIMEOUT = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
    NET_NETROM_ROUTING_CONTROL = 10,
    NET_NETROM_LINK_FAILS_COUNT = 11,
    NET_NETROM_RESET = 12
} ;
enum __anonenum_162 {
    NET_AX25_IP_DEFAULT_MODE = 1,
    NET_AX25_DEFAULT_MODE = 2,
    NET_AX25_BACKOFF_TYPE = 3,
    NET_AX25_CONNECT_MODE = 4,
    NET_AX25_STANDARD_WINDOW = 5,
    NET_AX25_EXTENDED_WINDOW = 6,
    NET_AX25_T1_TIMEOUT = 7,
    NET_AX25_T2_TIMEOUT = 8,
    NET_AX25_T3_TIMEOUT = 9,
    NET_AX25_IDLE_TIMEOUT = 10,
    NET_AX25_N2 = 11,
    NET_AX25_PACLEN = 12,
    NET_AX25_PROTOCOL = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT = 14
} ;
enum __anonenum_163 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_ROSE_ROUTING_CONTROL = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT = 7,
    NET_ROSE_MAX_VCS = 8,
    NET_ROSE_WINDOW_SIZE = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT = 10
} ;
enum __anonenum_164 {
    NET_X25_RESTART_REQUEST_TIMEOUT = 1,
    NET_X25_CALL_REQUEST_TIMEOUT = 2,
    NET_X25_RESET_REQUEST_TIMEOUT = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_X25_FORWARD = 6
} ;
enum __anonenum_165 {
    NET_TR_RIF_TIMEOUT = 1
} ;
enum __anonenum_166 {
    NET_DECNET_NODE_TYPE = 1,
    NET_DECNET_NODE_ADDRESS = 2,
    NET_DECNET_NODE_NAME = 3,
    NET_DECNET_DEFAULT_DEVICE = 4,
    NET_DECNET_TIME_WAIT = 5,
    NET_DECNET_DN_COUNT = 6,
    NET_DECNET_DI_COUNT = 7,
    NET_DECNET_DR_COUNT = 8,
    NET_DECNET_DST_GC_INTERVAL = 9,
    NET_DECNET_CONF = 10,
    NET_DECNET_NO_FC_MAX_CWND = 11,
    NET_DECNET_MEM = 12,
    NET_DECNET_RMEM = 13,
    NET_DECNET_WMEM = 14,
    NET_DECNET_DEBUG_LEVEL = 255
} ;
enum __anonenum_167 {
    NET_DECNET_CONF_LOOPBACK = -2,
    NET_DECNET_CONF_DDCMP = -3,
    NET_DECNET_CONF_PPP = -4,
    NET_DECNET_CONF_X25 = -5,
    NET_DECNET_CONF_GRE = -6,
    NET_DECNET_CONF_ETHER = -7
} ;
enum __anonenum_168 {
    NET_DECNET_CONF_DEV_PRIORITY = 1,
    NET_DECNET_CONF_DEV_T1 = 2,
    NET_DECNET_CONF_DEV_T2 = 3,
    NET_DECNET_CONF_DEV_T3 = 4,
    NET_DECNET_CONF_DEV_FORWARDING = 5,
    NET_DECNET_CONF_DEV_BLKSIZE = 6,
    NET_DECNET_CONF_DEV_STATE = 7
} ;
enum __anonenum_169 {
    NET_SCTP_RTO_INITIAL = 1,
    NET_SCTP_RTO_MIN = 2,
    NET_SCTP_RTO_MAX = 3,
    NET_SCTP_RTO_ALPHA = 4,
    NET_SCTP_RTO_BETA = 5,
    NET_SCTP_VALID_COOKIE_LIFE = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
    NET_SCTP_PATH_MAX_RETRANS = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS = 9,
    NET_SCTP_HB_INTERVAL = 10,
    NET_SCTP_PRESERVE_ENABLE = 11,
    NET_SCTP_MAX_BURST = 12,
    NET_SCTP_ADDIP_ENABLE = 13,
    NET_SCTP_PRSCTP_ENABLE = 14,
    NET_SCTP_SNDBUF_POLICY = 15,
    NET_SCTP_SACK_TIMEOUT = 16,
    NET_SCTP_RCVBUF_POLICY = 17
} ;
enum __anonenum_170 {
    NET_BRIDGE_NF_CALL_ARPTABLES = 1,
    NET_BRIDGE_NF_CALL_IPTABLES = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5
} ;
enum __anonenum_171 {
    NET_IRDA_DISCOVERY = 1,
    NET_IRDA_DEVNAME = 2,
    NET_IRDA_DEBUG = 3,
    NET_IRDA_FAST_POLL = 4,
    NET_IRDA_DISCOVERY_SLOTS = 5,
    NET_IRDA_DISCOVERY_TIMEOUT = 6,
    NET_IRDA_SLOT_TIMEOUT = 7,
    NET_IRDA_MAX_BAUD_RATE = 8,
    NET_IRDA_MIN_TX_TURN_TIME = 9,
    NET_IRDA_MAX_TX_DATA_SIZE = 10,
    NET_IRDA_MAX_TX_WINDOW = 11,
    NET_IRDA_MAX_NOREPLY_TIME = 12,
    NET_IRDA_WARN_NOREPLY_TIME = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME = 14
} ;
enum __anonenum_172 {
    FS_NRINODE = 1,
    FS_STATINODE = 2,
    FS_MAXINODE = 3,
    FS_NRDQUOT = 4,
    FS_MAXDQUOT = 5,
    FS_NRFILE = 6,
    FS_MAXFILE = 7,
    FS_DENTRY = 8,
    FS_NRSUPER = 9,
    FS_MAXSUPER = 10,
    FS_OVERFLOWUID = 11,
    FS_OVERFLOWGID = 12,
    FS_LEASES = 13,
    FS_DIR_NOTIFY = 14,
    FS_LEASE_TIME = 15,
    FS_DQSTATS = 16,
    FS_XFS = 17,
    FS_AIO_NR = 18,
    FS_AIO_MAX_NR = 19,
    FS_INOTIFY = 20,
    FS_OCFS2 = 988
} ;
enum __anonenum_173 {
    FS_DQ_LOOKUPS = 1,
    FS_DQ_DROPS = 2,
    FS_DQ_READS = 3,
    FS_DQ_WRITES = 4,
    FS_DQ_CACHE_HITS = 5,
    FS_DQ_ALLOCATED = 6,
    FS_DQ_FREE = 7,
    FS_DQ_SYNCS = 8,
    FS_DQ_WARNINGS = 9
} ;
enum __anonenum_174 {
    DEV_CDROM = 1,
    DEV_HWMON = 2,
    DEV_PARPORT = 3,
    DEV_RAID = 4,
    DEV_MAC_HID = 5,
    DEV_SCSI = 6,
    DEV_IPMI = 7
} ;
enum __anonenum_175 {
    DEV_CDROM_INFO = 1,
    DEV_CDROM_AUTOCLOSE = 2,
    DEV_CDROM_AUTOEJECT = 3,
    DEV_CDROM_DEBUG = 4,
    DEV_CDROM_LOCK = 5,
    DEV_CDROM_CHECK_MEDIA = 6
} ;
enum __anonenum_176 {
    DEV_PARPORT_DEFAULT = -3
} ;
enum __anonenum_177 {
    DEV_RAID_SPEED_LIMIT_MIN = 1,
    DEV_RAID_SPEED_LIMIT_MAX = 2
} ;
enum __anonenum_178 {
    DEV_PARPORT_DEFAULT_TIMESLICE = 1,
    DEV_PARPORT_DEFAULT_SPINTIME = 2
} ;
enum __anonenum_179 {
    DEV_PARPORT_SPINTIME = 1,
    DEV_PARPORT_BASE_ADDR = 2,
    DEV_PARPORT_IRQ = 3,
    DEV_PARPORT_DMA = 4,
    DEV_PARPORT_MODES = 5,
    DEV_PARPORT_DEVICES = 6,
    DEV_PARPORT_AUTOPROBE = 16
} ;
enum __anonenum_180 {
    DEV_PARPORT_DEVICES_ACTIVE = -3
} ;
enum __anonenum_181 {
    DEV_PARPORT_DEVICE_TIMESLICE = 1
} ;
enum __anonenum_182 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6
} ;
enum __anonenum_183 {
    DEV_SCSI_LOGGING_LEVEL = 1
} ;
enum __anonenum_184 {
    DEV_IPMI_POWEROFF_POWERCYCLE = 1
} ;
enum __anonenum_185 {
    ABI_DEFHANDLER_COFF = 1,
    ABI_DEFHANDLER_ELF = 2,
    ABI_DEFHANDLER_LCALL7 = 3,
    ABI_DEFHANDLER_LIBCSO = 4,
    ABI_TRACE = 5,
    ABI_FAKE_UTSNAME = 6
} ;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_set {
   struct list_head list ;
   struct ctl_table_set *parent ;
   int (*is_seen)(struct ctl_table_set * ) ;
};
struct ctl_table_header;
typedef struct ctl_table ctl_table;
typedef int ctl_handler(struct ctl_table *table , void *oldval , size_t *oldlenp ,
                        void *newval , size_t newlen );
typedef int proc_handler(struct ctl_table *ctl , int write , struct file *filp , void *buffer ,
                         size_t *lenp , loff_t *ppos );
struct ctl_table {
   int ctl_name ;
   char const   *procname ;
   void *data ;
   int maxlen ;
   mode_t mode ;
   struct ctl_table *child ;
   struct ctl_table *parent ;
   proc_handler *proc_handler ;
   ctl_handler *strategy ;
   void *extra1 ;
   void *extra2 ;
};
struct ctl_table_root {
   struct list_head root_list ;
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root *root , struct nsproxy *namespaces ) ;
   int (*permissions)(struct ctl_table_root *root , struct nsproxy *namespaces , struct ctl_table *table ) ;
};
struct ctl_table_header {
   struct ctl_table *ctl_table ;
   struct list_head ctl_entry ;
   int used ;
   int count ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_table *attached_by ;
   struct ctl_table *attached_to ;
   struct ctl_table_header *parent ;
};
struct ctl_path {
   char const   *procname ;
   int ctl_name ;
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct signal_struct;
struct key_type;
struct key_owner;
struct keyring_list;
struct keyring_name;
struct __key_reference_with_attributes;
typedef struct __key_reference_with_attributes *key_ref_t;
struct key_user;
union __anonunion_type_data_186 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
union __anonunion_payload_187 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_186 type_data ;
   union __anonunion_payload_187 payload ;
};
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
struct mem_cgroup;
struct futex_pi_state;
struct robust_list_head;
struct bts_tracer;
struct fs_struct;
struct cfs_rq;
struct task_group;
struct user_namespace;
typedef unsigned long aio_context_t;
enum __anonenum_188 {
    IOCB_CMD_PREAD = 0,
    IOCB_CMD_PWRITE = 1,
    IOCB_CMD_FSYNC = 2,
    IOCB_CMD_FDSYNC = 3,
    IOCB_CMD_NOOP = 6,
    IOCB_CMD_PREADV = 7,
    IOCB_CMD_PWRITEV = 8
} ;
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
struct iocb {
   __u64 aio_data ;
   __u32 aio_key ;
   __u32 aio_reserved1 ;
   __u16 aio_lio_opcode ;
   __s16 aio_reqprio ;
   __u32 aio_fildes ;
   __u64 aio_buf ;
   __u64 aio_nbytes ;
   __s64 aio_offset ;
   __u64 aio_reserved2 ;
   __u32 aio_flags ;
   __u32 aio_resfd ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
struct kioctx;
union __anonunion_ki_obj_189 {
   void *user ;
   struct task_struct *tsk ;
};
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_189 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
struct aio_ring {
   unsigned int id ;
   unsigned int nr ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int magic ;
   unsigned int compat_features ;
   unsigned int incompat_features ;
   unsigned int header_length ;
   struct io_event io_events[0] ;
};
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
enum powersavings_balance_level {
    POWERSAVINGS_BALANCE_NONE = 0,
    POWERSAVINGS_BALANCE_BASIC = 1,
    POWERSAVINGS_BALANCE_WAKEUP = 2,
    MAX_POWERSAVINGS_BALANCE_LEVELS = 3
} ;
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
struct sched_domain_attr {
   int relax_domain_level ;
};
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   unsigned long span[] ;
};
struct io_context;
struct audit_context;
struct uts_namespace;
struct rq;
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   int (*needs_post_schedule)(struct rq *this_rq ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
   void (*moved_group)(struct task_struct *p ) ;
};
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 start_runtime ;
   u64 avg_wakeup ;
   u64 nr_migrations ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
};
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
struct linux_binfmt;
struct irqaction;
struct css_set;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   unsigned int in_execve : 1 ;
   pid_t pid ;
   pid_t tgid ;
   unsigned long stack_canary ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   struct irqaction *irqaction ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   int cpuset_mems_generation ;
   int cpuset_mem_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   struct prop_local_single dirties ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
union thread_union {
   struct thread_info thread_info ;
   unsigned long stack[((1UL << 12) << 1) / sizeof(long )] ;
};
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
struct __large_struct {
   unsigned long buf[100] ;
};
struct movsl_mask {
   int mask ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef void (*poll_queue_proc)(struct file * , wait_queue_head_t * , struct poll_table_struct * );
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
typedef struct poll_table_struct poll_table;
struct poll_table_entry {
   struct file *filp ;
   wait_queue_t wait ;
   wait_queue_head_t *wait_address ;
};
struct poll_table_page;
struct poll_wqueues {
   poll_table pt ;
   struct poll_table_page *table ;
   struct task_struct *polling_task ;
   int triggered ;
   int error ;
   int inline_index ;
   struct poll_table_entry inline_entries[576UL / sizeof(struct poll_table_entry )] ;
};
struct __anonstruct_fd_set_bits_190 {
   unsigned long *in ;
   unsigned long *out ;
   unsigned long *ex ;
   unsigned long *res_in ;
   unsigned long *res_out ;
   unsigned long *res_ex ;
};
typedef struct __anonstruct_fd_set_bits_190 fd_set_bits;
enum __anonenum_191 {
    FW_NODE_CREATED___0 = 0,
    FW_NODE_UPDATED___0 = 1,
    FW_NODE_DESTROYED___0 = 2,
    FW_NODE_LINK_ON___0 = 3,
    FW_NODE_LINK_OFF___0 = 4,
    FW_NODE_INITIATED_RESET___0 = 5
} ;
struct client {
   u32 version ;
   struct fw_device *device ;
   spinlock_t lock ;
   bool in_shutdown ;
   struct idr resource_idr ;
   struct list_head event_list ;
   wait_queue_head_t wait ;
   u64 bus_reset_closure ;
   struct fw_iso_context *iso_context ;
   u64 iso_closure ;
   struct fw_iso_buffer buffer ;
   unsigned long vm_start ;
   struct list_head link ;
   struct kref kref ;
};
struct client_resource;
typedef void (*client_resource_release_fn_t)(struct client * , struct client_resource * );
struct client_resource {
   void (*release)(struct client * , struct client_resource * ) ;
   int handle ;
};
struct address_handler_resource {
   struct client_resource resource ;
   struct fw_address_handler handler ;
   __u64 closure ;
   struct client *client ;
};
struct outbound_transaction_resource {
   struct client_resource resource ;
   struct fw_transaction transaction ;
};
struct inbound_transaction_resource {
   struct client_resource resource ;
   struct fw_request *request ;
   void *data ;
   size_t length ;
};
struct descriptor_resource {
   struct client_resource resource ;
   struct fw_descriptor descriptor ;
   u32 data[0] ;
};
enum __anonenum_todo_192 {
    ISO_RES_ALLOC = 0,
    ISO_RES_REALLOC = 1,
    ISO_RES_DEALLOC = 2,
    ISO_RES_ALLOC_ONCE = 3,
    ISO_RES_DEALLOC_ONCE = 4
} ;
struct iso_resource_event;
struct iso_resource {
   struct client_resource resource ;
   struct client *client ;
   struct delayed_work work ;
   enum __anonenum_todo_192 todo ;
   int generation ;
   u64 channels ;
   s32 bandwidth ;
   struct iso_resource_event *e_alloc ;
   struct iso_resource_event *e_dealloc ;
};
struct __anonstruct_v_193 {
   void *data ;
   size_t size ;
};
struct event {
   struct __anonstruct_v_193 v[2] ;
   struct list_head link ;
};
struct bus_reset_event {
   struct event event ;
   struct fw_cdev_event_bus_reset reset ;
};
struct outbound_transaction_event {
   struct event event ;
   struct client *client ;
   struct outbound_transaction_resource r ;
   struct fw_cdev_event_response response ;
};
struct inbound_transaction_event {
   struct event event ;
   struct fw_cdev_event_request request ;
};
struct iso_interrupt_event {
   struct event event ;
   struct fw_cdev_event_iso_interrupt interrupt ;
};
struct iso_resource_event {
   struct event event ;
   struct fw_cdev_event_iso_resource resource ;
};
struct __anonstruct_u_194 {
   struct fw_iso_packet packet ;
   u8 header[256] ;
};
enum __anonenum_4___1 {
    false___1 = 0,
    true___1 = 1
} ;
enum __anonenum_8___0 {
    DUMP_PREFIX_NONE___1 = 0,
    DUMP_PREFIX_ADDRESS___1 = 1,
    DUMP_PREFIX_OFFSET___1 = 2
} ;
enum __anonenum_15___1 {
    PG_LEVEL_NONE___1 = 0,
    PG_LEVEL_4K___1 = 1,
    PG_LEVEL_2M___1 = 2,
    PG_LEVEL_1G___1 = 3,
    PG_LEVEL_NUM___1 = 4
} ;
enum __anonenum_19___1 {
    GATE_INTERRUPT___1 = 14,
    GATE_TRAP___1 = 15,
    GATE_CALL___1 = 12,
    GATE_TASK___1 = 5
} ;
enum __anonenum_20___1 {
    DESC_TSS___1 = 9,
    DESC_LDT___1 = 2,
    DESCTYPE_S___1 = 16
} ;
enum __anonenum_21___1 {
    ADDR_NO_RANDOMIZE___1 = 262144,
    FDPIC_FUNCPTRS___1 = 524288,
    MMAP_PAGE_ZERO___1 = 1048576,
    ADDR_COMPAT_LAYOUT___1 = 2097152,
    READ_IMPLIES_EXEC___1 = 4194304,
    ADDR_LIMIT_32BIT___1 = 8388608,
    SHORT_INODE___1 = 16777216,
    WHOLE_SECONDS___1 = 33554432,
    STICKY_TIMEOUTS___1 = 67108864,
    ADDR_LIMIT_3GB___1 = 134217728
} ;
enum __anonenum_22___1 {
    PER_LINUX___1 = 0,
    PER_LINUX_32BIT___1 = 8388608,
    PER_LINUX_FDPIC___1 = 524288,
    PER_SVR4___1 = 68157441,
    PER_SVR3___1 = 83886082,
    PER_SCOSVR3___1 = 117440515,
    PER_OSR5___1 = 100663299,
    PER_WYSEV386___1 = 83886084,
    PER_ISCR4___1 = 67108869,
    PER_BSD___1 = 6,
    PER_SUNOS___1 = 67108870,
    PER_XENIX___1 = 83886087,
    PER_LINUX32___1 = 8,
    PER_LINUX32_3GB___1 = 134217736,
    PER_IRIX32___1 = 67108873,
    PER_IRIXN32___1 = 67108874,
    PER_IRIX64___1 = 67108875,
    PER_RISCOS___1 = 12,
    PER_SOLARIS___1 = 67108877,
    PER_UW7___1 = 68157454,
    PER_OSF4___1 = 15,
    PER_HPUX___1 = 16,
    PER_MASK___1 = 255
} ;
union __anonunion_d_37___1 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_102 {
    QIF_BLIMITS_B___1 = 0,
    QIF_SPACE_B___1 = 1,
    QIF_ILIMITS_B___1 = 2,
    QIF_INODES_B___1 = 3,
    QIF_BTIME_B___1 = 4,
    QIF_ITIME_B___1 = 5
} ;
enum __anonenum_103 {
    QUOTA_NL_C_UNSPEC___1 = 0,
    QUOTA_NL_C_WARNING___1 = 1,
    __QUOTA_NL_C_MAX___1 = 2
} ;
enum __anonenum_104 {
    QUOTA_NL_A_UNSPEC___1 = 0,
    QUOTA_NL_A_QTYPE___1 = 1,
    QUOTA_NL_A_EXCESS_ID___1 = 2,
    QUOTA_NL_A_WARNING___1 = 3,
    QUOTA_NL_A_DEV_MAJOR___1 = 4,
    QUOTA_NL_A_DEV_MINOR___1 = 5,
    QUOTA_NL_A_CAUSED_ID___1 = 6,
    __QUOTA_NL_A_MAX___1 = 7
} ;
enum __anonenum_105 {
    _DQUOT_USAGE_ENABLED___1 = 0,
    _DQUOT_LIMITS_ENABLED___1 = 1,
    _DQUOT_SUSPENDED___1 = 2,
    _DQUOT_STATE_FLAGS___1 = 3
} ;
enum __anonenum_112___1 {
    SB_UNFROZEN___1 = 0,
    SB_FREEZE_WRITE___1 = 1,
    SB_FREEZE_TRANS___1 = 2
} ;
enum __anonenum_113___0 {
    DIO_LOCKING___1 = 1,
    DIO_NO_LOCKING___1 = 2,
    DIO_OWN_LOCKING___1 = 3
} ;
enum __anonenum_114 {
    FW_NODE_CREATED___1 = 0,
    FW_NODE_UPDATED___1 = 1,
    FW_NODE_DESTROYED___1 = 2,
    FW_NODE_LINK_ON___1 = 3,
    FW_NODE_LINK_OFF___1 = 4,
    FW_NODE_INITIATED_RESET___1 = 5
} ;
struct config_rom_attribute {
   struct device_attribute attr ;
   u32 key ;
};
enum __anonenum_122 {
    BC_UNKNOWN = 0,
    BC_UNIMPLEMENTED = 1,
    BC_IMPLEMENTED = 2
} ;
enum __anonenum_123 {
    REREAD_BIB_ERROR = 0,
    REREAD_BIB_GONE = 1,
    REREAD_BIB_UNCHANGED = 2,
    REREAD_BIB_CHANGED = 3
} ;
enum __anonenum_4___2 {
    false___2 = 0,
    true___2 = 1
} ;
enum __anonenum_10___0 {
    DUMP_PREFIX_NONE___2 = 0,
    DUMP_PREFIX_ADDRESS___2 = 1,
    DUMP_PREFIX_OFFSET___2 = 2
} ;
enum __anonenum_15___2 {
    PG_LEVEL_NONE___2 = 0,
    PG_LEVEL_4K___2 = 1,
    PG_LEVEL_2M___2 = 2,
    PG_LEVEL_1G___2 = 3,
    PG_LEVEL_NUM___2 = 4
} ;
enum __anonenum_19___2 {
    GATE_INTERRUPT___2 = 14,
    GATE_TRAP___2 = 15,
    GATE_CALL___2 = 12,
    GATE_TASK___2 = 5
} ;
enum __anonenum_20___2 {
    DESC_TSS___2 = 9,
    DESC_LDT___2 = 2,
    DESCTYPE_S___2 = 16
} ;
enum __anonenum_21___2 {
    ADDR_NO_RANDOMIZE___2 = 262144,
    FDPIC_FUNCPTRS___2 = 524288,
    MMAP_PAGE_ZERO___2 = 1048576,
    ADDR_COMPAT_LAYOUT___2 = 2097152,
    READ_IMPLIES_EXEC___2 = 4194304,
    ADDR_LIMIT_32BIT___2 = 8388608,
    SHORT_INODE___2 = 16777216,
    WHOLE_SECONDS___2 = 33554432,
    STICKY_TIMEOUTS___2 = 67108864,
    ADDR_LIMIT_3GB___2 = 134217728
} ;
enum __anonenum_22___2 {
    PER_LINUX___2 = 0,
    PER_LINUX_32BIT___2 = 8388608,
    PER_LINUX_FDPIC___2 = 524288,
    PER_SVR4___2 = 68157441,
    PER_SVR3___2 = 83886082,
    PER_SCOSVR3___2 = 117440515,
    PER_OSR5___2 = 100663299,
    PER_WYSEV386___2 = 83886084,
    PER_ISCR4___2 = 67108869,
    PER_BSD___2 = 6,
    PER_SUNOS___2 = 67108870,
    PER_XENIX___2 = 83886087,
    PER_LINUX32___2 = 8,
    PER_LINUX32_3GB___2 = 134217736,
    PER_IRIX32___2 = 67108873,
    PER_IRIXN32___2 = 67108874,
    PER_IRIX64___2 = 67108875,
    PER_RISCOS___2 = 12,
    PER_SOLARIS___2 = 67108877,
    PER_UW7___2 = 68157454,
    PER_OSF4___2 = 15,
    PER_HPUX___2 = 16,
    PER_MASK___2 = 255
} ;
union __anonunion_d_37___2 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_107___0 {
    FW_NODE_CREATED___2 = 0,
    FW_NODE_UPDATED___2 = 1,
    FW_NODE_DESTROYED___2 = 2,
    FW_NODE_LINK_ON___2 = 3,
    FW_NODE_LINK_OFF___2 = 4,
    FW_NODE_INITIATED_RESET___2 = 5
} ;
enum __anonenum_4___3 {
    false___3 = 0,
    true___3 = 1
} ;
enum __anonenum_10___1 {
    DUMP_PREFIX_NONE___3 = 0,
    DUMP_PREFIX_ADDRESS___3 = 1,
    DUMP_PREFIX_OFFSET___3 = 2
} ;
enum __anonenum_15___3 {
    PG_LEVEL_NONE___3 = 0,
    PG_LEVEL_4K___3 = 1,
    PG_LEVEL_2M___3 = 2,
    PG_LEVEL_1G___3 = 3,
    PG_LEVEL_NUM___3 = 4
} ;
enum __anonenum_19___3 {
    GATE_INTERRUPT___3 = 14,
    GATE_TRAP___3 = 15,
    GATE_CALL___3 = 12,
    GATE_TASK___3 = 5
} ;
enum __anonenum_20___3 {
    DESC_TSS___3 = 9,
    DESC_LDT___3 = 2,
    DESCTYPE_S___3 = 16
} ;
enum __anonenum_21___3 {
    ADDR_NO_RANDOMIZE___3 = 262144,
    FDPIC_FUNCPTRS___3 = 524288,
    MMAP_PAGE_ZERO___3 = 1048576,
    ADDR_COMPAT_LAYOUT___3 = 2097152,
    READ_IMPLIES_EXEC___3 = 4194304,
    ADDR_LIMIT_32BIT___3 = 8388608,
    SHORT_INODE___3 = 16777216,
    WHOLE_SECONDS___3 = 33554432,
    STICKY_TIMEOUTS___3 = 67108864,
    ADDR_LIMIT_3GB___3 = 134217728
} ;
enum __anonenum_22___3 {
    PER_LINUX___3 = 0,
    PER_LINUX_32BIT___3 = 8388608,
    PER_LINUX_FDPIC___3 = 524288,
    PER_SVR4___3 = 68157441,
    PER_SVR3___3 = 83886082,
    PER_SCOSVR3___3 = 117440515,
    PER_OSR5___3 = 100663299,
    PER_WYSEV386___3 = 83886084,
    PER_ISCR4___3 = 67108869,
    PER_BSD___3 = 6,
    PER_SUNOS___3 = 67108870,
    PER_XENIX___3 = 83886087,
    PER_LINUX32___3 = 8,
    PER_LINUX32_3GB___3 = 134217736,
    PER_IRIX32___3 = 67108873,
    PER_IRIXN32___3 = 67108874,
    PER_IRIX64___3 = 67108875,
    PER_RISCOS___3 = 12,
    PER_SOLARIS___3 = 67108877,
    PER_UW7___3 = 68157454,
    PER_OSF4___3 = 15,
    PER_HPUX___3 = 16,
    PER_MASK___3 = 255
} ;
union __anonunion_d_37___3 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum __anonenum_107___1 {
    FW_NODE_CREATED___3 = 0,
    FW_NODE_UPDATED___3 = 1,
    FW_NODE_DESTROYED___3 = 2,
    FW_NODE_LINK_ON___3 = 3,
    FW_NODE_LINK_OFF___3 = 4,
    FW_NODE_INITIATED_RESET___3 = 5
} ;
typedef void (*fw_node_callback_t)(struct fw_card *card , struct fw_node *node , struct fw_node *parent );
enum __anonenum_4___4 {
    false___4 = 0,
    true___4 = 1
} ;
enum __anonenum_10___2 {
    DUMP_PREFIX_NONE___4 = 0,
    DUMP_PREFIX_ADDRESS___4 = 1,
    DUMP_PREFIX_OFFSET___4 = 2
} ;
enum __anonenum_15___4 {
    PG_LEVEL_NONE___4 = 0,
    PG_LEVEL_4K___4 = 1,
    PG_LEVEL_2M___4 = 2,
    PG_LEVEL_1G___4 = 3,
    PG_LEVEL_NUM___4 = 4
} ;
enum __anonenum_19___4 {
    GATE_INTERRUPT___4 = 14,
    GATE_TRAP___4 = 15,
    GATE_CALL___4 = 12,
    GATE_TASK___4 = 5
} ;
enum __anonenum_20___4 {
    DESC_TSS___4 = 9,
    DESC_LDT___4 = 2,
    DESCTYPE_S___4 = 16
} ;
enum __anonenum_21___4 {
    ADDR_NO_RANDOMIZE___4 = 262144,
    FDPIC_FUNCPTRS___4 = 524288,
    MMAP_PAGE_ZERO___4 = 1048576,
    ADDR_COMPAT_LAYOUT___4 = 2097152,
    READ_IMPLIES_EXEC___4 = 4194304,
    ADDR_LIMIT_32BIT___4 = 8388608,
    SHORT_INODE___4 = 16777216,
    WHOLE_SECONDS___4 = 33554432,
    STICKY_TIMEOUTS___4 = 67108864,
    ADDR_LIMIT_3GB___4 = 134217728
} ;
enum __anonenum_22___4 {
    PER_LINUX___4 = 0,
    PER_LINUX_32BIT___4 = 8388608,
    PER_LINUX_FDPIC___4 = 524288,
    PER_SVR4___4 = 68157441,
    PER_SVR3___4 = 83886082,
    PER_SCOSVR3___4 = 117440515,
    PER_OSR5___4 = 100663299,
    PER_WYSEV386___4 = 83886084,
    PER_ISCR4___4 = 67108869,
    PER_BSD___4 = 6,
    PER_SUNOS___4 = 67108870,
    PER_XENIX___4 = 83886087,
    PER_LINUX32___4 = 8,
    PER_LINUX32_3GB___4 = 134217736,
    PER_IRIX32___4 = 67108873,
    PER_IRIXN32___4 = 67108874,
    PER_IRIX64___4 = 67108875,
    PER_RISCOS___4 = 12,
    PER_SOLARIS___4 = 67108877,
    PER_UW7___4 = 68157454,
    PER_OSF4___4 = 15,
    PER_HPUX___4 = 16,
    PER_MASK___4 = 255
} ;
union __anonunion_d_37___4 {
   u64 v64 ;
   u32 v32[2] ;
};
enum hrtimer_restart;
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct irq_desc;
enum __anonenum_119___0 {
    CTL_KERN___0 = 1,
    CTL_VM___0 = 2,
    CTL_NET___0 = 3,
    CTL_PROC___0 = 4,
    CTL_FS___0 = 5,
    CTL_DEBUG___0 = 6,
    CTL_DEV___0 = 7,
    CTL_BUS___0 = 8,
    CTL_ABI___0 = 9,
    CTL_CPU___0 = 10,
    CTL_ARLAN___0 = 254,
    CTL_S390DBF___0 = 5677,
    CTL_SUNRPC___0 = 7249,
    CTL_PM___0 = 9899,
    CTL_FRV___0 = 9898
} ;
enum __anonenum_120___1 {
    CTL_BUS_ISA___0 = 1
} ;
enum __anonenum_121___0 {
    INOTIFY_MAX_USER_INSTANCES___0 = 1,
    INOTIFY_MAX_USER_WATCHES___0 = 2,
    INOTIFY_MAX_QUEUED_EVENTS___0 = 3
} ;
enum __anonenum_122___0 {
    KERN_OSTYPE___0 = 1,
    KERN_OSRELEASE___0 = 2,
    KERN_OSREV___0 = 3,
    KERN_VERSION___0 = 4,
    KERN_SECUREMASK___0 = 5,
    KERN_PROF___0 = 6,
    KERN_NODENAME___0 = 7,
    KERN_DOMAINNAME___0 = 8,
    KERN_PANIC___0 = 15,
    KERN_REALROOTDEV___0 = 16,
    KERN_SPARC_REBOOT___0 = 21,
    KERN_CTLALTDEL___0 = 22,
    KERN_PRINTK___0 = 23,
    KERN_NAMETRANS___0 = 24,
    KERN_PPC_HTABRECLAIM___0 = 25,
    KERN_PPC_ZEROPAGED___0 = 26,
    KERN_PPC_POWERSAVE_NAP___0 = 27,
    KERN_MODPROBE___0 = 28,
    KERN_SG_BIG_BUFF___0 = 29,
    KERN_ACCT___0 = 30,
    KERN_PPC_L2CR___0 = 31,
    KERN_RTSIGNR___0 = 32,
    KERN_RTSIGMAX___0 = 33,
    KERN_SHMMAX___0 = 34,
    KERN_MSGMAX___0 = 35,
    KERN_MSGMNB___0 = 36,
    KERN_MSGPOOL___0 = 37,
    KERN_SYSRQ___0 = 38,
    KERN_MAX_THREADS___0 = 39,
    KERN_RANDOM___0 = 40,
    KERN_SHMALL___0 = 41,
    KERN_MSGMNI___0 = 42,
    KERN_SEM___0 = 43,
    KERN_SPARC_STOP_A___0 = 44,
    KERN_SHMMNI___0 = 45,
    KERN_OVERFLOWUID___0 = 46,
    KERN_OVERFLOWGID___0 = 47,
    KERN_SHMPATH___0 = 48,
    KERN_HOTPLUG___0 = 49,
    KERN_IEEE_EMULATION_WARNINGS___0 = 50,
    KERN_S390_USER_DEBUG_LOGGING___0 = 51,
    KERN_CORE_USES_PID___0 = 52,
    KERN_TAINTED___0 = 53,
    KERN_CADPID___0 = 54,
    KERN_PIDMAX___0 = 55,
    KERN_CORE_PATTERN___0 = 56,
    KERN_PANIC_ON_OOPS___0 = 57,
    KERN_HPPA_PWRSW___0 = 58,
    KERN_HPPA_UNALIGNED___0 = 59,
    KERN_PRINTK_RATELIMIT___0 = 60,
    KERN_PRINTK_RATELIMIT_BURST___0 = 61,
    KERN_PTY___0 = 62,
    KERN_NGROUPS_MAX___0 = 63,
    KERN_SPARC_SCONS_PWROFF___0 = 64,
    KERN_HZ_TIMER___0 = 65,
    KERN_UNKNOWN_NMI_PANIC___0 = 66,
    KERN_BOOTLOADER_TYPE___0 = 67,
    KERN_RANDOMIZE___0 = 68,
    KERN_SETUID_DUMPABLE___0 = 69,
    KERN_SPIN_RETRY___0 = 70,
    KERN_ACPI_VIDEO_FLAGS___0 = 71,
    KERN_IA64_UNALIGNED___0 = 72,
    KERN_COMPAT_LOG___0 = 73,
    KERN_MAX_LOCK_DEPTH___0 = 74,
    KERN_NMI_WATCHDOG___0 = 75,
    KERN_PANIC_ON_NMI___0 = 76
} ;
enum __anonenum_123___0 {
    VM_UNUSED1___0 = 1,
    VM_UNUSED2___0 = 2,
    VM_UNUSED3___0 = 3,
    VM_UNUSED4___0 = 4,
    VM_OVERCOMMIT_MEMORY___0 = 5,
    VM_UNUSED5___0 = 6,
    VM_UNUSED7___0 = 7,
    VM_UNUSED8___0 = 8,
    VM_UNUSED9___0 = 9,
    VM_PAGE_CLUSTER___0 = 10,
    VM_DIRTY_BACKGROUND___0 = 11,
    VM_DIRTY_RATIO___0 = 12,
    VM_DIRTY_WB_CS___0 = 13,
    VM_DIRTY_EXPIRE_CS___0 = 14,
    VM_NR_PDFLUSH_THREADS___0 = 15,
    VM_OVERCOMMIT_RATIO___0 = 16,
    VM_PAGEBUF___0 = 17,
    VM_HUGETLB_PAGES___0 = 18,
    VM_SWAPPINESS___0 = 19,
    VM_LOWMEM_RESERVE_RATIO___0 = 20,
    VM_MIN_FREE_KBYTES___0 = 21,
    VM_MAX_MAP_COUNT___0 = 22,
    VM_LAPTOP_MODE___0 = 23,
    VM_BLOCK_DUMP___0 = 24,
    VM_HUGETLB_GROUP___0 = 25,
    VM_VFS_CACHE_PRESSURE___0 = 26,
    VM_LEGACY_VA_LAYOUT___0 = 27,
    VM_SWAP_TOKEN_TIMEOUT___0 = 28,
    VM_DROP_PAGECACHE___0 = 29,
    VM_PERCPU_PAGELIST_FRACTION___0 = 30,
    VM_ZONE_RECLAIM_MODE___0 = 31,
    VM_MIN_UNMAPPED___0 = 32,
    VM_PANIC_ON_OOM___0 = 33,
    VM_VDSO_ENABLED___0 = 34,
    VM_MIN_SLAB___0 = 35
} ;
enum __anonenum_124 {
    NET_CORE___0 = 1,
    NET_ETHER___0 = 2,
    NET_802___0 = 3,
    NET_UNIX___0 = 4,
    NET_IPV4___0 = 5,
    NET_IPX___0 = 6,
    NET_ATALK___0 = 7,
    NET_NETROM___0 = 8,
    NET_AX25___0 = 9,
    NET_BRIDGE___0 = 10,
    NET_ROSE___0 = 11,
    NET_IPV6___0 = 12,
    NET_X25___0 = 13,
    NET_TR___0 = 14,
    NET_DECNET___0 = 15,
    NET_ECONET___0 = 16,
    NET_SCTP___0 = 17,
    NET_LLC___0 = 18,
    NET_NETFILTER___0 = 19,
    NET_DCCP___0 = 20,
    NET_IRDA___0 = 412
} ;
enum __anonenum_125 {
    RANDOM_POOLSIZE___0 = 1,
    RANDOM_ENTROPY_COUNT___0 = 2,
    RANDOM_READ_THRESH___0 = 3,
    RANDOM_WRITE_THRESH___0 = 4,
    RANDOM_BOOT_ID___0 = 5,
    RANDOM_UUID___0 = 6
} ;
enum __anonenum_126 {
    PTY_MAX___0 = 1,
    PTY_NR___0 = 2
} ;
enum __anonenum_127 {
    BUS_ISA_MEM_BASE___0 = 1,
    BUS_ISA_PORT_BASE___0 = 2,
    BUS_ISA_PORT_SHIFT___0 = 3
} ;
enum __anonenum_128 {
    NET_CORE_WMEM_MAX___0 = 1,
    NET_CORE_RMEM_MAX___0 = 2,
    NET_CORE_WMEM_DEFAULT___0 = 3,
    NET_CORE_RMEM_DEFAULT___0 = 4,
    NET_CORE_MAX_BACKLOG___0 = 6,
    NET_CORE_FASTROUTE___0 = 7,
    NET_CORE_MSG_COST___0 = 8,
    NET_CORE_MSG_BURST___0 = 9,
    NET_CORE_OPTMEM_MAX___0 = 10,
    NET_CORE_HOT_LIST_LENGTH___0 = 11,
    NET_CORE_DIVERT_VERSION___0 = 12,
    NET_CORE_NO_CONG_THRESH___0 = 13,
    NET_CORE_NO_CONG___0 = 14,
    NET_CORE_LO_CONG___0 = 15,
    NET_CORE_MOD_CONG___0 = 16,
    NET_CORE_DEV_WEIGHT___0 = 17,
    NET_CORE_SOMAXCONN___0 = 18,
    NET_CORE_BUDGET___0 = 19,
    NET_CORE_AEVENT_ETIME___0 = 20,
    NET_CORE_AEVENT_RSEQTH___0 = 21,
    NET_CORE_WARNINGS___0 = 22
} ;
enum __anonenum_129 {
    NET_UNIX_DESTROY_DELAY___0 = 1,
    NET_UNIX_DELETE_DELAY___0 = 2,
    NET_UNIX_MAX_DGRAM_QLEN___0 = 3
} ;
enum __anonenum_130 {
    NET_NF_CONNTRACK_MAX___0 = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___0 = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___0 = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___0 = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___0 = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___0 = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___0 = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___0 = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___0 = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT___0 = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM___0 = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT___0 = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT___0 = 13,
    NET_NF_CONNTRACK_BUCKETS___0 = 14,
    NET_NF_CONNTRACK_LOG_INVALID___0 = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___0 = 16,
    NET_NF_CONNTRACK_TCP_LOOSE___0 = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL___0 = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS___0 = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___0 = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___0 = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___0 = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___0 = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___0 = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___0 = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___0 = 26,
    NET_NF_CONNTRACK_COUNT___0 = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT___0 = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT___0 = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH___0 = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH___0 = 31,
    NET_NF_CONNTRACK_CHECKSUM___0 = 32
} ;
enum __anonenum_131 {
    NET_IPV4_FORWARD___0 = 8,
    NET_IPV4_DYNADDR___0 = 9,
    NET_IPV4_CONF___0 = 16,
    NET_IPV4_NEIGH___0 = 17,
    NET_IPV4_ROUTE___0 = 18,
    NET_IPV4_FIB_HASH___0 = 19,
    NET_IPV4_NETFILTER___0 = 20,
    NET_IPV4_TCP_TIMESTAMPS___0 = 33,
    NET_IPV4_TCP_WINDOW_SCALING___0 = 34,
    NET_IPV4_TCP_SACK___0 = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE___0 = 36,
    NET_IPV4_DEFAULT_TTL___0 = 37,
    NET_IPV4_AUTOCONFIG___0 = 38,
    NET_IPV4_NO_PMTU_DISC___0 = 39,
    NET_IPV4_TCP_SYN_RETRIES___0 = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH___0 = 41,
    NET_IPV4_IPFRAG_LOW_THRESH___0 = 42,
    NET_IPV4_IPFRAG_TIME___0 = 43,
    NET_IPV4_TCP_MAX_KA_PROBES___0 = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME___0 = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES___0 = 46,
    NET_IPV4_TCP_RETRIES1___0 = 47,
    NET_IPV4_TCP_RETRIES2___0 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT___0 = 49,
    NET_IPV4_IP_MASQ_DEBUG___0 = 50,
    NET_TCP_SYNCOOKIES___0 = 51,
    NET_TCP_STDURG___0 = 52,
    NET_TCP_RFC1337___0 = 53,
    NET_TCP_SYN_TAILDROP___0 = 54,
    NET_TCP_MAX_SYN_BACKLOG___0 = 55,
    NET_IPV4_LOCAL_PORT_RANGE___0 = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL___0 = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS___0 = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE___0 = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE___0 = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE___0 = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE___0 = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE___0 = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES___0 = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS___0 = 65,
    NET_TCP_TW_RECYCLE___0 = 66,
    NET_IPV4_ALWAYS_DEFRAG___0 = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL___0 = 68,
    NET_IPV4_INET_PEER_THRESHOLD___0 = 69,
    NET_IPV4_INET_PEER_MINTTL___0 = 70,
    NET_IPV4_INET_PEER_MAXTTL___0 = 71,
    NET_IPV4_INET_PEER_GC_MINTIME___0 = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME___0 = 73,
    NET_TCP_ORPHAN_RETRIES___0 = 74,
    NET_TCP_ABORT_ON_OVERFLOW___0 = 75,
    NET_TCP_SYNACK_RETRIES___0 = 76,
    NET_TCP_MAX_ORPHANS___0 = 77,
    NET_TCP_MAX_TW_BUCKETS___0 = 78,
    NET_TCP_FACK___0 = 79,
    NET_TCP_REORDERING___0 = 80,
    NET_TCP_ECN___0 = 81,
    NET_TCP_DSACK___0 = 82,
    NET_TCP_MEM___0 = 83,
    NET_TCP_WMEM___0 = 84,
    NET_TCP_RMEM___0 = 85,
    NET_TCP_APP_WIN___0 = 86,
    NET_TCP_ADV_WIN_SCALE___0 = 87,
    NET_IPV4_NONLOCAL_BIND___0 = 88,
    NET_IPV4_ICMP_RATELIMIT___0 = 89,
    NET_IPV4_ICMP_RATEMASK___0 = 90,
    NET_TCP_TW_REUSE___0 = 91,
    NET_TCP_FRTO___0 = 92,
    NET_TCP_LOW_LATENCY___0 = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL___0 = 94,
    NET_IPV4_IGMP_MAX_MSF___0 = 96,
    NET_TCP_NO_METRICS_SAVE___0 = 97,
    NET_TCP_DEFAULT_WIN_SCALE___0 = 105,
    NET_TCP_MODERATE_RCVBUF___0 = 106,
    NET_TCP_TSO_WIN_DIVISOR___0 = 107,
    NET_TCP_BIC_BETA___0 = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR___0 = 109,
    NET_TCP_CONG_CONTROL___0 = 110,
    NET_TCP_ABC___0 = 111,
    NET_IPV4_IPFRAG_MAX_DIST___0 = 112,
    NET_TCP_MTU_PROBING___0 = 113,
    NET_TCP_BASE_MSS___0 = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS___0 = 115,
    NET_TCP_DMA_COPYBREAK___0 = 116,
    NET_TCP_SLOW_START_AFTER_IDLE___0 = 117,
    NET_CIPSOV4_CACHE_ENABLE___0 = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE___0 = 119,
    NET_CIPSOV4_RBM_OPTFMT___0 = 120,
    NET_CIPSOV4_RBM_STRICTVALID___0 = 121,
    NET_TCP_AVAIL_CONG_CONTROL___0 = 122,
    NET_TCP_ALLOWED_CONG_CONTROL___0 = 123,
    NET_TCP_MAX_SSTHRESH___0 = 124,
    NET_TCP_FRTO_RESPONSE___0 = 125
} ;
enum __anonenum_132___0 {
    NET_IPV4_ROUTE_FLUSH___0 = 1,
    NET_IPV4_ROUTE_MIN_DELAY___0 = 2,
    NET_IPV4_ROUTE_MAX_DELAY___0 = 3,
    NET_IPV4_ROUTE_GC_THRESH___0 = 4,
    NET_IPV4_ROUTE_MAX_SIZE___0 = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL___0 = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT___0 = 7,
    NET_IPV4_ROUTE_GC_INTERVAL___0 = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD___0 = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER___0 = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE___0 = 11,
    NET_IPV4_ROUTE_ERROR_COST___0 = 12,
    NET_IPV4_ROUTE_ERROR_BURST___0 = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY___0 = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES___0 = 15,
    NET_IPV4_ROUTE_MIN_PMTU___0 = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS___0 = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL___0 = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS___0 = 19
} ;
enum __anonenum_133___0 {
    NET_PROTO_CONF_ALL___0 = -2,
    NET_PROTO_CONF_DEFAULT___0 = -3
} ;
enum __anonenum_134___0 {
    NET_IPV4_CONF_FORWARDING___0 = 1,
    NET_IPV4_CONF_MC_FORWARDING___0 = 2,
    NET_IPV4_CONF_PROXY_ARP___0 = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS___0 = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS___0 = 5,
    NET_IPV4_CONF_SEND_REDIRECTS___0 = 6,
    NET_IPV4_CONF_SHARED_MEDIA___0 = 7,
    NET_IPV4_CONF_RP_FILTER___0 = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE___0 = 9,
    NET_IPV4_CONF_BOOTP_RELAY___0 = 10,
    NET_IPV4_CONF_LOG_MARTIANS___0 = 11,
    NET_IPV4_CONF_TAG___0 = 12,
    NET_IPV4_CONF_ARPFILTER___0 = 13,
    NET_IPV4_CONF_MEDIUM_ID___0 = 14,
    NET_IPV4_CONF_NOXFRM___0 = 15,
    NET_IPV4_CONF_NOPOLICY___0 = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION___0 = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE___0 = 18,
    NET_IPV4_CONF_ARP_IGNORE___0 = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES___0 = 20,
    NET_IPV4_CONF_ARP_ACCEPT___0 = 21,
    NET_IPV4_CONF_ARP_NOTIFY___0 = 22,
    __NET_IPV4_CONF_MAX___0 = 23
} ;
enum __anonenum_135___0 {
    NET_IPV4_NF_CONNTRACK_MAX___0 = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT___0 = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV___0 = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED___0 = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT___0 = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT___0 = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK___0 = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT___0 = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE___0 = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT___0 = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM___0 = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT___0 = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT___0 = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS___0 = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID___0 = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS___0 = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE___0 = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL___0 = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS___0 = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED___0 = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT___0 = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED___0 = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED___0 = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT___0 = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD___0 = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT___0 = 26,
    NET_IPV4_NF_CONNTRACK_COUNT___0 = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM___0 = 28
} ;
enum __anonenum_136___0 {
    NET_IPV6_CONF___0 = 16,
    NET_IPV6_NEIGH___0 = 17,
    NET_IPV6_ROUTE___0 = 18,
    NET_IPV6_ICMP___0 = 19,
    NET_IPV6_BINDV6ONLY___0 = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH___0 = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH___0 = 22,
    NET_IPV6_IP6FRAG_TIME___0 = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL___0 = 24,
    NET_IPV6_MLD_MAX_MSF___0 = 25
} ;
enum __anonenum_137___0 {
    NET_IPV6_ROUTE_FLUSH___0 = 1,
    NET_IPV6_ROUTE_GC_THRESH___0 = 2,
    NET_IPV6_ROUTE_MAX_SIZE___0 = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL___0 = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT___0 = 5,
    NET_IPV6_ROUTE_GC_INTERVAL___0 = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY___0 = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES___0 = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS___0 = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS___0 = 10
} ;
enum __anonenum_138___0 {
    NET_IPV6_FORWARDING___0 = 1,
    NET_IPV6_HOP_LIMIT___0 = 2,
    NET_IPV6_MTU___0 = 3,
    NET_IPV6_ACCEPT_RA___0 = 4,
    NET_IPV6_ACCEPT_REDIRECTS___0 = 5,
    NET_IPV6_AUTOCONF___0 = 6,
    NET_IPV6_DAD_TRANSMITS___0 = 7,
    NET_IPV6_RTR_SOLICITS___0 = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL___0 = 9,
    NET_IPV6_RTR_SOLICIT_DELAY___0 = 10,
    NET_IPV6_USE_TEMPADDR___0 = 11,
    NET_IPV6_TEMP_VALID_LFT___0 = 12,
    NET_IPV6_TEMP_PREFERED_LFT___0 = 13,
    NET_IPV6_REGEN_MAX_RETRY___0 = 14,
    NET_IPV6_MAX_DESYNC_FACTOR___0 = 15,
    NET_IPV6_MAX_ADDRESSES___0 = 16,
    NET_IPV6_FORCE_MLD_VERSION___0 = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR___0 = 18,
    NET_IPV6_ACCEPT_RA_PINFO___0 = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF___0 = 20,
    NET_IPV6_RTR_PROBE_INTERVAL___0 = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN___0 = 22,
    NET_IPV6_PROXY_NDP___0 = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE___0 = 25,
    __NET_IPV6_MAX___0 = 26
} ;
enum __anonenum_139___0 {
    NET_IPV6_ICMP_RATELIMIT___0 = 1
} ;
enum __anonenum_140___0 {
    NET_NEIGH_MCAST_SOLICIT___0 = 1,
    NET_NEIGH_UCAST_SOLICIT___0 = 2,
    NET_NEIGH_APP_SOLICIT___0 = 3,
    NET_NEIGH_RETRANS_TIME___0 = 4,
    NET_NEIGH_REACHABLE_TIME___0 = 5,
    NET_NEIGH_DELAY_PROBE_TIME___0 = 6,
    NET_NEIGH_GC_STALE_TIME___0 = 7,
    NET_NEIGH_UNRES_QLEN___0 = 8,
    NET_NEIGH_PROXY_QLEN___0 = 9,
    NET_NEIGH_ANYCAST_DELAY___0 = 10,
    NET_NEIGH_PROXY_DELAY___0 = 11,
    NET_NEIGH_LOCKTIME___0 = 12,
    NET_NEIGH_GC_INTERVAL___0 = 13,
    NET_NEIGH_GC_THRESH1___0 = 14,
    NET_NEIGH_GC_THRESH2___0 = 15,
    NET_NEIGH_GC_THRESH3___0 = 16,
    NET_NEIGH_RETRANS_TIME_MS___0 = 17,
    NET_NEIGH_REACHABLE_TIME_MS___0 = 18,
    __NET_NEIGH_MAX___0 = 19
} ;
enum __anonenum_141___0 {
    NET_DCCP_DEFAULT___0 = 1
} ;
enum __anonenum_142___0 {
    NET_IPX_PPROP_BROADCASTING___0 = 1,
    NET_IPX_FORWARDING___0 = 2
} ;
enum __anonenum_143___0 {
    NET_LLC2___0 = 1,
    NET_LLC_STATION___0 = 2
} ;
enum __anonenum_144___0 {
    NET_LLC2_TIMEOUT___0 = 1
} ;
enum __anonenum_145___0 {
    NET_LLC_STATION_ACK_TIMEOUT___0 = 1
} ;
enum __anonenum_146___0 {
    NET_LLC2_ACK_TIMEOUT___0 = 1,
    NET_LLC2_P_TIMEOUT___0 = 2,
    NET_LLC2_REJ_TIMEOUT___0 = 3,
    NET_LLC2_BUSY_TIMEOUT___0 = 4
} ;
enum __anonenum_147___0 {
    NET_ATALK_AARP_EXPIRY_TIME___0 = 1,
    NET_ATALK_AARP_TICK_TIME___0 = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT___0 = 3,
    NET_ATALK_AARP_RESOLVE_TIME___0 = 4
} ;
enum __anonenum_148___0 {
    NET_NETROM_DEFAULT_PATH_QUALITY___0 = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER___0 = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER___0 = 3,
    NET_NETROM_TRANSPORT_TIMEOUT___0 = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES___0 = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY___0 = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY___0 = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE___0 = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT___0 = 9,
    NET_NETROM_ROUTING_CONTROL___0 = 10,
    NET_NETROM_LINK_FAILS_COUNT___0 = 11,
    NET_NETROM_RESET___0 = 12
} ;
enum __anonenum_149___0 {
    NET_AX25_IP_DEFAULT_MODE___0 = 1,
    NET_AX25_DEFAULT_MODE___0 = 2,
    NET_AX25_BACKOFF_TYPE___0 = 3,
    NET_AX25_CONNECT_MODE___0 = 4,
    NET_AX25_STANDARD_WINDOW___0 = 5,
    NET_AX25_EXTENDED_WINDOW___0 = 6,
    NET_AX25_T1_TIMEOUT___0 = 7,
    NET_AX25_T2_TIMEOUT___0 = 8,
    NET_AX25_T3_TIMEOUT___0 = 9,
    NET_AX25_IDLE_TIMEOUT___0 = 10,
    NET_AX25_N2___0 = 11,
    NET_AX25_PACLEN___0 = 12,
    NET_AX25_PROTOCOL___0 = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT___0 = 14
} ;
enum __anonenum_150___0 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT___0 = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT___0 = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT___0 = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT___0 = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT___0 = 5,
    NET_ROSE_ROUTING_CONTROL___0 = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT___0 = 7,
    NET_ROSE_MAX_VCS___0 = 8,
    NET_ROSE_WINDOW_SIZE___0 = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT___0 = 10
} ;
enum __anonenum_151___0 {
    NET_X25_RESTART_REQUEST_TIMEOUT___0 = 1,
    NET_X25_CALL_REQUEST_TIMEOUT___0 = 2,
    NET_X25_RESET_REQUEST_TIMEOUT___0 = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT___0 = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT___0 = 5,
    NET_X25_FORWARD___0 = 6
} ;
enum __anonenum_152___0 {
    NET_TR_RIF_TIMEOUT___0 = 1
} ;
enum __anonenum_153___0 {
    NET_DECNET_NODE_TYPE___0 = 1,
    NET_DECNET_NODE_ADDRESS___0 = 2,
    NET_DECNET_NODE_NAME___0 = 3,
    NET_DECNET_DEFAULT_DEVICE___0 = 4,
    NET_DECNET_TIME_WAIT___0 = 5,
    NET_DECNET_DN_COUNT___0 = 6,
    NET_DECNET_DI_COUNT___0 = 7,
    NET_DECNET_DR_COUNT___0 = 8,
    NET_DECNET_DST_GC_INTERVAL___0 = 9,
    NET_DECNET_CONF___0 = 10,
    NET_DECNET_NO_FC_MAX_CWND___0 = 11,
    NET_DECNET_MEM___0 = 12,
    NET_DECNET_RMEM___0 = 13,
    NET_DECNET_WMEM___0 = 14,
    NET_DECNET_DEBUG_LEVEL___0 = 255
} ;
enum __anonenum_154___0 {
    NET_DECNET_CONF_LOOPBACK___0 = -2,
    NET_DECNET_CONF_DDCMP___0 = -3,
    NET_DECNET_CONF_PPP___0 = -4,
    NET_DECNET_CONF_X25___0 = -5,
    NET_DECNET_CONF_GRE___0 = -6,
    NET_DECNET_CONF_ETHER___0 = -7
} ;
enum __anonenum_155___0 {
    NET_DECNET_CONF_DEV_PRIORITY___0 = 1,
    NET_DECNET_CONF_DEV_T1___0 = 2,
    NET_DECNET_CONF_DEV_T2___0 = 3,
    NET_DECNET_CONF_DEV_T3___0 = 4,
    NET_DECNET_CONF_DEV_FORWARDING___0 = 5,
    NET_DECNET_CONF_DEV_BLKSIZE___0 = 6,
    NET_DECNET_CONF_DEV_STATE___0 = 7
} ;
enum __anonenum_156___0 {
    NET_SCTP_RTO_INITIAL___0 = 1,
    NET_SCTP_RTO_MIN___0 = 2,
    NET_SCTP_RTO_MAX___0 = 3,
    NET_SCTP_RTO_ALPHA___0 = 4,
    NET_SCTP_RTO_BETA___0 = 5,
    NET_SCTP_VALID_COOKIE_LIFE___0 = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS___0 = 7,
    NET_SCTP_PATH_MAX_RETRANS___0 = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS___0 = 9,
    NET_SCTP_HB_INTERVAL___0 = 10,
    NET_SCTP_PRESERVE_ENABLE___0 = 11,
    NET_SCTP_MAX_BURST___0 = 12,
    NET_SCTP_ADDIP_ENABLE___0 = 13,
    NET_SCTP_PRSCTP_ENABLE___0 = 14,
    NET_SCTP_SNDBUF_POLICY___0 = 15,
    NET_SCTP_SACK_TIMEOUT___0 = 16,
    NET_SCTP_RCVBUF_POLICY___0 = 17
} ;
enum __anonenum_157___0 {
    NET_BRIDGE_NF_CALL_ARPTABLES___0 = 1,
    NET_BRIDGE_NF_CALL_IPTABLES___0 = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES___0 = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED___0 = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED___0 = 5
} ;
enum __anonenum_158___0 {
    NET_IRDA_DISCOVERY___0 = 1,
    NET_IRDA_DEVNAME___0 = 2,
    NET_IRDA_DEBUG___0 = 3,
    NET_IRDA_FAST_POLL___0 = 4,
    NET_IRDA_DISCOVERY_SLOTS___0 = 5,
    NET_IRDA_DISCOVERY_TIMEOUT___0 = 6,
    NET_IRDA_SLOT_TIMEOUT___0 = 7,
    NET_IRDA_MAX_BAUD_RATE___0 = 8,
    NET_IRDA_MIN_TX_TURN_TIME___0 = 9,
    NET_IRDA_MAX_TX_DATA_SIZE___0 = 10,
    NET_IRDA_MAX_TX_WINDOW___0 = 11,
    NET_IRDA_MAX_NOREPLY_TIME___0 = 12,
    NET_IRDA_WARN_NOREPLY_TIME___0 = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME___0 = 14
} ;
enum __anonenum_159___0 {
    FS_NRINODE___0 = 1,
    FS_STATINODE___0 = 2,
    FS_MAXINODE___0 = 3,
    FS_NRDQUOT___0 = 4,
    FS_MAXDQUOT___0 = 5,
    FS_NRFILE___0 = 6,
    FS_MAXFILE___0 = 7,
    FS_DENTRY___0 = 8,
    FS_NRSUPER___0 = 9,
    FS_MAXSUPER___0 = 10,
    FS_OVERFLOWUID___0 = 11,
    FS_OVERFLOWGID___0 = 12,
    FS_LEASES___0 = 13,
    FS_DIR_NOTIFY___0 = 14,
    FS_LEASE_TIME___0 = 15,
    FS_DQSTATS___0 = 16,
    FS_XFS___0 = 17,
    FS_AIO_NR___0 = 18,
    FS_AIO_MAX_NR___0 = 19,
    FS_INOTIFY___0 = 20,
    FS_OCFS2___0 = 988
} ;
enum __anonenum_160___0 {
    FS_DQ_LOOKUPS___0 = 1,
    FS_DQ_DROPS___0 = 2,
    FS_DQ_READS___0 = 3,
    FS_DQ_WRITES___0 = 4,
    FS_DQ_CACHE_HITS___0 = 5,
    FS_DQ_ALLOCATED___0 = 6,
    FS_DQ_FREE___0 = 7,
    FS_DQ_SYNCS___0 = 8,
    FS_DQ_WARNINGS___0 = 9
} ;
enum __anonenum_161___0 {
    DEV_CDROM___0 = 1,
    DEV_HWMON___0 = 2,
    DEV_PARPORT___0 = 3,
    DEV_RAID___0 = 4,
    DEV_MAC_HID___0 = 5,
    DEV_SCSI___0 = 6,
    DEV_IPMI___0 = 7
} ;
enum __anonenum_162___0 {
    DEV_CDROM_INFO___0 = 1,
    DEV_CDROM_AUTOCLOSE___0 = 2,
    DEV_CDROM_AUTOEJECT___0 = 3,
    DEV_CDROM_DEBUG___0 = 4,
    DEV_CDROM_LOCK___0 = 5,
    DEV_CDROM_CHECK_MEDIA___0 = 6
} ;
enum __anonenum_163___0 {
    DEV_PARPORT_DEFAULT___0 = -3
} ;
enum __anonenum_164___0 {
    DEV_RAID_SPEED_LIMIT_MIN___0 = 1,
    DEV_RAID_SPEED_LIMIT_MAX___0 = 2
} ;
enum __anonenum_165___0 {
    DEV_PARPORT_DEFAULT_TIMESLICE___0 = 1,
    DEV_PARPORT_DEFAULT_SPINTIME___0 = 2
} ;
enum __anonenum_166___0 {
    DEV_PARPORT_SPINTIME___0 = 1,
    DEV_PARPORT_BASE_ADDR___0 = 2,
    DEV_PARPORT_IRQ___0 = 3,
    DEV_PARPORT_DMA___0 = 4,
    DEV_PARPORT_MODES___0 = 5,
    DEV_PARPORT_DEVICES___0 = 6,
    DEV_PARPORT_AUTOPROBE___0 = 16
} ;
enum __anonenum_167___0 {
    DEV_PARPORT_DEVICES_ACTIVE___0 = -3
} ;
enum __anonenum_168___0 {
    DEV_PARPORT_DEVICE_TIMESLICE___0 = 1
} ;
enum __anonenum_169___0 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES___0 = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES___0 = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION___0 = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE___0 = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE___0 = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES___0 = 6
} ;
enum __anonenum_170___0 {
    DEV_SCSI_LOGGING_LEVEL___0 = 1
} ;
enum __anonenum_171___0 {
    DEV_IPMI_POWEROFF_POWERCYCLE___0 = 1
} ;
enum __anonenum_172___0 {
    ABI_DEFHANDLER_COFF___0 = 1,
    ABI_DEFHANDLER_ELF___0 = 2,
    ABI_DEFHANDLER_LCALL7___0 = 3,
    ABI_DEFHANDLER_LIBCSO___0 = 4,
    ABI_TRACE___0 = 5,
    ABI_FAKE_UTSNAME___0 = 6
} ;
enum __anonenum_175___0 {
    IOCB_CMD_PREAD___0 = 0,
    IOCB_CMD_PWRITE___0 = 1,
    IOCB_CMD_FSYNC___0 = 2,
    IOCB_CMD_FDSYNC___0 = 3,
    IOCB_CMD_NOOP___0 = 6,
    IOCB_CMD_PREADV___0 = 7,
    IOCB_CMD_PWRITEV___0 = 8
} ;
typedef struct pt_regs *T__;
typedef void (*irq_flow_handler_t)(unsigned int irq , struct irq_desc *desc );
struct proc_dir_entry;
struct msi_desc;
struct irq_chip {
   char const   *name ;
   unsigned int (*startup)(unsigned int irq ) ;
   void (*shutdown)(unsigned int irq ) ;
   void (*enable)(unsigned int irq ) ;
   void (*disable)(unsigned int irq ) ;
   void (*ack)(unsigned int irq ) ;
   void (*mask)(unsigned int irq ) ;
   void (*mask_ack)(unsigned int irq ) ;
   void (*unmask)(unsigned int irq ) ;
   void (*eoi)(unsigned int irq ) ;
   void (*end)(unsigned int irq ) ;
   void (*set_affinity)(unsigned int irq , struct cpumask  const  *dest ) ;
   int (*retrigger)(unsigned int irq ) ;
   int (*set_type)(unsigned int irq , unsigned int flow_type ) ;
   int (*set_wake)(unsigned int irq , unsigned int on ) ;
   char const   *typename ;
};
struct timer_rand_state;
struct irq_2_iommu;
struct irq_desc {
   unsigned int irq ;
   struct timer_rand_state *timer_rand_state ;
   unsigned int *kstat_irqs ;
   void (*handle_irq)(unsigned int irq , struct irq_desc *desc ) ;
   struct irq_chip *chip ;
   struct msi_desc *msi_desc ;
   void *handler_data ;
   void *chip_data ;
   struct irqaction *action ;
   unsigned int status ;
   unsigned int depth ;
   unsigned int wake_depth ;
   unsigned int irq_count ;
   unsigned long last_unhandled ;
   unsigned int irqs_unhandled ;
   spinlock_t lock ;
   cpumask_var_t affinity ;
   unsigned int cpu ;
   cpumask_var_t pending_mask ;
   atomic_t threads_active ;
   wait_queue_head_t wait_for_threads ;
   struct proc_dir_entry *dir ;
   char const   *name ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct irq_desc irq_desc_t;
enum profile_type {
    PROFILE_TASK_EXIT = 0,
    PROFILE_MUNMAP = 1
} ;
typedef int vector_irq_t[256];
struct __anonstruct_irq_cpustat_t_177 {
   unsigned int __softirq_pending ;
   unsigned int __nmi_count ;
   unsigned int irq0_irqs ;
   unsigned int apic_timer_irqs ;
   unsigned int irq_spurious_count ;
   unsigned int generic_irqs ;
   unsigned int irq_resched_count ;
   unsigned int irq_call_count ;
   unsigned int irq_tlb_count ;
   unsigned int irq_thermal_count ;
} __attribute__((__aligned__((1) <<  (5) ))) ;
typedef struct __anonstruct_irq_cpustat_t_177 irq_cpustat_t;
enum __anonenum_178___0 {
    IRQTF_RUNTHREAD = 0,
    IRQTF_DIED = 1,
    IRQTF_WARNED = 2
} ;
typedef irqreturn_t (*irq_handler_t)(int  , void * );
struct irqaction {
   irqreturn_t (*handler)(int  , void * ) ;
   unsigned long flags ;
   cpumask_t mask ;
   char const   *name ;
   void *dev_id ;
   struct irqaction *next ;
   int irq ;
   struct proc_dir_entry *dir ;
   irqreturn_t (*thread_fn)(int  , void * ) ;
   struct task_struct *thread ;
   unsigned long thread_flags ;
};
enum __anonenum_179___0 {
    HI_SOFTIRQ = 0,
    TIMER_SOFTIRQ = 1,
    NET_TX_SOFTIRQ = 2,
    NET_RX_SOFTIRQ = 3,
    BLOCK_SOFTIRQ = 4,
    TASKLET_SOFTIRQ = 5,
    SCHED_SOFTIRQ = 6,
    HRTIMER_SOFTIRQ = 7,
    RCU_SOFTIRQ = 8,
    NR_SOFTIRQS = 9
} ;
struct softirq_action {
   void (*action)(struct softirq_action * ) ;
};
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
enum __anonenum_180___0 {
    TASKLET_STATE_SCHED = 0,
    TASKLET_STATE_RUN = 1
} ;
typedef unsigned long kernel_ulong_t;
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct ieee1394_device_id {
   __u32 match_flags ;
   __u32 vendor_id ;
   __u32 model_id ;
   __u32 specifier_id ;
   __u32 version ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   kernel_ulong_t driver_info ;
};
struct hid_device_id {
   __u16 bus ;
   __u16 pad1 ;
   __u32 vendor ;
   __u32 product ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct ccw_device_id {
   __u16 match_flags ;
   __u16 cu_type ;
   __u16 dev_type ;
   __u8 cu_model ;
   __u8 dev_model ;
   kernel_ulong_t driver_info ;
};
struct ap_device_id {
   __u16 match_flags ;
   __u8 dev_type ;
   __u8 pad1 ;
   __u32 pad2 ;
   kernel_ulong_t driver_info ;
};
struct css_device_id {
   __u8 match_flags ;
   __u8 type ;
   __u16 pad2 ;
   __u32 pad3 ;
   kernel_ulong_t driver_data ;
};
struct acpi_device_id {
   __u8 id[16] ;
   kernel_ulong_t driver_data ;
};
struct pnp_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
};
struct __anonstruct_devs_181 {
   __u8 id[8] ;
};
struct pnp_card_device_id {
   __u8 id[8] ;
   kernel_ulong_t driver_data ;
   struct __anonstruct_devs_181 devs[8] ;
};
struct serio_device_id {
   __u8 type ;
   __u8 extra ;
   __u8 id ;
   __u8 proto ;
};
struct of_device_id {
   char name[32] ;
   char type[32] ;
   char compatible[128] ;
   void *data ;
};
struct vio_device_id {
   char type[32] ;
   char compat[32] ;
};
struct pcmcia_device_id {
   __u16 match_flags ;
   __u16 manf_id ;
   __u16 card_id ;
   __u8 func_id ;
   __u8 function ;
   __u8 device_no ;
   __u32 prod_id_hash[4]  __attribute__((__aligned__(sizeof(__u32 )))) ;
   char const   *prod_id[4] ;
   kernel_ulong_t driver_info ;
   char *cisfile ;
};
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1] ;
   kernel_ulong_t keybit[24] ;
   kernel_ulong_t relbit[1] ;
   kernel_ulong_t absbit[2] ;
   kernel_ulong_t mscbit[1] ;
   kernel_ulong_t ledbit[1] ;
   kernel_ulong_t sndbit[1] ;
   kernel_ulong_t ffbit[4] ;
   kernel_ulong_t swbit[1] ;
   kernel_ulong_t driver_info ;
};
struct eisa_device_id {
   char sig[8] ;
   kernel_ulong_t driver_data ;
};
struct parisc_device_id {
   __u8 hw_type ;
   __u8 hversion_rev ;
   __u16 hversion ;
   __u32 sversion ;
};
struct sdio_device_id {
   __u8 class ;
   __u16 vendor ;
   __u16 device ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct ssb_device_id {
   __u16 vendor ;
   __u16 coreid ;
   __u8 revision ;
};
struct virtio_device_id {
   __u32 device ;
   __u32 vendor ;
};
struct i2c_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
enum dmi_field {
    DMI_NONE = 0,
    DMI_BIOS_VENDOR = 1,
    DMI_BIOS_VERSION = 2,
    DMI_BIOS_DATE = 3,
    DMI_SYS_VENDOR = 4,
    DMI_PRODUCT_NAME = 5,
    DMI_PRODUCT_VERSION = 6,
    DMI_PRODUCT_SERIAL = 7,
    DMI_PRODUCT_UUID = 8,
    DMI_BOARD_VENDOR = 9,
    DMI_BOARD_NAME = 10,
    DMI_BOARD_VERSION = 11,
    DMI_BOARD_SERIAL = 12,
    DMI_BOARD_ASSET_TAG = 13,
    DMI_CHASSIS_VENDOR = 14,
    DMI_CHASSIS_TYPE = 15,
    DMI_CHASSIS_VERSION = 16,
    DMI_CHASSIS_SERIAL = 17,
    DMI_CHASSIS_ASSET_TAG = 18,
    DMI_STRING_MAX = 19
} ;
struct dmi_strmatch {
   unsigned char slot ;
   char substr[79] ;
};
struct dmi_system_id {
   int (*callback)(struct dmi_system_id  const  * ) ;
   char const   *ident ;
   struct dmi_strmatch matches[4] ;
   void *driver_data ;
};
struct platform_device_id {
   char name[20] ;
   kernel_ulong_t driver_data  __attribute__((__aligned__(sizeof(kernel_ulong_t )))) ;
};
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
enum pci_mmap_state {
    pci_mmap_io = 0,
    pci_mmap_mem = 1
} ;
enum __anonenum_182___0 {
    PCI_STD_RESOURCES = 0,
    PCI_STD_RESOURCE_END = 5,
    PCI_ROM_RESOURCE = 6,
    PCI_BRIDGE_RESOURCES = 7,
    PCI_BRIDGE_RESOURCE_END = 10,
    PCI_NUM_RESOURCES = 11,
    DEVICE_COUNT_RESOURCE = 12
} ;
typedef int pci_power_t;
typedef unsigned int pci_channel_state_t;
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned int pcie_reset_state_t;
enum pcie_reset_state {
    pcie_deassert_reset = 1,
    pcie_warm_reset = 2,
    pcie_hot_reset = 3
} ;
typedef unsigned short pci_dev_flags_t;
enum pci_dev_flags {
    PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
    PCI_DEV_FLAGS_NO_D3 = 2
} ;
enum pci_irq_reroute_variant {
    INTEL_IRQ_REROUTE_VARIANT = 1,
    MAX_IRQ_REROUTE_VARIANTS = 3
} ;
typedef unsigned short pci_bus_flags_t;
enum pci_bus_flags {
    PCI_BUS_FLAGS_NO_MSI = 1,
    PCI_BUS_FLAGS_NO_MMRBC = 2
} ;
struct pci_cap_saved_state {
   struct hlist_node next ;
   char cap_nr ;
   u32 data[0] ;
};
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_driver;
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   struct bin_attribute *res_attr_wc[12] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
};
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[16] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
struct pci_bus_region {
   resource_size_t start ;
   resource_size_t end ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
enum pci_ers_result {
    PCI_ERS_RESULT_NONE = 1,
    PCI_ERS_RESULT_CAN_RECOVER = 2,
    PCI_ERS_RESULT_NEED_RESET = 3,
    PCI_ERS_RESULT_DISCONNECT = 4,
    PCI_ERS_RESULT_RECOVERED = 5
} ;
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
enum pci_lost_interrupt_reason {
    PCI_LOST_IRQ_NO_INFORMATION = 0,
    PCI_LOST_IRQ_DISABLE_MSI = 1,
    PCI_LOST_IRQ_DISABLE_MSIX = 2,
    PCI_LOST_IRQ_DISABLE_ACPI = 3
} ;
struct dma_pool;
enum pci_dma_burst_strategy {
    PCI_DMA_BURST_INFINITY = 0,
    PCI_DMA_BURST_BOUNDARY = 1,
    PCI_DMA_BURST_MULTIPLE = 2
} ;
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
struct pci_sysdata {
   int domain ;
   int node ;
};
struct irq_routing_table;
struct pci_fixup {
   u16 vendor ;
   u16 device ;
   void (*hook)(struct pci_dev *dev ) ;
};
enum pci_fixup_pass {
    pci_fixup_early = 0,
    pci_fixup_header = 1,
    pci_fixup_final = 2,
    pci_fixup_enable = 3,
    pci_fixup_resume = 4,
    pci_fixup_suspend = 5,
    pci_fixup_resume_early = 6
} ;
enum __anonenum_184___0 {
    QIF_BLIMITS_B___2 = 0,
    QIF_SPACE_B___2 = 1,
    QIF_ILIMITS_B___2 = 2,
    QIF_INODES_B___2 = 3,
    QIF_BTIME_B___2 = 4,
    QIF_ITIME_B___2 = 5
} ;
enum __anonenum_185___0 {
    QUOTA_NL_C_UNSPEC___2 = 0,
    QUOTA_NL_C_WARNING___2 = 1,
    __QUOTA_NL_C_MAX___2 = 2
} ;
enum __anonenum_186 {
    QUOTA_NL_A_UNSPEC___2 = 0,
    QUOTA_NL_A_QTYPE___2 = 1,
    QUOTA_NL_A_EXCESS_ID___2 = 2,
    QUOTA_NL_A_WARNING___2 = 3,
    QUOTA_NL_A_DEV_MAJOR___2 = 4,
    QUOTA_NL_A_DEV_MINOR___2 = 5,
    QUOTA_NL_A_CAUSED_ID___2 = 6,
    __QUOTA_NL_A_MAX___2 = 7
} ;
enum __anonenum_187 {
    _DQUOT_USAGE_ENABLED___2 = 0,
    _DQUOT_LIMITS_ENABLED___2 = 1,
    _DQUOT_SUSPENDED___2 = 2,
    _DQUOT_STATE_FLAGS___2 = 3
} ;
enum __anonenum_194 {
    SB_UNFROZEN___2 = 0,
    SB_FREEZE_WRITE___2 = 1,
    SB_FREEZE_TRANS___2 = 2
} ;
enum __anonenum_195 {
    DIO_LOCKING___2 = 1,
    DIO_NO_LOCKING___2 = 2,
    DIO_OWN_LOCKING___2 = 3
} ;
enum __anonenum_197 {
    FW_NODE_CREATED___4 = 0,
    FW_NODE_UPDATED___4 = 1,
    FW_NODE_DESTROYED___4 = 2,
    FW_NODE_LINK_ON___4 = 3,
    FW_NODE_LINK_OFF___4 = 4,
    FW_NODE_INITIATED_RESET___4 = 5
} ;
struct transaction_callback_data {
   struct completion done ;
   void *payload ;
   int rcode ;
};
struct fw_request {
   struct fw_packet response ;
   u32 request_header[4] ;
   int ack ;
   u32 length ;
   u32 data[0] ;
};
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   ,
                                                                           float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   ,
                                                                        float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
extern char const   early_idt_handlers[32][10] ;
extern initcall_t __con_initcall_start[] ;
extern initcall_t __con_initcall_end[] ;
extern initcall_t __security_initcall_start[] ;
extern initcall_t __security_initcall_end[] ;
extern int do_one_initcall(int (*fn)(void) ) ;
extern char boot_command_line[]  __attribute__((__section__(".init.data"))) ;
extern char *saved_command_line ;
extern unsigned int reset_devices ;
extern void setup_arch(char ** ) ;
extern void prepare_namespace(void) ;
extern void (*late_time_init)(void) ;
extern void parse_early_param(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void parse_early_options(char *cmdline )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern unsigned long profile_pc(struct pt_regs *regs ) ;
extern unsigned long convert_ip_to_linear(struct task_struct *child , struct pt_regs *regs ) ;
extern void send_sigtrap(struct task_struct *tsk , struct pt_regs *regs , int error_code ,
                         int si_code ) ;
extern void signal_fault(struct pt_regs *regs , void *frame , char *where ) ;
extern long syscall_trace_enter(struct pt_regs * ) ;
extern void syscall_trace_leave(struct pt_regs * ) ;
__inline static unsigned long regs_return_value(struct pt_regs *regs ) 
{ 

  {
  return (regs->ax);
}
}
__inline static int user_mode(struct pt_regs *regs ) 
{ 

  {
  return ((regs->cs & 3UL) == 3UL);
}
}
__inline static int user_mode_vm(struct pt_regs *regs ) 
{ 

  {
  return (((regs->cs & 3UL) | (regs->flags & 131072UL)) >= 3UL);
}
}
__inline static int v8086_mode(struct pt_regs *regs ) 
{ 

  {
  return ((int )(regs->flags & 131072UL));
}
}
__inline static unsigned long kernel_stack_pointer(struct pt_regs *regs ) 
{ 

  {
  return ((unsigned long )(& regs->sp));
}
}
__inline static unsigned long instruction_pointer(struct pt_regs *regs ) 
{ 

  {
  return (regs->ip);
}
}
__inline static unsigned long frame_pointer(struct pt_regs *regs ) 
{ 

  {
  return (regs->bp);
}
}
__inline static unsigned long user_stack_pointer(struct pt_regs *regs ) 
{ 

  {
  return (regs->sp);
}
}
extern void user_enable_single_step(struct task_struct * ) ;
extern void user_disable_single_step(struct task_struct * ) ;
extern void user_enable_block_step(struct task_struct * ) ;
extern int do_get_thread_area(struct task_struct *p , int idx , struct user_desc *info ) ;
extern int do_set_thread_area(struct task_struct *p , int idx , struct user_desc *info ,
                              int can_allocate ) ;
extern void x86_ptrace_untrace(struct task_struct * ) ;
extern void x86_ptrace_fork(struct task_struct *child , unsigned long clone_flags ) ;
extern void handle_vm86_fault(struct kernel_vm86_regs * , long  ) ;
extern int handle_vm86_trap(struct kernel_vm86_regs * , long  , int  ) ;
extern struct pt_regs *save_v86_state(struct kernel_vm86_regs * ) ;
extern void release_vm86_irqs(struct task_struct * ) ;
extern void __bad_percpu_size(void) ;
extern unsigned long __per_cpu_offset[8] ;
extern void setup_per_cpu_areas(void) ;
extern unsigned long per_cpu__this_cpu_off  __attribute__((__section__(".data.percpu"))) ;
extern struct task_struct *per_cpu__current_task  __attribute__((__section__(".data.percpu"))) ;
__inline static struct task_struct *get_current(void) 
{ struct task_struct *ret__ ;

  {
  if ((int )sizeof(per_cpu__current_task) == 1) {
    goto switch_0_1;
  } else {
    if ((int )sizeof(per_cpu__current_task) == 2) {
      goto switch_0_2;
    } else {
      if ((int )sizeof(per_cpu__current_task) == 4) {
        goto switch_0_4;
      } else {
        if ((int )sizeof(per_cpu__current_task) == 8) {
          goto switch_0_8;
        } else {
          {
          goto switch_0_default;
          if (0) {
            switch_0_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__current_task));
            }
            goto switch_0_break;
            switch_0_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_0_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  return (ret__);
}
}
extern void alternative_instructions(void) ;
extern void apply_alternatives(struct alt_instr *start , struct alt_instr *end ) ;
extern void alternatives_smp_module_add(struct module *mod , char *name , void *locks ,
                                        void *locks_end , void *text , void *text_end ) ;
extern void alternatives_smp_module_del(struct module *mod ) ;
extern void alternatives_smp_switch(int smp ) ;
extern unsigned char const   * const  *find_nop_table(void) ;
__inline static void apply_paravirt(struct paravirt_patch_site *start , struct paravirt_patch_site *end ) 
{ 

  {
  return;
}
}
extern void add_nops(void *insns , unsigned int len ) ;
extern void *text_poke(void *addr , void const   *opcode , size_t len ) ;
extern void *text_poke_early(void *addr , void const   *opcode , size_t len ) ;
__inline static void set_bit(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return;
}
}
__inline static void __set_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return;
}
}
__inline static void clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static void clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  clear_bit((int )nr, addr);
  }
  return;
}
}
__inline static void __clear_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static void __clear_bit_unlock(unsigned int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  __clear_bit((int )nr, addr);
  }
  return;
}
}
__inline static void __change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static void change_bit(int nr , unsigned long volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return;
}
}
__inline static int test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int test_and_set_bit_lock(int nr , unsigned long volatile   *addr ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(nr, addr);
  }
  return (tmp);
}
}
__inline static int __test_and_set_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  ("bts %2,%1\n\t"
            "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return (oldbit);
}
}
__inline static int test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int __test_and_clear_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   ("btr %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr));
  }
  return (oldbit);
}
}
__inline static int __test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   ("btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int test_and_change_bit(int nr , unsigned long volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btc %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  }
  return (oldbit);
}
}
__inline static int constant_test_bit(unsigned int nr , unsigned long const volatile   *addr ) 
{ 

  {
  return (((1UL << nr % 32U) & *((unsigned long *)addr + nr / 32U)) != 0UL);
}
}
__inline static int variable_test_bit(int nr , unsigned long const volatile   *addr ) 
{ int oldbit ;

  {
  {
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  }
  return (oldbit);
}
}
__inline static unsigned long __ffs(unsigned long word ) 
{ 

  {
  {
  __asm__  ("bsf %1,%0": "=r" (word): "rm" (word));
  }
  return (word);
}
}
__inline static unsigned long ffz(unsigned long word ) 
{ 

  {
  {
  __asm__  ("bsf %1,%0": "=r" (word): "r" (~ word));
  }
  return (word);
}
}
__inline static unsigned long __fls(unsigned long word ) 
{ 

  {
  {
  __asm__  ("bsr %1,%0": "=r" (word): "rm" (word));
  }
  return (word);
}
}
__inline static int ffs(int x ) 
{ int r ;

  {
  {
  __asm__  ("bsfl %1,%0\n\t"
            "cmovzl %2,%0": "=r" (r): "rm" (x), "r" (-1));
  }
  return (r + 1);
}
}
__inline static int fls(int x ) 
{ int r ;

  {
  {
  __asm__  ("bsrl %1,%0\n\t"
            "cmovzl %2,%0": "=&r" (r): "rm" (x), "rm" (-1));
  }
  return (r + 1);
}
}
__inline static int sched_find_first_bit(unsigned long const   *b ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  if (*(b + 0)) {
    {
    tmp = __ffs((unsigned long )*(b + 0));
    }
    return ((int )tmp);
  }
  if (*(b + 1)) {
    {
    tmp___0 = __ffs((unsigned long )*(b + 1));
    }
    return ((int )(tmp___0 + 32UL));
  }
  if (*(b + 2)) {
    {
    tmp___1 = __ffs((unsigned long )*(b + 2));
    }
    return ((int )(tmp___1 + 64UL));
  }
  {
  tmp___2 = __ffs((unsigned long )*(b + 3));
  }
  return ((int )(tmp___2 + 96UL));
}
}
extern unsigned int hweight32(unsigned int w ) ;
extern unsigned int hweight16(unsigned int w ) ;
extern unsigned int hweight8(unsigned int w ) ;
extern unsigned long hweight64(__u64 w ) ;
__inline static int fls64(__u64 x ) 
{ __u32 h ;
  int tmp ;
  int tmp___0 ;

  {
  {
  h = (__u32 )(x >> 32);
  }
  if (h) {
    {
    tmp = fls((int )h);
    }
    return (tmp + 32);
  }
  {
  tmp___0 = fls((int )x);
  }
  return (tmp___0);
}
}
__inline static __u32 __arch_swab32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __arch_swab32(__u32 val ) 
{ 

  {
  {
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
  }
  return (val);
}
}
__inline static __u64 __arch_swab64(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __arch_swab64(__u64 val ) 
{ 

  {
  {
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
  }
  return (val);
}
}
__inline static __u16 __fswab16(__u16 val )  __attribute__((__const__)) ;
__inline static __u16 __fswab16(__u16 val ) 
{ 

  {
  return ((unsigned short )((((int )val & 255) << 8) | (((int )val & 65280) >> 8)));
}
}
__inline static __u32 __fswab32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __fswab32(__u32 val ) 
{ __u32 tmp ;

  {
  {
  tmp = __arch_swab32(val);
  }
  return (tmp);
}
}
__inline static __u64 __fswab64(__u64 val )  __attribute__((__const__)) ;
__inline static __u64 __fswab64(__u64 val ) 
{ __u64 tmp ;

  {
  {
  tmp = __arch_swab64(val);
  }
  return (tmp);
}
}
__inline static __u32 __fswahw32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __fswahw32(__u32 val ) 
{ 

  {
  return (((val & 65535U) << 16) | ((val & 4294901760U) >> 16));
}
}
__inline static __u32 __fswahb32(__u32 val )  __attribute__((__const__)) ;
__inline static __u32 __fswahb32(__u32 val ) 
{ 

  {
  return (((val & 16711935U) << 8) | ((val & 4278255360U) >> 8));
}
}
__inline static __u16 __swab16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __fswab16((unsigned short )*p);
  }
  return ((unsigned short )((int )tmp));
}
}
__inline static __u32 __swab32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __fswab32((unsigned int )*p);
  }
  return (tmp);
}
}
__inline static __u64 __swab64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __fswab64((unsigned long long )*p);
  }
  return (tmp);
}
}
__inline static __u32 __swahw32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __fswahw32((unsigned int )*p);
  }
  return (tmp);
}
}
__inline static __u32 __swahb32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __fswahb32((unsigned int )*p);
  }
  return (tmp);
}
}
__inline static void __swab16s(__u16 *p ) 
{ 

  {
  {
  *p = __swab16p((__u16 const   *)p);
  }
  return;
}
}
__inline static void __swab32s(__u32 *p ) 
{ 

  {
  {
  *p = __swab32p((__u32 const   *)p);
  }
  return;
}
}
__inline static void __swab64s(__u64 *p ) 
{ 

  {
  {
  *p = __swab64p((__u64 const   *)p);
  }
  return;
}
}
__inline static void __swahw32s(__u32 *p ) 
{ 

  {
  {
  *p = __swahw32p((__u32 const   *)p);
  }
  return;
}
}
__inline static void __swahb32s(__u32 *p ) 
{ 

  {
  {
  *p = __swahb32p((__u32 const   *)p);
  }
  return;
}
}
__inline static __le64 __cpu_to_le64p(__u64 const   *p ) 
{ 

  {
  return ((unsigned long long )*p);
}
}
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 

  {
  return ((unsigned long long )*p);
}
}
__inline static __le32 __cpu_to_le32p(__u32 const   *p ) 
{ 

  {
  return ((unsigned int )*p);
}
}
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 

  {
  return ((unsigned int )*p);
}
}
__inline static __le16 __cpu_to_le16p(__u16 const   *p ) 
{ 

  {
  return ((unsigned short )*p);
}
}
__inline static __u16 __le16_to_cpup(__le16 const   *p ) 
{ 

  {
  return ((unsigned short )*p);
}
}
__inline static __be64 __cpu_to_be64p(__u64 const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __swab64p(p);
  }
  return (tmp);
}
}
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ __u64 tmp ;

  {
  {
  tmp = __swab64p((__u64 const   *)((__u64 *)p));
  }
  return (tmp);
}
}
__inline static __be32 __cpu_to_be32p(__u32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __swab32p(p);
  }
  return (tmp);
}
}
__inline static __u32 __be32_to_cpup(__be32 const   *p ) 
{ __u32 tmp ;

  {
  {
  tmp = __swab32p((__u32 const   *)((__u32 *)p));
  }
  return (tmp);
}
}
__inline static __be16 __cpu_to_be16p(__u16 const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __swab16p(p);
  }
  return (tmp);
}
}
__inline static __u16 __be16_to_cpup(__be16 const   *p ) 
{ __u16 tmp ;

  {
  {
  tmp = __swab16p((__u16 const   *)((__u16 *)p));
  }
  return (tmp);
}
}
__inline static void le16_add_cpu(__le16 *var , u16 val ) 
{ 

  {
  {
  *var = (unsigned short )((int )*var + (int )val);
  }
  return;
}
}
__inline static void le32_add_cpu(__le32 *var , u32 val ) 
{ 

  {
  {
  *var += val;
  }
  return;
}
}
__inline static void le64_add_cpu(__le64 *var , u64 val ) 
{ 

  {
  {
  *var += val;
  }
  return;
}
}
__inline static void be16_add_cpu(__be16 *var , u16 val ) 
{ __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;

  {
  {
  tmp___2 = __fswab16(*var);
  tmp___3 = __fswab16((unsigned short )((int )tmp___2 + (int )val));
  *var = (unsigned short )((int )tmp___3);
  }
  return;
}
}
__inline static void be32_add_cpu(__be32 *var , u32 val ) 
{ __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
  {
  tmp___4 = __fswab32(*var);
  tmp___5 = __fswab32(tmp___4 + val);
  *var = tmp___5;
  }
  return;
}
}
__inline static void be64_add_cpu(__be64 *var , u64 val ) 
{ __u64 tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;
  __u64 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;
  __u64 tmp___6 ;
  __u64 tmp___7 ;
  __u64 tmp___8 ;
  __u64 tmp___9 ;

  {
  {
  tmp___8 = __fswab64(*var);
  tmp___9 = __fswab64(tmp___8 + val);
  *var = tmp___9;
  }
  return;
}
}
__inline static int get_bitmask_order(unsigned int count ) 
{ int order ;

  {
  {
  order = fls((int )count);
  }
  return (order);
}
}
__inline static int get_count_order(unsigned int count ) 
{ int order ;
  int tmp ;

  {
  {
  tmp = fls((int )count);
  order = tmp - 1;
  }
  if (count & (count - 1U)) {
    {
    order ++;
    }
  }
  return (order);
}
}
__inline static unsigned long hweight_long(unsigned long w ) 
{ unsigned int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  if (sizeof(w) == 4UL) {
    {
    tmp = hweight32((unsigned int )w);
    tmp___1 = (unsigned long )tmp;
    }
  } else {
    {
    tmp___0 = hweight64((unsigned long long )w);
    tmp___1 = tmp___0;
    }
  }
  return (tmp___1);
}
}
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word << shift) | (word >> (32U - shift)));
}
}
__inline static __u32 ror32(__u32 word , unsigned int shift ) 
{ 

  {
  return ((word >> shift) | (word << (32U - shift)));
}
}
__inline static __u16 rol16(__u16 word , unsigned int shift ) 
{ 

  {
  return ((unsigned short )(((int )word << shift) | ((int )word >> (16U - shift))));
}
}
__inline static __u16 ror16(__u16 word , unsigned int shift ) 
{ 

  {
  return ((unsigned short )(((int )word >> shift) | ((int )word << (16U - shift))));
}
}
__inline static __u8 rol8(__u8 word , unsigned int shift ) 
{ 

  {
  return ((unsigned char )(((int )word << shift) | ((int )word >> (8U - shift))));
}
}
__inline static __u8 ror8(__u8 word , unsigned int shift ) 
{ 

  {
  return ((unsigned char )(((int )word >> shift) | ((int )word << (8U - shift))));
}
}
__inline static unsigned int fls_long(unsigned long l ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (sizeof(l) == 4UL) {
    {
    tmp = fls((int )l);
    }
    return ((unsigned int )tmp);
  }
  {
  tmp___0 = fls64((unsigned long long )l);
  }
  return ((unsigned int )tmp___0);
}
}
__inline static unsigned long __ffs64(u64 word ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if ((unsigned long )((unsigned int )word) == 0UL) {
    {
    tmp = __ffs((unsigned long )((unsigned int )(word >> 32)));
    }
    return (tmp + 32UL);
  }
  {
  tmp___0 = __ffs((unsigned long )word);
  }
  return (tmp___0);
}
}
extern unsigned long find_first_bit(unsigned long const   *addr , unsigned long size ) ;
extern unsigned long find_first_zero_bit(unsigned long const   *addr , unsigned long size ) ;
extern unsigned long find_last_bit(unsigned long const   *addr , unsigned long size ) ;
extern unsigned long find_next_bit(unsigned long const   *addr , unsigned long size ,
                                   unsigned long offset ) ;
extern unsigned long find_next_zero_bit(unsigned long const   *addr , unsigned long size ,
                                        unsigned long offset ) ;
extern char const   * const  x86_cap_flags[288] ;
extern char const   * const  x86_power_flags[32] ;
__inline static void __set_64bit(unsigned long long *ptr , unsigned int low , unsigned int high ) 
{ 

  {
  {
  __asm__  volatile   ("\n1:\t"
                       "movl (%0), %%eax\n\t"
                       "movl 4(%0), %%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b (%0)\n\t"
                       "jnz 1b": : "D" (ptr), "b" (low), "c" (high): "ax", "dx", "memory");
  }
  return;
}
}
__inline static void __set_64bit_constant(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
  __set_64bit(ptr, (unsigned int )value, (unsigned int )(value >> 32));
  }
  return;
}
}
__inline static void __set_64bit_var(unsigned long long *ptr , unsigned long long value ) 
{ 

  {
  {
  __set_64bit(ptr, *((unsigned int *)(& value) + 0), *((unsigned int *)(& value) + 1));
  }
  return;
}
}
__inline static unsigned long __xchg(unsigned long x , void volatile   *ptr , int size ) 
{ 

  {
  if (size == 1) {
    goto switch_1_1;
  } else {
    if (size == 2) {
      goto switch_1_2;
    } else {
      if (size == 4) {
        goto switch_1_4;
      } else {
        if (0) {
          switch_1_1: /* CIL Label */ 
          {
          __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
          switch_1_2: /* CIL Label */ 
          {
          __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
          switch_1_4: /* CIL Label */ 
          {
          __asm__  volatile   ("xchgl %0,%1": "=r" (x): "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (x): "memory");
          }
          goto switch_1_break;
        } else {
          switch_1_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (x);
}
}
__inline static unsigned long __cmpxchg(void volatile   *ptr , unsigned long old ,
                                        unsigned long new , int size ) 
{ unsigned long prev ;

  {
  if (size == 1) {
    goto switch_2_1;
  } else {
    if (size == 2) {
      goto switch_2_2;
    } else {
      if (size == 4) {
        goto switch_2_4;
      } else {
        if (0) {
          switch_2_1: /* CIL Label */ 
          {
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_2_2: /* CIL Label */ 
          {
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_2_4: /* CIL Label */ 
          {
          __asm__  volatile   (".section .smp_locks,\"a\"\n"
                               " "
                               ".balign 4"
                               " "
                               "\n"
                               " "
                               ".long"
                               " "
                               "661f\n"
                               ".previous\n"
                               "661:\n\tlock; "
                               "cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
        } else {
          switch_2_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (old);
}
}
__inline static unsigned long __sync_cmpxchg(void volatile   *ptr , unsigned long old ,
                                             unsigned long new , int size ) 
{ unsigned long prev ;

  {
  if (size == 1) {
    goto switch_3_1;
  } else {
    if (size == 2) {
      goto switch_3_2;
    } else {
      if (size == 4) {
        goto switch_3_4;
      } else {
        if (0) {
          switch_3_1: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_3_2: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_3_4: /* CIL Label */ 
          {
          __asm__  volatile   ("lock; cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
        } else {
          switch_3_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (old);
}
}
__inline static unsigned long __cmpxchg_local(void volatile   *ptr , unsigned long old ,
                                              unsigned long new , int size ) 
{ unsigned long prev ;

  {
  if (size == 1) {
    goto switch_4_1;
  } else {
    if (size == 2) {
      goto switch_4_2;
    } else {
      if (size == 4) {
        goto switch_4_4;
      } else {
        if (0) {
          switch_4_1: /* CIL Label */ 
          {
          __asm__  volatile   ("cmpxchgb %b1,%2": "=a" (prev): "q" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_4_2: /* CIL Label */ 
          {
          __asm__  volatile   ("cmpxchgw %w1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
          switch_4_4: /* CIL Label */ 
          {
          __asm__  volatile   ("cmpxchgl %1,%2": "=a" (prev): "r" (new), "m" (*((struct __xchg_dummy *)ptr)),
                               "0" (old): "memory");
          }
          return (prev);
        } else {
          switch_4_break: /* CIL Label */ ;
        }
      }
    }
  }
  return (old);
}
}
__inline static unsigned long long __cmpxchg64(void volatile   *ptr , unsigned long long old ,
                                               unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
  return (prev);
}
}
__inline static unsigned long long __cmpxchg64_local(void volatile   *ptr , unsigned long long old ,
                                                     unsigned long long new ) 
{ unsigned long long prev ;

  {
  {
  __asm__  volatile   ("cmpxchg8b %3": "=A" (prev): "b" ((unsigned long )new), "c" ((unsigned long )(new >> 32)),
                       "m" (*((struct __xchg_dummy *)ptr)), "0" (old): "memory");
  }
  return (prev);
}
}
extern unsigned long long cmpxchg_486_u64(void volatile   * , u64  , u64  ) ;
extern  __attribute__((__noreturn__)) int ____ilog2_NaN(void)  __attribute__((__const__)) ;
__inline static int __ilog2_u32(u32 n )  __attribute__((__const__)) ;
__inline static int __ilog2_u32(u32 n ) 
{ int tmp ;

  {
  {
  tmp = fls((int )n);
  }
  return (tmp - 1);
}
}
__inline static int __ilog2_u64(u64 n )  __attribute__((__const__)) ;
__inline static int __ilog2_u64(u64 n ) 
{ int tmp ;

  {
  {
  tmp = fls64(n);
  }
  return (tmp - 1);
}
}
__inline static bool is_power_of_2(unsigned long n )  __attribute__((__const__)) ;
__inline static bool is_power_of_2(unsigned long n ) 
{ int tmp ;

  {
  if (n != 0UL) {
    if ((n & (n - 1UL)) == 0UL) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return ((_Bool )tmp);
}
}
__inline static unsigned long __roundup_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
  tmp = fls_long(n - 1UL);
  }
  return (1UL << tmp);
}
}
__inline static unsigned long __rounddown_pow_of_two(unsigned long n )  __attribute__((__const__)) ;
__inline static unsigned long __rounddown_pow_of_two(unsigned long n ) 
{ unsigned int tmp ;

  {
  {
  tmp = fls_long(n);
  }
  return (1UL << (tmp - 1U));
}
}
extern int __ratelimit(struct ratelimit_state *rs ) ;
extern long long dynamic_debug_enabled ;
extern long long dynamic_debug_enabled2 ;
extern int ddebug_add_module(struct _ddebug *tab , unsigned int n , char const   *modname ) ;
__inline static int ddebug_remove_module(char *mod ) 
{ 

  {
  return (0);
}
}
extern void ( /* format attribute */  warn_slowpath_fmt)(char const   *file , int line ,
                                                         char const   *fmt  , ...) ;
extern void warn_slowpath_null(char const   *file , int line ) ;
extern char const   linux_banner[] ;
extern char const   linux_proc_banner[] ;
extern int console_printk[] ;
extern int _cond_resched(void) ;
__inline static void might_fault(void) 
{ 

  {
  {
  while (1) {
    while_5_continue: /* CIL Label */ ;
    {
    _cond_resched();
    }
    goto while_5_break;
  }
  while_5_break: /* CIL Label */ ;
  }
  return;
}
}
extern struct atomic_notifier_head panic_notifier_list ;
extern long (*panic_blink)(long time ) ;
extern  __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *fmt 
                                                                            , ...) ;
extern void oops_enter(void) ;
extern void oops_exit(void) ;
extern int oops_may_print(void) ;
extern  __attribute__((__noreturn__)) void do_exit(long error_code ) ;
extern  __attribute__((__noreturn__)) void complete_and_exit(struct completion * ,
                                                             long  ) ;
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
extern unsigned long long simple_strtoull(char const   * , char ** , unsigned int  ) ;
extern long long simple_strtoll(char const   * , char ** , unsigned int  ) ;
extern int strict_strtoul(char const   * , unsigned int  , unsigned long * ) ;
extern int strict_strtol(char const   * , unsigned int  , long * ) ;
extern int strict_strtoull(char const   * , unsigned int  , unsigned long long * ) ;
extern int strict_strtoll(char const   * , unsigned int  , long long * ) ;
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
extern int ( /* format attribute */  vsprintf)(char *buf , char const   * , va_list  ) ;
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
extern int ( /* format attribute */  vsnprintf)(char *buf , size_t size , char const   *fmt ,
                                                va_list args ) ;
extern int ( /* format attribute */  scnprintf)(char *buf , size_t size , char const   *fmt 
                                                , ...) ;
extern int ( /* format attribute */  vscnprintf)(char *buf , size_t size , char const   *fmt ,
                                                 va_list args ) ;
extern char *( /* format attribute */  kasprintf)(gfp_t gfp , char const   *fmt  , ...) ;
extern char *kvasprintf(gfp_t gfp , char const   *fmt , va_list args ) ;
extern int ( /* format attribute */  sscanf)(char const   * , char const   *  , ...) ;
extern int ( /* format attribute */  vsscanf)(char const   * , char const   * , va_list  ) ;
extern int get_option(char **str , int *pint ) ;
extern char *get_options(char const   *str , int nints , int *ints ) ;
extern unsigned long long memparse(char const   *ptr , char **retptr ) ;
extern int core_kernel_text(unsigned long addr ) ;
extern int __kernel_text_address(unsigned long addr ) ;
extern int kernel_text_address(unsigned long addr ) ;
extern int func_ptr_is_kernel_text(void *ptr ) ;
extern struct pid *session_of_pgrp(struct pid *pgrp ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) vprintk)(char const   *fmt ,
                                                                             va_list args ) ;
extern int ( /* format attribute */ __attribute__((__regparm__(0))) printk)(char const   *fmt 
                                                                            , ...) ;
extern struct ratelimit_state printk_ratelimit_state ;
extern int printk_ratelimit(void) ;
extern bool printk_timed_ratelimit(unsigned long *caller_jiffies , unsigned int interval_msec ) ;
extern void log_buf_kexec_setup(void) ;
extern int printk_needs_cpu(int cpu ) ;
extern void printk_tick(void) ;
extern void ( /* format attribute */ __attribute__((__regparm__(0))) early_printk)(char const   *fmt 
                                                                                   , ...) ;
extern unsigned long int_sqrt(unsigned long  ) ;
__inline static void console_silent(void) 
{ 

  {
  {
  console_printk[0] = 0;
  }
  return;
}
}
__inline static void console_verbose(void) 
{ 

  {
  if (console_printk[0]) {
    {
    console_printk[0] = 15;
    }
  }
  return;
}
}
extern void bust_spinlocks(int yes ) ;
extern void wake_up_klogd(void) ;
extern int oops_in_progress ;
extern int panic_timeout ;
extern int panic_on_oops ;
extern int panic_on_unrecovered_nmi ;
extern char const   *print_tainted(void) ;
extern void add_taint(unsigned int flag ) ;
extern int test_taint(unsigned int flag ) ;
extern unsigned long get_taint(void) ;
extern int root_mountflags ;
extern enum system_states system_state ;
extern void dump_stack(void) ;
extern void hex_dump_to_buffer(void const   *buf , size_t len , int rowsize , int groupsize ,
                               char *linebuf , size_t linebuflen , bool ascii ) ;
extern void print_hex_dump(char const   *level , char const   *prefix_str , int prefix_type ,
                           int rowsize , int groupsize , void const   *buf , size_t len ,
                           bool ascii ) ;
extern void print_hex_dump_bytes(char const   *prefix_str , int prefix_type , void const   *buf ,
                                 size_t len ) ;
extern char const   hex_asc[] ;
__inline static char *pack_hex_byte(char *buf , u8 byte ) 
{ char *tmp ;
  char *tmp___0 ;

  {
  {
  tmp = buf;
  buf ++;
  *tmp = (char )hex_asc[((int )byte & 240) >> 4];
  tmp___0 = buf;
  buf ++;
  *tmp___0 = (char )hex_asc[(int )byte & 15];
  }
  return (buf);
}
}
extern void tracing_on(void) ;
extern void tracing_off(void) ;
extern void tracing_off_permanent(void) ;
extern int tracing_is_on(void) ;
extern void tracing_start(void) ;
extern void tracing_stop(void) ;
extern void ftrace_off_permanent(void) ;
extern void ftrace_special(unsigned long arg1 , unsigned long arg2 , unsigned long arg3 ) ;
__inline static void ( /* format attribute */  ____trace_printk_check_format)(char const   *fmt 
                                                                              , ...) 
{ 

  {
  return;
}
}
extern int ( /* format attribute */  __trace_bprintk)(unsigned long ip , char const   *fmt 
                                                      , ...) ;
extern int ( /* format attribute */  __trace_printk)(unsigned long ip , char const   *fmt 
                                                     , ...) ;
extern int __ftrace_vbprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
extern int __ftrace_vprintk(unsigned long ip , char const   *fmt , va_list ap ) ;
extern void ftrace_dump(void) ;
extern int do_sysinfo(struct sysinfo *info ) ;
__inline static unsigned long native_save_fl(void) 
{ unsigned long flags ;

  {
  {
  __asm__  volatile   ("# __raw_save_flags\n\t"
                       "pushf ; pop %0": "=g" (flags): : "memory");
  }
  return (flags);
}
}
__inline static void native_restore_fl(unsigned long flags ) 
{ 

  {
  {
  __asm__  volatile   ("push %0 ; popf": : "g" (flags): "memory", "cc");
  }
  return;
}
}
__inline static void native_irq_disable(void) 
{ 

  {
  {
  __asm__  volatile   ("cli": : : "memory");
  }
  return;
}
}
__inline static void native_irq_enable(void) 
{ 

  {
  {
  __asm__  volatile   ("sti": : : "memory");
  }
  return;
}
}
__inline static void native_safe_halt(void) 
{ 

  {
  {
  __asm__  volatile   ("sti; hlt": : : "memory");
  }
  return;
}
}
__inline static void native_halt(void) 
{ 

  {
  {
  __asm__  volatile   ("hlt": : : "memory");
  }
  return;
}
}
__inline static unsigned long __raw_local_save_flags(void) 
{ unsigned long tmp ;

  {
  {
  tmp = native_save_fl();
  }
  return (tmp);
}
}
__inline static void raw_local_irq_restore(unsigned long flags ) 
{ 

  {
  {
  native_restore_fl(flags);
  }
  return;
}
}
__inline static void raw_local_irq_disable(void) 
{ 

  {
  {
  native_irq_disable();
  }
  return;
}
}
__inline static void raw_local_irq_enable(void) 
{ 

  {
  {
  native_irq_enable();
  }
  return;
}
}
__inline static void raw_safe_halt(void) 
{ 

  {
  {
  native_safe_halt();
  }
  return;
}
}
__inline static void halt(void) 
{ 

  {
  {
  native_halt();
  }
  return;
}
}
__inline static unsigned long __raw_local_irq_save(void) 
{ unsigned long flags ;
  unsigned long tmp ;

  {
  {
  tmp = __raw_local_save_flags();
  flags = tmp;
  raw_local_irq_disable();
  }
  return (flags);
}
}
__inline static int raw_irqs_disabled_flags(unsigned long flags ) 
{ 

  {
  return (! (flags & 512UL));
}
}
__inline static int raw_irqs_disabled(void) 
{ unsigned long flags ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp = __raw_local_save_flags();
  flags = tmp;
  tmp___0 = raw_irqs_disabled_flags(flags);
  }
  return (tmp___0);
}
}
extern struct task_struct *__switch_to(struct task_struct *prev , struct task_struct *next ) ;
extern void __switch_to_xtra(struct task_struct *prev_p , struct task_struct *next_p ,
                             struct tss_struct *tss ) ;
extern void native_load_gs_index(unsigned int  ) ;
__inline static unsigned long get_limit(unsigned long segment ) 
{ unsigned long __limit ;

  {
  {
  __asm__  ("lsll %1,%0": "=r" (__limit): "r" (segment));
  }
  return (__limit + 1UL);
}
}
__inline static void native_clts(void) 
{ 

  {
  {
  __asm__  volatile   ("clts":);
  }
  return;
}
}
static unsigned long __force_order  ;
__inline static unsigned long native_read_cr0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static void native_write_cr0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static unsigned long native_read_cr2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static void native_write_cr2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static unsigned long native_read_cr3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static void native_write_cr3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static unsigned long native_read_cr4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order));
  }
  return;
}
}
__inline static void native_wbinvd(void) 
{ 

  {
  {
  __asm__  volatile   ("wbinvd": : : "memory");
  }
  return;
}
}
__inline static void clflush(void volatile   *__p ) 
{ 

  {
  {
  __asm__  volatile   ("clflush %0": "+m" (*((char volatile   *)__p)));
  }
  return;
}
}
extern void disable_hlt(void) ;
extern void enable_hlt(void) ;
extern void cpu_idle_wait(void) ;
extern unsigned long arch_align_stack(unsigned long sp ) ;
extern void free_init_pages(char *what , unsigned long begin , unsigned long end ) ;
extern void default_idle(void) ;
extern void stop_this_cpu(void *dummy ) ;
__inline static void rdtsc_barrier(void) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (113): "memory");
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x76,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "lfence"
                       "\n664:\n"
                       ".previous": : "i" (114): "memory");
  }
  return;
}
}
extern unsigned int __VMALLOC_RESERVE ;
extern int sysctl_legacy_va_layout ;
extern void find_low_pfn_range(void) ;
extern unsigned long init_memory_mapping(unsigned long start , unsigned long end ) ;
extern void initmem_init(unsigned long  , unsigned long  ) ;
extern void free_initmem(void) ;
extern void setup_bootmem_allocator(void) ;
extern int page_is_ram(unsigned long pagenr ) ;
extern int devmem_is_allowed(unsigned long pagenr ) ;
extern unsigned long max_low_pfn_mapped ;
extern unsigned long max_pfn_mapped ;
extern char *strndup_user(char const   * , long  ) ;
extern void *memdup_user(void const   * , size_t  ) ;
extern char *strcpy(char *dest , char const   *src ) ;
extern char *strncpy(char *dest , char const   *src , size_t count ) ;
extern char *strcat(char *dest , char const   *src ) ;
extern char *strncat(char *dest , char const   *src , size_t count ) ;
extern int strcmp(char const   *cs , char const   *ct ) ;
extern int strncmp(char const   *cs , char const   *ct , size_t count ) ;
extern char *strchr(char const   *s , int c ) ;
extern size_t strlen(char const   *s ) ;
__inline static void *__memcpy(void *to , void const   *from , size_t n ) 
{ int d0 ;
  int d1 ;
  int d2 ;

  {
  {
  __asm__  volatile   ("rep ; movsl\n\t"
                       "movl %4,%%ecx\n\t"
                       "andl $3,%%ecx\n\t"
                       "jz 1f\n\t"
                       "rep ; movsb\n\t"
                       "1:": "=&c" (d0), "=&D" (d1), "=&S" (d2): "0" (n / 4U), "g" (n),
                       "1" ((long )to), "2" ((long )from): "memory");
  }
  return (to);
}
}
__inline static void *__constant_memcpy(void *to , void const   *from , size_t n ) 
{ long esi ;
  long edi ;
  int ecx ;

  {
  if (! n) {
    return (to);
  }
  if ((int )n == 1) {
    goto switch_6_1;
  } else {
    if ((int )n == 2) {
      goto switch_6_2;
    } else {
      if ((int )n == 4) {
        goto switch_6_4;
      } else {
        if ((int )n == 3) {
          goto switch_6_3;
        } else {
          if ((int )n == 5) {
            goto switch_6_5;
          } else {
            if ((int )n == 6) {
              goto switch_6_6;
            } else {
              if ((int )n == 8) {
                goto switch_6_8;
              } else {
                if (0) {
                  switch_6_1: /* CIL Label */ 
                  {
                  *((char *)to) = *((char *)from);
                  }
                  return (to);
                  switch_6_2: /* CIL Label */ 
                  {
                  *((short *)to) = *((short *)from);
                  }
                  return (to);
                  switch_6_4: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  }
                  return (to);
                  switch_6_3: /* CIL Label */ 
                  {
                  *((short *)to) = *((short *)from);
                  *((char *)to + 2) = *((char *)from + 2);
                  }
                  return (to);
                  switch_6_5: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  *((char *)to + 4) = *((char *)from + 4);
                  }
                  return (to);
                  switch_6_6: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  *((short *)to + 2) = *((short *)from + 2);
                  }
                  return (to);
                  switch_6_8: /* CIL Label */ 
                  {
                  *((int *)to) = *((int *)from);
                  *((int *)to + 1) = *((int *)from + 1);
                  }
                  return (to);
                } else {
                  switch_6_break: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
  {
  esi = (long )from;
  edi = (long )to;
  }
  if (n >= 20U) {
    {
    __asm__  volatile   ("rep ; movsl": "=&c" (ecx), "=&D" (edi), "=&S" (esi): "0" (n / 4U),
                         "1" (edi), "2" (esi): "memory");
    }
  } else {
    if (n >= 16U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
    if (n >= 12U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
    if (n >= 8U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
    if (n >= 4U) {
      {
      __asm__  volatile   ("movsl": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
      }
    }
  }
  if ((int )(n % 4U) == 0) {
    goto switch_7_0;
  } else {
    if ((int )(n % 4U) == 1) {
      goto switch_7_1;
    } else {
      if ((int )(n % 4U) == 2) {
        goto switch_7_2;
      } else {
        {
        goto switch_7_default;
        if (0) {
          switch_7_0: /* CIL Label */ 
          return (to);
          switch_7_1: /* CIL Label */ 
          {
          __asm__  volatile   ("movsb": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
          return (to);
          switch_7_2: /* CIL Label */ 
          {
          __asm__  volatile   ("movsw": "=&D" (edi), "=&S" (esi): "0" (edi), "1" (esi): "memory");
          }
          return (to);
          switch_7_default: /* CIL Label */ 
          {
          __asm__  volatile   ("movsw\n\tmovsb": "=&D" (edi), "=&S" (esi): "0" (edi),
                               "1" (esi): "memory");
          }
          return (to);
        } else {
          switch_7_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
extern void *memmove(void *dest , void const   *src , size_t n ) ;
extern void *memchr(void const   *cs , int c , size_t count ) ;
__inline static void *__memset_generic(void *s , char c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
  __asm__  volatile   ("rep\n\t"
                       "stosb": "=&c" (d0), "=&D" (d1): "a" (c), "1" (s), "0" (count): "memory");
  }
  return (s);
}
}
__inline static void *__constant_c_memset(void *s , unsigned long c , size_t count ) 
{ int d0 ;
  int d1 ;

  {
  {
  __asm__  volatile   ("rep ; stosl\n\t"
                       "testb $2,%b3\n\t"
                       "je 1f\n\t"
                       "stosw\n"
                       "1:\ttestb $1,%b3\n\t"
                       "je 2f\n\t"
                       "stosb\n"
                       "2:": "=&c" (d0), "=&D" (d1): "a" (c), "q" (count), "0" (count / 4U),
                       "1" ((long )s): "memory");
  }
  return (s);
}
}
extern size_t strnlen(char const   *s , size_t count ) ;
extern char *strstr(char const   *cs , char const   *ct ) ;
__inline static void *__constant_c_and_count_memset(void *s , unsigned long pattern ,
                                                    size_t count ) 
{ int d0 ;
  int d1 ;
  unsigned long eax ;

  {
  if ((int )count == 0) {
    goto switch_8_0;
  } else {
    if ((int )count == 1) {
      goto switch_8_1;
    } else {
      if ((int )count == 2) {
        goto switch_8_2;
      } else {
        if ((int )count == 3) {
          goto switch_8_3;
        } else {
          if ((int )count == 4) {
            goto switch_8_4;
          } else {
            if (0) {
              switch_8_0: /* CIL Label */ 
              return (s);
              switch_8_1: /* CIL Label */ 
              {
              *((unsigned char *)s) = (unsigned char )(pattern & 255UL);
              }
              return (s);
              switch_8_2: /* CIL Label */ 
              {
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              }
              return (s);
              switch_8_3: /* CIL Label */ 
              {
              *((unsigned short *)s) = (unsigned short )(pattern & 65535UL);
              *((unsigned char *)s + 2) = (unsigned char )(pattern & 255UL);
              }
              return (s);
              switch_8_4: /* CIL Label */ 
              {
              *((unsigned long *)s) = pattern;
              }
              return (s);
            } else {
              switch_8_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
  eax = pattern;
  }
  if ((int )(count % 4U) == 0) {
    goto switch_9_0;
  } else {
    if ((int )(count % 4U) == 1) {
      goto switch_9_1;
    } else {
      if ((int )(count % 4U) == 2) {
        goto switch_9_2;
      } else {
        {
        goto switch_9_default;
        if (0) {
          switch_9_0: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_9_1: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_9_2: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw": "=&c" (d0), "=&D" (d1): "a" (eax), "0" (count / 4U),
                               "1" ((long )s): "memory");
          }
          return (s);
          switch_9_default: /* CIL Label */ 
          {
          __asm__  volatile   ("rep ; stosl"
                               "\n\tstosw\n\tstosb": "=&c" (d0), "=&D" (d1): "a" (eax),
                               "0" (count / 4U), "1" ((long )s): "memory");
          }
          return (s);
        } else {
          switch_9_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
extern void *memscan(void *addr , int c , size_t size ) ;
extern size_t strlcpy(char * , char const   * , size_t  ) ;
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
extern int strnicmp(char const   * , char const   * , __kernel_size_t  ) ;
extern int strcasecmp(char const   *s1 , char const   *s2 ) ;
extern int strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
extern char *strnchr(char const   * , size_t  , int  ) ;
extern char *strrchr(char const   * , int  ) ;
extern char *strstrip(char * ) ;
extern char *strpbrk(char const   * , char const   * ) ;
extern char *strsep(char ** , char const   * ) ;
extern __kernel_size_t strspn(char const   * , char const   * ) ;
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
extern int __builtin_memcmp(void const   * , void const   * , __kernel_size_t  ) ;
extern char *kstrdup(char const   *s , gfp_t gfp ) ;
extern char *kstrndup(char const   *s , size_t len , gfp_t gfp ) ;
extern void *kmemdup(void const   *src , size_t len , gfp_t gfp ) ;
extern char **argv_split(gfp_t gfp , char const   *str , int *argcp ) ;
extern void argv_free(char **argv ) ;
extern bool sysfs_streq(char const   *s1 , char const   *s2 ) ;
extern int vbin_printf(u32 *bin_buf , size_t size , char const   *fmt , va_list args ) ;
extern int bstr_printf(char *buf , size_t size , char const   *fmt , u32 const   *bin_buf ) ;
extern int ( /* format attribute */  bprintf)(u32 *bin_buf , size_t size , char const   *fmt 
                                              , ...) ;
extern ssize_t memory_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
__inline static bool strstarts(char const   *str , char const   *prefix ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  {
  tmp = strlen(prefix);
  tmp___0 = strncmp(str, prefix, tmp);
  }
  return ((_Bool )(tmp___0 == 0));
}
}
__inline static void clear_page(void *page ) 
{ 

  {
  {
  __constant_c_and_count_memset(page, 0UL, (unsigned int )(1UL << 12));
  }
  return;
}
}
__inline static void copy_page(void *to , void *from ) 
{ 

  {
  {
  __constant_memcpy(to, (void const   *)from, (unsigned int )(1UL << 12));
  }
  return;
}
}
__inline static void clear_user_page(void *page , unsigned long vaddr , struct page *pg ) 
{ 

  {
  {
  clear_page(page);
  }
  return;
}
}
__inline static void copy_user_page(void *to , void *from , unsigned long vaddr ,
                                    struct page *topage ) 
{ 

  {
  {
  copy_page(to, from);
  }
  return;
}
}
extern bool __virt_addr_valid(unsigned long kaddr ) ;
__inline static int get_order(unsigned long size )  __attribute__((__const__)) ;
__inline static int get_order(unsigned long size ) 
{ int order ;

  {
  {
  size = (size - 1UL) >> 11;
  order = -1;
  }
  {
  while (1) {
    while_10_continue: /* CIL Label */ ;
    {
    size >>= 1;
    order ++;
    }
    if (! size) {
      goto while_10_break;
    }
  }
  while_10_break: /* CIL Label */ ;
  }
  return (order);
}
}
extern bool __vmalloc_start_set ;
__inline static pgd_t native_make_pgd(pgdval_t val ) 
{ pgd_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.pgd = val;
  }
  return (__constr_expr_0);
}
}
__inline static pgdval_t native_pgd_val(pgd_t pgd ) 
{ 

  {
  return (pgd.pgd);
}
}
__inline static pgdval_t pgd_flags(pgd_t pgd ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pgd);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
__inline static int pgd_none(pgd_t pgd ) 
{ 

  {
  return (0);
}
}
__inline static int pgd_present(pgd_t pgd ) 
{ 

  {
  return (1);
}
}
__inline static void pgd_clear(pgd_t *pgd ) 
{ 

  {
  return;
}
}
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address ) 
{ 

  {
  return ((pud_t *)pgd);
}
}
__inline static pudval_t native_pud_val(pud_t pud ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pud.pgd);
  }
  return (tmp);
}
}
__inline static int pud_none(pud_t pud ) 
{ 

  {
  return (0);
}
}
__inline static int pud_present(pud_t pud ) 
{ 

  {
  return (1);
}
}
__inline static void pud_clear(pud_t *pud ) 
{ 

  {
  return;
}
}
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address ) 
{ 

  {
  return ((pmd_t *)pud);
}
}
__inline static void pmd_free(struct mm_struct *mm , pmd_t *pmd ) 
{ 

  {
  return;
}
}
__inline static pmdval_t native_pmd_val(pmd_t pmd ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pmd.pud.pgd);
  }
  return (tmp);
}
}
__inline static pudval_t pud_flags(pud_t pud ) 
{ pudval_t tmp ;

  {
  {
  tmp = native_pud_val(pud);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
__inline static pmdval_t pmd_flags(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = native_pmd_val(pmd);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
__inline static pte_t native_make_pte(pteval_t val ) 
{ pte_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.pte = val;
  }
  return (__constr_expr_0);
}
}
__inline static pteval_t native_pte_val(pte_t pte ) 
{ 

  {
  return (pte.pte);
}
}
__inline static pteval_t pte_flags(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = native_pte_val(pte);
  }
  return (tmp & ~ ((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))));
}
}
extern pteval_t __supported_pte_mask ;
extern int nx_enabled ;
extern void set_nx(void) ;
extern pgprot_t pgprot_writecombine(pgprot_t prot ) ;
extern pgprot_t phys_mem_access_prot(struct file *file , unsigned long pfn , unsigned long size ,
                                     pgprot_t vma_prot ) ;
extern int phys_mem_access_prot_allowed(struct file *file , unsigned long pfn , unsigned long size ,
                                        pgprot_t *vma_prot ) ;
extern void set_pte_vaddr(unsigned long vaddr , pte_t pte ) ;
extern void native_pagetable_setup_start(pgd_t *base ) ;
extern void native_pagetable_setup_done(pgd_t *base ) ;
extern void arch_report_meminfo(struct seq_file *m ) ;
extern void update_page_count(int level , unsigned long pages ) ;
extern pte_t *lookup_address(unsigned long address , unsigned int *level ) ;
__inline static unsigned long long native_read_tscp(unsigned int *aux ) 
{ unsigned long low ;
  unsigned long high ;

  {
  {
  __asm__  volatile   (".byte 0x0f,0x01,0xf9": "=a" (low), "=d" (high), "=c" (*aux));
  }
  return ((unsigned long long )low | ((unsigned long long )high << 32));
}
}
__inline static unsigned long long native_read_msr(unsigned int msr ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("rdmsr": "=A" (val): "c" (msr));
  }
  return (val);
}
}
__inline static unsigned long long native_read_msr_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("2: rdmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=r" (*err), "=A" (val): "c" (msr), [fault] "i" (-14));
  }
  return (val);
}
}
__inline static unsigned long long native_read_msr_amd_safe(unsigned int msr , int *err ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("2: rdmsr ; xor %0,%0\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %3,%0 ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": "=r" (*err), "=A" (val): "c" (msr), "D" (2623152186U),
                       "i" (-14));
  }
  return (val);
}
}
__inline static void native_write_msr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
  __asm__  volatile   ("wrmsr": : "c" (msr), "a" (low), "d" (high): "memory");
  }
  return;
}
}
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high )  __attribute__((__no_instrument_function__)) ;
__inline static int native_write_msr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int err ;

  {
  {
  __asm__  volatile   ("2: wrmsr ; xor %[err],%[err]\n"
                       "1:\n\t"
                       ".section .fixup,\"ax\"\n\t"
                       "3:  mov %[fault],%[err] ; jmp 1b\n\t"
                       ".previous\n\t"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "2b"
                       ","
                       "3b"
                       "\n"
                       " .previous\n": [err] "=a" (err): "c" (msr), "0" (low), "d" (high),
                       [fault] "i" (-14): "memory");
  }
  return (err);
}
}
extern unsigned long long native_read_tsc(void) ;
__inline static unsigned long long __native_read_tsc(void) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("rdtsc": "=A" (val));
  }
  return (val);
}
}
__inline static unsigned long long native_read_pmc(int counter ) 
{ unsigned long long val ;

  {
  {
  __asm__  volatile   ("rdpmc": "=A" (val): "c" (counter));
  }
  return (val);
}
}
__inline static void wrmsr(unsigned int msr , unsigned int low , unsigned int high ) 
{ 

  {
  {
  native_write_msr(msr, low, high);
  }
  return;
}
}
__inline static int wrmsr_safe(unsigned int msr , unsigned int low , unsigned int high ) 
{ int tmp ;

  {
  {
  tmp = native_write_msr_safe(msr, low, high);
  }
  return (tmp);
}
}
__inline static int rdmsrl_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
  *p = native_read_msr_safe(msr, & err);
  }
  return (err);
}
}
__inline static int rdmsrl_amd_safe(unsigned int msr , unsigned long long *p ) 
{ int err ;

  {
  {
  *p = native_read_msr_amd_safe(msr, & err);
  }
  return (err);
}
}
extern int rdmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
extern int wrmsr_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
extern int rdmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 *l , u32 *h ) ;
extern int wrmsr_safe_on_cpu(unsigned int cpu , u32 msr_no , u32 l , u32 h ) ;
__inline static void *ERR_PTR(long error ) 
{ 

  {
  return ((void *)error);
}
}
__inline static long PTR_ERR(void const   *ptr ) 
{ 

  {
  return ((long )ptr);
}
}
__inline static long IS_ERR(void const   *ptr ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! ((unsigned long )ptr >= 0xfffff001UL))), 0L);
  }
  return (tmp);
}
}
__inline static void *ERR_CAST(void const   *ptr ) 
{ 

  {
  return ((void *)ptr);
}
}
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored )  __attribute__((__section__(".cpuinit.text"))) ;
__inline static void ds_init_intel(struct cpuinfo_x86 *ignored ) 
{ 

  {
  return;
}
}
__inline static void ds_switch_to(struct task_struct *prev , struct task_struct *next ) 
{ 

  {
  return;
}
}
__inline static void ds_exit_thread(struct task_struct *tsk ) 
{ 

  {
  return;
}
}
extern int register_exec_domain(struct exec_domain * ) ;
extern int unregister_exec_domain(struct exec_domain * ) ;
extern int __set_personality(unsigned long  ) ;
extern int __bitmap_empty(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_full(unsigned long const   *bitmap , int bits ) ;
extern int __bitmap_equal(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                          int bits ) ;
extern void __bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                int bits ) ;
extern void __bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                 int shift , int bits ) ;
extern void __bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                int shift , int bits ) ;
extern void __bitmap_and(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_or(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                        int bits ) ;
extern void __bitmap_xor(unsigned long *dst , unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                         int bits ) ;
extern void __bitmap_andnot(unsigned long *dst , unsigned long const   *bitmap1 ,
                            unsigned long const   *bitmap2 , int bits ) ;
extern int __bitmap_intersects(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                               int bits ) ;
extern int __bitmap_subset(unsigned long const   *bitmap1 , unsigned long const   *bitmap2 ,
                           int bits ) ;
extern int __bitmap_weight(unsigned long const   *bitmap , int bits ) ;
extern int bitmap_scnprintf(char *buf , unsigned int len , unsigned long const   *src ,
                            int nbits ) ;
extern int __bitmap_parse(char const   *buf , unsigned int buflen , int is_user ,
                          unsigned long *dst , int nbits ) ;
extern int bitmap_parse_user(char const   *ubuf , unsigned int ulen , unsigned long *dst ,
                             int nbits ) ;
extern int bitmap_scnlistprintf(char *buf , unsigned int len , unsigned long const   *src ,
                                int nbits ) ;
extern int bitmap_parselist(char const   *buf , unsigned long *maskp , int nmaskbits ) ;
extern void bitmap_remap(unsigned long *dst , unsigned long const   *src , unsigned long const   *old ,
                         unsigned long const   *new , int bits ) ;
extern int bitmap_bitremap(int oldbit , unsigned long const   *old , unsigned long const   *new ,
                           int bits ) ;
extern void bitmap_onto(unsigned long *dst , unsigned long const   *orig , unsigned long const   *relmap ,
                        int bits ) ;
extern void bitmap_fold(unsigned long *dst , unsigned long const   *orig , int sz ,
                        int bits ) ;
extern int bitmap_find_free_region(unsigned long *bitmap , int bits , int order ) ;
extern void bitmap_release_region(unsigned long *bitmap , int pos , int order ) ;
extern int bitmap_allocate_region(unsigned long *bitmap , int pos , int order ) ;
extern void bitmap_copy_le(void *dst , unsigned long const   *src , int nbits ) ;
__inline static void bitmap_zero(unsigned long *dst , int nbits ) 
{ int len ;

  {
  {
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
  __constant_c_memset((void *)dst, 0UL, (unsigned int )len);
  }
  return;
}
}
__inline static void bitmap_fill(unsigned long *dst , int nbits ) 
{ size_t nlongs ;
  int len ;

  {
  {
  nlongs = (size_t )((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long )));
  len = (int )((unsigned long )(nlongs - 1U) * sizeof(unsigned long ));
  __constant_c_memset((void *)dst, 4294967295UL, (unsigned int )len);
  }
  if (nbits % 32) {
    {
    *(dst + (nlongs - 1U)) = (1UL << nbits % 32) - 1UL;
    }
  } else {
    {
    *(dst + (nlongs - 1U)) = ~ 0UL;
    }
  }
  return;
}
}
__inline static void bitmap_copy(unsigned long *dst , unsigned long const   *src ,
                                 int nbits ) 
{ int len ;

  {
  {
  len = (int )(((((unsigned long )nbits + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(unsigned long ));
  __memcpy((void *)dst, (void const   *)src, (unsigned int )len);
  }
  return;
}
}
__inline static void bitmap_and(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_and(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_or(unsigned long *dst , unsigned long const   *src1 ,
                               unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_or(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_xor(unsigned long *dst , unsigned long const   *src1 ,
                                unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_xor(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_andnot(unsigned long *dst , unsigned long const   *src1 ,
                                   unsigned long const   *src2 , int nbits ) 
{ 

  {
  {
  __bitmap_andnot(dst, src1, src2, nbits);
  }
  return;
}
}
__inline static void bitmap_complement(unsigned long *dst , unsigned long const   *src ,
                                       int nbits ) 
{ unsigned long tmp ;

  {
  {
  __bitmap_complement(dst, src, nbits);
  }
  return;
}
}
__inline static int bitmap_equal(unsigned long const   *src1 , unsigned long const   *src2 ,
                                 int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_equal(src1, src2, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_intersects(unsigned long const   *src1 , unsigned long const   *src2 ,
                                      int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = __bitmap_intersects(src1, src2, nbits);
  }
  return (tmp___0);
}
}
__inline static int bitmap_subset(unsigned long const   *src1 , unsigned long const   *src2 ,
                                  int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_subset(src1, src2, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_empty(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_empty(src, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_full(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_full(src, nbits);
  }
  return (tmp___1);
}
}
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___1 = __bitmap_weight(src, nbits);
  }
  return (tmp___1);
}
}
__inline static void bitmap_shift_right(unsigned long *dst , unsigned long const   *src ,
                                        int n , int nbits ) 
{ 

  {
  {
  __bitmap_shift_right(dst, src, n, nbits);
  }
  return;
}
}
__inline static void bitmap_shift_left(unsigned long *dst , unsigned long const   *src ,
                                       int n , int nbits ) 
{ unsigned long tmp ;

  {
  {
  __bitmap_shift_left(dst, src, n, nbits);
  }
  return;
}
}
__inline static int bitmap_parse(char const   *buf , unsigned int buflen , unsigned long *maskp ,
                                 int nmaskbits ) 
{ int tmp ;

  {
  {
  tmp = __bitmap_parse(buf, buflen, 0, maskp, nmaskbits);
  }
  return (tmp);
}
}
extern cpumask_t _unused_cpumask_arg_ ;
__inline static void __cpu_set(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
  set_bit((unsigned int )cpu, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __cpu_clear(int cpu , cpumask_t volatile   *dstp ) 
{ 

  {
  {
  clear_bit(cpu, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __cpus_setall(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_fill(dstp->bits, nbits);
  }
  return;
}
}
__inline static void __cpus_clear(cpumask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_zero(dstp->bits, nbits);
  }
  return;
}
}
__inline static int __cpu_test_and_set(int cpu , cpumask_t *addr ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(cpu, (unsigned long volatile   *)(addr->bits));
  }
  return (tmp);
}
}
__inline static void __cpus_and(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __cpus_or(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                               int nbits ) 
{ 

  {
  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
  return;
}
}
__inline static void __cpus_xor(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __cpus_andnot(cpumask_t *dstp , cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                   int nbits ) 
{ 

  {
  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  }
  return;
}
}
__inline static void __cpus_complement(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int nbits ) 
{ 

  {
  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
  return;
}
}
__inline static int __cpus_equal(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                 int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_intersects(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                      int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_subset(cpumask_t const   *src1p , cpumask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_empty(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_full(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __cpus_weight(cpumask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static void __cpus_shift_right(cpumask_t *dstp , cpumask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static void __cpus_shift_left(cpumask_t *dstp , cpumask_t const   *srcp ,
                                       int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static int __check_is_bitmap(unsigned long const   *bitmap ) 
{ 

  {
  return (1);
}
}
extern unsigned long const   cpu_bit_bitmap[33][((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
__inline static struct cpumask  const  *get_cpu_mask(unsigned int cpu ) 
{ unsigned long const   *p ;
  int tmp ;

  {
  {
  p = cpu_bit_bitmap[1U + cpu % 32U];
  p -= cpu / 32U;
  }
  return ((struct cpumask  const  *)((struct cpumask *)p));
}
}
__inline static int __cpu_remap(int oldbit , cpumask_t const   *oldp , cpumask_t const   *newp ,
                                int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
  return (tmp);
}
}
__inline static void __cpus_remap(cpumask_t *dstp , cpumask_t const   *srcp , cpumask_t const   *oldp ,
                                  cpumask_t const   *newp , int nbits ) 
{ 

  {
  {
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
  return;
}
}
__inline static void __cpus_onto(cpumask_t *dstp , cpumask_t const   *origp , cpumask_t const   *relmapp ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
  return;
}
}
__inline static void __cpus_fold(cpumask_t *dstp , cpumask_t const   *origp , int sz ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
  return;
}
}
extern int nr_cpu_ids ;
extern int __first_cpu(cpumask_t const   *srcp ) ;
extern int __next_cpu(int n , cpumask_t const   *srcp ) ;
extern int __any_online_cpu(cpumask_t const   *mask ) ;
extern struct cpumask  const  * const  cpu_possible_mask ;
extern struct cpumask  const  * const  cpu_online_mask ;
extern struct cpumask  const  * const  cpu_present_mask ;
extern struct cpumask  const  * const  cpu_active_mask ;
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 

  {
  return (cpu);
}
}
__inline static unsigned int cpumask_first(struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  {
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 8UL);
  }
  return ((unsigned int )tmp);
}
}
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  if (n != -1) {
    {
    cpumask_check((unsigned int )n);
    }
  }
  {
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
  return ((unsigned int )tmp);
}
}
__inline static unsigned int cpumask_next_zero(int n , struct cpumask  const  *srcp ) 
{ unsigned long tmp ;

  {
  if (n != -1) {
    {
    cpumask_check((unsigned int )n);
    }
  }
  {
  tmp = find_next_zero_bit((unsigned long const   *)(srcp->bits), 8UL, (unsigned long )(n + 1));
  }
  return ((unsigned int )tmp);
}
}
extern int cpumask_next_and(int n , struct cpumask  const  * , struct cpumask  const  * ) ;
extern int cpumask_any_but(struct cpumask  const  *mask , unsigned int cpu ) ;
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_check(cpu);
  set_bit(tmp, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void cpumask_clear_cpu(int cpu , struct cpumask *dstp ) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_check((unsigned int )cpu);
  clear_bit((int )tmp, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static int cpumask_test_and_set_cpu(int cpu , struct cpumask *cpumask ) 
{ unsigned int tmp ;
  int tmp___0 ;

  {
  {
  tmp = cpumask_check((unsigned int )cpu);
  tmp___0 = test_and_set_bit((int )tmp, (unsigned long volatile   *)(cpumask->bits));
  }
  return (tmp___0);
}
}
__inline static void cpumask_setall(struct cpumask *dstp ) 
{ 

  {
  {
  bitmap_fill(dstp->bits, 8);
  }
  return;
}
}
__inline static void cpumask_clear(struct cpumask *dstp ) 
{ 

  {
  {
  bitmap_zero(dstp->bits, 8);
  }
  return;
}
}
__inline static void cpumask_and(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             8);
  }
  return;
}
}
__inline static void cpumask_or(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            8);
  }
  return;
}
}
__inline static void cpumask_xor(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                 struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             8);
  }
  return;
}
}
__inline static void cpumask_andnot(struct cpumask *dstp , struct cpumask  const  *src1p ,
                                    struct cpumask  const  *src2p ) 
{ 

  {
  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                8);
  }
  return;
}
}
__inline static void cpumask_complement(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
  return;
}
}
__inline static bool cpumask_equal(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     8);
  }
  return ((_Bool )tmp);
}
}
__inline static bool cpumask_intersects(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          8);
  }
  return ((_Bool )tmp);
}
}
__inline static int cpumask_subset(struct cpumask  const  *src1p , struct cpumask  const  *src2p ) 
{ int tmp ;

  {
  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      8);
  }
  return (tmp);
}
}
__inline static bool cpumask_empty(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), 8);
  }
  return ((_Bool )tmp);
}
}
__inline static bool cpumask_full(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), 8);
  }
  return ((_Bool )tmp);
}
}
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), 8);
  }
  return ((unsigned int )tmp);
}
}
__inline static void cpumask_shift_right(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                         int n ) 
{ 

  {
  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
  return;
}
}
__inline static void cpumask_shift_left(struct cpumask *dstp , struct cpumask  const  *srcp ,
                                        int n ) 
{ 

  {
  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, 8);
  }
  return;
}
}
__inline static void cpumask_copy(struct cpumask *dstp , struct cpumask  const  *srcp ) 
{ 

  {
  {
  bitmap_copy(dstp->bits, (unsigned long const   *)(srcp->bits), 8);
  }
  return;
}
}
__inline static int cpumask_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         8);
  }
  return (tmp);
}
}
__inline static int cpumask_parse_user(char const   *buf , int len , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, 8);
  }
  return (tmp);
}
}
__inline static int cpulist_scnprintf(char *buf , int len , struct cpumask  const  *srcp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             8);
  }
  return (tmp);
}
}
__inline static int cpulist_parse(char const   *buf , struct cpumask *dstp ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parselist(buf, dstp->bits, 8);
  }
  return (tmp);
}
}
__inline static size_t cpumask_size(void) 
{ 

  {
  return ((unsigned int )((((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long )));
}
}
__inline static bool alloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
  return ((_Bool)1);
}
}
__inline static bool alloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
  return ((_Bool)1);
}
}
__inline static bool zalloc_cpumask_var(cpumask_var_t *mask , gfp_t flags ) 
{ 

  {
  {
  cpumask_clear(*mask);
  }
  return ((_Bool)1);
}
}
__inline static bool zalloc_cpumask_var_node(cpumask_var_t *mask , gfp_t flags , int node ) 
{ 

  {
  {
  cpumask_clear(*mask);
  }
  return ((_Bool)1);
}
}
__inline static void alloc_bootmem_cpumask_var(cpumask_var_t *mask ) 
{ 

  {
  return;
}
}
__inline static void free_cpumask_var(struct cpumask *mask ) 
{ 

  {
  return;
}
}
extern unsigned long const   cpu_all_bits[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
extern void set_cpu_possible(unsigned int cpu , bool possible ) ;
extern void set_cpu_present(unsigned int cpu , bool present ) ;
extern void set_cpu_online(unsigned int cpu , bool online ) ;
extern void set_cpu_active(unsigned int cpu , bool active ) ;
extern void init_cpu_present(struct cpumask  const  *src ) ;
extern void init_cpu_possible(struct cpumask  const  *src ) ;
extern void init_cpu_online(struct cpumask  const  *src ) ;
__inline static void *current_text_addr(void) 
{ void *pc ;

  {
  {
  __asm__  volatile   ("mov $1f, %0; 1:": "=r" (pc));
  }
  return (pc);
}
}
extern struct cpuinfo_x86 boot_cpu_data ;
extern struct cpuinfo_x86 new_cpu_data ;
extern struct tss_struct doublefault_tss ;
extern __u32 cleared_cpu_caps[9] ;
extern struct cpuinfo_x86 per_cpu__cpu_info  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
extern struct seq_operations  const  cpuinfo_op ;
__inline static int hlt_works(int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_info));
  }
  return ((int )((struct cpuinfo_x86 *)(__ptr + __per_cpu_offset[cpu]))->hlt_works_ok);
}
}
extern void cpu_detect(struct cpuinfo_x86 *c ) ;
extern struct pt_regs *idle_regs(struct pt_regs * ) ;
extern void early_cpu_init(void) ;
extern void identify_boot_cpu(void) ;
extern void identify_secondary_cpu(struct cpuinfo_x86 * ) ;
extern void print_cpu_info(struct cpuinfo_x86 * ) ;
extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c ) ;
extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c ) ;
extern unsigned short num_cache_leaves ;
extern void detect_extended_topology(struct cpuinfo_x86 *c ) ;
extern void detect_ht(struct cpuinfo_x86 *c ) ;
__inline static void native_cpuid(unsigned int *eax , unsigned int *ebx , unsigned int *ecx ,
                                  unsigned int *edx ) 
{ 

  {
  {
  __asm__  ("cpuid": "=a" (*eax), "=b" (*ebx), "=c" (*ecx), "=d" (*edx): "0" (*eax),
            "2" (*ecx));
  }
  return;
}
}
__inline static void load_cr3(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
extern struct tss_struct per_cpu__init_tss  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
extern unsigned int xstate_size ;
extern void free_thread_xstate(struct task_struct * ) ;
extern struct kmem_cache *task_xstate_cachep ;
__inline static unsigned long native_get_debugreg(int regno ) 
{ unsigned long val ;

  {
  {
  val = 0UL;
  }
  if (regno == 0) {
    goto switch_11_0;
  } else {
    if (regno == 1) {
      goto switch_11_1;
    } else {
      if (regno == 2) {
        goto switch_11_2;
      } else {
        if (regno == 3) {
          goto switch_11_3;
        } else {
          if (regno == 6) {
            goto switch_11_6;
          } else {
            if (regno == 7) {
              goto switch_11_7;
            } else {
              {
              goto switch_11_default;
              if (0) {
                switch_11_0: /* CIL Label */ 
                {
                __asm__  ("mov %%db0, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_1: /* CIL Label */ 
                {
                __asm__  ("mov %%db1, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_2: /* CIL Label */ 
                {
                __asm__  ("mov %%db2, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_3: /* CIL Label */ 
                {
                __asm__  ("mov %%db3, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_6: /* CIL Label */ 
                {
                __asm__  ("mov %%db6, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_7: /* CIL Label */ 
                {
                __asm__  ("mov %%db7, %0": "=r" (val));
                }
                goto switch_11_break;
                switch_11_default: /* CIL Label */ 
                {

                }
                {
                while (1) {
                  while_12_continue: /* CIL Label */ ;
                  {
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (497), "i" (sizeof(struct bug_entry )));
                  }
                  {
                  while (1) {
                    while_13_continue: /* CIL Label */ ;
                  }
                  while_13_break: /* CIL Label */ ;
                  }
                  goto while_12_break;
                }
                while_12_break: /* CIL Label */ ;
                }
              } else {
                switch_11_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
  return (val);
}
}
__inline static void native_set_debugreg(int regno , unsigned long value ) 
{ 

  {
  if (regno == 0) {
    goto switch_14_0;
  } else {
    if (regno == 1) {
      goto switch_14_1;
    } else {
      if (regno == 2) {
        goto switch_14_2;
      } else {
        if (regno == 3) {
          goto switch_14_3;
        } else {
          if (regno == 6) {
            goto switch_14_6;
          } else {
            if (regno == 7) {
              goto switch_14_7;
            } else {
              {
              goto switch_14_default;
              if (0) {
                switch_14_0: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db0": : "r" (value));
                }
                goto switch_14_break;
                switch_14_1: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db1": : "r" (value));
                }
                goto switch_14_break;
                switch_14_2: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db2": : "r" (value));
                }
                goto switch_14_break;
                switch_14_3: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db3": : "r" (value));
                }
                goto switch_14_break;
                switch_14_6: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db6": : "r" (value));
                }
                goto switch_14_break;
                switch_14_7: /* CIL Label */ 
                {
                __asm__  ("mov %0, %%db7": : "r" (value));
                }
                goto switch_14_break;
                switch_14_default: /* CIL Label */ 
                {

                }
                {
                while (1) {
                  while_15_continue: /* CIL Label */ ;
                  {
                  __asm__  volatile   ("1:\tud2\n"
                                       ".pushsection __bug_table,\"a\"\n"
                                       "2:\t.long 1b, %c0\n"
                                       "\t.word %c1, 0\n"
                                       "\t.org 2b+%c2\n"
                                       ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/processor.h"),
                                       "i" (524), "i" (sizeof(struct bug_entry )));
                  }
                  {
                  while (1) {
                    while_16_continue: /* CIL Label */ ;
                  }
                  while_16_break: /* CIL Label */ ;
                  }
                  goto while_15_break;
                }
                while_15_break: /* CIL Label */ ;
                }
              } else {
                switch_14_break: /* CIL Label */ ;
              }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
__inline static void native_set_iopl_mask(unsigned int mask ) 
{ unsigned int reg ;

  {
  {
  __asm__  volatile   ("pushfl;"
                       "popl %0;"
                       "andl %1, %0;"
                       "orl %2, %0;"
                       "pushl %0;"
                       "popfl": "=&r" (reg): "i" (~ 12288), "r" (mask));
  }
  return;
}
}
__inline static void native_load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ long tmp ;

  {
  {
  tss->x86_tss.sp0 = thread->sp0;
  tmp = __builtin_expect((long )(! (! ((unsigned long )tss->x86_tss.ss1 != thread->sysenter_cs))),
                         0L);
  }
  if (tmp) {
    {
    tss->x86_tss.ss1 = (unsigned short )thread->sysenter_cs;
    wrmsr(372U, (unsigned int )thread->sysenter_cs, 0U);
    }
  }
  return;
}
}
__inline static void native_swapgs(void) 
{ 

  {
  return;
}
}
__inline static void load_sp0(struct tss_struct *tss , struct thread_struct *thread ) 
{ 

  {
  {
  native_load_sp0(tss, thread);
  }
  return;
}
}
extern unsigned long mmu_cr4_features ;
__inline static void set_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4((unsigned long )cr4);
  }
  return;
}
}
extern int kernel_thread(int (*fn)(void * ) , void *arg , unsigned long flags ) ;
extern void release_thread(struct task_struct * ) ;
extern void prepare_to_copy(struct task_struct *tsk ) ;
extern unsigned long get_wchan(struct task_struct *p ) ;
__inline static void cpuid(unsigned int op , unsigned int *eax , unsigned int *ebx ,
                           unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
  *eax = op;
  *ecx = 0U;
  native_cpuid(eax, ebx, ecx, edx);
  }
  return;
}
}
__inline static void cpuid_count(unsigned int op , int count , unsigned int *eax ,
                                 unsigned int *ebx , unsigned int *ecx , unsigned int *edx ) 
{ 

  {
  {
  *eax = op;
  *ecx = (unsigned int )count;
  native_cpuid(eax, ebx, ecx, edx);
  }
  return;
}
}
__inline static unsigned int cpuid_eax(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (eax);
}
}
__inline static unsigned int cpuid_ebx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (ebx);
}
}
__inline static unsigned int cpuid_ecx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (ecx);
}
}
__inline static unsigned int cpuid_edx(unsigned int op ) 
{ unsigned int eax ;
  unsigned int ebx ;
  unsigned int ecx ;
  unsigned int edx ;

  {
  {
  cpuid(op, & eax, & ebx, & ecx, & edx);
  }
  return (edx);
}
}
__inline static void rep_nop(void) 
{ 

  {
  {
  __asm__  volatile   ("rep; nop": : : "memory");
  }
  return;
}
}
__inline static void cpu_relax(void) 
{ 

  {
  {
  rep_nop();
  }
  return;
}
}
__inline static void sync_core(void) 
{ int tmp ;

  {
  {
  __asm__  volatile   ("cpuid": "=a" (tmp): "0" (1): "ebx", "ecx", "edx", "memory");
  }
  return;
}
}
__inline static void __monitor(void const   *eax , unsigned long ecx , unsigned long edx ) 
{ 

  {
  {
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc8;": : "a" (eax), "c" (ecx), "d" (edx));
  }
  return;
}
}
__inline static void __mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
  __asm__  volatile   (".byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
  return;
}
}
__inline static void __sti_mwait(unsigned long eax , unsigned long ecx ) 
{ 

  {
  {
  while (1) {
    while_17_continue: /* CIL Label */ ;
    goto while_17_break;
  }
  while_17_break: /* CIL Label */ ;
  }
  {
  __asm__  volatile   ("sti; .byte 0x0f, 0x01, 0xc9;": : "a" (eax), "c" (ecx));
  }
  return;
}
}
extern void mwait_idle_with_hints(unsigned long eax , unsigned long ecx ) ;
extern void select_idle_routine(struct cpuinfo_x86  const  *c ) ;
extern void init_c1e_mask(void) ;
extern unsigned long boot_option_idle_override ;
extern unsigned long idle_halt ;
extern unsigned long idle_nomwait ;
__inline static void wbinvd_halt(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
  if (19 >> 5 == 0) {
    if ((1UL << 19) & (unsigned long )(1 | (1 << 15))) {
      {
      tmp___1 = 1;
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    if (19 >> 5 == 1) {
      goto _L___4;
    } else {
      _L___4: /* CIL Label */ 
      if (19 >> 5 == 2) {
        goto _L___3;
      } else {
        _L___3: /* CIL Label */ 
        if (19 >> 5 == 3) {
          goto _L___2;
        } else {
          _L___2: /* CIL Label */ 
          if (19 >> 5 == 4) {
            goto _L___1;
          } else {
            _L___1: /* CIL Label */ 
            if (19 >> 5 == 5) {
              goto _L___0;
            } else {
              _L___0: /* CIL Label */ 
              if (19 >> 5 == 6) {
                goto _L;
              } else {
                _L: /* CIL Label */ 
                if (19 >> 5 == 7) {
                  {
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                  tmp___1 = tmp;
                  }
                } else {
                  {
                  tmp = constant_test_bit(19U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                  tmp___1 = tmp;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (tmp___1) {
    {
    __asm__  volatile   ("cli; wbinvd; 1: hlt; jmp 1b": : : "memory");
    }
  } else {
    {
    while (1) {
      while_18_continue: /* CIL Label */ ;
      {
      halt();
      }
    }
    while_18_break: /* CIL Label */ ;
    }
  }
  return;
}
}
extern void enable_sep_cpu(void) ;
extern int sysenter_setup(void) ;
extern struct desc_ptr early_gdt_descr ;
extern void cpu_set_gdt(int  ) ;
extern void switch_to_new_gdt(int  ) ;
extern void load_percpu_segment(int  ) ;
extern void cpu_init(void) ;
__inline static unsigned long get_debugctlmsr(void) 
{ unsigned long debugctlmsr ;
  unsigned long long tmp ;

  {
  {
  debugctlmsr = 0UL;
  tmp = native_read_msr(473U);
  debugctlmsr = (unsigned long )tmp;
  }
  return (debugctlmsr);
}
}
__inline static void update_debugctlmsr(unsigned long debugctlmsr ) 
{ 

  {
  {
  native_write_msr(473U, (unsigned int )((unsigned long long )debugctlmsr), (unsigned int )((unsigned long long )debugctlmsr >> 32));
  }
  return;
}
}
extern unsigned int machine_id ;
extern unsigned int machine_submodel_id ;
extern unsigned int BIOS_revision ;
extern int bootloader_type ;
extern char ignore_fpu_irq ;
__inline static void prefetch(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchnta (%1)"
                       "\n664:\n"
                       ".previous": : "i" (25), "r" (x));
  }
  return;
}
}
__inline static void prefetchw(void const   *x ) 
{ 

  {
  {
  __asm__  volatile   ("661:\n\t"
                       ".byte 0x8d,0x74,0x26,0x00\n"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "prefetchw (%1)"
                       "\n664:\n"
                       ".previous": : "i" (63), "r" (x));
  }
  return;
}
}
__inline static void spin_lock_prefetch(void const   *x ) 
{ 

  {
  {
  prefetchw(x);
  }
  return;
}
}
extern unsigned long thread_saved_pc(struct task_struct *tsk ) ;
extern void start_thread(struct pt_regs *regs , unsigned long new_ip , unsigned long new_sp ) ;
extern int get_tsc_mode(unsigned long adr ) ;
extern int set_tsc_mode(unsigned int val ) ;
__inline static void prefetch_range(void *addr , size_t len ) 
{ char *cp ;
  char *end ;

  {
  {
  end = (char *)(addr + len);
  cp = (char *)addr;
  }
  {
  while (1) {
    while_19_continue: /* CIL Label */ ;
    if (! ((unsigned long )cp < (unsigned long )end)) {
      goto while_19_break;
    }
    {
    prefetch((void const   *)cp);
    cp += 4 * (1 << 5);
    }
  }
  while_19_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 

  {
  {
  list->next = list;
  list->prev = list;
  }
  return;
}
}
__inline static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  }
  return;
}
}
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head, head->next);
  }
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add(new, head->prev, head);
  }
  return;
}
}
__inline static void __list_del(struct list_head *prev , struct list_head *next ) 
{ 

  {
  {
  next->prev = prev;
  prev->next = next;
  }
  return;
}
}
__inline static void list_del(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->next = (struct list_head *)((void *)1048832);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static void list_replace(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
  new->next = old->next;
  (new->next)->prev = new;
  new->prev = old->prev;
  (new->prev)->next = new;
  }
  return;
}
}
__inline static void list_replace_init(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
  list_replace(old, new);
  INIT_LIST_HEAD(old);
  }
  return;
}
}
__inline static void list_del_init(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  INIT_LIST_HEAD(entry);
  }
  return;
}
}
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
  __list_del(list->prev, list->next);
  list_add(list, head);
  }
  return;
}
}
__inline static void list_move_tail(struct list_head *list , struct list_head *head ) 
{ 

  {
  {
  __list_del(list->prev, list->next);
  list_add_tail(list, head);
  }
  return;
}
}
__inline static int list_is_last(struct list_head  const  *list , struct list_head  const  *head ) 
{ 

  {
  return ((unsigned long )list->next == (unsigned long )head);
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 

  {
  return ((unsigned long )head->next == (unsigned long )head);
}
}
__inline static int list_empty_careful(struct list_head  const  *head ) 
{ struct list_head *next ;
  int tmp ;

  {
  {
  next = (struct list_head *)head->next;
  }
  if ((unsigned long )next == (unsigned long )head) {
    if ((unsigned long )next == (unsigned long )head->prev) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int list_is_singular(struct list_head  const  *head ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = list_empty(head);
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    if ((unsigned long )head->next == (unsigned long )head->prev) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static void __list_cut_position(struct list_head *list , struct list_head *head ,
                                         struct list_head *entry ) 
{ struct list_head *new_first ;

  {
  {
  new_first = entry->next;
  list->next = head->next;
  (list->next)->prev = list;
  list->prev = entry;
  entry->next = list;
  head->next = new_first;
  new_first->prev = head;
  }
  return;
}
}
__inline static void list_cut_position(struct list_head *list , struct list_head *head ,
                                       struct list_head *entry ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = list_empty((struct list_head  const  *)head);
  }
  if (tmp) {
    return;
  }
  {
  tmp___0 = list_is_singular((struct list_head  const  *)head);
  }
  if (tmp___0) {
    if ((unsigned long )head->next != (unsigned long )entry) {
      if ((unsigned long )head != (unsigned long )entry) {
        return;
      }
    }
  }
  if ((unsigned long )entry == (unsigned long )head) {
    {
    INIT_LIST_HEAD(list);
    }
  } else {
    {
    __list_cut_position(list, head, entry);
    }
  }
  return;
}
}
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ struct list_head *first ;
  struct list_head *last ;

  {
  {
  first = (struct list_head *)list->next;
  last = (struct list_head *)list->prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
  }
  return;
}
}
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty(list);
  }
  if (! tmp) {
    {
    __list_splice(list, head, head->next);
    }
  }
  return;
}
}
__inline static void list_splice_tail(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)list);
  }
  if (! tmp) {
    {
    __list_splice((struct list_head  const  *)list, head->prev, head);
    }
  }
  return;
}
}
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)list);
  }
  if (! tmp) {
    {
    __list_splice((struct list_head  const  *)list, head, head->next);
    INIT_LIST_HEAD(list);
    }
  }
  return;
}
}
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)list);
  }
  if (! tmp) {
    {
    __list_splice((struct list_head  const  *)list, head->prev, head);
    INIT_LIST_HEAD(list);
    }
  }
  return;
}
}
__inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
{ 

  {
  {
  h->next = (struct hlist_node *)((void *)0);
  h->pprev = (struct hlist_node **)((void *)0);
  }
  return;
}
}
__inline static int hlist_unhashed(struct hlist_node  const  *h ) 
{ 

  {
  return (! h->pprev);
}
}
__inline static int hlist_empty(struct hlist_head  const  *h ) 
{ 

  {
  return (! h->first);
}
}
__inline static void __hlist_del(struct hlist_node *n ) 
{ struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
  {
  next = n->next;
  pprev = n->pprev;
  *pprev = next;
  }
  if (next) {
    {
    next->pprev = pprev;
    }
  }
  return;
}
}
__inline static void hlist_del(struct hlist_node *n ) 
{ 

  {
  {
  __hlist_del(n);
  n->next = (struct hlist_node *)((void *)1048832);
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_del_init(struct hlist_node *n ) 
{ int tmp ;

  {
  {
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
  if (! tmp) {
    {
    __hlist_del(n);
    INIT_HLIST_NODE(n);
    }
  }
  return;
}
}
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
  first = h->first;
  n->next = first;
  }
  if (first) {
    {
    first->pprev = & n->next;
    }
  }
  {
  h->first = n;
  n->pprev = & h->first;
  }
  return;
}
}
__inline static void hlist_add_before(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
  n->pprev = next->pprev;
  n->next = next;
  next->pprev = & n->next;
  *(n->pprev) = n;
  }
  return;
}
}
__inline static void hlist_add_after(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
  next->next = n->next;
  n->next = next;
  next->pprev = & n->next;
  }
  if (next->next) {
    {
    (next->next)->pprev = & next->next;
    }
  }
  return;
}
}
__inline static void hlist_move_list(struct hlist_head *old , struct hlist_head *new ) 
{ 

  {
  {
  new->first = old->first;
  }
  if (new->first) {
    {
    (new->first)->pprev = & new->first;
    }
  }
  {
  old->first = (struct hlist_node *)((void *)0);
  }
  return;
}
}
extern long do_no_restart_syscall(struct restart_block *parm ) ;
__inline static void atomic_add(int i , atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (v->counter): "ir" (i));
  }
  return;
}
}
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %1,%0": "+m" (v->counter): "ir" (i));
  }
  return;
}
}
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "subl %2,%0; sete %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static void atomic_inc(atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (v->counter));
  }
  return;
}
}
__inline static void atomic_dec(atomic_t *v ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0": "+m" (v->counter));
  }
  return;
}
}
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "decl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int atomic_inc_and_test(atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0; sete %1": "+m" (v->counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int atomic_add_negative(int i , atomic_t *v ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %2,%0; sets %1": "+m" (v->counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ int __i ;

  {
  {
  __i = i;
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddl %0, %1": "+r" (i), "+m" (v->counter): : "memory");
  }
  return (i + __i);
}
}
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ int tmp ;

  {
  {
  tmp = atomic_add_return(- i, v);
  }
  return (tmp);
}
}
__inline static int atomic_add_unless(atomic_t *v , int a , int u ) 
{ int c ;
  int old ;
  long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;

  {
  {
  c = (int )v->counter;
  }
  {
  while (1) {
    while_20_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (c == u))), 0L);
    }
    if (tmp) {
      goto while_20_break;
    }
    {
    tmp___0 = __cmpxchg((void volatile   *)(& v->counter), (unsigned long )c, (unsigned long )(c + a),
                        (int )sizeof(v->counter));
    old = (int )((int volatile   )tmp___0);
    tmp___1 = __builtin_expect((long )(! (! (old == c))), 1L);
    }
    if (tmp___1) {
      goto while_20_break;
    }
    {
    c = old;
    }
  }
  while_20_break: /* CIL Label */ ;
  }
  return (c != u);
}
}
__inline static long atomic_long_read(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  }
  return ((long )v->counter);
}
}
__inline static void atomic_long_set(atomic_long_t *l , long i ) 
{ atomic_t *v ;

  {
  {
  v = l;
  v->counter = (int volatile   )i;
  }
  return;
}
}
__inline static void atomic_long_inc(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_inc(v);
  }
  return;
}
}
__inline static void atomic_long_dec(atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_dec(v);
  }
  return;
}
}
__inline static void atomic_long_add(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_add((int )i, v);
  }
  return;
}
}
__inline static void atomic_long_sub(long i , atomic_long_t *l ) 
{ atomic_t *v ;

  {
  {
  v = l;
  atomic_sub((int )i, v);
  }
  return;
}
}
__inline static int atomic_long_sub_and_test(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_sub_and_test((int )i, v);
  }
  return (tmp);
}
}
__inline static int atomic_long_dec_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_dec_and_test(v);
  }
  return (tmp);
}
}
__inline static int atomic_long_inc_and_test(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_inc_and_test(v);
  }
  return (tmp);
}
}
__inline static int atomic_long_add_negative(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_negative((int )i, v);
  }
  return (tmp);
}
}
__inline static long atomic_long_add_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_return((int )i, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_sub_return(long i , atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_sub_return((int )i, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_inc_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_return(1, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_dec_return(atomic_long_t *l ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_sub_return(1, v);
  }
  return ((long )tmp);
}
}
__inline static long atomic_long_add_unless(atomic_long_t *l , long a , long u ) 
{ atomic_t *v ;
  int tmp ;

  {
  {
  v = l;
  tmp = atomic_add_unless(v, (int )a, (int )u);
  }
  return ((long )tmp);
}
}
register unsigned long current_stack_pointer  __asm__("esp")   ;
__inline static struct thread_info *current_thread_info(void) 
{ 

  {
  return ((struct thread_info *)(current_stack_pointer & ~ (((1UL << 12) << 1) - 1UL)));
}
}
__inline static void set_restore_sigmask(void) 
{ struct thread_info *ti ;
  struct thread_info *tmp ;

  {
  {
  tmp = current_thread_info();
  ti = tmp;
  ti->status |= 8U;
  set_bit(2U, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return;
}
}
extern void arch_task_cache_init(void) ;
extern void free_thread_info(struct thread_info *ti ) ;
extern int arch_dup_task_struct(struct task_struct *dst , struct task_struct *src ) ;
__inline static void set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
  set_bit((unsigned int )flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return;
}
}
__inline static void clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 

  {
  {
  clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return;
}
}
__inline static int test_and_set_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return (tmp);
}
}
__inline static int test_and_clear_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(flag, (unsigned long volatile   *)((unsigned long *)(& ti->flags)));
  }
  return (tmp);
}
}
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
  }
  return (tmp___0);
}
}
extern void local_bh_disable(void) ;
extern void _local_bh_enable(void) ;
extern void local_bh_enable(void) ;
extern void local_bh_enable_ip(unsigned long ip ) ;
extern void early_init_irq_lock_class(void) ;
extern int generic__raw_read_trylock(raw_rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
__inline static void __ticket_spin_lock(raw_spinlock_t *lock ) 
{ short inc ;

  {
  {
  inc = (short)256;
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xaddw %w0, %1\n"
                       "1:\t"
                       "cmpb %h0, %b0\n\t"
                       "je 2f\n\t"
                       "rep ; nop\n\t"
                       "movb %1, %b0\n\t"
                       "jmp 1b\n"
                       "2:": "+Q" (inc), "+m" (lock->slock): : "memory", "cc");
  }
  return;
}
}
__inline static int __ticket_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;
  int new ;

  {
  {
  __asm__  volatile   ("movzwl %2, %0\n\t"
                       "cmpb %h0,%b0\n\t"
                       "leal 0x100(%"
                       "k"
                       "0), %1\n\t"
                       "jne 1f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "cmpxchgw %w1,%2\n\t"
                       "1:"
                       "sete %b1\n\t"
                       "movzbl %b1,%0\n\t": "=&a" (tmp), "=&q" (new), "+m" (lock->slock): : "memory",
                       "cc");
  }
  return (tmp);
}
}
__inline static void __ticket_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
  __asm__  volatile   ("incb %0": "+m" (lock->slock): : "memory", "cc");
  }
  return;
}
}
__inline static int __ticket_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
  return (! (! (((tmp >> 8) ^ tmp) & ((1 << 8) - 1))));
}
}
__inline static int __ticket_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = (int )*((unsigned int volatile   *)(& lock->slock));
  }
  return ((((tmp >> 8) - tmp) & ((1 << 8) - 1)) > 1);
}
}
__inline static int __raw_spin_is_locked(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = __ticket_spin_is_locked(lock);
  }
  return (tmp);
}
}
__inline static int __raw_spin_is_contended(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = __ticket_spin_is_contended(lock);
  }
  return (tmp);
}
}
__inline static void __raw_spin_lock(raw_spinlock_t *lock ) 
{ 

  {
  {
  __ticket_spin_lock(lock);
  }
  return;
}
}
__inline static int __raw_spin_trylock(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  tmp = __ticket_spin_trylock(lock);
  }
  return (tmp);
}
}
__inline static void __raw_spin_unlock(raw_spinlock_t *lock ) 
{ 

  {
  {
  __ticket_spin_unlock(lock);
  }
  return;
}
}
__inline static void __raw_spin_lock_flags(raw_spinlock_t *lock , unsigned long flags ) 
{ 

  {
  {
  __raw_spin_lock(lock);
  }
  return;
}
}
__inline static void __raw_spin_unlock_wait(raw_spinlock_t *lock ) 
{ int tmp ;

  {
  {
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
    tmp = __raw_spin_is_locked(lock);
    }
    if (! tmp) {
      goto while_21_break;
    }
    {
    cpu_relax();
    }
  }
  while_21_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int __raw_read_can_lock(raw_rwlock_t *lock ) 
{ 

  {
  return ((int )lock->lock > 0);
}
}
__inline static int __raw_write_can_lock(raw_rwlock_t *lock ) 
{ 

  {
  return (lock->lock == 16777216U);
}
}
__inline static void __raw_read_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl $1,(%0)\n\t"
                       "jns 1f\n"
                       "call __read_lock_failed\n\t"
                       "1:\n": : "a" (rw): "memory");
  }
  return;
}
}
__inline static void __raw_write_lock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       " subl %1,(%0)\n\t"
                       "jz 1f\n"
                       "call __write_lock_failed\n\t"
                       "1:\n": : "a" (rw), "i" (16777216): "memory");
  }
  return;
}
}
__inline static int __raw_read_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
  count = (atomic_t *)lock;
  tmp = atomic_sub_return(1, count);
  }
  if (tmp >= 0) {
    return (1);
  }
  {
  atomic_inc(count);
  }
  return (0);
}
}
__inline static int __raw_write_trylock(raw_rwlock_t *lock ) 
{ atomic_t *count ;
  int tmp ;

  {
  {
  count = (atomic_t *)lock;
  tmp = atomic_sub_and_test(16777216, count);
  }
  if (tmp) {
    return (1);
  }
  {
  atomic_add(16777216, count);
  }
  return (0);
}
}
__inline static void __raw_read_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "incl %0": "+m" (rw->lock): : "memory");
  }
  return;
}
}
__inline static void __raw_write_unlock(raw_rwlock_t *rw ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1, %0": "+m" (rw->lock): "i" (16777216): "memory");
  }
  return;
}
}
extern int in_lock_functions(unsigned long addr ) ;
extern void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_nest_lock(spinlock_t *lock , struct lockdep_map *map )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_lock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_lock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_lock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _spin_lock_irqsave(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _spin_lock_irqsave_nested(spinlock_t *lock , int subclass )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _read_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern unsigned long _write_lock_irqsave(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _spin_trylock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _read_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _write_trylock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern int _spin_trylock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock_bh(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock_bh(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock_irq(rwlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
extern void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void _read_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern void _write_unlock_irqrestore(rwlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
extern int _atomic_dec_and_lock(atomic_t *atomic , spinlock_t *lock ) ;
extern int default_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                 void *key ) ;
extern void init_waitqueue_head(wait_queue_head_t *q ) ;
__inline static void init_waitqueue_entry(wait_queue_t *q , struct task_struct *p ) 
{ 

  {
  {
  q->flags = 0U;
  q->private = (void *)p;
  q->func = & default_wake_function;
  }
  return;
}
}
__inline static void init_waitqueue_func_entry(wait_queue_t *q , int (*func)(wait_queue_t *wait ,
                                                                             unsigned int mode ,
                                                                             int sync ,
                                                                             void *key ) ) 
{ 

  {
  {
  q->flags = 0U;
  q->private = (void *)0;
  q->func = func;
  }
  return;
}
}
__inline static int waitqueue_active(wait_queue_head_t *q ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  return (tmp___0);
}
}
extern void add_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
extern void add_wait_queue_exclusive(wait_queue_head_t *q , wait_queue_t *wait ) ;
extern void remove_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
__inline static void __add_wait_queue(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
  list_add(& new->task_list, & head->task_list);
  }
  return;
}
}
__inline static void __add_wait_queue_tail(wait_queue_head_t *head , wait_queue_t *new ) 
{ 

  {
  {
  list_add_tail(& new->task_list, & head->task_list);
  }
  return;
}
}
__inline static void __remove_wait_queue(wait_queue_head_t *head , wait_queue_t *old ) 
{ 

  {
  {
  list_del(& old->task_list);
  }
  return;
}
}
extern void __wake_up_common(wait_queue_head_t *q , unsigned int mode , int nr_exclusive ,
                             int sync , void *key ) ;
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
extern void __wake_up_locked_key(wait_queue_head_t *q , unsigned int mode , void *key ) ;
extern void __wake_up_sync_key(wait_queue_head_t *q , unsigned int mode , int nr ,
                               void *key ) ;
extern void __wake_up_locked(wait_queue_head_t *q , unsigned int mode ) ;
extern void __wake_up_sync(wait_queue_head_t *q , unsigned int mode , int nr ) ;
extern void __wake_up_bit(wait_queue_head_t * , void * , int  ) ;
extern int __wait_on_bit(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                         unsigned int  ) ;
extern int __wait_on_bit_lock(wait_queue_head_t * , struct wait_bit_queue * , int (*)(void * ) ,
                              unsigned int  ) ;
extern void wake_up_bit(void * , int  ) ;
extern int out_of_line_wait_on_bit(void * , int  , int (*)(void * ) , unsigned int  ) ;
extern int out_of_line_wait_on_bit_lock(void * , int  , int (*)(void * ) , unsigned int  ) ;
extern wait_queue_head_t *bit_waitqueue(void * , int  ) ;
__inline static void add_wait_queue_exclusive_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
  wait->flags |= 1U;
  __add_wait_queue_tail(q, wait);
  }
  return;
}
}
__inline static void remove_wait_queue_locked(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 

  {
  {
  __remove_wait_queue(q, wait);
  }
  return;
}
}
extern void sleep_on(wait_queue_head_t *q ) ;
extern long sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
extern void interruptible_sleep_on(wait_queue_head_t *q ) ;
extern long interruptible_sleep_on_timeout(wait_queue_head_t *q , long timeout ) ;
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
extern void prepare_to_wait_exclusive(wait_queue_head_t *q , wait_queue_t *wait ,
                                      int state ) ;
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
extern void abort_exclusive_wait(wait_queue_head_t *q , wait_queue_t *wait , unsigned int mode ,
                                 void *key ) ;
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
extern int wake_bit_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
__inline static int wait_on_bit(void *word , int bit , int (*action)(void * ) , unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)word);
  }
  if (! tmp___0) {
    return (0);
  }
  {
  tmp___1 = out_of_line_wait_on_bit(word, bit, action, mode);
  }
  return (tmp___1);
}
}
__inline static int wait_on_bit_lock(void *word , int bit , int (*action)(void * ) ,
                                     unsigned int mode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = test_and_set_bit(bit, (unsigned long volatile   *)word);
  }
  if (! tmp) {
    return (0);
  }
  {
  tmp___0 = out_of_line_wait_on_bit_lock(word, bit, action, mode);
  }
  return (tmp___0);
}
}
__inline static void init_completion(struct completion *x ) 
{ 

  {
  {
  x->done = 0U;
  init_waitqueue_head(& x->wait);
  }
  return;
}
}
extern void wait_for_completion(struct completion * ) ;
extern int wait_for_completion_interruptible(struct completion *x ) ;
extern int wait_for_completion_killable(struct completion *x ) ;
extern unsigned long wait_for_completion_timeout(struct completion *x , unsigned long timeout ) ;
extern unsigned long wait_for_completion_interruptible_timeout(struct completion *x ,
                                                               unsigned long timeout ) ;
extern bool try_wait_for_completion(struct completion *x ) ;
extern bool completion_done(struct completion *x ) ;
extern void complete(struct completion * ) ;
extern void complete_all(struct completion * ) ;
extern u16 const   crc_itu_t_table[256] ;
extern u16 crc_itu_t(u16 crc , u8 const   *buffer , size_t len ) ;
__inline static u16 crc_itu_t_byte(u16 crc , u8 data ) 
{ 

  {
  return ((unsigned short )(((int )crc << 8) ^ (int )crc_itu_t_table[(((int )crc >> 8) ^ (int )data) & 255]));
}
}
extern unsigned long loops_per_jiffy ;
extern void __bad_udelay(void) ;
extern void __bad_ndelay(void) ;
extern void __udelay(unsigned long usecs ) ;
extern void __ndelay(unsigned long nsecs ) ;
extern void __const_udelay(unsigned long xloops ) ;
extern void __delay(unsigned long loops ) ;
extern void use_tsc_delay(void) ;
extern unsigned long lpj_fine ;
extern void calibrate_delay(void) ;
extern void msleep(unsigned int msecs ) ;
extern unsigned long msleep_interruptible(unsigned int msecs ) ;
__inline static void ssleep(unsigned int seconds ) 
{ 

  {
  {
  msleep(seconds * 1000U);
  }
  return;
}
}
extern struct resource ioport_resource ;
extern struct resource iomem_resource ;
extern int request_resource(struct resource *root , struct resource *new ) ;
extern int release_resource(struct resource *new ) ;
extern void reserve_region_with_split(struct resource *root , resource_size_t start ,
                                      resource_size_t end , char const   *name ) ;
extern int insert_resource(struct resource *parent , struct resource *new ) ;
extern void insert_resource_expand_to_fit(struct resource *root , struct resource *new ) ;
extern int allocate_resource(struct resource *root , struct resource *new , resource_size_t size ,
                             resource_size_t min , resource_size_t max , resource_size_t align ,
                             void (*alignf)(void * , struct resource * , resource_size_t  ,
                                            resource_size_t  ) , void *alignf_data ) ;
extern int adjust_resource(struct resource *res , resource_size_t start , resource_size_t size ) ;
extern resource_size_t resource_alignment(struct resource *res ) ;
__inline static resource_size_t resource_size(struct resource *res ) 
{ 

  {
  return ((res->end - res->start) + 1U);
}
}
__inline static unsigned long resource_type(struct resource *res ) 
{ 

  {
  return (res->flags & 3840UL);
}
}
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
extern int __check_region(struct resource * , resource_size_t  , resource_size_t  ) ;
extern void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
__inline static int check_region(resource_size_t s , resource_size_t n ) 
{ int tmp ;

  {
  {
  tmp = __check_region(& ioport_resource, s, n);
  }
  return (tmp);
}
}
extern struct resource *__devm_request_region(struct device *dev , struct resource *parent ,
                                              resource_size_t start , resource_size_t n ,
                                              char const   *name ) ;
extern void __devm_release_region(struct device *dev , struct resource *parent , resource_size_t start ,
                                  resource_size_t n ) ;
extern int iomem_map_sanity_check(resource_size_t addr , unsigned long size ) ;
extern int iomem_is_exclusive(u64 addr ) ;
extern int sysfs_schedule_callback(struct kobject *kobj , void (*func)(void * ) ,
                                   void *data , struct module *owner ) ;
extern int sysfs_create_dir(struct kobject *kobj ) ;
extern void sysfs_remove_dir(struct kobject *kobj ) ;
extern int sysfs_rename_dir(struct kobject *kobj , char const   *new_name ) ;
extern int sysfs_move_dir(struct kobject *kobj , struct kobject *new_parent_kobj ) ;
extern int sysfs_create_file(struct kobject *kobj , struct attribute  const  *attr ) ;
extern int sysfs_chmod_file(struct kobject *kobj , struct attribute *attr , mode_t mode ) ;
extern void sysfs_remove_file(struct kobject *kobj , struct attribute  const  *attr ) ;
extern int sysfs_create_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern void sysfs_remove_bin_file(struct kobject *kobj , struct bin_attribute *attr ) ;
extern int sysfs_create_link(struct kobject *kobj , struct kobject *target , char const   *name ) ;
extern int sysfs_create_link_nowarn(struct kobject *kobj , struct kobject *target ,
                                    char const   *name ) ;
extern void sysfs_remove_link(struct kobject *kobj , char const   *name ) ;
extern int sysfs_create_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern int sysfs_update_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern void sysfs_remove_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
extern int sysfs_add_file_to_group(struct kobject *kobj , struct attribute  const  *attr ,
                                   char const   *group ) ;
extern void sysfs_remove_file_from_group(struct kobject *kobj , struct attribute  const  *attr ,
                                         char const   *group ) ;
extern void sysfs_notify(struct kobject *kobj , char const   *dir , char const   *attr ) ;
extern void sysfs_notify_dirent(struct sysfs_dirent *sd ) ;
extern struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd , unsigned char const   *name ) ;
extern struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd ) ;
extern void sysfs_put(struct sysfs_dirent *sd ) ;
extern void sysfs_printk_last_file(void) ;
extern int sysfs_init(void) ;
extern void kref_set(struct kref *kref , int num ) ;
extern void kref_init(struct kref *kref ) ;
extern void kref_get(struct kref *kref ) ;
extern int kref_put(struct kref *kref , void (*release)(struct kref *kref ) ) ;
extern char uevent_helper[] ;
extern u64 uevent_seqnum ;
extern int ( /* format attribute */  kobject_set_name)(struct kobject *kobj , char const   *name 
                                                       , ...) ;
extern int kobject_set_name_vargs(struct kobject *kobj , char const   *fmt , va_list vargs ) ;
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 

  {
  return ((char const   *)kobj->name);
}
}
extern void kobject_init(struct kobject *kobj , struct kobj_type *ktype ) ;
extern int kobject_add(struct kobject *kobj , struct kobject *parent , char const   *fmt 
                       , ...) ;
extern int kobject_init_and_add(struct kobject *kobj , struct kobj_type *ktype , struct kobject *parent ,
                                char const   *fmt  , ...) ;
extern void kobject_del(struct kobject *kobj ) ;
extern struct kobject *kobject_create(void) ;
extern struct kobject *kobject_create_and_add(char const   *name , struct kobject *parent ) ;
extern int kobject_rename(struct kobject * , char const   *new_name ) ;
extern int kobject_move(struct kobject * , struct kobject * ) ;
extern struct kobject *kobject_get(struct kobject *kobj ) ;
extern void kobject_put(struct kobject *kobj ) ;
extern char *kobject_get_path(struct kobject *kobj , gfp_t flag ) ;
extern struct sysfs_ops kobj_sysfs_ops ;
extern void kset_init(struct kset *kset ) ;
extern int kset_register(struct kset *kset ) ;
extern void kset_unregister(struct kset *kset ) ;
extern struct kset *kset_create_and_add(char const   *name , struct kset_uevent_ops *u ,
                                        struct kobject *parent_kobj ) ;
__inline static struct kset *to_kset(struct kobject *kobj ) 
{ struct kobject  const  *__mptr ;
  struct kset *tmp ;

  {
  if (kobj) {
    {
    __mptr = (struct kobject  const  *)kobj;
    tmp = (struct kset *)((char *)__mptr - (unsigned int )(& ((struct kset *)0)->kobj));
    }
  } else {
    {
    tmp = (struct kset *)((void *)0);
    }
  }
  return (tmp);
}
}
__inline static struct kset *kset_get(struct kset *k ) 
{ struct kobject *tmp ;
  struct kset *tmp___0 ;
  struct kset *tmp___1 ;

  {
  if (k) {
    {
    tmp = kobject_get(& k->kobj);
    tmp___0 = to_kset(tmp);
    tmp___1 = tmp___0;
    }
  } else {
    {
    tmp___1 = (struct kset *)((void *)0);
    }
  }
  return (tmp___1);
}
}
__inline static void kset_put(struct kset *k ) 
{ 

  {
  {
  kobject_put(& k->kobj);
  }
  return;
}
}
__inline static struct kobj_type *get_ktype(struct kobject *kobj ) 
{ 

  {
  return (kobj->ktype);
}
}
extern struct kobject *kset_find_obj(struct kset * , char const   * ) ;
extern struct kobject *kernel_kobj ;
extern struct kobject *mm_kobj ;
extern struct kobject *hypervisor_kobj ;
extern struct kobject *power_kobj ;
extern struct kobject *firmware_kobj ;
extern int kobject_uevent(struct kobject *kobj , enum kobject_action action ) ;
extern int kobject_uevent_env(struct kobject *kobj , enum kobject_action action ,
                              char **envp ) ;
extern int ( /* format attribute */  add_uevent_var)(struct kobj_uevent_env *env ,
                                                     char const   *format  , ...) ;
extern int kobject_action_type(char const   *buf , size_t count , enum kobject_action *type ) ;
extern void klist_init(struct klist *k , void (*get)(struct klist_node * ) , void (*put)(struct klist_node * ) ) ;
extern void klist_add_tail(struct klist_node *n , struct klist *k ) ;
extern void klist_add_head(struct klist_node *n , struct klist *k ) ;
extern void klist_add_after(struct klist_node *n , struct klist_node *pos ) ;
extern void klist_add_before(struct klist_node *n , struct klist_node *pos ) ;
extern void klist_del(struct klist_node *n ) ;
extern void klist_remove(struct klist_node *n ) ;
extern int klist_node_attached(struct klist_node *n ) ;
extern void klist_iter_init(struct klist *k , struct klist_iter *i ) ;
extern void klist_iter_init_node(struct klist *k , struct klist_iter *i , struct klist_node *n ) ;
extern void klist_iter_exit(struct klist_iter *i ) ;
extern struct klist_node *klist_next(struct klist_iter *i ) ;
__inline static void write_seqlock(seqlock_t *sl ) 
{ 

  {
  {
  _spin_lock(& sl->lock);
  (sl->sequence) ++;
  __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
__inline static void write_sequnlock(seqlock_t *sl ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  (sl->sequence) ++;
  }
  {
  while (1) {
    while_22_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& sl->lock.raw_lock);
    }
    goto while_22_break;
  }
  while_22_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int write_tryseqlock(seqlock_t *sl ) 
{ int ret ;
  int tmp ;

  {
  {
  tmp = _spin_trylock(& sl->lock);
  ret = tmp;
  }
  if (ret) {
    {
    (sl->sequence) ++;
    __asm__  volatile   ("": : : "memory");
    }
  }
  return (ret);
}
}
__inline static unsigned int read_seqbegin(seqlock_t const   *sl ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
  ret = (unsigned int )sl->sequence;
  __asm__  volatile   ("": : : "memory");
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
  if (tmp) {
    {
    cpu_relax();
    }
    goto repeat;
  }
  return (ret);
}
}
__inline static int read_seqretry(seqlock_t const   *sl , unsigned int start ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  }
  return (sl->sequence != (unsigned int const   )start);
}
}
__inline static unsigned int read_seqcount_begin(seqcount_t const   *s ) 
{ unsigned int ret ;
  long tmp ;

  {
  repeat: 
  {
  ret = (unsigned int )s->sequence;
  __asm__  volatile   ("": : : "memory");
  tmp = __builtin_expect((long )(! (! (ret & 1U))), 0L);
  }
  if (tmp) {
    {
    cpu_relax();
    }
    goto repeat;
  }
  return (ret);
}
}
__inline static int read_seqcount_retry(seqcount_t const   *s , unsigned int start ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  }
  return (s->sequence != (unsigned int const   )start);
}
}
__inline static void write_seqcount_begin(seqcount_t *s ) 
{ 

  {
  {
  (s->sequence) ++;
  __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
__inline static void write_seqcount_end(seqcount_t *s ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  (s->sequence) ++;
  }
  return;
}
}
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
extern s64 div_s64_rem(s64 dividend , s32 divisor , s32 *remainder ) ;
extern u64 div64_u64(u64 dividend , u64 divisor ) ;
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static s64 div_s64(s64 dividend , s32 divisor ) 
{ s32 remainder ;
  s64 tmp ;

  {
  {
  tmp = div_s64_rem(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
extern u32 iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) ;
__inline static u32 __iter_div_u64_rem(u64 dividend , u32 divisor , u64 *remainder ) 
{ u32 ret ;

  {
  {
  ret = (u32 )0;
  }
  {
  while (1) {
    while_23_continue: /* CIL Label */ ;
    if (! (dividend >= (u64 )divisor)) {
      goto while_23_break;
    }
    {
    __asm__  ("": "+rm" (dividend));
    dividend -= (u64 )divisor;
    ret ++;
    }
  }
  while_23_break: /* CIL Label */ ;
  }
  {
  *remainder = dividend;
  }
  return (ret);
}
}
extern struct timezone sys_tz ;
__inline static int timespec_equal(struct timespec  const  *a , struct timespec  const  *b ) 
{ int tmp ;

  {
  if (a->tv_sec == b->tv_sec) {
    if (a->tv_nsec == b->tv_nsec) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int timespec_compare(struct timespec  const  *lhs , struct timespec  const  *rhs ) 
{ 

  {
  if (lhs->tv_sec < rhs->tv_sec) {
    return (-1);
  }
  if (lhs->tv_sec > rhs->tv_sec) {
    return (1);
  }
  return ((int )(lhs->tv_nsec - rhs->tv_nsec));
}
}
__inline static int timeval_compare(struct timeval  const  *lhs , struct timeval  const  *rhs ) 
{ 

  {
  if (lhs->tv_sec < rhs->tv_sec) {
    return (-1);
  }
  if (lhs->tv_sec > rhs->tv_sec) {
    return (1);
  }
  return ((int )(lhs->tv_usec - rhs->tv_usec));
}
}
extern unsigned long mktime(unsigned int year , unsigned int mon , unsigned int day ,
                            unsigned int hour , unsigned int min , unsigned int sec ) ;
extern void set_normalized_timespec(struct timespec *ts , time_t sec , long nsec ) ;
extern struct timespec timespec_add_safe(struct timespec lhs , struct timespec rhs ) ;
__inline static struct timespec timespec_sub(struct timespec lhs , struct timespec rhs ) 
{ struct timespec ts_delta ;

  {
  {
  set_normalized_timespec(& ts_delta, lhs.tv_sec - rhs.tv_sec, lhs.tv_nsec - rhs.tv_nsec);
  }
  return (ts_delta);
}
}
extern struct timespec xtime ;
extern struct timespec wall_to_monotonic ;
extern seqlock_t xtime_lock ;
extern unsigned long read_persistent_clock(void) ;
extern int update_persistent_clock(struct timespec now ) ;
extern int no_sync_cmos_clock  __attribute__((__section__(".data.read_mostly"))) ;
extern void timekeeping_init(void) ;
extern int timekeeping_suspended ;
extern unsigned long get_seconds(void) ;
extern struct timespec current_kernel_time(void) ;
extern void do_gettimeofday(struct timeval *tv ) ;
extern int do_settimeofday(struct timespec *tv ) ;
extern int do_sys_settimeofday(struct timespec *tv , struct timezone *tz ) ;
extern long do_utimes(int dfd , char *filename , struct timespec *times , int flags ) ;
extern int do_setitimer(int which , struct itimerval *value , struct itimerval *ovalue ) ;
extern unsigned int alarm_setitimer(unsigned int seconds ) ;
extern int do_getitimer(int which , struct itimerval *value ) ;
extern void getnstimeofday(struct timespec *tv ) ;
extern void getrawmonotonic(struct timespec *ts ) ;
extern void getboottime(struct timespec *ts ) ;
extern void monotonic_to_bootbased(struct timespec *ts ) ;
extern struct timespec timespec_trunc(struct timespec t , unsigned int gran ) ;
extern int timekeeping_valid_for_hres(void) ;
extern void update_wall_time(void) ;
extern void update_xtime_cache(u64 nsec ) ;
extern void do_sys_times(struct tms * ) ;
__inline static s64 timespec_to_ns(struct timespec  const  *ts ) 
{ 

  {
  return ((long long )ts->tv_sec * 1000000000LL + (long long )ts->tv_nsec);
}
}
__inline static s64 timeval_to_ns(struct timeval  const  *tv ) 
{ 

  {
  return ((long long )tv->tv_sec * 1000000000LL + (long long )(tv->tv_usec * 1000L));
}
}
extern struct timespec ns_to_timespec(s64 nsec ) ;
extern struct timeval ns_to_timeval(s64 nsec ) ;
__inline static void timespec_add_ns(struct timespec *a , u64 ns ) 
{ u32 tmp ;

  {
  {
  tmp = __iter_div_u64_rem((u64 )a->tv_nsec + ns, 1000000000U, & ns);
  a->tv_sec += (__kernel_time_t )tmp;
  a->tv_nsec = (long )ns;
  }
  return;
}
}
extern nodemask_t _unused_nodemask_arg_ ;
__inline static void __node_set(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
  set_bit((unsigned int )node, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __node_clear(int node , nodemask_t volatile   *dstp ) 
{ 

  {
  {
  clear_bit(node, (unsigned long volatile   *)(dstp->bits));
  }
  return;
}
}
__inline static void __nodes_setall(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_fill(dstp->bits, nbits);
  }
  return;
}
}
__inline static void __nodes_clear(nodemask_t *dstp , int nbits ) 
{ 

  {
  {
  bitmap_zero(dstp->bits, nbits);
  }
  return;
}
}
__inline static int __node_test_and_set(int node , nodemask_t *addr ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(node, (unsigned long volatile   *)(addr->bits));
  }
  return (tmp);
}
}
__inline static void __nodes_and(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_and(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __nodes_or(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                int nbits ) 
{ 

  {
  {
  bitmap_or(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
            nbits);
  }
  return;
}
}
__inline static void __nodes_xor(nodemask_t *dstp , nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                 int nbits ) 
{ 

  {
  {
  bitmap_xor(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
             nbits);
  }
  return;
}
}
__inline static void __nodes_andnot(nodemask_t *dstp , nodemask_t const   *src1p ,
                                    nodemask_t const   *src2p , int nbits ) 
{ 

  {
  {
  bitmap_andnot(dstp->bits, (unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                nbits);
  }
  return;
}
}
__inline static void __nodes_complement(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int nbits ) 
{ 

  {
  {
  bitmap_complement(dstp->bits, (unsigned long const   *)(srcp->bits), nbits);
  }
  return;
}
}
__inline static int __nodes_equal(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                  int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_equal((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                     nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_intersects(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                       int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_intersects((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                          nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_subset(nodemask_t const   *src1p , nodemask_t const   *src2p ,
                                   int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_subset((unsigned long const   *)(src1p->bits), (unsigned long const   *)(src2p->bits),
                      nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_empty(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_empty((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_full(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_full((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static int __nodes_weight(nodemask_t const   *srcp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_weight((unsigned long const   *)(srcp->bits), nbits);
  }
  return (tmp);
}
}
__inline static void __nodes_shift_right(nodemask_t *dstp , nodemask_t const   *srcp ,
                                         int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_right(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static void __nodes_shift_left(nodemask_t *dstp , nodemask_t const   *srcp ,
                                        int n , int nbits ) 
{ 

  {
  {
  bitmap_shift_left(dstp->bits, (unsigned long const   *)(srcp->bits), n, nbits);
  }
  return;
}
}
__inline static int __first_node(nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  __min1 = 1;
  tmp = find_first_bit((unsigned long const   *)(srcp->bits), 1UL);
  __min2 = (int )tmp;
  }
  if (__min1 < __min2) {
    {
    tmp___0 = __min1;
    }
  } else {
    {
    tmp___0 = __min2;
    }
  }
  return (tmp___0);
}
}
__inline static int __next_node(int n , nodemask_t const   *srcp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  __min1 = 1;
  tmp = find_next_bit((unsigned long const   *)(srcp->bits), 1UL, (unsigned long )(n + 1));
  __min2 = (int )tmp;
  }
  if (__min1 < __min2) {
    {
    tmp___0 = __min1;
    }
  } else {
    {
    tmp___0 = __min2;
    }
  }
  return (tmp___0);
}
}
__inline static int __first_unset_node(nodemask_t const   *maskp ) 
{ int __min1 ;
  int __min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  {
  __min1 = 1;
  tmp = find_first_zero_bit((unsigned long const   *)(maskp->bits), 1UL);
  __min2 = (int )tmp;
  }
  if (__min1 < __min2) {
    {
    tmp___0 = __min1;
    }
  } else {
    {
    tmp___0 = __min2;
    }
  }
  return (tmp___0);
}
}
__inline static int __nodemask_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                         nbits);
  }
  return (tmp);
}
}
__inline static int __nodemask_parse_user(char const   *buf , int len , nodemask_t *dstp ,
                                          int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parse_user(buf, (unsigned int )len, dstp->bits, nbits);
  }
  return (tmp);
}
}
__inline static int __nodelist_scnprintf(char *buf , int len , nodemask_t const   *srcp ,
                                         int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_scnlistprintf(buf, (unsigned int )len, (unsigned long const   *)(srcp->bits),
                             nbits);
  }
  return (tmp);
}
}
__inline static int __nodelist_parse(char const   *buf , nodemask_t *dstp , int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_parselist(buf, dstp->bits, nbits);
  }
  return (tmp);
}
}
__inline static int __node_remap(int oldbit , nodemask_t const   *oldp , nodemask_t const   *newp ,
                                 int nbits ) 
{ int tmp ;

  {
  {
  tmp = bitmap_bitremap(oldbit, (unsigned long const   *)(oldp->bits), (unsigned long const   *)(newp->bits),
                        nbits);
  }
  return (tmp);
}
}
__inline static void __nodes_remap(nodemask_t *dstp , nodemask_t const   *srcp , nodemask_t const   *oldp ,
                                   nodemask_t const   *newp , int nbits ) 
{ 

  {
  {
  bitmap_remap(dstp->bits, (unsigned long const   *)(srcp->bits), (unsigned long const   *)(oldp->bits),
               (unsigned long const   *)(newp->bits), nbits);
  }
  return;
}
}
__inline static void __nodes_onto(nodemask_t *dstp , nodemask_t const   *origp , nodemask_t const   *relmapp ,
                                  int nbits ) 
{ 

  {
  {
  bitmap_onto(dstp->bits, (unsigned long const   *)(origp->bits), (unsigned long const   *)(relmapp->bits),
              nbits);
  }
  return;
}
}
__inline static void __nodes_fold(nodemask_t *dstp , nodemask_t const   *origp , int sz ,
                                  int nbits ) 
{ 

  {
  {
  bitmap_fold(dstp->bits, (unsigned long const   *)(origp->bits), sz, nbits);
  }
  return;
}
}
extern nodemask_t node_states[5] ;
__inline static int node_state(int node , enum node_states state ) 
{ 

  {
  return (node == 0);
}
}
__inline static void node_set_state(int node , enum node_states state ) 
{ 

  {
  return;
}
}
__inline static int num_node_state(enum node_states state ) 
{ 

  {
  return (1);
}
}
extern unsigned long get_pageblock_flags_group(struct page *page , int start_bitidx ,
                                               int end_bitidx ) ;
extern void set_pageblock_flags_group(struct page *page , unsigned long flags , int start_bitidx ,
                                      int end_bitidx ) ;
extern int page_group_by_mobility_disabled ;
__inline static int get_pageblock_migratetype(struct page *page ) 
{ long tmp ;
  unsigned long tmp___0 ;

  {
  {
  tmp = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
  if (tmp) {
    return (0);
  }
  {
  tmp___0 = get_pageblock_flags_group(page, 0, 2);
  }
  return ((int )tmp___0);
}
}
__inline static int is_file_lru(enum lru_list l ) 
{ int tmp ;

  {
  if ((unsigned int )l == 2U) {
    {
    tmp = 1;
    }
  } else {
    if ((unsigned int )l == 3U) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
__inline static int is_active_lru(enum lru_list l ) 
{ int tmp ;

  {
  if ((unsigned int )l == 1U) {
    {
    tmp = 1;
    }
  } else {
    if ((unsigned int )l == 3U) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
__inline static int is_unevictable_lru(enum lru_list l ) 
{ 

  {
  return ((unsigned int )l == 4U);
}
}
__inline static void zone_set_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
  set_bit((unsigned int )flag, (unsigned long volatile   *)(& zone->flags));
  }
  return;
}
}
__inline static int zone_test_and_set_flag(struct zone *zone , zone_flags_t flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
__inline static void zone_clear_flag(struct zone *zone , zone_flags_t flag ) 
{ 

  {
  {
  clear_bit((int )flag, (unsigned long volatile   *)(& zone->flags));
  }
  return;
}
}
__inline static int zone_is_all_unreclaimable(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
__inline static int zone_is_reclaim_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
__inline static int zone_is_oom_locked(struct zone  const  *zone ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& zone->flags));
  }
  return (tmp);
}
}
extern struct page *mem_map ;
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
__inline static int mutex_is_locked(struct mutex *lock ) 
{ 

  {
  return (lock->count.counter != (int volatile   )1);
}
}
extern void mutex_lock(struct mutex *lock ) ;
extern int mutex_lock_interruptible(struct mutex *lock ) ;
extern int mutex_lock_killable(struct mutex *lock ) ;
extern int mutex_trylock(struct mutex *lock ) ;
extern void mutex_unlock(struct mutex *lock ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_read_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_down_write_failed)(struct rw_semaphore *sem ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_wake)(struct rw_semaphore * ) ;
extern struct rw_semaphore *( __attribute__((__regparm__(3))) rwsem_downgrade_wake)(struct rw_semaphore *sem ) ;
extern void __init_rwsem(struct rw_semaphore *sem , char const   *name , struct lock_class_key *key ) ;
__inline static void __down_read(struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   ("# beginning down_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  incl      (%%eax)\n\t"
                       "  jns        1f\n"
                       "  call call_rwsem_down_read_failed\n"
                       "1:\n\t"
                       "# ending down_read\n\t": "+m" (sem->count): "a" (sem): "memory",
                       "cc");
  }
  return;
}
}
__inline static int __down_read_trylock(struct rw_semaphore *sem ) 
{ __s32 result ;
  __s32 tmp ;
  int tmp___0 ;

  {
  {
  __asm__  volatile   ("# beginning __down_read_trylock\n\t"
                       "  movl      %0,%1\n\t"
                       "1:\n\t"
                       "  movl\t     %1,%2\n\t"
                       "  addl      %3,%2\n\t"
                       "  jle\t     2f\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  cmpxchgl  %2,%0\n\t"
                       "  jnz\t     1b\n\t"
                       "2:\n\t"
                       "# ending __down_read_trylock\n\t": "+m" (sem->count), "=&a" (result),
                       "=&r" (tmp): "i" (1): "memory", "cc");
  }
  if (result >= 0) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
__inline static void __down_write_nested(struct rw_semaphore *sem , int subclass ) 
{ int tmp ;

  {
  {
  tmp = -65535;
  __asm__  volatile   ("# beginning down_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  testl     %%edx,%%edx\n\t"
                       "  jz        1f\n"
                       "  call call_rwsem_down_write_failed\n"
                       "1:\n"
                       "# ending down_write": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
  return;
}
}
__inline static void __down_write(struct rw_semaphore *sem ) 
{ 

  {
  {
  __down_write_nested(sem, 0);
  }
  return;
}
}
__inline static int __down_write_trylock(struct rw_semaphore *sem ) 
{ long ret ;
  unsigned long tmp ;

  {
  {
  tmp = __cmpxchg((void volatile   *)(& sem->count), 0UL, 0xffff0001UL, (int )sizeof(sem->count));
  ret = (long )tmp;
  }
  if (ret == 0L) {
    return (1);
  }
  return (0);
}
}
__inline static void __up_read(struct rw_semaphore *sem ) 
{ __s32 tmp ;

  {
  {
  tmp = -1;
  __asm__  volatile   ("# beginning __up_read\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xadd      %%edx,(%%eax)\n\t"
                       "  jns        1f\n\t"
                       "  call call_rwsem_wake\n"
                       "1:\n"
                       "# ending __up_read\n": "+m" (sem->count), "=d" (tmp): "a" (sem),
                       "1" (tmp): "memory", "cc");
  }
  return;
}
}
__inline static void __up_write(struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   ("# beginning __up_write\n\t"
                       "  movl      %2,%%edx\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  xaddl     %%edx,(%%eax)\n\t"
                       "  jz       1f\n"
                       "  call call_rwsem_wake\n"
                       "1:\n\t"
                       "# ending __up_write\n": "+m" (sem->count): "a" (sem), "i" (65535): "memory",
                       "cc", "edx");
  }
  return;
}
}
__inline static void __downgrade_write(struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   ("# beginning __downgrade_write\n\t"
                       ".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "  addl      %2,(%%eax)\n\t"
                       "  jns       1f\n\t"
                       "  call call_rwsem_downgrade_wake\n"
                       "1:\n\t"
                       "# ending __downgrade_write\n": "+m" (sem->count): "a" (sem),
                       "i" (65536): "memory", "cc");
  }
  return;
}
}
__inline static void rwsem_atomic_add(int delta , struct rw_semaphore *sem ) 
{ 

  {
  {
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "addl %1,%0": "+m" (sem->count): "ir" (delta));
  }
  return;
}
}
__inline static int rwsem_atomic_update(int delta , struct rw_semaphore *sem ) 
{ int tmp ;

  {
  {
  tmp = delta;
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "xadd %0,%1": "+r" (tmp), "+m" (sem->count): : "memory");
  }
  return (tmp + delta);
}
}
__inline static int rwsem_is_locked(struct rw_semaphore *sem ) 
{ 

  {
  return (sem->count != 0L);
}
}
extern void down_read(struct rw_semaphore *sem ) ;
extern int down_read_trylock(struct rw_semaphore *sem ) ;
extern void down_write(struct rw_semaphore *sem ) ;
extern int down_write_trylock(struct rw_semaphore *sem ) ;
extern void up_read(struct rw_semaphore *sem ) ;
extern void up_write(struct rw_semaphore *sem ) ;
extern void downgrade_write(struct rw_semaphore *sem ) ;
extern int init_srcu_struct(struct srcu_struct *sp ) ;
extern void cleanup_srcu_struct(struct srcu_struct *sp ) ;
extern int srcu_read_lock(struct srcu_struct *sp ) ;
extern void srcu_read_unlock(struct srcu_struct *sp , int idx ) ;
extern void synchronize_srcu(struct srcu_struct *sp ) ;
extern long srcu_batches_completed(struct srcu_struct *sp ) ;
extern void srcu_init_notifier_head(struct srcu_notifier_head *nh ) ;
extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh , struct notifier_block *nb ) ;
extern int raw_notifier_chain_register(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
extern int blocking_notifier_chain_cond_register(struct blocking_notifier_head *nh ,
                                                 struct notifier_block *nb ) ;
extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh , struct notifier_block *nb ) ;
extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh ,
                                              struct notifier_block *nb ) ;
extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh , struct notifier_block *nb ) ;
extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh , struct notifier_block *nb ) ;
extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                      void *v ) ;
extern int __atomic_notifier_call_chain(struct atomic_notifier_head *nh , unsigned long val ,
                                        void *v , int nr_to_call , int *nr_calls ) ;
extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                        void *v ) ;
extern int __blocking_notifier_call_chain(struct blocking_notifier_head *nh , unsigned long val ,
                                          void *v , int nr_to_call , int *nr_calls ) ;
extern int raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                   void *v ) ;
extern int __raw_notifier_call_chain(struct raw_notifier_head *nh , unsigned long val ,
                                     void *v , int nr_to_call , int *nr_calls ) ;
extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                    void *v ) ;
extern int __srcu_notifier_call_chain(struct srcu_notifier_head *nh , unsigned long val ,
                                      void *v , int nr_to_call , int *nr_calls ) ;
__inline static int notifier_from_errno(int err ) 
{ 

  {
  return (32768 | (1 - err));
}
}
__inline static int notifier_to_errno(int ret ) 
{ int tmp ;

  {
  {
  ret &= -32769;
  }
  if (ret > 1) {
    {
    tmp = 1 - ret;
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern struct blocking_notifier_head reboot_notifier_list ;
__inline static void pgdat_resize_lock(struct pglist_data *p , unsigned long *f ) 
{ 

  {
  return;
}
}
__inline static void pgdat_resize_init(struct pglist_data *pgdat ) 
{ 

  {
  return;
}
}
__inline static unsigned int zone_span_seqbegin(struct zone *zone ) 
{ 

  {
  return (0U);
}
}
__inline static int zone_span_seqretry(struct zone *zone , unsigned int iv ) 
{ 

  {
  return (0);
}
}
__inline static void zone_span_writelock(struct zone *zone ) 
{ 

  {
  return;
}
}
__inline static int mhp_notimplemented(char const   *func ) 
{ 

  {
  {
  printk("<4>%s() called, with CONFIG_MEMORY_HOTPLUG disabled\n", func);
  dump_stack();
  }
  return (-38);
}
}
extern int walk_memory_resource(unsigned long start_pfn , unsigned long nr_pages ,
                                void *arg , int (*func)(unsigned long  , unsigned long  ,
                                                        void * ) ) ;
__inline static int is_mem_section_removable(unsigned long pfn , unsigned long nr_pages ) 
{ 

  {
  return (0);
}
}
extern int add_memory(int nid , u64 start , u64 size ) ;
extern int arch_add_memory(int nid , u64 start , u64 size ) ;
extern int remove_memory(u64 start , u64 size ) ;
extern int sparse_add_one_section(struct zone *zone , unsigned long start_pfn , int nr_pages ) ;
extern void sparse_remove_one_section(struct zone *zone , struct mem_section *ms ) ;
extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map , unsigned long pnum ) ;
extern void get_zone_counts(unsigned long *active , unsigned long *inactive , unsigned long *free ) ;
extern void build_all_zonelists(void) ;
extern void wakeup_kswapd(struct zone *zone , int order ) ;
extern int zone_watermark_ok(struct zone *z , int order , unsigned long mark , int classzone_idx ,
                             int alloc_flags ) ;
extern int init_currently_empty_zone(struct zone *zone , unsigned long start_pfn ,
                                     unsigned long size , enum memmap_context context ) ;
__inline static void memory_present(int nid , unsigned long start , unsigned long end ) 
{ 

  {
  return;
}
}
__inline static int populated_zone(struct zone *zone ) 
{ 

  {
  return (! (! zone->present_pages));
}
}
extern int movable_zone ;
__inline static int zone_movable_is_highmem(void) 
{ 

  {
  return (movable_zone == 2);
}
}
__inline static int is_highmem_idx(enum zone_type idx ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )idx == 2U) {
    {
    tmp___0 = 1;
    }
  } else {
    if ((unsigned int )idx == 3U) {
      {
      tmp = zone_movable_is_highmem();
      }
      if (tmp) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static int is_normal_idx(enum zone_type idx ) 
{ 

  {
  return ((unsigned int )idx == 1U);
}
}
__inline static int is_highmem(struct zone *zone ) 
{ int zone_off ;
  int tmp ;
  int tmp___0 ;

  {
  {
  zone_off = (char *)zone - (char *)((zone->zone_pgdat)->node_zones);
  }
  if ((unsigned long )zone_off == 2UL * sizeof(*zone)) {
    {
    tmp___0 = 1;
    }
  } else {
    if ((unsigned long )zone_off == 3UL * sizeof(*zone)) {
      {
      tmp = zone_movable_is_highmem();
      }
      if (tmp) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static int is_normal(struct zone *zone ) 
{ 

  {
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 1));
}
}
__inline static int is_dma32(struct zone *zone ) 
{ 

  {
  return (0);
}
}
__inline static int is_dma(struct zone *zone ) 
{ 

  {
  return ((unsigned long )zone == (unsigned long )((zone->zone_pgdat)->node_zones + 0));
}
}
extern int min_free_kbytes_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                          void * , size_t * , loff_t * ) ;
extern int sysctl_lowmem_reserve_ratio[3] ;
extern int lowmem_reserve_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                               void * , size_t * , loff_t * ) ;
extern int percpu_pagelist_fraction_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                   void * , size_t * , loff_t * ) ;
extern int sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                    void * , size_t * , loff_t * ) ;
extern int sysctl_min_slab_ratio_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                                void * , size_t * , loff_t * ) ;
extern int numa_zonelist_order_handler(struct ctl_table * , int  , struct file * ,
                                       void * , size_t * , loff_t * ) ;
extern char numa_zonelist_order[] ;
extern struct pglist_data contig_page_data ;
extern struct pglist_data *first_online_pgdat(void) ;
extern struct pglist_data *next_online_pgdat(struct pglist_data *pgdat ) ;
extern struct zone *next_zone(struct zone *zone ) ;
__inline static struct zone *zonelist_zone(struct zoneref *zoneref ) 
{ 

  {
  return (zoneref->zone);
}
}
__inline static int zonelist_zone_idx(struct zoneref *zoneref ) 
{ 

  {
  return (zoneref->zone_idx);
}
}
__inline static int zonelist_node_idx(struct zoneref *zoneref ) 
{ 

  {
  return (0);
}
}
extern struct zoneref *next_zones_zonelist(struct zoneref *z , enum zone_type highest_zoneidx ,
                                           nodemask_t *nodes , struct zone **zone ) ;
__inline static struct zoneref *first_zones_zonelist(struct zonelist *zonelist , enum zone_type highest_zoneidx ,
                                                     nodemask_t *nodes , struct zone **zone ) 
{ struct zoneref *tmp ;

  {
  {
  tmp = next_zones_zonelist(zonelist->_zonerefs, highest_zoneidx, nodes, zone);
  }
  return (tmp);
}
}
extern unsigned long node_memmap_size_bytes(int  , unsigned long  , unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static int memmap_valid_within(unsigned long pfn , struct page *page , struct zone *zone ) 
{ 

  {
  return (1);
}
}
extern void cpu_idle(void) ;
extern unsigned int total_cpus ;
extern int smp_call_function_single(int cpuid , void (*func)(void *info ) , void *info ,
                                    int wait ) ;
extern int apic_version[256] ;
extern int pic_mode ;
extern unsigned int def_to_bigsmp ;
extern u8 apicid_2_node[] ;
extern void early_find_smp_config(void) ;
extern void early_get_smp_config(void) ;
extern unsigned long mp_bus_not_pci[((260UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
extern unsigned int boot_cpu_physical_apicid ;
extern unsigned int max_physical_apicid ;
extern int smp_found_config ;
extern int mpc_default_type ;
extern unsigned long mp_lapic_addr ;
extern void get_smp_config(void) ;
extern void find_smp_config(void) ;
extern void early_reserve_e820_mpc_new(void) ;
extern void generic_processor_info(int apicid , int version )  __attribute__((__section__(".cpuinit.text"))) ;
extern void mp_register_ioapic(int id , u32 address , u32 gsi_base ) ;
extern void mp_override_legacy_irq(u8 bus_irq , u8 polarity , u8 trigger , u32 gsi ) ;
extern void mp_config_acpi_legacy_irqs(void) ;
extern int mp_register_gsi(u32 gsi , int edge_level , int active_high_low ) ;
extern int acpi_probe_gsi(void) ;
extern int mp_config_acpi_gsi(unsigned char number , unsigned int devfn , u8 pin ,
                              u32 gsi , int triggering , int polarity ) ;
extern int mp_find_ioapic(int gsi ) ;
extern int mp_find_ioapic_pin(int ioapic , int gsi ) ;
__inline static void physid_set_mask_of_physid(int physid , physid_mask_t *map ) 
{ 

  {
  {
  bitmap_zero(map->mask, 256);
  set_bit((unsigned int )physid, (unsigned long volatile   *)(map->mask));
  }
  return;
}
}
extern physid_mask_t phys_cpu_present_map ;
extern int generic_mps_oem_check(struct mpc_table * , char * , char * ) ;
extern int default_acpi_madt_oem_check(char * , char * ) ;
extern void (*pm_idle)(void) ;
extern void (*pm_power_off)(void) ;
extern void (*pm_power_off_prepare)(void) ;
extern void device_pm_lock(void) ;
extern int sysdev_resume(void) ;
extern void device_power_up(pm_message_t state ) ;
extern void device_resume(pm_message_t state ) ;
extern void device_pm_unlock(void) ;
extern int sysdev_suspend(pm_message_t state ) ;
extern int device_power_down(pm_message_t state ) ;
extern int device_suspend(pm_message_t state ) ;
extern int device_prepare_suspend(pm_message_t state ) ;
extern void __suspend_report_result(char const   *function , void *fn , int ret ) ;
extern unsigned int pm_flags ;
extern int pxm_to_nid(int pxm ) ;
extern void numa_remove_cpu(int cpu ) ;
extern void set_highmem_pages_init(void) ;
extern void leave_mm(int cpu ) ;
extern int __acpi_acquire_global_lock(unsigned int *lock ) ;
extern int __acpi_release_global_lock(unsigned int *lock ) ;
extern int acpi_lapic ;
extern int acpi_ioapic ;
extern int acpi_noirq ;
extern int acpi_strict ;
extern int acpi_disabled ;
extern int acpi_ht ;
extern int acpi_pci_disabled ;
extern int acpi_skip_timer_override ;
extern int acpi_use_timer_override ;
extern u8 acpi_sci_flags ;
extern int acpi_sci_override_gsi ;
extern void acpi_pic_sci_set_trigger(unsigned int  , u16  ) ;
__inline static void disable_acpi(void) 
{ 

  {
  {
  acpi_disabled = 1;
  acpi_ht = 0;
  acpi_pci_disabled = 1;
  acpi_noirq = 1;
  }
  return;
}
}
extern int acpi_gsi_to_irq(u32 gsi , unsigned int *irq ) ;
__inline static void acpi_noirq_set(void) 
{ 

  {
  {
  acpi_noirq = 1;
  }
  return;
}
}
__inline static void acpi_disable_pci(void) 
{ 

  {
  {
  acpi_pci_disabled = 1;
  acpi_noirq_set();
  }
  return;
}
}
extern int acpi_save_state_mem(void) ;
extern void acpi_restore_state_mem(void) ;
extern unsigned long acpi_wakeup_address ;
extern void acpi_reserve_bootmem(void) ;
__inline static unsigned int acpi_processor_cstate_check(unsigned int max_cstate ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )boot_cpu_data.x86 == 15) {
    if ((int )boot_cpu_data.x86_vendor == 2) {
      if ((int )boot_cpu_data.x86_model <= 5) {
        if ((int )boot_cpu_data.x86_mask < 10) {
          return (1U);
        } else {
          goto _L___8;
        }
      } else {
        goto _L___8;
      }
    } else {
      goto _L___8;
    }
  } else {
    _L___8: /* CIL Label */ 
    _L___7: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    if (117 >> 5 == 0) {
      if ((1UL << 21) & (unsigned long )(1 | (1 << 15))) {
        {
        tmp___1 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      if (117 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
        if (117 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
          if (117 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
            if (117 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
              if (117 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
                if (117 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
                  if (117 >> 5 == 7) {
                    {
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___1 = tmp;
                    }
                  } else {
                    {
                    tmp = constant_test_bit(117U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___1 = tmp;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (tmp___1) {
      return (1U);
    } else {
      return (max_cstate);
    }
  }
}
}
__inline static void acpi_fake_nodes(struct bootnode  const  *fake_nodes , int num_nodes ) 
{ 

  {
  return;
}
}
extern unsigned long __FIXADDR_TOP ;
extern void reserve_top_address(unsigned long reserve ) ;
extern int fixmaps_set ;
extern pte_t *kmap_pte ;
extern pgprot_t kmap_prot ;
extern pte_t *pkmap_page_table ;
extern void __native_set_fixmap(enum fixed_addresses idx , pte_t pte ) ;
extern void native_set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) ;
__inline static void __set_fixmap(enum fixed_addresses idx , phys_addr_t phys , pgprot_t flags ) 
{ 

  {
  {
  native_set_fixmap(idx, phys, flags);
  }
  return;
}
}
extern void __this_fixmap_does_not_exist(void) ;
__inline static unsigned long fix_to_virt(unsigned int idx ) 
{ 

  {
  if (idx >= 513U) {
    {
    __this_fixmap_does_not_exist();
    }
  }
  return (__FIXADDR_TOP - (unsigned long )(idx << 12));
}
}
__inline static unsigned long virt_to_fix(unsigned long vaddr ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
  while (1) {
    while_24_continue: /* CIL Label */ ;
    if (vaddr >= __FIXADDR_TOP) {
      {
      tmp = 1;
      }
    } else {
      if (vaddr < __FIXADDR_TOP - (unsigned long )(176 << 12)) {
        {
        tmp = 1;
        }
      } else {
        {
        tmp = 0;
        }
      }
    }
    {
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
    if (tmp___0) {
      {
      while (1) {
        while_25_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/fixmap.h"),
                             "i" (205), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_26_continue: /* CIL Label */ ;
        }
        while_26_break: /* CIL Label */ ;
        }
        goto while_25_break;
      }
      while_25_break: /* CIL Label */ ;
      }
    }
    goto while_24_break;
  }
  while_24_break: /* CIL Label */ ;
  }
  return ((__FIXADDR_TOP - (vaddr & ~ ((1UL << 12) - 1UL))) >> 12);
}
}
extern void generic_apic_probe(void) ;
extern unsigned int apic_verbosity ;
extern int local_apic_timer_c2_ok ;
extern int disable_apic ;
extern void __inquire_remote_apic(int apicid ) ;
__inline static void default_inquire_remote_apic(int apicid ) 
{ 

  {
  if (apic_verbosity >= 2U) {
    {
    __inquire_remote_apic(apicid);
    }
  }
  return;
}
}
__inline static int is_vsmp_box(void) 
{ 

  {
  return (0);
}
}
extern void xapic_wait_icr_idle(void) ;
extern u32 safe_xapic_wait_icr_idle(void) ;
extern void xapic_icr_write(u32  , u32  ) ;
extern int setup_profiling_timer(unsigned int  ) ;
__inline static void native_apic_mem_write(u32 reg , u32 v ) 
{ u32 volatile   *addr ;
  unsigned long tmp ;

  {
  {
  tmp = fix_to_virt(4U);
  addr = (u32 volatile   *)(tmp + (unsigned long )reg);
  __asm__  volatile   ("661:\n\t"
                       "movl %0, %1"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c[feat]\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "xchgl %0, %1"
                       "\n664:\n"
                       ".previous": "=r" (v), "=m" (*addr): [feat] "i" (115), "0" (v),
                       "m" (*addr));
  }
  return;
}
}
__inline static u32 native_apic_mem_read(u32 reg ) 
{ unsigned long tmp ;

  {
  {
  tmp = fix_to_virt(4U);
  }
  return ((unsigned int )*((u32 volatile   *)(tmp + (unsigned long )reg)));
}
}
extern void native_apic_wait_icr_idle(void) ;
extern u32 native_safe_apic_wait_icr_idle(void) ;
extern void native_apic_icr_write(u32 low , u32 id ) ;
extern u64 native_apic_icr_read(void) ;
extern int get_physical_broadcast(void) ;
extern int lapic_get_maxlvt(void) ;
extern void clear_local_APIC(void) ;
extern void connect_bsp_APIC(void) ;
extern void disconnect_bsp_APIC(int virt_wire_setup ) ;
extern void disable_local_APIC(void) ;
extern void lapic_shutdown(void) ;
extern int verify_local_APIC(void) ;
extern void cache_APIC_registers(void) ;
extern void sync_Arb_IDs(void) ;
extern void init_bsp_APIC(void) ;
extern void setup_local_APIC(void) ;
extern void end_local_APIC_setup(void) ;
extern void init_apic_mappings(void) ;
extern void setup_boot_APIC_clock(void) ;
extern void setup_secondary_APIC_clock(void) ;
extern int APIC_init_uniprocessor(void) ;
extern void enable_NMI_through_LVT0(void) ;
extern u8 setup_APIC_eilvt_mce(u8 vector , u8 msg_type , u8 mask ) ;
extern u8 setup_APIC_eilvt_ibs(u8 vector , u8 msg_type , u8 mask ) ;
extern struct apic *apic ;
extern atomic_t init_deasserted ;
extern int wakeup_secondary_cpu_via_nmi(int apicid , unsigned long start_eip ) ;
__inline static u32 apic_read(u32 reg ) 
{ u32 tmp ;

  {
  {
  tmp = (*(apic->read))(reg);
  }
  return (tmp);
}
}
__inline static void apic_write(u32 reg , u32 val ) 
{ 

  {
  {
  (*(apic->write))(reg, val);
  }
  return;
}
}
__inline static u64 apic_icr_read(void) 
{ u64 tmp ;

  {
  {
  tmp = (*(apic->icr_read))();
  }
  return (tmp);
}
}
__inline static void apic_icr_write(u32 low , u32 high ) 
{ 

  {
  {
  (*(apic->icr_write))(low, high);
  }
  return;
}
}
__inline static void apic_wait_icr_idle(void) 
{ 

  {
  {
  (*(apic->wait_icr_idle))();
  }
  return;
}
}
__inline static u32 safe_apic_wait_icr_idle(void) 
{ u32 tmp ;

  {
  {
  tmp = (*(apic->safe_wait_icr_idle))();
  }
  return (tmp);
}
}
__inline static void ack_APIC_irq(void) 
{ 

  {
  {
  apic_write(176U, 0U);
  }
  return;
}
}
__inline static unsigned int default_get_apic_id(unsigned long x ) 
{ unsigned int ver ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = apic_read(48U);
  ver = tmp & 255U;
  }
  if (ver >= 20U) {
    return ((unsigned int )((x >> 24) & 255UL));
  } else {
    if (122 >> 5 == 0) {
      if ((1UL << 26) & (unsigned long )(1 | (1 << 15))) {
        {
        tmp___2 = 1;
        }
      } else {
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      if (122 >> 5 == 1) {
        goto _L___4;
      } else {
        _L___4: /* CIL Label */ 
        if (122 >> 5 == 2) {
          goto _L___3;
        } else {
          _L___3: /* CIL Label */ 
          if (122 >> 5 == 3) {
            goto _L___2;
          } else {
            _L___2: /* CIL Label */ 
            if (122 >> 5 == 4) {
              goto _L___1;
            } else {
              _L___1: /* CIL Label */ 
              if (122 >> 5 == 5) {
                goto _L___0;
              } else {
                _L___0: /* CIL Label */ 
                if (122 >> 5 == 6) {
                  goto _L;
                } else {
                  _L: /* CIL Label */ 
                  if (122 >> 5 == 7) {
                    {
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___2 = tmp___0;
                    }
                  } else {
                    {
                    tmp___0 = constant_test_bit(122U, (unsigned long const volatile   *)((unsigned long *)(boot_cpu_data.x86_capability)));
                    tmp___2 = tmp___0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (tmp___2) {
      return ((unsigned int )((x >> 24) & 255UL));
    } else {
      return ((unsigned int )((x >> 24) & 15UL));
    }
  }
}
}
__inline static void default_wait_for_init_deassert(atomic_t *deassert ) 
{ 

  {
  {
  while (1) {
    while_27_continue: /* CIL Label */ ;
    if (! (! deassert->counter)) {
      goto while_27_break;
    }
    {
    cpu_relax();
    }
  }
  while_27_break: /* CIL Label */ ;
  }
  return;
}
}
extern void generic_bigsmp_probe(void) ;
__inline static struct cpumask  const  *default_target_cpus(void) 
{ 

  {
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
extern u16 per_cpu__x86_bios_cpu_apicid  __attribute__((__section__(".data.percpu"))) ;
extern u16 *x86_bios_cpu_apicid_early_ptr ;
extern u16 x86_bios_cpu_apicid_early_map[] ;
__inline static unsigned int read_apic_id(void) 
{ unsigned int reg ;
  unsigned int tmp ;

  {
  {
  reg = apic_read(32U);
  tmp = (*(apic->get_apic_id))((unsigned long )reg);
  }
  return (tmp);
}
}
extern void default_setup_apic_routing(void) ;
extern void default_init_apic_ldr(void) ;
__inline static int default_apic_id_registered(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  {
  tmp___2 = read_apic_id();
  tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
  return (tmp___3);
}
}
__inline static int default_phys_pkg_id(int cpuid_apic , int index_msb ) 
{ 

  {
  return (cpuid_apic >> index_msb);
}
}
extern int default_apicid_to_node(int logical_apicid ) ;
__inline static unsigned int default_cpu_mask_to_apicid(struct cpumask  const  *cpumask ) 
{ 

  {
  return ((unsigned int )(cpumask->bits[0] & 255UL));
}
}
__inline static unsigned int default_cpu_mask_to_apicid_and(struct cpumask  const  *cpumask ,
                                                            struct cpumask  const  *andmask ) 
{ unsigned long mask1 ;
  unsigned long mask2 ;
  unsigned long mask3 ;

  {
  {
  mask1 = cpumask->bits[0];
  mask2 = andmask->bits[0];
  mask3 = cpu_online_mask->bits[0];
  }
  return ((unsigned int )((mask1 & mask2) & mask3));
}
}
__inline static unsigned long default_check_apicid_used(physid_mask_t bitmap , int apicid ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(apicid, (unsigned long const volatile   *)(bitmap.mask));
  }
  return ((unsigned long )tmp___0);
}
}
__inline static unsigned long default_check_apicid_present(int bit ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(bit, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
  return ((unsigned long )tmp___0);
}
}
__inline static physid_mask_t default_ioapic_phys_id_map(physid_mask_t phys_map ) 
{ 

  {
  return (phys_map);
}
}
__inline static int default_cpu_to_logical_apicid(int cpu ) 
{ 

  {
  return (1 << cpu);
}
}
__inline static int __default_cpu_present_to_apicid(int mps_cpu ) 
{ unsigned long __ptr ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;

  {
  if (mps_cpu < nr_cpu_ids) {
    {
    tmp___2 = cpumask_check((unsigned int )mps_cpu);
    tmp___3 = variable_test_bit((int )tmp___2, (unsigned long const volatile   *)(cpu_present_mask->bits));
    }
    if (tmp___3) {
      {
      __asm__  ("": "=r" (__ptr): "0" (& per_cpu__x86_bios_cpu_apicid));
      }
      return ((int )*((u16 *)(__ptr + __per_cpu_offset[mps_cpu])));
    } else {
      return (255);
    }
  } else {
    return (255);
  }
}
}
__inline static int __default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(boot_cpu_physical_apicid___0, (unsigned long const volatile   *)(phys_cpu_present_map.mask));
  }
  return (tmp___0);
}
}
__inline static int default_cpu_present_to_apicid(int mps_cpu ) 
{ int tmp ;

  {
  {
  tmp = __default_cpu_present_to_apicid(mps_cpu);
  }
  return (tmp);
}
}
__inline static int default_check_phys_apicid_present(int boot_cpu_physical_apicid___0 ) 
{ int tmp ;

  {
  {
  tmp = __default_check_phys_apicid_present(boot_cpu_physical_apicid___0);
  }
  return (tmp);
}
}
__inline static physid_mask_t default_apicid_to_cpu_present(int phys_apicid ) 
{ physid_mask_t __physid_mask ;

  {
  {
  __physid_mask.mask[0] = 0UL;
  __physid_mask.mask[1] = 0UL;
  __physid_mask.mask[2] = 0UL;
  __physid_mask.mask[3] = 0UL;
  set_bit((unsigned int )phys_apicid, (unsigned long volatile   *)(__physid_mask.mask));
  }
  return (__physid_mask);
}
}
extern u8 cpu_2_logical_apicid[8] ;
__inline static int invalid_vm86_irq(int irq ) 
{ int tmp ;

  {
  if (irq < 3) {
    {
    tmp = 1;
    }
  } else {
    if (irq > 15) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
extern int nr_ioapics ;
extern int nr_ioapic_registers[64] ;
extern struct mpc_ioapic mp_ioapics[64] ;
extern int mp_irq_entries ;
extern struct mpc_intsrc mp_irqs[256] ;
extern int sis_apic_bug ;
extern int skip_ioapic_setup ;
extern int noioapicquirk ;
extern int noioapicreroute ;
extern int timer_through_8259 ;
extern int io_apic_get_unique_id(int ioapic , int apic_id ) ;
extern int io_apic_get_version(int ioapic ) ;
extern int io_apic_get_redir_entries(int ioapic ) ;
extern int io_apic_set_pci_routing(int ioapic , int pin , int irq , int edge_level ,
                                   int active_high_low ) ;
extern int (*ioapic_renumber_irq)(int ioapic , int irq ) ;
extern void ioapic_init_mappings(void) ;
extern void probe_nr_irqs_gsi(void) ;
extern int setup_ioapic_entry(int apic , int irq , struct IO_APIC_route_entry *entry ,
                              unsigned int destination , int trigger , int polarity ,
                              int vector , int pin ) ;
extern void ioapic_write_entry(int apic , int pin , struct IO_APIC_route_entry e ) ;
extern cpumask_var_t cpu_callin_mask ;
extern cpumask_var_t cpu_callout_mask ;
extern cpumask_var_t cpu_initialized_mask ;
extern cpumask_var_t cpu_sibling_setup_mask ;
extern void setup_cpu_local_masks(void) ;
extern int smp_num_siblings ;
extern unsigned int num_processors ;
extern cpumask_var_t per_cpu__cpu_sibling_map  __attribute__((__section__(".data.percpu"))) ;
extern cpumask_var_t per_cpu__cpu_core_map  __attribute__((__section__(".data.percpu"))) ;
extern u16 per_cpu__cpu_llc_id  __attribute__((__section__(".data.percpu"))) ;
extern int per_cpu__cpu_number  __attribute__((__section__(".data.percpu"))) ;
__inline static struct cpumask *cpu_sibling_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_sibling_map));
  }
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
__inline static struct cpumask *cpu_core_mask(int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__cpu_core_map));
  }
  return (*((cpumask_var_t *)(__ptr + __per_cpu_offset[cpu])));
}
}
extern u16 per_cpu__x86_cpu_to_apicid  __attribute__((__section__(".data.percpu"))) ;
extern u16 *x86_cpu_to_apicid_early_ptr ;
extern u16 x86_cpu_to_apicid_early_map[] ;
extern struct __anonstruct_stack_start_92 stack_start ;
extern void set_cpu_sibling_map(int cpu ) ;
extern struct smp_ops smp_ops ;
__inline static void smp_send_stop(void) 
{ 

  {
  {
  (*(smp_ops.smp_send_stop))();
  }
  return;
}
}
__inline static void smp_prepare_boot_cpu(void) 
{ 

  {
  {
  (*(smp_ops.smp_prepare_boot_cpu))();
  }
  return;
}
}
__inline static void smp_prepare_cpus(unsigned int max_cpus ) 
{ 

  {
  {
  (*(smp_ops.smp_prepare_cpus))(max_cpus);
  }
  return;
}
}
__inline static void smp_cpus_done(unsigned int max_cpus ) 
{ 

  {
  {
  (*(smp_ops.smp_cpus_done))(max_cpus);
  }
  return;
}
}
__inline static int __cpu_up(unsigned int cpunum ) 
{ int tmp ;

  {
  {
  tmp = (*(smp_ops.cpu_up))(cpunum);
  }
  return (tmp);
}
}
__inline static int __cpu_disable(void) 
{ int tmp ;

  {
  {
  tmp = (*(smp_ops.cpu_disable))();
  }
  return (tmp);
}
}
__inline static void __cpu_die(unsigned int cpu ) 
{ 

  {
  {
  (*(smp_ops.cpu_die))(cpu);
  }
  return;
}
}
__inline static void play_dead(void) 
{ 

  {
  {
  (*(smp_ops.play_dead))();
  }
  return;
}
}
__inline static void smp_send_reschedule(int cpu ) 
{ 

  {
  {
  (*(smp_ops.smp_send_reschedule))(cpu);
  }
  return;
}
}
__inline static void arch_send_call_function_single_ipi(int cpu ) 
{ 

  {
  {
  (*(smp_ops.send_call_func_single_ipi))(cpu);
  }
  return;
}
}
__inline static void arch_send_call_function_ipi_mask(struct cpumask  const  *mask ) 
{ 

  {
  {
  (*(smp_ops.send_call_func_ipi))(mask);
  }
  return;
}
}
extern void cpu_disable_common(void) ;
extern void native_smp_prepare_boot_cpu(void) ;
extern void native_smp_prepare_cpus(unsigned int max_cpus ) ;
extern void native_smp_cpus_done(unsigned int max_cpus ) ;
extern int native_cpu_up(unsigned int cpunum ) ;
extern int native_cpu_disable(void) ;
extern void native_cpu_die(unsigned int cpu ) ;
extern void native_play_dead(void) ;
extern void play_dead_common(void) ;
extern void native_send_call_func_ipi(struct cpumask  const  *mask ) ;
extern void native_send_call_func_single_ipi(int cpu ) ;
extern void smp_store_cpu_info(int id ) ;
__inline static int num_booting_cpus(void) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_weight((struct cpumask  const  *)(cpu_callout_mask));
  }
  return ((int )tmp);
}
}
extern unsigned int disabled_cpus  __attribute__((__section__(".cpuinit.data"))) ;
extern int safe_smp_processor_id(void) ;
__inline static int logical_smp_processor_id(void) 
{ unsigned long tmp ;

  {
  {
  tmp = fix_to_virt(4U);
  }
  return ((int )((*((u32 *)(tmp + 208UL)) >> 24) & 255U));
}
}
extern int hard_smp_processor_id(void) ;
extern int smp_call_function(void (*func)(void *info ) , void *info , int wait ) ;
extern void smp_call_function_many(struct cpumask  const  *mask , void (*func)(void *info ) ,
                                   void *info , bool wait ) ;
__inline static int smp_call_function_mask(cpumask_t mask , void (*func)(void *info ) ,
                                           void *info , int wait ) 
{ 

  {
  {
  smp_call_function_many((struct cpumask  const  *)(& mask), func, info, (_Bool )wait);
  }
  return (0);
}
}
extern void __smp_call_function_single(int cpuid , struct call_single_data *data ,
                                       int wait ) ;
extern void generic_smp_call_function_single_interrupt(void) ;
extern void generic_smp_call_function_interrupt(void) ;
extern void ipi_call_lock(void) ;
extern void ipi_call_unlock(void) ;
extern void ipi_call_lock_irq(void) ;
extern void ipi_call_unlock_irq(void) ;
extern int on_each_cpu(void (*func)(void *info ) , void *info , int wait ) ;
extern unsigned int setup_max_cpus ;
extern void arch_disable_smp_support(void) ;
extern void smp_setup_processor_id(void) ;
__inline static int cpu_to_node(int cpu ) 
{ 

  {
  return (0);
}
}
__inline static struct cpumask  const  *cpumask_of_node(int node ) 
{ 

  {
  return ((struct cpumask  const  *)cpu_online_mask);
}
}
extern struct cpumask  const  *cpu_coregroup_mask(int cpu ) ;
__inline static void arch_fix_phys_package_id(int num , u32 slot ) 
{ 

  {
  return;
}
}
extern void x86_pci_root_bus_res_quirks(struct pci_bus *b ) ;
__inline static void set_mp_bus_to_node(int busnum , int node ) 
{ 

  {
  return;
}
}
extern int arch_update_cpu_topology(void) ;
__inline static int allocflags_to_migratetype(gfp_t gfp_flags ) 
{ int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
  __ret_warn_on = ! (! ((gfp_flags & 1572864U) == 1572864U));
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
  if (tmp) {
    {
    warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/gfp.h",
                       105);
    }
  }
  {
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  tmp___0 = __builtin_expect((long )(! (! page_group_by_mobility_disabled)), 0L);
  }
  if (tmp___0) {
    return (0);
  }
  return ((((gfp_flags & 1048576U) != 0U) << 1) | ((gfp_flags & 524288U) != 0U));
}
}
__inline static enum zone_type gfp_zone(gfp_t flags ) 
{ 

  {
  if (flags & 1U) {
    return ((enum zone_type )0);
  }
  if ((flags & 1048578U) == 1048578U) {
    return ((enum zone_type )3);
  }
  if (flags & 2U) {
    return ((enum zone_type )2);
  }
  return ((enum zone_type )1);
}
}
__inline static int gfp_zonelist(gfp_t flags ) 
{ long tmp ;

  {
  return (0);
}
}
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ int tmp ;

  {
  {
  tmp = gfp_zonelist(flags);
  }
  return (contig_page_data.node_zonelists + tmp);
}
}
__inline static void arch_free_page(struct page *page , int order ) 
{ 

  {
  return;
}
}
extern struct page *__alloc_pages_internal(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ,
                                           nodemask_t *nodemask ) ;
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ struct page *tmp ;

  {
  {
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, (nodemask_t *)((void *)0));
  }
  return (tmp);
}
}
__inline static struct page *__alloc_pages_nodemask(gfp_t gfp_mask , unsigned int order ,
                                                    struct zonelist *zonelist , nodemask_t *nodemask ) 
{ struct page *tmp ;

  {
  {
  tmp = __alloc_pages_internal(gfp_mask, order, zonelist, nodemask);
  }
  return (tmp);
}
}
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ long tmp ;
  int ret__ ;
  struct zonelist *tmp___0 ;
  struct page *tmp___1 ;

  {
  {
  tmp = __builtin_expect((long )(! (! (order >= 11U))), 0L);
  }
  if (tmp) {
    return ((struct page *)((void *)0));
  }
  if (nid < 0) {
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_28_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_28_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_28_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_28_8;
          } else {
            {
            goto switch_28_default;
            if (0) {
              switch_28_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_28_break;
              switch_28_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_28_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    nid = 0;
    }
  }
  {
  tmp___0 = node_zonelist(nid, gfp_mask);
  tmp___1 = __alloc_pages(gfp_mask, order, tmp___0);
  }
  return (tmp___1);
}
}
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
extern unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
extern void *alloc_pages_exact(size_t size , gfp_t gfp_mask ) ;
extern void free_pages_exact(void *virt , size_t size ) ;
extern void __free_pages(struct page *page , unsigned int order ) ;
extern void free_pages(unsigned long addr , unsigned int order ) ;
extern void free_hot_page(struct page *page ) ;
extern void free_cold_page(struct page *page ) ;
extern void page_alloc_init(void) ;
extern void drain_zone_pages(struct zone *zone , struct per_cpu_pages *pcp ) ;
extern void drain_all_pages(void) ;
extern void drain_local_pages(void *dummy ) ;
extern int ( /* format attribute */  __request_module)(bool wait , char const   *name 
                                                       , ...) ;
extern struct subprocess_info *call_usermodehelper_setup(char *path , char **argv ,
                                                         char **envp , gfp_t gfp_mask ) ;
extern void call_usermodehelper_setkeys(struct subprocess_info *info , struct key *session_keyring ) ;
extern int call_usermodehelper_stdinpipe(struct subprocess_info *sub_info , struct file **filp ) ;
extern void call_usermodehelper_setcleanup(struct subprocess_info *info , void (*cleanup)(char **argv ,
                                                                                          char **envp ) ) ;
extern int call_usermodehelper_exec(struct subprocess_info *info , enum umh_wait wait ) ;
extern void call_usermodehelper_freeinfo(struct subprocess_info *info ) ;
__inline static int call_usermodehelper(char *path , char **argv , char **envp , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  if ((int )wait == -1) {
    {
    tmp = 32U;
    }
  } else {
    {
    tmp = 208U;
    }
  }
  {
  gfp_mask = tmp;
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
  return (tmp___0);
}
}
__inline static int call_usermodehelper_keys(char *path , char **argv , char **envp ,
                                             struct key *session_keyring , enum umh_wait wait ) 
{ struct subprocess_info *info ;
  gfp_t gfp_mask ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  if ((int )wait == -1) {
    {
    tmp = 32U;
    }
  } else {
    {
    tmp = 208U;
    }
  }
  {
  gfp_mask = tmp;
  info = call_usermodehelper_setup(path, argv, envp, gfp_mask);
  }
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  call_usermodehelper_setkeys(info, session_keyring);
  tmp___0 = call_usermodehelper_exec(info, wait);
  }
  return (tmp___0);
}
}
extern void usermodehelper_init(void) ;
extern int call_usermodehelper_pipe(char *path , char **argv , char **envp , struct file **filp ) ;
extern int usermodehelper_disable(void) ;
extern void usermodehelper_enable(void) ;
extern char const   VDSO32_PRELINK[] ;
extern void __kernel_sigreturn ;
extern void __kernel_rt_sigreturn ;
extern char const   vdso32_int80_start ;
extern char const   vdso32_int80_end ;
extern char const   vdso32_syscall_start ;
extern char const   vdso32_syscall_end ;
extern char const   vdso32_sysenter_start ;
extern char const   vdso32_sysenter_end ;
extern unsigned int vdso_enabled ;
__inline static void fill_ldt(struct desc_struct *desc , struct user_desc  const  *info ) 
{ 

  {
  {
  desc->__annonCompField8.__annonCompField7.limit0 = (unsigned short )(info->limit & 65535U);
  desc->__annonCompField8.__annonCompField7.base0 = (unsigned short )(info->base_addr & 65535U);
  desc->__annonCompField8.__annonCompField7.base1 = (unsigned int )((info->base_addr & 16711680U) >> 16);
  desc->__annonCompField8.__annonCompField7.type = (unsigned int )((info->read_exec_only ^ 1U) << 1);
  desc->__annonCompField8.__annonCompField7.type |= (unsigned int )(info->contents << 2);
  desc->__annonCompField8.__annonCompField7.s = 1U;
  desc->__annonCompField8.__annonCompField7.dpl = 3U;
  desc->__annonCompField8.__annonCompField7.p = (unsigned int )(info->seg_not_present ^ 1U);
  desc->__annonCompField8.__annonCompField7.limit = (unsigned int )((info->limit & 983040U) >> 16);
  desc->__annonCompField8.__annonCompField7.avl = (unsigned int )info->useable;
  desc->__annonCompField8.__annonCompField7.d = (unsigned int )info->seg_32bit;
  desc->__annonCompField8.__annonCompField7.g = (unsigned int )info->limit_in_pages;
  desc->__annonCompField8.__annonCompField7.base2 = (unsigned int )((info->base_addr & 4278190080U) >> 24);
  desc->__annonCompField8.__annonCompField7.l = 0U;
  }
  return;
}
}
extern struct desc_ptr idt_descr ;
extern gate_desc idt_table[] ;
extern struct gdt_page per_cpu__gdt_page  __attribute__((__section__(".data.percpu.page_aligned"))) ;
__inline static struct desc_struct *get_cpu_gdt_table(unsigned int cpu ) 
{ unsigned long __ptr ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__gdt_page));
  }
  return (((struct gdt_page *)(__ptr + __per_cpu_offset[cpu]))->gdt);
}
}
__inline static void pack_gate(gate_desc *gate , unsigned char type , unsigned long base ,
                               unsigned int dpl , unsigned int flags , unsigned short seg ) 
{ 

  {
  {
  gate->__annonCompField8.__annonCompField6.a = (unsigned int )((unsigned long )((int )seg << 16) | (base & 65535UL));
  gate->__annonCompField8.__annonCompField6.b = (unsigned int )((base & 4294901760UL) | (unsigned long )((((unsigned int )(128 | (int )type) | (dpl << 5)) & 255U) << 8));
  }
  return;
}
}
__inline static int desc_empty(void const   *ptr ) 
{ u32 const   *desc ;

  {
  {
  desc = (u32 const   *)ptr;
  }
  return (! (*(desc + 0) | *(desc + 1)));
}
}
__inline static void paravirt_alloc_ldt(struct desc_struct *ldt , unsigned int entries ) 
{ 

  {
  return;
}
}
__inline static void native_write_idt_entry(gate_desc *idt , int entry , gate_desc const   *gate ) 
{ 

  {
  {
  __constant_memcpy((void *)(idt + entry), (void const   *)gate, (unsigned int )sizeof(*gate));
  }
  return;
}
}
__inline static void native_write_ldt_entry(struct desc_struct *ldt , int entry ,
                                            void const   *desc ) 
{ 

  {
  {
  __constant_memcpy((void *)(ldt + entry), desc, 8U);
  }
  return;
}
}
__inline static void native_write_gdt_entry(struct desc_struct *gdt , int entry ,
                                            void const   *desc , int type ) 
{ unsigned int size ;

  {
  if (type == 9) {
    goto switch_29_9;
  } else {
    if (type == 2) {
      goto switch_29_2;
    } else {
      {
      goto switch_29_default;
      if (0) {
        switch_29_9: /* CIL Label */ 
        {
        size = (unsigned int )sizeof(tss_desc );
        }
        goto switch_29_break;
        switch_29_2: /* CIL Label */ 
        {
        size = (unsigned int )sizeof(ldt_desc );
        }
        goto switch_29_break;
        switch_29_default: /* CIL Label */ 
        {
        size = (unsigned int )sizeof(struct desc_struct );
        }
        goto switch_29_break;
      } else {
        switch_29_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
  __memcpy((void *)(gdt + entry), desc, size);
  }
  return;
}
}
__inline static void pack_descriptor(struct desc_struct *desc , unsigned long base ,
                                     unsigned long limit , unsigned char type , unsigned char flags ) 
{ 

  {
  {
  desc->__annonCompField8.__annonCompField6.a = (unsigned int )(((base & 65535UL) << 16) | (limit & 65535UL));
  desc->__annonCompField8.__annonCompField6.b = (unsigned int )(((((base & 4278190080UL) | ((base & 16711680UL) >> 16)) | (limit & 983040UL)) | (unsigned long )(((int )type & 255) << 8)) | (unsigned long )(((int )flags & 15) << 20));
  desc->__annonCompField8.__annonCompField7.p = 1U;
  }
  return;
}
}
__inline static void set_tssldt_descriptor(void *d , unsigned long addr , unsigned int type ,
                                           unsigned int size ) 
{ 

  {
  {
  pack_descriptor((struct desc_struct *)d, addr, (unsigned long )size, (unsigned char )(128U | type),
                  (unsigned char)0);
  }
  return;
}
}
__inline static void __set_tss_desc(unsigned int cpu , unsigned int entry , void *addr ) 
{ struct desc_struct *d ;
  struct desc_struct *tmp ;
  tss_desc tss ;

  {
  {
  tmp = get_cpu_gdt_table(cpu);
  d = tmp;
  set_tssldt_descriptor((void *)(& tss), (unsigned long )addr, 9U, (unsigned int )(((unsigned long )((unsigned int )(& ((struct tss_struct *)0)->io_bitmap) + 8192U) + sizeof(unsigned long )) - 1UL));
  native_write_gdt_entry(d, (int )entry, (void const   *)(& tss), 9);
  }
  return;
}
}
__inline static void native_set_ldt(void const   *addr , unsigned int entries ) 
{ unsigned int cpu ;
  int ret__ ;
  ldt_desc ldt ;
  struct desc_struct *tmp ;
  long tmp___0 ;

  {
  {
  tmp___0 = __builtin_expect((long )(! (! (entries == 0U))), 1L);
  }
  if (tmp___0) {
    {
    __asm__  volatile   ("lldt %w0": : "q" (0));
    }
  } else {
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_30_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_30_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_30_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_30_8;
          } else {
            {
            goto switch_30_default;
            if (0) {
              switch_30_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_30_break;
              switch_30_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_30_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    cpu = (unsigned int )ret__;
    set_tssldt_descriptor((void *)(& ldt), (unsigned long )addr, 2U, entries * 8U - 1U);
    tmp = get_cpu_gdt_table(cpu);
    native_write_gdt_entry(tmp, 17, (void const   *)(& ldt), 2);
    __asm__  volatile   ("lldt %w0": : "q" (136));
    }
  }
  return;
}
}
__inline static void native_load_tr_desc(void) 
{ 

  {
  {
  __asm__  volatile   ("ltr %w0": : "q" (128));
  }
  return;
}
}
__inline static void native_load_gdt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("lgdt %0": : "m" (*dtr));
  }
  return;
}
}
__inline static void native_load_idt(struct desc_ptr  const  *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("lidt %0": : "m" (*dtr));
  }
  return;
}
}
__inline static void native_store_gdt(struct desc_ptr *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("sgdt %0": "=m" (*dtr));
  }
  return;
}
}
__inline static void native_store_idt(struct desc_ptr *dtr ) 
{ 

  {
  {
  __asm__  volatile   ("sidt %0": "=m" (*dtr));
  }
  return;
}
}
__inline static unsigned long native_store_tr(void) 
{ unsigned long tr ;

  {
  {
  __asm__  volatile   ("str %0": "=r" (tr));
  }
  return (tr);
}
}
__inline static void native_load_tls(struct thread_struct *t , unsigned int cpu ) 
{ unsigned int i ;
  struct desc_struct *gdt ;
  struct desc_struct *tmp ;

  {
  {
  tmp = get_cpu_gdt_table(cpu);
  gdt = tmp;
  i = 0U;
  }
  {
  while (1) {
    while_31_continue: /* CIL Label */ ;
    if (! (i < 3U)) {
      goto while_31_break;
    }
    {
    *(gdt + (6U + i)) = t->tls_array[i];
    i ++;
    }
  }
  while_31_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void clear_LDT(void) 
{ 

  {
  {
  native_set_ldt((void const   *)((void *)0), 0U);
  }
  return;
}
}
__inline static void load_LDT_nolock(mm_context_t *pc ) 
{ 

  {
  {
  native_set_ldt((void const   *)pc->ldt, (unsigned int )pc->size);
  }
  return;
}
}
__inline static void load_LDT(mm_context_t *pc ) 
{ 

  {
  {
  while (1) {
    while_32_continue: /* CIL Label */ ;
    goto while_32_break;
  }
  while_32_break: /* CIL Label */ ;
  }
  {
  load_LDT_nolock(pc);
  }
  {
  while (1) {
    while_33_continue: /* CIL Label */ ;
    goto while_33_break;
  }
  while_33_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static unsigned long get_desc_base(struct desc_struct  const  *desc ) 
{ 

  {
  return ((unsigned long )(((unsigned int const   )desc->__annonCompField8.__annonCompField7.base0 | (desc->__annonCompField8.__annonCompField7.base1 << 16)) | (desc->__annonCompField8.__annonCompField7.base2 << 24)));
}
}
__inline static unsigned long get_desc_limit(struct desc_struct  const  *desc ) 
{ 

  {
  return ((unsigned long )((unsigned int const   )desc->__annonCompField8.__annonCompField7.limit0 | (desc->__annonCompField8.__annonCompField7.limit << 16)));
}
}
__inline static void _set_gate(int gate , unsigned int type , void *addr , unsigned int dpl ,
                               unsigned int ist , unsigned int seg ) 
{ gate_desc s ;

  {
  {
  pack_gate(& s, (unsigned char )type, (unsigned long )addr, dpl, ist, (unsigned short )seg);
  native_write_idt_entry(idt_table, gate, (gate_desc const   *)(& s));
  }
  return;
}
}
__inline static void set_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_34_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_35_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (320), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_36_continue: /* CIL Label */ ;
        }
        while_36_break: /* CIL Label */ ;
        }
        goto while_35_break;
      }
      while_35_break: /* CIL Label */ ;
      }
    }
    goto while_34_break;
  }
  while_34_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 14U, addr, 0U, 0U, 96U);
  }
  return;
}
}
extern int first_system_vector ;
extern unsigned long used_vectors[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
__inline static void alloc_system_vector(int vector ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = variable_test_bit(vector, (unsigned long const volatile   *)(used_vectors));
  }
  if (tmp___0) {
    {
    while (1) {
      while_37_continue: /* CIL Label */ ;
      {
      __asm__  volatile   ("1:\tud2\n"
                           ".pushsection __bug_table,\"a\"\n"
                           "2:\t.long 1b, %c0\n"
                           "\t.word %c1, 0\n"
                           "\t.org 2b+%c2\n"
                           ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                           "i" (335), "i" (sizeof(struct bug_entry )));
      }
      {
      while (1) {
        while_38_continue: /* CIL Label */ ;
      }
      while_38_break: /* CIL Label */ ;
      }
      goto while_37_break;
    }
    while_37_break: /* CIL Label */ ;
    }
  } else {
    {
    set_bit((unsigned int )vector, (unsigned long volatile   *)(used_vectors));
    }
    if (first_system_vector > vector) {
      {
      first_system_vector = vector;
      }
    }
  }
  return;
}
}
__inline static void alloc_intr_gate(unsigned int n , void *addr ) 
{ 

  {
  {
  alloc_system_vector((int )n);
  set_intr_gate(n, addr);
  }
  return;
}
}
__inline static void set_system_intr_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_39_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_40_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (349), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_41_continue: /* CIL Label */ ;
        }
        while_41_break: /* CIL Label */ ;
        }
        goto while_40_break;
      }
      while_40_break: /* CIL Label */ ;
      }
    }
    goto while_39_break;
  }
  while_39_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 14U, addr, 3U, 0U, 96U);
  }
  return;
}
}
__inline static void set_system_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_42_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_43_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (355), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_44_continue: /* CIL Label */ ;
        }
        while_44_break: /* CIL Label */ ;
        }
        goto while_43_break;
      }
      while_43_break: /* CIL Label */ ;
      }
    }
    goto while_42_break;
  }
  while_42_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 15U, addr, 3U, 0U, 96U);
  }
  return;
}
}
__inline static void set_trap_gate(unsigned int n , void *addr ) 
{ long tmp ;

  {
  {
  while (1) {
    while_45_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_46_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (361), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_47_continue: /* CIL Label */ ;
        }
        while_47_break: /* CIL Label */ ;
        }
        goto while_46_break;
      }
      while_46_break: /* CIL Label */ ;
      }
    }
    goto while_45_break;
  }
  while_45_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 15U, addr, 0U, 0U, 96U);
  }
  return;
}
}
__inline static void set_task_gate(unsigned int n , unsigned int gdt_entry ) 
{ long tmp ;

  {
  {
  while (1) {
    while_48_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_49_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (367), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_50_continue: /* CIL Label */ ;
        }
        while_50_break: /* CIL Label */ ;
        }
        goto while_49_break;
      }
      while_49_break: /* CIL Label */ ;
      }
    }
    goto while_48_break;
  }
  while_48_break: /* CIL Label */ ;
  }
  {
  _set_gate((int )n, 5U, (void *)0, 0U, 0U, gdt_entry << 3);
  }
  return;
}
}
__inline static void set_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
  while (1) {
    while_51_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_52_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (373), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_53_continue: /* CIL Label */ ;
        }
        while_53_break: /* CIL Label */ ;
        }
        goto while_52_break;
      }
      while_52_break: /* CIL Label */ ;
      }
    }
    goto while_51_break;
  }
  while_51_break: /* CIL Label */ ;
  }
  {
  _set_gate(n, 14U, addr, 0U, ist, 96U);
  }
  return;
}
}
__inline static void set_system_intr_gate_ist(int n , void *addr , unsigned int ist ) 
{ long tmp ;

  {
  {
  while (1) {
    while_54_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! ((unsigned int )n > 255U))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_55_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/desc.h"),
                             "i" (379), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_56_continue: /* CIL Label */ ;
        }
        while_56_break: /* CIL Label */ ;
        }
        goto while_55_break;
      }
      while_55_break: /* CIL Label */ ;
      }
    }
    goto while_54_break;
  }
  while_54_break: /* CIL Label */ ;
  }
  {
  _set_gate(n, 14U, addr, 3U, ist, 96U);
  }
  return;
}
}
extern int arch_setup_additional_pages(struct linux_binprm *bprm , int uses_interp ) ;
extern int syscall32_setup_pages(struct linux_binprm * , int exstack ) ;
extern unsigned long arch_randomize_brk(struct mm_struct *mm ) ;
extern Elf64_Dyn _DYNAMIC[] ;
__inline static int elf_coredump_extra_notes_write(struct file *file , loff_t *foffset ) 
{ 

  {
  return (0);
}
}
extern int parse_args(char const   *name , char *args , struct kernel_param *params ,
                      unsigned int num , int (*unknown)(char *param , char *val ) ) ;
extern void destroy_params(struct kernel_param  const  *params , unsigned int num ) ;
extern int param_set_byte(char const   *val , struct kernel_param *kp ) ;
extern int param_get_byte(char *buffer , struct kernel_param *kp ) ;
extern int param_set_short(char const   *val , struct kernel_param *kp ) ;
extern int param_get_short(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ushort(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ushort(char *buffer , struct kernel_param *kp ) ;
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
extern int param_set_long(char const   *val , struct kernel_param *kp ) ;
extern int param_get_long(char *buffer , struct kernel_param *kp ) ;
extern int param_set_ulong(char const   *val , struct kernel_param *kp ) ;
extern int param_get_ulong(char *buffer , struct kernel_param *kp ) ;
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
extern int param_set_invbool(char const   *val , struct kernel_param *kp ) ;
extern int param_get_invbool(char *buffer , struct kernel_param *kp ) ;
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
extern int param_set_copystring(char const   *val , struct kernel_param *kp ) ;
extern int param_get_string(char *buffer , struct kernel_param *kp ) ;
extern int module_param_sysfs_setup(struct module *mod , struct kernel_param *kparam ,
                                    unsigned int num_params ) ;
extern void module_param_sysfs_remove(struct module *mod ) ;
extern void marker_update_probe_range(struct marker *begin , struct marker *end ) ;
extern marker_probe_func __mark_empty_function ;
extern void marker_probe_cb(struct marker  const  *mdata , void *call_private  , ...) ;
extern int marker_probe_register(char const   *name , char const   *format , marker_probe_func *probe ,
                                 void *probe_private ) ;
extern int marker_probe_unregister(char const   *name , marker_probe_func *probe ,
                                   void *probe_private ) ;
extern int marker_probe_unregister_private_data(marker_probe_func *probe , void *probe_private ) ;
extern void *marker_get_private_data(char const   *name , marker_probe_func *probe ,
                                     int num ) ;
extern int rcu_scheduler_active ;
extern void rcu_qsctr_inc(int cpu ) ;
extern void rcu_bh_qsctr_inc(int cpu ) ;
extern int rcu_pending(int cpu ) ;
extern int rcu_needs_cpu(int cpu ) ;
__inline static void __rcu_read_lock(void) 
{ 

  {
  {
  while (1) {
    while_57_continue: /* CIL Label */ ;
    goto while_57_break;
  }
  while_57_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_58_continue: /* CIL Label */ ;
    goto while_58_break;
  }
  while_58_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void __rcu_read_lock_bh(void) 
{ 

  {
  {
  local_bh_disable();
  }
  {
  while (1) {
    while_59_continue: /* CIL Label */ ;
    goto while_59_break;
  }
  while_59_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void __rcu_read_unlock_bh(void) 
{ 

  {
  {
  while (1) {
    while_60_continue: /* CIL Label */ ;
    goto while_60_break;
  }
  while_60_break: /* CIL Label */ ;
  }
  {
  local_bh_enable();
  }
  return;
}
}
extern void __rcu_init(void) ;
extern void rcu_check_callbacks(int cpu , int user ) ;
extern void rcu_restart_cpu(int cpu ) ;
extern long rcu_batches_completed(void) ;
extern long rcu_batches_completed_bh(void) ;
extern void rcu_enter_nohz(void) ;
extern void rcu_exit_nohz(void) ;
__inline static int rcu_blocking_is_gp(void) 
{ unsigned int tmp ;

  {
  {
  tmp = cpumask_weight((struct cpumask  const  *)cpu_online_mask);
  }
  return (tmp == 1U);
}
}
extern void wakeme_after_rcu(struct rcu_head *head ) ;
extern void call_rcu(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
extern void call_rcu_bh(struct rcu_head *head , void (*func)(struct rcu_head *head ) ) ;
extern void synchronize_rcu(void) ;
extern void rcu_barrier(void) ;
extern void rcu_barrier_bh(void) ;
extern void rcu_barrier_sched(void) ;
extern void rcu_init(void) ;
extern void rcu_scheduler_starting(void) ;
extern void tracepoint_update_probe_range(struct tracepoint *begin , struct tracepoint *end ) ;
extern int tracepoint_probe_register(char const   *name , void *probe ) ;
extern int tracepoint_probe_unregister(char const   *name , void *probe ) ;
extern int tracepoint_probe_register_noupdate(char const   *name , void *probe ) ;
extern int tracepoint_probe_unregister_noupdate(char const   *name , void *probe ) ;
extern void tracepoint_probe_update_all(void) ;
extern void tracepoint_iter_start(struct tracepoint_iter *iter ) ;
extern void tracepoint_iter_next(struct tracepoint_iter *iter ) ;
extern void tracepoint_iter_stop(struct tracepoint_iter *iter ) ;
extern void tracepoint_iter_reset(struct tracepoint_iter *iter ) ;
extern int tracepoint_get_iter_range(struct tracepoint **tracepoint , struct tracepoint *begin ,
                                     struct tracepoint *end ) ;
__inline static void tracepoint_synchronize_unregister(void) 
{ 

  {
  {
  synchronize_rcu();
  }
  return;
}
}
extern void kmem_cache_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern int slab_is_available(void) ;
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
extern void kmem_cache_destroy(struct kmem_cache * ) ;
extern int kmem_cache_shrink(struct kmem_cache * ) ;
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
extern unsigned int kmem_cache_size(struct kmem_cache * ) ;
extern char const   *kmem_cache_name(struct kmem_cache * ) ;
extern int kmem_ptr_validate(struct kmem_cache *cachep , void const   *ptr ) ;
extern void *__krealloc(void const   * , size_t  , gfp_t  ) ;
extern void *krealloc(void const   * , size_t  , gfp_t  ) ;
extern void kfree(void const   * ) ;
extern void kzfree(void const   * ) ;
extern size_t ksize(void const   * ) ;
extern unsigned int cpu_khz ;
extern unsigned int tsc_khz ;
extern void disable_TSC(void) ;
__inline static cycles_t get_cycles(void) 
{ unsigned long long ret ;

  {
  {
  ret = 0ULL;
  ret = __native_read_tsc();
  }
  return (ret);
}
}
__inline static cycles_t vget_cycles(void) 
{ unsigned long long tmp ;

  {
  {
  tmp = __native_read_tsc();
  }
  return (tmp);
}
}
extern void tsc_init(void) ;
extern void mark_tsc_unstable(char *reason ) ;
extern int unsynchronized_tsc(void) ;
extern int check_tsc_unstable(void) ;
extern void check_tsc_sync_source(int cpu ) ;
extern void check_tsc_sync_target(void) ;
extern int notsc_setup(char * ) ;
extern unsigned long tick_usec ;
extern unsigned long tick_nsec ;
extern int tickadj ;
extern int time_status ;
extern long time_maxerror ;
extern long time_esterror ;
extern long time_adjust ;
extern void ntp_init(void) ;
extern void ntp_clear(void) ;
__inline static int ntp_synced(void) 
{ 

  {
  return (! (time_status & 64));
}
}
extern u64 tick_length ;
extern void second_overflow(void) ;
extern void update_ntp_one_tick(void) ;
extern int do_adjtimex(struct timex * ) ;
extern int read_current_timer(unsigned long *timer_val ) ;
extern u64 jiffies_64  __attribute__((__section__(".data"))) ;
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
extern u64 get_jiffies_64(void) ;
extern unsigned long preset_lpj ;
extern unsigned int jiffies_to_msecs(unsigned long j ) ;
extern unsigned int jiffies_to_usecs(unsigned long j ) ;
extern unsigned long msecs_to_jiffies(unsigned int m ) ;
extern unsigned long usecs_to_jiffies(unsigned int u ) ;
extern unsigned long timespec_to_jiffies(struct timespec  const  *value ) ;
extern void jiffies_to_timespec(unsigned long jiffies , struct timespec *value ) ;
extern unsigned long timeval_to_jiffies(struct timeval  const  *value ) ;
extern void jiffies_to_timeval(unsigned long jiffies , struct timeval *value ) ;
extern clock_t jiffies_to_clock_t(long x ) ;
extern unsigned long clock_t_to_jiffies(unsigned long x ) ;
extern u64 jiffies_64_to_clock_t(u64 x ) ;
extern u64 nsec_to_clock_t(u64 x ) ;
__inline static ktime_t ktime_set(long secs , unsigned long nsecs ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (long long )secs * 1000000000LL + (long long )nsecs;
  }
  return (__constr_expr_0);
}
}
__inline static ktime_t timespec_to_ktime(struct timespec ts ) 
{ ktime_t tmp ;

  {
  {
  tmp = ktime_set(ts.tv_sec, (unsigned long )ts.tv_nsec);
  }
  return (tmp);
}
}
__inline static ktime_t timeval_to_ktime(struct timeval tv ) 
{ ktime_t tmp ;

  {
  {
  tmp = ktime_set(tv.tv_sec, (unsigned long )(tv.tv_usec * 1000L));
  }
  return (tmp);
}
}
__inline static int ktime_equal(ktime_t cmp1 , ktime_t cmp2 ) 
{ 

  {
  return (cmp1.tv64 == cmp2.tv64);
}
}
__inline static s64 ktime_to_us(ktime_t kt ) 
{ struct timeval tv ;
  struct timeval tmp ;

  {
  {
  tmp = ns_to_timeval(kt.tv64);
  tv = tmp;
  }
  return ((long long )tv.tv_sec * 1000000LL + (long long )tv.tv_usec);
}
}
__inline static s64 ktime_us_delta(ktime_t later , ktime_t earlier ) 
{ ktime_t __constr_expr_0 ;
  s64 tmp ;

  {
  {
  __constr_expr_0.tv64 = later.tv64 - earlier.tv64;
  tmp = ktime_to_us(__constr_expr_0);
  }
  return (tmp);
}
}
__inline static ktime_t ktime_add_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 + usec * 1000ULL);
  }
  return (__constr_expr_0);
}
}
__inline static ktime_t ktime_sub_us(ktime_t kt , u64 usec ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )kt.tv64 - usec * 1000ULL);
  }
  return (__constr_expr_0);
}
}
extern ktime_t ktime_add_safe(ktime_t lhs , ktime_t rhs ) ;
extern void ktime_get_ts(struct timespec *ts ) ;
__inline static ktime_t ns_to_ktime(u64 ns ) ;
static union ktime  const  ktime_zero  =    {(s64 )0};
__inline static ktime_t ns_to_ktime(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
__inline static void debug_object_init(void *addr , struct debug_obj_descr *descr ) 
{ 

  {
  return;
}
}
__inline static void debug_check_no_obj_freed(void const   *address , unsigned long size ) 
{ 

  {
  return;
}
}
extern struct tvec_base boot_tvec_bases ;
extern void init_timer_key(struct timer_list *timer , char const   *name , struct lock_class_key *key ) ;
extern void init_timer_deferrable_key(struct timer_list *timer , char const   *name ,
                                      struct lock_class_key *key ) ;
__inline static void destroy_timer_on_stack(struct timer_list *timer ) 
{ 

  {
  return;
}
}
__inline static void init_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                             struct lock_class_key *key ) 
{ 

  {
  {
  init_timer_key(timer, name, key);
  }
  return;
}
}
__inline static void setup_timer_key(struct timer_list *timer , char const   *name ,
                                     struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                     unsigned long data ) 
{ 

  {
  {
  timer->function = function;
  timer->data = data;
  init_timer_key(timer, name, key);
  }
  return;
}
}
__inline static void setup_timer_on_stack_key(struct timer_list *timer , char const   *name ,
                                              struct lock_class_key *key , void (*function)(unsigned long  ) ,
                                              unsigned long data ) 
{ 

  {
  {
  timer->function = function;
  timer->data = data;
  init_timer_on_stack_key(timer, name, key);
  }
  return;
}
}
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 

  {
  return ((unsigned long )timer->entry.next != (unsigned long )((void *)0));
}
}
extern void add_timer_on(struct timer_list *timer , int cpu ) ;
extern int del_timer(struct timer_list *timer ) ;
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
extern int mod_timer_pending(struct timer_list *timer , unsigned long expires ) ;
extern unsigned long next_timer_interrupt(void) ;
extern unsigned long get_next_timer_interrupt(unsigned long now ) ;
extern void init_timer_stats(void) ;
extern void timer_stats_update_stats(void *timer , pid_t pid , void *startf , void *timerf ,
                                     char *comm , unsigned int timer_flag ) ;
extern void __timer_stats_timer_set_start_info(struct timer_list *timer , void *addr ) ;
__inline static void timer_stats_timer_set_start_info(struct timer_list *timer ) 
{ void *tmp ;

  {
  {
  tmp = __builtin_return_address(0U);
  __timer_stats_timer_set_start_info(timer, tmp);
  }
  return;
}
}
__inline static void timer_stats_timer_clear_start_info(struct timer_list *timer ) 
{ 

  {
  {
  timer->start_site = (void *)0;
  }
  return;
}
}
extern void add_timer(struct timer_list *timer ) ;
extern int try_to_del_timer_sync(struct timer_list *timer ) ;
extern int del_timer_sync(struct timer_list *timer ) ;
extern void init_timers(void) ;
extern void run_local_timers(void) ;
extern int it_real_fn(struct hrtimer * ) ;
extern unsigned long __round_jiffies(unsigned long j , int cpu ) ;
extern unsigned long __round_jiffies_relative(unsigned long j , int cpu ) ;
extern unsigned long round_jiffies(unsigned long j ) ;
extern unsigned long round_jiffies_relative(unsigned long j ) ;
extern unsigned long __round_jiffies_up(unsigned long j , int cpu ) ;
extern unsigned long __round_jiffies_up_relative(unsigned long j , int cpu ) ;
extern unsigned long round_jiffies_up(unsigned long j ) ;
extern unsigned long round_jiffies_up_relative(unsigned long j ) ;
__inline static struct delayed_work *to_delayed_work(struct work_struct *work ) 
{ struct work_struct  const  *__mptr ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  }
  return ((struct delayed_work *)((char *)__mptr - (unsigned int )(& ((struct delayed_work *)0)->work)));
}
}
extern struct workqueue_struct *__create_workqueue_key(char const   *name , int singlethread ,
                                                       int freezeable , int rt , struct lock_class_key *key ,
                                                       char const   *lock_name ) ;
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
extern int queue_work(struct workqueue_struct *wq , struct work_struct *work ) ;
extern int queue_work_on(int cpu , struct workqueue_struct *wq , struct work_struct *work ) ;
extern int queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *work ,
                              unsigned long delay ) ;
extern int queue_delayed_work_on(int cpu , struct workqueue_struct *wq , struct delayed_work *work ,
                                 unsigned long delay ) ;
extern void flush_workqueue(struct workqueue_struct *wq ) ;
extern void flush_scheduled_work(void) ;
extern int schedule_work(struct work_struct *work ) ;
extern int schedule_work_on(int cpu , struct work_struct *work ) ;
extern int schedule_delayed_work(struct delayed_work *work , unsigned long delay ) ;
extern int schedule_delayed_work_on(int cpu , struct delayed_work *work , unsigned long delay ) ;
extern int schedule_on_each_cpu(void (*func)(struct work_struct *work ) ) ;
extern int current_is_keventd(void) ;
extern int keventd_up(void) ;
extern void init_workqueues(void) ;
extern int execute_in_process_context(void (*fn)(struct work_struct *work ) , struct execute_work * ) ;
extern int flush_work(struct work_struct *work ) ;
extern int cancel_work_sync(struct work_struct *work ) ;
__inline static int cancel_delayed_work(struct delayed_work *work ) 
{ int ret ;

  {
  {
  ret = del_timer_sync(& work->timer);
  }
  if (ret) {
    {
    clear_bit(0, (unsigned long volatile   *)((unsigned long *)(& work->work.data)));
    }
  }
  return (ret);
}
}
extern int cancel_delayed_work_sync(struct delayed_work *work ) ;
__inline static void cancel_rearming_delayed_workqueue(struct workqueue_struct *wq ,
                                                       struct delayed_work *work ) 
{ 

  {
  {
  cancel_delayed_work_sync(work);
  }
  return;
}
}
__inline static void cancel_rearming_delayed_work(struct delayed_work *work ) 
{ 

  {
  {
  cancel_delayed_work_sync(work);
  }
  return;
}
}
extern long work_on_cpu(unsigned int cpu , long (*fn)(void * ) , void *arg ) ;
extern struct tracepoint __tracepoint_kmalloc ;
__inline static void trace_kmalloc(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                                   size_t bytes_alloc , gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_61_continue: /* CIL Label */ ;
      {
      while (1) {
        while_62_continue: /* CIL Label */ ;
        goto while_62_break;
      }
      while_62_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc.funcs));
      }
      {
      while (1) {
        while_63_continue: /* CIL Label */ ;
        goto while_63_break;
      }
      while_63_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_64_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
          it_func ++;
          }
          if (! *it_func) {
            goto while_64_break;
          }
        }
        while_64_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_65_continue: /* CIL Label */ ;
        goto while_65_break;
      }
      while_65_break: /* CIL Label */ ;
      }
      goto while_61_break;
    }
    while_61_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr , size_t bytes_req ,
                                                         size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmalloc", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmalloc(void (*probe)(unsigned long call_site ,
                                                           void const   *ptr , size_t bytes_req ,
                                                           size_t bytes_alloc , gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmalloc", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmem_cache_alloc ;
__inline static void trace_kmem_cache_alloc(unsigned long call_site , void const   *ptr ,
                                            size_t bytes_req , size_t bytes_alloc ,
                                            gfp_t gfp_flags ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_66_continue: /* CIL Label */ ;
      {
      while (1) {
        while_67_continue: /* CIL Label */ ;
        goto while_67_break;
      }
      while_67_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc.funcs));
      }
      {
      while (1) {
        while_68_continue: /* CIL Label */ ;
        goto while_68_break;
      }
      while_68_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_69_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags ))*it_func))(call_site,
                                                                         ptr, bytes_req,
                                                                         bytes_alloc,
                                                                         gfp_flags);
          it_func ++;
          }
          if (! *it_func) {
            goto while_69_break;
          }
        }
        while_69_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_70_continue: /* CIL Label */ ;
        goto while_70_break;
      }
      while_70_break: /* CIL Label */ ;
      }
      goto while_66_break;
    }
    while_66_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                  void const   *ptr ,
                                                                  size_t bytes_req ,
                                                                  size_t bytes_alloc ,
                                                                  gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmem_cache_alloc", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmem_cache_alloc(void (*probe)(unsigned long call_site ,
                                                                    void const   *ptr ,
                                                                    size_t bytes_req ,
                                                                    size_t bytes_alloc ,
                                                                    gfp_t gfp_flags ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmem_cache_alloc", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmalloc_node ;
__inline static void trace_kmalloc_node(unsigned long call_site , void const   *ptr ,
                                        size_t bytes_req , size_t bytes_alloc , gfp_t gfp_flags ,
                                        int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmalloc_node.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_71_continue: /* CIL Label */ ;
      {
      while (1) {
        while_72_continue: /* CIL Label */ ;
        goto while_72_break;
      }
      while_72_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmalloc_node.funcs));
      }
      {
      while (1) {
        while_73_continue: /* CIL Label */ ;
        goto while_73_break;
      }
      while_73_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_74_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
          it_func ++;
          }
          if (! *it_func) {
            goto while_74_break;
          }
        }
        while_74_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_75_continue: /* CIL Label */ ;
        goto while_75_break;
      }
      while_75_break: /* CIL Label */ ;
      }
      goto while_71_break;
    }
    while_71_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                              void const   *ptr ,
                                                              size_t bytes_req , size_t bytes_alloc ,
                                                              gfp_t gfp_flags , int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmalloc_node", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmalloc_node(void (*probe)(unsigned long call_site ,
                                                                void const   *ptr ,
                                                                size_t bytes_req ,
                                                                size_t bytes_alloc ,
                                                                gfp_t gfp_flags ,
                                                                int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmalloc_node", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmem_cache_alloc_node ;
__inline static void trace_kmem_cache_alloc_node(unsigned long call_site , void const   *ptr ,
                                                 size_t bytes_req , size_t bytes_alloc ,
                                                 gfp_t gfp_flags , int node ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_alloc_node.state)),
                         0L);
  }
  if (tmp) {
    {
    while (1) {
      while_76_continue: /* CIL Label */ ;
      {
      while (1) {
        while_77_continue: /* CIL Label */ ;
        goto while_77_break;
      }
      while_77_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_alloc_node.funcs));
      }
      {
      while (1) {
        while_78_continue: /* CIL Label */ ;
        goto while_78_break;
      }
      while_78_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_79_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr , size_t bytes_req ,
                       size_t bytes_alloc , gfp_t gfp_flags , int node ))*it_func))(call_site,
                                                                                    ptr,
                                                                                    bytes_req,
                                                                                    bytes_alloc,
                                                                                    gfp_flags,
                                                                                    node);
          it_func ++;
          }
          if (! *it_func) {
            goto while_79_break;
          }
        }
        while_79_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_80_continue: /* CIL Label */ ;
        goto while_80_break;
      }
      while_80_break: /* CIL Label */ ;
      }
      goto while_76_break;
    }
    while_76_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                       void const   *ptr ,
                                                                       size_t bytes_req ,
                                                                       size_t bytes_alloc ,
                                                                       gfp_t gfp_flags ,
                                                                       int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmem_cache_alloc_node", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmem_cache_alloc_node(void (*probe)(unsigned long call_site ,
                                                                         void const   *ptr ,
                                                                         size_t bytes_req ,
                                                                         size_t bytes_alloc ,
                                                                         gfp_t gfp_flags ,
                                                                         int node ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmem_cache_alloc_node", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kfree ;
__inline static void trace_kfree(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kfree.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_81_continue: /* CIL Label */ ;
      {
      while (1) {
        while_82_continue: /* CIL Label */ ;
        goto while_82_break;
      }
      while_82_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kfree.funcs));
      }
      {
      while (1) {
        while_83_continue: /* CIL Label */ ;
        goto while_83_break;
      }
      while_83_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_84_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
          it_func ++;
          }
          if (! *it_func) {
            goto while_84_break;
          }
        }
        while_84_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_85_continue: /* CIL Label */ ;
        goto while_85_break;
      }
      while_85_break: /* CIL Label */ ;
      }
      goto while_81_break;
    }
    while_81_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kfree(void (*probe)(unsigned long call_site , void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kfree", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kfree(void (*probe)(unsigned long call_site ,
                                                         void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kfree", (void *)probe);
  }
  return (tmp);
}
}
extern struct tracepoint __tracepoint_kmem_cache_free ;
__inline static void trace_kmem_cache_free(unsigned long call_site , void const   *ptr ) 
{ void **it_func ;
  void **_________p1 ;
  long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! __tracepoint_kmem_cache_free.state)), 0L);
  }
  if (tmp) {
    {
    while (1) {
      while_86_continue: /* CIL Label */ ;
      {
      while (1) {
        while_87_continue: /* CIL Label */ ;
        goto while_87_break;
      }
      while_87_break: /* CIL Label */ ;
      }
      {
      _________p1 = (void **)*((void ** volatile  *)(& __tracepoint_kmem_cache_free.funcs));
      }
      {
      while (1) {
        while_88_continue: /* CIL Label */ ;
        goto while_88_break;
      }
      while_88_break: /* CIL Label */ ;
      }
      {
      it_func = _________p1;
      }
      if (it_func) {
        {
        while (1) {
          while_89_continue: /* CIL Label */ ;
          {
          (*((void (*)(unsigned long call_site , void const   *ptr ))*it_func))(call_site,
                                                                                ptr);
          it_func ++;
          }
          if (! *it_func) {
            goto while_89_break;
          }
        }
        while_89_break: /* CIL Label */ ;
        }
      }
      {
      while (1) {
        while_90_continue: /* CIL Label */ ;
        goto while_90_break;
      }
      while_90_break: /* CIL Label */ ;
      }
      goto while_86_break;
    }
    while_86_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int register_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                 void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_register("kmem_cache_free", (void *)probe);
  }
  return (tmp);
}
}
__inline static int unregister_trace_kmem_cache_free(void (*probe)(unsigned long call_site ,
                                                                   void const   *ptr ) ) 
{ int tmp ;

  {
  {
  tmp = tracepoint_probe_unregister("kmem_cache_free", (void *)probe);
  }
  return (tmp);
}
}
extern struct kmem_cache kmalloc_caches[14] ;
__inline static int kmalloc_index(size_t size ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;

  {
  if (! size) {
    return (0);
  }
  if (size <= 8U) {
    if (8ULL & (1ULL << 63)) {
      {
      tmp___63 = 63;
      }
    } else {
      if (8ULL & (1ULL << 62)) {
        {
        tmp___62 = 62;
        }
      } else {
        if (8ULL & (1ULL << 61)) {
          {
          tmp___61 = 61;
          }
        } else {
          if (8ULL & (1ULL << 60)) {
            {
            tmp___60 = 60;
            }
          } else {
            if (8ULL & (1ULL << 59)) {
              {
              tmp___59 = 59;
              }
            } else {
              if (8ULL & (1ULL << 58)) {
                {
                tmp___58 = 58;
                }
              } else {
                if (8ULL & (1ULL << 57)) {
                  {
                  tmp___57 = 57;
                  }
                } else {
                  if (8ULL & (1ULL << 56)) {
                    {
                    tmp___56 = 56;
                    }
                  } else {
                    if (8ULL & (1ULL << 55)) {
                      {
                      tmp___55 = 55;
                      }
                    } else {
                      if (8ULL & (1ULL << 54)) {
                        {
                        tmp___54 = 54;
                        }
                      } else {
                        if (8ULL & (1ULL << 53)) {
                          {
                          tmp___53 = 53;
                          }
                        } else {
                          if (8ULL & (1ULL << 52)) {
                            {
                            tmp___52 = 52;
                            }
                          } else {
                            if (8ULL & (1ULL << 51)) {
                              {
                              tmp___51 = 51;
                              }
                            } else {
                              if (8ULL & (1ULL << 50)) {
                                {
                                tmp___50 = 50;
                                }
                              } else {
                                if (8ULL & (1ULL << 49)) {
                                  {
                                  tmp___49 = 49;
                                  }
                                } else {
                                  if (8ULL & (1ULL << 48)) {
                                    {
                                    tmp___48 = 48;
                                    }
                                  } else {
                                    if (8ULL & (1ULL << 47)) {
                                      {
                                      tmp___47 = 47;
                                      }
                                    } else {
                                      if (8ULL & (1ULL << 46)) {
                                        {
                                        tmp___46 = 46;
                                        }
                                      } else {
                                        if (8ULL & (1ULL << 45)) {
                                          {
                                          tmp___45 = 45;
                                          }
                                        } else {
                                          if (8ULL & (1ULL << 44)) {
                                            {
                                            tmp___44 = 44;
                                            }
                                          } else {
                                            if (8ULL & (1ULL << 43)) {
                                              {
                                              tmp___43 = 43;
                                              }
                                            } else {
                                              if (8ULL & (1ULL << 42)) {
                                                {
                                                tmp___42 = 42;
                                                }
                                              } else {
                                                if (8ULL & (1ULL << 41)) {
                                                  {
                                                  tmp___41 = 41;
                                                  }
                                                } else {
                                                  if (8ULL & (1ULL << 40)) {
                                                    {
                                                    tmp___40 = 40;
                                                    }
                                                  } else {
                                                    if (8ULL & (1ULL << 39)) {
                                                      {
                                                      tmp___39 = 39;
                                                      }
                                                    } else {
                                                      if (8ULL & (1ULL << 38)) {
                                                        {
                                                        tmp___38 = 38;
                                                        }
                                                      } else {
                                                        if (8ULL & (1ULL << 37)) {
                                                          {
                                                          tmp___37 = 37;
                                                          }
                                                        } else {
                                                          if (8ULL & (1ULL << 36)) {
                                                            {
                                                            tmp___36 = 36;
                                                            }
                                                          } else {
                                                            if (8ULL & (1ULL << 35)) {
                                                              {
                                                              tmp___35 = 35;
                                                              }
                                                            } else {
                                                              if (8ULL & (1ULL << 34)) {
                                                                {
                                                                tmp___34 = 34;
                                                                }
                                                              } else {
                                                                if (8ULL & (1ULL << 33)) {
                                                                  {
                                                                  tmp___33 = 33;
                                                                  }
                                                                } else {
                                                                  if (8ULL & (1ULL << 32)) {
                                                                    {
                                                                    tmp___32 = 32;
                                                                    }
                                                                  } else {
                                                                    if (8ULL & (1ULL << 31)) {
                                                                      {
                                                                      tmp___31 = 31;
                                                                      }
                                                                    } else {
                                                                      if (8ULL & (1ULL << 30)) {
                                                                        {
                                                                        tmp___30 = 30;
                                                                        }
                                                                      } else {
                                                                        if (8ULL & (1ULL << 29)) {
                                                                          {
                                                                          tmp___29 = 29;
                                                                          }
                                                                        } else {
                                                                          if (8ULL & (1ULL << 28)) {
                                                                            {
                                                                            tmp___28 = 28;
                                                                            }
                                                                          } else {
                                                                            if (8ULL & (1ULL << 27)) {
                                                                              {
                                                                              tmp___27 = 27;
                                                                              }
                                                                            } else {
                                                                              if (8ULL & (1ULL << 26)) {
                                                                                {
                                                                                tmp___26 = 26;
                                                                                }
                                                                              } else {
                                                                                if (8ULL & (1ULL << 25)) {
                                                                                  {
                                                                                  tmp___25 = 25;
                                                                                  }
                                                                                } else {
                                                                                  if (8ULL & (1ULL << 24)) {
                                                                                    {
                                                                                    tmp___24 = 24;
                                                                                    }
                                                                                  } else {
                                                                                    if (8ULL & (1ULL << 23)) {
                                                                                      {
                                                                                      tmp___23 = 23;
                                                                                      }
                                                                                    } else {
                                                                                      if (8ULL & (1ULL << 22)) {
                                                                                        {
                                                                                        tmp___22 = 22;
                                                                                        }
                                                                                      } else {
                                                                                        if (8ULL & (1ULL << 21)) {
                                                                                          {
                                                                                          tmp___21 = 21;
                                                                                          }
                                                                                        } else {
                                                                                          if (8ULL & (1ULL << 20)) {
                                                                                            {
                                                                                            tmp___20 = 20;
                                                                                            }
                                                                                          } else {
                                                                                            if (8ULL & (1ULL << 19)) {
                                                                                              {
                                                                                              tmp___19 = 19;
                                                                                              }
                                                                                            } else {
                                                                                              if (8ULL & (1ULL << 18)) {
                                                                                                {
                                                                                                tmp___18 = 18;
                                                                                                }
                                                                                              } else {
                                                                                                if (8ULL & (1ULL << 17)) {
                                                                                                  {
                                                                                                  tmp___17 = 17;
                                                                                                  }
                                                                                                } else {
                                                                                                  if (8ULL & (1ULL << 16)) {
                                                                                                    {
                                                                                                    tmp___16 = 16;
                                                                                                    }
                                                                                                  } else {
                                                                                                    if (8ULL & (1ULL << 15)) {
                                                                                                      {
                                                                                                      tmp___15 = 15;
                                                                                                      }
                                                                                                    } else {
                                                                                                      if (8ULL & (1ULL << 14)) {
                                                                                                        {
                                                                                                        tmp___14 = 14;
                                                                                                        }
                                                                                                      } else {
                                                                                                        if (8ULL & (1ULL << 13)) {
                                                                                                          {
                                                                                                          tmp___13 = 13;
                                                                                                          }
                                                                                                        } else {
                                                                                                          if (8ULL & (1ULL << 12)) {
                                                                                                            {
                                                                                                            tmp___12 = 12;
                                                                                                            }
                                                                                                          } else {
                                                                                                            if (8ULL & (1ULL << 11)) {
                                                                                                              {
                                                                                                              tmp___11 = 11;
                                                                                                              }
                                                                                                            } else {
                                                                                                              if (8ULL & (1ULL << 10)) {
                                                                                                                {
                                                                                                                tmp___10 = 10;
                                                                                                                }
                                                                                                              } else {
                                                                                                                if (8ULL & (1ULL << 9)) {
                                                                                                                  {
                                                                                                                  tmp___9 = 9;
                                                                                                                  }
                                                                                                                } else {
                                                                                                                  if (8ULL & (1ULL << 8)) {
                                                                                                                    {
                                                                                                                    tmp___8 = 8;
                                                                                                                    }
                                                                                                                  } else {
                                                                                                                    if (8ULL & (1ULL << 7)) {
                                                                                                                      {
                                                                                                                      tmp___7 = 7;
                                                                                                                      }
                                                                                                                    } else {
                                                                                                                      if (8ULL & (1ULL << 6)) {
                                                                                                                        {
                                                                                                                        tmp___6 = 6;
                                                                                                                        }
                                                                                                                      } else {
                                                                                                                        if (8ULL & (1ULL << 5)) {
                                                                                                                          {
                                                                                                                          tmp___5 = 5;
                                                                                                                          }
                                                                                                                        } else {
                                                                                                                          if (8ULL & (1ULL << 4)) {
                                                                                                                            {
                                                                                                                            tmp___4 = 4;
                                                                                                                            }
                                                                                                                          } else {
                                                                                                                            if (8ULL & (1ULL << 3)) {
                                                                                                                              {
                                                                                                                              tmp___3 = 3;
                                                                                                                              }
                                                                                                                            } else {
                                                                                                                              if (8ULL & (1ULL << 2)) {
                                                                                                                                {
                                                                                                                                tmp___2 = 2;
                                                                                                                                }
                                                                                                                              } else {
                                                                                                                                if (8ULL & (1ULL << 1)) {
                                                                                                                                  {
                                                                                                                                  tmp___1 = 1;
                                                                                                                                  }
                                                                                                                                } else {
                                                                                                                                  {
                                                                                                                                  tmp___0 = ____ilog2_NaN();
                                                                                                                                  tmp___1 = tmp___0;
                                                                                                                                  }
                                                                                                                                }
                                                                                                                                {
                                                                                                                                tmp___2 = tmp___1;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              {
                                                                                                                              tmp___3 = tmp___2;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            {
                                                                                                                            tmp___4 = tmp___3;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          {
                                                                                                                          tmp___5 = tmp___4;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        {
                                                                                                                        tmp___6 = tmp___5;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      {
                                                                                                                      tmp___7 = tmp___6;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    {
                                                                                                                    tmp___8 = tmp___7;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  {
                                                                                                                  tmp___9 = tmp___8;
                                                                                                                  }
                                                                                                                }
                                                                                                                {
                                                                                                                tmp___10 = tmp___9;
                                                                                                                }
                                                                                                              }
                                                                                                              {
                                                                                                              tmp___11 = tmp___10;
                                                                                                              }
                                                                                                            }
                                                                                                            {
                                                                                                            tmp___12 = tmp___11;
                                                                                                            }
                                                                                                          }
                                                                                                          {
                                                                                                          tmp___13 = tmp___12;
                                                                                                          }
                                                                                                        }
                                                                                                        {
                                                                                                        tmp___14 = tmp___13;
                                                                                                        }
                                                                                                      }
                                                                                                      {
                                                                                                      tmp___15 = tmp___14;
                                                                                                      }
                                                                                                    }
                                                                                                    {
                                                                                                    tmp___16 = tmp___15;
                                                                                                    }
                                                                                                  }
                                                                                                  {
                                                                                                  tmp___17 = tmp___16;
                                                                                                  }
                                                                                                }
                                                                                                {
                                                                                                tmp___18 = tmp___17;
                                                                                                }
                                                                                              }
                                                                                              {
                                                                                              tmp___19 = tmp___18;
                                                                                              }
                                                                                            }
                                                                                            {
                                                                                            tmp___20 = tmp___19;
                                                                                            }
                                                                                          }
                                                                                          {
                                                                                          tmp___21 = tmp___20;
                                                                                          }
                                                                                        }
                                                                                        {
                                                                                        tmp___22 = tmp___21;
                                                                                        }
                                                                                      }
                                                                                      {
                                                                                      tmp___23 = tmp___22;
                                                                                      }
                                                                                    }
                                                                                    {
                                                                                    tmp___24 = tmp___23;
                                                                                    }
                                                                                  }
                                                                                  {
                                                                                  tmp___25 = tmp___24;
                                                                                  }
                                                                                }
                                                                                {
                                                                                tmp___26 = tmp___25;
                                                                                }
                                                                              }
                                                                              {
                                                                              tmp___27 = tmp___26;
                                                                              }
                                                                            }
                                                                            {
                                                                            tmp___28 = tmp___27;
                                                                            }
                                                                          }
                                                                          {
                                                                          tmp___29 = tmp___28;
                                                                          }
                                                                        }
                                                                        {
                                                                        tmp___30 = tmp___29;
                                                                        }
                                                                      }
                                                                      {
                                                                      tmp___31 = tmp___30;
                                                                      }
                                                                    }
                                                                    {
                                                                    tmp___32 = tmp___31;
                                                                    }
                                                                  }
                                                                  {
                                                                  tmp___33 = tmp___32;
                                                                  }
                                                                }
                                                                {
                                                                tmp___34 = tmp___33;
                                                                }
                                                              }
                                                              {
                                                              tmp___35 = tmp___34;
                                                              }
                                                            }
                                                            {
                                                            tmp___36 = tmp___35;
                                                            }
                                                          }
                                                          {
                                                          tmp___37 = tmp___36;
                                                          }
                                                        }
                                                        {
                                                        tmp___38 = tmp___37;
                                                        }
                                                      }
                                                      {
                                                      tmp___39 = tmp___38;
                                                      }
                                                    }
                                                    {
                                                    tmp___40 = tmp___39;
                                                    }
                                                  }
                                                  {
                                                  tmp___41 = tmp___40;
                                                  }
                                                }
                                                {
                                                tmp___42 = tmp___41;
                                                }
                                              }
                                              {
                                              tmp___43 = tmp___42;
                                              }
                                            }
                                            {
                                            tmp___44 = tmp___43;
                                            }
                                          }
                                          {
                                          tmp___45 = tmp___44;
                                          }
                                        }
                                        {
                                        tmp___46 = tmp___45;
                                        }
                                      }
                                      {
                                      tmp___47 = tmp___46;
                                      }
                                    }
                                    {
                                    tmp___48 = tmp___47;
                                    }
                                  }
                                  {
                                  tmp___49 = tmp___48;
                                  }
                                }
                                {
                                tmp___50 = tmp___49;
                                }
                              }
                              {
                              tmp___51 = tmp___50;
                              }
                            }
                            {
                            tmp___52 = tmp___51;
                            }
                          }
                          {
                          tmp___53 = tmp___52;
                          }
                        }
                        {
                        tmp___54 = tmp___53;
                        }
                      }
                      {
                      tmp___55 = tmp___54;
                      }
                    }
                    {
                    tmp___56 = tmp___55;
                    }
                  }
                  {
                  tmp___57 = tmp___56;
                  }
                }
                {
                tmp___58 = tmp___57;
                }
              }
              {
              tmp___59 = tmp___58;
              }
            }
            {
            tmp___60 = tmp___59;
            }
          }
          {
          tmp___61 = tmp___60;
          }
        }
        {
        tmp___62 = tmp___61;
        }
      }
      {
      tmp___63 = tmp___62;
      }
    }
    return (tmp___63);
  }
  if (size > 64U) {
    if (size <= 96U) {
      return (1);
    }
  }
  if (size > 128U) {
    if (size <= 192U) {
      return (2);
    }
  }
  if (size <= 8U) {
    return (3);
  }
  if (size <= 16U) {
    return (4);
  }
  if (size <= 32U) {
    return (5);
  }
  if (size <= 64U) {
    return (6);
  }
  if (size <= 128U) {
    return (7);
  }
  if (size <= 256U) {
    return (8);
  }
  if (size <= 512U) {
    return (9);
  }
  if (size <= 1024U) {
    return (10);
  }
  if (size <= 2048U) {
    return (11);
  }
  if (size <= 4096U) {
    return (12);
  }
  if (size <= 8192U) {
    return (13);
  }
  if (size <= 16384U) {
    return (14);
  }
  if (size <= 32768U) {
    return (15);
  }
  if (size <= 65536U) {
    return (16);
  }
  if (size <= 131072U) {
    return (17);
  }
  if (size <= 262144U) {
    return (18);
  }
  if (size <= 524288U) {
    return (19);
  }
  if (size <= 1048576U) {
    return (20);
  }
  if (size <= 2097152U) {
    return (21);
  }
  return (-1);
}
}
__inline static struct kmem_cache *kmalloc_slab(size_t size ) 
{ int index___0 ;
  int tmp ;

  {
  {
  tmp = kmalloc_index(size);
  index___0 = tmp;
  }
  if (index___0 == 0) {
    return ((struct kmem_cache *)((void *)0));
  }
  return (& kmalloc_caches[index___0]);
}
}
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
extern void *__kmalloc(size_t size , gfp_t flags ) ;
__inline static void *kmem_cache_alloc_notrace(struct kmem_cache *s , gfp_t gfpflags ) 
{ void *tmp ;

  {
  {
  tmp = kmem_cache_alloc(s, gfpflags);
  }
  return (tmp);
}
}
__inline static void *kmalloc_large(size_t size , gfp_t flags ) 
{ unsigned int order ;
  int tmp ;
  void *ret ;
  unsigned long tmp___0 ;

  {
  {
  tmp = get_order((unsigned long )size);
  order = (unsigned int )tmp;
  tmp___0 = __get_free_pages(flags | 16384U, order);
  ret = (void *)tmp___0;
  }
  __here: 
  {
  trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )((1UL << 12) << order),
                flags);
  }
  return (ret);
}
}
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ void *ret ;
  void *tmp ;
  struct kmem_cache *s ;
  struct kmem_cache *tmp___0 ;
  void *tmp___1 ;

  {
  if (0) {
    if ((unsigned long )size > 2UL * (1UL << 12)) {
      {
      tmp = kmalloc_large(size, flags);
      }
      return (tmp);
    }
    if (! (flags & 1U)) {
      {
      tmp___0 = kmalloc_slab(size);
      s = tmp___0;
      }
      if (! s) {
        return ((void *)16);
      }
      {
      ret = kmem_cache_alloc_notrace(s, flags);
      }
      __here: 
      {
      trace_kmalloc((unsigned long )((void *)0), (void const   *)ret, size, (unsigned int )s->size,
                    flags);
      }
      return (ret);
    }
  }
  {
  tmp___1 = __kmalloc(size, flags);
  }
  return (tmp___1);
}
}
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  if (size != 0U) {
    if ((unsigned long )n > 0xffffffffUL / (unsigned long )size) {
      return ((void *)0);
    }
  }
  {
  tmp = __kmalloc(n * size, flags | 32768U);
  }
  return (tmp);
}
}
__inline static void *kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags);
  }
  return (tmp);
}
}
__inline static void *__kmalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
  tmp = __kmalloc(size, flags);
  }
  return (tmp);
}
}
__inline static void *kmem_cache_alloc_node(struct kmem_cache *cachep , gfp_t flags ,
                                            int node ) 
{ void *tmp ;

  {
  {
  tmp = kmem_cache_alloc(cachep, flags);
  }
  return (tmp);
}
}
extern void *__kmalloc_track_caller(size_t  , gfp_t  , unsigned long  ) ;
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmem_cache_alloc(k, flags | 32768U);
  }
  return (tmp);
}
}
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ void *tmp ;

  {
  {
  tmp = kmalloc_node(size, flags | 32768U, node);
  }
  return (tmp);
}
}
extern void *pcpu_base_addr ;
extern size_t pcpu_setup_first_chunk(struct page *(*get_page_fn)(unsigned int cpu ,
                                                                 int pageno ) , size_t static_size ,
                                     size_t reserved_size , ssize_t dyn_size , ssize_t unit_size ,
                                     void *base_addr , void (*populate_pte_fn)(unsigned long addr ) )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern ssize_t pcpu_embed_first_chunk(size_t static_size , size_t reserved_size ,
                                      ssize_t dyn_size , ssize_t unit_size )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern void *__alloc_reserved_percpu(size_t size , size_t align ) ;
extern void *__alloc_percpu(size_t size , size_t align ) ;
extern void free_percpu(void *__pdata ) ;
__inline static void local_inc(local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
  return;
}
}
__inline static void local_dec(local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0": "+m" (l->a.counter));
  }
  return;
}
}
__inline static void local_add(long i , local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
  return;
}
}
__inline static void local_sub(long i , local_t *l ) 
{ 

  {
  {
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%1,%0": "+m" (l->a.counter): "ir" (i));
  }
  return;
}
}
__inline static int local_sub_and_test(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "subl"
                       " "
                       "%2,%0; sete %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static int local_dec_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "decl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int local_inc_and_test(local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "incl"
                       " "
                       "%0; sete %1": "+m" (l->a.counter), "=qm" (c): : "memory");
  }
  return ((int )c != 0);
}
}
__inline static int local_add_negative(long i , local_t *l ) 
{ unsigned char c ;

  {
  {
  __asm__  volatile   (" "
                       "addl"
                       " "
                       "%2,%0; sets %1": "+m" (l->a.counter), "=qm" (c): "ir" (i): "memory");
  }
  return ((int )c);
}
}
__inline static long local_add_return(long i , local_t *l ) 
{ long __i ;

  {
  {
  __i = i;
  __asm__  volatile   (" "
                       "xaddl"
                       " "
                       "%0, %1;": "+r" (i), "+m" (l->a.counter): : "memory");
  }
  return (i + __i);
}
}
__inline static long local_sub_return(long i , local_t *l ) 
{ long tmp ;

  {
  {
  tmp = local_add_return(- i, l);
  }
  return (tmp);
}
}
extern int init_module(void) ;
extern void cleanup_module(void) ;
extern struct exception_table_entry  const  *search_extable(struct exception_table_entry  const  *first ,
                                                            struct exception_table_entry  const  *last ,
                                                            unsigned long value ) ;
extern void sort_extable(struct exception_table_entry *start , struct exception_table_entry *finish ) ;
extern void sort_main_extable(void) ;
extern struct exception_table_entry  const  *search_exception_tables(unsigned long add ) ;
extern void *__symbol_get(char const   *symbol ) ;
extern void *__symbol_get_gpl(char const   *symbol ) ;
extern struct mutex module_mutex ;
__inline static int module_is_live(struct module *mod ) 
{ 

  {
  return ((unsigned int )mod->state != 2U);
}
}
extern struct module *__module_text_address(unsigned long addr ) ;
extern struct module *__module_address(unsigned long addr ) ;
extern bool is_module_address(unsigned long addr ) ;
extern bool is_module_text_address(unsigned long addr ) ;
__inline static int within_module_core(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
  if ((unsigned long )mod->module_core <= addr) {
    if (addr < (unsigned long )mod->module_core + (unsigned long )mod->core_size) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int within_module_init(unsigned long addr , struct module *mod ) 
{ int tmp ;

  {
  if ((unsigned long )mod->module_init <= addr) {
    if (addr < (unsigned long )mod->module_init + (unsigned long )mod->init_size) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern struct module *find_module(char const   *name ) ;
extern struct kernel_symbol  const  *find_symbol(char const   *name , struct module **owner ,
                                                 unsigned long const   **crc , bool gplok ,
                                                 bool warn ) ;
extern bool each_symbol(bool (*fn)(struct symsearch  const  *arr , struct module *owner ,
                                   unsigned int symnum , void *data ) , void *data ) ;
extern int module_get_kallsym(unsigned int symnum , unsigned long *value , char *type ,
                              char *name , char *module_name , int *exported ) ;
extern unsigned long module_kallsyms_lookup_name(char const   *name ) ;
extern int module_kallsyms_on_each_symbol(int (*fn)(void * , char const   * , struct module * ,
                                                    unsigned long  ) , void *data ) ;
extern  __attribute__((__noreturn__)) void __module_put_and_exit(struct module *mod ,
                                                                 long code ) ;
extern unsigned int module_refcount(struct module *mod ) ;
extern void __symbol_put(char const   *symbol ) ;
extern void symbol_put_addr(void *addr ) ;
__inline static local_t *__module_ref_addr(struct module *mod , int cpu ) 
{ 

  {
  return ((local_t *)(mod->refptr + __per_cpu_offset[cpu]));
}
}
__inline static void __module_get(struct module *module ) 
{ int ret__ ;
  local_t *tmp ;

  {
  if (module) {
    {
    while (1) {
      while_91_continue: /* CIL Label */ ;
      goto while_91_break;
    }
    while_91_break: /* CIL Label */ ;
    }
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_92_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_92_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_92_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_92_8;
          } else {
            {
            goto switch_92_default;
            if (0) {
              switch_92_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_92_break;
              switch_92_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_92_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    tmp = __module_ref_addr(module, ret__);
    local_inc(tmp);
    }
    {
    while (1) {
      while_93_continue: /* CIL Label */ ;
      goto while_93_break;
    }
    while_93_break: /* CIL Label */ ;
    }
  }
  return;
}
}
__inline static int try_module_get(struct module *module ) 
{ int ret ;
  unsigned int cpu ;
  int ret__ ;
  local_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  ret = 1;
  }
  if (module) {
    {
    while (1) {
      while_94_continue: /* CIL Label */ ;
      goto while_94_break;
    }
    while_94_break: /* CIL Label */ ;
    }
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_95_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_95_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_95_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_95_8;
          } else {
            {
            goto switch_95_default;
            if (0) {
              switch_95_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_95_break;
              switch_95_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_95_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    cpu = (unsigned int )ret__;
    tmp___0 = module_is_live(module);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 1L);
    }
    if (tmp___2) {
      {
      tmp = __module_ref_addr(module, (int )cpu);
      local_inc(tmp);
      }
    } else {
      {
      ret = 0;
      }
    }
    {
    while (1) {
      while_96_continue: /* CIL Label */ ;
      goto while_96_break;
    }
    while_96_break: /* CIL Label */ ;
    }
  }
  return (ret);
}
}
extern void module_put(struct module *module ) ;
extern int use_module(struct module *a , struct module *b ) ;
extern char const   *module_address_lookup(unsigned long addr , unsigned long *symbolsize ,
                                           unsigned long *offset , char **modname ,
                                           char *namebuf ) ;
extern int lookup_module_symbol_name(unsigned long addr , char *symname ) ;
extern int lookup_module_symbol_attrs(unsigned long addr , unsigned long *size , unsigned long *offset ,
                                      char *modname , char *name ) ;
extern struct exception_table_entry  const  *search_module_extables(unsigned long addr ) ;
extern int register_module_notifier(struct notifier_block *nb ) ;
extern int unregister_module_notifier(struct notifier_block *nb ) ;
extern void print_modules(void) ;
extern void module_update_markers(void) ;
extern void module_update_tracepoints(void) ;
extern int module_get_iter_tracepoints(struct tracepoint_iter *iter ) ;
extern struct kset *module_kset ;
extern struct kobj_type module_ktype ;
extern int module_sysfs_initialized ;
extern int mod_sysfs_init(struct module *mod ) ;
extern int mod_sysfs_setup(struct module *mod , struct kernel_param *kparam , unsigned int num_params ) ;
extern int module_add_modinfo_attrs(struct module *mod ) ;
extern void module_remove_modinfo_attrs(struct module *mod ) ;
static struct lock_class_key __key  ;
__inline static void sema_init(struct semaphore *sem , int val ) 
{ struct semaphore __constr_expr_0 ;

  {
  {
  __constr_expr_0.lock.raw_lock.slock = 0U;
  __constr_expr_0.count = (unsigned int )val;
  __constr_expr_0.wait_list.next = & sem->wait_list;
  __constr_expr_0.wait_list.prev = & sem->wait_list;
  *sem = __constr_expr_0;
  }
  {
  while (1) {
    while_97_continue: /* CIL Label */ ;
    goto while_97_break;
  }
  while_97_break: /* CIL Label */ ;
  }
  return;
}
}
extern void down(struct semaphore *sem ) ;
extern int down_interruptible(struct semaphore *sem ) ;
extern int down_killable(struct semaphore *sem ) ;
extern int down_trylock(struct semaphore *sem ) ;
extern int down_timeout(struct semaphore *sem , long jiffies ) ;
extern void up(struct semaphore *sem ) ;
extern int bus_create_file(struct bus_type * , struct bus_attribute * ) ;
extern void bus_remove_file(struct bus_type * , struct bus_attribute * ) ;
extern int bus_register(struct bus_type *bus ) ;
extern void bus_unregister(struct bus_type *bus ) ;
extern int bus_rescan_devices(struct bus_type *bus ) ;
extern int bus_for_each_dev(struct bus_type *bus , struct device *start , void *data ,
                            int (*fn)(struct device *dev , void *data ) ) ;
extern struct device *bus_find_device(struct bus_type *bus , struct device *start ,
                                      void *data , int (*match)(struct device *dev ,
                                                                void *data ) ) ;
extern struct device *bus_find_device_by_name(struct bus_type *bus , struct device *start ,
                                              char const   *name ) ;
extern int bus_for_each_drv(struct bus_type *bus , struct device_driver *start , void *data ,
                            int (*fn)(struct device_driver * , void * ) ) ;
extern void bus_sort_breadthfirst(struct bus_type *bus , int (*compare)(struct device  const  *a ,
                                                                        struct device  const  *b ) ) ;
extern int bus_register_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
extern int bus_unregister_notifier(struct bus_type *bus , struct notifier_block *nb ) ;
extern struct kset *bus_get_kset(struct bus_type *bus ) ;
extern struct klist *bus_get_device_klist(struct bus_type *bus ) ;
extern int driver_register(struct device_driver *drv ) ;
extern void driver_unregister(struct device_driver *drv ) ;
extern struct device_driver *get_driver(struct device_driver *drv ) ;
extern void put_driver(struct device_driver *drv ) ;
extern struct device_driver *driver_find(char const   *name , struct bus_type *bus ) ;
extern int driver_probe_done(void) ;
extern void wait_for_device_probe(void) ;
extern int driver_create_file(struct device_driver *driver , struct driver_attribute *attr ) ;
extern void driver_remove_file(struct device_driver *driver , struct driver_attribute *attr ) ;
extern int driver_add_kobj(struct device_driver *drv , struct kobject *kobj , char const   *fmt 
                           , ...) ;
extern int driver_for_each_device(struct device_driver *drv , struct device *start ,
                                  void *data , int (*fn)(struct device *dev , void * ) ) ;
extern struct device *driver_find_device(struct device_driver *drv , struct device *start ,
                                         void *data , int (*match)(struct device *dev ,
                                                                   void *data ) ) ;
extern struct kobject *sysfs_dev_block_kobj ;
extern struct kobject *sysfs_dev_char_kobj ;
extern int __class_register(struct class *class , struct lock_class_key *key ) ;
extern void class_unregister(struct class *class ) ;
extern void class_dev_iter_init(struct class_dev_iter *iter , struct class *class ,
                                struct device *start , struct device_type  const  *type ) ;
extern struct device *class_dev_iter_next(struct class_dev_iter *iter ) ;
extern void class_dev_iter_exit(struct class_dev_iter *iter ) ;
extern int class_for_each_device(struct class *class , struct device *start , void *data ,
                                 int (*fn)(struct device *dev , void *data ) ) ;
extern struct device *class_find_device(struct class *class , struct device *start ,
                                        void *data , int (*match)(struct device * ,
                                                                  void * ) ) ;
extern int class_create_file(struct class *class , struct class_attribute  const  *attr ) ;
extern void class_remove_file(struct class *class , struct class_attribute  const  *attr ) ;
extern int class_interface_register(struct class_interface * ) ;
extern void class_interface_unregister(struct class_interface * ) ;
extern struct class *__class_create(struct module *owner , char const   *name , struct lock_class_key *key ) ;
extern void class_destroy(struct class *cls ) ;
extern int device_create_file(struct device *device , struct device_attribute *entry ) ;
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
extern int device_create_bin_file(struct device *dev , struct bin_attribute *attr ) ;
extern void device_remove_bin_file(struct device *dev , struct bin_attribute *attr ) ;
extern int device_schedule_callback_owner(struct device *dev , void (*func)(struct device *dev ) ,
                                          struct module *owner ) ;
extern void *__devres_alloc(void (*release)(struct device *dev , void *res ) , size_t size ,
                            gfp_t gfp , char const   *name ) ;
extern void devres_free(void *res ) ;
extern void devres_add(struct device *dev , void *res ) ;
extern void *devres_find(struct device *dev , void (*release)(struct device *dev ,
                                                              void *res ) , int (*match)(struct device *dev ,
                                                                                         void *res ,
                                                                                         void *match_data ) ,
                         void *match_data ) ;
extern void *devres_get(struct device *dev , void *new_res , int (*match)(struct device *dev ,
                                                                          void *res ,
                                                                          void *match_data ) ,
                        void *match_data ) ;
extern void *devres_remove(struct device *dev , void (*release)(struct device *dev ,
                                                                void *res ) , int (*match)(struct device *dev ,
                                                                                           void *res ,
                                                                                           void *match_data ) ,
                           void *match_data ) ;
extern int devres_destroy(struct device *dev , void (*release)(struct device *dev ,
                                                               void *res ) , int (*match)(struct device *dev ,
                                                                                          void *res ,
                                                                                          void *match_data ) ,
                          void *match_data ) ;
extern void *devres_open_group(struct device *dev , void *id , gfp_t gfp ) ;
extern void devres_close_group(struct device *dev , void *id ) ;
extern void devres_remove_group(struct device *dev , void *id ) ;
extern int devres_release_group(struct device *dev , void *id ) ;
extern void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) ;
extern void devm_kfree(struct device *dev , void *p ) ;
__inline static void device_init_wakeup(struct device *dev , int val ) 
{ unsigned int tmp ;

  {
  {
  tmp = (unsigned int )(! (! val));
  dev->power.should_wakeup = tmp;
  dev->power.can_wakeup = tmp;
  }
  return;
}
}
__inline static void device_set_wakeup_capable(struct device *dev , int val ) 
{ 

  {
  {
  dev->power.can_wakeup = (unsigned int )(! (! val));
  }
  return;
}
}
__inline static int device_can_wakeup(struct device *dev ) 
{ 

  {
  return ((int )dev->power.can_wakeup);
}
}
__inline static void device_set_wakeup_enable(struct device *dev , int val ) 
{ 

  {
  {
  dev->power.should_wakeup = (unsigned int )(! (! val));
  }
  return;
}
}
__inline static int device_may_wakeup(struct device *dev ) 
{ int tmp ;

  {
  if (dev->power.can_wakeup) {
    if (dev->power.should_wakeup) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static char const   *dev_name(struct device  const  *dev ) 
{ char const   *tmp ;

  {
  {
  tmp = kobject_name(& dev->kobj);
  }
  return (tmp);
}
}
extern int ( /* format attribute */  dev_set_name)(struct device *dev , char const   *name 
                                                   , ...) ;
__inline static int dev_to_node(struct device *dev ) 
{ 

  {
  return (-1);
}
}
__inline static void set_dev_node(struct device *dev , int node ) 
{ 

  {
  return;
}
}
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 

  {
  return ((void *)dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 

  {
  {
  dev->driver_data = data;
  }
  return;
}
}
__inline static unsigned int dev_get_uevent_suppress(struct device  const  *dev ) 
{ 

  {
  return ((unsigned int )dev->kobj.uevent_suppress);
}
}
__inline static void dev_set_uevent_suppress(struct device *dev , int val ) 
{ 

  {
  {
  dev->kobj.uevent_suppress = (unsigned int )val;
  }
  return;
}
}
__inline static int device_is_registered(struct device *dev ) 
{ 

  {
  return ((int )dev->kobj.state_in_sysfs);
}
}
extern void driver_init(void) ;
extern int device_register(struct device *dev ) ;
extern void device_unregister(struct device *dev ) ;
extern void device_initialize(struct device *dev ) ;
extern int device_add(struct device *dev ) ;
extern void device_del(struct device *dev ) ;
extern int device_for_each_child(struct device *dev , void *data , int (*fn)(struct device *dev ,
                                                                             void *data ) ) ;
extern struct device *device_find_child(struct device *dev , void *data , int (*match)(struct device *dev ,
                                                                                       void *data ) ) ;
extern int device_rename(struct device *dev , char *new_name ) ;
extern int device_move(struct device *dev , struct device *new_parent , enum dpm_order dpm_order ) ;
extern struct device *__root_device_register(char const   *name , struct module *owner ) ;
__inline static struct device *root_device_register(char const   *name ) 
{ struct device *tmp ;

  {
  {
  tmp = __root_device_register(name, (struct module *)0);
  }
  return (tmp);
}
}
extern void root_device_unregister(struct device *root ) ;
extern int device_bind_driver(struct device *dev ) ;
extern void device_release_driver(struct device *dev ) ;
extern int device_attach(struct device *dev ) ;
extern int driver_attach(struct device_driver *drv ) ;
extern int device_reprobe(struct device *dev ) ;
extern struct device *device_create_vargs(struct class *cls , struct device *parent ,
                                          dev_t devt , void *drvdata , char const   *fmt ,
                                          va_list vargs ) ;
extern struct device *( /* format attribute */  device_create)(struct class *cls ,
                                                               struct device *parent ,
                                                               dev_t devt , void *drvdata ,
                                                               char const   *fmt 
                                                               , ...) ;
extern void device_destroy(struct class *cls , dev_t devt ) ;
extern int (*platform_notify)(struct device *dev ) ;
extern int (*platform_notify_remove)(struct device *dev ) ;
extern struct device *get_device(struct device *dev ) ;
extern void put_device(struct device *dev ) ;
extern void device_shutdown(void) ;
extern void sysdev_shutdown(void) ;
extern char const   *dev_driver_string(struct device  const  *dev ) ;
__inline static int is_warning_bug(struct bug_entry  const  *bug ) 
{ 

  {
  return ((int )((int const   )bug->flags & 1));
}
}
extern struct bug_entry  const  *find_bug(unsigned long bugaddr ) ;
extern enum bug_trap_type report_bug(unsigned long bug_addr , struct pt_regs *regs ) ;
extern int module_bug_finalize(Elf32_Ehdr const   * , Elf32_Shdr const   * , struct module * ) ;
extern void module_bug_cleanup(struct module * ) ;
extern int is_valid_bugaddr(unsigned long addr ) ;
__inline static void init_dma_attrs(struct dma_attrs *attrs ) 
{ 

  {
  {
  bitmap_zero(attrs->flags, (int )(((2UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))));
  }
  return;
}
}
__inline static void dma_set_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 

  {
  return;
}
}
__inline static int dma_get_attr(enum dma_attr attr , struct dma_attrs *attrs ) 
{ 

  {
  return (0);
}
}
__inline static void rb_set_parent(struct rb_node *rb , struct rb_node *p ) 
{ 

  {
  {
  rb->rb_parent_color = (rb->rb_parent_color & 3UL) | (unsigned long )p;
  }
  return;
}
}
__inline static void rb_set_color(struct rb_node *rb , int color ) 
{ 

  {
  {
  rb->rb_parent_color = (rb->rb_parent_color & 0xfffffffeUL) | (unsigned long )color;
  }
  return;
}
}
extern void rb_insert_color(struct rb_node * , struct rb_root * ) ;
extern void rb_erase(struct rb_node * , struct rb_root * ) ;
extern struct rb_node *rb_next(struct rb_node  const  * ) ;
extern struct rb_node *rb_prev(struct rb_node  const  * ) ;
extern struct rb_node *rb_first(struct rb_root  const  * ) ;
extern struct rb_node *rb_last(struct rb_root  const  * ) ;
extern void rb_replace_node(struct rb_node *victim , struct rb_node *new , struct rb_root *root ) ;
__inline static void rb_link_node(struct rb_node *node , struct rb_node *parent ,
                                  struct rb_node **rb_link ) 
{ struct rb_node *tmp ;

  {
  {
  node->rb_parent_color = (unsigned long )parent;
  tmp = (struct rb_node *)((void *)0);
  node->rb_right = tmp;
  node->rb_left = tmp;
  *rb_link = node;
  }
  return;
}
}
__inline static void prio_tree_iter_init(struct prio_tree_iter *iter , struct prio_tree_root *root ,
                                         unsigned long r_index , unsigned long h_index ) 
{ 

  {
  {
  iter->root = root;
  iter->r_index = r_index;
  iter->h_index = h_index;
  iter->cur = (struct prio_tree_node *)((void *)0);
  }
  return;
}
}
__inline static int prio_tree_empty(struct prio_tree_root  const  *root ) 
{ 

  {
  return ((unsigned long )root->prio_tree_node == (unsigned long )((void *)0));
}
}
__inline static int prio_tree_root(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((unsigned long )node->parent == (unsigned long )node);
}
}
__inline static int prio_tree_left_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((unsigned long )node->left == (unsigned long )node);
}
}
__inline static int prio_tree_right_empty(struct prio_tree_node  const  *node ) 
{ 

  {
  return ((unsigned long )node->right == (unsigned long )node);
}
}
extern struct prio_tree_node *prio_tree_replace(struct prio_tree_root *root , struct prio_tree_node *old ,
                                                struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_insert(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern void prio_tree_remove(struct prio_tree_root *root , struct prio_tree_node *node ) ;
extern struct prio_tree_node *prio_tree_next(struct prio_tree_iter *iter ) ;
extern int debug_locks ;
extern int debug_locks_silent ;
__inline static int __debug_locks_off(void) 
{ unsigned long tmp ;

  {
  {
  tmp = __xchg(0UL, (void volatile   *)(& debug_locks), (int )sizeof(debug_locks));
  }
  return ((int )tmp);
}
}
extern int debug_locks_off(void) ;
extern unsigned long max_mapnr ;
extern unsigned long num_physpages ;
extern void *high_memory ;
extern int page_cluster ;
extern unsigned long mmap_min_addr ;
extern unsigned long empty_zero_page[(1UL << 12) / sizeof(unsigned long )] ;
extern spinlock_t pgd_lock ;
extern struct list_head pgd_list ;
__inline static void paravirt_pagetable_setup_start(pgd_t *base )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static void paravirt_pagetable_setup_start(pgd_t *base ) 
{ 

  {
  {
  native_pagetable_setup_start(base);
  }
  return;
}
}
__inline static void paravirt_pagetable_setup_done(pgd_t *base )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static void paravirt_pagetable_setup_done(pgd_t *base ) 
{ 

  {
  {
  native_pagetable_setup_done(base);
  }
  return;
}
}
__inline static int pte_dirty(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 6)));
}
}
__inline static int pte_young(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 5)));
}
}
__inline static int pte_write(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 1)));
}
}
__inline static int pte_huge(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 7)));
}
}
__inline static int pte_global(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 8)));
}
}
__inline static int pte_exec(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return (1);
}
}
__inline static int pte_special(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(pte);
  }
  return ((int )(tmp & (1UL << 9)));
}
}
__inline static unsigned long pte_pfn(pte_t pte ) 
{ pteval_t tmp ;

  {
  {
  tmp = native_pte_val(pte);
  }
  return ((tmp & (unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))) >> 12);
}
}
__inline static int pmd_large(pmd_t pte ) 
{ pmdval_t tmp ;

  {
  {
  tmp = pmd_flags(pte);
  }
  return ((tmp & ((1UL << 7) | 1UL)) == ((1UL << 7) | 1UL));
}
}
__inline static pte_t pte_set_flags(pte_t pte , pteval_t set ) 
{ pteval_t v ;
  pteval_t tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = native_pte_val(pte);
  v = tmp;
  tmp___0 = native_make_pte(v | set);
  }
  return (tmp___0);
}
}
__inline static pte_t pte_clear_flags(pte_t pte , pteval_t clear ) 
{ pteval_t v ;
  pteval_t tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = native_pte_val(pte);
  v = tmp;
  tmp___0 = native_make_pte(v & ~ clear);
  }
  return (tmp___0);
}
}
__inline static pte_t pte_mkclean(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 6);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkold(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 5);
  }
  return (tmp);
}
}
__inline static pte_t pte_wrprotect(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 1);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkexec(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 0UL);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkdirty(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 6);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkyoung(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 5);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkwrite(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 1);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkhuge(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 7);
  }
  return (tmp);
}
}
__inline static pte_t pte_clrhuge(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 7);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkglobal(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 8);
  }
  return (tmp);
}
}
__inline static pte_t pte_clrglobal(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_clear_flags(pte, 1UL << 8);
  }
  return (tmp);
}
}
__inline static pte_t pte_mkspecial(pte_t pte ) 
{ pte_t tmp ;

  {
  {
  tmp = pte_set_flags(pte, 1UL << 9);
  }
  return (tmp);
}
}
__inline static pgprotval_t massage_pgprot(pgprot_t pgprot ) 
{ pgprotval_t protval ;

  {
  {
  protval = pgprot.pgprot;
  }
  if (protval & 1UL) {
    {
    protval &= __supported_pte_mask;
    }
  }
  return (protval);
}
}
__inline static pte_t pfn_pte(unsigned long page_nr , pgprot_t pgprot ) 
{ pgprotval_t tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = massage_pgprot(pgprot);
  tmp___0 = native_make_pte((unsigned long )((unsigned int )page_nr << 12) | tmp);
  }
  return (tmp___0);
}
}
__inline static pmd_t pfn_pmd(unsigned long page_nr , pgprot_t pgprot ) 
{ pmd_t __constr_expr_0 ;
  pgprotval_t tmp ;
  pgd_t tmp___0 ;

  {
  {
  tmp = massage_pgprot(pgprot);
  tmp___0 = native_make_pgd((unsigned long )((unsigned int )page_nr << 12) | tmp);
  __constr_expr_0.pud.pgd = tmp___0;
  }
  return (__constr_expr_0);
}
}
__inline static pte_t pte_modify(pte_t pte , pgprot_t newprot ) 
{ pteval_t val ;
  pteval_t tmp ;
  pgprotval_t tmp___0 ;
  pte_t tmp___1 ;

  {
  {
  tmp = native_pte_val(pte);
  val = tmp;
  val &= (((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6);
  tmp___0 = massage_pgprot(newprot);
  val |= tmp___0 & ~ ((((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
  tmp___1 = native_make_pte(val);
  }
  return (tmp___1);
}
}
__inline static pgprot_t pgprot_modify(pgprot_t oldprot , pgprot_t newprot ) 
{ pgprotval_t preservebits ;
  pgprotval_t addbits ;
  pgprot_t __constr_expr_0 ;

  {
  {
  preservebits = oldprot.pgprot & ((((((unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U)) | (1UL << 4)) | (1UL << 3)) | (1UL << 9)) | (1UL << 5)) | (1UL << 6));
  addbits = newprot.pgprot;
  __constr_expr_0.pgprot = preservebits | addbits;
  }
  return (__constr_expr_0);
}
}
__inline static int is_new_memtype_allowed(unsigned long flags , unsigned long new_flags ) 
{ 

  {
  if (flags == 1UL << 4) {
    if (new_flags == 0UL) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (flags == 1UL << 3) {
      if (new_flags == 0UL) {
        return (0);
      }
    }
  }
  return (1);
}
}
extern pmd_t *populate_extra_pmd(unsigned long vaddr ) ;
extern pte_t *populate_extra_pte(unsigned long vaddr ) ;
extern pgd_t swapper_pg_dir[1024] ;
extern void paging_init(void) ;
extern void set_pmd_pfn(unsigned long  , unsigned long  , pgprot_t  ) ;
__inline static void native_set_pte(pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  *ptep = pte;
  }
  return;
}
}
__inline static void native_set_pmd(pmd_t *pmdp , pmd_t pmd ) 
{ 

  {
  {
  *pmdp = pmd;
  }
  return;
}
}
__inline static void native_set_pte_atomic(pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  native_set_pte(ptep, pte);
  }
  return;
}
}
__inline static void native_pmd_clear(pmd_t *pmdp ) 
{ pmd_t __constr_expr_0 ;
  pgd_t tmp ;

  {
  {
  tmp = native_make_pgd(0UL);
  __constr_expr_0.pud.pgd = tmp;
  native_set_pmd(pmdp, __constr_expr_0);
  }
  return;
}
}
__inline static void native_pte_clear(struct mm_struct *mm , unsigned long addr ,
                                      pte_t *xp ) 
{ 

  {
  {
  *xp = native_make_pte(0UL);
  }
  return;
}
}
__inline static pte_t native_ptep_get_and_clear(pte_t *xp ) 
{ unsigned long tmp ;
  pte_t tmp___0 ;

  {
  {
  tmp = __xchg(0UL, (void volatile   *)(& xp->pte_low), (int )sizeof(xp->pte_low));
  tmp___0 = native_make_pte(tmp);
  }
  return (tmp___0);
}
}
__inline static int pte_none(pte_t pte ) 
{ 

  {
  return (! pte.pte);
}
}
__inline static int pte_same(pte_t a , pte_t b ) 
{ 

  {
  return (a.pte == b.pte);
}
}
__inline static int pte_present(pte_t a ) 
{ pteval_t tmp ;

  {
  {
  tmp = pte_flags(a);
  }
  return ((int )(tmp & (1UL | (1UL << 8))));
}
}
__inline static int pmd_present(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = pmd_flags(pmd);
  }
  return ((int )(tmp & 1UL));
}
}
__inline static int pmd_none(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = native_pmd_val(pmd);
  }
  return (tmp == 0UL);
}
}
__inline static unsigned long pmd_page_vaddr(pmd_t pmd ) 
{ pgdval_t tmp ;

  {
  {
  tmp = native_pgd_val(pmd.pud.pgd);
  }
  return ((unsigned long )((void *)((tmp & (unsigned long )((long )(~ ((1UL << 12) - 1UL)) & (long )((unsigned int )(1ULL << 32) - 1U))) + 3221225472UL)));
}
}
__inline static unsigned int pmd_index(unsigned long address ) 
{ 

  {
  return (0U);
}
}
__inline static unsigned int pte_index(unsigned long address ) 
{ 

  {
  return ((unsigned int )((address >> 12) & 1023UL));
}
}
__inline static pte_t *pte_offset_kernel(pmd_t *pmd , unsigned long address ) 
{ unsigned long tmp ;
  unsigned int tmp___0 ;

  {
  {
  tmp = pmd_page_vaddr(*pmd);
  tmp___0 = pte_index(address);
  }
  return ((pte_t *)tmp + tmp___0);
}
}
__inline static int pmd_bad(pmd_t pmd ) 
{ pmdval_t tmp ;

  {
  {
  tmp = pmd_flags(pmd);
  }
  return ((tmp & ~ (1UL << 2)) != (((1UL | (1UL << 1)) | (1UL << 5)) | (1UL << 6)));
}
}
__inline static unsigned long pages_to_mb(unsigned long npg ) 
{ 

  {
  return (npg >> 8);
}
}
__inline static pte_t native_local_ptep_get_and_clear(pte_t *ptep ) 
{ pte_t res ;

  {
  {
  res = *ptep;
  native_pte_clear((struct mm_struct *)((void *)0), 0UL, ptep);
  }
  return (res);
}
}
__inline static void native_set_pte_at(struct mm_struct *mm , unsigned long addr ,
                                       pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  native_set_pte(ptep, pte);
  }
  return;
}
}
extern int ptep_set_access_flags(struct vm_area_struct *vma , unsigned long address ,
                                 pte_t *ptep , pte_t entry , int dirty ) ;
extern int ptep_test_and_clear_young(struct vm_area_struct *vma , unsigned long addr ,
                                     pte_t *ptep ) ;
extern int ptep_clear_flush_young(struct vm_area_struct *vma , unsigned long address ,
                                  pte_t *ptep ) ;
__inline static pte_t ptep_get_and_clear(struct mm_struct *mm , unsigned long addr ,
                                         pte_t *ptep ) 
{ pte_t pte ;
  pte_t tmp ;

  {
  {
  tmp = native_ptep_get_and_clear(ptep);
  pte = tmp;
  }
  {
  while (1) {
    while_98_continue: /* CIL Label */ ;
    goto while_98_break;
  }
  while_98_break: /* CIL Label */ ;
  }
  return (pte);
}
}
__inline static pte_t ptep_get_and_clear_full(struct mm_struct *mm , unsigned long addr ,
                                              pte_t *ptep , int full ) 
{ pte_t pte ;

  {
  if (full) {
    {
    pte = native_local_ptep_get_and_clear(ptep);
    }
  } else {
    {
    pte = ptep_get_and_clear(mm, addr, ptep);
    }
  }
  return (pte);
}
}
__inline static void ptep_set_wrprotect(struct mm_struct *mm , unsigned long addr ,
                                        pte_t *ptep ) 
{ 

  {
  {
  clear_bit(1, (unsigned long volatile   *)(& ptep->pte));
  }
  {
  while (1) {
    while_99_continue: /* CIL Label */ ;
    goto while_99_break;
  }
  while_99_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void clone_pgd_range(pgd_t *dst , pgd_t *src , int count ) 
{ 

  {
  {
  __memcpy((void *)dst, (void const   *)src, (unsigned int )((unsigned long )count * sizeof(pgd_t )));
  }
  return;
}
}
extern void pgd_clear_bad(pgd_t * ) ;
extern void pud_clear_bad(pud_t * ) ;
extern void pmd_clear_bad(pmd_t * ) ;
__inline static int pgd_none_or_clear_bad(pgd_t *pgd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = pgd_none(*pgd);
  }
  if (tmp) {
    return (1);
  }
  {
  tmp___0 = pgd_none(*pgd);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    pgd_clear_bad(pgd);
    }
    return (1);
  }
  return (0);
}
}
__inline static int pud_none_or_clear_bad(pud_t *pud ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = pud_none(*pud);
  }
  if (tmp) {
    return (1);
  }
  {
  tmp___0 = pud_none(*pud);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    pud_clear_bad(pud);
    }
    return (1);
  }
  return (0);
}
}
__inline static int pmd_none_or_clear_bad(pmd_t *pmd ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = pmd_none(*pmd);
  }
  if (tmp) {
    return (1);
  }
  {
  tmp___0 = pmd_bad(*pmd);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    pmd_clear_bad(pmd);
    }
    return (1);
  }
  return (0);
}
}
__inline static pte_t __ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep ) 
{ pte_t tmp ;

  {
  {
  tmp = ptep_get_and_clear(mm, addr, ptep);
  }
  return (tmp);
}
}
__inline static void __ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                               pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  native_set_pte_at(mm, addr, ptep, pte);
  }
  return;
}
}
__inline static pte_t ptep_modify_prot_start(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep ) 
{ pte_t tmp ;

  {
  {
  tmp = __ptep_modify_prot_start(mm, addr, ptep);
  }
  return (tmp);
}
}
__inline static void ptep_modify_prot_commit(struct mm_struct *mm , unsigned long addr ,
                                             pte_t *ptep , pte_t pte ) 
{ 

  {
  {
  __ptep_modify_prot_commit(mm, addr, ptep, pte);
  }
  return;
}
}
extern int track_pfn_vma_new(struct vm_area_struct *vma , pgprot_t *prot , unsigned long pfn ,
                             unsigned long size ) ;
extern int track_pfn_vma_copy(struct vm_area_struct *vma ) ;
extern void untrack_pfn_vma(struct vm_area_struct *vma , unsigned long pfn , unsigned long size ) ;
extern struct kmem_cache *vm_area_cachep ;
extern pgprot_t protection_map[16] ;
__inline static int is_linear_pfn_mapping(struct vm_area_struct *vma ) 
{ 

  {
  return ((int )(vma->vm_flags & 1073741824UL));
}
}
__inline static int is_pfn_mapping(struct vm_area_struct *vma ) 
{ 

  {
  return ((int )(vma->vm_flags & 1024UL));
}
}
__inline static int PageLocked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(0U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestSetPageLocked(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageError(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageError(struct page *page ) 
{ 

  {
  {
  set_bit(1U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageError(struct page *page ) 
{ 

  {
  {
  clear_bit(1, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageReferenced(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(2U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageReferenced(struct page *page ) 
{ 

  {
  {
  set_bit(2U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageReferenced(struct page *page ) 
{ 

  {
  {
  clear_bit(2, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageReferenced(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(2, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageDirty(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(4U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageDirty(struct page *page ) 
{ 

  {
  {
  set_bit(4U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageDirty(struct page *page ) 
{ 

  {
  {
  clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPageDirty(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPageDirty(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __ClearPageDirty(struct page *page ) 
{ 

  {
  {
  __clear_bit(4, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageLRU(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(5U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageLRU(struct page *page ) 
{ 

  {
  {
  set_bit(5U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageLRU(struct page *page ) 
{ 

  {
  {
  clear_bit(5, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageLRU(struct page *page ) 
{ 

  {
  {
  __clear_bit(5, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageActive(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(6U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageActive(struct page *page ) 
{ 

  {
  {
  set_bit(6U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageActive(struct page *page ) 
{ 

  {
  {
  clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageActive(struct page *page ) 
{ 

  {
  {
  __clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageActive(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageSlab(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(7U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageSlab(struct page *page ) 
{ 

  {
  {
  __set_bit(7, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSlab(struct page *page ) 
{ 

  {
  {
  __clear_bit(7, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageChecked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(8U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageChecked(struct page *page ) 
{ 

  {
  {
  set_bit(8U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageChecked(struct page *page ) 
{ 

  {
  {
  clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPagePinned(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(8, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPagePinned(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(8, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageReserved(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(10U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageReserved(struct page *page ) 
{ 

  {
  {
  set_bit(10U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageReserved(struct page *page ) 
{ 

  {
  {
  clear_bit(10, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageReserved(struct page *page ) 
{ 

  {
  {
  __clear_bit(10, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageSwapBacked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(20U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageSwapBacked(struct page *page ) 
{ 

  {
  {
  set_bit(20U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageSwapBacked(struct page *page ) 
{ 

  {
  {
  clear_bit(20, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSwapBacked(struct page *page ) 
{ 

  {
  {
  __clear_bit(20, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __SetPageSlobPage(struct page *page ) 
{ 

  {
  {
  __set_bit(6, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageSlobFree(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(11U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageSlobFree(struct page *page ) 
{ 

  {
  {
  __set_bit(11, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSlobFree(struct page *page ) 
{ 

  {
  {
  __clear_bit(11, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __SetPageSlubDebug(struct page *page ) 
{ 

  {
  {
  __set_bit(1, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageSlubDebug(struct page *page ) 
{ 

  {
  {
  __clear_bit(1, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void SetPagePrivate(struct page *page ) 
{ 

  {
  {
  set_bit(11U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPagePrivate(struct page *page ) 
{ 

  {
  {
  clear_bit(11, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PagePrivate2(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(12U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPagePrivate2(struct page *page ) 
{ 

  {
  {
  set_bit(12U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPagePrivate2(struct page *page ) 
{ 

  {
  {
  clear_bit(12, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPagePrivate2(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(12, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPagePrivate2(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(12, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageWriteback(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(13U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestSetPageWriteback(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(13, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPageWriteback(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(13, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageBuddy(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(19U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageBuddy(struct page *page ) 
{ 

  {
  {
  __set_bit(19, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageBuddy(struct page *page ) 
{ 

  {
  {
  __clear_bit(19, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageMappedToDisk(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(17U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageMappedToDisk(struct page *page ) 
{ 

  {
  {
  set_bit(17U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageMappedToDisk(struct page *page ) 
{ 

  {
  {
  clear_bit(17, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageReclaim(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(18U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageReclaim(struct page *page ) 
{ 

  {
  {
  set_bit(18U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageReclaim(struct page *page ) 
{ 

  {
  {
  clear_bit(18, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageReclaim(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(18, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageSwapCache(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(16U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageSwapCache(struct page *page ) 
{ 

  {
  {
  set_bit(16U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageSwapCache(struct page *page ) 
{ 

  {
  {
  clear_bit(16, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageUnevictable(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(21U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageUnevictable(struct page *page ) 
{ 

  {
  {
  set_bit(21U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageUnevictable(struct page *page ) 
{ 

  {
  {
  clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageUnevictable(struct page *page ) 
{ 

  {
  {
  __clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestClearPageUnevictable(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(21, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageMlocked(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(22U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void SetPageMlocked(struct page *page ) 
{ 

  {
  {
  set_bit(22U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageMlocked(struct page *page ) 
{ 

  {
  {
  clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageMlocked(struct page *page ) 
{ 

  {
  {
  __clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int TestSetPageMlocked(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int TestClearPageMlocked(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_bit(22, (unsigned long volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static int PageUncached(struct page *page ) 
{ 

  {
  return (0);
}
}
__inline static int PageUptodate(struct page *page ) 
{ int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(3U, (unsigned long const volatile   *)(& page->flags));
  ret = tmp;
  }
  if (ret) {
    {
    __asm__  volatile   ("": : : "memory");
    }
  }
  return (ret);
}
}
__inline static void __SetPageUptodate(struct page *page ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  __set_bit(3, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void SetPageUptodate(struct page *page ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  set_bit(3U, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void ClearPageUptodate(struct page *page ) 
{ 

  {
  {
  clear_bit(3, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
extern void cancel_dirty_page(struct page *page , unsigned int account_size ) ;
extern int test_clear_page_writeback(struct page *page ) ;
extern int test_set_page_writeback(struct page *page ) ;
__inline static void set_page_writeback(struct page *page ) 
{ 

  {
  {
  test_set_page_writeback(page);
  }
  return;
}
}
__inline static int PageHead(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(14U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageHead(struct page *page ) 
{ 

  {
  {
  __set_bit(14, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageHead(struct page *page ) 
{ 

  {
  {
  __clear_bit(14, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageTail(struct page *page ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(15U, (unsigned long const volatile   *)(& page->flags));
  }
  return (tmp);
}
}
__inline static void __SetPageTail(struct page *page ) 
{ 

  {
  {
  __set_bit(15, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static void __ClearPageTail(struct page *page ) 
{ 

  {
  {
  __clear_bit(15, (unsigned long volatile   *)(& page->flags));
  }
  return;
}
}
__inline static int PageCompound(struct page *page ) 
{ 

  {
  return ((int )(page->flags & (unsigned long )((1L << 14) | (1L << 15))));
}
}
__inline static int put_page_testzero(struct page *page ) 
{ int tmp ;

  {
  {
  while (1) {
    while_100_continue: /* CIL Label */ ;
    goto while_100_break;
  }
  while_100_break: /* CIL Label */ ;
  }
  {
  tmp = atomic_dec_and_test(& page->_count);
  }
  return (tmp);
}
}
__inline static int get_page_unless_zero(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = atomic_add_unless(& page->_count, 1, 0);
  }
  return (tmp);
}
}
extern struct page *vmalloc_to_page(void const   *addr ) ;
extern unsigned long vmalloc_to_pfn(void const   *addr ) ;
__inline static int is_vmalloc_addr(void const   *x ) 
{ unsigned long addr ;
  int tmp ;

  {
  {
  addr = (unsigned long )x;
  }
  if (addr >= (unsigned long )high_memory + 8388608UL) {
    if (addr < (((__FIXADDR_TOP - (unsigned long )(513 << 12)) - (1UL << 12) * 1025UL) & ~ ((1UL << 22) - 1UL)) - 2UL * (1UL << 12)) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static struct page *compound_head(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = PageTail(page);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return (page->__annonCompField19.first_page);
  }
  return (page);
}
}
__inline static int page_count(struct page *page ) 
{ struct page *tmp ;

  {
  {
  tmp = compound_head(page);
  }
  return ((int )tmp->_count.counter);
}
}
__inline static void get_page(struct page *page ) 
{ 

  {
  {
  page = compound_head(page);
  }
  {
  while (1) {
    while_101_continue: /* CIL Label */ ;
    goto while_101_break;
  }
  while_101_break: /* CIL Label */ ;
  }
  {
  atomic_inc(& page->_count);
  }
  return;
}
}
__inline static struct page *virt_to_head_page(void const   *x ) 
{ struct page *page ;
  struct page *tmp ;

  {
  {
  page = mem_map + (((unsigned long )x - 3221225472UL) >> 12);
  tmp = compound_head(page);
  }
  return (tmp);
}
}
__inline static void init_page_count(struct page *page ) 
{ 

  {
  {
  page->_count.counter = (int volatile   )1;
  }
  return;
}
}
extern void put_page(struct page *page ) ;
extern void put_pages_list(struct list_head *pages ) ;
extern void split_page(struct page *page , unsigned int order ) ;
__inline static void set_compound_page_dtor(struct page *page , compound_page_dtor *dtor ) 
{ 

  {
  {
  (page + 1)->lru.next = (struct list_head *)((void *)dtor);
  }
  return;
}
}
__inline static compound_page_dtor *get_compound_page_dtor(struct page *page ) 
{ 

  {
  return ((compound_page_dtor *)(page + 1)->lru.next);
}
}
__inline static int compound_order(struct page *page ) 
{ int tmp ;

  {
  {
  tmp = PageHead(page);
  }
  if (! tmp) {
    return (0);
  }
  return ((int )((unsigned long )(page + 1)->lru.prev));
}
}
__inline static void set_compound_order(struct page *page , unsigned long order ) 
{ 

  {
  {
  (page + 1)->lru.prev = (struct list_head *)((void *)order);
  }
  return;
}
}
__inline static enum zone_type page_zonenum(struct page *page ) 
{ 

  {
  return ((enum zone_type )((page->flags >> (sizeof(unsigned long ) * 8UL - 2UL)) & ((1UL << 2) - 1UL)));
}
}
__inline static int page_zone_id(struct page *page ) 
{ unsigned long tmp ;

  {
  if (sizeof(unsigned long ) * 8UL < sizeof(unsigned long ) * 8UL - 2UL) {
    {
    tmp = sizeof(unsigned long ) * 8UL;
    }
  } else {
    {
    tmp = sizeof(unsigned long ) * 8UL - 2UL;
    }
  }
  return ((int )((page->flags >> tmp) & ((1UL << 2) - 1UL)));
}
}
__inline static struct zone *page_zone(struct page *page ) 
{ enum zone_type tmp ;

  {
  {
  tmp = page_zonenum(page);
  }
  return (& contig_page_data.node_zones[tmp]);
}
}
__inline static void set_page_zone(struct page *page , enum zone_type zone ) 
{ 

  {
  {
  page->flags &= ~ (((1UL << 2) - 1UL) << (sizeof(unsigned long ) * 8UL - 2UL));
  page->flags |= ((unsigned long )zone & ((1UL << 2) - 1UL)) << (sizeof(unsigned long ) * 8UL - 2UL);
  }
  return;
}
}
__inline static void set_page_node(struct page *page , unsigned long node ) 
{ 

  {
  {
  page->flags &= 0xffffffffUL;
  page->flags = page->flags;
  }
  return;
}
}
__inline static void set_page_links(struct page *page , enum zone_type zone , unsigned long node ,
                                    unsigned long pfn ) 
{ 

  {
  {
  set_page_zone(page, zone);
  set_page_node(page, node);
  set_page_node(page, pfn);
  }
  return;
}
}
__inline static unsigned long round_hint_to_min(unsigned long hint ) 
{ 

  {
  {
  hint &= ~ ((1UL << 12) - 1UL);
  }
  if ((unsigned long )((void *)hint) != (unsigned long )((void *)0)) {
    if (hint < mmap_min_addr) {
      return ((mmap_min_addr + ((1UL << 12) - 1UL)) & ~ ((1UL << 12) - 1UL));
    }
  }
  return (hint);
}
}
extern int sysctl_stat_interval ;
extern struct vm_event_state per_cpu__vm_event_states  __attribute__((__section__(".data.percpu"))) ;
__inline static void __count_vm_event(enum vm_event_item item ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_102_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_102_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_102_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_102_8;
        } else {
          {
          goto switch_102_default;
          if (0) {
            switch_102_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_102_break;
            switch_102_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_102_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  (((struct vm_event_state *)(__ptr + ret__))->event[item]) ++;
  }
  return;
}
}
extern int simple_identifier_vm_event_states(void) ;
__inline static void count_vm_event(enum vm_event_item item ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  while (1) {
    while_103_continue: /* CIL Label */ ;
    goto while_103_break;
  }
  while_103_break: /* CIL Label */ ;
  }
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_104_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_104_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_104_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_104_8;
        } else {
          {
          goto switch_104_default;
          if (0) {
            switch_104_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_104_break;
            switch_104_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_104_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  (((struct vm_event_state *)(__ptr + ret__))->event[item]) ++;
  }
  {
  while (1) {
    while_105_continue: /* CIL Label */ ;
    goto while_105_break;
  }
  while_105_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void __count_vm_events(enum vm_event_item item , long delta ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_106_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_106_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_106_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_106_8;
        } else {
          {
          goto switch_106_default;
          if (0) {
            switch_106_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_106_break;
            switch_106_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_106_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ((struct vm_event_state *)(__ptr + ret__))->event[item] += (unsigned long )delta;
  }
  return;
}
}
__inline static void count_vm_events(enum vm_event_item item , long delta ) 
{ unsigned long __ptr ;
  unsigned long ret__ ;

  {
  {
  while (1) {
    while_107_continue: /* CIL Label */ ;
    goto while_107_break;
  }
  while_107_break: /* CIL Label */ ;
  }
  {
  __asm__  ("": "=r" (__ptr): "0" (& per_cpu__vm_event_states));
  }
  if ((int )sizeof(per_cpu__this_cpu_off) == 1) {
    goto switch_108_1;
  } else {
    if ((int )sizeof(per_cpu__this_cpu_off) == 2) {
      goto switch_108_2;
    } else {
      if ((int )sizeof(per_cpu__this_cpu_off) == 4) {
        goto switch_108_4;
      } else {
        if ((int )sizeof(per_cpu__this_cpu_off) == 8) {
          goto switch_108_8;
        } else {
          {
          goto switch_108_default;
          if (0) {
            switch_108_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__this_cpu_off));
            }
            goto switch_108_break;
            switch_108_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_108_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  ((struct vm_event_state *)(__ptr + ret__))->event[item] += (unsigned long )delta;
  }
  {
  while (1) {
    while_109_continue: /* CIL Label */ ;
    goto while_109_break;
  }
  while_109_break: /* CIL Label */ ;
  }
  return;
}
}
extern void all_vm_events(unsigned long * ) ;
extern void vm_events_fold_cpu(int cpu ) ;
extern atomic_long_t vm_stat[19] ;
__inline static void zone_page_state_add(long x , struct zone *zone , enum zone_stat_item item ) 
{ 

  {
  {
  atomic_long_add(x, & zone->vm_stat[item]);
  atomic_long_add(x, & vm_stat[item]);
  }
  return;
}
}
__inline static unsigned long global_page_state(enum zone_stat_item item ) 
{ long x ;
  long tmp ;

  {
  {
  tmp = atomic_long_read(& vm_stat[item]);
  x = tmp;
  }
  if (x < 0L) {
    {
    x = 0L;
    }
  }
  return ((unsigned long )x);
}
}
__inline static unsigned long zone_page_state(struct zone *zone , enum zone_stat_item item ) 
{ long x ;
  long tmp ;

  {
  {
  tmp = atomic_long_read(& zone->vm_stat[item]);
  x = tmp;
  }
  if (x < 0L) {
    {
    x = 0L;
    }
  }
  return ((unsigned long )x);
}
}
extern unsigned long global_lru_pages(void) ;
__inline static unsigned long zone_lru_pages(struct zone *zone ) 
{ unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
  tmp = zone_page_state(zone, (enum zone_stat_item )2);
  tmp___0 = zone_page_state(zone, (enum zone_stat_item )4);
  tmp___1 = zone_page_state(zone, (enum zone_stat_item )1);
  tmp___2 = zone_page_state(zone, (enum zone_stat_item )3);
  }
  return (((tmp + tmp___0) + tmp___1) + tmp___2);
}
}
__inline static void zap_zone_vm_stats(struct zone *zone ) 
{ 

  {
  {
  __constant_c_and_count_memset((void *)(zone->vm_stat), 0UL, (unsigned int )sizeof(zone->vm_stat));
  }
  return;
}
}
extern void inc_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void __mod_zone_page_state(struct zone * , enum zone_stat_item item , int  ) ;
extern void __inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void __dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void mod_zone_page_state(struct zone * , enum zone_stat_item  , int  ) ;
extern void inc_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void dec_zone_page_state(struct page * , enum zone_stat_item  ) ;
extern void __inc_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void dec_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void __dec_zone_state(struct zone * , enum zone_stat_item  ) ;
extern void refresh_cpu_vm_stats(int  ) ;
__inline static void *lowmem_page_address(struct page *page ) 
{ 

  {
  return ((void *)(((unsigned long )(page - mem_map) << 12) + 3221225472UL));
}
}
extern void *page_address(struct page *page ) ;
extern void set_page_address(struct page *page , void *virtual ) ;
extern void page_address_init(void) ;
extern struct address_space swapper_space ;
__inline static struct address_space *page_mapping(struct page *page ) 
{ struct address_space *mapping ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  mapping = page->__annonCompField19.__annonCompField18.mapping;
  }
  {
  while (1) {
    while_110_continue: /* CIL Label */ ;
    goto while_110_break;
  }
  while_110_break: /* CIL Label */ ;
  }
  {
  tmp___0 = PageSwapCache(page);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    mapping = & swapper_space;
    }
  } else {
    {
    tmp = __builtin_expect((long )(! (! ((unsigned long )mapping & 1UL))), 0L);
    }
    if (tmp) {
      {
      mapping = (struct address_space *)((void *)0);
      }
    }
  }
  return (mapping);
}
}
__inline static int PageAnon(struct page *page ) 
{ 

  {
  return (((unsigned long )page->__annonCompField19.__annonCompField18.mapping & 1UL) != 0UL);
}
}
__inline static unsigned long page_index(struct page *page ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = PageSwapCache(page);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    return (page->__annonCompField19.__annonCompField18.private);
  }
  return (page->__annonCompField20.index);
}
}
__inline static void reset_page_mapcount(struct page *page ) 
{ 

  {
  {
  page->__annonCompField17._mapcount.counter = (int volatile   )-1;
  }
  return;
}
}
__inline static int page_mapcount(struct page *page ) 
{ 

  {
  return ((int )(page->__annonCompField17._mapcount.counter + (int volatile   )1));
}
}
__inline static int page_mapped(struct page *page ) 
{ 

  {
  return (page->__annonCompField17._mapcount.counter >= (int volatile   )0);
}
}
extern void pagefault_out_of_memory(void) ;
extern void show_free_areas(void) ;
extern int shmem_lock(struct file *file , int lock , struct user_struct *user ) ;
extern struct file *shmem_file_setup(char *name , loff_t size , unsigned long flags ) ;
extern int shmem_zero_setup(struct vm_area_struct * ) ;
extern int can_do_mlock(void) ;
extern int user_shm_lock(size_t  , struct user_struct * ) ;
extern void user_shm_unlock(size_t  , struct user_struct * ) ;
extern struct page *vm_normal_page(struct vm_area_struct *vma , unsigned long addr ,
                                   pte_t pte ) ;
extern int zap_vma_ptes(struct vm_area_struct *vma , unsigned long address , unsigned long size ) ;
extern unsigned long zap_page_range(struct vm_area_struct *vma , unsigned long address ,
                                    unsigned long size , struct zap_details * ) ;
extern unsigned long unmap_vmas(struct mmu_gather **tlb , struct vm_area_struct *start_vma ,
                                unsigned long start_addr , unsigned long end_addr ,
                                unsigned long *nr_accounted , struct zap_details * ) ;
extern int walk_page_range(unsigned long addr , unsigned long end , struct mm_walk *walk ) ;
extern void free_pgd_range(struct mmu_gather *tlb , unsigned long addr , unsigned long end ,
                           unsigned long floor , unsigned long ceiling ) ;
extern int copy_page_range(struct mm_struct *dst , struct mm_struct *src , struct vm_area_struct *vma ) ;
extern void unmap_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                loff_t holelen , int even_cows ) ;
extern int follow_phys(struct vm_area_struct *vma , unsigned long address , unsigned int flags ,
                       unsigned long *prot , resource_size_t *phys ) ;
extern int generic_access_phys(struct vm_area_struct *vma , unsigned long addr , void *buf ,
                               int len , int write ) ;
__inline static void unmap_shared_mapping_range(struct address_space *mapping , loff_t holebegin ,
                                                loff_t holelen ) 
{ 

  {
  {
  unmap_mapping_range(mapping, holebegin, holelen, 0);
  }
  return;
}
}
extern int vmtruncate(struct inode *inode , loff_t offset ) ;
extern int vmtruncate_range(struct inode *inode , loff_t offset , loff_t end ) ;
extern int handle_mm_fault(struct mm_struct *mm , struct vm_area_struct *vma , unsigned long address ,
                           int write_access ) ;
extern int make_pages_present(unsigned long addr , unsigned long end ) ;
extern int access_process_vm(struct task_struct *tsk , unsigned long addr , void *buf ,
                             int len , int write ) ;
extern int get_user_pages(struct task_struct *tsk , struct mm_struct *mm , unsigned long start ,
                          int len , int write , int force , struct page **pages ,
                          struct vm_area_struct **vmas ) ;
extern int try_to_release_page(struct page *page , gfp_t gfp_mask ) ;
extern void do_invalidatepage(struct page *page , unsigned long offset ) ;
extern int __set_page_dirty_nobuffers(struct page *page ) ;
extern int __set_page_dirty_no_writeback(struct page *page ) ;
extern int redirty_page_for_writepage(struct writeback_control *wbc , struct page *page ) ;
extern void account_page_dirtied(struct page *page , struct address_space *mapping ) ;
extern int set_page_dirty(struct page *page ) ;
extern int set_page_dirty_lock(struct page *page ) ;
extern int clear_page_dirty_for_io(struct page *page ) ;
extern unsigned long move_page_tables(struct vm_area_struct *vma , unsigned long old_addr ,
                                      struct vm_area_struct *new_vma , unsigned long new_addr ,
                                      unsigned long len ) ;
extern unsigned long do_mremap(unsigned long addr , unsigned long old_len , unsigned long new_len ,
                               unsigned long flags , unsigned long new_addr ) ;
extern int mprotect_fixup(struct vm_area_struct *vma , struct vm_area_struct **pprev ,
                          unsigned long start , unsigned long end , unsigned long newflags ) ;
extern int get_user_pages_fast(unsigned long start , int nr_pages , int write , struct page **pages ) ;
extern void register_shrinker(struct shrinker * ) ;
extern void unregister_shrinker(struct shrinker * ) ;
extern int vma_wants_writenotify(struct vm_area_struct *vma ) ;
extern pte_t *get_locked_pte(struct mm_struct *mm , unsigned long addr , spinlock_t **ptl ) ;
__inline static int __pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) 
{ 

  {
  return (0);
}
}
__inline static int __pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) 
{ 

  {
  return (0);
}
}
extern int __pte_alloc(struct mm_struct *mm , pmd_t *pmd , unsigned long address ) ;
extern int __pte_alloc_kernel(pmd_t *pmd , unsigned long address ) ;
__inline static pud_t *pud_alloc(struct mm_struct *mm , pgd_t *pgd , unsigned long address ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  pud_t *tmp___3 ;
  pud_t *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
  {
  tmp___5 = pgd_none(*pgd);
  }
  if (tmp___5) {
    {
    tmp___6 = 1;
    }
  } else {
    {
    tmp___6 = 0;
    }
  }
  {
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
  if (tmp___7) {
    {
    tmp___8 = __pud_alloc(mm, pgd, address);
    }
    if (tmp___8) {
      {
      tmp___4 = (pud_t *)((void *)0);
      }
    } else {
      {
      tmp___3 = pud_offset(pgd, address);
      tmp___4 = tmp___3;
      }
    }
  } else {
    {
    tmp___3 = pud_offset(pgd, address);
    tmp___4 = tmp___3;
    }
  }
  return (tmp___4);
}
}
__inline static pmd_t *pmd_alloc(struct mm_struct *mm , pud_t *pud , unsigned long address ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  pmd_t *tmp___3 ;
  pmd_t *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
  {
  tmp___5 = pud_none(*pud);
  }
  if (tmp___5) {
    {
    tmp___6 = 1;
    }
  } else {
    {
    tmp___6 = 0;
    }
  }
  {
  tmp___7 = __builtin_expect((long )tmp___6, 0L);
  }
  if (tmp___7) {
    {
    tmp___8 = __pmd_alloc(mm, pud, address);
    }
    if (tmp___8) {
      {
      tmp___4 = (pmd_t *)((void *)0);
      }
    } else {
      {
      tmp___3 = pmd_offset(pud, address);
      tmp___4 = tmp___3;
      }
    }
  } else {
    {
    tmp___3 = pmd_offset(pud, address);
    tmp___4 = tmp___3;
    }
  }
  return (tmp___4);
}
}
__inline static void pgtable_page_ctor(struct page *page ) 
{ spinlock_t __constr_expr_0 ;

  {
  {
  while (1) {
    while_111_continue: /* CIL Label */ ;
    {
    while (1) {
      while_112_continue: /* CIL Label */ ;
      {
      __constr_expr_0.raw_lock.slock = 0U;
      page->__annonCompField19.ptl = __constr_expr_0;
      }
      goto while_112_break;
    }
    while_112_break: /* CIL Label */ ;
    }
    goto while_111_break;
  }
  while_111_break: /* CIL Label */ ;
  }
  {
  inc_zone_page_state(page, (enum zone_stat_item )14);
  }
  return;
}
}
__inline static void pgtable_page_dtor(struct page *page ) 
{ 

  {
  {
  page->__annonCompField19.__annonCompField18.mapping = (struct address_space *)((void *)0);
  dec_zone_page_state(page, (enum zone_stat_item )14);
  }
  return;
}
}
extern void free_area_init(unsigned long *zones_size ) ;
extern void free_area_init_node(int nid , unsigned long *zones_size , unsigned long zone_start_pfn ,
                                unsigned long *zholes_size ) ;
extern void free_area_init_nodes(unsigned long *max_zone_pfn ) ;
extern void add_active_range(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
extern void remove_active_range(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
extern void push_node_boundaries(unsigned int nid , unsigned long start_pfn , unsigned long end_pfn ) ;
extern void remove_all_active_ranges(void) ;
extern unsigned long absent_pages_in_range(unsigned long start_pfn , unsigned long end_pfn ) ;
extern void get_pfn_range_for_nid(unsigned int nid , unsigned long *start_pfn , unsigned long *end_pfn ) ;
extern unsigned long find_min_pfn_with_active_regions(void) ;
extern void free_bootmem_with_active_regions(int nid , unsigned long max_low_pfn ) ;
extern void work_with_active_regions(int nid , int (*work_fn)(unsigned long  , unsigned long  ,
                                                              void * ) , void *data ) ;
extern void sparse_memory_present_with_active_regions(int nid ) ;
extern int early_pfn_to_nid(unsigned long pfn )  __attribute__((__section__(".meminit.text"))) ;
extern void set_dma_reserve(unsigned long new_dma_reserve ) ;
extern void memmap_init_zone(unsigned long  , int  , unsigned long  , unsigned long  ,
                             enum memmap_context  ) ;
extern void setup_per_zone_pages_min(void) ;
extern void mem_init(void) ;
extern void mmap_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void show_mem(void) ;
extern void si_meminfo(struct sysinfo *val ) ;
extern void si_meminfo_node(struct sysinfo *val , int nid ) ;
extern int after_bootmem ;
extern atomic_long_t mmap_pages_allocated ;
extern void vma_prio_tree_add(struct vm_area_struct * , struct vm_area_struct *old ) ;
extern void vma_prio_tree_insert(struct vm_area_struct * , struct prio_tree_root * ) ;
extern void vma_prio_tree_remove(struct vm_area_struct * , struct prio_tree_root * ) ;
extern struct vm_area_struct *vma_prio_tree_next(struct vm_area_struct *vma , struct prio_tree_iter *iter ) ;
__inline static void vma_nonlinear_insert(struct vm_area_struct *vma , struct list_head *list ) 
{ 

  {
  {
  vma->shared.vm_set.parent = (void *)0;
  list_add_tail(& vma->shared.vm_set.list, list);
  }
  return;
}
}
extern int __vm_enough_memory(struct mm_struct *mm , long pages , int cap_sys_admin ) ;
extern void vma_adjust(struct vm_area_struct *vma , unsigned long start , unsigned long end ,
                       unsigned long pgoff , struct vm_area_struct *insert ) ;
extern struct vm_area_struct *vma_merge(struct mm_struct * , struct vm_area_struct *prev ,
                                        unsigned long addr , unsigned long end , unsigned long vm_flags ,
                                        struct anon_vma * , struct file * , unsigned long  ,
                                        struct mempolicy * ) ;
extern struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct * ) ;
extern int split_vma(struct mm_struct * , struct vm_area_struct * , unsigned long addr ,
                     int new_below ) ;
extern int insert_vm_struct(struct mm_struct * , struct vm_area_struct * ) ;
extern void __vma_link_rb(struct mm_struct * , struct vm_area_struct * , struct rb_node ** ,
                          struct rb_node * ) ;
extern void unlink_file_vma(struct vm_area_struct * ) ;
extern struct vm_area_struct *copy_vma(struct vm_area_struct ** , unsigned long addr ,
                                       unsigned long len , unsigned long pgoff ) ;
extern void exit_mmap(struct mm_struct * ) ;
extern int mm_take_all_locks(struct mm_struct *mm ) ;
extern void mm_drop_all_locks(struct mm_struct *mm ) ;
extern void added_exe_file_vma(struct mm_struct *mm ) ;
extern void removed_exe_file_vma(struct mm_struct *mm ) ;
extern int may_expand_vm(struct mm_struct *mm , unsigned long npages ) ;
extern int install_special_mapping(struct mm_struct *mm , unsigned long addr , unsigned long len ,
                                   unsigned long flags , struct page **pages ) ;
extern unsigned long get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                       unsigned long  , unsigned long  ) ;
extern unsigned long do_mmap_pgoff(struct file *file , unsigned long addr , unsigned long len ,
                                   unsigned long prot , unsigned long flag , unsigned long pgoff ) ;
extern unsigned long mmap_region(struct file *file , unsigned long addr , unsigned long len ,
                                 unsigned long flags , unsigned int vm_flags , unsigned long pgoff ) ;
__inline static unsigned long do_mmap(struct file *file , unsigned long addr , unsigned long len ,
                                      unsigned long prot , unsigned long flag , unsigned long offset ) 
{ unsigned long ret ;

  {
  {
  ret = 0xffffffeaUL;
  }
  if (offset + ((len + ((1UL << 12) - 1UL)) & ~ ((1UL << 12) - 1UL)) < offset) {
    goto out;
  }
  if (! (offset & ~ (~ ((1UL << 12) - 1UL)))) {
    {
    ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 12);
    }
  }
  out: 
  return (ret);
}
}
extern int do_munmap(struct mm_struct * , unsigned long  , size_t  ) ;
extern unsigned long do_brk(unsigned long  , unsigned long  ) ;
extern unsigned long page_unuse(struct page * ) ;
extern void truncate_inode_pages(struct address_space * , loff_t  ) ;
extern void truncate_inode_pages_range(struct address_space * , loff_t lstart , loff_t lend ) ;
extern int filemap_fault(struct vm_area_struct * , struct vm_fault * ) ;
extern int write_one_page(struct page *page , int wait ) ;
extern void task_dirty_inc(struct task_struct *tsk ) ;
extern int do_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                   unsigned long offset , unsigned long nr_to_read ) ;
extern int force_page_cache_readahead(struct address_space *mapping , struct file *filp ,
                                      unsigned long offset , unsigned long nr_to_read ) ;
extern void page_cache_sync_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                      struct file *filp , unsigned long offset , unsigned long size ) ;
extern void page_cache_async_readahead(struct address_space *mapping , struct file_ra_state *ra ,
                                       struct file *filp , struct page *pg , unsigned long offset ,
                                       unsigned long size ) ;
extern unsigned long max_sane_readahead(unsigned long nr ) ;
extern int expand_stack(struct vm_area_struct *vma , unsigned long address ) ;
extern int expand_stack_downwards(struct vm_area_struct *vma , unsigned long address ) ;
extern struct vm_area_struct *find_vma(struct mm_struct *mm , unsigned long addr ) ;
extern struct vm_area_struct *find_vma_prev(struct mm_struct *mm , unsigned long addr ,
                                            struct vm_area_struct **pprev ) ;
__inline static struct vm_area_struct *find_vma_intersection(struct mm_struct *mm ,
                                                             unsigned long start_addr ,
                                                             unsigned long end_addr ) 
{ struct vm_area_struct *vma ;
  struct vm_area_struct *tmp ;

  {
  {
  tmp = find_vma(mm, start_addr);
  vma = tmp;
  }
  if (vma) {
    if (end_addr <= vma->vm_start) {
      {
      vma = (struct vm_area_struct *)((void *)0);
      }
    }
  }
  return (vma);
}
}
__inline static unsigned long vma_pages(struct vm_area_struct *vma ) 
{ 

  {
  return ((vma->vm_end - vma->vm_start) >> 12);
}
}
extern pgprot_t vm_get_page_prot(unsigned long vm_flags ) ;
extern struct vm_area_struct *find_extend_vma(struct mm_struct * , unsigned long addr ) ;
extern int remap_pfn_range(struct vm_area_struct * , unsigned long addr , unsigned long pfn ,
                           unsigned long size , pgprot_t  ) ;
extern int vm_insert_page(struct vm_area_struct * , unsigned long addr , struct page * ) ;
extern int vm_insert_pfn(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
extern int vm_insert_mixed(struct vm_area_struct *vma , unsigned long addr , unsigned long pfn ) ;
extern struct page *follow_page(struct vm_area_struct * , unsigned long address ,
                                unsigned int foll_flags ) ;
extern int apply_to_page_range(struct mm_struct *mm , unsigned long address , unsigned long size ,
                               int (*fn)(pte_t *pte , pgtable_t token , unsigned long addr ,
                                         void *data ) , void *data ) ;
extern void vm_stat_account(struct mm_struct * , unsigned long  , struct file * ,
                            long  ) ;
__inline static void kernel_map_pages(struct page *page , int numpages , int enable ) 
{ 

  {
  return;
}
}
__inline static bool kernel_page_present(struct page *page ) 
{ 

  {
  return ((_Bool)1);
}
}
extern struct vm_area_struct *get_gate_vma(struct task_struct *tsk ) ;
extern int in_gate_area_no_task(unsigned long addr ) ;
extern int in_gate_area(struct task_struct *task , unsigned long addr ) ;
extern int drop_caches_sysctl_handler(struct ctl_table * , int  , struct file * ,
                                      void * , size_t * , loff_t * ) ;
extern unsigned long shrink_slab(unsigned long scanned , gfp_t gfp_mask , unsigned long lru_pages ) ;
extern int randomize_va_space ;
extern char const   *arch_vma_name(struct vm_area_struct *vma ) ;
extern void print_vma_addr(char *prefix , unsigned long rip ) ;
extern struct page *sparse_mem_map_populate(unsigned long pnum , int nid ) ;
extern pgd_t *vmemmap_pgd_populate(unsigned long addr , int node ) ;
extern pud_t *vmemmap_pud_populate(pgd_t *pgd , unsigned long addr , int node ) ;
extern pmd_t *vmemmap_pmd_populate(pud_t *pud , unsigned long addr , int node ) ;
extern pte_t *vmemmap_pte_populate(pmd_t *pmd , unsigned long addr , int node ) ;
extern void *vmemmap_alloc_block(unsigned long size , int node ) ;
extern void vmemmap_verify(pte_t * , int  , unsigned long  , unsigned long  ) ;
extern int vmemmap_populate_basepages(struct page *start_page , unsigned long pages ,
                                      int node ) ;
extern int vmemmap_populate(struct page *start_page , unsigned long pages , int node ) ;
extern void vmemmap_populate_print_last(void) ;
extern void *alloc_locked_buffer(size_t size ) ;
extern void free_locked_buffer(void *buffer , size_t size ) ;
extern void release_locked_buffer(void *buffer , size_t size ) ;
__inline static unsigned char readb(void const volatile   *addr ) 
{ unsigned char ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
  }
  return (ret);
}
}
__inline static unsigned short readw(void const volatile   *addr ) 
{ unsigned short ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
  }
  return (ret);
}
}
__inline static unsigned int readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
  }
  return (ret);
}
}
__inline static unsigned char __readb(void const volatile   *addr ) 
{ unsigned char ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)));
  }
  return (ret);
}
}
__inline static unsigned short __readw(void const volatile   *addr ) 
{ unsigned short ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)));
  }
  return (ret);
}
}
__inline static unsigned int __readl(void const volatile   *addr ) 
{ unsigned int ret ;

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)));
  }
  return (ret);
}
}
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
  }
  return;
}
}
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
  }
  return;
}
}
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
  }
  return;
}
}
__inline static void __writeb(unsigned char val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "b"
                       " %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)));
  }
  return;
}
}
__inline static void __writew(unsigned short val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "w"
                       " %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)));
  }
  return;
}
}
__inline static void __writel(unsigned int val , void volatile   *addr ) 
{ 

  {
  {
  __asm__  volatile   ("mov"
                       "l"
                       " %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)));
  }
  return;
}
}
__inline static __u64 readq(void const volatile   *addr ) 
{ u32 const volatile   *p ;
  u32 low ;
  u32 high ;

  {
  {
  p = (u32 const volatile   *)addr;
  low = readl((void const volatile   *)p);
  high = readl((void const volatile   *)(p + 1));
  }
  return ((unsigned long long )low + ((unsigned long long )high << 32));
}
}
__inline static void writeq(__u64 val , void volatile   *addr ) 
{ 

  {
  {
  writel((unsigned int )val, addr);
  writel((unsigned int )(val >> 32), addr + 4);
  }
  return;
}
}
__inline static phys_addr_t virt_to_phys(void volatile   *address ) 
{ 

  {
  return ((unsigned int )((unsigned long )address - 3221225472UL));
}
}
__inline static void *phys_to_virt(phys_addr_t address ) 
{ 

  {
  return ((void *)((unsigned long )address + 3221225472UL));
}
}
__inline static unsigned int isa_virt_to_bus(void volatile   *address ) 
{ phys_addr_t tmp ;

  {
  {
  tmp = virt_to_phys(address);
  }
  return (tmp);
}
}
extern void *ioremap_nocache(resource_size_t offset , unsigned long size ) ;
extern void *ioremap_cache(resource_size_t offset , unsigned long size ) ;
extern void *ioremap_prot(resource_size_t offset , unsigned long size , unsigned long prot_val ) ;
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ void *tmp ;

  {
  {
  tmp = ioremap_nocache(offset, size);
  }
  return (tmp);
}
}
extern void iounmap(void volatile   *addr ) ;
extern unsigned int ioread8(void * ) ;
extern unsigned int ioread16(void * ) ;
extern unsigned int ioread16be(void * ) ;
extern unsigned int ioread32(void * ) ;
extern unsigned int ioread32be(void * ) ;
extern void iowrite8(u8  , void * ) ;
extern void iowrite16(u16  , void * ) ;
extern void iowrite16be(u16  , void * ) ;
extern void iowrite32(u32  , void * ) ;
extern void iowrite32be(u32  , void * ) ;
extern void ioread8_rep(void *port , void *buf , unsigned long count ) ;
extern void ioread16_rep(void *port , void *buf , unsigned long count ) ;
extern void ioread32_rep(void *port , void *buf , unsigned long count ) ;
extern void iowrite8_rep(void *port , void const   *buf , unsigned long count ) ;
extern void iowrite16_rep(void *port , void const   *buf , unsigned long count ) ;
extern void iowrite32_rep(void *port , void const   *buf , unsigned long count ) ;
extern void *ioport_map(unsigned long port , unsigned int nr ) ;
extern void ioport_unmap(void * ) ;
extern void *pci_iomap(struct pci_dev *dev , int bar , unsigned long max ) ;
extern void pci_iounmap(struct pci_dev *dev , void * ) ;
extern void vm_unmap_ram(void const   *mem , unsigned int count ) ;
extern void *vm_map_ram(struct page **pages , unsigned int count , int node , pgprot_t prot ) ;
extern void vm_unmap_aliases(void) ;
extern void vmalloc_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void *vmalloc(unsigned long size ) ;
extern void *vmalloc_user(unsigned long size ) ;
extern void *vmalloc_node(unsigned long size , int node ) ;
extern void *vmalloc_exec(unsigned long size ) ;
extern void *vmalloc_32(unsigned long size ) ;
extern void *vmalloc_32_user(unsigned long size ) ;
extern void *__vmalloc(unsigned long size , gfp_t gfp_mask , pgprot_t prot ) ;
extern void *__vmalloc_area(struct vm_struct *area , gfp_t gfp_mask , pgprot_t prot ) ;
extern void vfree(void const   *addr ) ;
extern void *vmap(struct page **pages , unsigned int count , unsigned long flags ,
                  pgprot_t prot ) ;
extern void vunmap(void const   *addr ) ;
extern int remap_vmalloc_range(struct vm_area_struct *vma , void *addr , unsigned long pgoff ) ;
extern void vmalloc_sync_all(void) ;
__inline static size_t get_vm_area_size(struct vm_struct  const  *area ) 
{ 

  {
  return ((unsigned int )(area->size - (unsigned long const   )(1UL << 12)));
}
}
extern struct vm_struct *get_vm_area(unsigned long size , unsigned long flags ) ;
extern struct vm_struct *get_vm_area_caller(unsigned long size , unsigned long flags ,
                                            void *caller ) ;
extern struct vm_struct *__get_vm_area(unsigned long size , unsigned long flags ,
                                       unsigned long start , unsigned long end ) ;
extern struct vm_struct *__get_vm_area_caller(unsigned long size , unsigned long flags ,
                                              unsigned long start , unsigned long end ,
                                              void *caller ) ;
extern struct vm_struct *get_vm_area_node(unsigned long size , unsigned long flags ,
                                          int node , gfp_t gfp_mask ) ;
extern struct vm_struct *remove_vm_area(void const   *addr ) ;
extern int map_vm_area(struct vm_struct *area , pgprot_t prot , struct page ***pages ) ;
extern int map_kernel_range_noflush(unsigned long start , unsigned long size , pgprot_t prot ,
                                    struct page **pages ) ;
extern void unmap_kernel_range_noflush(unsigned long addr , unsigned long size ) ;
extern void unmap_kernel_range(unsigned long addr , unsigned long size ) ;
extern struct vm_struct *alloc_vm_area(size_t size ) ;
extern void free_vm_area(struct vm_struct *area ) ;
extern long vread(char *buf , char *addr , unsigned long count ) ;
extern long vwrite(char *buf , char *addr , unsigned long count ) ;
extern rwlock_t vmlist_lock ;
extern struct vm_struct *vmlist ;
extern void vm_area_register_early(struct vm_struct *vm , size_t align )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
__inline static void memset_io(void volatile   *addr , unsigned char val , int count ) 
{ 

  {
  {
  __memset_generic((void *)addr, (char )val, (unsigned int )count);
  }
  return;
}
}
__inline static void memcpy_fromio(void *dst , void const volatile   *src , int count ) 
{ 

  {
  {
  __memcpy(dst, (void const   *)src, (unsigned int )count);
  }
  return;
}
}
__inline static void memcpy_toio(void volatile   *dst , void const   *src , int count ) 
{ 

  {
  {
  __memcpy((void *)dst, src, (unsigned int )count);
  }
  return;
}
}
extern void native_io_delay(void) ;
extern int io_delay_type ;
extern void io_delay_init(void) ;
__inline static void slow_down_io(void) 
{ 

  {
  {
  native_io_delay();
  }
  return;
}
}
__inline static void outb_local(unsigned char value , int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned char inb_local(int port ) 
{ unsigned char value ;

  {
  {
  __asm__  volatile   ("in"
                       "b"
                       " %w1, %"
                       "b"
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void outb_local_p(unsigned char value , int port ) 
{ 

  {
  {
  outb_local(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned char inb_local_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  {
  tmp = inb_local(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outb(unsigned char value , int port ) 
{ 

  {
  {
  outb_local(value, port);
  }
  return;
}
}
__inline static unsigned char inb(int port ) 
{ unsigned char tmp ;

  {
  {
  tmp = inb_local(port);
  }
  return (tmp);
}
}
__inline static void outb_p(unsigned char value , int port ) 
{ 

  {
  {
  outb(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned char inb_p(int port ) 
{ unsigned char value ;
  unsigned char tmp ;

  {
  {
  tmp = inb(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outsb(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "b": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void insb(int port , void *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "b": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void outw_local(unsigned short value , int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned short inw_local(int port ) 
{ unsigned short value ;

  {
  {
  __asm__  volatile   ("in"
                       "w"
                       " %w1, %"
                       "w"
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void outw_local_p(unsigned short value , int port ) 
{ 

  {
  {
  outw_local(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned short inw_local_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  {
  tmp = inw_local(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outw(unsigned short value , int port ) 
{ 

  {
  {
  outw_local(value, port);
  }
  return;
}
}
__inline static unsigned short inw(int port ) 
{ unsigned short tmp ;

  {
  {
  tmp = inw_local(port);
  }
  return (tmp);
}
}
__inline static void outw_p(unsigned short value , int port ) 
{ 

  {
  {
  outw(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned short inw_p(int port ) 
{ unsigned short value ;
  unsigned short tmp ;

  {
  {
  tmp = inw(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outsw(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "w": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void insw(int port , void *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "w": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void outl_local(unsigned int value , int port ) 
{ 

  {
  {
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       ""
                       "0, %w1": : "a" (value), "Nd" (port));
  }
  return;
}
}
__inline static unsigned int inl_local(int port ) 
{ unsigned int value ;

  {
  {
  __asm__  volatile   ("in"
                       "l"
                       " %w1, %"
                       ""
                       "0": "=a" (value): "Nd" (port));
  }
  return (value);
}
}
__inline static void outl_local_p(unsigned int value , int port ) 
{ 

  {
  {
  outl_local(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned int inl_local_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  {
  tmp = inl_local(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outl(unsigned int value , int port ) 
{ 

  {
  {
  outl_local(value, port);
  }
  return;
}
}
__inline static unsigned int inl(int port ) 
{ unsigned int tmp ;

  {
  {
  tmp = inl_local(port);
  }
  return (tmp);
}
}
__inline static void outl_p(unsigned int value , int port ) 
{ 

  {
  {
  outl(value, port);
  slow_down_io();
  }
  return;
}
}
__inline static unsigned int inl_p(int port ) 
{ unsigned int value ;
  unsigned int tmp ;

  {
  {
  tmp = inl(port);
  value = tmp;
  slow_down_io();
  }
  return (value);
}
}
__inline static void outsl(int port , void const   *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; outs"
                       "l": "+S" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
__inline static void insl(int port , void *addr , unsigned long count ) 
{ 

  {
  {
  __asm__  volatile   ("rep; ins"
                       "l": "+D" (addr), "+c" (count): "d" (port));
  }
  return;
}
}
extern void *xlate_dev_mem_ptr(unsigned long phys ) ;
extern void unxlate_dev_mem_ptr(unsigned long phys , void *addr ) ;
extern int ioremap_change_attr(unsigned long vaddr , unsigned long size , unsigned long prot_val ) ;
extern void *ioremap_wc(resource_size_t offset , unsigned long size ) ;
extern void early_ioremap_init(void) ;
extern void early_ioremap_reset(void) ;
extern void *early_ioremap(resource_size_t phys_addr , unsigned long size ) ;
extern void *early_memremap(resource_size_t phys_addr , unsigned long size ) ;
extern void early_iounmap(void *addr , unsigned long size ) ;
__inline static void sg_assign_page(struct scatterlist *sg , struct page *page ) 
{ unsigned long page_link ;
  long tmp ;

  {
  {
  page_link = sg->page_link & 3UL;
  }
  {
  while (1) {
    while_113_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! ((unsigned long )page & 3UL))), 0L);
    }
    if (tmp) {
      {
      while (1) {
        while_114_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/scatterlist.h"),
                             "i" (63), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_115_continue: /* CIL Label */ ;
        }
        while_115_break: /* CIL Label */ ;
        }
        goto while_114_break;
      }
      while_114_break: /* CIL Label */ ;
      }
    }
    goto while_113_break;
  }
  while_113_break: /* CIL Label */ ;
  }
  {
  sg->page_link = page_link | (unsigned long )page;
  }
  return;
}
}
__inline static void sg_set_page(struct scatterlist *sg , struct page *page , unsigned int len ,
                                 unsigned int offset ) 
{ 

  {
  {
  sg_assign_page(sg, page);
  sg->offset = offset;
  sg->length = len;
  }
  return;
}
}
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 

  {
  return ((struct page *)(sg->page_link & 0xfffffffcUL));
}
}
__inline static void sg_set_buf(struct scatterlist *sg , void const   *buf , unsigned int buflen ) 
{ 

  {
  {
  sg_set_page(sg, mem_map + (((unsigned long )buf - 3221225472UL) >> 12), buflen,
              (unsigned int )((unsigned long )buf & ~ (~ ((1UL << 12) - 1UL))));
  }
  return;
}
}
__inline static void sg_chain(struct scatterlist *prv , unsigned int prv_nents , struct scatterlist *sgl ) 
{ 

  {
  {
  (prv + (prv_nents - 1U))->offset = 0U;
  (prv + (prv_nents - 1U))->length = 0U;
  (prv + (prv_nents - 1U))->page_link = ((unsigned long )sgl | 1UL) & 0xfffffffdUL;
  }
  return;
}
}
__inline static void sg_mark_end(struct scatterlist *sg ) 
{ 

  {
  {
  sg->page_link |= 2UL;
  sg->page_link &= 0xfffffffeUL;
  }
  return;
}
}
__inline static dma_addr_t sg_phys(struct scatterlist *sg ) 
{ struct page *tmp ;

  {
  {
  tmp = sg_page(sg);
  }
  return (((unsigned int )((unsigned long )(tmp - mem_map)) << 12) + sg->offset);
}
}
__inline static void *sg_virt(struct scatterlist *sg ) 
{ struct page *tmp ;
  void *tmp___0 ;

  {
  {
  tmp = sg_page(sg);
  tmp___0 = page_address(tmp);
  }
  return (tmp___0 + sg->offset);
}
}
extern struct scatterlist *sg_next(struct scatterlist * ) ;
extern struct scatterlist *sg_last(struct scatterlist *s , unsigned int  ) ;
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
extern void sg_init_one(struct scatterlist * , void const   * , unsigned int  ) ;
extern void __sg_free_table(struct sg_table * , unsigned int  , sg_free_fn * ) ;
extern void sg_free_table(struct sg_table * ) ;
extern int __sg_alloc_table(struct sg_table * , unsigned int  , unsigned int  , gfp_t  ,
                            sg_alloc_fn * ) ;
extern int sg_alloc_table(struct sg_table * , unsigned int  , gfp_t  ) ;
extern size_t sg_copy_from_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                  size_t buflen ) ;
extern size_t sg_copy_to_buffer(struct scatterlist *sgl , unsigned int nents , void *buf ,
                                size_t buflen ) ;
extern void sg_miter_start(struct sg_mapping_iter *miter , struct scatterlist *sgl ,
                           unsigned int nents , unsigned int flags ) ;
extern bool sg_miter_next(struct sg_mapping_iter *miter ) ;
extern void sg_miter_stop(struct sg_mapping_iter *miter ) ;
__inline static int valid_dma_direction(int dma_direction ) 
{ int tmp ;

  {
  if (dma_direction == 0) {
    {
    tmp = 1;
    }
  } else {
    if (dma_direction == 1) {
      {
      tmp = 1;
      }
    } else {
      if (dma_direction == 2) {
        {
        tmp = 1;
        }
      } else {
        {
        tmp = 0;
        }
      }
    }
  }
  return (tmp);
}
}
__inline static int is_device_dma_capable(struct device *dev ) 
{ int tmp ;

  {
  if ((unsigned long )dev->dma_mask != (unsigned long )((void *)0)) {
    if (*(dev->dma_mask) != 0ULL) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static int is_buffer_dma_capable(u64 mask , dma_addr_t addr , size_t size ) 
{ 

  {
  return ((u64 )(addr + size) <= mask);
}
}
__inline static void dma_debug_add_bus(struct bus_type *bus ) 
{ 

  {
  return;
}
}
__inline static void dma_debug_init(u32 num_entries ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , int direction , dma_addr_t dma_addr ,
                                        bool map_single ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                          int direction , bool map_single ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_map_sg(struct device *dev , struct scatterlist *sg ,
                                      int nents , int mapped_ents , int direction ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_unmap_sg(struct device *dev , struct scatterlist *sglist ,
                                        int nelems , int dir ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t dma_addr ,
                                              void *virt ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_free_coherent(struct device *dev , size_t size , void *virt ,
                                             dma_addr_t addr ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_sync_single_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                   size_t size , int direction ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t dma_handle ,
                                                         unsigned long offset , size_t size ,
                                                         int direction ) 
{ 

  {
  return;
}
}
__inline static void debug_dma_dump_mappings(struct device *dev ) 
{ 

  {
  return;
}
}
extern void swiotlb_init(void) ;
extern void *swiotlb_alloc_boot(size_t bytes , unsigned long nslabs ) ;
extern void *swiotlb_alloc(unsigned int order , unsigned long nslabs ) ;
extern dma_addr_t swiotlb_phys_to_bus(struct device *hwdev , phys_addr_t address ) ;
extern phys_addr_t swiotlb_bus_to_phys(dma_addr_t address ) ;
extern int swiotlb_arch_range_needs_mapping(phys_addr_t paddr , size_t size ) ;
extern void *swiotlb_alloc_coherent(struct device *hwdev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t flags ) ;
extern void swiotlb_free_coherent(struct device *hwdev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
extern dma_addr_t swiotlb_map_page(struct device *dev , struct page *page , unsigned long offset ,
                                   size_t size , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern void swiotlb_unmap_page(struct device *hwdev , dma_addr_t dev_addr , size_t size ,
                               enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern int swiotlb_map_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                          int direction ) ;
extern void swiotlb_unmap_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                             int direction ) ;
extern int swiotlb_map_sg_attrs(struct device *hwdev , struct scatterlist *sgl , int nelems ,
                                enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern void swiotlb_unmap_sg_attrs(struct device *hwdev , struct scatterlist *sgl ,
                                   int nelems , enum dma_data_direction dir , struct dma_attrs *attrs ) ;
extern void swiotlb_sync_single_for_cpu(struct device *hwdev , dma_addr_t dev_addr ,
                                        size_t size , enum dma_data_direction dir ) ;
extern void swiotlb_sync_sg_for_cpu(struct device *hwdev , struct scatterlist *sg ,
                                    int nelems , enum dma_data_direction dir ) ;
extern void swiotlb_sync_single_for_device(struct device *hwdev , dma_addr_t dev_addr ,
                                           size_t size , enum dma_data_direction dir ) ;
extern void swiotlb_sync_sg_for_device(struct device *hwdev , struct scatterlist *sg ,
                                       int nelems , enum dma_data_direction dir ) ;
extern void swiotlb_sync_single_range_for_cpu(struct device *hwdev , dma_addr_t dev_addr ,
                                              unsigned long offset , size_t size ,
                                              enum dma_data_direction dir ) ;
extern void swiotlb_sync_single_range_for_device(struct device *hwdev , dma_addr_t dev_addr ,
                                                 unsigned long offset , size_t size ,
                                                 enum dma_data_direction dir ) ;
extern int swiotlb_dma_mapping_error(struct device *hwdev , dma_addr_t dma_addr ) ;
extern int swiotlb_dma_supported(struct device *hwdev , u64 mask ) ;
extern int swiotlb_force ;
__inline static void dma_mark_clean(void *addr , size_t size ) 
{ 

  {
  return;
}
}
extern int dma_alloc_from_coherent(struct device *dev , ssize_t size , dma_addr_t *dma_handle ,
                                   void **ret ) ;
extern int dma_release_from_coherent(struct device *dev , int order , void *vaddr ) ;
extern int dma_declare_coherent_memory(struct device *dev , dma_addr_t bus_addr ,
                                       dma_addr_t device_addr , size_t size , int flags ) ;
extern void dma_release_declared_memory(struct device *dev ) ;
extern void *dma_mark_declared_memory_occupied(struct device *dev , dma_addr_t device_addr ,
                                               size_t size ) ;
extern dma_addr_t bad_dma_address ;
extern int iommu_merge ;
extern struct device x86_dma_fallback_dev ;
extern int panic_on_overflow ;
extern struct dma_map_ops *dma_ops ;
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 

  {
  return (dma_ops);
}
}
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  if (ops->mapping_error) {
    {
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
    }
    return (tmp___0);
  }
  return (dma_addr == bad_dma_address);
}
}
extern int dma_supported(struct device *hwdev , u64 mask ) ;
extern int dma_set_mask(struct device *dev , u64 mask ) ;
extern void *dma_generic_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_addr ,
                                        gfp_t flag ) ;
__inline static dma_addr_t dma_map_single(struct device *hwdev , void *ptr , size_t size ,
                                          enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_116_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_117_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (62), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_118_continue: /* CIL Label */ ;
        }
        while_118_break: /* CIL Label */ ;
        }
        goto while_117_break;
      }
      while_117_break: /* CIL Label */ ;
      }
    }
    goto while_116_break;
  }
  while_116_break: /* CIL Label */ ;
  }
  {
  addr = (*(ops->map_page))(hwdev, mem_map + (((unsigned long )ptr - 3221225472UL) >> 12),
                            (unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL)), size,
                            dir, (struct dma_attrs *)((void *)0));
  debug_dma_map_page(hwdev, mem_map + (((unsigned long )ptr - 3221225472UL) >> 12),
                     (unsigned int )((unsigned long )ptr & ~ (~ ((1UL << 12) - 1UL))),
                     size, (int )dir, addr, (_Bool)1);
  }
  return (addr);
}
}
__inline static void dma_unmap_single(struct device *dev , dma_addr_t addr , size_t size ,
                                      enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_119_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_120_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (78), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_121_continue: /* CIL Label */ ;
        }
        while_121_break: /* CIL Label */ ;
        }
        goto while_120_break;
      }
      while_120_break: /* CIL Label */ ;
      }
    }
    goto while_119_break;
  }
  while_119_break: /* CIL Label */ ;
  }
  if (ops->unmap_page) {
    {
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)((void *)0));
    }
  }
  {
  debug_dma_unmap_page(dev, addr, size, (int )dir, (_Bool)1);
  }
  return;
}
}
__inline static int dma_map_sg(struct device *hwdev , struct scatterlist *sg , int nents ,
                               enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int ents ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_122_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_123_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (91), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_124_continue: /* CIL Label */ ;
        }
        while_124_break: /* CIL Label */ ;
        }
        goto while_123_break;
      }
      while_123_break: /* CIL Label */ ;
      }
    }
    goto while_122_break;
  }
  while_122_break: /* CIL Label */ ;
  }
  {
  ents = (*(ops->map_sg))(hwdev, sg, nents, dir, (struct dma_attrs *)((void *)0));
  debug_dma_map_sg(hwdev, sg, nents, ents, (int )dir);
  }
  return (ents);
}
}
__inline static void dma_unmap_sg(struct device *hwdev , struct scatterlist *sg ,
                                  int nents , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_125_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_126_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (104), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_127_continue: /* CIL Label */ ;
        }
        while_127_break: /* CIL Label */ ;
        }
        goto while_126_break;
      }
      while_126_break: /* CIL Label */ ;
      }
    }
    goto while_125_break;
  }
  while_125_break: /* CIL Label */ ;
  }
  {
  debug_dma_unmap_sg(hwdev, sg, nents, (int )dir);
  }
  if (ops->unmap_sg) {
    {
    (*(ops->unmap_sg))(hwdev, sg, nents, dir, (struct dma_attrs *)((void *)0));
    }
  }
  return;
}
}
__inline static void dma_sync_single_for_cpu(struct device *hwdev , dma_addr_t dma_handle ,
                                             size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_128_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_129_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (116), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_130_continue: /* CIL Label */ ;
        }
        while_130_break: /* CIL Label */ ;
        }
        goto while_129_break;
      }
      while_129_break: /* CIL Label */ ;
      }
    }
    goto while_128_break;
  }
  while_128_break: /* CIL Label */ ;
  }
  if (ops->sync_single_for_cpu) {
    {
    (*(ops->sync_single_for_cpu))(hwdev, dma_handle, size, dir);
    }
  }
  {
  debug_dma_sync_single_for_cpu(hwdev, dma_handle, size, (int )dir);
  }
  {
  while (1) {
    while_131_continue: /* CIL Label */ ;
    goto while_131_break;
  }
  while_131_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_single_for_device(struct device *hwdev , dma_addr_t dma_handle ,
                                                size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_132_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_133_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (129), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_134_continue: /* CIL Label */ ;
        }
        while_134_break: /* CIL Label */ ;
        }
        goto while_133_break;
      }
      while_133_break: /* CIL Label */ ;
      }
    }
    goto while_132_break;
  }
  while_132_break: /* CIL Label */ ;
  }
  if (ops->sync_single_for_device) {
    {
    (*(ops->sync_single_for_device))(hwdev, dma_handle, size, dir);
    }
  }
  {
  debug_dma_sync_single_for_cpu(hwdev, dma_handle, size, (int )dir);
  }
  {
  while (1) {
    while_135_continue: /* CIL Label */ ;
    goto while_135_break;
  }
  while_135_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_single_range_for_cpu(struct device *hwdev , dma_addr_t dma_handle ,
                                                   unsigned long offset , size_t size ,
                                                   enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_136_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_137_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (143), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_138_continue: /* CIL Label */ ;
        }
        while_138_break: /* CIL Label */ ;
        }
        goto while_137_break;
      }
      while_137_break: /* CIL Label */ ;
      }
    }
    goto while_136_break;
  }
  while_136_break: /* CIL Label */ ;
  }
  if (ops->sync_single_range_for_cpu) {
    {
    (*(ops->sync_single_range_for_cpu))(hwdev, dma_handle, offset, size, dir);
    }
  }
  {
  debug_dma_sync_single_range_for_cpu(hwdev, dma_handle, offset, size, (int )dir);
  }
  {
  while (1) {
    while_139_continue: /* CIL Label */ ;
    goto while_139_break;
  }
  while_139_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_single_range_for_device(struct device *hwdev , dma_addr_t dma_handle ,
                                                      unsigned long offset , size_t size ,
                                                      enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_140_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_141_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (159), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_142_continue: /* CIL Label */ ;
        }
        while_142_break: /* CIL Label */ ;
        }
        goto while_141_break;
      }
      while_141_break: /* CIL Label */ ;
      }
    }
    goto while_140_break;
  }
  while_140_break: /* CIL Label */ ;
  }
  if (ops->sync_single_range_for_device) {
    {
    (*(ops->sync_single_range_for_device))(hwdev, dma_handle, offset, size, dir);
    }
  }
  {
  debug_dma_sync_single_range_for_cpu(hwdev, dma_handle, offset, size, (int )dir);
  }
  {
  while (1) {
    while_143_continue: /* CIL Label */ ;
    goto while_143_break;
  }
  while_143_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_sg_for_cpu(struct device *hwdev , struct scatterlist *sg ,
                                         int nelems , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_144_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_145_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (174), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_146_continue: /* CIL Label */ ;
        }
        while_146_break: /* CIL Label */ ;
        }
        goto while_145_break;
      }
      while_145_break: /* CIL Label */ ;
      }
    }
    goto while_144_break;
  }
  while_144_break: /* CIL Label */ ;
  }
  if (ops->sync_sg_for_cpu) {
    {
    (*(ops->sync_sg_for_cpu))(hwdev, sg, nelems, dir);
    }
  }
  {
  debug_dma_unmap_sg(hwdev, sg, nelems, (int )dir);
  }
  {
  while (1) {
    while_147_continue: /* CIL Label */ ;
    goto while_147_break;
  }
  while_147_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void dma_sync_sg_for_device(struct device *hwdev , struct scatterlist *sg ,
                                            int nelems , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(hwdev);
  ops = tmp;
  }
  {
  while (1) {
    while_148_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_149_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (187), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_150_continue: /* CIL Label */ ;
        }
        while_150_break: /* CIL Label */ ;
        }
        goto while_149_break;
      }
      while_149_break: /* CIL Label */ ;
      }
    }
    goto while_148_break;
  }
  while_148_break: /* CIL Label */ ;
  }
  if (ops->sync_sg_for_device) {
    {
    (*(ops->sync_sg_for_device))(hwdev, sg, nelems, dir);
    }
  }
  {
  debug_dma_unmap_sg(hwdev, sg, nelems, (int )dir);
  }
  {
  while (1) {
    while_151_continue: /* CIL Label */ ;
    goto while_151_break;
  }
  while_151_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_152_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_153_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (202), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_154_continue: /* CIL Label */ ;
        }
        while_154_break: /* CIL Label */ ;
        }
        goto while_153_break;
      }
      while_153_break: /* CIL Label */ ;
      }
    }
    goto while_152_break;
  }
  while_152_break: /* CIL Label */ ;
  }
  {
  addr = (*(ops->map_page))(dev, page, (unsigned long )offset, size, dir, (struct dma_attrs *)((void *)0));
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, (_Bool)0);
  }
  return (addr);
}
}
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_155_continue: /* CIL Label */ ;
    {
    tmp___0 = valid_dma_direction((int )dir);
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
    {
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
    if (tmp___2) {
      {
      while (1) {
        while_156_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h"),
                             "i" (214), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_157_continue: /* CIL Label */ ;
        }
        while_157_break: /* CIL Label */ ;
        }
        goto while_156_break;
      }
      while_156_break: /* CIL Label */ ;
      }
    }
    goto while_155_break;
  }
  while_155_break: /* CIL Label */ ;
  }
  if (ops->unmap_page) {
    {
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)((void *)0));
    }
  }
  {
  debug_dma_unmap_page(dev, addr, size, (int )dir, (_Bool)0);
  }
  return;
}
}
__inline static void dma_cache_sync(struct device *dev , void *vaddr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 

  {
  {
  while (1) {
    while_158_continue: /* CIL Label */ ;
    goto while_158_break;
  }
  while_158_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int dma_get_cache_alignment(void) 
{ 

  {
  return ((int )boot_cpu_data.x86_clflush_size);
}
}
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;

  {
  {
  dma_mask = 0UL;
  dma_mask = (unsigned long )dev->coherent_dma_mask;
  }
  if (! dma_mask) {
    if (gfp & 1U) {
      {
      dma_mask = (unsigned long )((1ULL << 24) - 1ULL);
      }
    } else {
      {
      dma_mask = (unsigned long )((1ULL << 32) - 1ULL);
      }
    }
  }
  return (dma_mask);
}
}
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ unsigned long dma_mask ;
  unsigned long tmp ;

  {
  {
  tmp = dma_alloc_coherent_mask(dev, gfp);
  dma_mask = tmp;
  }
  if ((unsigned long long )dma_mask <= (1ULL << 24) - 1ULL) {
    {
    gfp |= 1U;
    }
  }
  return (gfp);
}
}
__inline static void *dma_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                         gfp_t gfp ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  int tmp___1 ;
  gfp_t tmp___2 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  gfp &= 4294967288U;
  tmp___0 = dma_alloc_from_coherent(dev, (int )size, dma_handle, & memory);
  }
  if (tmp___0) {
    return (memory);
  }
  if (! dev) {
    {
    dev = & x86_dma_fallback_dev;
    gfp |= 1U;
    }
  }
  {
  tmp___1 = is_device_dma_capable(dev);
  }
  if (! tmp___1) {
    return ((void *)0);
  }
  if (! ops->alloc_coherent) {
    return ((void *)0);
  }
  {
  tmp___2 = dma_alloc_coherent_gfp_flags(dev, gfp);
  memory = (*(ops->alloc_coherent))(dev, size, dma_handle, tmp___2);
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
  return (memory);
}
}
__inline static void dma_free_coherent(struct device *dev , size_t size , void *vaddr ,
                                       dma_addr_t bus ) 
{ struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  }
  {
  while (1) {
    while_159_continue: /* CIL Label */ ;
    {
    _flags = __raw_local_save_flags();
    }
    goto while_159_break;
  }
  while_159_break: /* CIL Label */ ;
  }
  {
  tmp___0 = raw_irqs_disabled_flags(_flags);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  __ret_warn_on = tmp___1;
  tmp___2 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
  if (tmp___2) {
    {
    warn_slowpath_null("/home/kalmera/goblint_stuff/goblint/../linux-headers/arch/x86/include/asm/dma-mapping.h",
                       294);
    }
  }
  {
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  tmp___3 = get_order((unsigned long )size);
  tmp___4 = dma_release_from_coherent(dev, tmp___3, vaddr);
  }
  if (tmp___4) {
    return;
  }
  {
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
  if (ops->free_coherent) {
    {
    (*(ops->free_coherent))(dev, size, vaddr, bus);
    }
  }
  return;
}
}
__inline static u64 dma_get_mask(struct device *dev ) 
{ 

  {
  if (dev) {
    if (dev->dma_mask) {
      if (*(dev->dma_mask)) {
        return (*(dev->dma_mask));
      }
    }
  }
  return ((1ULL << 32) - 1ULL);
}
}
extern u64 dma_get_required_mask(struct device *dev ) ;
__inline static unsigned int dma_get_max_seg_size(struct device *dev ) 
{ unsigned int tmp ;

  {
  if (dev->dma_parms) {
    {
    tmp = (dev->dma_parms)->max_segment_size;
    }
  } else {
    {
    tmp = 65536U;
    }
  }
  return (tmp);
}
}
__inline static unsigned int dma_set_max_seg_size(struct device *dev , unsigned int size ) 
{ 

  {
  if (dev->dma_parms) {
    {
    (dev->dma_parms)->max_segment_size = size;
    }
    return (0U);
  } else {
    return (4294967291U);
  }
}
}
__inline static unsigned long dma_get_seg_boundary(struct device *dev ) 
{ unsigned long tmp ;

  {
  if (dev->dma_parms) {
    {
    tmp = (dev->dma_parms)->segment_boundary_mask;
    }
  } else {
    {
    tmp = 4294967295UL;
    }
  }
  return (tmp);
}
}
__inline static int dma_set_seg_boundary(struct device *dev , unsigned long mask ) 
{ 

  {
  if (dev->dma_parms) {
    {
    (dev->dma_parms)->segment_boundary_mask = mask;
    }
    return (0);
  } else {
    return (-5);
  }
}
}
extern void *dmam_alloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                 gfp_t gfp ) ;
extern void dmam_free_coherent(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
extern void *dmam_alloc_noncoherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                    gfp_t gfp ) ;
extern void dmam_free_noncoherent(struct device *dev , size_t size , void *vaddr ,
                                  dma_addr_t dma_handle ) ;
extern int dmam_declare_coherent_memory(struct device *dev , dma_addr_t bus_addr ,
                                        dma_addr_t device_addr , size_t size , int flags ) ;
extern void dmam_release_declared_memory(struct device *dev ) ;
__inline static void fw_memcpy_from_be32(void *_dst , void *_src , size_t size ) 
{ u32 *dst ;
  __be32 *src ;
  int i ;
  __u32 tmp ;

  {
  {
  dst = (u32 *)_dst;
  src = (__be32 *)_src;
  i = 0;
  }
  {
  while (1) {
    while_160_continue: /* CIL Label */ ;
    if (! ((size_t )i < size / 4U)) {
      goto while_160_break;
    }
    {
    tmp = __fswab32(*(src + i));
    *(dst + i) = tmp;
    i ++;
    }
  }
  while_160_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void fw_memcpy_to_be32(void *_dst , void *_src , size_t size ) 
{ 

  {
  {
  fw_memcpy_from_be32(_dst, _src, size);
  }
  return;
}
}
int fw_core_add_descriptor(struct fw_descriptor *desc ) ;
void fw_core_remove_descriptor(struct fw_descriptor *desc ) ;
struct fw_address_region  const  fw_high_memory_region ;
int fw_core_add_address_handler(struct fw_address_handler *handler , struct fw_address_region  const  *region ) ;
void fw_core_remove_address_handler(struct fw_address_handler *handler ) ;
void fw_fill_response(struct fw_packet *response , u32 *request_header , int rcode ,
                      void *payload , size_t length ) ;
void fw_send_response(struct fw_card *card , struct fw_request *request , int rcode ) ;
struct bus_type fw_bus_type ;
__inline static struct fw_card *fw_card_get(struct fw_card *card ) 
{ 

  {
  {
  kref_get(& card->kref);
  }
  return (card);
}
}
void fw_card_release(struct kref *kref ) ;
__inline static void fw_card_put(struct fw_card *card ) 
{ 

  {
  {
  kref_put(& card->kref, & fw_card_release);
  }
  return;
}
}
void fw_schedule_bm_work(struct fw_card *card , unsigned long delay ) ;
__inline static bool is_next_generation(int new_generation , int old_generation ) 
{ 

  {
  return ((_Bool )((new_generation & 255) == ((old_generation + 1) & 255)));
}
}
int fw_iso_buffer_init(struct fw_iso_buffer *buffer , struct fw_card *card , int page_count___0 ,
                       enum dma_data_direction direction ) ;
int fw_iso_buffer_map(struct fw_iso_buffer *buffer , struct vm_area_struct *vma ) ;
void fw_iso_buffer_destroy(struct fw_iso_buffer *buffer , struct fw_card *card ) ;
struct fw_iso_context *fw_iso_context_create(struct fw_card *card , int type , int channel ,
                                             int speed , size_t header_size , void (*callback)(struct fw_iso_context *context ,
                                                                                               u32 cycle ,
                                                                                               size_t header_length ,
                                                                                               void *header ,
                                                                                               void *data ) ,
                                             void *callback_data ) ;
int fw_iso_context_queue(struct fw_iso_context *ctx , struct fw_iso_packet *packet ,
                         struct fw_iso_buffer *buffer , unsigned long payload ) ;
int fw_iso_context_start(struct fw_iso_context *ctx , int cycle , int sync , int tags ) ;
int fw_iso_context_stop(struct fw_iso_context *ctx ) ;
void fw_iso_context_destroy(struct fw_iso_context *ctx ) ;
void fw_iso_resource_manage(struct fw_card *card , int generation , u64 channels_mask ,
                            int *channel , int *bandwidth , bool allocate ) ;
int fw_core_initiate_bus_reset(struct fw_card *card , int short_reset ) ;
void fw_send_request(struct fw_card *card , struct fw_transaction *t , int tcode ,
                     int destination_id , int generation , int speed , unsigned long long offset ,
                     void *payload , size_t length , void (*callback)(struct fw_card *card ,
                                                                      int rcode ,
                                                                      void *data ,
                                                                      size_t length ,
                                                                      void *callback_data ) ,
                     void *callback_data ) ;
int fw_cancel_transaction(struct fw_card *card , struct fw_transaction *transaction ) ;
void fw_flush_transactions(struct fw_card *card ) ;
int fw_run_transaction(struct fw_card *card , int tcode , int destination_id , int generation ,
                       int speed , unsigned long long offset , void *payload , size_t length ) ;
void fw_send_phy_config(struct fw_card *card , int node_id , int generation , int gap_count ) ;
__inline static int fw_stream_packet_destination_id(int tag , int channel , int sy ) 
{ 

  {
  return (((tag << 14) | (channel << 8)) | sy);
}
}
void fw_node_event(struct fw_card *card , struct fw_node *node , int event ) ;
void fw_card_initialize(struct fw_card *card , struct fw_card_driver  const  *driver ,
                        struct device *device ) ;
int fw_card_add(struct fw_card *card , u32 max_receive , u32 link_speed , u64 guid ) ;
void fw_core_remove_card(struct fw_card *card ) ;
void fw_core_handle_bus_reset(struct fw_card *card , int node_id , int generation ,
                              int self_id_count , u32 *self_ids ) ;
void fw_core_handle_request(struct fw_card *card , struct fw_packet *p ) ;
void fw_core_handle_response(struct fw_card *card , struct fw_packet *p ) ;
extern int fw_irm_set_broadcast_channel_register(struct device *dev , void *data ) ;
__inline static struct fw_node *fw_node_get(struct fw_node *node ) 
{ 

  {
  {
  atomic_inc(& node->ref_count);
  }
  return (node);
}
}
__inline static void fw_node_put(struct fw_node *node ) 
{ int tmp ;

  {
  {
  tmp = atomic_dec_and_test(& node->ref_count);
  }
  if (tmp) {
    {
    kfree((void const   *)node);
    }
  }
  return;
}
}
void fw_destroy_nodes(struct fw_card *card ) ;
int fw_compute_block_crc(u32 *block ) ;
extern unsigned int __invalid_size_argument_for_IOC ;
__inline static int old_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < 256U) {
    if ((dev & ((1U << 20) - 1U)) < 256U) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static u16 old_encode_dev(dev_t dev ) 
{ 

  {
  return ((unsigned short )(((dev >> 20) << 8) | (dev & ((1U << 20) - 1U))));
}
}
__inline static dev_t old_decode_dev(u16 val ) 
{ 

  {
  return ((unsigned int )(((((int )val >> 8) & 255) << 20) | ((int )val & 255)));
}
}
__inline static int new_valid_dev(dev_t dev ) 
{ 

  {
  return (1);
}
}
__inline static u32 new_encode_dev(dev_t dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
  major = dev >> 20;
  minor = dev & ((1U << 20) - 1U);
  }
  return (((minor & 255U) | (major << 8)) | ((minor & 4294967040U) << 12));
}
}
__inline static dev_t new_decode_dev(u32 dev ) 
{ unsigned int major ;
  unsigned int minor ;

  {
  {
  major = (dev & 1048320U) >> 8;
  minor = (dev & 255U) | ((dev >> 12) & 1048320U);
  }
  return ((major << 20) | minor);
}
}
__inline static u64 huge_encode_dev(dev_t dev ) 
{ u32 tmp ;

  {
  {
  tmp = new_encode_dev(dev);
  }
  return ((unsigned long long )tmp);
}
}
__inline static dev_t huge_decode_dev(u64 dev ) 
{ dev_t tmp ;

  {
  {
  tmp = new_decode_dev((unsigned int )dev);
  }
  return (tmp);
}
}
__inline static int sysv_valid_dev(dev_t dev ) 
{ int tmp ;

  {
  if (dev >> 20 < (unsigned int )(1 << 14)) {
    if ((dev & ((1U << 20) - 1U)) < (unsigned int )(1 << 18)) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
__inline static u32 sysv_encode_dev(dev_t dev ) 
{ 

  {
  return ((dev & ((1U << 20) - 1U)) | ((dev >> 20) << 18));
}
}
__inline static unsigned int sysv_major(u32 dev ) 
{ 

  {
  return ((dev >> 18) & 16383U);
}
}
__inline static unsigned int sysv_minor(u32 dev ) 
{ 

  {
  return (dev & 262143U);
}
}
__inline static void __list_add_rcu(struct list_head *new , struct list_head *prev ,
                                    struct list_head *next ) 
{ 

  {
  {
  new->next = next;
  new->prev = prev;
  __asm__  volatile   ("": : : "memory");
  prev->next = new;
  next->prev = new;
  }
  return;
}
}
__inline static void list_add_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add_rcu(new, head, head->next);
  }
  return;
}
}
__inline static void list_add_tail_rcu(struct list_head *new , struct list_head *head ) 
{ 

  {
  {
  __list_add_rcu(new, head->prev, head);
  }
  return;
}
}
__inline static void list_del_rcu(struct list_head *entry ) 
{ 

  {
  {
  __list_del(entry->prev, entry->next);
  entry->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_del_init_rcu(struct hlist_node *n ) 
{ int tmp ;

  {
  {
  tmp = hlist_unhashed((struct hlist_node  const  *)n);
  }
  if (! tmp) {
    {
    __hlist_del(n);
    n->pprev = (struct hlist_node **)((void *)0);
    }
  }
  return;
}
}
__inline static void list_replace_rcu(struct list_head *old , struct list_head *new ) 
{ 

  {
  {
  new->next = old->next;
  new->prev = old->prev;
  __asm__  volatile   ("": : : "memory");
  (new->prev)->next = new;
  (new->next)->prev = new;
  old->prev = (struct list_head *)((void *)2097664);
  }
  return;
}
}
__inline static void list_splice_init_rcu(struct list_head *list , struct list_head *head ,
                                          void (*sync)(void) ) 
{ struct list_head *first ;
  struct list_head *last ;
  struct list_head *at ;
  int tmp ;

  {
  {
  first = list->next;
  last = list->prev;
  at = head->next;
  tmp = list_empty((struct list_head  const  *)head);
  }
  if (tmp) {
    return;
  }
  {
  INIT_LIST_HEAD(list);
  (*sync)();
  last->next = at;
  __asm__  volatile   ("": : : "memory");
  head->next = first;
  first->prev = head;
  at->prev = last;
  }
  return;
}
}
__inline static void hlist_del_rcu(struct hlist_node *n ) 
{ 

  {
  {
  __hlist_del(n);
  n->pprev = (struct hlist_node **)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_replace_rcu(struct hlist_node *old , struct hlist_node *new ) 
{ struct hlist_node *next ;

  {
  {
  next = old->next;
  new->next = next;
  new->pprev = old->pprev;
  __asm__  volatile   ("": : : "memory");
  *(new->pprev) = new;
  }
  if (next) {
    {
    (new->next)->pprev = & new->next;
    }
  }
  {
  old->pprev = (struct hlist_node **)((void *)2097664);
  }
  return;
}
}
__inline static void hlist_add_head_rcu(struct hlist_node *n , struct hlist_head *h ) 
{ struct hlist_node *first ;

  {
  {
  first = h->first;
  n->next = first;
  n->pprev = & h->first;
  __asm__  volatile   ("": : : "memory");
  h->first = n;
  }
  if (first) {
    {
    first->pprev = & n->next;
    }
  }
  return;
}
}
__inline static void hlist_add_before_rcu(struct hlist_node *n , struct hlist_node *next ) 
{ 

  {
  {
  n->pprev = next->pprev;
  n->next = next;
  __asm__  volatile   ("": : : "memory");
  *(n->pprev) = n;
  next->pprev = & n->next;
  }
  return;
}
}
__inline static void hlist_add_after_rcu(struct hlist_node *prev , struct hlist_node *n ) 
{ 

  {
  {
  n->next = prev->next;
  n->pprev = & prev->next;
  __asm__  volatile   ("": : : "memory");
  prev->next = n;
  }
  if (n->next) {
    {
    (n->next)->pprev = & n->next;
    }
  }
  return;
}
}
extern struct dentry_stat_t dentry_stat ;
__inline static unsigned long partial_name_hash(unsigned long c , unsigned long prevhash ) 
{ 

  {
  return (((prevhash + (c << 4)) + (c >> 4)) * 11UL);
}
}
__inline static unsigned long end_name_hash(unsigned long hash ) 
{ 

  {
  return ((unsigned long )((unsigned int )hash));
}
}
__inline static unsigned int full_name_hash(unsigned char const   *name , unsigned int len ) 
{ unsigned long hash ;
  unsigned char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  hash = 0UL;
  }
  {
  while (1) {
    while_161_continue: /* CIL Label */ ;
    {
    tmp___0 = len;
    len --;
    }
    if (! tmp___0) {
      goto while_161_break;
    }
    {
    tmp = name;
    name ++;
    hash = partial_name_hash((unsigned long )*tmp, hash);
    }
  }
  while_161_break: /* CIL Label */ ;
  }
  {
  tmp___1 = end_name_hash(hash);
  }
  return ((unsigned int )tmp___1);
}
}
extern spinlock_t dcache_lock ;
extern seqlock_t rename_lock ;
__inline static void __d_drop(struct dentry *dentry ) 
{ 

  {
  if (! (dentry->d_flags & 16U)) {
    {
    dentry->d_flags |= 16U;
    hlist_del_rcu(& dentry->d_hash);
    }
  }
  return;
}
}
__inline static void d_drop(struct dentry *dentry ) 
{ 

  {
  {
  _spin_lock(& dcache_lock);
  _spin_lock(& dentry->d_lock);
  __d_drop(dentry);
  }
  {
  while (1) {
    while_162_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dentry->d_lock.raw_lock);
    }
    goto while_162_break;
  }
  while_162_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_163_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dcache_lock.raw_lock);
    }
    goto while_163_break;
  }
  while_163_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static int dname_external(struct dentry *dentry ) 
{ 

  {
  return ((unsigned long )dentry->d_name.name != (unsigned long )(dentry->d_iname));
}
}
extern void d_instantiate(struct dentry * , struct inode * ) ;
extern struct dentry *d_instantiate_unique(struct dentry * , struct inode * ) ;
extern struct dentry *d_materialise_unique(struct dentry * , struct inode * ) ;
extern void d_delete(struct dentry * ) ;
extern struct dentry *d_alloc(struct dentry * , struct qstr  const  * ) ;
extern struct dentry *d_splice_alias(struct inode * , struct dentry * ) ;
extern struct dentry *d_add_ci(struct dentry * , struct inode * , struct qstr * ) ;
extern struct dentry *d_obtain_alias(struct inode * ) ;
extern void shrink_dcache_sb(struct super_block * ) ;
extern void shrink_dcache_parent(struct dentry * ) ;
extern void shrink_dcache_for_umount(struct super_block * ) ;
extern int d_invalidate(struct dentry * ) ;
extern struct dentry *d_alloc_root(struct inode * ) ;
extern void d_genocide(struct dentry * ) ;
extern struct dentry *d_find_alias(struct inode * ) ;
extern void d_prune_aliases(struct inode * ) ;
extern int have_submounts(struct dentry * ) ;
extern void d_rehash(struct dentry * ) ;
__inline static void d_add(struct dentry *entry , struct inode *inode ) 
{ 

  {
  {
  d_instantiate(entry, inode);
  d_rehash(entry);
  }
  return;
}
}
__inline static struct dentry *d_add_unique(struct dentry *entry , struct inode *inode ) 
{ struct dentry *res ;
  struct dentry *tmp ;

  {
  {
  res = d_instantiate_unique(entry, inode);
  }
  if ((unsigned long )res != (unsigned long )((void *)0)) {
    {
    tmp = res;
    }
  } else {
    {
    tmp = entry;
    }
  }
  {
  d_rehash(tmp);
  }
  return (res);
}
}
extern void d_move(struct dentry * , struct dentry * ) ;
extern struct dentry *d_ancestor(struct dentry * , struct dentry * ) ;
extern struct dentry *d_lookup(struct dentry * , struct qstr * ) ;
extern struct dentry *__d_lookup(struct dentry * , struct qstr * ) ;
extern struct dentry *d_hash_and_lookup(struct dentry * , struct qstr * ) ;
extern int d_validate(struct dentry * , struct dentry * ) ;
extern char *dynamic_dname(struct dentry * , char * , int  , char const   *  , ...) ;
extern char *__d_path(struct path  const  *path , struct path *root , char * , int  ) ;
extern char *d_path(struct path  const  * , char * , int  ) ;
extern char *dentry_path(struct dentry * , char * , int  ) ;
__inline static struct dentry *dget(struct dentry *dentry ) 
{ long tmp ;

  {
  if (dentry) {
    {
    while (1) {
      while_164_continue: /* CIL Label */ ;
      {
      tmp = __builtin_expect((long )(! (! (! dentry->d_count.counter))), 0L);
      }
      if (tmp) {
        {
        while (1) {
          while_165_continue: /* CIL Label */ ;
          {
          __asm__  volatile   ("1:\tud2\n"
                               ".pushsection __bug_table,\"a\"\n"
                               "2:\t.long 1b, %c0\n"
                               "\t.word %c1, 0\n"
                               "\t.org 2b+%c2\n"
                               ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/dcache.h"),
                               "i" (334), "i" (sizeof(struct bug_entry )));
          }
          {
          while (1) {
            while_166_continue: /* CIL Label */ ;
          }
          while_166_break: /* CIL Label */ ;
          }
          goto while_165_break;
        }
        while_165_break: /* CIL Label */ ;
        }
      }
      goto while_164_break;
    }
    while_164_break: /* CIL Label */ ;
    }
    {
    atomic_inc(& dentry->d_count);
    }
  }
  return (dentry);
}
}
extern struct dentry *dget_locked(struct dentry * ) ;
__inline static int d_unhashed(struct dentry *dentry ) 
{ 

  {
  return ((int )(dentry->d_flags & 16U));
}
}
__inline static struct dentry *dget_parent(struct dentry *dentry ) 
{ struct dentry *ret ;

  {
  {
  _spin_lock(& dentry->d_lock);
  ret = dget(dentry->d_parent);
  }
  {
  while (1) {
    while_167_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dentry->d_lock.raw_lock);
    }
    goto while_167_break;
  }
  while_167_break: /* CIL Label */ ;
  }
  return (ret);
}
}
extern void dput(struct dentry * ) ;
__inline static int d_mountpoint(struct dentry *dentry ) 
{ 

  {
  return (dentry->d_mounted);
}
}
extern struct vfsmount *lookup_mnt(struct vfsmount * , struct dentry * ) ;
extern struct dentry *lookup_create(struct nameidata *nd , int is_dir ) ;
extern int sysctl_vfs_cache_pressure ;
extern void path_get(struct path * ) ;
extern void path_put(struct path * ) ;
__inline static void *radix_tree_ptr_to_indirect(void *ptr ) 
{ 

  {
  return ((void *)((unsigned long )ptr | 1UL));
}
}
__inline static void *radix_tree_indirect_to_ptr(void *ptr ) 
{ 

  {
  return ((void *)((unsigned long )ptr & 0xfffffffeUL));
}
}
__inline static int radix_tree_is_indirect_ptr(void *ptr ) 
{ 

  {
  return ((int )((unsigned long )ptr & 1UL));
}
}
__inline static void *radix_tree_deref_slot(void **pslot ) 
{ void *ret ;
  void *_________p1 ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  _________p1 = (void *)*((void * volatile  *)pslot);
  }
  {
  while (1) {
    while_168_continue: /* CIL Label */ ;
    goto while_168_break;
  }
  while_168_break: /* CIL Label */ ;
  }
  {
  ret = _________p1;
  tmp = radix_tree_is_indirect_ptr(ret);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    {
    ret = (void *)0xffffffffUL;
    }
  }
  return (ret);
}
}
__inline static void radix_tree_replace_slot(void **pslot , void *item ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  while (1) {
    while_169_continue: /* CIL Label */ ;
    {
    tmp = radix_tree_is_indirect_ptr(item);
    }
    if (tmp) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
    {
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
    if (tmp___1) {
      {
      while (1) {
        while_170_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/radix-tree.h"),
                             "i" (154), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_171_continue: /* CIL Label */ ;
        }
        while_171_break: /* CIL Label */ ;
        }
        goto while_170_break;
      }
      while_170_break: /* CIL Label */ ;
      }
    }
    goto while_169_break;
  }
  while_169_break: /* CIL Label */ ;
  }
  {
  __asm__  volatile   ("": : : "memory");
  *pslot = item;
  }
  return;
}
}
extern int radix_tree_insert(struct radix_tree_root * , unsigned long  , void * ) ;
extern void *radix_tree_lookup(struct radix_tree_root * , unsigned long  ) ;
extern void **radix_tree_lookup_slot(struct radix_tree_root * , unsigned long  ) ;
extern void *radix_tree_delete(struct radix_tree_root * , unsigned long  ) ;
extern unsigned int radix_tree_gang_lookup(struct radix_tree_root *root , void **results ,
                                           unsigned long first_index , unsigned int max_items ) ;
extern unsigned int radix_tree_gang_lookup_slot(struct radix_tree_root *root , void ***results ,
                                                unsigned long first_index , unsigned int max_items ) ;
extern unsigned long radix_tree_next_hole(struct radix_tree_root *root , unsigned long index ,
                                          unsigned long max_scan ) ;
extern int radix_tree_preload(gfp_t gfp_mask ) ;
extern void radix_tree_init(void) ;
extern void *radix_tree_tag_set(struct radix_tree_root *root , unsigned long index ,
                                unsigned int tag ) ;
extern void *radix_tree_tag_clear(struct radix_tree_root *root , unsigned long index ,
                                  unsigned int tag ) ;
extern int radix_tree_tag_get(struct radix_tree_root *root , unsigned long index ,
                              unsigned int tag ) ;
extern unsigned int radix_tree_gang_lookup_tag(struct radix_tree_root *root , void **results ,
                                               unsigned long first_index , unsigned int max_items ,
                                               unsigned int tag ) ;
extern unsigned int radix_tree_gang_lookup_tag_slot(struct radix_tree_root *root ,
                                                    void ***results , unsigned long first_index ,
                                                    unsigned int max_items , unsigned int tag ) ;
extern int radix_tree_tagged(struct radix_tree_root *root , unsigned int tag ) ;
__inline static void radix_tree_preload_end(void) 
{ 

  {
  {
  while (1) {
    while_172_continue: /* CIL Label */ ;
    goto while_172_break;
  }
  while_172_break: /* CIL Label */ ;
  }
  return;
}
}
extern struct pid init_struct_pid ;
__inline static struct pid *get_pid(struct pid *pid ) 
{ 

  {
  if (pid) {
    {
    atomic_inc(& pid->count);
    }
  }
  return (pid);
}
}
extern void put_pid(struct pid *pid ) ;
extern struct task_struct *pid_task(struct pid *pid , enum pid_type  ) ;
extern struct task_struct *get_pid_task(struct pid *pid , enum pid_type  ) ;
extern struct pid *get_task_pid(struct task_struct *task , enum pid_type type ) ;
extern void attach_pid(struct task_struct *task , enum pid_type type , struct pid *pid ) ;
extern void detach_pid(struct task_struct *task , enum pid_type  ) ;
extern void change_pid(struct task_struct *task , enum pid_type  , struct pid *pid ) ;
extern void transfer_pid(struct task_struct *old , struct task_struct *new , enum pid_type  ) ;
extern struct pid_namespace init_pid_ns ;
extern struct pid *find_pid_ns(int nr , struct pid_namespace *ns ) ;
extern struct pid *find_vpid(int nr ) ;
extern struct pid *find_get_pid(int nr ) ;
extern struct pid *find_ge_pid(int nr , struct pid_namespace * ) ;
extern int next_pidmap(struct pid_namespace *pid_ns , int last ) ;
extern struct pid *alloc_pid(struct pid_namespace *ns ) ;
extern void free_pid(struct pid *pid ) ;
__inline static struct pid_namespace *ns_of_pid(struct pid *pid ) 
{ struct pid_namespace *ns ;

  {
  {
  ns = (struct pid_namespace *)((void *)0);
  }
  if (pid) {
    {
    ns = pid->numbers[pid->level].ns;
    }
  }
  return (ns);
}
}
__inline static pid_t pid_nr(struct pid *pid ) 
{ pid_t nr ;

  {
  {
  nr = 0;
  }
  if (pid) {
    {
    nr = pid->numbers[0].nr;
    }
  }
  return (nr);
}
}
extern pid_t pid_nr_ns(struct pid *pid , struct pid_namespace *ns ) ;
extern pid_t pid_vnr(struct pid *pid ) ;
extern int file_caps_enabled ;
__inline static kernel_cap_t cap_combine(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_173_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_174_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_174_break;
      }
      {
      dest.cap[__capi] = a.cap[__capi] | b.cap[__capi];
      __capi ++;
      }
    }
    while_174_break: /* CIL Label */ ;
    }
    goto while_173_break;
  }
  while_173_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static kernel_cap_t cap_intersect(kernel_cap_t a , kernel_cap_t b ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_175_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_176_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_176_break;
      }
      {
      dest.cap[__capi] = a.cap[__capi] & b.cap[__capi];
      __capi ++;
      }
    }
    while_176_break: /* CIL Label */ ;
    }
    goto while_175_break;
  }
  while_175_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static kernel_cap_t cap_drop(kernel_cap_t a , kernel_cap_t drop ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_177_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_178_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_178_break;
      }
      {
      dest.cap[__capi] = a.cap[__capi] & ~ drop.cap[__capi];
      __capi ++;
      }
    }
    while_178_break: /* CIL Label */ ;
    }
    goto while_177_break;
  }
  while_177_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static kernel_cap_t cap_invert(kernel_cap_t c ) 
{ kernel_cap_t dest ;
  unsigned int __capi ;

  {
  {
  while (1) {
    while_179_continue: /* CIL Label */ ;
    {
    __capi = 0U;
    }
    {
    while (1) {
      while_180_continue: /* CIL Label */ ;
      if (! (__capi < 2U)) {
        goto while_180_break;
      }
      {
      dest.cap[__capi] = ~ c.cap[__capi];
      __capi ++;
      }
    }
    while_180_break: /* CIL Label */ ;
    }
    goto while_179_break;
  }
  while_179_break: /* CIL Label */ ;
  }
  return (dest);
}
}
__inline static int cap_isclear(kernel_cap_t a ) 
{ unsigned int __capi ;

  {
  {
  __capi = 0U;
  }
  {
  while (1) {
    while_181_continue: /* CIL Label */ ;
    if (! (__capi < 2U)) {
      goto while_181_break;
    }
    if (a.cap[__capi] != 0U) {
      return (0);
    }
    {
    __capi ++;
    }
  }
  while_181_break: /* CIL Label */ ;
  }
  return (1);
}
}
__inline static int cap_issubset(kernel_cap_t a , kernel_cap_t set ) 
{ kernel_cap_t dest ;
  int tmp ;

  {
  {
  dest = cap_drop(a, set);
  tmp = cap_isclear(dest);
  }
  return (tmp);
}
}
__inline static int cap_is_fs_cap(int cap ) 
{ kernel_cap_t __cap_fs_set ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
  __cap_fs_set.cap[1] = (__u32 )1;
  }
  return (! (! ((unsigned int )(1 << (cap & 31)) & __cap_fs_set.cap[cap >> 5])));
}
}
__inline static kernel_cap_t cap_drop_fs_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
  __cap_fs_set.cap[1] = (__u32 )1;
  tmp = cap_drop(a, __cap_fs_set);
  }
  return (tmp);
}
}
__inline static kernel_cap_t cap_raise_fs_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 9));
  __cap_fs_set.cap[1] = (__u32 )1;
  tmp = cap_intersect(permitted, __cap_fs_set);
  tmp___0 = cap_combine(a, tmp);
  }
  return (tmp___0);
}
}
__inline static kernel_cap_t cap_drop_nfsd_set(kernel_cap_t a ) 
{ kernel_cap_t __cap_fs_set ;
  kernel_cap_t tmp ;

  {
  {
  __cap_fs_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
  __cap_fs_set.cap[1] = (__u32 )1;
  tmp = cap_drop(a, __cap_fs_set);
  }
  return (tmp);
}
}
__inline static kernel_cap_t cap_raise_nfsd_set(kernel_cap_t a , kernel_cap_t permitted ) 
{ kernel_cap_t __cap_nfsd_set ;
  kernel_cap_t tmp ;
  kernel_cap_t tmp___0 ;

  {
  {
  __cap_nfsd_set.cap[0] = (__u32 )((((((1 | (1 << 27)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 24));
  __cap_nfsd_set.cap[1] = (__u32 )1;
  tmp = cap_intersect(permitted, __cap_nfsd_set);
  tmp___0 = cap_combine(a, tmp);
  }
  return (tmp___0);
}
}
extern kernel_cap_t const   __cap_empty_set ;
extern kernel_cap_t const   __cap_full_set ;
extern kernel_cap_t const   __cap_init_eff_set ;
extern int capable(int cap ) ;
extern int get_vfs_caps_from_disk(struct dentry  const  *dentry , struct cpu_vfs_cap_data *cpu_caps ) ;
extern void inode_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void inode_init_early(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern void files_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern struct files_stat_struct files_stat ;
extern int get_max_files(void) ;
extern int sysctl_nr_open ;
extern struct inodes_stat_t inodes_stat ;
extern int leases_enable ;
extern int lease_break_time ;
extern int dir_notify_enable ;
extern int qtree_write_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_read_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_delete_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_release_dquot(struct qtree_mem_dqinfo *info , struct dquot *dquot ) ;
extern int qtree_entry_unused(struct qtree_mem_dqinfo *info , char *disk ) ;
__inline static int qtree_depth(struct qtree_mem_dqinfo *info ) 
{ unsigned int epb ;
  unsigned long long entries ;
  int i ;

  {
  {
  epb = info->dqi_usable_bs >> 2;
  entries = (unsigned long long )epb;
  i = 1;
  }
  {
  while (1) {
    while_182_continue: /* CIL Label */ ;
    if (! (entries < 1ULL << 32)) {
      goto while_182_break;
    }
    {
    entries *= (unsigned long long )epb;
    i ++;
    }
  }
  while_182_break: /* CIL Label */ ;
  }
  return (i);
}
}
extern spinlock_t dq_data_lock ;
extern void mark_info_dirty(struct super_block *sb , int type ) ;
__inline static int info_dirty(struct mem_dqinfo *info ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = constant_test_bit(16U, (unsigned long const volatile   *)(& info->dqi_flags));
  }
  return (tmp);
}
}
extern struct dqstats dqstats ;
__inline static unsigned int dquot_state_flag(unsigned int flags , int type ) 
{ 

  {
  if (type == 0) {
    return (flags);
  }
  return (flags << 3);
}
}
__inline static unsigned int dquot_generic_flag(unsigned int flags , int type ) 
{ 

  {
  if (type == 0) {
    return (flags);
  }
  return (flags >> 3);
}
}
extern int register_quota_format(struct quota_format_type *fmt ) ;
extern void unregister_quota_format(struct quota_format_type *fmt ) ;
extern size_t iov_iter_copy_from_user_atomic(struct page *page , struct iov_iter *i ,
                                             unsigned long offset , size_t bytes ) ;
extern size_t iov_iter_copy_from_user(struct page *page , struct iov_iter *i , unsigned long offset ,
                                      size_t bytes ) ;
extern void iov_iter_advance(struct iov_iter *i , size_t bytes ) ;
extern int iov_iter_fault_in_readable(struct iov_iter *i , size_t bytes ) ;
extern size_t iov_iter_single_seg_count(struct iov_iter *i ) ;
__inline static void iov_iter_init(struct iov_iter *i , struct iovec  const  *iov ,
                                   unsigned long nr_segs , size_t count , size_t written ) 
{ 

  {
  {
  i->iov = iov;
  i->nr_segs = nr_segs;
  i->iov_offset = 0U;
  i->count = count + written;
  iov_iter_advance(i, written);
  }
  return;
}
}
__inline static size_t iov_iter_count(struct iov_iter *i ) 
{ 

  {
  return (i->count);
}
}
extern int pagecache_write_begin(struct file * , struct address_space *mapping , loff_t pos ,
                                 unsigned int len , unsigned int flags , struct page **pagep ,
                                 void **fsdata ) ;
extern int pagecache_write_end(struct file * , struct address_space *mapping , loff_t pos ,
                               unsigned int len , unsigned int copied , struct page *page ,
                               void *fsdata ) ;
extern int mapping_tagged(struct address_space *mapping , int tag ) ;
__inline static int mapping_mapped(struct address_space *mapping ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = prio_tree_empty((struct prio_tree_root  const  *)(& mapping->i_mmap));
  }
  if (tmp) {
    {
    tmp___0 = list_empty((struct list_head  const  *)(& mapping->i_mmap_nonlinear));
    }
    if (tmp___0) {
      {
      tmp___1 = 0;
      }
    } else {
      {
      tmp___1 = 1;
      }
    }
  } else {
    {
    tmp___1 = 1;
    }
  }
  return (tmp___1);
}
}
__inline static int mapping_writably_mapped(struct address_space *mapping ) 
{ 

  {
  return (mapping->i_mmap_writable != 0U);
}
}
__inline static loff_t i_size_read(struct inode  const  *inode ) 
{ loff_t i_size ;
  unsigned int seq ;
  int tmp ;

  {
  {
  while (1) {
    while_183_continue: /* CIL Label */ ;
    {
    seq = read_seqcount_begin(& inode->i_size_seqcount);
    i_size = (long long )inode->i_size;
    tmp = read_seqcount_retry(& inode->i_size_seqcount, seq);
    }
    if (! tmp) {
      goto while_183_break;
    }
  }
  while_183_break: /* CIL Label */ ;
  }
  return (i_size);
}
}
__inline static void i_size_write(struct inode *inode , loff_t i_size ) 
{ 

  {
  {
  write_seqcount_begin(& inode->i_size_seqcount);
  inode->i_size = i_size;
  write_seqcount_end(& inode->i_size_seqcount);
  }
  return;
}
}
__inline static unsigned int iminor(struct inode  const  *inode ) 
{ 

  {
  return ((unsigned int )(inode->i_rdev & (unsigned int const   )((1U << 20) - 1U)));
}
}
__inline static unsigned int imajor(struct inode  const  *inode ) 
{ 

  {
  return ((unsigned int )(inode->i_rdev >> 20));
}
}
extern struct block_device *I_BDEV(struct inode *inode ) ;
__inline static int ra_has_index(struct file_ra_state *ra , unsigned long index___0 ) 
{ int tmp ;

  {
  if (index___0 >= ra->start) {
    if (index___0 < ra->start + (unsigned long )ra->size) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern spinlock_t files_lock ;
__inline static void file_take_write(struct file *filp ) 
{ 

  {
  return;
}
}
__inline static int file_check_writeable(struct file *filp ) 
{ 

  {
  return (0);
}
}
extern void locks_start_grace(struct lock_manager * ) ;
extern void locks_end_grace(struct lock_manager * ) ;
extern int locks_in_grace(void) ;
__inline static int nfs_compare_fh(struct nfs_fh  const  *a , struct nfs_fh  const  *b ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((int const   )a->size != (int const   )b->size) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp = __builtin_memcmp((void const   *)(a->data), (void const   *)(b->data), (unsigned int )a->size);
    }
    if (tmp != 0) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  }
  return (tmp___0);
}
}
__inline static void nfs_copy_fh(struct nfs_fh *target , struct nfs_fh  const  *source ) 
{ 

  {
  {
  target->size = (unsigned short )source->size;
  __memcpy((void *)(target->data), (void const   *)(source->data), (unsigned int )source->size);
  }
  return;
}
}
extern void send_sigio(struct fown_struct *fown , int fd , int band ) ;
extern int do_sync_mapping_range(struct address_space *mapping , loff_t offset , loff_t endbyte ,
                                 unsigned int flags ) ;
extern int fcntl_getlk(struct file * , struct flock * ) ;
extern int fcntl_setlk(unsigned int  , struct file * , unsigned int  , struct flock * ) ;
extern int fcntl_getlk64(struct file * , struct flock64 * ) ;
extern int fcntl_setlk64(unsigned int  , struct file * , unsigned int  , struct flock64 * ) ;
extern int fcntl_setlease(unsigned int fd , struct file *filp , long arg ) ;
extern int fcntl_getlease(struct file *filp ) ;
extern void locks_init_lock(struct file_lock * ) ;
extern void locks_copy_lock(struct file_lock * , struct file_lock * ) ;
extern void __locks_copy_lock(struct file_lock * , struct file_lock  const  * ) ;
extern void locks_remove_posix(struct file * , fl_owner_t  ) ;
extern void locks_remove_flock(struct file * ) ;
extern void posix_test_lock(struct file * , struct file_lock * ) ;
extern int posix_lock_file(struct file * , struct file_lock * , struct file_lock * ) ;
extern int posix_lock_file_wait(struct file * , struct file_lock * ) ;
extern int posix_unblock_lock(struct file * , struct file_lock * ) ;
extern int vfs_test_lock(struct file * , struct file_lock * ) ;
extern int vfs_lock_file(struct file * , unsigned int  , struct file_lock * , struct file_lock * ) ;
extern int vfs_cancel_lock(struct file *filp , struct file_lock *fl ) ;
extern int flock_lock_file_wait(struct file *filp , struct file_lock *fl ) ;
extern int __break_lease(struct inode *inode , unsigned int flags ) ;
extern void lease_get_mtime(struct inode * , struct timespec *time ) ;
extern int generic_setlease(struct file * , long  , struct file_lock ** ) ;
extern int vfs_setlease(struct file * , long  , struct file_lock ** ) ;
extern int lease_modify(struct file_lock ** , int  ) ;
extern int lock_may_read(struct inode * , loff_t start , unsigned long count ) ;
extern int lock_may_write(struct inode * , loff_t start , unsigned long count ) ;
extern int fasync_helper(int  , struct file * , int  , struct fasync_struct ** ) ;
extern void kill_fasync(struct fasync_struct ** , int  , int  ) ;
extern void __kill_fasync(struct fasync_struct * , int  , int  ) ;
extern int __f_setown(struct file *filp , struct pid * , enum pid_type  , int force ) ;
extern int f_setown(struct file *filp , unsigned long arg , int force ) ;
extern void f_delown(struct file *filp ) ;
extern pid_t f_getown(struct file *filp ) ;
extern int send_sigurg(struct fown_struct *fown ) ;
extern struct list_head super_blocks ;
extern spinlock_t sb_lock ;
extern struct timespec current_fs_time(struct super_block *sb ) ;
extern void lock_super(struct super_block * ) ;
extern void unlock_super(struct super_block * ) ;
extern int vfs_create(struct inode * , struct dentry * , int  , struct nameidata * ) ;
extern int vfs_mkdir(struct inode * , struct dentry * , int  ) ;
extern int vfs_mknod(struct inode * , struct dentry * , int  , dev_t  ) ;
extern int vfs_symlink(struct inode * , struct dentry * , char const   * ) ;
extern int vfs_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int vfs_rmdir(struct inode * , struct dentry * ) ;
extern int vfs_unlink(struct inode * , struct dentry * ) ;
extern int vfs_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern void dentry_unhash(struct dentry *dentry ) ;
extern int file_permission(struct file * , int  ) ;
extern int fiemap_fill_next_extent(struct fiemap_extent_info *info , u64 logical ,
                                   u64 phys , u64 len , u32 flags ) ;
extern int fiemap_check_flags(struct fiemap_extent_info *fieinfo , u32 fs_flags ) ;
extern int generic_osync_inode(struct inode * , struct address_space * , int  ) ;
extern ssize_t rw_copy_check_uvector(int type , struct iovec  const  *uvector , unsigned long nr_segs ,
                                     unsigned long fast_segs , struct iovec *fast_pointer ,
                                     struct iovec **ret_pointer ) ;
extern ssize_t vfs_read(struct file * , char * , size_t  , loff_t * ) ;
extern ssize_t vfs_write(struct file * , char const   * , size_t  , loff_t * ) ;
extern ssize_t vfs_readv(struct file * , struct iovec  const  * , unsigned long  ,
                         loff_t * ) ;
extern ssize_t vfs_writev(struct file * , struct iovec  const  * , unsigned long  ,
                          loff_t * ) ;
extern void __mark_inode_dirty(struct inode * , int  ) ;
__inline static void mark_inode_dirty(struct inode *inode ) 
{ 

  {
  {
  __mark_inode_dirty(inode, 7);
  }
  return;
}
}
__inline static void mark_inode_dirty_sync(struct inode *inode ) 
{ 

  {
  {
  __mark_inode_dirty(inode, 1);
  }
  return;
}
}
__inline static void inc_nlink(struct inode *inode ) 
{ 

  {
  {
  (inode->i_nlink) ++;
  }
  return;
}
}
__inline static void inode_inc_link_count(struct inode *inode ) 
{ 

  {
  {
  inc_nlink(inode);
  mark_inode_dirty(inode);
  }
  return;
}
}
__inline static void drop_nlink(struct inode *inode ) 
{ 

  {
  {
  (inode->i_nlink) --;
  }
  return;
}
}
__inline static void clear_nlink(struct inode *inode ) 
{ 

  {
  {
  inode->i_nlink = 0U;
  }
  return;
}
}
__inline static void inode_dec_link_count(struct inode *inode ) 
{ 

  {
  {
  drop_nlink(inode);
  mark_inode_dirty(inode);
  }
  return;
}
}
__inline static void inode_inc_iversion(struct inode *inode ) 
{ 

  {
  {
  _spin_lock(& inode->i_lock);
  (inode->i_version) ++;
  }
  {
  while (1) {
    while_184_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& inode->i_lock.raw_lock);
    }
    goto while_184_break;
  }
  while_184_break: /* CIL Label */ ;
  }
  return;
}
}
extern void touch_atime(struct vfsmount *mnt , struct dentry *dentry ) ;
__inline static void file_accessed(struct file *file ) 
{ 

  {
  if (! (file->f_flags & 262144U)) {
    {
    touch_atime(file->f_path.mnt, file->f_path.dentry);
    }
  }
  return;
}
}
extern int sync_inode(struct inode *inode , struct writeback_control *wbc ) ;
extern int get_sb_ns(struct file_system_type *fs_type , int flags , void *data , int (*fill_super)(struct super_block * ,
                                                                                                   void * ,
                                                                                                   int  ) ,
                     struct vfsmount *mnt ) ;
extern int get_sb_bdev(struct file_system_type *fs_type , int flags , char const   *dev_name ,
                       void *data , int (*fill_super)(struct super_block * , void * ,
                                                      int  ) , struct vfsmount *mnt ) ;
extern int get_sb_single(struct file_system_type *fs_type , int flags , void *data ,
                         int (*fill_super)(struct super_block * , void * , int  ) ,
                         struct vfsmount *mnt ) ;
extern int get_sb_nodev(struct file_system_type *fs_type , int flags , void *data ,
                        int (*fill_super)(struct super_block * , void * , int  ) ,
                        struct vfsmount *mnt ) ;
extern void generic_shutdown_super(struct super_block *sb ) ;
extern void kill_block_super(struct super_block *sb ) ;
extern void kill_anon_super(struct super_block *sb ) ;
extern void kill_litter_super(struct super_block *sb ) ;
extern void deactivate_super(struct super_block *sb ) ;
extern void deactivate_locked_super(struct super_block *sb ) ;
extern int set_anon_super(struct super_block *s , void *data ) ;
extern struct super_block *sget(struct file_system_type *type , int (*test)(struct super_block * ,
                                                                            void * ) ,
                                int (*set)(struct super_block * , void * ) , void *data ) ;
extern int get_sb_pseudo(struct file_system_type * , char * , struct super_operations  const  *ops ,
                         unsigned long  , struct vfsmount *mnt ) ;
extern void simple_set_mnt(struct vfsmount *mnt , struct super_block *sb ) ;
extern int __put_super_and_need_restart(struct super_block *sb ) ;
extern int register_filesystem(struct file_system_type * ) ;
extern int unregister_filesystem(struct file_system_type * ) ;
extern struct vfsmount *kern_mount_data(struct file_system_type * , void *data ) ;
extern int may_umount_tree(struct vfsmount * ) ;
extern int may_umount(struct vfsmount * ) ;
extern long do_mount(char * , char * , char * , unsigned long  , void * ) ;
extern struct vfsmount *collect_mounts(struct vfsmount * , struct dentry * ) ;
extern void drop_collected_mounts(struct vfsmount * ) ;
extern int vfs_statfs(struct dentry * , struct kstatfs * ) ;
extern int current_umask(void) ;
extern struct kobject *fs_kobj ;
extern int rw_verify_area(int  , struct file * , loff_t * , size_t  ) ;
extern int locks_mandatory_locked(struct inode * ) ;
extern int locks_mandatory_area(int  , struct inode * , struct file * , loff_t  ,
                                size_t  ) ;
__inline static int __mandatory_lock(struct inode *ino ) 
{ 

  {
  return (((int )ino->i_mode & 1032) == 1024);
}
}
__inline static int mandatory_lock(struct inode *ino ) 
{ int tmp ;
  int tmp___0 ;

  {
  if ((ino->i_sb)->s_flags & 64UL) {
    {
    tmp = __mandatory_lock(ino);
    }
    if (tmp) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
__inline static int locks_verify_locked(struct inode *inode ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp___0 = mandatory_lock(inode);
  }
  if (tmp___0) {
    {
    tmp = locks_mandatory_locked(inode);
    }
    return (tmp);
  }
  return (0);
}
}
__inline static int locks_verify_truncate(struct inode *inode , struct file *filp ,
                                          loff_t size ) 
{ loff_t tmp ;
  loff_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (inode->i_flock) {
    {
    tmp___2 = mandatory_lock(inode);
    }
    if (tmp___2) {
      if (size < inode->i_size) {
        {
        tmp = inode->i_size - size;
        }
      } else {
        {
        tmp = size - inode->i_size;
        }
      }
      if (size < inode->i_size) {
        {
        tmp___0 = size;
        }
      } else {
        {
        tmp___0 = inode->i_size;
        }
      }
      {
      tmp___1 = locks_mandatory_area(2, inode, filp, tmp___0, (unsigned int )tmp);
      }
      return (tmp___1);
    }
  }
  return (0);
}
}
__inline static int break_lease(struct inode *inode , unsigned int mode ) 
{ int tmp ;

  {
  if (inode->i_flock) {
    {
    tmp = __break_lease(inode, mode);
    }
    return (tmp);
  }
  return (0);
}
}
extern int do_truncate(struct dentry * , loff_t start , unsigned int time_attrs ,
                       struct file *filp ) ;
extern long do_sys_open(int dfd , char const   *filename , int flags , int mode ) ;
extern struct file *filp_open(char const   * , int  , int  ) ;
extern struct file *dentry_open(struct dentry * , struct vfsmount * , int  , struct cred  const  * ) ;
extern int filp_close(struct file * , fl_owner_t id ) ;
extern char *getname(char const   * ) ;
extern void vfs_caches_init_early(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern void vfs_caches_init(unsigned long  )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern struct kmem_cache *names_cachep ;
extern void putname(char const   *name ) ;
extern int register_blkdev(unsigned int  , char const   * ) ;
extern void unregister_blkdev(unsigned int  , char const   * ) ;
extern struct block_device *bdget(dev_t  ) ;
extern void bd_set_size(struct block_device * , loff_t size ) ;
extern void bd_forget(struct inode *inode ) ;
extern void bdput(struct block_device * ) ;
extern struct block_device *open_by_devnum(dev_t  , fmode_t  ) ;
extern void invalidate_bdev(struct block_device * ) ;
extern int sync_blockdev(struct block_device *bdev ) ;
extern struct super_block *freeze_bdev(struct block_device * ) ;
extern void emergency_thaw_all(void) ;
extern int thaw_bdev(struct block_device *bdev , struct super_block *sb ) ;
extern int fsync_bdev(struct block_device * ) ;
extern int fsync_super(struct super_block * ) ;
extern int fsync_no_super(struct block_device * ) ;
extern struct file_operations  const  def_blk_fops ;
extern struct file_operations  const  def_chr_fops ;
extern struct file_operations  const  bad_sock_fops ;
extern struct file_operations  const  def_fifo_fops ;
extern int ioctl_by_bdev(struct block_device * , unsigned int  , unsigned long  ) ;
extern int blkdev_ioctl(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
extern long compat_blkdev_ioctl(struct file * , unsigned int  , unsigned long  ) ;
extern int blkdev_get(struct block_device * , fmode_t  ) ;
extern int blkdev_put(struct block_device * , fmode_t  ) ;
extern int bd_claim(struct block_device * , void * ) ;
extern void bd_release(struct block_device * ) ;
extern int bd_claim_by_disk(struct block_device * , void * , struct gendisk * ) ;
extern void bd_release_from_disk(struct block_device * , struct gendisk * ) ;
extern int alloc_chrdev_region(dev_t * , unsigned int  , unsigned int  , char const   * ) ;
extern int register_chrdev_region(dev_t  , unsigned int  , char const   * ) ;
extern int register_chrdev(unsigned int  , char const   * , struct file_operations  const  * ) ;
extern void unregister_chrdev(unsigned int  , char const   * ) ;
extern void unregister_chrdev_region(dev_t  , unsigned int  ) ;
extern void chrdev_show(struct seq_file * , off_t  ) ;
extern char const   *__bdevname(dev_t  , char *buffer ) ;
extern char const   *bdevname(struct block_device *bdev , char *buffer ) ;
extern struct block_device *lookup_bdev(char const   * ) ;
extern struct block_device *open_bdev_exclusive(char const   * , fmode_t  , void * ) ;
extern void close_bdev_exclusive(struct block_device * , fmode_t  ) ;
extern void blkdev_show(struct seq_file * , off_t  ) ;
extern void init_special_inode(struct inode * , umode_t  , dev_t  ) ;
extern void make_bad_inode(struct inode * ) ;
extern int is_bad_inode(struct inode * ) ;
extern struct file_operations  const  read_pipefifo_fops ;
extern struct file_operations  const  write_pipefifo_fops ;
extern struct file_operations  const  rdwr_pipefifo_fops ;
extern int fs_may_remount_ro(struct super_block * ) ;
extern void check_disk_size_change(struct gendisk *disk , struct block_device *bdev ) ;
extern int revalidate_disk(struct gendisk * ) ;
extern int check_disk_change(struct block_device * ) ;
extern int __invalidate_device(struct block_device * ) ;
extern int invalidate_partition(struct gendisk * , int  ) ;
extern int invalidate_inodes(struct super_block * ) ;
extern unsigned long __invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                                unsigned long end , bool be_atomic ) ;
extern unsigned long invalidate_mapping_pages(struct address_space *mapping , unsigned long start ,
                                              unsigned long end ) ;
__inline static unsigned long invalidate_inode_pages(struct address_space *mapping ) 
{ unsigned long tmp ;

  {
  {
  tmp = invalidate_mapping_pages(mapping, 0UL, ~ 0UL);
  }
  return (tmp);
}
}
__inline static void invalidate_remote_inode(struct inode *inode ) 
{ 

  {
  if (((int )inode->i_mode & 61440) == 32768) {
    {
    invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
    }
  } else {
    if (((int )inode->i_mode & 61440) == 16384) {
      {
      invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
      }
    } else {
      if (((int )inode->i_mode & 61440) == 40960) {
        {
        invalidate_mapping_pages(inode->i_mapping, 0UL, 0xffffffffUL);
        }
      }
    }
  }
  return;
}
}
extern int invalidate_inode_pages2(struct address_space *mapping ) ;
extern int invalidate_inode_pages2_range(struct address_space *mapping , unsigned long start ,
                                         unsigned long end ) ;
extern void generic_sync_sb_inodes(struct super_block *sb , struct writeback_control *wbc ) ;
extern int write_inode_now(struct inode * , int  ) ;
extern int filemap_fdatawrite(struct address_space * ) ;
extern int filemap_flush(struct address_space * ) ;
extern int filemap_fdatawait(struct address_space * ) ;
extern int filemap_write_and_wait(struct address_space *mapping ) ;
extern int filemap_write_and_wait_range(struct address_space *mapping , loff_t lstart ,
                                        loff_t lend ) ;
extern int wait_on_page_writeback_range(struct address_space *mapping , unsigned long start ,
                                        unsigned long end ) ;
extern int __filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                      loff_t end , int sync_mode ) ;
extern int filemap_fdatawrite_range(struct address_space *mapping , loff_t start ,
                                    loff_t end ) ;
extern int vfs_fsync(struct file *file , struct dentry *dentry , int datasync ) ;
extern void sync_supers(void) ;
extern void sync_filesystems(int wait ) ;
extern void __fsync_super(struct super_block *sb ) ;
extern void emergency_sync(void) ;
extern void emergency_remount(void) ;
extern int do_remount_sb(struct super_block *sb , int flags , void *data , int force ) ;
extern sector_t bmap(struct inode * , sector_t  ) ;
extern int notify_change(struct dentry * , struct iattr * ) ;
extern int inode_permission(struct inode * , int  ) ;
extern int generic_permission(struct inode * , int  , int (*check_acl)(struct inode * ,
                                                                       int  ) ) ;
__inline static bool execute_ok(struct inode *inode ) 
{ int tmp ;

  {
  if ((int )inode->i_mode & 73) {
    {
    tmp = 1;
    }
  } else {
    if (((int )inode->i_mode & 61440) == 16384) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return ((_Bool )tmp);
}
}
extern int get_write_access(struct inode * ) ;
extern int deny_write_access(struct file * ) ;
__inline static void put_write_access(struct inode *inode ) 
{ 

  {
  {
  atomic_dec(& inode->i_writecount);
  }
  return;
}
}
__inline static void allow_write_access(struct file *file ) 
{ 

  {
  if (file) {
    {
    atomic_inc(& ((file->f_path.dentry)->d_inode)->i_writecount);
    }
  }
  return;
}
}
extern int do_pipe_flags(int * , int  ) ;
extern struct file *create_read_pipe(struct file *f , int flags ) ;
extern struct file *create_write_pipe(int flags ) ;
extern void free_write_pipe(struct file * ) ;
extern struct file *do_filp_open(int dfd , char const   *pathname , int open_flag ,
                                 int mode , int acc_mode ) ;
extern int may_open(struct path * , int  , int  ) ;
extern int kernel_read(struct file * , unsigned long  , char * , unsigned long  ) ;
extern struct file *open_exec(char const   * ) ;
extern int is_subdir(struct dentry * , struct dentry * ) ;
extern ino_t find_inode_number(struct dentry * , struct qstr * ) ;
extern loff_t default_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t vfs_llseek(struct file *file , loff_t offset , int origin ) ;
extern struct inode *inode_init_always(struct super_block * , struct inode * ) ;
extern void inode_init_once(struct inode * ) ;
extern void inode_add_to_lists(struct super_block * , struct inode * ) ;
extern void iput(struct inode * ) ;
extern struct inode *igrab(struct inode * ) ;
extern ino_t iunique(struct super_block * , ino_t  ) ;
extern int inode_needs_sync(struct inode *inode ) ;
extern void generic_delete_inode(struct inode *inode ) ;
extern void generic_drop_inode(struct inode *inode ) ;
extern struct inode *ilookup5_nowait(struct super_block *sb , unsigned long hashval ,
                                     int (*test)(struct inode * , void * ) , void *data ) ;
extern struct inode *ilookup5(struct super_block *sb , unsigned long hashval , int (*test)(struct inode * ,
                                                                                           void * ) ,
                              void *data ) ;
extern struct inode *ilookup(struct super_block *sb , unsigned long ino ) ;
extern struct inode *iget5_locked(struct super_block * , unsigned long  , int (*test)(struct inode * ,
                                                                                      void * ) ,
                                  int (*set)(struct inode * , void * ) , void * ) ;
extern struct inode *iget_locked(struct super_block * , unsigned long  ) ;
extern int insert_inode_locked4(struct inode * , unsigned long  , int (*test)(struct inode * ,
                                                                              void * ) ,
                                void * ) ;
extern int insert_inode_locked(struct inode * ) ;
extern void unlock_new_inode(struct inode * ) ;
extern void __iget(struct inode *inode ) ;
extern void iget_failed(struct inode * ) ;
extern void clear_inode(struct inode * ) ;
extern void destroy_inode(struct inode * ) ;
extern struct inode *new_inode(struct super_block * ) ;
extern int should_remove_suid(struct dentry * ) ;
extern int file_remove_suid(struct file * ) ;
extern void __insert_inode_hash(struct inode * , unsigned long hashval ) ;
extern void remove_inode_hash(struct inode * ) ;
__inline static void insert_inode_hash(struct inode *inode ) 
{ 

  {
  {
  __insert_inode_hash(inode, inode->i_ino);
  }
  return;
}
}
extern struct file *get_empty_filp(void) ;
extern void file_move(struct file *f , struct list_head *list ) ;
extern void file_kill(struct file *f ) ;
extern void submit_bio(int  , struct bio * ) ;
extern int bdev_read_only(struct block_device * ) ;
extern int set_blocksize(struct block_device * , int  ) ;
extern int sb_set_blocksize(struct super_block * , int  ) ;
extern int sb_min_blocksize(struct super_block * , int  ) ;
extern int sb_has_dirty_inodes(struct super_block * ) ;
extern int generic_file_mmap(struct file * , struct vm_area_struct * ) ;
extern int generic_file_readonly_mmap(struct file * , struct vm_area_struct * ) ;
extern int file_read_actor(read_descriptor_t *desc , struct page *page , unsigned long offset ,
                           unsigned long size ) ;
extern int generic_write_checks(struct file *file , loff_t *pos , size_t *count ,
                                int isblk ) ;
extern ssize_t generic_file_aio_read(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                     loff_t  ) ;
extern ssize_t generic_file_aio_write(struct kiocb * , struct iovec  const  * , unsigned long  ,
                                      loff_t  ) ;
extern ssize_t generic_file_aio_write_nolock(struct kiocb * , struct iovec  const  * ,
                                             unsigned long  , loff_t  ) ;
extern ssize_t generic_file_direct_write(struct kiocb * , struct iovec  const  * ,
                                         unsigned long * , loff_t  , loff_t * , size_t  ,
                                         size_t  ) ;
extern ssize_t generic_file_buffered_write(struct kiocb * , struct iovec  const  * ,
                                           unsigned long  , loff_t  , loff_t * , size_t  ,
                                           ssize_t  ) ;
extern ssize_t do_sync_read(struct file *filp , char *buf , size_t len , loff_t *ppos ) ;
extern ssize_t do_sync_write(struct file *filp , char const   *buf , size_t len ,
                             loff_t *ppos ) ;
extern int generic_segment_checks(struct iovec  const  *iov , unsigned long *nr_segs ,
                                  size_t *count , int access_flags ) ;
extern ssize_t generic_file_splice_read(struct file * , loff_t * , struct pipe_inode_info * ,
                                        size_t  , unsigned int  ) ;
extern ssize_t generic_file_splice_write(struct pipe_inode_info * , struct file * ,
                                         loff_t * , size_t  , unsigned int  ) ;
extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe , struct file *out ,
                                       loff_t * , size_t len , unsigned int flags ) ;
extern long do_splice_direct(struct file *in , loff_t *ppos , struct file *out , size_t len ,
                             unsigned int flags ) ;
extern void file_ra_state_init(struct file_ra_state *ra , struct address_space *mapping ) ;
extern loff_t no_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t generic_file_llseek(struct file *file , loff_t offset , int origin ) ;
extern loff_t generic_file_llseek_unlocked(struct file *file , loff_t offset , int origin ) ;
extern int generic_file_open(struct inode *inode , struct file *filp ) ;
extern int nonseekable_open(struct inode *inode , struct file *filp ) ;
__inline static int xip_truncate_page(struct address_space *mapping , loff_t from ) 
{ 

  {
  return (0);
}
}
extern ssize_t __blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                    struct block_device *bdev , struct iovec  const  *iov ,
                                    loff_t offset , unsigned long nr_segs , get_block_t *get_block ,
                                    dio_iodone_t *end_io , int lock_type ) ;
__inline static ssize_t blockdev_direct_IO(int rw , struct kiocb *iocb , struct inode *inode ,
                                           struct block_device *bdev , struct iovec  const  *iov ,
                                           loff_t offset , unsigned long nr_segs ,
                                           get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 1);
  }
  return (tmp);
}
}
__inline static ssize_t blockdev_direct_IO_no_locking(int rw , struct kiocb *iocb ,
                                                      struct inode *inode , struct block_device *bdev ,
                                                      struct iovec  const  *iov ,
                                                      loff_t offset , unsigned long nr_segs ,
                                                      get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 2);
  }
  return (tmp);
}
}
__inline static ssize_t blockdev_direct_IO_own_locking(int rw , struct kiocb *iocb ,
                                                       struct inode *inode , struct block_device *bdev ,
                                                       struct iovec  const  *iov ,
                                                       loff_t offset , unsigned long nr_segs ,
                                                       get_block_t *get_block , dio_iodone_t *end_io ) 
{ ssize_t tmp ;

  {
  {
  tmp = __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset, nr_segs, get_block,
                             end_io, 3);
  }
  return (tmp);
}
}
extern struct file_operations  const  generic_ro_fops ;
extern int vfs_readlink(struct dentry * , char * , int  , char const   * ) ;
extern int vfs_follow_link(struct nameidata * , char const   * ) ;
extern int page_readlink(struct dentry * , char * , int  ) ;
extern void *page_follow_link_light(struct dentry * , struct nameidata * ) ;
extern void page_put_link(struct dentry * , struct nameidata * , void * ) ;
extern int __page_symlink(struct inode *inode , char const   *symname , int len ,
                          int nofs ) ;
extern int page_symlink(struct inode *inode , char const   *symname , int len ) ;
extern struct inode_operations  const  page_symlink_inode_operations ;
extern int generic_readlink(struct dentry * , char * , int  ) ;
extern void generic_fillattr(struct inode * , struct kstat * ) ;
extern int vfs_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern void inode_add_bytes(struct inode *inode , loff_t bytes ) ;
extern void inode_sub_bytes(struct inode *inode , loff_t bytes ) ;
extern loff_t inode_get_bytes(struct inode *inode ) ;
extern void inode_set_bytes(struct inode *inode , loff_t bytes ) ;
extern int vfs_readdir(struct file * , int (*)(void * , char const   * , int  , loff_t  ,
                                               u64  , unsigned int  ) , void * ) ;
extern int vfs_stat(char * , struct kstat * ) ;
extern int vfs_lstat(char * , struct kstat * ) ;
extern int vfs_fstat(unsigned int  , struct kstat * ) ;
extern int vfs_fstatat(int  , char * , struct kstat * , int  ) ;
extern int do_vfs_ioctl(struct file *filp , unsigned int fd , unsigned int cmd , unsigned long arg ) ;
extern int __generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                  u64 start , u64 len , get_block_t *get_block ) ;
extern int generic_block_fiemap(struct inode *inode , struct fiemap_extent_info *fieinfo ,
                                u64 start , u64 len , get_block_t *get_block ) ;
extern void get_filesystem(struct file_system_type *fs ) ;
extern void put_filesystem(struct file_system_type *fs ) ;
extern struct file_system_type *get_fs_type(char const   *name ) ;
extern struct super_block *get_super(struct block_device * ) ;
extern struct super_block *user_get_super(dev_t  ) ;
extern void drop_super(struct super_block *sb ) ;
extern int dcache_dir_open(struct inode * , struct file * ) ;
extern int dcache_dir_close(struct inode * , struct file * ) ;
extern loff_t dcache_dir_lseek(struct file * , loff_t  , int  ) ;
extern int dcache_readdir(struct file * , void * , int (*)(void * , char const   * ,
                                                           int  , loff_t  , u64  ,
                                                           unsigned int  ) ) ;
extern int simple_getattr(struct vfsmount * , struct dentry * , struct kstat * ) ;
extern int simple_statfs(struct dentry * , struct kstatfs * ) ;
extern int simple_link(struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_unlink(struct inode * , struct dentry * ) ;
extern int simple_rmdir(struct inode * , struct dentry * ) ;
extern int simple_rename(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
extern int simple_sync_file(struct file * , struct dentry * , int  ) ;
extern int simple_empty(struct dentry * ) ;
extern int simple_readpage(struct file *file , struct page *page ) ;
extern int simple_prepare_write(struct file *file , struct page *page , unsigned int offset ,
                                unsigned int to ) ;
extern int simple_write_begin(struct file *file , struct address_space *mapping ,
                              loff_t pos , unsigned int len , unsigned int flags ,
                              struct page **pagep , void **fsdata ) ;
extern int simple_write_end(struct file *file , struct address_space *mapping , loff_t pos ,
                            unsigned int len , unsigned int copied , struct page *page ,
                            void *fsdata ) ;
extern struct dentry *simple_lookup(struct inode * , struct dentry * , struct nameidata * ) ;
extern ssize_t generic_read_dir(struct file * , char * , size_t  , loff_t * ) ;
extern struct file_operations  const  simple_dir_operations ;
extern struct inode_operations  const  simple_dir_inode_operations ;
extern struct dentry *d_alloc_name(struct dentry * , char const   * ) ;
extern int simple_fill_super(struct super_block * , int  , struct tree_descr * ) ;
extern int simple_pin_fs(struct file_system_type * , struct vfsmount **mount , int *count ) ;
extern void simple_release_fs(struct vfsmount **mount , int *count ) ;
extern ssize_t simple_read_from_buffer(void *to , size_t count , loff_t *ppos , void const   *from ,
                                       size_t available ) ;
extern int inode_change_ok(struct inode * , struct iattr * ) ;
extern int inode_setattr(struct inode * , struct iattr * ) ;
extern void file_update_time(struct file *file ) ;
extern int generic_show_options(struct seq_file *m , struct vfsmount *mnt ) ;
extern void save_mount_options(struct super_block *sb , char *options ) ;
extern void replace_mount_options(struct super_block *sb , char *options ) ;
__inline static ino_t parent_ino(struct dentry *dentry ) 
{ ino_t res ;

  {
  {
  _spin_lock(& dentry->d_lock);
  res = ((dentry->d_parent)->d_inode)->i_ino;
  }
  {
  while (1) {
    while_185_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& dentry->d_lock.raw_lock);
    }
    goto while_185_break;
  }
  while_185_break: /* CIL Label */ ;
  }
  return (res);
}
}
extern char *simple_transaction_get(struct file *file , char const   *buf , size_t size ) ;
extern ssize_t simple_transaction_read(struct file *file , char *buf , size_t size ,
                                       loff_t *pos ) ;
extern int simple_transaction_release(struct inode *inode , struct file *file ) ;
extern void simple_transaction_set(struct file *file , size_t n ) ;
extern int simple_attr_open(struct inode *inode , struct file *file , int (*get)(void * ,
                                                                                 u64 * ) ,
                            int (*set)(void * , u64  ) , char const   *fmt ) ;
extern int simple_attr_release(struct inode *inode , struct file *file ) ;
extern ssize_t simple_attr_read(struct file *file , char *buf , size_t len , loff_t *ppos ) ;
extern ssize_t simple_attr_write(struct file *file , char const   *buf , size_t len ,
                                 loff_t *ppos ) ;
extern int proc_nr_files(struct ctl_table *table , int write , struct file *filp ,
                         void *buffer , size_t *lenp , loff_t *ppos ) ;
extern int get_filesystem_list(char *buf )  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern void *idr_find(struct idr *idp , int id ) ;
extern int idr_pre_get(struct idr *idp , gfp_t gfp_mask ) ;
extern int idr_get_new(struct idr *idp , void *ptr , int *id ) ;
extern int idr_get_new_above(struct idr *idp , void *ptr , int starting_id , int *id ) ;
extern int idr_for_each(struct idr *idp , int (*fn)(int id , void *p , void *data ) ,
                        void *data ) ;
extern void *idr_get_next(struct idr *idp , int *nextid ) ;
extern void *idr_replace(struct idr *idp , void *ptr , int id ) ;
extern void idr_remove(struct idr *idp , int id ) ;
extern void idr_remove_all(struct idr *idp ) ;
extern void idr_destroy(struct idr *idp ) ;
extern void idr_init(struct idr *idp ) ;
extern int ida_pre_get(struct ida *ida , gfp_t gfp_mask ) ;
extern int ida_get_new_above(struct ida *ida , int starting_id , int *p_id ) ;
extern int ida_get_new(struct ida *ida , int *p_id ) ;
extern void ida_remove(struct ida *ida , int id ) ;
extern void ida_destroy(struct ida *ida ) ;
extern void ida_init(struct ida *ida ) ;
extern void idr_init_cache(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
__inline static struct fw_device *fw_device(struct device *dev ) 
{ struct device  const  *__mptr ;

  {
  {
  __mptr = (struct device  const  *)dev;
  }
  return ((struct fw_device *)((char *)__mptr - (unsigned int )(& ((struct fw_device *)0)->device)));
}
}
__inline static int fw_device_is_shutdown(struct fw_device *device ) 
{ 

  {
  return (device->state.counter == (int volatile   )3);
}
}
__inline static struct fw_device *fw_device_get(struct fw_device *device ) 
{ 

  {
  {
  get_device(& device->device);
  }
  return (device);
}
}
__inline static void fw_device_put(struct fw_device *device ) 
{ 

  {
  {
  put_device(& device->device);
  }
  return;
}
}
struct fw_device *fw_device_get_by_devt(dev_t devt ) ;
int fw_device_enable_phys_dma(struct fw_device *device ) ;
void fw_device_set_broadcast_channel(struct fw_device *device , int generation ) ;
void fw_device_cdev_update(struct fw_device *device ) ;
void fw_device_cdev_remove(struct fw_device *device ) ;
struct rw_semaphore fw_device_rwsem ;
struct idr fw_device_idr ;
int fw_cdev_major ;
__inline static struct fw_unit *fw_unit(struct device *dev ) 
{ struct device  const  *__mptr ;

  {
  {
  __mptr = (struct device  const  *)dev;
  }
  return ((struct fw_unit *)((char *)__mptr - (unsigned int )(& ((struct fw_unit *)0)->device)));
}
}
__inline static struct fw_unit *fw_unit_get(struct fw_unit *unit ) 
{ 

  {
  {
  get_device(& unit->device);
  }
  return (unit);
}
}
__inline static void fw_unit_put(struct fw_unit *unit ) 
{ 

  {
  {
  put_device(& unit->device);
  }
  return;
}
}
void fw_csr_iterator_init(struct fw_csr_iterator *ci , u32 *p ) ;
int fw_csr_iterator_next(struct fw_csr_iterator *ci , int *key , int *value ) ;
__inline static struct fw_driver *fw_driver(struct device_driver *drv ) 
{ struct device_driver  const  *__mptr ;

  {
  {
  __mptr = (struct device_driver  const  *)drv;
  }
  return ((struct fw_driver *)((char *)__mptr - (unsigned int )(& ((struct fw_driver *)0)->driver)));
}
}
struct file_operations  const  fw_device_ops ;
int fw_compute_block_crc(u32 *block ) 
{ __be32 be32_block[256] ;
  int i ;
  int length ;
  __u32 tmp ;
  u16 tmp___0 ;

  {
  {
  length = (int )((*block >> 16) & 255U);
  i = 0;
  }
  {
  while (1) {
    while_186_continue: /* CIL Label */ ;
    if (! (i < length)) {
      goto while_186_break;
    }
    {
    tmp = __fswab32(*(block + (i + 1)));
    be32_block[i] = tmp;
    i ++;
    }
  }
  while_186_break: /* CIL Label */ ;
  }
  {
  tmp___0 = crc_itu_t((unsigned short)0, (u8 const   *)((u8 *)(be32_block)), (unsigned int )(length * 4));
  *block |= (unsigned int )tmp___0;
  }
  return (length);
}
}
static struct mutex card_mutex  =    {{(int volatile   )1}, {{0U}}, {& card_mutex.wait_list, & card_mutex.wait_list},
    (struct thread_info *)0};
static struct list_head card_list  =    {& card_list, & card_list};
static struct list_head descriptor_list  =    {& descriptor_list, & descriptor_list};
static int descriptor_count  ;
static u32 config_rom[256]  ;
static u32 *generate_config_rom(struct fw_card *card , size_t *config_rom_length ) 
{ struct fw_descriptor *desc ;
  int i ;
  int j ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
  {
  __constant_c_and_count_memset((void *)(config_rom), 0UL, (unsigned int )sizeof(config_rom));
  config_rom[0] = (unsigned int )((4 << 16) | (4 << 24));
  config_rom[1] = 825440564U;
  tmp = card->config_rom_generation;
  (card->config_rom_generation) ++;
  config_rom[2] = (((((unsigned int )((card->link_speed | ((tmp % 14 + 2) << 4)) | (2 << 8)) | (card->max_receive << 12)) | (unsigned int )(1 << 28)) | (unsigned int )(1 << 29)) | (unsigned int )(1 << 30)) | (unsigned int )(1 << 31);
  config_rom[3] = (unsigned int )(card->guid >> 32);
  config_rom[4] = (unsigned int )card->guid;
  i = 5;
  tmp___0 = i;
  i ++;
  config_rom[tmp___0] = 0U;
  tmp___1 = i;
  i ++;
  config_rom[tmp___1] = 201360320U;
  j = i + descriptor_count;
  __mptr = (struct list_head  const  *)descriptor_list.next;
  desc = (struct fw_descriptor *)((char *)__mptr - (unsigned int )(& ((struct fw_descriptor *)0)->link));
  }
  {
  while (1) {
    while_187_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)desc->link.next);
    }
    if (! ((unsigned long )(& desc->link) != (unsigned long )(& descriptor_list))) {
      goto while_187_break;
    }
    if (desc->immediate > 0U) {
      {
      tmp___2 = i;
      i ++;
      config_rom[tmp___2] = desc->immediate;
      }
    }
    {
    config_rom[i] = desc->key | (unsigned int )(j - i);
    i ++;
    j = (int )((size_t )j + desc->length);
    __mptr___0 = (struct list_head  const  *)desc->link.next;
    desc = (struct fw_descriptor *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_descriptor *)0)->link));
    }
  }
  while_187_break: /* CIL Label */ ;
  }
  {
  config_rom[5] = (unsigned int )(((i - 5) - 1) << 16);
  __mptr___1 = (struct list_head  const  *)descriptor_list.next;
  desc = (struct fw_descriptor *)((char *)__mptr___1 - (unsigned int )(& ((struct fw_descriptor *)0)->link));
  }
  {
  while (1) {
    while_188_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)desc->link.next);
    }
    if (! ((unsigned long )(& desc->link) != (unsigned long )(& descriptor_list))) {
      goto while_188_break;
    }
    {
    __memcpy((void *)(& config_rom[i]), (void const   *)desc->data, desc->length * 4U);
    i = (int )((size_t )i + desc->length);
    __mptr___2 = (struct list_head  const  *)desc->link.next;
    desc = (struct fw_descriptor *)((char *)__mptr___2 - (unsigned int )(& ((struct fw_descriptor *)0)->link));
    }
  }
  while_188_break: /* CIL Label */ ;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_189_continue: /* CIL Label */ ;
    if (! (i < j)) {
      goto while_189_break;
    }
    {
    length = fw_compute_block_crc(config_rom + i);
    i += length + 1;
    }
  }
  while_189_break: /* CIL Label */ ;
  }
  {
  *config_rom_length = (unsigned int )j;
  }
  return (config_rom);
}
}
static void update_config_roms(void) 
{ struct fw_card *card ;
  u32 *config_rom___0 ;
  size_t length ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  __mptr = (struct list_head  const  *)card_list.next;
  card = (struct fw_card *)((char *)__mptr - (unsigned int )(& ((struct fw_card *)0)->link));
  }
  {
  while (1) {
    while_190_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)card->link.next);
    }
    if (! ((unsigned long )(& card->link) != (unsigned long )(& card_list))) {
      goto while_190_break;
    }
    {
    config_rom___0 = generate_config_rom(card, & length);
    (*((card->driver)->set_config_rom))(card, config_rom___0, length);
    __mptr___0 = (struct list_head  const  *)card->link.next;
    card = (struct fw_card *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_card *)0)->link));
    }
  }
  while_190_break: /* CIL Label */ ;
  }
  return;
}
}
int fw_core_add_descriptor(struct fw_descriptor *desc ) 
{ size_t i ;

  {
  {
  i = 0U;
  }
  {
  while (1) {
    while_191_continue: /* CIL Label */ ;
    if (! (i < desc->length)) {
      goto while_191_break;
    }
    {
    i += (size_t )((*(desc->data + i) >> 16) + 1U);
    }
  }
  while_191_break: /* CIL Label */ ;
  }
  if (i != desc->length) {
    return (-22);
  }
  {
  mutex_lock(& card_mutex);
  list_add_tail(& desc->link, & descriptor_list);
  descriptor_count ++;
  }
  if (desc->immediate > 0U) {
    {
    descriptor_count ++;
    }
  }
  {
  update_config_roms();
  mutex_unlock(& card_mutex);
  }
  return (0);
}
}
void fw_core_remove_descriptor(struct fw_descriptor *desc ) 
{ 

  {
  {
  mutex_lock(& card_mutex);
  list_del(& desc->link);
  descriptor_count --;
  }
  if (desc->immediate > 0U) {
    {
    descriptor_count --;
    }
  }
  {
  update_config_roms();
  mutex_unlock(& card_mutex);
  }
  return;
}
}
static int set_broadcast_channel(struct device *dev , void *data ) 
{ struct fw_device *tmp ;

  {
  {
  tmp = fw_device(dev);
  fw_device_set_broadcast_channel(tmp, (int )((long )data));
  }
  return (0);
}
}
static void allocate_broadcast_channel(struct fw_card *card , int generation ) 
{ int channel ;
  int bandwidth ;

  {
  {
  bandwidth = 0;
  fw_iso_resource_manage(card, generation, 1ULL << 31, & channel, & bandwidth, (_Bool)1);
  }
  if (channel == 31) {
    {
    card->broadcast_channel_allocated = (_Bool)1;
    device_for_each_child(card->device, (void *)((long )generation), & set_broadcast_channel);
    }
  }
  return;
}
}
static char const   gap_count_table[16]  = 
  {      (char const   )63,      (char const   )5,      (char const   )7,      (char const   )8, 
        (char const   )10,      (char const   )13,      (char const   )16,      (char const   )18, 
        (char const   )21,      (char const   )24,      (char const   )26,      (char const   )29, 
        (char const   )32,      (char const   )35,      (char const   )37,      (char const   )40};
void fw_schedule_bm_work(struct fw_card *card , unsigned long delay ) 
{ int scheduled ;

  {
  {
  fw_card_get(card);
  scheduled = schedule_delayed_work(& card->work, delay);
  }
  if (! scheduled) {
    {
    fw_card_put(card);
    }
  }
  return;
}
}
static void fw_card_bm_work(struct work_struct *work ) 
{ struct fw_card *card ;
  struct work_struct  const  *__mptr ;
  struct fw_device *root_device ;
  struct fw_node *root_node ;
  unsigned long flags ;
  int root_id ;
  int new_root_id ;
  int irm_id ;
  int local_id ;
  int gap_count ;
  int generation ;
  int grace ;
  int rcode ;
  bool do_reset ;
  bool root_device_is_running ;
  bool root_device_is_cmc ;
  __be32 lock_data[2] ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;
  int tmp___0 ;
  unsigned long __dummy___1 ;
  unsigned long volatile   __dummy2___1 ;
  unsigned long __dummy___2 ;
  unsigned long __dummy2___2 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  unsigned long __dummy___3 ;
  unsigned long __dummy2___3 ;
  __u32 tmp___3 ;
  unsigned long __dummy___4 ;
  unsigned long __dummy2___4 ;
  unsigned long __dummy___5 ;
  unsigned long __dummy2___5 ;
  bool tmp___4 ;
  unsigned long __dummy___6 ;
  unsigned long __dummy2___6 ;
  int tmp___5 ;
  unsigned long __dummy___7 ;
  unsigned long __dummy2___7 ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  card = (struct fw_card *)((char *)__mptr - (unsigned int )(& ((struct fw_card *)0)->work.work));
  do_reset = (bool )0;
  }
  {
  while (1) {
    while_192_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_192_break;
  }
  while_192_break: /* CIL Label */ ;
  }
  if ((unsigned long )card->local_node == (unsigned long )((void *)0)) {
    {
    while (1) {
      while_193_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& card->lock, flags);
      }
      goto while_193_break;
    }
    while_193_break: /* CIL Label */ ;
    }
    goto out_put_card;
  }
  {
  generation = card->generation;
  root_node = card->root_node;
  fw_node_get(root_node);
  root_device = (struct fw_device *)root_node->data;
  }
  if (root_device) {
    if (root_device->state.counter == (int volatile   )1) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  } else {
    {
    tmp = 0;
    }
  }
  {
  root_device_is_running = (_Bool )tmp;
  }
  if (root_device) {
    if (root_device->cmc) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  root_device_is_cmc = (_Bool )tmp___0;
  root_id = (int )root_node->node_id;
  irm_id = (int )(card->irm_node)->node_id;
  local_id = (int )(card->local_node)->node_id;
  grace = ((long )(card->reset_jiffies + 125UL) - (long )jiffies < 0L) != 0;
  tmp___4 = is_next_generation(generation, card->bm_generation);
  }
  if (tmp___4) {
    goto _L;
  } else {
    if (card->bm_generation != generation) {
      if (grace) {
        _L: /* CIL Label */ 
        if (! (card->irm_node)->link_on) {
          {
          new_root_id = local_id;
          printk("<5>SomeModule: IRM has link off, making local node (%02x) root.\n",
                 new_root_id);
          }
          goto pick_me;
        }
        {
        lock_data[0] = 63U << 24;
        tmp___2 = __fswab32((unsigned int )local_id);
        lock_data[1] = tmp___2;
        }
        {
        while (1) {
          while_194_continue: /* CIL Label */ ;
          {
          _spin_unlock_irqrestore(& card->lock, flags);
          }
          goto while_194_break;
        }
        while_194_break: /* CIL Label */ ;
        }
        {
        rcode = fw_run_transaction(card, 18, irm_id, generation, 0, 281474708275740ULL,
                                   (void *)(lock_data), (unsigned int )sizeof(lock_data));
        }
        if (rcode == 19) {
          goto out;
        }
        if (rcode == 0) {
          if (lock_data[0] != 63U << 24) {
            if (local_id == irm_id) {
              {
              allocate_broadcast_channel(card, generation);
              }
            }
            goto out;
          }
        }
        {
        while (1) {
          while_195_continue: /* CIL Label */ ;
          {
          flags = _spin_lock_irqsave(& card->lock);
          }
          goto while_195_break;
        }
        while_195_break: /* CIL Label */ ;
        }
        if (rcode != 0) {
          {
          new_root_id = local_id;
          printk("<5>SomeModule: BM lock failed, making local node (%02x) root.\n",
                 new_root_id);
          }
          goto pick_me;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      if (card->bm_generation != generation) {
        {
        while (1) {
          while_196_continue: /* CIL Label */ ;
          {
          _spin_unlock_irqrestore(& card->lock, flags);
          }
          goto while_196_break;
        }
        while_196_break: /* CIL Label */ ;
        }
        {
        fw_schedule_bm_work(card, 125UL);
        }
        goto out;
      }
    }
  }
  {
  card->bm_generation = generation;
  }
  if ((unsigned long )root_device == (unsigned long )((void *)0)) {
    {
    new_root_id = local_id;
    }
  } else {
    if (! root_device_is_running) {
      {
      while (1) {
        while_197_continue: /* CIL Label */ ;
        {
        _spin_unlock_irqrestore(& card->lock, flags);
        }
        goto while_197_break;
      }
      while_197_break: /* CIL Label */ ;
      }
      goto out;
    } else {
      if (root_device_is_cmc) {
        {
        new_root_id = root_id;
        }
      } else {
        {
        new_root_id = local_id;
        }
      }
    }
  }
  pick_me: 
  if (! card->beta_repeaters_present) {
    if ((unsigned long )root_node->max_hops < sizeof(gap_count_table) / sizeof(gap_count_table[0])) {
      {
      gap_count = (int )gap_count_table[root_node->max_hops];
      }
    } else {
      {
      gap_count = 63;
      }
    }
  } else {
    {
    gap_count = 63;
    }
  }
  {
  tmp___5 = card->bm_retries;
  (card->bm_retries) ++;
  }
  if (tmp___5 < 5) {
    if (card->gap_count != gap_count) {
      {
      do_reset = (_Bool)1;
      }
    } else {
      if (new_root_id != root_id) {
        {
        do_reset = (_Bool)1;
        }
      }
    }
  }
  {
  while (1) {
    while_198_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_198_break;
  }
  while_198_break: /* CIL Label */ ;
  }
  if (do_reset) {
    {
    printk("<5>SomeModule: phy config: card %d, new root=%x, gap_count=%d\n", card->index,
           new_root_id, gap_count);
    fw_send_phy_config(card, new_root_id, generation, gap_count);
    fw_core_initiate_bus_reset(card, 1);
    }
  } else {
    if (local_id == irm_id) {
      {
      allocate_broadcast_channel(card, generation);
      }
    }
  }
  out: 
  {
  fw_node_put(root_node);
  }
  out_put_card: 
  {
  fw_card_put(card);
  }
  return;
}
}
static void flush_timer_callback(unsigned long data ) 
{ struct fw_card *card ;

  {
  {
  card = (struct fw_card *)data;
  fw_flush_transactions(card);
  }
  return;
}
}
static atomic_t index  =    {(int volatile   )-1};
void fw_card_initialize(struct fw_card *card , struct fw_card_driver  const  *driver ,
                        struct device *device ) 
{ spinlock_t __constr_expr_0 ;
  atomic_long_t __constr_expr_1 ;

  {
  {
  card->index = atomic_add_return(1, & index);
  card->driver = driver;
  card->device = device;
  card->current_tlabel = 0;
  card->tlabel_mask = 0;
  card->color = (unsigned char)0;
  card->broadcast_channel = (unsigned int )((1 << 31) | 31);
  kref_init(& card->kref);
  init_completion(& card->done);
  INIT_LIST_HEAD(& card->transaction_list);
  }
  {
  while (1) {
    while_199_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    card->lock = __constr_expr_0;
    }
    goto while_199_break;
  }
  while_199_break: /* CIL Label */ ;
  }
  {
  setup_timer_key(& card->flush_timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0),
                  & flush_timer_callback, (unsigned long )card);
  card->local_node = (struct fw_node *)((void *)0);
  }
  {
  while (1) {
    while_200_continue: /* CIL Label */ ;
    {
    while (1) {
      while_201_continue: /* CIL Label */ ;
      {
      __constr_expr_1.counter = (int volatile   )0;
      card->work.work.data = __constr_expr_1;
      INIT_LIST_HEAD(& card->work.work.entry);
      }
      {
      while (1) {
        while_202_continue: /* CIL Label */ ;
        {
        card->work.work.func = & fw_card_bm_work;
        }
        goto while_202_break;
      }
      while_202_break: /* CIL Label */ ;
      }
      goto while_201_break;
    }
    while_201_break: /* CIL Label */ ;
    }
    {
    init_timer_key(& card->work.timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0));
    }
    goto while_200_break;
  }
  while_200_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_fw_card_initialize[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'a',      (char const   )'r',      (char const   )'d',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'i',      (char const   )'t', 
        (char const   )'i',      (char const   )'a',      (char const   )'l',      (char const   )'i', 
        (char const   )'z',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_card_initialize  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_card_initialize), __kstrtab_fw_card_initialize};
int fw_card_add(struct fw_card *card , u32 max_receive , u32 link_speed , u64 guid ) 
{ u32 *config_rom___0 ;
  size_t length ;
  int ret ;

  {
  {
  card->max_receive = max_receive;
  card->link_speed = (int )link_speed;
  card->guid = guid;
  mutex_lock(& card_mutex);
  config_rom___0 = generate_config_rom(card, & length);
  list_add_tail(& card->link, & card_list);
  mutex_unlock(& card_mutex);
  ret = (*((card->driver)->enable))(card, config_rom___0, length);
  }
  if (ret < 0) {
    {
    mutex_lock(& card_mutex);
    list_del(& card->link);
    mutex_unlock(& card_mutex);
    }
  }
  return (ret);
}
}
static char const   __kstrtab_fw_card_add[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'a',      (char const   )'r',      (char const   )'d',      (char const   )'_', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_card_add  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_card_add), __kstrtab_fw_card_add};
static int dummy_enable(struct fw_card *card , u32 *config_rom___0 , size_t length ) 
{ 

  {
  {
  while (1) {
    while_203_continue: /* CIL Label */ ;
    {
    __asm__  volatile   ("1:\tud2\n"
                         ".pushsection __bug_table,\"a\"\n"
                         "2:\t.long 1b, %c0\n"
                         "\t.word %c1, 0\n"
                         "\t.org 2b+%c2\n"
                         ".popsection": : "i" ("fw-card.c"), "i" (468), "i" (sizeof(struct bug_entry )));
    }
    {
    while (1) {
      while_204_continue: /* CIL Label */ ;
    }
    while_204_break: /* CIL Label */ ;
    }
    goto while_203_break;
  }
  while_203_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static int dummy_update_phy_reg(struct fw_card *card , int address , int clear_bits ,
                                int set_bits ) 
{ 

  {
  return (-19);
}
}
static int dummy_set_config_rom(struct fw_card *card , u32 *config_rom___0 , size_t length ) 
{ 

  {
  {
  while (1) {
    while_205_continue: /* CIL Label */ ;
    {
    __asm__  volatile   ("1:\tud2\n"
                         ".pushsection __bug_table,\"a\"\n"
                         "2:\t.long 1b, %c0\n"
                         "\t.word %c1, 0\n"
                         "\t.org 2b+%c2\n"
                         ".popsection": : "i" ("fw-card.c"), "i" (485), "i" (sizeof(struct bug_entry )));
    }
    {
    while (1) {
      while_206_continue: /* CIL Label */ ;
    }
    while_206_break: /* CIL Label */ ;
    }
    goto while_205_break;
  }
  while_205_break: /* CIL Label */ ;
  }
  return (-1);
}
}
static void dummy_send_request(struct fw_card *card , struct fw_packet *packet ) 
{ 

  {
  {
  (*(packet->callback))(packet, card, -19);
  }
  return;
}
}
static void dummy_send_response(struct fw_card *card , struct fw_packet *packet ) 
{ 

  {
  {
  (*(packet->callback))(packet, card, -19);
  }
  return;
}
}
static int dummy_cancel_packet(struct fw_card *card , struct fw_packet *packet ) 
{ 

  {
  return (-2);
}
}
static int dummy_enable_phys_dma(struct fw_card *card , int node_id , int generation ) 
{ 

  {
  return (-19);
}
}
static struct fw_card_driver dummy_driver  = 
     {& dummy_enable, & dummy_update_phy_reg, & dummy_set_config_rom, & dummy_send_request,
    & dummy_send_response, & dummy_cancel_packet, & dummy_enable_phys_dma, (u64 (*)(struct fw_card *card ))0,
    (struct fw_iso_context *(*)(struct fw_card *card , int type , int channel , size_t header_size ))0,
    (void (*)(struct fw_iso_context *ctx ))0, (int (*)(struct fw_iso_context *ctx ,
                                                       s32 cycle , u32 sync , u32 tags ))0,
    (int (*)(struct fw_iso_context *ctx , struct fw_iso_packet *packet , struct fw_iso_buffer *buffer ,
             unsigned long payload ))0, (int (*)(struct fw_iso_context *ctx ))0};
void fw_card_release(struct kref *kref ) 
{ struct fw_card *card ;
  struct kref  const  *__mptr ;

  {
  {
  __mptr = (struct kref  const  *)kref;
  card = (struct fw_card *)((char *)__mptr - (unsigned int )(& ((struct fw_card *)0)->kref));
  complete(& card->done);
  }
  return;
}
}
void fw_core_remove_card(struct fw_card *card ) 
{ int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  (*((card->driver)->update_phy_reg))(card, 4, 192, 0);
  fw_core_initiate_bus_reset(card, 1);
  mutex_lock(& card_mutex);
  list_del_init(& card->link);
  mutex_unlock(& card_mutex);
  card->driver = (struct fw_card_driver  const  *)(& dummy_driver);
  fw_destroy_nodes(card);
  fw_card_put(card);
  wait_for_completion(& card->done);
  tmp = list_empty((struct list_head  const  *)(& card->transaction_list));
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  {
  __ret_warn_on = tmp___0;
  tmp___1 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
  if (tmp___1) {
    {
    warn_slowpath_null("fw-card.c", 546);
    }
  }
  {
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  del_timer_sync(& card->flush_timer);
  }
  return;
}
}
static char const   __kstrtab_fw_core_remove_card[20]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'_',      (char const   )'c', 
        (char const   )'a',      (char const   )'r',      (char const   )'d',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_core_remove_card  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_core_remove_card), __kstrtab_fw_core_remove_card};
int fw_core_initiate_bus_reset(struct fw_card *card , int short_reset ) 
{ int reg ;
  int tmp ;
  int bit ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (short_reset) {
    {
    tmp = 5;
    }
  } else {
    {
    tmp = 1;
    }
  }
  {
  reg = tmp;
  }
  if (short_reset) {
    {
    tmp___0 = 64;
    }
  } else {
    {
    tmp___0 = 64;
    }
  }
  {
  bit = tmp___0;
  tmp___1 = (*((card->driver)->update_phy_reg))(card, reg, 0, bit);
  }
  return (tmp___1);
}
}
static char const   __kstrtab_fw_core_initiate_bus_reset[27]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'i',      (char const   )'t', 
        (char const   )'i',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'_',      (char const   )'b',      (char const   )'u',      (char const   )'s', 
        (char const   )'_',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_core_initiate_bus_reset  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_core_initiate_bus_reset), __kstrtab_fw_core_initiate_bus_reset};
static unsigned long __force_order___0  ;
__inline static unsigned long native_read_cr0___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static void native_write_cr0___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static void native_write_cr2___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static void native_write_cr3___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___0));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___0(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___0): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___0(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___0));
  }
  return;
}
}
__inline static void load_cr3___0(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___0((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___0(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___0();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___0((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___0(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___0();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___0((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___0(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___0 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___0(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___0(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___0(u64 ns ) ;
static union ktime  const  ktime_zero___0  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___0(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___0.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___0  ;
extern int copy_semundo(unsigned long clone_flags , struct task_struct *tsk ) ;
extern void exit_sem(struct task_struct *tsk ) ;
extern void do_notify_resume(struct pt_regs * , void * , __u32  ) ;
extern void do_schedule_next_timer(struct siginfo *info ) ;
__inline static void copy_siginfo(struct siginfo *to , struct siginfo *from ) 
{ 

  {
  if (from->si_code < 0) {
    {
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )sizeof(*to));
    }
  } else {
    {
    __constant_memcpy((void *)to, (void const   *)from, (unsigned int )(4UL * sizeof(int ) + sizeof(from->_sifields._sigchld)));
    }
  }
  return;
}
}
extern int copy_siginfo_to_user(struct siginfo *to , struct siginfo *from ) ;
__inline static void sigaddset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
  sig = (unsigned long )(_sig - 1);
  set->sig[0] |= 1UL << sig;
  }
  return;
}
}
__inline static void sigdelset(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
  sig = (unsigned long )(_sig - 1);
  set->sig[0] &= ~ (1UL << sig);
  }
  return;
}
}
__inline static int sigismember(sigset_t *set , int _sig ) 
{ unsigned long sig ;

  {
  {
  sig = (unsigned long )(_sig - 1);
  }
  return ((int )(1UL & (set->sig[0] >> sig)));
}
}
__inline static int sigfindinword(unsigned long word ) 
{ unsigned long tmp ;

  {
  {
  tmp = ffz(~ word);
  }
  return ((int )tmp);
}
}
extern void _NSIG_WORDS_is_unsupported_size(void) ;
__inline static int sigisemptyset(sigset_t *set ) 
{ 

  {
  if (1 == 4) {
    goto switch_207_4;
  } else {
    if (1 == 2) {
      goto switch_207_2;
    } else {
      if (1 == 1) {
        goto switch_207_1;
      } else {
        {
        goto switch_207_default;
        if (0) {
          switch_207_4: /* CIL Label */ 
          return ((((set->sig[3] | set->sig[2]) | set->sig[1]) | set->sig[0]) == 0UL);
          switch_207_2: /* CIL Label */ 
          return ((set->sig[1] | set->sig[0]) == 0UL);
          switch_207_1: /* CIL Label */ 
          return (set->sig[0] == 0UL);
          switch_207_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
          return (0);
        } else {
          switch_207_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
}
}
__inline static void sigorsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  if (1 == 4) {
    goto switch_208_4;
  } else {
    if (1 == 2) {
      goto switch_208_2;
    } else {
      if (1 == 1) {
        goto switch_208_1;
      } else {
        {
        goto switch_208_default;
        if (0) {
          switch_208_4: /* CIL Label */ 
          {
          a3 = a->sig[3];
          a2 = a->sig[2];
          b3 = b->sig[3];
          b2 = b->sig[2];
          r->sig[3] = a3 | b3;
          r->sig[2] = a2 | b2;
          }
          switch_208_2: /* CIL Label */ 
          {
          a1 = a->sig[1];
          b1 = b->sig[1];
          r->sig[1] = a1 | b1;
          }
          switch_208_1: /* CIL Label */ 
          {
          a0 = a->sig[0];
          b0 = b->sig[0];
          r->sig[0] = a0 | b0;
          }
          goto switch_208_break;
          switch_208_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_208_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void sigandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  if (1 == 4) {
    goto switch_209_4;
  } else {
    if (1 == 2) {
      goto switch_209_2;
    } else {
      if (1 == 1) {
        goto switch_209_1;
      } else {
        {
        goto switch_209_default;
        if (0) {
          switch_209_4: /* CIL Label */ 
          {
          a3 = a->sig[3];
          a2 = a->sig[2];
          b3 = b->sig[3];
          b2 = b->sig[2];
          r->sig[3] = a3 & b3;
          r->sig[2] = a2 & b2;
          }
          switch_209_2: /* CIL Label */ 
          {
          a1 = a->sig[1];
          b1 = b->sig[1];
          r->sig[1] = a1 & b1;
          }
          switch_209_1: /* CIL Label */ 
          {
          a0 = a->sig[0];
          b0 = b->sig[0];
          r->sig[0] = a0 & b0;
          }
          goto switch_209_break;
          switch_209_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_209_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void signandsets(sigset_t *r , sigset_t const   *a , sigset_t const   *b ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;

  {
  if (1 == 4) {
    goto switch_210_4;
  } else {
    if (1 == 2) {
      goto switch_210_2;
    } else {
      if (1 == 1) {
        goto switch_210_1;
      } else {
        {
        goto switch_210_default;
        if (0) {
          switch_210_4: /* CIL Label */ 
          {
          a3 = a->sig[3];
          a2 = a->sig[2];
          b3 = b->sig[3];
          b2 = b->sig[2];
          r->sig[3] = a3 & ~ b3;
          r->sig[2] = a2 & ~ b2;
          }
          switch_210_2: /* CIL Label */ 
          {
          a1 = a->sig[1];
          b1 = b->sig[1];
          r->sig[1] = a1 & ~ b1;
          }
          switch_210_1: /* CIL Label */ 
          {
          a0 = a->sig[0];
          b0 = b->sig[0];
          r->sig[0] = a0 & ~ b0;
          }
          goto switch_210_break;
          switch_210_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_210_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void signotset(sigset_t *set ) 
{ 

  {
  if (1 == 4) {
    goto switch_211_4;
  } else {
    if (1 == 2) {
      goto switch_211_2;
    } else {
      if (1 == 1) {
        goto switch_211_1;
      } else {
        {
        goto switch_211_default;
        if (0) {
          switch_211_4: /* CIL Label */ 
          {
          set->sig[3] = ~ set->sig[3];
          set->sig[2] = ~ set->sig[2];
          }
          switch_211_2: /* CIL Label */ 
          {
          set->sig[1] = ~ set->sig[1];
          }
          switch_211_1: /* CIL Label */ 
          {
          set->sig[0] = ~ set->sig[0];
          }
          goto switch_211_break;
          switch_211_default: /* CIL Label */ 
          {
          _NSIG_WORDS_is_unsupported_size();
          }
        } else {
          switch_211_break: /* CIL Label */ ;
        }
        }
      }
    }
  }
  return;
}
}
__inline static void sigemptyset(sigset_t *set ) 
{ 

  {
  if (1 == 2) {
    goto switch_212_2;
  } else {
    if (1 == 1) {
      goto switch_212_1;
    } else {
      {
      goto switch_212_default;
      if (0) {
        switch_212_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)set, 0UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_212_break;
        switch_212_2: /* CIL Label */ 
        {
        set->sig[1] = 0UL;
        }
        switch_212_1: /* CIL Label */ 
        {
        set->sig[0] = 0UL;
        }
        goto switch_212_break;
      } else {
        switch_212_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void sigfillset(sigset_t *set ) 
{ 

  {
  if (1 == 2) {
    goto switch_213_2;
  } else {
    if (1 == 1) {
      goto switch_213_1;
    } else {
      {
      goto switch_213_default;
      if (0) {
        switch_213_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)set, 4294967295UL, (unsigned int )sizeof(sigset_t ));
        }
        goto switch_213_break;
        switch_213_2: /* CIL Label */ 
        {
        set->sig[1] = 0xffffffffUL;
        }
        switch_213_1: /* CIL Label */ 
        {
        set->sig[0] = 0xffffffffUL;
        }
        goto switch_213_break;
      } else {
        switch_213_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void sigaddsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] |= mask;
  }
  return;
}
}
__inline static void sigdelsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] &= ~ mask;
  }
  return;
}
}
__inline static int sigtestsetmask(sigset_t *set , unsigned long mask ) 
{ 

  {
  return ((set->sig[0] & mask) != 0UL);
}
}
__inline static void siginitset(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] = mask;
  }
  if (1 == 2) {
    goto switch_214_2;
  } else {
    if (1 == 1) {
      goto switch_214_1;
    } else {
      {
      goto switch_214_default;
      if (0) {
        switch_214_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)(& set->sig[1]), 0UL, 0U);
        }
        goto switch_214_break;
        switch_214_2: /* CIL Label */ 
        {
        set->sig[1] = 0UL;
        }
        switch_214_1: /* CIL Label */ 
        {

        }
      } else {
        switch_214_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void siginitsetinv(sigset_t *set , unsigned long mask ) 
{ 

  {
  {
  set->sig[0] = ~ mask;
  }
  if (1 == 2) {
    goto switch_215_2;
  } else {
    if (1 == 1) {
      goto switch_215_1;
    } else {
      {
      goto switch_215_default;
      if (0) {
        switch_215_default: /* CIL Label */ 
        {
        __constant_c_and_count_memset((void *)(& set->sig[1]), 4294967295UL, 0U);
        }
        goto switch_215_break;
        switch_215_2: /* CIL Label */ 
        {
        set->sig[1] = 0xffffffffUL;
        }
        switch_215_1: /* CIL Label */ 
        {

        }
      } else {
        switch_215_break: /* CIL Label */ ;
      }
      }
    }
  }
  return;
}
}
__inline static void init_sigpending(struct sigpending *sig ) 
{ 

  {
  {
  sigemptyset(& sig->signal);
  INIT_LIST_HEAD(& sig->list);
  }
  return;
}
}
extern void flush_sigqueue(struct sigpending *queue ) ;
__inline static int valid_signal(unsigned long sig ) 
{ int tmp ;

  {
  if (sig <= 64UL) {
    {
    tmp = 1;
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern int next_signal(struct sigpending *pending , sigset_t *mask ) ;
extern int group_send_sig_info(int sig , struct siginfo *info , struct task_struct *p ) ;
extern int __group_send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern long do_sigpending(void * , unsigned long  ) ;
extern int sigprocmask(int  , sigset_t * , sigset_t * ) ;
extern int show_unhandled_signals ;
extern int get_signal_to_deliver(siginfo_t *info , struct k_sigaction *return_ka ,
                                 struct pt_regs *regs , void *cookie ) ;
extern void exit_signals(struct task_struct *tsk ) ;
extern struct kmem_cache *sighand_cachep ;
extern int unhandled_signal(struct task_struct *tsk , int sig ) ;
extern void signals_init(void) ;
extern int percpu_counter_batch ;
extern int __percpu_counter_init(struct percpu_counter *fbc , s64 amount , struct lock_class_key *key ) ;
extern void percpu_counter_destroy(struct percpu_counter *fbc ) ;
extern void percpu_counter_set(struct percpu_counter *fbc , s64 amount ) ;
extern void __percpu_counter_add(struct percpu_counter *fbc , s64 amount , s32 batch ) ;
extern s64 __percpu_counter_sum(struct percpu_counter *fbc ) ;
__inline static void percpu_counter_add(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
  __percpu_counter_add(fbc, amount, percpu_counter_batch);
  }
  return;
}
}
__inline static s64 percpu_counter_sum_positive(struct percpu_counter *fbc ) 
{ s64 ret ;
  s64 tmp ;
  s64 tmp___0 ;

  {
  {
  tmp = __percpu_counter_sum(fbc);
  ret = tmp;
  }
  if (ret < 0LL) {
    {
    tmp___0 = 0LL;
    }
  } else {
    {
    tmp___0 = ret;
    }
  }
  return (tmp___0);
}
}
__inline static s64 percpu_counter_sum(struct percpu_counter *fbc ) 
{ s64 tmp ;

  {
  {
  tmp = __percpu_counter_sum(fbc);
  }
  return (tmp);
}
}
__inline static s64 percpu_counter_read(struct percpu_counter *fbc ) 
{ 

  {
  return (fbc->count);
}
}
__inline static s64 percpu_counter_read_positive(struct percpu_counter *fbc ) 
{ s64 ret ;

  {
  {
  ret = fbc->count;
  __asm__  volatile   ("": : : "memory");
  }
  if (ret >= 0LL) {
    return (ret);
  }
  return (1LL);
}
}
__inline static void percpu_counter_inc(struct percpu_counter *fbc ) 
{ 

  {
  {
  percpu_counter_add(fbc, 1LL);
  }
  return;
}
}
__inline static void percpu_counter_dec(struct percpu_counter *fbc ) 
{ 

  {
  {
  percpu_counter_add(fbc, -1LL);
  }
  return;
}
}
__inline static void percpu_counter_sub(struct percpu_counter *fbc , s64 amount ) 
{ 

  {
  {
  percpu_counter_add(fbc, - amount);
  }
  return;
}
}
extern int prop_descriptor_init(struct prop_descriptor *pd , int shift ) ;
extern void prop_change_shift(struct prop_descriptor *pd , int new_shift ) ;
extern int prop_local_init_percpu(struct prop_local_percpu *pl ) ;
extern void prop_local_destroy_percpu(struct prop_local_percpu *pl ) ;
extern void __prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) ;
extern void prop_fraction_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                 long *numerator , long *denominator ) ;
__inline static void prop_inc_percpu(struct prop_descriptor *pd , struct prop_local_percpu *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
  while (1) {
    while_216_continue: /* CIL Label */ ;
    {
    while (1) {
      while_217_continue: /* CIL Label */ ;
      {
      flags = __raw_local_irq_save();
      }
      goto while_217_break;
    }
    while_217_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_218_continue: /* CIL Label */ ;
      goto while_218_break;
    }
    while_218_break: /* CIL Label */ ;
    }
    goto while_216_break;
  }
  while_216_break: /* CIL Label */ ;
  }
  {
  __prop_inc_percpu(pd, pl);
  }
  {
  while (1) {
    while_219_continue: /* CIL Label */ ;
    {
    tmp = raw_irqs_disabled_flags(flags);
    }
    if (tmp) {
      {
      raw_local_irq_restore(flags);
      }
      {
      while (1) {
        while_220_continue: /* CIL Label */ ;
        goto while_220_break;
      }
      while_220_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_221_continue: /* CIL Label */ ;
        goto while_221_break;
      }
      while_221_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_restore(flags);
      }
    }
    goto while_219_break;
  }
  while_219_break: /* CIL Label */ ;
  }
  return;
}
}
extern void __prop_inc_percpu_max(struct prop_descriptor *pd , struct prop_local_percpu *pl ,
                                  long frac ) ;
extern int prop_local_init_single(struct prop_local_single *pl ) ;
extern void prop_local_destroy_single(struct prop_local_single *pl ) ;
extern void __prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) ;
extern void prop_fraction_single(struct prop_descriptor *pd , struct prop_local_single *pl ,
                                 long *numerator , long *denominator ) ;
__inline static void prop_inc_single(struct prop_descriptor *pd , struct prop_local_single *pl ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
  while (1) {
    while_222_continue: /* CIL Label */ ;
    {
    while (1) {
      while_223_continue: /* CIL Label */ ;
      {
      flags = __raw_local_irq_save();
      }
      goto while_223_break;
    }
    while_223_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_224_continue: /* CIL Label */ ;
      goto while_224_break;
    }
    while_224_break: /* CIL Label */ ;
    }
    goto while_222_break;
  }
  while_222_break: /* CIL Label */ ;
  }
  {
  __prop_inc_single(pd, pl);
  }
  {
  while (1) {
    while_225_continue: /* CIL Label */ ;
    {
    tmp = raw_irqs_disabled_flags(flags);
    }
    if (tmp) {
      {
      raw_local_irq_restore(flags);
      }
      {
      while (1) {
        while_226_continue: /* CIL Label */ ;
        goto while_226_break;
      }
      while_226_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_227_continue: /* CIL Label */ ;
        goto while_227_break;
      }
      while_227_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_restore(flags);
      }
    }
    goto while_225_break;
  }
  while_225_break: /* CIL Label */ ;
  }
  return;
}
}
extern void __secure_computing(int  ) ;
__inline static void secure_computing(int this_syscall ) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = current_thread_info();
  tmp___0 = test_ti_thread_flag(tmp, 8);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  if (tmp___2) {
    {
    __secure_computing(this_syscall);
    }
  }
  return;
}
}
extern long prctl_get_seccomp(void) ;
extern long prctl_set_seccomp(unsigned long  ) ;
__inline static void plist_head_init(struct plist_head *head , spinlock_t *lock ) 
{ 

  {
  {
  INIT_LIST_HEAD(& head->prio_list);
  INIT_LIST_HEAD(& head->node_list);
  }
  return;
}
}
__inline static void plist_node_init(struct plist_node *node , int prio ) 
{ 

  {
  {
  node->prio = prio;
  plist_head_init(& node->plist, (spinlock_t *)((void *)0));
  }
  return;
}
}
extern void plist_add(struct plist_node *node , struct plist_head *head ) ;
extern void plist_del(struct plist_node *node , struct plist_head *head ) ;
__inline static int plist_head_empty(struct plist_head  const  *head ) 
{ int tmp ;

  {
  {
  tmp = list_empty(& head->node_list);
  }
  return (tmp);
}
}
__inline static int plist_node_empty(struct plist_node  const  *node ) 
{ int tmp ;

  {
  {
  tmp = plist_head_empty(& node->plist);
  }
  return (tmp);
}
}
__inline static struct plist_node *plist_first(struct plist_head  const  *head ) 
{ struct list_head  const  *__mptr ;

  {
  {
  __mptr = (struct list_head  const  *)head->node_list.next;
  }
  return ((struct plist_node *)((char *)__mptr - (unsigned int )(& ((struct plist_node *)0)->plist.node_list)));
}
}
__inline static int rt_mutex_debug_check_no_locks_freed(void const   *from , unsigned long len ) 
{ 

  {
  return (0);
}
}
__inline static int rt_mutex_is_locked(struct rt_mutex *lock ) 
{ 

  {
  return ((unsigned long )lock->owner != (unsigned long )((void *)0));
}
}
extern void __rt_mutex_init(struct rt_mutex *lock , char const   *name ) ;
extern void rt_mutex_destroy(struct rt_mutex *lock ) ;
extern void rt_mutex_lock(struct rt_mutex *lock ) ;
extern int rt_mutex_lock_interruptible(struct rt_mutex *lock , int detect_deadlock ) ;
extern int rt_mutex_timed_lock(struct rt_mutex *lock , struct hrtimer_sleeper *timeout ,
                               int detect_deadlock ) ;
extern int rt_mutex_trylock(struct rt_mutex *lock ) ;
extern void rt_mutex_unlock(struct rt_mutex *lock ) ;
extern int getrusage(struct task_struct *p , int who , struct rusage *ru ) ;
__inline static void hrtimer_set_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
  timer->_expires = time;
  timer->_softexpires = time;
  }
  return;
}
}
__inline static void hrtimer_set_expires_range(struct hrtimer *timer , ktime_t time ,
                                               ktime_t delta ) 
{ 

  {
  {
  timer->_softexpires = time;
  timer->_expires = ktime_add_safe(time, delta);
  }
  return;
}
}
__inline static void hrtimer_set_expires_range_ns(struct hrtimer *timer , ktime_t time ,
                                                  unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___0((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
__inline static void hrtimer_set_expires_tv64(struct hrtimer *timer , s64 tv64 ) 
{ 

  {
  {
  timer->_expires.tv64 = tv64;
  timer->_softexpires.tv64 = tv64;
  }
  return;
}
}
__inline static void hrtimer_add_expires(struct hrtimer *timer , ktime_t time ) 
{ 

  {
  {
  timer->_expires = ktime_add_safe(timer->_expires, time);
  timer->_softexpires = ktime_add_safe(timer->_softexpires, time);
  }
  return;
}
}
__inline static void hrtimer_add_expires_ns(struct hrtimer *timer , u64 ns ) 
{ ktime_t __constr_expr_0 ;
  ktime_t __constr_expr_1 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )timer->_expires.tv64 + ns);
  timer->_expires = __constr_expr_0;
  __constr_expr_1.tv64 = (s64 )((u64 )timer->_softexpires.tv64 + ns);
  timer->_softexpires = __constr_expr_1;
  }
  return;
}
}
__inline static ktime_t hrtimer_get_expires(struct hrtimer  const  *timer ) 
{ 

  {
  return (timer->_expires);
}
}
__inline static ktime_t hrtimer_get_softexpires(struct hrtimer  const  *timer ) 
{ 

  {
  return (timer->_softexpires);
}
}
__inline static s64 hrtimer_get_expires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
  return ((long long )timer->_expires.tv64);
}
}
__inline static s64 hrtimer_get_softexpires_tv64(struct hrtimer  const  *timer ) 
{ 

  {
  return ((long long )timer->_softexpires.tv64);
}
}
__inline static ktime_t hrtimer_expires_remaining(struct hrtimer  const  *timer ) 
{ ktime_t __constr_expr_0 ;
  ktime_t tmp ;

  {
  {
  tmp = (*((timer->base)->get_time))();
  __constr_expr_0.tv64 = (s64 )(timer->_expires.tv64 - (s64 const   )tmp.tv64);
  }
  return (__constr_expr_0);
}
}
extern void clock_was_set(void) ;
extern void hres_timers_resume(void) ;
extern void hrtimer_interrupt(struct clock_event_device *dev ) ;
__inline static ktime_t hrtimer_cb_get_time(struct hrtimer *timer ) 
{ ktime_t tmp ;

  {
  {
  tmp = (*((timer->base)->get_time))();
  }
  return (tmp);
}
}
__inline static int hrtimer_is_hres_active(struct hrtimer *timer ) 
{ 

  {
  return (((timer->base)->cpu_base)->hres_active);
}
}
extern void hrtimer_peek_ahead_timers(void) ;
extern ktime_t ktime_get(void) ;
extern ktime_t ktime_get_real(void) ;
extern struct tick_device per_cpu__tick_cpu_device  __attribute__((__section__(".data.percpu"))) ;
extern void hrtimer_init(struct hrtimer *timer , clockid_t which_clock , enum hrtimer_mode mode ) ;
__inline static void hrtimer_init_on_stack(struct hrtimer *timer , clockid_t which_clock ,
                                           enum hrtimer_mode mode ) 
{ 

  {
  {
  hrtimer_init(timer, which_clock, mode);
  }
  return;
}
}
__inline static void destroy_hrtimer_on_stack(struct hrtimer *timer ) 
{ 

  {
  return;
}
}
extern int hrtimer_start(struct hrtimer *timer , ktime_t tim , enum hrtimer_mode mode ) ;
extern int hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long range_ns ,
                                  enum hrtimer_mode mode ) ;
extern int __hrtimer_start_range_ns(struct hrtimer *timer , ktime_t tim , unsigned long delta_ns ,
                                    enum hrtimer_mode mode , int wakeup ) ;
extern int hrtimer_cancel(struct hrtimer *timer ) ;
extern int hrtimer_try_to_cancel(struct hrtimer *timer ) ;
__inline static int hrtimer_start_expires(struct hrtimer *timer , enum hrtimer_mode mode ) 
{ unsigned long delta ;
  ktime_t soft ;
  ktime_t hard ;
  ktime_t __constr_expr_0 ;
  int tmp ;

  {
  {
  soft = hrtimer_get_softexpires((struct hrtimer  const  *)timer);
  hard = hrtimer_get_expires((struct hrtimer  const  *)timer);
  __constr_expr_0.tv64 = hard.tv64 - soft.tv64;
  delta = (unsigned long )__constr_expr_0.tv64;
  tmp = hrtimer_start_range_ns(timer, soft, delta, mode);
  }
  return (tmp);
}
}
__inline static int hrtimer_restart(struct hrtimer *timer ) 
{ int tmp ;

  {
  {
  tmp = hrtimer_start_expires(timer, (enum hrtimer_mode )0);
  }
  return (tmp);
}
}
extern ktime_t hrtimer_get_remaining(struct hrtimer  const  *timer ) ;
extern int hrtimer_get_res(clockid_t which_clock , struct timespec *tp ) ;
extern ktime_t hrtimer_get_next_event(void) ;
__inline static int hrtimer_active(struct hrtimer  const  *timer ) 
{ 

  {
  return (timer->state != 0UL);
}
}
__inline static int hrtimer_is_queued(struct hrtimer *timer ) 
{ 

  {
  return ((int )(timer->state & 1UL));
}
}
__inline static int hrtimer_callback_running(struct hrtimer *timer ) 
{ 

  {
  return ((int )(timer->state & 2UL));
}
}
extern u64 hrtimer_forward(struct hrtimer *timer , ktime_t now , ktime_t interval ) ;
__inline static u64 hrtimer_forward_now(struct hrtimer *timer , ktime_t interval ) 
{ ktime_t tmp ;
  u64 tmp___0 ;

  {
  {
  tmp = (*((timer->base)->get_time))();
  tmp___0 = hrtimer_forward(timer, tmp, interval);
  }
  return (tmp___0);
}
}
extern long hrtimer_nanosleep(struct timespec *rqtp , struct timespec *rmtp , enum hrtimer_mode mode ,
                              clockid_t clockid ) ;
extern long hrtimer_nanosleep_restart(struct restart_block *restart_block ) ;
extern void hrtimer_init_sleeper(struct hrtimer_sleeper *sl , struct task_struct *tsk ) ;
extern int schedule_hrtimeout_range(ktime_t *expires , unsigned long delta , enum hrtimer_mode mode ) ;
extern int schedule_hrtimeout(ktime_t *expires , enum hrtimer_mode mode ) ;
extern void hrtimer_run_queues(void) ;
extern void hrtimer_run_pending(void) ;
extern void hrtimers_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern u64 ktime_divns(ktime_t kt , s64 div ) ;
extern void sysrq_timer_list_show(void) ;
__inline static void timer_stats_account_hrtimer(struct hrtimer *timer ) 
{ 

  {
  {
  timer_stats_update_stats((void *)timer, timer->start_pid, timer->start_site, (void *)timer->function,
                           timer->start_comm, 0U);
  }
  return;
}
}
extern void __timer_stats_hrtimer_set_start_info(struct hrtimer *timer , void *addr ) ;
__inline static void timer_stats_hrtimer_set_start_info(struct hrtimer *timer ) 
{ void *tmp ;

  {
  {
  tmp = __builtin_return_address(0U);
  __timer_stats_hrtimer_set_start_info(timer, tmp);
  }
  return;
}
}
__inline static void timer_stats_hrtimer_clear_start_info(struct hrtimer *timer ) 
{ 

  {
  {
  timer->start_site = (void *)0;
  }
  return;
}
}
__inline static void account_scheduler_latency(struct task_struct *task , int usecs ,
                                               int inter ) 
{ 

  {
  return;
}
}
extern void setup_sysctl_set(struct ctl_table_set *p , struct ctl_table_set *parent ,
                             int (*is_seen)(struct ctl_table_set * ) ) ;
extern void sysctl_head_get(struct ctl_table_header * ) ;
extern void sysctl_head_put(struct ctl_table_header * ) ;
extern int sysctl_is_seen(struct ctl_table_header * ) ;
extern struct ctl_table_header *sysctl_head_grab(struct ctl_table_header * ) ;
extern struct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev ) ;
extern struct ctl_table_header *__sysctl_head_next(struct nsproxy *namespaces , struct ctl_table_header *prev ) ;
extern void sysctl_head_finish(struct ctl_table_header *prev ) ;
extern int sysctl_perm(struct ctl_table_root *root , struct ctl_table *table , int op ) ;
extern int proc_dostring(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
extern int proc_dointvec(struct ctl_table * , int  , struct file * , void * , size_t * ,
                         loff_t * ) ;
extern int proc_dointvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                size_t * , loff_t * ) ;
extern int proc_dointvec_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                 size_t * , loff_t * ) ;
extern int proc_dointvec_userhz_jiffies(struct ctl_table * , int  , struct file * ,
                                        void * , size_t * , loff_t * ) ;
extern int proc_dointvec_ms_jiffies(struct ctl_table * , int  , struct file * , void * ,
                                    size_t * , loff_t * ) ;
extern int proc_doulongvec_minmax(struct ctl_table * , int  , struct file * , void * ,
                                  size_t * , loff_t * ) ;
extern int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table , int  , struct file * ,
                                             void * , size_t * , loff_t * ) ;
extern int do_sysctl(int *name , int nlen , void *oldval , size_t *oldlenp , void *newval ,
                     size_t newlen ) ;
extern ctl_handler sysctl_data ;
extern ctl_handler sysctl_string ;
extern ctl_handler sysctl_intvec ;
extern ctl_handler sysctl_jiffies ;
extern ctl_handler sysctl_ms_jiffies ;
extern void register_sysctl_root(struct ctl_table_root *root ) ;
extern struct ctl_table_header *__register_sysctl_paths(struct ctl_table_root *root ,
                                                        struct nsproxy *namespaces ,
                                                        struct ctl_path  const  *path ,
                                                        struct ctl_table *table ) ;
extern struct ctl_table_header *register_sysctl_table(struct ctl_table *table ) ;
extern struct ctl_table_header *register_sysctl_paths(struct ctl_path  const  *path ,
                                                      struct ctl_table *table ) ;
extern void unregister_sysctl_table(struct ctl_table_header *table ) ;
extern int sysctl_check_table(struct nsproxy *namespaces , struct ctl_table *table ) ;
__inline static key_ref_t make_key_ref(struct key  const  *key , unsigned long possession ) 
{ 

  {
  return ((struct __key_reference_with_attributes *)((unsigned long )key | possession));
}
}
__inline static struct key *key_ref_to_ptr(key_ref_t key_ref ) 
{ 

  {
  return ((struct key *)((unsigned long )key_ref & 0xfffffffeUL));
}
}
__inline static unsigned long is_key_possessed(key_ref_t key_ref ) 
{ 

  {
  return ((unsigned long )key_ref & 1UL);
}
}
extern struct key *key_alloc(struct key_type *type , char const   *desc , uid_t uid ,
                             gid_t gid , struct cred  const  *cred , key_perm_t perm ,
                             unsigned long flags ) ;
extern void key_revoke(struct key *key ) ;
extern void key_put(struct key *key ) ;
__inline static struct key *key_get(struct key *key ) 
{ 

  {
  if (key) {
    {
    atomic_inc(& key->usage);
    }
  }
  return (key);
}
}
__inline static void key_ref_put(key_ref_t key_ref ) 
{ struct key *tmp ;

  {
  {
  tmp = key_ref_to_ptr(key_ref);
  key_put(tmp);
  }
  return;
}
}
extern struct key *request_key(struct key_type *type , char const   *description ,
                               char const   *callout_info ) ;
extern struct key *request_key_with_auxdata(struct key_type *type , char const   *description ,
                                            void const   *callout_info , size_t callout_len ,
                                            void *aux ) ;
extern struct key *request_key_async(struct key_type *type , char const   *description ,
                                     void const   *callout_info , size_t callout_len ) ;
extern struct key *request_key_async_with_auxdata(struct key_type *type , char const   *description ,
                                                  void const   *callout_info , size_t callout_len ,
                                                  void *aux ) ;
extern int wait_for_key_construction(struct key *key , bool intr ) ;
extern int key_validate(struct key *key ) ;
extern key_ref_t key_create_or_update(key_ref_t keyring , char const   *type , char const   *description ,
                                      void const   *payload , size_t plen , key_perm_t perm ,
                                      unsigned long flags ) ;
extern int key_update(key_ref_t key , void const   *payload , size_t plen ) ;
extern int key_link(struct key *keyring , struct key *key ) ;
extern int key_unlink(struct key *keyring , struct key *key ) ;
extern struct key *keyring_alloc(char const   *description , uid_t uid , gid_t gid ,
                                 struct cred  const  *cred , unsigned long flags ,
                                 struct key *dest ) ;
extern int keyring_clear(struct key *keyring ) ;
extern key_ref_t keyring_search(key_ref_t keyring , struct key_type *type , char const   *description ) ;
extern int keyring_add_key(struct key *keyring , struct key *key ) ;
extern struct key *key_lookup(key_serial_t id ) ;
__inline static key_serial_t key_serial(struct key *key ) 
{ key_serial_t tmp ;

  {
  if (key) {
    {
    tmp = key->serial;
    }
  } else {
    {
    tmp = 0;
    }
  }
  return (tmp);
}
}
extern ctl_table key_sysctls[] ;
extern int install_thread_keyring_to_cred(struct cred *cred ) ;
extern void key_fsuid_changed(struct task_struct *tsk ) ;
extern void key_fsgid_changed(struct task_struct *tsk ) ;
extern void key_init(void) ;
__inline static struct group_info *get_group_info(struct group_info *gi ) 
{ 

  {
  {
  atomic_inc(& gi->usage);
  }
  return (gi);
}
}
extern struct group_info *groups_alloc(int  ) ;
extern struct group_info init_groups ;
extern void groups_free(struct group_info * ) ;
extern int set_current_groups(struct group_info * ) ;
extern int set_groups(struct cred * , struct group_info * ) ;
extern int groups_search(struct group_info  const  * , gid_t  ) ;
extern int in_group_p(gid_t  ) ;
extern int in_egroup_p(gid_t  ) ;
extern void __put_cred(struct cred * ) ;
extern int copy_creds(struct task_struct * , unsigned long  ) ;
extern struct cred *prepare_creds(void) ;
extern struct cred *prepare_exec_creds(void) ;
extern struct cred *prepare_usermodehelper_creds(void) ;
extern int commit_creds(struct cred * ) ;
extern void abort_creds(struct cred * ) ;
extern struct cred  const  *override_creds(struct cred  const  * ) ;
extern void revert_creds(struct cred  const  * ) ;
extern struct cred *prepare_kernel_cred(struct task_struct * ) ;
extern int change_create_files_as(struct cred * , struct inode * ) ;
extern int set_security_override(struct cred * , u32  ) ;
extern int set_security_override_from_ctx(struct cred * , char const   * ) ;
extern int set_create_files_as(struct cred * , struct inode * ) ;
extern void cred_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
__inline static struct cred *get_new_cred(struct cred *cred ) 
{ 

  {
  {
  atomic_inc(& cred->usage);
  }
  return (cred);
}
}
__inline static struct cred  const  *get_cred(struct cred  const  *cred ) 
{ struct cred *tmp ;

  {
  {
  tmp = get_new_cred((struct cred *)cred);
  }
  return ((struct cred  const  *)tmp);
}
}
__inline static void put_cred(struct cred  const  *_cred ) 
{ struct cred *cred ;
  long tmp ;
  int tmp___0 ;

  {
  {
  cred = (struct cred *)_cred;
  }
  {
  while (1) {
    while_228_continue: /* CIL Label */ ;
    {
    tmp = __builtin_expect((long )(! (! (cred->usage.counter <= (int volatile   )0))),
                           0L);
    }
    if (tmp) {
      {
      while (1) {
        while_229_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("/home/kalmera/goblint_stuff/goblint/../linux-headers/include/linux/cred.h"),
                             "i" (207), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_230_continue: /* CIL Label */ ;
        }
        while_230_break: /* CIL Label */ ;
        }
        goto while_229_break;
      }
      while_229_break: /* CIL Label */ ;
      }
    }
    goto while_228_break;
  }
  while_228_break: /* CIL Label */ ;
  }
  {
  tmp___0 = atomic_dec_and_test(& cred->usage);
  }
  if (tmp___0) {
    {
    __put_cred(cred);
    }
  }
  return;
}
}
extern unsigned long avenrun[] ;
extern unsigned long total_forks ;
extern int nr_threads ;
extern unsigned long per_cpu__process_counts  __attribute__((__section__(".data.percpu"))) ;
extern int nr_processes(void) ;
extern unsigned long nr_running(void) ;
extern unsigned long nr_uninterruptible(void) ;
extern unsigned long nr_active(void) ;
extern unsigned long nr_iowait(void) ;
extern unsigned long get_parent_ip(unsigned long addr ) ;
__inline static void proc_sched_show_task(struct task_struct *p , struct seq_file *m ) 
{ 

  {
  return;
}
}
__inline static void print_cfs_rq(struct seq_file *m , int cpu , struct cfs_rq *cfs_rq ) 
{ 

  {
  return;
}
}
extern unsigned long long time_sync_thresh ;
extern rwlock_t tasklist_lock ;
extern spinlock_t mmlist_lock ;
extern void sched_init(void) ;
extern void sched_init_smp(void) ;
extern void ( __attribute__((__regparm__(0))) schedule_tail)(struct task_struct *prev ) ;
extern void init_idle(struct task_struct *idle , int cpu ) ;
extern void init_idle_bootup_task(struct task_struct *idle ) ;
extern int runqueue_is_locked(void) ;
extern void task_rq_unlock_wait(struct task_struct *p ) ;
extern cpumask_var_t nohz_cpu_mask ;
extern int select_nohz_load_balancer(int cpu ) ;
extern void show_state_filter(unsigned long state_filter ) ;
__inline static void show_state(void) 
{ 

  {
  {
  show_state_filter(0UL);
  }
  return;
}
}
extern void show_regs(struct pt_regs * ) ;
extern void show_stack(struct task_struct *task , unsigned long *sp ) ;
extern void io_schedule(void) ;
extern long io_schedule_timeout(long timeout ) ;
extern void trap_init(void) ;
extern void update_process_times(int user ) ;
extern void scheduler_tick(void) ;
extern void sched_show_task(struct task_struct *p ) ;
extern char __sched_text_start[] ;
extern char __sched_text_end[] ;
extern int in_sched_functions(unsigned long addr ) ;
extern long schedule_timeout(long timeout ) ;
extern long schedule_timeout_interruptible(long timeout ) ;
extern long schedule_timeout_killable(long timeout ) ;
extern long schedule_timeout_uninterruptible(long timeout ) ;
extern void ( __attribute__((__regparm__(0))) __schedule)(void) ;
extern void ( __attribute__((__regparm__(0))) schedule)(void) ;
extern int mutex_spin_on_owner(struct mutex *lock , struct thread_info *owner ) ;
extern int sysctl_max_map_count ;
__inline static size_t iov_length(struct iovec  const  *iov , unsigned long nr_segs ) 
{ unsigned long seg ;
  size_t ret ;

  {
  {
  ret = (size_t )0;
  seg = 0UL;
  }
  {
  while (1) {
    while_231_continue: /* CIL Label */ ;
    if (! (seg < nr_segs)) {
      goto while_231_break;
    }
    {
    ret += (size_t )(iov + seg)->iov_len;
    seg ++;
    }
  }
  while_231_break: /* CIL Label */ ;
  }
  return (ret);
}
}
extern unsigned long iov_shorten(struct iovec *iov , unsigned long nr_segs , size_t to ) ;
extern unsigned int aio_max_size ;
extern ssize_t wait_on_sync_kiocb(struct kiocb *iocb ) ;
extern int aio_put_req(struct kiocb *iocb ) ;
extern void kick_iocb(struct kiocb *iocb ) ;
extern int aio_complete(struct kiocb *iocb , long res , long res2 ) ;
extern void exit_aio(struct mm_struct *mm ) ;
__inline static struct kiocb *list_kiocb(struct list_head *h ) 
{ struct list_head  const  *__mptr ;

  {
  {
  __mptr = (struct list_head  const  *)h;
  }
  return ((struct kiocb *)((char *)__mptr - (unsigned int )(& ((struct kiocb *)0)->ki_list)));
}
}
extern unsigned long aio_nr ;
extern unsigned long aio_max_nr ;
extern unsigned long arch_get_unmapped_area(struct file * , unsigned long  , unsigned long  ,
                                            unsigned long  , unsigned long  ) ;
extern unsigned long arch_get_unmapped_area_topdown(struct file *filp , unsigned long addr ,
                                                    unsigned long len , unsigned long pgoff ,
                                                    unsigned long flags ) ;
extern void arch_unmap_area(struct mm_struct * , unsigned long  ) ;
extern void arch_unmap_area_topdown(struct mm_struct * , unsigned long  ) ;
__inline static unsigned long get_mm_hiwater_rss(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  long tmp ;
  long tmp___0 ;
  unsigned long _max2 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
  _max1 = mm->hiwater_rss;
  tmp___1 = atomic_long_read(& mm->_file_rss);
  tmp___2 = atomic_long_read(& mm->_anon_rss);
  _max2 = (unsigned long )tmp___1 + (unsigned long )tmp___2;
  }
  if (_max1 > _max2) {
    {
    tmp___3 = _max1;
    }
  } else {
    {
    tmp___3 = _max2;
    }
  }
  return (tmp___3);
}
}
__inline static unsigned long get_mm_hiwater_vm(struct mm_struct *mm ) 
{ unsigned long _max1 ;
  unsigned long _max2 ;
  unsigned long tmp ;

  {
  {
  _max1 = mm->hiwater_vm;
  _max2 = mm->total_vm;
  }
  if (_max1 > _max2) {
    {
    tmp = _max1;
    }
  } else {
    {
    tmp = _max2;
    }
  }
  return (tmp);
}
}
extern void set_dumpable(struct mm_struct *mm , int value ) ;
extern int get_dumpable(struct mm_struct *mm ) ;
__inline static int signal_group_exit(struct signal_struct  const  *sig ) 
{ int tmp ;

  {
  if (sig->flags & 8U) {
    {
    tmp = 1;
    }
  } else {
    if ((unsigned long )sig->group_exit_task != (unsigned long )((void *)0)) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return (tmp);
}
}
extern int uids_sysfs_init(void) ;
extern struct user_struct *find_user(uid_t  ) ;
extern struct user_struct root_user ;
__inline static int sched_info_on(void) 
{ 

  {
  return (1);
}
}
extern int sched_mc_power_savings ;
extern int sched_smt_power_savings ;
__inline static int sd_balance_for_mc_power(void) 
{ 

  {
  if (sched_smt_power_savings) {
    return (256);
  }
  return (0);
}
}
__inline static int sd_balance_for_package_power(void) 
{ 

  {
  if (sched_mc_power_savings | sched_smt_power_savings) {
    return (256);
  }
  return (0);
}
}
__inline static int sd_power_saving_flags(void) 
{ 

  {
  if (sched_mc_power_savings | sched_smt_power_savings) {
    return (2);
  }
  return (0);
}
}
__inline static struct cpumask *sched_group_cpus(struct sched_group *sg ) 
{ int tmp ;

  {
  return ((struct cpumask *)(sg->cpumask));
}
}
__inline static struct cpumask *sched_domain_span(struct sched_domain *sd ) 
{ int tmp ;

  {
  return ((struct cpumask *)(sd->span));
}
}
extern void partition_sched_domains(int ndoms_new , struct cpumask *doms_new , struct sched_domain_attr *dattr_new ) ;
__inline static int test_sd_parent(struct sched_domain *sd , int flag ) 
{ 

  {
  if (sd->parent) {
    if ((sd->parent)->flags & flag) {
      return (1);
    }
  }
  return (0);
}
}
__inline static int rt_prio(int prio ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! (prio < 100))), 0L);
  }
  if (tmp) {
    return (1);
  }
  return (0);
}
}
__inline static int rt_task(struct task_struct *p ) 
{ int tmp ;

  {
  {
  tmp = rt_prio(p->prio);
  }
  return (tmp);
}
}
__inline static struct pid *task_pid(struct task_struct *task ) 
{ 

  {
  return (task->pids[0].pid);
}
}
__inline static struct pid *task_tgid(struct task_struct *task ) 
{ 

  {
  return ((task->group_leader)->pids[0].pid);
}
}
__inline static struct pid *task_pgrp(struct task_struct *task ) 
{ 

  {
  return ((task->group_leader)->pids[1].pid);
}
}
__inline static struct pid *task_session(struct task_struct *task ) 
{ 

  {
  return ((task->group_leader)->pids[2].pid);
}
}
extern pid_t __task_pid_nr_ns(struct task_struct *task , enum pid_type type , struct pid_namespace *ns ) ;
__inline static pid_t task_pid_nr(struct task_struct *tsk ) 
{ 

  {
  return (tsk->pid);
}
}
__inline static pid_t task_pid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, ns);
  }
  return (tmp);
}
}
__inline static pid_t task_pid_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )0, (struct pid_namespace *)((void *)0));
  }
  return (tmp);
}
}
__inline static pid_t task_tgid_nr(struct task_struct *tsk ) 
{ 

  {
  return (tsk->tgid);
}
}
extern pid_t task_tgid_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) ;
__inline static pid_t task_tgid_vnr(struct task_struct *tsk ) 
{ struct pid *tmp ;
  pid_t tmp___0 ;

  {
  {
  tmp = task_tgid(tsk);
  tmp___0 = pid_vnr(tmp);
  }
  return (tmp___0);
}
}
__inline static pid_t task_pgrp_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, ns);
  }
  return (tmp);
}
}
__inline static pid_t task_pgrp_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )1, (struct pid_namespace *)((void *)0));
  }
  return (tmp);
}
}
__inline static pid_t task_session_nr_ns(struct task_struct *tsk , struct pid_namespace *ns ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, ns);
  }
  return (tmp);
}
}
__inline static pid_t task_session_vnr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = __task_pid_nr_ns(tsk, (enum pid_type )2, (struct pid_namespace *)((void *)0));
  }
  return (tmp);
}
}
__inline static pid_t task_pgrp_nr(struct task_struct *tsk ) 
{ pid_t tmp ;

  {
  {
  tmp = task_pgrp_nr_ns(tsk, & init_pid_ns);
  }
  return (tmp);
}
}
__inline static int pid_alive(struct task_struct *p ) 
{ 

  {
  return ((unsigned long )p->pids[0].pid != (unsigned long )((void *)0));
}
}
__inline static int is_global_init(struct task_struct *tsk ) 
{ 

  {
  return (tsk->pid == 1);
}
}
extern int is_container_init(struct task_struct *tsk ) ;
extern struct pid *cad_pid ;
extern void free_task(struct task_struct *tsk ) ;
extern void __put_task_struct(struct task_struct *t ) ;
__inline static void put_task_struct(struct task_struct *t ) 
{ int tmp ;

  {
  {
  tmp = atomic_dec_and_test(& t->usage);
  }
  if (tmp) {
    {
    __put_task_struct(t);
    }
  }
  return;
}
}
extern cputime_t task_utime(struct task_struct *p ) ;
extern cputime_t task_stime(struct task_struct *p ) ;
extern cputime_t task_gtime(struct task_struct *p ) ;
extern int set_cpus_allowed_ptr(struct task_struct *p , struct cpumask  const  *new_mask ) ;
__inline static int set_cpus_allowed(struct task_struct *p , cpumask_t new_mask ) 
{ int tmp ;

  {
  {
  tmp = set_cpus_allowed_ptr(p, (struct cpumask  const  *)(& new_mask));
  }
  return (tmp);
}
}
extern int sched_clock_stable ;
extern unsigned long long sched_clock(void) ;
extern void sched_clock_init(void) ;
extern u64 sched_clock_cpu(int cpu ) ;
extern void sched_clock_tick(void) ;
extern void sched_clock_idle_sleep_event(void) ;
extern void sched_clock_idle_wakeup_event(u64 delta_ns ) ;
extern unsigned long long cpu_clock(int cpu ) ;
extern unsigned long long task_sched_runtime(struct task_struct *task ) ;
extern unsigned long long thread_group_sched_runtime(struct task_struct *task ) ;
extern void sched_exec(void) ;
extern void idle_task_exit(void) ;
extern void sched_idle_next(void) ;
extern void wake_up_idle_cpu(int cpu ) ;
extern unsigned int sysctl_sched_latency ;
extern unsigned int sysctl_sched_min_granularity ;
extern unsigned int sysctl_sched_wakeup_granularity ;
extern unsigned int sysctl_sched_shares_ratelimit ;
extern unsigned int sysctl_sched_shares_thresh ;
extern unsigned int sysctl_sched_rt_period ;
extern int sysctl_sched_rt_runtime ;
extern int sched_rt_handler(struct ctl_table *table , int write , struct file *filp ,
                            void *buffer , size_t *lenp , loff_t *ppos ) ;
extern unsigned int sysctl_sched_compat_yield ;
extern int rt_mutex_getprio(struct task_struct *p ) ;
extern void rt_mutex_setprio(struct task_struct *p , int prio ) ;
extern void rt_mutex_adjust_pi(struct task_struct *p ) ;
extern void set_user_nice(struct task_struct *p , long nice ) ;
extern int task_prio(struct task_struct  const  *p ) ;
extern int task_nice(struct task_struct  const  *p ) ;
extern int can_nice(struct task_struct  const  *p , int nice ) ;
extern int task_curr(struct task_struct  const  *p ) ;
extern int idle_cpu(int cpu ) ;
extern int sched_setscheduler(struct task_struct * , int  , struct sched_param * ) ;
extern int sched_setscheduler_nocheck(struct task_struct * , int  , struct sched_param * ) ;
extern struct task_struct *idle_task(int cpu ) ;
extern struct task_struct *curr_task(int cpu ) ;
extern void set_curr_task(int cpu , struct task_struct *p ) ;
extern void yield(void) ;
extern struct exec_domain default_exec_domain ;
__inline static int kstack_end(void *addr ) 
{ 

  {
  return (! ((((unsigned long )addr + sizeof(void *)) - 1UL) & (((1UL << 12) << 1) - sizeof(void *))));
}
}
extern union thread_union init_thread_union ;
extern struct task_struct init_task ;
extern struct mm_struct init_mm ;
extern struct task_struct *find_task_by_pid_type_ns(int type , int pid , struct pid_namespace *ns ) ;
extern struct task_struct *find_task_by_vpid(pid_t nr ) ;
extern struct task_struct *find_task_by_pid_ns(pid_t nr , struct pid_namespace *ns ) ;
extern void __set_special_pids(struct pid *pid ) ;
extern struct user_struct *alloc_uid(struct user_namespace * , uid_t  ) ;
__inline static struct user_struct *get_uid(struct user_struct *u ) 
{ 

  {
  {
  atomic_inc(& u->__count);
  }
  return (u);
}
}
extern void free_uid(struct user_struct * ) ;
extern void release_uids(struct user_namespace *ns ) ;
extern void do_timer(unsigned long ticks ) ;
extern int wake_up_state(struct task_struct *tsk , unsigned int state ) ;
extern int wake_up_process(struct task_struct *tsk ) ;
extern void wake_up_new_task(struct task_struct *tsk , unsigned long clone_flags ) ;
extern void kick_process(struct task_struct *tsk ) ;
extern void sched_fork(struct task_struct *p , int clone_flags ) ;
extern void sched_dead(struct task_struct *p ) ;
extern void proc_caches_init(void) ;
extern void flush_signals(struct task_struct * ) ;
extern void ignore_signals(struct task_struct * ) ;
extern void flush_signal_handlers(struct task_struct * , int force_default ) ;
extern int dequeue_signal(struct task_struct *tsk , sigset_t *mask , siginfo_t *info ) ;
__inline static int dequeue_signal_lock(struct task_struct *tsk , sigset_t *mask ,
                                        siginfo_t *info ) 
{ unsigned long flags ;
  int ret ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_232_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& (tsk->sighand)->siglock);
    }
    goto while_232_break;
  }
  while_232_break: /* CIL Label */ ;
  }
  {
  ret = dequeue_signal(tsk, mask, info);
  }
  {
  while (1) {
    while_233_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, flags);
    }
    goto while_233_break;
  }
  while_233_break: /* CIL Label */ ;
  }
  return (ret);
}
}
extern void block_all_signals(int (*notifier)(void *priv ) , void *priv , sigset_t *mask ) ;
extern void unblock_all_signals(void) ;
extern void release_task(struct task_struct *p ) ;
extern int send_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int force_sigsegv(int  , struct task_struct * ) ;
extern int force_sig_info(int  , struct siginfo * , struct task_struct * ) ;
extern int __kill_pgrp_info(int sig , struct siginfo *info , struct pid *pgrp ) ;
extern int kill_pid_info(int sig , struct siginfo *info , struct pid *pid ) ;
extern int kill_pid_info_as_uid(int  , struct siginfo * , struct pid * , uid_t  ,
                                uid_t  , u32  ) ;
extern int kill_pgrp(struct pid *pid , int sig , int priv ) ;
extern int kill_pid(struct pid *pid , int sig , int priv ) ;
extern int kill_proc_info(int  , struct siginfo * , pid_t  ) ;
extern int do_notify_parent(struct task_struct * , int  ) ;
extern void force_sig(int  , struct task_struct * ) ;
extern void force_sig_specific(int  , struct task_struct * ) ;
extern int send_sig(int  , struct task_struct * , int  ) ;
extern void zap_other_threads(struct task_struct *p ) ;
extern struct sigqueue *sigqueue_alloc(void) ;
extern void sigqueue_free(struct sigqueue * ) ;
extern int send_sigqueue(struct sigqueue * , struct task_struct * , int group ) ;
extern int do_sigaction(int  , struct k_sigaction * , struct k_sigaction * ) ;
extern int do_sigaltstack(stack_t const   * , stack_t * , unsigned long  ) ;
__inline static int kill_cad_pid(int sig , int priv ) 
{ int tmp ;

  {
  {
  tmp = kill_pid(cad_pid, sig, priv);
  }
  return (tmp);
}
}
__inline static int is_si_special(struct siginfo  const  *info ) 
{ 

  {
  return ((unsigned long )info <= (unsigned long )((struct siginfo *)2));
}
}
__inline static int on_sig_stack(unsigned long sp ) 
{ struct task_struct *tmp ;
  struct task_struct *tmp___0 ;

  {
  {
  tmp = get_current();
  tmp___0 = get_current();
  }
  return (sp - tmp->sas_ss_sp < (unsigned long )tmp___0->sas_ss_size);
}
}
__inline static int sas_ss_flags(unsigned long sp ) 
{ struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct task_struct *tmp___4 ;

  {
  {
  tmp___4 = get_current();
  }
  if (tmp___4->sas_ss_size == 0U) {
    {
    tmp___3 = 2;
    }
  } else {
    {
    tmp___2 = on_sig_stack(sp);
    }
    if (tmp___2) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
    {
    tmp___3 = tmp___1;
    }
  }
  return (tmp___3);
}
}
extern struct mm_struct *mm_alloc(void) ;
extern void __mmdrop(struct mm_struct * ) ;
__inline static void mmdrop(struct mm_struct *mm ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = atomic_dec_and_test(& mm->mm_count);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  if (tmp___1) {
    {
    __mmdrop(mm);
    }
  }
  return;
}
}
extern void mmput(struct mm_struct * ) ;
extern struct mm_struct *get_task_mm(struct task_struct *task ) ;
extern void mm_release(struct task_struct * , struct mm_struct * ) ;
extern struct mm_struct *dup_mm(struct task_struct *tsk ) ;
extern int copy_thread(unsigned long  , unsigned long  , unsigned long  , struct task_struct * ,
                       struct pt_regs * ) ;
extern void flush_thread(void) ;
extern void exit_thread(void) ;
extern void exit_files(struct task_struct * ) ;
extern void __cleanup_signal(struct signal_struct * ) ;
extern void __cleanup_sighand(struct sighand_struct * ) ;
extern void exit_itimers(struct signal_struct * ) ;
extern void flush_itimer_signals(void) ;
extern void do_group_exit(int  ) ;
extern void daemonize(char const   *  , ...) ;
extern int allow_signal(int  ) ;
extern int disallow_signal(int  ) ;
extern int do_execve(char * , char ** , char ** , struct pt_regs * ) ;
extern long do_fork(unsigned long  , unsigned long  , struct pt_regs * , unsigned long  ,
                    int * , int * ) ;
extern struct task_struct *fork_idle(int  ) ;
extern void set_task_comm(struct task_struct *tsk , char *from ) ;
extern char *get_task_comm(char *to , struct task_struct *tsk ) ;
extern unsigned long wait_task_inactive(struct task_struct * , long match_state ) ;
extern bool is_single_threaded(struct task_struct * ) ;
__inline static int has_group_leader_pid(struct task_struct *p ) 
{ 

  {
  return (p->pid == p->tgid);
}
}
__inline static int same_thread_group(struct task_struct *p1 , struct task_struct *p2 ) 
{ 

  {
  return (p1->tgid == p2->tgid);
}
}
__inline static struct task_struct *next_thread(struct task_struct  const  *p ) 
{ struct list_head  const  *__mptr ;
  struct list_head *_________p1 ;

  {
  {
  _________p1 = (struct list_head *)*((struct list_head * const volatile  *)(& p->thread_group.next));
  }
  {
  while (1) {
    while_234_continue: /* CIL Label */ ;
    goto while_234_break;
  }
  while_234_break: /* CIL Label */ ;
  }
  {
  __mptr = (struct list_head  const  *)_________p1;
  }
  return ((struct task_struct *)((char *)__mptr - (unsigned int )(& ((struct task_struct *)0)->thread_group)));
}
}
__inline static int thread_group_empty(struct task_struct *p ) 
{ int tmp ;

  {
  {
  tmp = list_empty((struct list_head  const  *)(& p->thread_group));
  }
  return (tmp);
}
}
__inline static int task_detached(struct task_struct *p ) 
{ 

  {
  return (p->exit_signal == -1);
}
}
__inline static void task_lock(struct task_struct *p ) 
{ 

  {
  {
  _spin_lock(& p->alloc_lock);
  }
  return;
}
}
__inline static void task_unlock(struct task_struct *p ) 
{ 

  {
  {
  while (1) {
    while_235_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& p->alloc_lock.raw_lock);
    }
    goto while_235_break;
  }
  while_235_break: /* CIL Label */ ;
  }
  return;
}
}
extern struct sighand_struct *lock_task_sighand(struct task_struct *tsk , unsigned long *flags ) ;
__inline static void unlock_task_sighand(struct task_struct *tsk , unsigned long *flags ) 
{ unsigned long __dummy ;
  unsigned long __dummy2 ;

  {
  {
  while (1) {
    while_236_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& (tsk->sighand)->siglock, *flags);
    }
    goto while_236_break;
  }
  while_236_break: /* CIL Label */ ;
  }
  return;
}
}
__inline static void setup_thread_stack(struct task_struct *p , struct task_struct *org ) 
{ 

  {
  {
  *((struct thread_info *)p->stack) = *((struct thread_info *)org->stack);
  ((struct thread_info *)p->stack)->task = p;
  }
  return;
}
}
__inline static unsigned long *end_of_stack(struct task_struct *p ) 
{ 

  {
  return ((unsigned long *)((struct thread_info *)p->stack + 1));
}
}
__inline static int object_is_on_stack(void *obj ) 
{ void *stack ;
  struct task_struct *tmp ;
  int tmp___0 ;

  {
  {
  tmp = get_current();
  stack = tmp->stack;
  }
  if ((unsigned long )obj >= (unsigned long )stack) {
    if ((unsigned long )obj < (unsigned long )(stack + ((1UL << 12) << 1))) {
      {
      tmp___0 = 1;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
extern void thread_info_cache_init(void) ;
__inline static unsigned long stack_not_used(struct task_struct *p ) 
{ unsigned long *n ;
  unsigned long *tmp ;
  unsigned long *tmp___0 ;

  {
  {
  tmp = end_of_stack(p);
  n = tmp;
  }
  {
  while (1) {
    while_237_continue: /* CIL Label */ ;
    {
    n ++;
    }
    if (! (! *n)) {
      goto while_237_break;
    }
  }
  while_237_break: /* CIL Label */ ;
  }
  {
  tmp___0 = end_of_stack(p);
  }
  return ((unsigned long )n - (unsigned long )tmp___0);
}
}
__inline static void set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
  set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return;
}
}
__inline static void clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 

  {
  {
  clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return;
}
}
__inline static int test_and_set_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static int test_and_clear_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_and_clear_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ int tmp ;

  {
  {
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
  return (tmp);
}
}
__inline static void set_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
  set_tsk_thread_flag(tsk, 3);
  }
  return;
}
}
__inline static void clear_tsk_need_resched(struct task_struct *tsk ) 
{ 

  {
  {
  clear_tsk_thread_flag(tsk, 3);
  }
  return;
}
}
__inline static int test_tsk_need_resched(struct task_struct *tsk ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = test_tsk_thread_flag(tsk, 3);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  return ((int )tmp___1);
}
}
__inline static int signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
  tmp = test_tsk_thread_flag(p, 2);
  }
  if (tmp) {
    {
    tmp___0 = 1;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  {
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
  return ((int )tmp___1);
}
}
extern int __fatal_signal_pending(struct task_struct *p ) ;
__inline static int fatal_signal_pending(struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = signal_pending(p);
  }
  if (tmp) {
    {
    tmp___0 = __fatal_signal_pending(p);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  return (tmp___1);
}
}
__inline static int signal_pending_state(long state , struct task_struct *p ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! (state & 129L)) {
    return (0);
  }
  {
  tmp = signal_pending(p);
  }
  if (! tmp) {
    return (0);
  }
  if (state & 1L) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___0 = __fatal_signal_pending(p);
    }
    if (tmp___0) {
      {
      tmp___1 = 1;
      }
    } else {
      {
      tmp___1 = 0;
      }
    }
  }
  return (tmp___1);
}
}
__inline static int need_resched(void) 
{ struct thread_info *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
  tmp = current_thread_info();
  tmp___0 = test_ti_thread_flag(tmp, 3);
  }
  if (tmp___0) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
  return ((int )tmp___2);
}
}
__inline static int cond_resched(void) 
{ int tmp ;

  {
  {
  tmp = _cond_resched();
  }
  return (tmp);
}
}
extern int cond_resched_lock(spinlock_t *lock ) ;
extern int cond_resched_softirq(void) ;
__inline static int spin_needbreak(spinlock_t *lock ) 
{ 

  {
  return (0);
}
}
extern void thread_group_cputime(struct task_struct *tsk , struct task_cputime *times ) ;
extern void thread_group_cputimer(struct task_struct *tsk , struct task_cputime *times ) ;
__inline static void thread_group_cputime_init(struct signal_struct *sig ) 
{ struct task_cputime __constr_expr_0 ;
  spinlock_t __constr_expr_1 ;

  {
  {
  __constr_expr_0.utime = 0UL;
  __constr_expr_0.stime = 0UL;
  __constr_expr_0.sum_exec_runtime = 0ULL;
  sig->cputimer.cputime = __constr_expr_0;
  }
  {
  while (1) {
    while_238_continue: /* CIL Label */ ;
    {
    __constr_expr_1.raw_lock.slock = 0U;
    sig->cputimer.lock = __constr_expr_1;
    }
    goto while_238_break;
  }
  while_238_break: /* CIL Label */ ;
  }
  {
  sig->cputimer.running = 0;
  }
  return;
}
}
__inline static void thread_group_cputime_free(struct signal_struct *sig ) 
{ 

  {
  return;
}
}
extern void recalc_sigpending_and_wake(struct task_struct *t ) ;
extern void recalc_sigpending(void) ;
extern void signal_wake_up(struct task_struct *t , int resume_stopped ) ;
__inline static unsigned int task_cpu(struct task_struct  const  *p ) 
{ 

  {
  return (((struct thread_info *)p->stack)->cpu);
}
}
extern void set_task_cpu(struct task_struct *p , unsigned int cpu ) ;
extern void arch_pick_mmap_layout(struct mm_struct *mm ) ;
extern void __trace_special(void *__tr , void *__data , unsigned long arg1 , unsigned long arg2 ,
                            unsigned long arg3 ) ;
extern long sched_setaffinity(pid_t pid , struct cpumask  const  *new_mask ) ;
extern long sched_getaffinity(pid_t pid , struct cpumask *mask ) ;
extern void normalize_rt_tasks(void) ;
extern struct task_group init_task_group ;
extern struct task_group *sched_create_group(struct task_group *parent ) ;
extern void sched_destroy_group(struct task_group *tg ) ;
extern void sched_move_task(struct task_struct *tsk ) ;
extern int sched_group_set_shares(struct task_group *tg , unsigned long shares ) ;
extern unsigned long sched_group_shares(struct task_group *tg ) ;
extern int task_can_switch_user(struct user_struct *up , struct task_struct *tsk ) ;
__inline static void add_rchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
  tsk->ioac.rchar += (u64 )amt;
  }
  return;
}
}
__inline static void add_wchar(struct task_struct *tsk , ssize_t amt ) 
{ 

  {
  {
  tsk->ioac.wchar += (u64 )amt;
  }
  return;
}
}
__inline static void inc_syscr(struct task_struct *tsk ) 
{ 

  {
  {
  (tsk->ioac.syscr) ++;
  }
  return;
}
}
__inline static void inc_syscw(struct task_struct *tsk ) 
{ 

  {
  {
  (tsk->ioac.syscw) ++;
  }
  return;
}
}
__inline static void mm_update_next_owner(struct mm_struct *mm ) 
{ 

  {
  return;
}
}
__inline static void mm_init_owner(struct mm_struct *mm , struct task_struct *p ) 
{ 

  {
  return;
}
}
extern int fixup_exception(struct pt_regs *regs ) ;
extern int __get_user_1(void) ;
extern int __get_user_2(void) ;
extern int __get_user_4(void) ;
extern int __get_user_8(void) ;
extern int __get_user_bad(void) ;
extern void __put_user_bad(void) ;
extern void __put_user_1(void) ;
extern void __put_user_2(void) ;
extern void __put_user_4(void) ;
extern void __put_user_8(void) ;
extern struct movsl_mask movsl_mask ;
extern unsigned long __copy_to_user_ll(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll_nozero(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll_nocache(void *to , void const   *from , unsigned long n ) ;
extern unsigned long __copy_from_user_ll_nocache_nozero(void *to , void const   *from ,
                                                        unsigned long n ) ;
__inline static unsigned long __copy_to_user_inatomic(void *to , void const   *from ,
                                                      unsigned long n ) 
{ unsigned long ret ;
  unsigned long tmp ;

  {
  if (0) {
    if ((int )n == 1) {
      goto switch_239_1;
    } else {
      if ((int )n == 2) {
        goto switch_239_2;
      } else {
        if ((int )n == 4) {
          goto switch_239_4;
        } else {
          if (0) {
            switch_239_1: /* CIL Label */ 
            {
            while (1) {
              while_240_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_241_1;
              } else {
                if (1 == 2) {
                  goto switch_241_2;
                } else {
                  if (1 == 4) {
                    goto switch_241_4;
                  } else {
                    if (1 == 8) {
                      goto switch_241_8;
                    } else {
                      {
                      goto switch_241_default;
                      if (0) {
                        switch_241_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_241_break;
                        switch_241_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_241_break;
                        switch_241_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u8 *)from)),
                                             "m" (*((struct __large_struct *)((u8 *)to))),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_241_break;
                        switch_241_8: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u8 *)from)),
                                             "r" ((u8 *)to), "i" (1), "0" (ret));
                        }
                        goto switch_241_break;
                        switch_241_default: /* CIL Label */ 
                        {
                        __put_user_bad();
                        }
                      } else {
                        switch_241_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_240_break;
            }
            while_240_break: /* CIL Label */ ;
            }
            return (ret);
            switch_239_2: /* CIL Label */ 
            {
            while (1) {
              while_242_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_243_1;
              } else {
                if (2 == 2) {
                  goto switch_243_2;
                } else {
                  if (2 == 4) {
                    goto switch_243_4;
                  } else {
                    if (2 == 8) {
                      goto switch_243_8;
                    } else {
                      {
                      goto switch_243_default;
                      if (0) {
                        switch_243_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_243_break;
                        switch_243_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_243_break;
                        switch_243_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u16 *)from)),
                                             "m" (*((struct __large_struct *)((u16 *)to))),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_243_break;
                        switch_243_8: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u16 *)from)),
                                             "r" ((u16 *)to), "i" (2), "0" (ret));
                        }
                        goto switch_243_break;
                        switch_243_default: /* CIL Label */ 
                        {
                        __put_user_bad();
                        }
                      } else {
                        switch_243_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_242_break;
            }
            while_242_break: /* CIL Label */ ;
            }
            return (ret);
            switch_239_4: /* CIL Label */ 
            {
            while (1) {
              while_244_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_245_1;
              } else {
                if (4 == 2) {
                  goto switch_245_2;
                } else {
                  if (4 == 4) {
                    goto switch_245_4;
                  } else {
                    if (4 == 8) {
                      goto switch_245_8;
                    } else {
                      {
                      goto switch_245_default;
                      if (0) {
                        switch_245_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "iq" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_245_break;
                        switch_245_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_245_break;
                        switch_245_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%2\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "ir" (*((u32 *)from)),
                                             "m" (*((struct __large_struct *)((u32 *)to))),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_245_break;
                        switch_245_8: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmovl %%eax,0(%2)\n"
                                             "2:\tmovl %%edx,4(%2)\n"
                                             "3:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "4:\tmovl %3,%0\n"
                                             "\tjmp 3b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "2b"
                                             ","
                                             "4b"
                                             "\n"
                                             " .previous\n": "=r" (ret): "A" (*((u32 *)from)),
                                             "r" ((u32 *)to), "i" (4), "0" (ret));
                        }
                        goto switch_245_break;
                        switch_245_default: /* CIL Label */ 
                        {
                        __put_user_bad();
                        }
                      } else {
                        switch_245_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_244_break;
            }
            while_244_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_239_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp = __copy_to_user_ll(to, from, n);
  }
  return (tmp);
}
}
__inline static unsigned long __copy_to_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long tmp ;

  {
  {
  might_fault();
  tmp = __copy_to_user_inatomic(to, from, n);
  }
  return (tmp);
}
}
__inline static unsigned long __copy_from_user_inatomic(void *to , void const   *from ,
                                                        unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  if (0) {
    if ((int )n == 1) {
      goto switch_246_1;
    } else {
      if ((int )n == 2) {
        goto switch_246_2;
      } else {
        if ((int )n == 4) {
          goto switch_246_4;
        } else {
          if (0) {
            switch_246_1: /* CIL Label */ 
            {
            while (1) {
              while_247_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_248_1;
              } else {
                if (1 == 2) {
                  goto switch_248_2;
                } else {
                  if (1 == 4) {
                    goto switch_248_4;
                  } else {
                    if (1 == 8) {
                      goto switch_248_8;
                    } else {
                      {
                      goto switch_248_default;
                      if (0) {
                        switch_248_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_248_break;
                        switch_248_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_248_break;
                        switch_248_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_248_break;
                        switch_248_8: /* CIL Label */ 
                        {
                        tmp = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_248_break;
                        switch_248_default: /* CIL Label */ 
                        {
                        tmp___0 = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_248_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_247_break;
            }
            while_247_break: /* CIL Label */ ;
            }
            return (ret);
            switch_246_2: /* CIL Label */ 
            {
            while (1) {
              while_249_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_250_1;
              } else {
                if (2 == 2) {
                  goto switch_250_2;
                } else {
                  if (2 == 4) {
                    goto switch_250_4;
                  } else {
                    if (2 == 8) {
                      goto switch_250_8;
                    } else {
                      {
                      goto switch_250_default;
                      if (0) {
                        switch_250_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_250_break;
                        switch_250_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_250_break;
                        switch_250_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_250_break;
                        switch_250_8: /* CIL Label */ 
                        {
                        tmp___1 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_250_break;
                        switch_250_default: /* CIL Label */ 
                        {
                        tmp___2 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_250_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_249_break;
            }
            while_249_break: /* CIL Label */ ;
            }
            return (ret);
            switch_246_4: /* CIL Label */ 
            {
            while (1) {
              while_251_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_252_1;
              } else {
                if (4 == 2) {
                  goto switch_252_2;
                } else {
                  if (4 == 4) {
                    goto switch_252_4;
                  } else {
                    if (4 == 8) {
                      goto switch_252_8;
                    } else {
                      {
                      goto switch_252_default;
                      if (0) {
                        switch_252_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_252_break;
                        switch_252_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_252_break;
                        switch_252_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_252_break;
                        switch_252_8: /* CIL Label */ 
                        {
                        tmp___3 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_252_break;
                        switch_252_default: /* CIL Label */ 
                        {
                        tmp___4 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_252_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_251_break;
            }
            while_251_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_246_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp___5 = __copy_from_user_ll_nozero(to, from, n);
  }
  return (tmp___5);
}
}
__inline static unsigned long __copy_from_user(void *to , void const   *from , unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
  might_fault();
  }
  if (0) {
    if ((int )n == 1) {
      goto switch_253_1;
    } else {
      if ((int )n == 2) {
        goto switch_253_2;
      } else {
        if ((int )n == 4) {
          goto switch_253_4;
        } else {
          if (0) {
            switch_253_1: /* CIL Label */ 
            {
            while (1) {
              while_254_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_255_1;
              } else {
                if (1 == 2) {
                  goto switch_255_2;
                } else {
                  if (1 == 4) {
                    goto switch_255_4;
                  } else {
                    if (1 == 8) {
                      goto switch_255_8;
                    } else {
                      {
                      goto switch_255_default;
                      if (0) {
                        switch_255_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_255_break;
                        switch_255_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_255_break;
                        switch_255_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_255_break;
                        switch_255_8: /* CIL Label */ 
                        {
                        tmp = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_255_break;
                        switch_255_default: /* CIL Label */ 
                        {
                        tmp___0 = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_255_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_254_break;
            }
            while_254_break: /* CIL Label */ ;
            }
            return (ret);
            switch_253_2: /* CIL Label */ 
            {
            while (1) {
              while_256_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_257_1;
              } else {
                if (2 == 2) {
                  goto switch_257_2;
                } else {
                  if (2 == 4) {
                    goto switch_257_4;
                  } else {
                    if (2 == 8) {
                      goto switch_257_8;
                    } else {
                      {
                      goto switch_257_default;
                      if (0) {
                        switch_257_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_257_break;
                        switch_257_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_257_break;
                        switch_257_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_257_break;
                        switch_257_8: /* CIL Label */ 
                        {
                        tmp___1 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_257_break;
                        switch_257_default: /* CIL Label */ 
                        {
                        tmp___2 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_257_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_256_break;
            }
            while_256_break: /* CIL Label */ ;
            }
            return (ret);
            switch_253_4: /* CIL Label */ 
            {
            while (1) {
              while_258_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_259_1;
              } else {
                if (4 == 2) {
                  goto switch_259_2;
                } else {
                  if (4 == 4) {
                    goto switch_259_4;
                  } else {
                    if (4 == 8) {
                      goto switch_259_8;
                    } else {
                      {
                      goto switch_259_default;
                      if (0) {
                        switch_259_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_259_break;
                        switch_259_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_259_break;
                        switch_259_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_259_break;
                        switch_259_8: /* CIL Label */ 
                        {
                        tmp___3 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_259_break;
                        switch_259_default: /* CIL Label */ 
                        {
                        tmp___4 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_259_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_258_break;
            }
            while_258_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_253_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp___5 = __copy_from_user_ll(to, from, n);
  }
  return (tmp___5);
}
}
__inline static unsigned long __copy_from_user_nocache(void *to , void const   *from ,
                                                       unsigned long n ) 
{ unsigned long ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
  might_fault();
  }
  if (0) {
    if ((int )n == 1) {
      goto switch_260_1;
    } else {
      if ((int )n == 2) {
        goto switch_260_2;
      } else {
        if ((int )n == 4) {
          goto switch_260_4;
        } else {
          if (0) {
            switch_260_1: /* CIL Label */ 
            {
            while (1) {
              while_261_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (1 == 1) {
                goto switch_262_1;
              } else {
                if (1 == 2) {
                  goto switch_262_2;
                } else {
                  if (1 == 4) {
                    goto switch_262_4;
                  } else {
                    if (1 == 8) {
                      goto switch_262_8;
                    } else {
                      {
                      goto switch_262_default;
                      if (0) {
                        switch_262_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_262_break;
                        switch_262_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_262_break;
                        switch_262_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u8 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (1), "0" (ret));
                        }
                        goto switch_262_break;
                        switch_262_8: /* CIL Label */ 
                        {
                        tmp = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp;
                        }
                        goto switch_262_break;
                        switch_262_default: /* CIL Label */ 
                        {
                        tmp___0 = __get_user_bad();
                        *((u8 *)to) = (unsigned char )tmp___0;
                        }
                      } else {
                        switch_262_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_261_break;
            }
            while_261_break: /* CIL Label */ ;
            }
            return (ret);
            switch_260_2: /* CIL Label */ 
            {
            while (1) {
              while_263_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (2 == 1) {
                goto switch_264_1;
              } else {
                if (2 == 2) {
                  goto switch_264_2;
                } else {
                  if (2 == 4) {
                    goto switch_264_4;
                  } else {
                    if (2 == 8) {
                      goto switch_264_8;
                    } else {
                      {
                      goto switch_264_default;
                      if (0) {
                        switch_264_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_264_break;
                        switch_264_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_264_break;
                        switch_264_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u16 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (2), "0" (ret));
                        }
                        goto switch_264_break;
                        switch_264_8: /* CIL Label */ 
                        {
                        tmp___1 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___1;
                        }
                        goto switch_264_break;
                        switch_264_default: /* CIL Label */ 
                        {
                        tmp___2 = __get_user_bad();
                        *((u16 *)to) = (unsigned short )tmp___2;
                        }
                      } else {
                        switch_264_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_263_break;
            }
            while_263_break: /* CIL Label */ ;
            }
            return (ret);
            switch_260_4: /* CIL Label */ 
            {
            while (1) {
              while_265_continue: /* CIL Label */ ;
              {
              ret = 0UL;
              }
              if (4 == 1) {
                goto switch_266_1;
              } else {
                if (4 == 2) {
                  goto switch_266_2;
                } else {
                  if (4 == 4) {
                    goto switch_266_4;
                  } else {
                    if (4 == 8) {
                      goto switch_266_8;
                    } else {
                      {
                      goto switch_266_default;
                      if (0) {
                        switch_266_1: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "b"
                                             " %2,%"
                                             "b"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "b"
                                             " %"
                                             "b"
                                             "1,%"
                                             "b"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=q" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_266_break;
                        switch_266_2: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "w"
                                             " %2,%"
                                             "w"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "w"
                                             " %"
                                             "w"
                                             "1,%"
                                             "w"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_266_break;
                        switch_266_4: /* CIL Label */ 
                        {
                        __asm__  volatile   ("1:\tmov"
                                             "l"
                                             " %2,%"
                                             "k"
                                             "1\n"
                                             "2:\n"
                                             ".section .fixup,\"ax\"\n"
                                             "3:\tmov %3,%0\n"
                                             "\txor"
                                             "l"
                                             " %"
                                             "k"
                                             "1,%"
                                             "k"
                                             "1\n"
                                             "\tjmp 2b\n"
                                             ".previous\n"
                                             " .section __ex_table,\"a\"\n"
                                             " "
                                             ".balign 4"
                                             " "
                                             "\n"
                                             " "
                                             ".long"
                                             " "
                                             "1b"
                                             ","
                                             "3b"
                                             "\n"
                                             " .previous\n": "=r" (ret), "=r" (*((u32 *)to)): "m" (*((struct __large_struct *)from)),
                                             "i" (4), "0" (ret));
                        }
                        goto switch_266_break;
                        switch_266_8: /* CIL Label */ 
                        {
                        tmp___3 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___3;
                        }
                        goto switch_266_break;
                        switch_266_default: /* CIL Label */ 
                        {
                        tmp___4 = __get_user_bad();
                        *((u32 *)to) = (unsigned int )tmp___4;
                        }
                      } else {
                        switch_266_break: /* CIL Label */ ;
                      }
                      }
                    }
                  }
                }
              }
              goto while_265_break;
            }
            while_265_break: /* CIL Label */ ;
            }
            return (ret);
          } else {
            switch_260_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  tmp___5 = __copy_from_user_ll_nocache(to, from, n);
  }
  return (tmp___5);
}
}
__inline static unsigned long __copy_from_user_inatomic_nocache(void *to , void const   *from ,
                                                                unsigned long n ) 
{ unsigned long tmp ;

  {
  {
  tmp = __copy_from_user_ll_nocache_nozero(to, from, n);
  }
  return (tmp);
}
}
extern unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
extern unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) ;
extern long strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long __strncpy_from_user(char *dst , char const   *src , long count ) ;
extern long strnlen_user(char const   *str , long n ) ;
extern unsigned long clear_user(void *mem , unsigned long len ) ;
extern unsigned long __clear_user(void *mem , unsigned long len ) ;
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 

  {
  if (p) {
    if (wait_address) {
      {
      (*(p->qproc))(filp, wait_address, p);
      }
    }
  }
  return;
}
}
__inline static void init_poll_funcptr(poll_table *pt , void (*qproc)(struct file * ,
                                                                      wait_queue_head_t * ,
                                                                      struct poll_table_struct * ) ) 
{ 

  {
  {
  pt->qproc = qproc;
  }
  return;
}
}
extern void poll_initwait(struct poll_wqueues *pwq ) ;
extern void poll_freewait(struct poll_wqueues *pwq ) ;
extern int poll_schedule_timeout(struct poll_wqueues *pwq , int state , ktime_t *expires ,
                                 unsigned long slack ) ;
__inline static int poll_schedule(struct poll_wqueues *pwq , int state ) 
{ int tmp ;

  {
  {
  tmp = poll_schedule_timeout(pwq, state, (ktime_t *)((void *)0), 0UL);
  }
  return (tmp);
}
}
__inline static int get_fd_set(unsigned long nr , void *ufdset , unsigned long *fdset ) 
{ unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  nr = (((nr + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long );
  }
  if (ufdset) {
    {
    tmp___1 = copy_from_user((void *)fdset, (void const   *)ufdset, nr);
    }
    if (tmp___1) {
      {
      tmp___0 = -14;
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
    return (tmp___0);
  }
  {
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )nr);
  }
  return (0);
}
}
__inline static unsigned long set_fd_set(unsigned long nr , void *ufdset , unsigned long *fdset ) 
{ unsigned long tmp ;

  {
  if (ufdset) {
    {
    tmp = __copy_to_user(ufdset, (void const   *)fdset, (((nr + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long ));
    }
    return (tmp);
  }
  return (0UL);
}
}
__inline static void zero_fd_set(unsigned long nr , unsigned long *fdset ) 
{ 

  {
  {
  __constant_c_memset((void *)fdset, 0UL, (unsigned int )((((nr + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) * sizeof(long )));
  }
  return;
}
}
extern int do_select(int n , fd_set_bits *fds , struct timespec *end_time ) ;
extern int do_sys_poll(struct pollfd *ufds , unsigned int nfds , struct timespec *end_time ) ;
extern int core_sys_select(int n , fd_set *inp , fd_set *outp , fd_set *exp , struct timespec *end_time ) ;
extern int poll_select_set_timeout(struct timespec *to , long sec , long nsec ) ;
__inline static void client_get(struct client *client ) 
{ 

  {
  {
  kref_get(& client->kref);
  }
  return;
}
}
static void client_release(struct kref *kref ) 
{ struct client *client ;
  struct kref  const  *__mptr ;

  {
  {
  __mptr = (struct kref  const  *)kref;
  client = (struct client *)((char *)__mptr - (unsigned int )(& ((struct client *)0)->kref));
  fw_device_put(client->device);
  kfree((void const   *)client);
  }
  return;
}
}
static void client_put(struct client *client ) 
{ 

  {
  {
  kref_put(& client->kref, & client_release);
  }
  return;
}
}
static void schedule_iso_resource(struct iso_resource *r ) ;
static void release_iso_resource(struct client *client , struct client_resource *resource ) ;
__inline static void *u64_to_uptr(__u64 value ) 
{ 

  {
  return ((void *)((unsigned long )value));
}
}
__inline static __u64 uptr_to_u64(void *ptr ) 
{ 

  {
  return ((unsigned long long )((unsigned long )ptr));
}
}
static int fw_device_op_open(struct inode *inode , struct file *file ) 
{ struct fw_device *device ;
  struct client *client ;
  int tmp ;
  void *tmp___0 ;
  spinlock_t __constr_expr_0 ;

  {
  {
  device = fw_device_get_by_devt(inode->i_rdev);
  }
  if ((unsigned long )device == (unsigned long )((void *)0)) {
    return (-19);
  }
  {
  tmp = fw_device_is_shutdown(device);
  }
  if (tmp) {
    {
    fw_device_put(device);
    }
    return (-19);
  }
  {
  tmp___0 = kzalloc((unsigned int )sizeof(*client), 208U);
  client = (struct client *)tmp___0;
  }
  if ((unsigned long )client == (unsigned long )((void *)0)) {
    {
    fw_device_put(device);
    }
    return (-12);
  }
  {
  client->device = device;
  }
  {
  while (1) {
    while_267_continue: /* CIL Label */ ;
    {
    __constr_expr_0.raw_lock.slock = 0U;
    client->lock = __constr_expr_0;
    }
    goto while_267_break;
  }
  while_267_break: /* CIL Label */ ;
  }
  {
  idr_init(& client->resource_idr);
  INIT_LIST_HEAD(& client->event_list);
  init_waitqueue_head(& client->wait);
  kref_init(& client->kref);
  file->private_data = (void *)client;
  mutex_lock(& device->client_list_mutex);
  list_add_tail(& client->link, & device->client_list);
  mutex_unlock(& device->client_list_mutex);
  }
  return (0);
}
}
static void queue_event(struct client *client , struct event *event , void *data0 ,
                        size_t size0 , void *data1 , size_t size1 ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  event->v[0].data = data0;
  event->v[0].size = size0;
  event->v[1].data = data1;
  event->v[1].size = size1;
  }
  {
  while (1) {
    while_268_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& client->lock);
    }
    goto while_268_break;
  }
  while_268_break: /* CIL Label */ ;
  }
  if (client->in_shutdown) {
    {
    kfree((void const   *)event);
    }
  } else {
    {
    list_add_tail(& event->link, & client->event_list);
    }
  }
  {
  while (1) {
    while_269_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& client->lock, flags);
    }
    goto while_269_break;
  }
  while_269_break: /* CIL Label */ ;
  }
  {
  __wake_up(& client->wait, 1U, 1, (void *)0);
  }
  return;
}
}
static int dequeue_event(struct client *client , char *buffer , size_t count ) 
{ struct event *event ;
  size_t size ;
  size_t total ;
  int i ;
  int ret ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct list_head  const  *__mptr ;
  size_t _min1 ;
  size_t _min2 ;
  size_t tmp___8 ;
  unsigned long tmp___9 ;

  {
  {
  __ret = 0;
  tmp___4 = list_empty((struct list_head  const  *)(& client->event_list));
  }
  if (tmp___4) {
    {
    tmp___5 = fw_device_is_shutdown(client->device);
    }
    if (! tmp___5) {
      {
      while (1) {
        while_270_continue: /* CIL Label */ ;
        {
        tmp = get_current();
        __wait.flags = 0U;
        __wait.private = (void *)tmp;
        __wait.func = & autoremove_wake_function;
        __wait.task_list.next = & __wait.task_list;
        __wait.task_list.prev = & __wait.task_list;
        }
        {
        while (1) {
          while_271_continue: /* CIL Label */ ;
          {
          prepare_to_wait(& client->wait, & __wait, 1);
          tmp___0 = list_empty((struct list_head  const  *)(& client->event_list));
          }
          if (tmp___0) {
            {
            tmp___1 = fw_device_is_shutdown(client->device);
            }
            if (tmp___1) {
              goto while_271_break;
            }
          } else {
            goto while_271_break;
          }
          {
          tmp___2 = get_current();
          tmp___3 = signal_pending(tmp___2);
          }
          if (! tmp___3) {
            {
            schedule();
            }
            goto __Cont;
          }
          {
          __ret = -512;
          }
          goto while_271_break;
          __Cont: /* CIL Label */ 
          {

          }
        }
        while_271_break: /* CIL Label */ ;
        }
        {
        finish_wait(& client->wait, & __wait);
        }
        goto while_270_break;
      }
      while_270_break: /* CIL Label */ ;
      }
    }
  }
  {
  ret = __ret;
  }
  if (ret < 0) {
    return (ret);
  }
  {
  tmp___6 = list_empty((struct list_head  const  *)(& client->event_list));
  }
  if (tmp___6) {
    {
    tmp___7 = fw_device_is_shutdown(client->device);
    }
    if (tmp___7) {
      return (-19);
    }
  }
  {
  _spin_lock_irq(& client->lock);
  __mptr = (struct list_head  const  *)client->event_list.next;
  event = (struct event *)((char *)__mptr - (unsigned int )(& ((struct event *)0)->link));
  list_del(& event->link);
  }
  {
  while (1) {
    while_272_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& client->lock.raw_lock);
    }
    {
    while (1) {
      while_273_continue: /* CIL Label */ ;
      {
      while (1) {
        while_274_continue: /* CIL Label */ ;
        goto while_274_break;
      }
      while_274_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_273_break;
    }
    while_273_break: /* CIL Label */ ;
    }
    goto while_272_break;
  }
  while_272_break: /* CIL Label */ ;
  }
  {
  total = 0U;
  i = 0;
  }
  {
  while (1) {
    while_275_continue: /* CIL Label */ ;
    if ((unsigned long )i < sizeof(event->v) / sizeof(event->v[0])) {
      if (! (total < count)) {
        goto while_275_break;
      }
    } else {
      goto while_275_break;
    }
    {
    _min1 = event->v[i].size;
    _min2 = count - total;
    }
    if (_min1 < _min2) {
      {
      tmp___8 = _min1;
      }
    } else {
      {
      tmp___8 = _min2;
      }
    }
    {
    size = tmp___8;
    tmp___9 = copy_to_user((void *)(buffer + total), (void const   *)event->v[i].data,
                           (unsigned long )size);
    }
    if (tmp___9) {
      {
      ret = -14;
      }
      goto out;
    }
    {
    total += size;
    i ++;
    }
  }
  while_275_break: /* CIL Label */ ;
  }
  {
  ret = (int )total;
  }
  out: 
  {
  kfree((void const   *)event);
  }
  return (ret);
}
}
static ssize_t fw_device_op_read(struct file *file , char *buffer , size_t count ,
                                 loff_t *offset ) 
{ struct client *client ;
  int tmp ;

  {
  {
  client = (struct client *)file->private_data;
  tmp = dequeue_event(client, buffer, count);
  }
  return (tmp);
}
}
static void fill_bus_reset_event(struct fw_cdev_event_bus_reset *event , struct client *client ) 
{ struct fw_card *card ;

  {
  {
  card = (client->device)->card;
  _spin_lock_irq(& card->lock);
  event->closure = client->bus_reset_closure;
  event->type = 0U;
  event->generation = (unsigned int )(client->device)->generation;
  event->node_id = (unsigned int )(client->device)->node_id;
  event->local_node_id = (unsigned int )(card->local_node)->node_id;
  event->bm_node_id = 0U;
  event->irm_node_id = (unsigned int )(card->irm_node)->node_id;
  event->root_node_id = (unsigned int )(card->root_node)->node_id;
  }
  {
  while (1) {
    while_276_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& card->lock.raw_lock);
    }
    {
    while (1) {
      while_277_continue: /* CIL Label */ ;
      {
      while (1) {
        while_278_continue: /* CIL Label */ ;
        goto while_278_break;
      }
      while_278_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_277_break;
    }
    while_277_break: /* CIL Label */ ;
    }
    goto while_276_break;
  }
  while_276_break: /* CIL Label */ ;
  }
  return;
}
}
static void for_each_client(struct fw_device *device , void (*callback)(struct client *client ) ) 
{ struct client *c ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  mutex_lock(& device->client_list_mutex);
  __mptr = (struct list_head  const  *)device->client_list.next;
  c = (struct client *)((char *)__mptr - (unsigned int )(& ((struct client *)0)->link));
  }
  {
  while (1) {
    while_279_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)c->link.next);
    }
    if (! ((unsigned long )(& c->link) != (unsigned long )(& device->client_list))) {
      goto while_279_break;
    }
    {
    (*callback)(c);
    __mptr___0 = (struct list_head  const  *)c->link.next;
    c = (struct client *)((char *)__mptr___0 - (unsigned int )(& ((struct client *)0)->link));
    }
  }
  while_279_break: /* CIL Label */ ;
  }
  {
  mutex_unlock(& device->client_list_mutex);
  }
  return;
}
}
static int schedule_reallocations(int id , void *p , void *data ) 
{ struct client_resource *r ;
  struct client_resource  const  *__mptr ;

  {
  {
  r = (struct client_resource *)p;
  }
  if ((unsigned long )r->release == (unsigned long )(& release_iso_resource)) {
    {
    __mptr = (struct client_resource  const  *)r;
    schedule_iso_resource((struct iso_resource *)((char *)__mptr - (unsigned int )(& ((struct iso_resource *)0)->resource)));
    }
  }
  return (0);
}
}
static void queue_bus_reset_event(struct client *client ) 
{ struct bus_reset_event *e ;
  void *tmp ;

  {
  {
  tmp = kzalloc((unsigned int )sizeof(*e), 208U);
  e = (struct bus_reset_event *)tmp;
  }
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
    printk("<5>SomeModule: Out of memory when allocating bus reset event\n");
    }
    return;
  }
  {
  fill_bus_reset_event(& e->reset, client);
  queue_event(client, & e->event, (void *)(& e->reset), (unsigned int )sizeof(e->reset),
              (void *)0, 0U);
  _spin_lock_irq(& client->lock);
  idr_for_each(& client->resource_idr, & schedule_reallocations, (void *)client);
  }
  {
  while (1) {
    while_280_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& client->lock.raw_lock);
    }
    {
    while (1) {
      while_281_continue: /* CIL Label */ ;
      {
      while (1) {
        while_282_continue: /* CIL Label */ ;
        goto while_282_break;
      }
      while_282_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_281_break;
    }
    while_281_break: /* CIL Label */ ;
    }
    goto while_280_break;
  }
  while_280_break: /* CIL Label */ ;
  }
  return;
}
}
void fw_device_cdev_update(struct fw_device *device ) 
{ 

  {
  {
  for_each_client(device, & queue_bus_reset_event);
  }
  return;
}
}
static void wake_up_client(struct client *client ) 
{ 

  {
  {
  __wake_up(& client->wait, 1U, 1, (void *)0);
  }
  return;
}
}
void fw_device_cdev_remove(struct fw_device *device ) 
{ 

  {
  {
  for_each_client(device, & wake_up_client);
  }
  return;
}
}
static int ioctl_get_info(struct client *client , void *buffer ) 
{ struct fw_cdev_get_info *get_info ;
  struct fw_cdev_event_bus_reset bus_reset ;
  unsigned long ret ;
  void *uptr ;
  void *tmp ;
  size_t want ;
  size_t have ;
  size_t _min1 ;
  size_t _min2 ;
  size_t tmp___0 ;
  void *uptr___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
  get_info = (struct fw_cdev_get_info *)buffer;
  ret = 0UL;
  client->version = get_info->version;
  get_info->version = 2U;
  get_info->card = (unsigned int )((client->device)->card)->index;
  down_read(& fw_device_rwsem);
  }
  if (get_info->rom != 0ULL) {
    {
    tmp = u64_to_uptr(get_info->rom);
    uptr = tmp;
    want = get_info->rom_length;
    have = (client->device)->config_rom_length * 4U;
    _min1 = want;
    _min2 = have;
    }
    if (_min1 < _min2) {
      {
      tmp___0 = _min1;
      }
    } else {
      {
      tmp___0 = _min2;
      }
    }
    {
    ret = copy_to_user(uptr, (void const   *)(client->device)->config_rom, (unsigned long )tmp___0);
    }
  }
  {
  get_info->rom_length = (client->device)->config_rom_length * 4U;
  up_read(& fw_device_rwsem);
  }
  if (ret != 0UL) {
    return (-14);
  }
  {
  client->bus_reset_closure = get_info->bus_reset_closure;
  }
  if (get_info->bus_reset != 0ULL) {
    {
    tmp___1 = u64_to_uptr(get_info->bus_reset);
    uptr___0 = tmp___1;
    fill_bus_reset_event(& bus_reset, client);
    tmp___2 = copy_to_user(uptr___0, (void const   *)(& bus_reset), sizeof(bus_reset));
    }
    if (tmp___2) {
      return (-14);
    }
  }
  return (0);
}
}
static int add_client_resource(struct client *client , struct client_resource *resource ,
                               gfp_t gfp_mask ) 
{ unsigned long flags ;
  int ret ;
  int tmp ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct client_resource  const  *__mptr ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp___0 ;

  {
  retry: 
  {
  tmp = idr_pre_get(& client->resource_idr, gfp_mask);
  }
  if (tmp == 0) {
    return (-12);
  }
  {
  while (1) {
    while_283_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& client->lock);
    }
    goto while_283_break;
  }
  while_283_break: /* CIL Label */ ;
  }
  if (client->in_shutdown) {
    {
    ret = -125;
    }
  } else {
    {
    ret = idr_get_new(& client->resource_idr, (void *)resource, & resource->handle);
    }
  }
  if (ret >= 0) {
    {
    client_get(client);
    }
    if ((unsigned long )resource->release == (unsigned long )(& release_iso_resource)) {
      {
      __mptr = (struct client_resource  const  *)resource;
      schedule_iso_resource((struct iso_resource *)((char *)__mptr - (unsigned int )(& ((struct iso_resource *)0)->resource)));
      }
    }
  }
  {
  while (1) {
    while_284_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& client->lock, flags);
    }
    goto while_284_break;
  }
  while_284_break: /* CIL Label */ ;
  }
  if (ret == -11) {
    goto retry;
  }
  if (ret < 0) {
    {
    tmp___0 = ret;
    }
  } else {
    {
    tmp___0 = 0;
    }
  }
  return (tmp___0);
}
}
static int release_client_resource(struct client *client , u32 handle , void (*release)(struct client * ,
                                                                                        struct client_resource * ) ,
                                   struct client_resource **resource ) 
{ struct client_resource *r ;
  void *tmp ;

  {
  {
  _spin_lock_irq(& client->lock);
  }
  if (client->in_shutdown) {
    {
    r = (struct client_resource *)((void *)0);
    }
  } else {
    {
    tmp = idr_find(& client->resource_idr, (int )handle);
    r = (struct client_resource *)tmp;
    }
  }
  if (r) {
    if ((unsigned long )r->release == (unsigned long )release) {
      {
      idr_remove(& client->resource_idr, (int )handle);
      }
    }
  }
  {
  while (1) {
    while_285_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& client->lock.raw_lock);
    }
    {
    while (1) {
      while_286_continue: /* CIL Label */ ;
      {
      while (1) {
        while_287_continue: /* CIL Label */ ;
        goto while_287_break;
      }
      while_287_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_286_break;
    }
    while_286_break: /* CIL Label */ ;
    }
    goto while_285_break;
  }
  while_285_break: /* CIL Label */ ;
  }
  if (r) {
    if (! ((unsigned long )r->release == (unsigned long )release)) {
      return (-22);
    }
  } else {
    return (-22);
  }
  if (resource) {
    {
    *resource = r;
    }
  } else {
    {
    (*(r->release))(client, r);
    }
  }
  {
  client_put(client);
  }
  return (0);
}
}
static void release_transaction(struct client *client , struct client_resource *resource ) 
{ struct outbound_transaction_resource *r ;
  struct client_resource  const  *__mptr ;

  {
  {
  __mptr = (struct client_resource  const  *)resource;
  r = (struct outbound_transaction_resource *)((char *)__mptr - (unsigned int )(& ((struct outbound_transaction_resource *)0)->resource));
  fw_cancel_transaction((client->device)->card, & r->transaction);
  }
  return;
}
}
static void complete_transaction(struct fw_card *card , int rcode , void *payload ,
                                 size_t length , void *data ) 
{ struct outbound_transaction_event *e ;
  struct fw_cdev_event_response *rsp ;
  struct client *client ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  void *tmp ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  e = (struct outbound_transaction_event *)data;
  rsp = & e->response;
  client = e->client;
  }
  if (length < rsp->length) {
    {
    rsp->length = length;
    }
  }
  if (rcode == 0) {
    {
    __memcpy((void *)(rsp->data), (void const   *)payload, rsp->length);
    }
  }
  {
  while (1) {
    while_288_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& client->lock);
    }
    goto while_288_break;
  }
  while_288_break: /* CIL Label */ ;
  }
  if (! client->in_shutdown) {
    {
    tmp = idr_find(& client->resource_idr, e->r.resource.handle);
    }
    if (tmp) {
      {
      idr_remove(& client->resource_idr, e->r.resource.handle);
      client_put(client);
      }
    }
  }
  {
  while (1) {
    while_289_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& client->lock, flags);
    }
    goto while_289_break;
  }
  while_289_break: /* CIL Label */ ;
  }
  {
  rsp->type = 1U;
  rsp->rcode = (unsigned int )rcode;
  }
  if ((unsigned long )rsp->length <= sizeof(*rsp) - (unsigned long )((unsigned int )(& ((struct fw_cdev_event_response *)0)->data))) {
    {
    queue_event(client, & e->event, (void *)rsp, (unsigned int )sizeof(*rsp), (void *)(rsp->data),
                rsp->length);
    }
  } else {
    {
    queue_event(client, & e->event, (void *)rsp, (unsigned int )(sizeof(*rsp) + (unsigned long )rsp->length),
                (void *)0, 0U);
    }
  }
  {
  client_put(client);
  }
  return;
}
}
static int init_request(struct client *client , struct fw_cdev_send_request *request ,
                        int destination_id , int speed ) 
{ struct outbound_transaction_event *e ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;

  {
  if (request->tcode != 10U) {
    if (request->length > 4096U) {
      return (-5);
    } else {
      if (request->length > (__u32 )(512 << speed)) {
        return (-5);
      }
    }
  }
  {
  tmp = kmalloc((unsigned int )(sizeof(*e) + (unsigned long )request->length), 208U);
  e = (struct outbound_transaction_event *)tmp;
  }
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  e->client = client;
  e->response.length = request->length;
  e->response.closure = request->closure;
  }
  if (request->data) {
    {
    tmp___0 = u64_to_uptr(request->data);
    tmp___1 = copy_from_user((void *)(e->response.data), (void const   *)tmp___0,
                             (unsigned long )request->length);
    }
    if (tmp___1) {
      {
      ret = -14;
      }
      goto failed;
    }
  }
  {
  e->r.resource.release = & release_transaction;
  ret = add_client_resource(client, & e->r.resource, 208U);
  }
  if (ret < 0) {
    goto failed;
  }
  {
  client_get(client);
  fw_send_request((client->device)->card, & e->r.transaction, (int )request->tcode,
                  destination_id, (int )request->generation, speed, request->offset,
                  (void *)(e->response.data), request->length, & complete_transaction,
                  (void *)e);
  }
  return (0);
  failed: 
  {
  kfree((void const   *)e);
  }
  return (ret);
}
}
static int ioctl_send_request(struct client *client , void *buffer ) 
{ struct fw_cdev_send_request *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_send_request *)buffer;
  }
  if ((int )request->tcode == 0) {
    goto switch_290_0;
  } else {
    if ((int )request->tcode == 1) {
      goto switch_290_0;
    } else {
      if ((int )request->tcode == 4) {
        goto switch_290_0;
      } else {
        if ((int )request->tcode == 5) {
          goto switch_290_0;
        } else {
          if ((int )request->tcode == 17) {
            goto switch_290_0;
          } else {
            if ((int )request->tcode == 18) {
              goto switch_290_0;
            } else {
              if ((int )request->tcode == 19) {
                goto switch_290_0;
              } else {
                if ((int )request->tcode == 20) {
                  goto switch_290_0;
                } else {
                  if ((int )request->tcode == 21) {
                    goto switch_290_0;
                  } else {
                    if ((int )request->tcode == 22) {
                      goto switch_290_0;
                    } else {
                      if ((int )request->tcode == 23) {
                        goto switch_290_0;
                      } else {
                        {
                        goto switch_290_default;
                        if (0) {
                          switch_290_0: /* CIL Label */ 
                          switch_290_1: /* CIL Label */ 
                          switch_290_4: /* CIL Label */ 
                          switch_290_5: /* CIL Label */ 
                          switch_290_17: /* CIL Label */ 
                          switch_290_18: /* CIL Label */ 
                          switch_290_19: /* CIL Label */ 
                          switch_290_20: /* CIL Label */ 
                          switch_290_21: /* CIL Label */ 
                          switch_290_22: /* CIL Label */ 
                          switch_290_23: /* CIL Label */ 
                          goto switch_290_break;
                          switch_290_default: /* CIL Label */ 
                          {

                          }
                          return (-22);
                        } else {
                          switch_290_break: /* CIL Label */ ;
                        }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
  tmp = init_request(client, request, (client->device)->node_id, (int )(client->device)->max_speed);
  }
  return (tmp);
}
}
static void release_request(struct client *client , struct client_resource *resource ) 
{ struct inbound_transaction_resource *r ;
  struct client_resource  const  *__mptr ;

  {
  {
  __mptr = (struct client_resource  const  *)resource;
  r = (struct inbound_transaction_resource *)((char *)__mptr - (unsigned int )(& ((struct inbound_transaction_resource *)0)->resource));
  fw_send_response((client->device)->card, r->request, 4);
  kfree((void const   *)r);
  }
  return;
}
}
static void handle_request(struct fw_card *card , struct fw_request *request , int tcode ,
                           int destination , int source , int generation , int speed ,
                           unsigned long long offset , void *payload , size_t length ,
                           void *callback_data ) 
{ struct address_handler_resource *handler ;
  struct inbound_transaction_resource *r ;
  struct inbound_transaction_event *e ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  handler = (struct address_handler_resource *)callback_data;
  tmp = kmalloc((unsigned int )sizeof(*r), 32U);
  r = (struct inbound_transaction_resource *)tmp;
  tmp___0 = kmalloc((unsigned int )sizeof(*e), 32U);
  e = (struct inbound_transaction_event *)tmp___0;
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    goto failed;
  } else {
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      goto failed;
    }
  }
  {
  r->request = request;
  r->data = payload;
  r->length = length;
  r->resource.release = & release_request;
  ret = add_client_resource(handler->client, & r->resource, 32U);
  }
  if (ret < 0) {
    goto failed;
  }
  {
  e->request.type = 2U;
  e->request.tcode = (unsigned int )tcode;
  e->request.offset = offset;
  e->request.length = length;
  e->request.handle = (unsigned int )r->resource.handle;
  e->request.closure = handler->closure;
  queue_event(handler->client, & e->event, (void *)(& e->request), (unsigned int )sizeof(e->request),
              payload, length);
  }
  return;
  failed: 
  {
  kfree((void const   *)r);
  kfree((void const   *)e);
  fw_send_response(card, request, 4);
  }
  return;
}
}
static void release_address_handler(struct client *client , struct client_resource *resource ) 
{ struct address_handler_resource *r ;
  struct client_resource  const  *__mptr ;

  {
  {
  __mptr = (struct client_resource  const  *)resource;
  r = (struct address_handler_resource *)((char *)__mptr - (unsigned int )(& ((struct address_handler_resource *)0)->resource));
  fw_core_remove_address_handler(& r->handler);
  kfree((void const   *)r);
  }
  return;
}
}
static int ioctl_allocate(struct client *client , void *buffer ) 
{ struct fw_cdev_allocate *request ;
  struct address_handler_resource *r ;
  struct fw_address_region region ;
  int ret ;
  void *tmp ;

  {
  {
  request = (struct fw_cdev_allocate *)buffer;
  tmp = kmalloc((unsigned int )sizeof(*r), 208U);
  r = (struct address_handler_resource *)tmp;
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  region.start = request->offset;
  region.end = request->offset + (__u64 )request->length;
  r->handler.length = request->length;
  r->handler.address_callback = & handle_request;
  r->handler.callback_data = (void *)r;
  r->closure = request->closure;
  r->client = client;
  ret = fw_core_add_address_handler(& r->handler, (struct fw_address_region  const  *)(& region));
  }
  if (ret < 0) {
    {
    kfree((void const   *)r);
    }
    return (ret);
  }
  {
  r->resource.release = & release_address_handler;
  ret = add_client_resource(client, & r->resource, 208U);
  }
  if (ret < 0) {
    {
    release_address_handler(client, & r->resource);
    }
    return (ret);
  }
  {
  request->handle = (unsigned int )r->resource.handle;
  }
  return (0);
}
}
static int ioctl_deallocate(struct client *client , void *buffer ) 
{ struct fw_cdev_deallocate *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_deallocate *)buffer;
  tmp = release_client_resource(client, request->handle, & release_address_handler,
                                (struct client_resource **)((void *)0));
  }
  return (tmp);
}
}
static int ioctl_send_response(struct client *client , void *buffer ) 
{ struct fw_cdev_send_response *request ;
  struct client_resource *resource ;
  struct inbound_transaction_resource *r ;
  int tmp ;
  struct client_resource  const  *__mptr ;
  void *tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  request = (struct fw_cdev_send_response *)buffer;
  tmp = release_client_resource(client, request->handle, & release_request, & resource);
  }
  if (tmp < 0) {
    return (-22);
  }
  {
  __mptr = (struct client_resource  const  *)resource;
  r = (struct inbound_transaction_resource *)((char *)__mptr - (unsigned int )(& ((struct inbound_transaction_resource *)0)->resource));
  }
  if (request->length < r->length) {
    {
    r->length = request->length;
    }
  }
  {
  tmp___0 = u64_to_uptr(request->data);
  tmp___1 = copy_from_user(r->data, (void const   *)tmp___0, (unsigned long )r->length);
  }
  if (tmp___1) {
    return (-14);
  }
  {
  fw_send_response((client->device)->card, r->request, (int )request->rcode);
  kfree((void const   *)r);
  }
  return (0);
}
}
static int ioctl_initiate_bus_reset(struct client *client , void *buffer ) 
{ struct fw_cdev_initiate_bus_reset *request ;
  int short_reset ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_initiate_bus_reset *)buffer;
  short_reset = request->type == 1U;
  tmp = fw_core_initiate_bus_reset((client->device)->card, short_reset);
  }
  return (tmp);
}
}
static void release_descriptor(struct client *client , struct client_resource *resource ) 
{ struct descriptor_resource *r ;
  struct client_resource  const  *__mptr ;

  {
  {
  __mptr = (struct client_resource  const  *)resource;
  r = (struct descriptor_resource *)((char *)__mptr - (unsigned int )(& ((struct descriptor_resource *)0)->resource));
  fw_core_remove_descriptor(& r->descriptor);
  kfree((void const   *)r);
  }
  return;
}
}
static int ioctl_add_descriptor(struct client *client , void *buffer ) 
{ struct fw_cdev_add_descriptor *request ;
  struct fw_card *card ;
  struct descriptor_resource *r ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  request = (struct fw_cdev_add_descriptor *)buffer;
  card = (client->device)->card;
  _spin_lock_irq(& card->lock);
  ret = (client->device)->node_id != (int )(card->local_node)->node_id;
  }
  {
  while (1) {
    while_291_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& card->lock.raw_lock);
    }
    {
    while (1) {
      while_292_continue: /* CIL Label */ ;
      {
      while (1) {
        while_293_continue: /* CIL Label */ ;
        goto while_293_break;
      }
      while_293_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_292_break;
    }
    while_292_break: /* CIL Label */ ;
    }
    goto while_291_break;
  }
  while_291_break: /* CIL Label */ ;
  }
  if (ret) {
    return (-38);
  }
  if (request->length > 256U) {
    return (-22);
  }
  {
  tmp = kmalloc((unsigned int )(sizeof(*r) + (unsigned long )(request->length * 4U)),
                208U);
  r = (struct descriptor_resource *)tmp;
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  tmp___0 = u64_to_uptr(request->data);
  tmp___1 = copy_from_user((void *)(r->data), (void const   *)tmp___0, (unsigned long )(request->length * 4U));
  }
  if (tmp___1) {
    {
    ret = -14;
    }
    goto failed;
  }
  {
  r->descriptor.length = request->length;
  r->descriptor.immediate = request->immediate;
  r->descriptor.key = request->key;
  r->descriptor.data = (u32 const   *)(r->data);
  ret = fw_core_add_descriptor(& r->descriptor);
  }
  if (ret < 0) {
    goto failed;
  }
  {
  r->resource.release = & release_descriptor;
  ret = add_client_resource(client, & r->resource, 208U);
  }
  if (ret < 0) {
    {
    fw_core_remove_descriptor(& r->descriptor);
    }
    goto failed;
  }
  {
  request->handle = (unsigned int )r->resource.handle;
  }
  return (0);
  failed: 
  {
  kfree((void const   *)r);
  }
  return (ret);
}
}
static int ioctl_remove_descriptor(struct client *client , void *buffer ) 
{ struct fw_cdev_remove_descriptor *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_remove_descriptor *)buffer;
  tmp = release_client_resource(client, request->handle, & release_descriptor, (struct client_resource **)((void *)0));
  }
  return (tmp);
}
}
static void iso_callback(struct fw_iso_context *context , u32 cycle , size_t header_length ,
                         void *header , void *data ) 
{ struct client *client ;
  struct iso_interrupt_event *e ;
  void *tmp ;

  {
  {
  client = (struct client *)data;
  tmp = kzalloc((unsigned int )(sizeof(*e) + (unsigned long )header_length), 32U);
  e = (struct iso_interrupt_event *)tmp;
  }
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    return;
  }
  {
  e->interrupt.type = 3U;
  e->interrupt.closure = client->iso_closure;
  e->interrupt.cycle = cycle;
  e->interrupt.header_length = header_length;
  __memcpy((void *)(e->interrupt.header), (void const   *)header, header_length);
  queue_event(client, & e->event, (void *)(& e->interrupt), (unsigned int )(sizeof(e->interrupt) + (unsigned long )header_length),
              (void *)0, 0U);
  }
  return;
}
}
static int ioctl_create_iso_context(struct client *client , void *buffer ) 
{ struct fw_cdev_create_iso_context *request ;
  struct fw_iso_context *context ;
  long tmp ;
  long tmp___0 ;

  {
  {
  request = (struct fw_cdev_create_iso_context *)buffer;
  }
  if ((unsigned long )client->iso_context != (unsigned long )((void *)0)) {
    return (-16);
  }
  if (request->channel > 63U) {
    return (-22);
  }
  if ((int )request->type == 1) {
    goto switch_294_1;
  } else {
    if ((int )request->type == 0) {
      goto switch_294_0;
    } else {
      {
      goto switch_294_default;
      if (0) {
        switch_294_1: /* CIL Label */ 
        if (request->header_size < 4U) {
          return (-22);
        } else {
          if (request->header_size & 3U) {
            return (-22);
          }
        }
        goto switch_294_break;
        switch_294_0: /* CIL Label */ 
        if (request->speed > 5U) {
          return (-22);
        }
        goto switch_294_break;
        switch_294_default: /* CIL Label */ 
        {

        }
        return (-22);
      } else {
        switch_294_break: /* CIL Label */ ;
      }
      }
    }
  }
  {
  context = fw_iso_context_create((client->device)->card, (int )request->type, (int )request->channel,
                                  (int )request->speed, request->header_size, & iso_callback,
                                  (void *)client);
  tmp___0 = IS_ERR((void const   *)context);
  }
  if (tmp___0) {
    {
    tmp = PTR_ERR((void const   *)context);
    }
    return ((int )tmp);
  }
  {
  client->iso_closure = request->closure;
  client->iso_context = context;
  request->handle = 0U;
  }
  return (0);
}
}
static int ioctl_queue_iso(struct client *client , void *buffer ) 
{ struct fw_cdev_queue_iso *request ;
  struct fw_cdev_iso_packet *p ;
  struct fw_cdev_iso_packet *end ;
  struct fw_cdev_iso_packet *next ;
  struct fw_iso_context *ctx ;
  unsigned long payload ;
  unsigned long buffer_end ;
  unsigned long header_length ;
  u32 control ;
  int count ;
  struct __anonstruct_u_194 u ;
  void *tmp ;
  unsigned long flag ;
  unsigned long roksum ;
  struct thread_info *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int __ret_gu ;
  unsigned long __val_gu ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  __u64 tmp___5 ;

  {
  {
  request = (struct fw_cdev_queue_iso *)buffer;
  ctx = client->iso_context;
  }
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    return (-22);
  } else {
    if (request->handle != 0U) {
      return (-22);
    }
  }
  {
  payload = (unsigned long )request->data - client->vm_start;
  buffer_end = (unsigned long )(client->buffer.page_count << 12);
  }
  if (request->data == 0ULL) {
    {
    payload = 0UL;
    buffer_end = 0UL;
    }
  } else {
    if ((unsigned long )client->buffer.pages == (unsigned long )((void *)0)) {
      {
      payload = 0UL;
      buffer_end = 0UL;
      }
    } else {
      if (payload >= buffer_end) {
        {
        payload = 0UL;
        buffer_end = 0UL;
        }
      }
    }
  }
  {
  tmp = u64_to_uptr(request->packets);
  p = (struct fw_cdev_iso_packet *)tmp;
  tmp___0 = current_thread_info();
  __asm__  ("add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0": "=&r" (flag), "=r" (roksum): "1" (p),
            "g" ((long )request->size), "rm" (tmp___0->addr_limit.seg));
  }
  if (flag == 0UL) {
    {
    tmp___1 = 1;
    }
  } else {
    {
    tmp___1 = 0;
    }
  }
  {
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  }
  if (! tmp___2) {
    return (-14);
  }
  {
  end = (struct fw_cdev_iso_packet *)((void *)p + request->size);
  count = 0;
  }
  {
  while (1) {
    while_295_continue: /* CIL Label */ ;
    if (! ((unsigned long )p < (unsigned long )end)) {
      goto while_295_break;
    }
    {
    might_fault();
    }
    if ((int )sizeof(p->control) == 1) {
      goto switch_296_1;
    } else {
      if ((int )sizeof(p->control) == 2) {
        goto switch_296_2;
      } else {
        if ((int )sizeof(p->control) == 4) {
          goto switch_296_4;
        } else {
          if ((int )sizeof(p->control) == 8) {
            goto switch_296_8;
          } else {
            {
            goto switch_296_default;
            if (0) {
              switch_296_1: /* CIL Label */ 
              {
              __asm__  volatile   ("call __get_user_"
                                   "1": "=a" (__ret_gu), "=d" (__val_gu): "0" (& p->control));
              }
              goto switch_296_break;
              switch_296_2: /* CIL Label */ 
              {
              __asm__  volatile   ("call __get_user_"
                                   "2": "=a" (__ret_gu), "=d" (__val_gu): "0" (& p->control));
              }
              goto switch_296_break;
              switch_296_4: /* CIL Label */ 
              {
              __asm__  volatile   ("call __get_user_"
                                   "4": "=a" (__ret_gu), "=d" (__val_gu): "0" (& p->control));
              }
              goto switch_296_break;
              switch_296_8: /* CIL Label */ 
              {
              __asm__  volatile   ("call __get_user_"
                                   "X": "=a" (__ret_gu), "=d" (__val_gu): "0" (& p->control));
              }
              goto switch_296_break;
              switch_296_default: /* CIL Label */ 
              {
              __asm__  volatile   ("call __get_user_"
                                   "X": "=a" (__ret_gu), "=d" (__val_gu): "0" (& p->control));
              }
              goto switch_296_break;
            } else {
              switch_296_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    control = (unsigned int )__val_gu;
    }
    if (__ret_gu) {
      return (-14);
    }
    {
    u.packet.payload_length = (unsigned short )(control & 65535U);
    u.packet.interrupt = (control >> 16) & 1U;
    u.packet.skip = (control >> 17) & 1U;
    u.packet.tag = (control >> 18) & 3U;
    u.packet.sy = (control >> 20) & 15U;
    u.packet.header_length = (control >> 24) & 255U;
    }
    if (ctx->type == 0) {
      {
      header_length = (unsigned long )u.packet.header_length;
      }
    } else {
      if (ctx->header_size == 0U) {
        if (u.packet.header_length > 0U) {
          return (-22);
        }
      } else {
        if (u.packet.header_length % ctx->header_size != 0U) {
          return (-22);
        }
      }
      {
      header_length = 0UL;
      }
    }
    {
    next = (struct fw_cdev_iso_packet *)(& p->header[header_length / 4UL]);
    }
    if ((unsigned long )next > (unsigned long )end) {
      return (-22);
    }
    {
    tmp___3 = __copy_from_user((void *)(u.packet.header), (void const   *)(p->header),
                               header_length);
    }
    if (tmp___3) {
      return (-14);
    }
    if (u.packet.skip) {
      if (ctx->type == 0) {
        if (u.packet.header_length + (u32 )u.packet.payload_length > 0U) {
          return (-22);
        }
      }
    }
    if (payload + (unsigned long )u.packet.payload_length > buffer_end) {
      return (-22);
    }
    {
    tmp___4 = fw_iso_context_queue(ctx, & u.packet, & client->buffer, payload);
    }
    if (tmp___4) {
      goto while_295_break;
    }
    {
    p = next;
    payload += (unsigned long )u.packet.payload_length;
    count ++;
    }
  }
  while_295_break: /* CIL Label */ ;
  }
  {
  tmp___5 = uptr_to_u64((void *)p);
  request->size = (unsigned int )((__u64 )request->size - (tmp___5 - request->packets));
  request->packets = uptr_to_u64((void *)p);
  request->data = (unsigned long long )(client->vm_start + payload);
  }
  return (count);
}
}
static int ioctl_start_iso(struct client *client , void *buffer ) 
{ struct fw_cdev_start_iso *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_start_iso *)buffer;
  }
  if ((unsigned long )client->iso_context == (unsigned long )((void *)0)) {
    return (-22);
  } else {
    if (request->handle != 0U) {
      return (-22);
    }
  }
  if ((client->iso_context)->type == 1) {
    if (request->tags == 0U) {
      return (-22);
    } else {
      if (request->tags > 15U) {
        return (-22);
      }
    }
    if (request->sync > 15U) {
      return (-22);
    }
  }
  {
  tmp = fw_iso_context_start(client->iso_context, request->cycle, (int )request->sync,
                             (int )request->tags);
  }
  return (tmp);
}
}
static int ioctl_stop_iso(struct client *client , void *buffer ) 
{ struct fw_cdev_stop_iso *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_stop_iso *)buffer;
  }
  if ((unsigned long )client->iso_context == (unsigned long )((void *)0)) {
    return (-22);
  } else {
    if (request->handle != 0U) {
      return (-22);
    }
  }
  {
  tmp = fw_iso_context_stop(client->iso_context);
  }
  return (tmp);
}
}
static int ioctl_get_cycle_timer(struct client *client , void *buffer ) 
{ struct fw_cdev_get_cycle_timer *request ;
  struct fw_card *card ;
  unsigned long long bus_time ;
  struct timeval tv ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_get_cycle_timer *)buffer;
  card = (client->device)->card;
  }
  {
  while (1) {
    while_297_continue: /* CIL Label */ ;
    goto while_297_break;
  }
  while_297_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_298_continue: /* CIL Label */ ;
    {
    while (1) {
      while_299_continue: /* CIL Label */ ;
      {
      flags = __raw_local_irq_save();
      }
      goto while_299_break;
    }
    while_299_break: /* CIL Label */ ;
    }
    {
    while (1) {
      while_300_continue: /* CIL Label */ ;
      goto while_300_break;
    }
    while_300_break: /* CIL Label */ ;
    }
    goto while_298_break;
  }
  while_298_break: /* CIL Label */ ;
  }
  {
  bus_time = (*((card->driver)->get_bus_time))(card);
  do_gettimeofday(& tv);
  }
  {
  while (1) {
    while_301_continue: /* CIL Label */ ;
    {
    tmp = raw_irqs_disabled_flags(flags);
    }
    if (tmp) {
      {
      raw_local_irq_restore(flags);
      }
      {
      while (1) {
        while_302_continue: /* CIL Label */ ;
        goto while_302_break;
      }
      while_302_break: /* CIL Label */ ;
      }
    } else {
      {
      while (1) {
        while_303_continue: /* CIL Label */ ;
        goto while_303_break;
      }
      while_303_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_restore(flags);
      }
    }
    goto while_301_break;
  }
  while_301_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_304_continue: /* CIL Label */ ;
    goto while_304_break;
  }
  while_304_break: /* CIL Label */ ;
  }
  {
  request->local_time = (unsigned long long )tv.tv_sec * 1000000ULL + (unsigned long long )tv.tv_usec;
  request->cycle_timer = (unsigned int )(bus_time & 4294967295ULL);
  }
  return (0);
}
}
static void iso_resource_work(struct work_struct *work ) 
{ struct iso_resource_event *e ;
  struct iso_resource *r ;
  struct work_struct  const  *__mptr ;
  struct client *client ;
  int generation ;
  int channel ;
  int bandwidth ;
  int todo ;
  bool skip ;
  bool free ;
  bool success ;
  int tmp ;
  int tmp___0 ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long volatile   __dummy2___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  r = (struct iso_resource *)((char *)__mptr - (unsigned int )(& ((struct iso_resource *)0)->work.work));
  client = r->client;
  _spin_lock_irq(& client->lock);
  generation = (client->device)->generation;
  todo = (int )r->todo;
  }
  if (todo == 0) {
    if ((long )jiffies - (long )(((client->device)->card)->reset_jiffies + 1000UL) < 0L) {
      {
      tmp = schedule_delayed_work(& r->work, 334UL);
      }
      if (tmp) {
        {
        client_get(client);
        }
      }
      {
      skip = (_Bool)1;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (todo == 1) {
      if (r->generation == generation) {
        {
        tmp___0 = 1;
        }
      } else {
        {
        tmp___0 = 0;
        }
      }
    } else {
      {
      tmp___0 = 0;
      }
    }
    {
    skip = (_Bool )tmp___0;
    }
  }
  if (todo == 2) {
    {
    tmp___1 = 1;
    }
  } else {
    if (todo == 3) {
      {
      tmp___1 = 1;
      }
    } else {
      if (todo == 4) {
        {
        tmp___1 = 1;
        }
      } else {
        {
        tmp___1 = 0;
        }
      }
    }
  }
  {
  free = (_Bool )tmp___1;
  r->generation = generation;
  }
  {
  while (1) {
    while_305_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& client->lock.raw_lock);
    }
    {
    while (1) {
      while_306_continue: /* CIL Label */ ;
      {
      while (1) {
        while_307_continue: /* CIL Label */ ;
        goto while_307_break;
      }
      while_307_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_306_break;
    }
    while_306_break: /* CIL Label */ ;
    }
    goto while_305_break;
  }
  while_305_break: /* CIL Label */ ;
  }
  if (skip) {
    goto out;
  }
  {
  bandwidth = r->bandwidth;
  }
  if (todo == 0) {
    {
    tmp___2 = 1;
    }
  } else {
    if (todo == 1) {
      {
      tmp___2 = 1;
      }
    } else {
      if (todo == 3) {
        {
        tmp___2 = 1;
        }
      } else {
        {
        tmp___2 = 0;
        }
      }
    }
  }
  {
  fw_iso_resource_manage((client->device)->card, generation, r->channels, & channel,
                         & bandwidth, (_Bool )tmp___2);
  }
  if (channel == -11) {
    if (todo == 0) {
      goto out;
    } else {
      if (todo == 1) {
        goto out;
      }
    }
  }
  if (channel >= 0) {
    {
    tmp___3 = 1;
    }
  } else {
    if (bandwidth > 0) {
      {
      tmp___3 = 1;
      }
    } else {
      {
      tmp___3 = 0;
      }
    }
  }
  {
  success = (_Bool )tmp___3;
  _spin_lock_irq(& client->lock);
  }
  if ((unsigned int )r->todo == 0U) {
    {
    r->todo = (enum __anonenum_todo_192 )1;
    }
  }
  if ((unsigned int )r->todo == 1U) {
    if (! success) {
      if (! client->in_shutdown) {
        {
        tmp___4 = idr_find(& client->resource_idr, r->resource.handle);
        }
        if (tmp___4) {
          {
          idr_remove(& client->resource_idr, r->resource.handle);
          client_put(client);
          free = (_Bool)1;
          }
        }
      }
    }
  }
  {
  while (1) {
    while_308_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& client->lock.raw_lock);
    }
    {
    while (1) {
      while_309_continue: /* CIL Label */ ;
      {
      while (1) {
        while_310_continue: /* CIL Label */ ;
        goto while_310_break;
      }
      while_310_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_309_break;
    }
    while_309_break: /* CIL Label */ ;
    }
    goto while_308_break;
  }
  while_308_break: /* CIL Label */ ;
  }
  if (todo == 0) {
    if (channel >= 0) {
      {
      r->channels = 1ULL << channel;
      }
    }
  }
  if (todo == 1) {
    if (success) {
      goto out;
    }
  }
  if (todo == 0) {
    {
    e = r->e_alloc;
    r->e_alloc = (struct iso_resource_event *)((void *)0);
    }
  } else {
    if (todo == 3) {
      {
      e = r->e_alloc;
      r->e_alloc = (struct iso_resource_event *)((void *)0);
      }
    } else {
      {
      e = r->e_dealloc;
      r->e_dealloc = (struct iso_resource_event *)((void *)0);
      }
    }
  }
  {
  e->resource.handle = (unsigned int )r->resource.handle;
  e->resource.channel = channel;
  e->resource.bandwidth = bandwidth;
  queue_event(client, & e->event, (void *)(& e->resource), (unsigned int )sizeof(e->resource),
              (void *)0, 0U);
  }
  if (free) {
    {
    cancel_delayed_work(& r->work);
    kfree((void const   *)r->e_alloc);
    kfree((void const   *)r->e_dealloc);
    kfree((void const   *)r);
    }
  }
  out: 
  {
  client_put(client);
  }
  return;
}
}
static void schedule_iso_resource(struct iso_resource *r ) 
{ int tmp ;

  {
  {
  client_get(r->client);
  tmp = schedule_delayed_work(& r->work, 0UL);
  }
  if (! tmp) {
    {
    client_put(r->client);
    }
  }
  return;
}
}
static void release_iso_resource(struct client *client , struct client_resource *resource ) 
{ struct iso_resource *r ;
  struct client_resource  const  *__mptr ;

  {
  {
  __mptr = (struct client_resource  const  *)resource;
  r = (struct iso_resource *)((char *)__mptr - (unsigned int )(& ((struct iso_resource *)0)->resource));
  _spin_lock_irq(& client->lock);
  r->todo = (enum __anonenum_todo_192 )2;
  schedule_iso_resource(r);
  }
  {
  while (1) {
    while_311_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& client->lock.raw_lock);
    }
    {
    while (1) {
      while_312_continue: /* CIL Label */ ;
      {
      while (1) {
        while_313_continue: /* CIL Label */ ;
        goto while_313_break;
      }
      while_313_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_312_break;
    }
    while_312_break: /* CIL Label */ ;
    }
    goto while_311_break;
  }
  while_311_break: /* CIL Label */ ;
  }
  return;
}
}
static int init_iso_resource(struct client *client , struct fw_cdev_allocate_iso_resource *request ,
                             int todo ) 
{ struct iso_resource_event *e1 ;
  struct iso_resource_event *e2 ;
  struct iso_resource *r ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  atomic_long_t __constr_expr_0 ;

  {
  if (request->channels == 0ULL) {
    if (request->bandwidth == 0U) {
      return (-22);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (request->bandwidth > 4915U) {
      return (-22);
    } else {
      if (request->bandwidth < 0U) {
        return (-22);
      }
    }
  }
  {
  tmp = kmalloc((unsigned int )sizeof(*r), 208U);
  r = (struct iso_resource *)tmp;
  tmp___0 = kmalloc((unsigned int )sizeof(*e1), 208U);
  e1 = (struct iso_resource_event *)tmp___0;
  tmp___1 = kmalloc((unsigned int )sizeof(*e2), 208U);
  e2 = (struct iso_resource_event *)tmp___1;
  }
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
    ret = -12;
    }
    goto fail;
  } else {
    if ((unsigned long )e1 == (unsigned long )((void *)0)) {
      {
      ret = -12;
      }
      goto fail;
    } else {
      if ((unsigned long )e2 == (unsigned long )((void *)0)) {
        {
        ret = -12;
        }
        goto fail;
      }
    }
  }
  {
  while (1) {
    while_314_continue: /* CIL Label */ ;
    {
    while (1) {
      while_315_continue: /* CIL Label */ ;
      {
      __constr_expr_0.counter = (int volatile   )0;
      r->work.work.data = __constr_expr_0;
      INIT_LIST_HEAD(& r->work.work.entry);
      }
      {
      while (1) {
        while_316_continue: /* CIL Label */ ;
        {
        r->work.work.func = & iso_resource_work;
        }
        goto while_316_break;
      }
      while_316_break: /* CIL Label */ ;
      }
      goto while_315_break;
    }
    while_315_break: /* CIL Label */ ;
    }
    {
    init_timer_key(& r->work.timer, (char const   *)((void *)0), (struct lock_class_key *)((void *)0));
    }
    goto while_314_break;
  }
  while_314_break: /* CIL Label */ ;
  }
  {
  r->client = client;
  r->todo = (enum __anonenum_todo_192 )todo;
  r->generation = -1;
  r->channels = request->channels;
  r->bandwidth = (int )request->bandwidth;
  r->e_alloc = e1;
  r->e_dealloc = e2;
  e1->resource.closure = request->closure;
  e1->resource.type = 4U;
  e2->resource.closure = request->closure;
  e2->resource.type = 5U;
  }
  if (todo == 0) {
    {
    r->resource.release = & release_iso_resource;
    ret = add_client_resource(client, & r->resource, 208U);
    }
    if (ret < 0) {
      goto fail;
    }
  } else {
    {
    r->resource.release = (void (*)(struct client * , struct client_resource * ))((void *)0);
    r->resource.handle = -1;
    schedule_iso_resource(r);
    }
  }
  {
  request->handle = (unsigned int )r->resource.handle;
  }
  return (0);
  fail: 
  {
  kfree((void const   *)r);
  kfree((void const   *)e1);
  kfree((void const   *)e2);
  }
  return (ret);
}
}
static int ioctl_allocate_iso_resource(struct client *client , void *buffer ) 
{ struct fw_cdev_allocate_iso_resource *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_allocate_iso_resource *)buffer;
  tmp = init_iso_resource(client, request, 0);
  }
  return (tmp);
}
}
static int ioctl_deallocate_iso_resource(struct client *client , void *buffer ) 
{ struct fw_cdev_deallocate *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_deallocate *)buffer;
  tmp = release_client_resource(client, request->handle, & release_iso_resource, (struct client_resource **)((void *)0));
  }
  return (tmp);
}
}
static int ioctl_allocate_iso_resource_once(struct client *client , void *buffer ) 
{ struct fw_cdev_allocate_iso_resource *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_allocate_iso_resource *)buffer;
  tmp = init_iso_resource(client, request, 3);
  }
  return (tmp);
}
}
static int ioctl_deallocate_iso_resource_once(struct client *client , void *buffer ) 
{ struct fw_cdev_allocate_iso_resource *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_allocate_iso_resource *)buffer;
  tmp = init_iso_resource(client, request, 4);
  }
  return (tmp);
}
}
static int ioctl_get_speed(struct client *client , void *buffer ) 
{ 

  {
  return ((int )(client->device)->max_speed);
}
}
static int ioctl_send_broadcast_request(struct client *client , void *buffer ) 
{ struct fw_cdev_send_request *request ;
  int tmp ;

  {
  {
  request = (struct fw_cdev_send_request *)buffer;
  }
  if ((int )request->tcode == 0) {
    goto switch_317_0;
  } else {
    if ((int )request->tcode == 1) {
      goto switch_317_0;
    } else {
      {
      goto switch_317_default;
      if (0) {
        switch_317_0: /* CIL Label */ 
        switch_317_1: /* CIL Label */ 
        goto switch_317_break;
        switch_317_default: /* CIL Label */ 
        {

        }
        return (-22);
      } else {
        switch_317_break: /* CIL Label */ ;
      }
      }
    }
  }
  if (request->offset < 281474708277248ULL) {
    return (-13);
  }
  {
  tmp = init_request(client, request, 65535, 0);
  }
  return (tmp);
}
}
static int ioctl_send_stream_packet(struct client *client , void *buffer ) 
{ struct fw_cdev_send_stream_packet *p ;
  struct fw_cdev_send_request request ;
  int dest ;
  int tmp ;

  {
  {
  p = (struct fw_cdev_send_stream_packet *)buffer;
  }
  if (p->speed > (__u32 )((client->device)->card)->link_speed) {
    return (-5);
  } else {
    if (p->length > (__u32 )(1024 << p->speed)) {
      return (-5);
    }
  }
  if (p->tag > 3U) {
    return (-22);
  } else {
    if (p->channel > 63U) {
      return (-22);
    } else {
      if (p->sy > 15U) {
        return (-22);
      }
    }
  }
  {
  dest = fw_stream_packet_destination_id((int )p->tag, (int )p->channel, (int )p->sy);
  request.tcode = 10U;
  request.length = p->length;
  request.closure = p->closure;
  request.data = p->data;
  request.generation = p->generation;
  tmp = init_request(client, & request, dest, (int )p->speed);
  }
  return (tmp);
}
}
static int (* const  ioctl_handlers[20])(struct client *client , void *buffer )  = 
  {      (int (* const  )(struct client *client , void *buffer ))(& ioctl_get_info),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_send_request),      (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_allocate),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_deallocate), 
        (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_send_response),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_initiate_bus_reset),      (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_add_descriptor),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_remove_descriptor), 
        (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_create_iso_context),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_queue_iso),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_start_iso),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_stop_iso), 
        (int (* const  )(struct client *client , void *buffer ))(& ioctl_get_cycle_timer),      (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_allocate_iso_resource),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_deallocate_iso_resource),      (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_allocate_iso_resource_once), 
        (int (* const  )(struct client *client , void *buffer ))(& ioctl_deallocate_iso_resource_once),      (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_get_speed),      (int (* const  )(struct client *client , void *buffer ))(& ioctl_send_broadcast_request),      (int (* const  )(struct client *client ,
                      void *buffer ))(& ioctl_send_stream_packet)};
static int dispatch_ioctl(struct client *client , unsigned int cmd , void *arg ) 
{ char buffer[256] ;
  int ret ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (((cmd >> 8) & (unsigned int )((1 << 8) - 1)) != 35U) {
    return (-22);
  } else {
    if ((unsigned long )(cmd & (unsigned int )((1 << 8) - 1)) >= sizeof(ioctl_handlers) / sizeof(ioctl_handlers[0])) {
      return (-22);
    }
  }
  if (((cmd >> 30) & (unsigned int )((1 << 2) - 1)) & 1U) {
    if ((unsigned long )((cmd >> 16) & (unsigned int )((1 << 14) - 1)) > sizeof(buffer)) {
      return (-14);
    } else {
      {
      tmp = copy_from_user((void *)(buffer), (void const   *)arg, (unsigned long )((cmd >> 16) & (unsigned int )((1 << 14) - 1)));
      }
      if (tmp) {
        return (-14);
      }
    }
  }
  {
  ret = (*(ioctl_handlers[cmd & (unsigned int )((1 << 8) - 1)]))(client, (void *)(buffer));
  }
  if (ret < 0) {
    return (ret);
  }
  if (((cmd >> 30) & (unsigned int )((1 << 2) - 1)) & 2U) {
    if ((unsigned long )((cmd >> 16) & (unsigned int )((1 << 14) - 1)) > sizeof(buffer)) {
      return (-14);
    } else {
      {
      tmp___0 = copy_to_user(arg, (void const   *)(buffer), (unsigned long )((cmd >> 16) & (unsigned int )((1 << 14) - 1)));
      }
      if (tmp___0) {
        return (-14);
      }
    }
  }
  return (ret);
}
}
static long fw_device_op_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ struct client *client ;
  int tmp ;
  int tmp___0 ;

  {
  {
  client = (struct client *)file->private_data;
  tmp = fw_device_is_shutdown(client->device);
  }
  if (tmp) {
    return (-19L);
  }
  {
  tmp___0 = dispatch_ioctl(client, cmd, (void *)arg);
  }
  return ((long )tmp___0);
}
}
static int fw_device_op_mmap(struct file *file , struct vm_area_struct *vma ) 
{ struct client *client ;
  enum dma_data_direction direction ;
  unsigned long size ;
  int page_count___0 ;
  int ret ;
  int tmp ;

  {
  {
  client = (struct client *)file->private_data;
  tmp = fw_device_is_shutdown(client->device);
  }
  if (tmp) {
    return (-19);
  }
  if ((unsigned long )client->buffer.pages != (unsigned long )((void *)0)) {
    return (-16);
  }
  if (! (vma->vm_flags & 8UL)) {
    return (-22);
  }
  if (vma->vm_start & ~ (~ ((1UL << 12) - 1UL))) {
    return (-22);
  }
  {
  client->vm_start = vma->vm_start;
  size = vma->vm_end - vma->vm_start;
  page_count___0 = (int )(size >> 12);
  }
  if (size & ~ (~ ((1UL << 12) - 1UL))) {
    return (-22);
  }
  if (vma->vm_flags & 2UL) {
    {
    direction = (enum dma_data_direction )1;
    }
  } else {
    {
    direction = (enum dma_data_direction )2;
    }
  }
  {
  ret = fw_iso_buffer_init(& client->buffer, (client->device)->card, page_count___0,
                           direction);
  }
  if (ret < 0) {
    return (ret);
  }
  {
  ret = fw_iso_buffer_map(& client->buffer, vma);
  }
  if (ret < 0) {
    {
    fw_iso_buffer_destroy(& client->buffer, (client->device)->card);
    }
  }
  return (ret);
}
}
static int shutdown_resource(int id , void *p , void *data ) 
{ struct client_resource *r ;
  struct client *client ;

  {
  {
  r = (struct client_resource *)p;
  client = (struct client *)data;
  (*(r->release))(client, r);
  client_put(client);
  }
  return (0);
}
}
static int fw_device_op_release(struct inode *inode , struct file *file ) 
{ struct client *client ;
  struct event *e ;
  struct event *next_e ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  client = (struct client *)file->private_data;
  mutex_lock(& (client->device)->client_list_mutex);
  list_del(& client->link);
  mutex_unlock(& (client->device)->client_list_mutex);
  }
  if (client->iso_context) {
    {
    fw_iso_context_destroy(client->iso_context);
    }
  }
  if (client->buffer.pages) {
    {
    fw_iso_buffer_destroy(& client->buffer, (client->device)->card);
    }
  }
  {
  _spin_lock_irq(& client->lock);
  client->in_shutdown = (_Bool)1;
  }
  {
  while (1) {
    while_318_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& client->lock.raw_lock);
    }
    {
    while (1) {
      while_319_continue: /* CIL Label */ ;
      {
      while (1) {
        while_320_continue: /* CIL Label */ ;
        goto while_320_break;
      }
      while_320_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_319_break;
    }
    while_319_break: /* CIL Label */ ;
    }
    goto while_318_break;
  }
  while_318_break: /* CIL Label */ ;
  }
  {
  idr_for_each(& client->resource_idr, & shutdown_resource, (void *)client);
  idr_remove_all(& client->resource_idr);
  idr_destroy(& client->resource_idr);
  __mptr = (struct list_head  const  *)client->event_list.next;
  e = (struct event *)((char *)__mptr - (unsigned int )(& ((struct event *)0)->link));
  __mptr___0 = (struct list_head  const  *)e->link.next;
  next_e = (struct event *)((char *)__mptr___0 - (unsigned int )(& ((struct event *)0)->link));
  }
  {
  while (1) {
    while_321_continue: /* CIL Label */ ;
    if (! ((unsigned long )(& e->link) != (unsigned long )(& client->event_list))) {
      goto while_321_break;
    }
    {
    kfree((void const   *)e);
    e = next_e;
    __mptr___1 = (struct list_head  const  *)next_e->link.next;
    next_e = (struct event *)((char *)__mptr___1 - (unsigned int )(& ((struct event *)0)->link));
    }
  }
  while_321_break: /* CIL Label */ ;
  }
  {
  client_put(client);
  }
  return (0);
}
}
static unsigned int fw_device_op_poll(struct file *file , poll_table *pt ) 
{ struct client *client ;
  unsigned int mask ;
  int tmp ;
  int tmp___0 ;

  {
  {
  client = (struct client *)file->private_data;
  mask = 0U;
  poll_wait(file, & client->wait, pt);
  tmp = fw_device_is_shutdown(client->device);
  }
  if (tmp) {
    {
    mask |= 24U;
    }
  }
  {
  tmp___0 = list_empty((struct list_head  const  *)(& client->event_list));
  }
  if (! tmp___0) {
    {
    mask |= 65U;
    }
  }
  return (mask);
}
}
struct file_operations  const  fw_device_ops  = 
     {(struct module *)0, (loff_t (*)(struct file * , loff_t  , int  ))0, & fw_device_op_read,
    (ssize_t (*)(struct file * , char const   * , size_t  , loff_t * ))0, (ssize_t (*)(struct kiocb * ,
                                                                                       struct iovec  const  * ,
                                                                                       unsigned long  ,
                                                                                       loff_t  ))0,
    (ssize_t (*)(struct kiocb * , struct iovec  const  * , unsigned long  , loff_t  ))0,
    (int (*)(struct file * , void * , int (*)(void * , char const   * , int  , loff_t  ,
                                              u64  , unsigned int  ) ))0, & fw_device_op_poll,
    (int (*)(struct inode * , struct file * , unsigned int  , unsigned long  ))0,
    & fw_device_op_ioctl, (long (*)(struct file * , unsigned int  , unsigned long  ))0,
    & fw_device_op_mmap, & fw_device_op_open, (int (*)(struct file * , fl_owner_t id ))0,
    & fw_device_op_release, (int (*)(struct file * , struct dentry * , int datasync ))0,
    (int (*)(struct kiocb * , int datasync ))0, (int (*)(int  , struct file * , int  ))0,
    (int (*)(struct file * , int  , struct file_lock * ))0, (ssize_t (*)(struct file * ,
                                                                         struct page * ,
                                                                         int  , size_t  ,
                                                                         loff_t * ,
                                                                         int  ))0,
    (unsigned long (*)(struct file * , unsigned long  , unsigned long  , unsigned long  ,
                       unsigned long  ))0, (int (*)(int  ))0, (int (*)(struct file * ,
                                                                       int  , struct file_lock * ))0,
    (ssize_t (*)(struct pipe_inode_info * , struct file * , loff_t * , size_t  , unsigned int  ))0,
    (ssize_t (*)(struct file * , loff_t * , struct pipe_inode_info * , size_t  , unsigned int  ))0,
    (int (*)(struct file * , long  , struct file_lock ** ))0};
extern unsigned char _ctype[] ;
__inline static unsigned char __tolower(unsigned char c ) 
{ 

  {
  if (((int )_ctype[(int )c] & 1) != 0) {
    {
    c = (unsigned char )((int )c - -32);
    }
  }
  return (c);
}
}
__inline static unsigned char __toupper(unsigned char c ) 
{ 

  {
  if (((int )_ctype[(int )c] & 2) != 0) {
    {
    c = (unsigned char )((int )c - 32);
    }
  }
  return (c);
}
}
static unsigned long __force_order___1  ;
__inline static unsigned long native_read_cr0___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static void native_write_cr0___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static void native_write_cr2___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static void native_write_cr3___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___1));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___1(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___1): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___1(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___1));
  }
  return;
}
}
__inline static void load_cr3___1(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___1((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___1(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___1();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___1((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___1(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___1();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___1((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___1(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___1 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___1(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___1(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___1(u64 ns ) ;
static union ktime  const  ktime_zero___1  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___1(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___1.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___1  ;
int fw_cdev_major  ;
void fw_csr_iterator_init(struct fw_csr_iterator *ci , u32 *p ) 
{ 

  {
  {
  ci->p = p + 1;
  ci->end = ci->p + (*(p + 0) >> 16);
  }
  return;
}
}
static char const   __kstrtab_fw_csr_iterator_init[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'s',      (char const   )'r',      (char const   )'_',      (char const   )'i', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'a', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'i',      (char const   )'t', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_csr_iterator_init  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_csr_iterator_init), __kstrtab_fw_csr_iterator_init};
int fw_csr_iterator_next(struct fw_csr_iterator *ci , int *key , int *value ) 
{ u32 *tmp ;

  {
  {
  *key = (int )(*(ci->p) >> 24);
  *value = (int )(*(ci->p) & 16777215U);
  tmp = ci->p;
  (ci->p) ++;
  }
  return ((unsigned long )tmp < (unsigned long )ci->end);
}
}
static char const   __kstrtab_fw_csr_iterator_next[21]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'s',      (char const   )'r',      (char const   )'_',      (char const   )'i', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'a', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'_', 
        (char const   )'n',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_csr_iterator_next  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_csr_iterator_next), __kstrtab_fw_csr_iterator_next};
static int is_fw_unit(struct device *dev ) ;
static int match_unit_directory(u32 *directory , struct fw_device_id  const  *id ) 
{ struct fw_csr_iterator ci ;
  int key ;
  int value ;
  int match ;
  int tmp ;

  {
  {
  match = 0;
  fw_csr_iterator_init(& ci, directory);
  }
  {
  while (1) {
    while_322_continue: /* CIL Label */ ;
    {
    tmp = fw_csr_iterator_next(& ci, & key, & value);
    }
    if (! tmp) {
      goto while_322_break;
    }
    if (key == 3) {
      if ((u32 const   )value == id->vendor) {
        {
        match |= 1;
        }
      }
    }
    if (key == 23) {
      if ((u32 const   )value == id->model) {
        {
        match |= 2;
        }
      }
    }
    if (key == 18) {
      if ((u32 const   )value == id->specifier_id) {
        {
        match |= 4;
        }
      }
    }
    if (key == 19) {
      if ((u32 const   )value == id->version) {
        {
        match |= 8;
        }
      }
    }
  }
  while_322_break: /* CIL Label */ ;
  }
  return (((unsigned int const   )match & id->match_flags) == id->match_flags);
}
}
static int fw_unit_match(struct device *dev , struct device_driver *drv ) 
{ struct fw_unit *unit ;
  struct fw_unit *tmp ;
  struct fw_driver *driver ;
  struct fw_driver *tmp___0 ;
  int i ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = fw_unit(dev);
  unit = tmp;
  tmp___0 = fw_driver(drv);
  driver = tmp___0;
  tmp___1 = is_fw_unit(dev);
  }
  if (! tmp___1) {
    return (0);
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_323_continue: /* CIL Label */ ;
    if (! ((driver->id_table + i)->match_flags != 0U)) {
      goto while_323_break;
    }
    {
    tmp___2 = match_unit_directory(unit->directory, driver->id_table + i);
    }
    if (tmp___2) {
      return (1);
    }
    {
    i ++;
    }
  }
  while_323_break: /* CIL Label */ ;
  }
  return (0);
}
}
static int get_modalias(struct fw_unit *unit , char *buffer , size_t buffer_size ) 
{ struct fw_device *device ;
  struct fw_device *tmp ;
  struct fw_csr_iterator ci ;
  int key ;
  int value ;
  int vendor ;
  int model ;
  int specifier_id ;
  int version ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  tmp = fw_device(unit->device.parent);
  device = tmp;
  vendor = 0;
  model = 0;
  specifier_id = 0;
  version = 0;
  fw_csr_iterator_init(& ci, device->config_rom + 5);
  }
  {
  while (1) {
    while_324_continue: /* CIL Label */ ;
    {
    tmp___0 = fw_csr_iterator_next(& ci, & key, & value);
    }
    if (! tmp___0) {
      goto while_324_break;
    }
    if (key == 3) {
      goto switch_325_3;
    } else {
      if (key == 23) {
        goto switch_325_23;
      } else {
        if (0) {
          switch_325_3: /* CIL Label */ 
          {
          vendor = value;
          }
          goto switch_325_break;
          switch_325_23: /* CIL Label */ 
          {
          model = value;
          }
          goto switch_325_break;
        } else {
          switch_325_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_324_break: /* CIL Label */ ;
  }
  {
  fw_csr_iterator_init(& ci, unit->directory);
  }
  {
  while (1) {
    while_326_continue: /* CIL Label */ ;
    {
    tmp___1 = fw_csr_iterator_next(& ci, & key, & value);
    }
    if (! tmp___1) {
      goto while_326_break;
    }
    if (key == 18) {
      goto switch_327_18;
    } else {
      if (key == 19) {
        goto switch_327_19;
      } else {
        if (0) {
          switch_327_18: /* CIL Label */ 
          {
          specifier_id = value;
          }
          goto switch_327_break;
          switch_327_19: /* CIL Label */ 
          {
          version = value;
          }
          goto switch_327_break;
        } else {
          switch_327_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_326_break: /* CIL Label */ ;
  }
  {
  tmp___2 = snprintf(buffer, buffer_size, "ieee1394:ven%08Xmo%08Xsp%08Xver%08X", vendor,
                     model, specifier_id, version);
  }
  return (tmp___2);
}
}
static int fw_unit_uevent(struct device *dev , struct kobj_uevent_env *env ) 
{ struct fw_unit *unit ;
  struct fw_unit *tmp ;
  char modalias[64] ;
  int tmp___0 ;

  {
  {
  tmp = fw_unit(dev);
  unit = tmp;
  get_modalias(unit, modalias, (unsigned int )sizeof(modalias));
  tmp___0 = add_uevent_var(env, "MODALIAS=%s", modalias);
  }
  if (tmp___0) {
    return (-12);
  }
  return (0);
}
}
struct bus_type fw_bus_type  = 
     {"firewire", (struct bus_attribute *)0, (struct device_attribute *)0, (struct driver_attribute *)0,
    & fw_unit_match, (int (*)(struct device *dev , struct kobj_uevent_env *env ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
    (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ,
                                                                   pm_message_t state ))0,
    (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (struct dev_pm_ops *)0,
    (struct bus_type_private *)0};
static char const   __kstrtab_fw_bus_type[12]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'b', 
        (char const   )'u',      (char const   )'s',      (char const   )'_',      (char const   )'t', 
        (char const   )'y',      (char const   )'p',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_bus_type  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_bus_type), __kstrtab_fw_bus_type};
int fw_device_enable_phys_dma(struct fw_device *device ) 
{ int generation ;
  int tmp ;

  {
  {
  generation = device->generation;
  __asm__  volatile   ("": : : "memory");
  tmp = (*(((device->card)->driver)->enable_phys_dma))(device->card, device->node_id,
                                                       generation);
  }
  return (tmp);
}
}
static char const   __kstrtab_fw_device_enable_phys_dma[26]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'d', 
        (char const   )'e',      (char const   )'v',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )'_',      (char const   )'e',      (char const   )'n', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )'_',      (char const   )'p',      (char const   )'h',      (char const   )'y', 
        (char const   )'s',      (char const   )'_',      (char const   )'d',      (char const   )'m', 
        (char const   )'a',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_device_enable_phys_dma  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_device_enable_phys_dma), __kstrtab_fw_device_enable_phys_dma};
static ssize_t show_immediate(struct device *dev ,
                              struct device_attribute *dattr , char *buf ) 
{ struct config_rom_attribute *attr ;
  struct device_attribute  const  *__mptr ;
  struct fw_csr_iterator ci ;
  u32 *dir ;
  int key ;
  int value ;
  int ret ;
  struct fw_unit *tmp ;
  struct fw_device *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  {
  __mptr = (struct device_attribute  const  *)dattr;
  attr = (struct config_rom_attribute *)((char *)__mptr - (unsigned int )(& ((struct config_rom_attribute *)0)->attr));
  ret = -2;
  down_read(& fw_device_rwsem);
  tmp___1 = is_fw_unit(dev);
  }
  if (tmp___1) {
    {
    tmp = fw_unit(dev);
    dir = tmp->directory;
    }
  } else {
    {
    tmp___0 = fw_device(dev);
    dir = tmp___0->config_rom + 5;
    }
  }
  {
  fw_csr_iterator_init(& ci, dir);
  }
  {
  while (1) {
    while_328_continue: /* CIL Label */ ;
    {
    tmp___3 = fw_csr_iterator_next(& ci, & key, & value);
    }
    if (! tmp___3) {
      goto while_328_break;
    }
    if (attr->key == (u32 )key) {
      if (buf) {
        {
        tmp___2 = 1UL << 12;
        }
      } else {
        {
        tmp___2 = 0UL;
        }
      }
      {
      ret = snprintf(buf, (unsigned int )tmp___2, "0x%06x\n", value);
      }
      goto while_328_break;
    }
  }
  while_328_break: /* CIL Label */ ;
  }
  {
  up_read(& fw_device_rwsem);
  }
  return (ret);
}
}
static ssize_t show_text_leaf(struct device *dev , struct device_attribute *dattr ,
                              char *buf ) 
{ struct config_rom_attribute *attr ;
  struct device_attribute  const  *__mptr ;
  struct fw_csr_iterator ci ;
  u32 *dir ;
  u32 *block ;
  u32 *p ;
  u32 *end ;
  int length ;
  int key ;
  int value ;
  int last_key ;
  int ret ;
  char *b ;
  struct fw_unit *tmp ;
  struct fw_device *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u32 _min1 ;
  unsigned int _min2 ;
  u32 tmp___3 ;
  __u32 tmp___4 ;
  int tmp___5 ;

  {
  {
  __mptr = (struct device_attribute  const  *)dattr;
  attr = (struct config_rom_attribute *)((char *)__mptr - (unsigned int )(& ((struct config_rom_attribute *)0)->attr));
  block = (u32 *)((void *)0);
  last_key = 0;
  ret = -2;
  down_read(& fw_device_rwsem);
  tmp___1 = is_fw_unit(dev);
  }
  if (tmp___1) {
    {
    tmp = fw_unit(dev);
    dir = tmp->directory;
    }
  } else {
    {
    tmp___0 = fw_device(dev);
    dir = tmp___0->config_rom + 5;
    }
  }
  {
  fw_csr_iterator_init(& ci, dir);
  }
  {
  while (1) {
    while_329_continue: /* CIL Label */ ;
    {
    tmp___2 = fw_csr_iterator_next(& ci, & key, & value);
    }
    if (! tmp___2) {
      goto while_329_break;
    }
    if (attr->key == (u32 )last_key) {
      if (key == 129) {
        {
        block = (ci.p - 1) + value;
        }
      }
    }
    {
    last_key = key;
    }
  }
  while_329_break: /* CIL Label */ ;
  }
  if ((unsigned long )block == (unsigned long )((void *)0)) {
    goto out;
  }
  {
  _min1 = *(block + 0) >> 16;
  _min2 = 256U;
  }
  if (_min1 < _min2) {
    {
    tmp___3 = _min1;
    }
  } else {
    {
    tmp___3 = _min2;
    }
  }
  {
  length = (int )tmp___3;
  }
  if (length < 3) {
    goto out;
  }
  if (*(block + 1) != 0U) {
    goto out;
  } else {
    if (*(block + 2) != 0U) {
      goto out;
    }
  }
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
    ret = length * 4;
    }
    goto out;
  }
  {
  b = buf;
  end = block + (length + 1);
  p = block + 3;
  }
  {
  while (1) {
    while_330_continue: /* CIL Label */ ;
    if (! ((unsigned long )p < (unsigned long )end)) {
      goto while_330_break;
    }
    {
    tmp___4 = __fswab32(*p);
    *((u32 *)b) = tmp___4;
    p ++;
    b += 4;
    }
  }
  while_330_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_331_continue: /* CIL Label */ ;
    {
    b --;
    }
    if (((int )_ctype[(int )((unsigned char )*b)] & 32) != 0) {
      goto _L;
    } else {
      if ((int )*b == 0) {
        _L: /* CIL Label */ 
        if ((unsigned long )b > (unsigned long )buf) {
          {
          tmp___5 = 1;
          }
        } else {
          {
          tmp___5 = 0;
          }
        }
      } else {
        {
        tmp___5 = 0;
        }
      }
    }
    if (! tmp___5) {
      goto while_331_break;
    }
  }
  while_331_break: /* CIL Label */ ;
  }
  {
  strcpy(b + 1, "\n");
  ret = (b + 2) - buf;
  }
  out: 
  {
  up_read(& fw_device_rwsem);
  }
  return (ret);
}
}
static struct config_rom_attribute config_rom_attributes[8]  = 
  {      {{{"vendor", (struct module *)0, (mode_t )292}, & show_immediate, (ssize_t (*)(struct device *dev ,
                                                                                    struct device_attribute *attr ,
                                                                                    char const   *buf ,
                                                                                    size_t count ))((void *)0)},
      (u32 )3}, 
        {{{"hardware_version", (struct module *)0, (mode_t )292}, & show_immediate, (ssize_t (*)(struct device *dev ,
                                                                                              struct device_attribute *attr ,
                                                                                              char const   *buf ,
                                                                                              size_t count ))((void *)0)},
      (u32 )4}, 
        {{{"specifier_id", (struct module *)0, (mode_t )292}, & show_immediate, (ssize_t (*)(struct device *dev ,
                                                                                          struct device_attribute *attr ,
                                                                                          char const   *buf ,
                                                                                          size_t count ))((void *)0)},
      (u32 )18}, 
        {{{"version", (struct module *)0, (mode_t )292}, & show_immediate, (ssize_t (*)(struct device *dev ,
                                                                                     struct device_attribute *attr ,
                                                                                     char const   *buf ,
                                                                                     size_t count ))((void *)0)},
      (u32 )19}, 
        {{{"model", (struct module *)0, (mode_t )292}, & show_immediate, (ssize_t (*)(struct device *dev ,
                                                                                   struct device_attribute *attr ,
                                                                                   char const   *buf ,
                                                                                   size_t count ))((void *)0)},
      (u32 )23}, 
        {{{"vendor_name", (struct module *)0, (mode_t )292}, & show_text_leaf, (ssize_t (*)(struct device *dev ,
                                                                                         struct device_attribute *attr ,
                                                                                         char const   *buf ,
                                                                                         size_t count ))((void *)0)},
      (u32 )3}, 
        {{{"model_name", (struct module *)0, (mode_t )292}, & show_text_leaf, (ssize_t (*)(struct device *dev ,
                                                                                        struct device_attribute *attr ,
                                                                                        char const   *buf ,
                                                                                        size_t count ))((void *)0)},
      (u32 )23}, 
        {{{"hardware_version_name", (struct module *)0, (mode_t )292}, & show_text_leaf,
       (ssize_t (*)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ))((void *)0)}, (u32 )4}};
static void init_fw_attribute_group(struct device *dev , struct device_attribute *attrs ,
                                    struct fw_attribute_group *group ) 
{ struct device_attribute *attr ;
  int i ;
  int j ;
  ssize_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  {
  j = 0;
  }
  {
  while (1) {
    while_332_continue: /* CIL Label */ ;
    if (! ((unsigned long )(attrs + j)->attr.name != (unsigned long )((void *)0))) {
      goto while_332_break;
    }
    {
    group->attrs[j] = & (attrs + j)->attr;
    j ++;
    }
  }
  while_332_break: /* CIL Label */ ;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_333_continue: /* CIL Label */ ;
    if (! ((unsigned long )i < sizeof(config_rom_attributes) / sizeof(config_rom_attributes[0]))) {
      goto while_333_break;
    }
    {
    attr = & config_rom_attributes[i].attr;
    tmp = (*(attr->show))(dev, attr, (char *)((void *)0));
    }
    if (tmp < 0) {
      goto __Cont;
    }
    {
    tmp___0 = j;
    j ++;
    group->attrs[tmp___0] = & attr->attr;
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_333_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_334_continue: /* CIL Label */ ;
    {
    tmp___1 = __builtin_expect((long )(! (! ((unsigned long )j >= sizeof(group->attrs) / sizeof(group->attrs[0])))),
                               0L);
    }
    if (tmp___1) {
      {
      while (1) {
        while_335_continue: /* CIL Label */ ;
        {
        __asm__  volatile   ("1:\tud2\n"
                             ".pushsection __bug_table,\"a\"\n"
                             "2:\t.long 1b, %c0\n"
                             "\t.word %c1, 0\n"
                             "\t.org 2b+%c2\n"
                             ".popsection": : "i" ("fw-device.c"), "i" (295), "i" (sizeof(struct bug_entry )));
        }
        {
        while (1) {
          while_336_continue: /* CIL Label */ ;
        }
        while_336_break: /* CIL Label */ ;
        }
        goto while_335_break;
      }
      while_335_break: /* CIL Label */ ;
      }
    }
    goto while_334_break;
  }
  while_334_break: /* CIL Label */ ;
  }
  {
  tmp___2 = j;
  j ++;
  group->attrs[tmp___2] = (struct attribute *)((void *)0);
  group->groups[0] = & group->group;
  group->groups[1] = (struct attribute_group *)((void *)0);
  group->group.attrs = group->attrs;
  dev->groups = group->groups;
  }
  return;
}
}
static ssize_t modalias_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ struct fw_unit *unit ;
  struct fw_unit *tmp ;
  int length ;

  {
  {
  tmp = fw_unit(dev);
  unit = tmp;
  length = get_modalias(unit, buf, (unsigned int )(1UL << 12));
  strcpy(buf + length, "\n");
  }
  return (length + 1);
}
}
static ssize_t rom_index_show(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ struct fw_device *device ;
  struct fw_device *tmp ;
  struct fw_unit *unit ;
  struct fw_unit *tmp___0 ;
  int tmp___1 ;

  {
  {
  tmp = fw_device(dev->parent);
  device = tmp;
  tmp___0 = fw_unit(dev);
  unit = tmp___0;
  tmp___1 = snprintf(buf, (unsigned int )(1UL << 12), "%d\n", unit->directory - device->config_rom);
  }
  return (tmp___1);
}
}
static struct device_attribute fw_unit_attributes[3]  = {      {{"modalias", (struct module *)0, (mode_t )292}, & modalias_show, (ssize_t (*)(struct device *dev ,
                                                                                    struct device_attribute *attr ,
                                                                                    char const   *buf ,
                                                                                    size_t count ))0}, 
        {{"rom_index",
       (struct module *)0, (mode_t )292}, & rom_index_show, (ssize_t (*)(struct device *dev ,
                                                                         struct device_attribute *attr ,
                                                                         char const   *buf ,
                                                                         size_t count ))0}, 
        {{(char const   *)((void *)0),
       (struct module *)0, (unsigned short)0}, (ssize_t (*)(struct device *dev , struct device_attribute *attr ,
                                                            char *buf ))0, (ssize_t (*)(struct device *dev ,
                                                                                        struct device_attribute *attr ,
                                                                                        char const   *buf ,
                                                                                        size_t count ))0}};
static ssize_t config_rom_show(struct device *dev ,
                               struct device_attribute *attr , char *buf ) 
{ struct fw_device *device ;
  struct fw_device *tmp ;
  size_t length ;

  {
  {
  tmp = fw_device(dev);
  device = tmp;
  down_read(& fw_device_rwsem);
  length = device->config_rom_length * 4U;
  __memcpy((void *)buf, (void const   *)device->config_rom, length);
  up_read(& fw_device_rwsem);
  }
  return ((int )length);
}
}
static ssize_t guid_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ struct fw_device *device ;
  struct fw_device *tmp ;
  int ret ;

  {
  {
  tmp = fw_device(dev);
  device = tmp;
  down_read(& fw_device_rwsem);
  ret = snprintf(buf, (unsigned int )(1UL << 12), "0x%08x%08x\n", *(device->config_rom + 3),
                 *(device->config_rom + 4));
  up_read(& fw_device_rwsem);
  }
  return (ret);
}
}
static struct device_attribute fw_device_attributes[3]  = {      {{"config_rom", (struct module *)0, (mode_t )292}, & config_rom_show, (ssize_t (*)(struct device *dev ,
                                                                                        struct device_attribute *attr ,
                                                                                        char const   *buf ,
                                                                                        size_t count ))0}, 
        {{"guid",
       (struct module *)0, (mode_t )292}, & guid_show, (ssize_t (*)(struct device *dev ,
                                                                    struct device_attribute *attr ,
                                                                    char const   *buf ,
                                                                    size_t count ))0}, 
        {{(char const   *)((void *)0),
       (struct module *)0, (unsigned short)0}, (ssize_t (*)(struct device *dev , struct device_attribute *attr ,
                                                            char *buf ))0, (ssize_t (*)(struct device *dev ,
                                                                                        struct device_attribute *attr ,
                                                                                        char const   *buf ,
                                                                                        size_t count ))0}};
static int read_rom(struct fw_device *device ,
                    int generation , int index___0 , u32 *data ) 
{ int rcode ;

  {
  {
  __asm__  volatile   ("": : : "memory");
  rcode = fw_run_transaction(device->card, 4, device->node_id, generation, (int )device->max_speed,
                             281474708276224ULL + (unsigned long long )(index___0 * 4),
                             (void *)data, 4U);
  __swab32s(data);
  }
  return (rcode);
}
}
static int read_bus_info_block(struct fw_device *device , int generation ) 
{ u32 *rom ;
  u32 *stack ;
  u32 *old_rom ;
  u32 *new_rom ;
  u32 sp ;
  u32 key ;
  int i ;
  int end ;
  int length ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  u32 dummy ;
  int tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u32 tmp___5 ;
  void *tmp___6 ;

  {
  {
  ret = -1;
  tmp = kmalloc((unsigned int )(sizeof(*rom) * 256UL + sizeof(*stack) * 16UL), 208U);
  rom = (u32 *)tmp;
  }
  if ((unsigned long )rom == (unsigned long )((void *)0)) {
    return (-12);
  }
  {
  stack = rom + 256;
  device->max_speed = 0U;
  i = 0;
  }
  {
  while (1) {
    while_337_continue: /* CIL Label */ ;
    if (! (i < 5)) {
      goto while_337_break;
    }
    {
    tmp___0 = read_rom(device, generation, i, rom + i);
    }
    if (tmp___0 != 0) {
      goto out;
    }
    if (i == 0) {
      if (*(rom + i) == 0U) {
        goto out;
      }
    }
    {
    i ++;
    }
  }
  while_337_break: /* CIL Label */ ;
  }
  {
  device->max_speed = (unsigned int )(device->node)->max_speed;
  }
  if ((*(rom + 2) & 7U) < device->max_speed) {
    goto _L;
  } else {
    if (device->max_speed == 3U) {
      goto _L;
    } else {
      if ((device->card)->beta_repeaters_present) {
        _L: /* CIL Label */ 
        if (device->max_speed == 3U) {
          {
          device->max_speed = (unsigned int )(device->card)->link_speed;
          }
        }
        {
        while (1) {
          while_338_continue: /* CIL Label */ ;
          if (! (device->max_speed > 0U)) {
            goto while_338_break;
          }
          {
          tmp___1 = read_rom(device, generation, 0, & dummy);
          }
          if (tmp___1 == 0) {
            goto while_338_break;
          }
          {
          (device->max_speed) --;
          }
        }
        while_338_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
  length = i;
  sp = 0U;
  tmp___2 = sp;
  sp ++;
  *(stack + tmp___2) = 3221225477U;
  }
  {
  while (1) {
    while_339_continue: /* CIL Label */ ;
    if (! (sp > 0U)) {
      goto while_339_break;
    }
    {
    sp --;
    key = *(stack + sp);
    i = (int )(key & 16777215U);
    }
    if (i >= 256) {
      goto out;
    }
    {
    tmp___3 = read_rom(device, generation, i, rom + i);
    }
    if (tmp___3 != 0) {
      goto out;
    }
    {
    end = (int )(((u32 )i + (*(rom + i) >> 16)) + 1U);
    i ++;
    }
    if (end > 256) {
      goto out;
    }
    {
    while (1) {
      while_340_continue: /* CIL Label */ ;
      if (! (i < end)) {
        goto while_340_break;
      }
      {
      tmp___4 = read_rom(device, generation, i, rom + i);
      }
      if (tmp___4 != 0) {
        goto out;
      }
      if (key >> 30 == 3U) {
        if (*(rom + i) >> 30 > 1U) {
          if (sp < 16U) {
            {
            tmp___5 = sp;
            sp ++;
            *(stack + tmp___5) = (u32 )i + *(rom + i);
            }
          }
        }
      }
      {
      i ++;
      }
    }
    while_340_break: /* CIL Label */ ;
    }
    if (length < i) {
      {
      length = i;
      }
    }
  }
  while_339_break: /* CIL Label */ ;
  }
  {
  old_rom = device->config_rom;
  tmp___6 = kmemdup((void const   *)rom, (unsigned int )(length * 4), 208U);
  new_rom = (u32 *)tmp___6;
  }
  if ((unsigned long )new_rom == (unsigned long )((void *)0)) {
    goto out;
  }
  {
  down_write(& fw_device_rwsem);
  device->config_rom = new_rom;
  device->config_rom_length = (unsigned int )length;
  up_write(& fw_device_rwsem);
  kfree((void const   *)old_rom);
  ret = 0;
  device->cmc = (*(rom + 2) >> 30) & 1U;
  }
  out: 
  {
  kfree((void const   *)rom);
  }
  return (ret);
}
}
static void fw_unit_release(struct device *dev ) 
{ struct fw_unit *unit ;
  struct fw_unit *tmp ;

  {
  {
  tmp = fw_unit(dev);
  unit = tmp;
  kfree((void const   *)unit);
  }
  return;
}
}
static struct device_type fw_unit_type  =    {(char const   *)0, (struct attribute_group **)0, & fw_unit_uevent, & fw_unit_release,
    (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
    (struct dev_pm_ops *)0};
static int is_fw_unit(struct device *dev ) 
{ 

  {
  return ((unsigned long )dev->type == (unsigned long )(& fw_unit_type));
}
}
static void create_units(struct fw_device *device ) 
{ struct fw_csr_iterator ci ;
  struct fw_unit *unit ;
  int key ;
  int value ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  i = 0;
  fw_csr_iterator_init(& ci, device->config_rom + 5);
  }
  {
  while (1) {
    while_341_continue: /* CIL Label */ ;
    {
    tmp___3 = fw_csr_iterator_next(& ci, & key, & value);
    }
    if (! tmp___3) {
      goto while_341_break;
    }
    if (key != 209) {
      goto while_341_continue;
    }
    {
    tmp = kzalloc((unsigned int )sizeof(*unit), 208U);
    unit = (struct fw_unit *)tmp;
    }
    if ((unsigned long )unit == (unsigned long )((void *)0)) {
      {
      printk("<3>SomeModule: failed to allocate memory for unit\n");
      }
      goto while_341_continue;
    }
    {
    unit->directory = (ci.p + value) - 1;
    unit->device.bus = & fw_bus_type;
    unit->device.type = & fw_unit_type;
    unit->device.parent = & device->device;
    tmp___0 = i;
    i ++;
    tmp___1 = dev_name((struct device  const  *)(& device->device));
    dev_set_name(& unit->device, "%s.%d", tmp___1, tmp___0);
    init_fw_attribute_group(& unit->device, fw_unit_attributes, & unit->attribute_group);
    tmp___2 = device_register(& unit->device);
    }
    if (tmp___2 < 0) {
      goto skip_unit;
    }
    goto while_341_continue;
    skip_unit: 
    {
    kfree((void const   *)unit);
    }
  }
  while_341_break: /* CIL Label */ ;
  }
  return;
}
}
static int shutdown_unit(struct device *device , void *data ) 
{ 

  {
  {
  device_unregister(device);
  }
  return (0);
}
}
struct rw_semaphore fw_device_rwsem  =    {0L, {{0U}}, {& fw_device_rwsem.wait_list, & fw_device_rwsem.wait_list}};
struct idr fw_device_idr  =    {(struct idr_layer *)((void *)0), (struct idr_layer *)((void *)0), 0, 0, {{0U}}};
struct fw_device *fw_device_get_by_devt(dev_t devt ) 
{ struct fw_device *device ;
  void *tmp ;

  {
  {
  down_read(& fw_device_rwsem);
  tmp = idr_find(& fw_device_idr, (int )(devt & ((1U << 20) - 1U)));
  device = (struct fw_device *)tmp;
  }
  if (device) {
    {
    fw_device_get(device);
    }
  }
  {
  up_read(& fw_device_rwsem);
  }
  return (device);
}
}
static void fw_device_shutdown(struct work_struct *work ) 
{ struct fw_device *device ;
  struct work_struct  const  *__mptr ;
  int minor ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long volatile   __dummy2___0 ;
  int tmp ;
  unsigned long tmp___0 ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  device = (struct fw_device *)((char *)__mptr - (unsigned int )(& ((struct fw_device *)0)->work.work));
  minor = (int )(device->device.devt & ((1U << 20) - 1U));
  }
  if ((long )jiffies - (long )((device->card)->reset_jiffies + 2000UL) < 0L) {
    {
    tmp = list_empty((struct list_head  const  *)(& (device->card)->link));
    }
    if (! tmp) {
      {
      schedule_delayed_work(& device->work, 2000UL);
      }
      return;
    }
  }
  {
  tmp___0 = __cmpxchg((void volatile   *)(& device->state.counter), 2UL, 3UL, (int )sizeof(device->state.counter));
  }
  if ((int volatile   )tmp___0 != (int volatile   )2) {
    return;
  }
  {
  fw_device_cdev_remove(device);
  device_for_each_child(& device->device, (void *)0, & shutdown_unit);
  device_unregister(& device->device);
  down_write(& fw_device_rwsem);
  idr_remove(& fw_device_idr, minor);
  up_write(& fw_device_rwsem);
  fw_device_put(device);
  }
  return;
}
}
static void fw_device_release(struct device *dev ) 
{ struct fw_device *device ;
  struct fw_device *tmp ;
  struct fw_card *card ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  tmp = fw_device(dev);
  device = tmp;
  card = device->card;
  }
  {
  while (1) {
    while_342_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_342_break;
  }
  while_342_break: /* CIL Label */ ;
  }
  {
  (device->node)->data = (void *)0;
  }
  {
  while (1) {
    while_343_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_343_break;
  }
  while_343_break: /* CIL Label */ ;
  }
  {
  fw_node_put(device->node);
  kfree((void const   *)device->config_rom);
  kfree((void const   *)device);
  fw_card_put(card);
  }
  return;
}
}
static struct device_type fw_device_type  =    {(char const   *)0, (struct attribute_group **)0, (int (*)(struct device *dev ,
                                                              struct kobj_uevent_env *env ))0,
    & fw_device_release, (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
    (struct dev_pm_ops *)0};
static int update_unit(struct device *dev , void *data ) 
{ struct fw_unit *unit ;
  struct fw_unit *tmp ;
  struct fw_driver *driver ;
  int tmp___0 ;

  {
  {
  tmp = fw_unit(dev);
  unit = tmp;
  driver = (struct fw_driver *)dev->driver;
  tmp___0 = is_fw_unit(dev);
  }
  if (tmp___0) {
    if ((unsigned long )driver != (unsigned long )((void *)0)) {
      if ((unsigned long )driver->update != (unsigned long )((void *)0)) {
        {
        down(& dev->sem);
        (*(driver->update))(unit);
        up(& dev->sem);
        }
      }
    }
  }
  return (0);
}
}
static void fw_device_update(struct work_struct *work ) 
{ struct fw_device *device ;
  struct work_struct  const  *__mptr ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  device = (struct fw_device *)((char *)__mptr - (unsigned int )(& ((struct fw_device *)0)->work.work));
  fw_device_cdev_update(device);
  device_for_each_child(& device->device, (void *)0, & update_unit);
  }
  return;
}
}
static int lookup_existing_device(struct device *dev , void *data ) 
{ struct fw_device *old ;
  struct fw_device *tmp ;
  struct fw_device *new ;
  struct fw_card *card ;
  int match ;
  struct fw_node *current_node ;
  struct fw_node *obsolete_node ;
  char const   *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
  tmp = fw_device(dev);
  old = tmp;
  new = (struct fw_device *)data;
  card = new->card;
  match = 0;
  down_read(& fw_device_rwsem);
  _spin_lock_irq(& card->lock);
  tmp___1 = __builtin_memcmp((void const   *)old->config_rom, (void const   *)new->config_rom,
                             24U);
  }
  if (tmp___1 == 0) {
    {
    tmp___2 = __cmpxchg((void volatile   *)(& old->state.counter), 2UL, 1UL, (int )sizeof(old->state.counter));
    }
    if ((int volatile   )tmp___2 == (int volatile   )2) {
      {
      current_node = new->node;
      obsolete_node = old->node;
      new->node = obsolete_node;
      (new->node)->data = (void *)new;
      old->node = current_node;
      (old->node)->data = (void *)old;
      old->max_speed = new->max_speed;
      old->node_id = (int )current_node->node_id;
      __asm__  volatile   ("": : : "memory");
      old->generation = card->generation;
      old->config_rom_retries = 0;
      tmp___0 = dev_name((struct device  const  *)dev);
      printk("<5>SomeModule: rediscovered device %s\n", tmp___0);
      }
      {
      while (1) {
        while_344_continue: /* CIL Label */ ;
        {
        old->work.work.func = & fw_device_update;
        }
        goto while_344_break;
      }
      while_344_break: /* CIL Label */ ;
      }
      {
      schedule_delayed_work(& old->work, 0UL);
      }
      if ((unsigned long )current_node == (unsigned long )card->root_node) {
        {
        fw_schedule_bm_work(card, 0UL);
        }
      }
      {
      match = 1;
      }
    }
  }
  {
  while (1) {
    while_345_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& card->lock.raw_lock);
    }
    {
    while (1) {
      while_346_continue: /* CIL Label */ ;
      {
      while (1) {
        while_347_continue: /* CIL Label */ ;
        goto while_347_break;
      }
      while_347_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_346_break;
    }
    while_346_break: /* CIL Label */ ;
    }
    goto while_345_break;
  }
  while_345_break: /* CIL Label */ ;
  }
  {
  up_read(& fw_device_rwsem);
  }
  return (match);
}
}
void fw_device_set_broadcast_channel(struct fw_device *device , int generation ) 
{ struct fw_card *card ;
  __be32 data ;
  int rcode ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  {
  card = device->card;
  }
  if (! card->broadcast_channel_allocated) {
    return;
  }
  if (device->bc_implemented == 0U) {
    {
    rcode = fw_run_transaction(card, 4, device->node_id, generation, (int )device->max_speed,
                               281474708275764ULL, (void *)(& data), 4U);
    }
    if (rcode == 0) {
      goto switch_348_0;
    } else {
      if (rcode == 7) {
        goto switch_348_7;
      } else {
        if (0) {
          switch_348_0: /* CIL Label */ 
          if (data & ((((((unsigned int )(1 << 31) & 255U) << 24) | (((unsigned int )(1 << 31) & 65280U) << 8)) | (((unsigned int )(1 << 31) & 16711680U) >> 8)) | (((unsigned int )(1 << 31) & 4278190080U) >> 24))) {
            {
            device->bc_implemented = 2U;
            }
            goto switch_348_break;
          }
          switch_348_7: /* CIL Label */ 
          {
          device->bc_implemented = 1U;
          }
        } else {
          switch_348_break: /* CIL Label */ ;
        }
      }
    }
  }
  if (device->bc_implemented == 2U) {
    {
    data = (((((unsigned int )(((1 << 31) | 31) | (1 << 30)) & 255U) << 24) | (((unsigned int )(((1 << 31) | 31) | (1 << 30)) & 65280U) << 8)) | (((unsigned int )(((1 << 31) | 31) | (1 << 30)) & 16711680U) >> 8)) | (((unsigned int )(((1 << 31) | 31) | (1 << 30)) & 4278190080U) >> 24);
    fw_run_transaction(card, 0, device->node_id, generation, (int )device->max_speed,
                       281474708275764ULL, (void *)(& data), 4U);
    }
  }
  return;
}
}
static void fw_device_init(struct work_struct *work ) 
{ struct fw_device *device ;
  struct work_struct  const  *__mptr ;
  struct device *revived_dev ;
  int minor ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  unsigned long tmp___6 ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  device = (struct fw_device *)((char *)__mptr - (unsigned int )(& ((struct fw_device *)0)->work.work));
  tmp = read_bus_info_block(device, device->generation);
  }
  if (tmp < 0) {
    if (device->config_rom_retries < 10) {
      if (device->state.counter == (int volatile   )0) {
        {
        (device->config_rom_retries) ++;
        schedule_delayed_work(& device->work, 3000UL);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
      printk("<5>SomeModule: giving up on config rom for node id %x\n", device->node_id);
      }
      if ((unsigned long )device->node == (unsigned long )(device->card)->root_node) {
        {
        fw_schedule_bm_work(device->card, 0UL);
        }
      }
      {
      fw_device_release(& device->device);
      }
    }
    return;
  }
  {
  revived_dev = device_find_child((device->card)->device, (void *)device, & lookup_existing_device);
  }
  if (revived_dev) {
    {
    put_device(revived_dev);
    fw_device_release(& device->device);
    }
    return;
  }
  {
  device_initialize(& device->device);
  fw_device_get(device);
  down_write(& fw_device_rwsem);
  tmp___2 = idr_pre_get(& fw_device_idr, 208U);
  }
  if (tmp___2) {
    {
    tmp___1 = idr_get_new(& fw_device_idr, (void *)device, & minor);
    ret = tmp___1;
    }
  } else {
    {
    ret = -12;
    }
  }
  {
  up_write(& fw_device_rwsem);
  }
  if (ret < 0) {
    goto error;
  }
  {
  device->device.bus = & fw_bus_type;
  device->device.type = & fw_device_type;
  device->device.parent = (device->card)->device;
  device->device.devt = (unsigned int )((fw_cdev_major << 20) | minor);
  dev_set_name(& device->device, "fw%d", minor);
  init_fw_attribute_group(& device->device, fw_device_attributes, & device->attribute_group);
  tmp___3 = device_add(& device->device);
  }
  if (tmp___3) {
    {
    printk("<3>SomeModule: Failed to add device.\n");
    }
    goto error_with_cdev;
  }
  {
  create_units(device);
  tmp___6 = __cmpxchg((void volatile   *)(& device->state.counter), 0UL, 1UL, (int )sizeof(device->state.counter));
  }
  if ((int volatile   )tmp___6 == (int volatile   )2) {
    {
    while (1) {
      while_349_continue: /* CIL Label */ ;
      {
      device->work.work.func = & fw_device_shutdown;
      }
      goto while_349_break;
    }
    while_349_break: /* CIL Label */ ;
    }
    {
    schedule_delayed_work(& device->work, 2000UL);
    }
  } else {
    if (device->config_rom_retries) {
      {
      tmp___4 = dev_name((struct device  const  *)(& device->device));
      printk("<5>SomeModule: created device %s: GUID %08x%08x, S%d00, %d config ROM retries\n",
             tmp___4, *(device->config_rom + 3), *(device->config_rom + 4), 1 << device->max_speed,
             device->config_rom_retries);
      }
    } else {
      {
      tmp___5 = dev_name((struct device  const  *)(& device->device));
      printk("<5>SomeModule: created device %s: GUID %08x%08x, S%d00\n", tmp___5,
             *(device->config_rom + 3), *(device->config_rom + 4), 1 << device->max_speed);
      }
    }
    {
    device->config_rom_retries = 0;
    fw_device_set_broadcast_channel(device, device->generation);
    }
  }
  if ((unsigned long )device->node == (unsigned long )(device->card)->root_node) {
    {
    fw_schedule_bm_work(device->card, 0UL);
    }
  }
  return;
  error_with_cdev: 
  {
  down_write(& fw_device_rwsem);
  idr_remove(& fw_device_idr, minor);
  up_write(& fw_device_rwsem);
  }
  error: 
  {
  fw_device_put(device);
  put_device(& device->device);
  }
  return;
}
}
static int reread_bus_info_block(struct fw_device *device , int generation ) 
{ u32 q ;
  int i ;
  int tmp ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_350_continue: /* CIL Label */ ;
    if (! (i < 6)) {
      goto while_350_break;
    }
    {
    tmp = read_rom(device, generation, i, & q);
    }
    if (tmp != 0) {
      return (0);
    }
    if (i == 0) {
      if (q == 0U) {
        return (1);
      }
    }
    if (q != *(device->config_rom + i)) {
      return (3);
    }
    {
    i ++;
    }
  }
  while_350_break: /* CIL Label */ ;
  }
  return (2);
}
}
static void fw_device_refresh(struct work_struct *work ) 
{ struct fw_device *device ;
  struct work_struct  const  *__mptr ;
  struct fw_card *card ;
  int node_id ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
  __mptr = (struct work_struct  const  *)work;
  device = (struct fw_device *)((char *)__mptr - (unsigned int )(& ((struct fw_device *)0)->work.work));
  card = device->card;
  node_id = device->node_id;
  tmp = reread_bus_info_block(device, device->generation);
  }
  if (tmp == 0) {
    goto switch_351_0;
  } else {
    if (tmp == 1) {
      goto switch_351_1;
    } else {
      if (tmp == 2) {
        goto switch_351_2;
      } else {
        if (tmp == 3) {
          goto switch_351_3;
        } else {
          if (0) {
            switch_351_0: /* CIL Label */ 
            if (device->config_rom_retries < 5) {
              if (device->state.counter == (int volatile   )0) {
                {
                (device->config_rom_retries) ++;
                schedule_delayed_work(& device->work, 1500UL);
                }
                return;
              }
            }
            goto give_up;
            switch_351_1: /* CIL Label */ 
            goto gone;
            switch_351_2: /* CIL Label */ 
            {
            tmp___0 = __cmpxchg((void volatile   *)(& device->state.counter), 0UL,
                                1UL, (int )sizeof(device->state.counter));
            }
            if ((int volatile   )tmp___0 == (int volatile   )2) {
              goto gone;
            }
            {
            fw_device_update(work);
            device->config_rom_retries = 0;
            }
            goto out;
            switch_351_3: /* CIL Label */ 
            goto switch_351_break;
          } else {
            switch_351_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
  device_for_each_child(& device->device, (void *)0, & shutdown_unit);
  tmp___1 = read_bus_info_block(device, device->generation);
  }
  if (tmp___1 < 0) {
    if (device->config_rom_retries < 10) {
      if (device->state.counter == (int volatile   )0) {
        {
        (device->config_rom_retries) ++;
        schedule_delayed_work(& device->work, 3000UL);
        }
        return;
      }
    }
    goto give_up;
  }
  {
  create_units(device);
  tmp___2 = __cmpxchg((void volatile   *)(& device->state.counter), 0UL, 1UL, (int )sizeof(device->state.counter));
  }
  if ((int volatile   )tmp___2 == (int volatile   )2) {
    goto gone;
  }
  {
  tmp___3 = dev_name((struct device  const  *)(& device->device));
  printk("<5>SomeModule: refreshed device %s\n", tmp___3);
  device->config_rom_retries = 0;
  }
  goto out;
  give_up: 
  {
  tmp___4 = dev_name((struct device  const  *)(& device->device));
  printk("<5>SomeModule: giving up on refresh of device %s\n", tmp___4);
  }
  gone: 
  {
  device->state.counter = (int volatile   )2;
  }
  {
  while (1) {
    while_352_continue: /* CIL Label */ ;
    {
    device->work.work.func = & fw_device_shutdown;
    }
    goto while_352_break;
  }
  while_352_break: /* CIL Label */ ;
  }
  {
  schedule_delayed_work(& device->work, 2000UL);
  }
  out: 
  if (node_id == (int )(card->root_node)->node_id) {
    {
    fw_schedule_bm_work(card, 0UL);
    }
  }
  return;
}
}
static struct lock_class_key __key___2  ;
void fw_node_event(struct fw_card *card , struct fw_node *node , int event ) 
{ struct fw_device *device ;
  void *tmp ;
  atomic_long_t __constr_expr_0 ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
  if (event == 0) {
    goto switch_353_0;
  } else {
    if (event == 3) {
      goto switch_353_0;
    } else {
      if (event == 5) {
        goto switch_353_5;
      } else {
        if (event == 1) {
          goto switch_353_1;
        } else {
          if (event == 2) {
            goto switch_353_2;
          } else {
            if (event == 4) {
              goto switch_353_2;
            } else {
              if (0) {
                switch_353_0: /* CIL Label */ 
                switch_353_3: /* CIL Label */ 
                if (! node->link_on) {
                  goto switch_353_break;
                }
                create: 
                {
                tmp = kzalloc((unsigned int )sizeof(*device), 32U);
                device = (struct fw_device *)tmp;
                }
                if ((unsigned long )device == (unsigned long )((void *)0)) {
                  goto switch_353_break;
                }
                {
                device->state.counter = (int volatile   )0;
                device->card = fw_card_get(card);
                device->node = fw_node_get(node);
                device->node_id = (int )node->node_id;
                device->generation = card->generation;
                }
                {
                while (1) {
                  while_354_continue: /* CIL Label */ ;
                  {
                  __mutex_init(& device->client_list_mutex, "&device->client_list_mutex",
                               & __key___2);
                  }
                  goto while_354_break;
                }
                while_354_break: /* CIL Label */ ;
                }
                {
                INIT_LIST_HEAD(& device->client_list);
                node->data = (void *)device;
                }
                {
                while (1) {
                  while_355_continue: /* CIL Label */ ;
                  {
                  while (1) {
                    while_356_continue: /* CIL Label */ ;
                    {
                    __constr_expr_0.counter = (int volatile   )0;
                    device->work.work.data = __constr_expr_0;
                    INIT_LIST_HEAD(& device->work.work.entry);
                    }
                    {
                    while (1) {
                      while_357_continue: /* CIL Label */ ;
                      {
                      device->work.work.func = & fw_device_init;
                      }
                      goto while_357_break;
                    }
                    while_357_break: /* CIL Label */ ;
                    }
                    goto while_356_break;
                  }
                  while_356_break: /* CIL Label */ ;
                  }
                  {
                  init_timer_key(& device->work.timer, (char const   *)((void *)0),
                                 (struct lock_class_key *)((void *)0));
                  }
                  goto while_355_break;
                }
                while_355_break: /* CIL Label */ ;
                }
                {
                schedule_delayed_work(& device->work, 500UL);
                }
                goto switch_353_break;
                switch_353_5: /* CIL Label */ 
                {
                device = (struct fw_device *)node->data;
                }
                if ((unsigned long )device == (unsigned long )((void *)0)) {
                  goto create;
                }
                {
                device->node_id = (int )node->node_id;
                __asm__  volatile   ("": : : "memory");
                device->generation = card->generation;
                tmp___1 = __cmpxchg((void volatile   *)(& device->state.counter),
                                    1UL, 0UL, (int )sizeof(device->state.counter));
                }
                if ((int volatile   )tmp___1 == (int volatile   )1) {
                  {
                  while (1) {
                    while_358_continue: /* CIL Label */ ;
                    {
                    device->work.work.func = & fw_device_refresh;
                    }
                    goto while_358_break;
                  }
                  while_358_break: /* CIL Label */ ;
                  }
                  if ((unsigned long )node == (unsigned long )card->local_node) {
                    {
                    tmp___0 = 0;
                    }
                  } else {
                    {
                    tmp___0 = 500;
                    }
                  }
                  {
                  schedule_delayed_work(& device->work, (unsigned long )tmp___0);
                  }
                }
                goto switch_353_break;
                switch_353_1: /* CIL Label */ 
                if (! node->link_on) {
                  goto switch_353_break;
                } else {
                  if ((unsigned long )node->data == (unsigned long )((void *)0)) {
                    goto switch_353_break;
                  }
                }
                {
                device = (struct fw_device *)node->data;
                device->node_id = (int )node->node_id;
                __asm__  volatile   ("": : : "memory");
                device->generation = card->generation;
                }
                if (device->state.counter == (int volatile   )1) {
                  {
                  while (1) {
                    while_359_continue: /* CIL Label */ ;
                    {
                    device->work.work.func = & fw_device_update;
                    }
                    goto while_359_break;
                  }
                  while_359_break: /* CIL Label */ ;
                  }
                  {
                  schedule_delayed_work(& device->work, 0UL);
                  }
                }
                goto switch_353_break;
                switch_353_2: /* CIL Label */ 
                switch_353_4: /* CIL Label */ 
                if (! node->data) {
                  goto switch_353_break;
                }
                {
                device = (struct fw_device *)node->data;
                tmp___5 = __xchg(2UL, (void volatile   *)(& device->state.counter),
                                 (int )sizeof(device->state.counter));
                }
                if ((int volatile   )tmp___5 == (int volatile   )1) {
                  {
                  while (1) {
                    while_360_continue: /* CIL Label */ ;
                    {
                    device->work.work.func = & fw_device_shutdown;
                    }
                    goto while_360_break;
                  }
                  while_360_break: /* CIL Label */ ;
                  }
                  {
                  tmp___4 = list_empty((struct list_head  const  *)(& card->link));
                  }
                  if (tmp___4) {
                    {
                    tmp___3 = 0;
                    }
                  } else {
                    {
                    tmp___3 = 2000;
                    }
                  }
                  {
                  schedule_delayed_work(& device->work, (unsigned long )tmp___3);
                  }
                }
                goto switch_353_break;
              } else {
                switch_353_break: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
static unsigned long __force_order___2  ;
__inline static unsigned long native_read_cr0___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static void native_write_cr0___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static void native_write_cr2___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static void native_write_cr3___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___2));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___2(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___2): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___2(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___2));
  }
  return;
}
}
__inline static void load_cr3___2(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___2((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___2(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___2();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___2((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___2(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___2();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___2((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___2(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___2 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___2(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___2(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___2(u64 ns ) ;
static union ktime  const  ktime_zero___2  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___2(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___2.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___3  ;
int fw_iso_buffer_init(struct fw_iso_buffer *buffer , struct fw_card *card , int page_count___0 ,
                       enum dma_data_direction direction ) 
{ int i ;
  int j ;
  dma_addr_t address ;
  void *tmp ;
  int ret__ ;
  int tmp___0 ;

  {
  {
  buffer->page_count = page_count___0;
  buffer->direction = direction;
  tmp = kmalloc((unsigned int )((unsigned long )page_count___0 * sizeof(*(buffer->pages + 0))),
                208U);
  buffer->pages = (struct page **)tmp;
  }
  if ((unsigned long )buffer->pages == (unsigned long )((void *)0)) {
    goto out;
  }
  {
  i = 0;
  }
  {
  while (1) {
    while_361_continue: /* CIL Label */ ;
    if (! (i < buffer->page_count)) {
      goto while_361_break;
    }
    if ((int )sizeof(per_cpu__cpu_number) == 1) {
      goto switch_362_1;
    } else {
      if ((int )sizeof(per_cpu__cpu_number) == 2) {
        goto switch_362_2;
      } else {
        if ((int )sizeof(per_cpu__cpu_number) == 4) {
          goto switch_362_4;
        } else {
          if ((int )sizeof(per_cpu__cpu_number) == 8) {
            goto switch_362_8;
          } else {
            {
            goto switch_362_default;
            if (0) {
              switch_362_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=q" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_362_break;
              switch_362_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_362_break;
              switch_362_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_362_break;
              switch_362_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q "
                        "%%"
                        "fs"
                        ":%P"
                        "1"
                        ",%0": "=r" (ret__): "m" (per_cpu__cpu_number));
              }
              goto switch_362_break;
              switch_362_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_362_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    {
    *(buffer->pages + i) = alloc_pages_node(0, 32980U, 0U);
    }
    if ((unsigned long )*(buffer->pages + i) == (unsigned long )((void *)0)) {
      goto out_pages;
    }
    {
    address = dma_map_page(card->device, *(buffer->pages + i), 0U, (unsigned int )(1UL << 12),
                           direction);
    tmp___0 = dma_mapping_error(card->device, address);
    }
    if (tmp___0) {
      {
      __free_pages(*(buffer->pages + i), 0U);
      }
      goto out_pages;
    }
    {
    (*(buffer->pages + i))->__annonCompField19.__annonCompField18.private = (unsigned long )address;
    i ++;
    }
  }
  while_361_break: /* CIL Label */ ;
  }
  return (0);
  out_pages: 
  {
  j = 0;
  }
  {
  while (1) {
    while_363_continue: /* CIL Label */ ;
    if (! (j < i)) {
      goto while_363_break;
    }
    {
    address = (unsigned int )(*(buffer->pages + j))->__annonCompField19.__annonCompField18.private;
    dma_unmap_page(card->device, address, (unsigned int )(1UL << 12), (enum dma_data_direction )1);
    __free_pages(*(buffer->pages + j), 0U);
    j ++;
    }
  }
  while_363_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)buffer->pages);
  }
  out: 
  {
  buffer->pages = (struct page **)((void *)0);
  }
  return (-12);
}
}
int fw_iso_buffer_map(struct fw_iso_buffer *buffer , struct vm_area_struct *vma ) 
{ unsigned long uaddr ;
  int i ;
  int err ;

  {
  {
  uaddr = vma->vm_start;
  i = 0;
  }
  {
  while (1) {
    while_364_continue: /* CIL Label */ ;
    if (! (i < buffer->page_count)) {
      goto while_364_break;
    }
    {
    err = vm_insert_page(vma, uaddr, *(buffer->pages + i));
    }
    if (err) {
      return (err);
    }
    {
    uaddr += 1UL << 12;
    i ++;
    }
  }
  while_364_break: /* CIL Label */ ;
  }
  return (0);
}
}
void fw_iso_buffer_destroy(struct fw_iso_buffer *buffer , struct fw_card *card ) 
{ int i ;
  dma_addr_t address ;

  {
  {
  i = 0;
  }
  {
  while (1) {
    while_365_continue: /* CIL Label */ ;
    if (! (i < buffer->page_count)) {
      goto while_365_break;
    }
    {
    address = (unsigned int )(*(buffer->pages + i))->__annonCompField19.__annonCompField18.private;
    dma_unmap_page(card->device, address, (unsigned int )(1UL << 12), (enum dma_data_direction )1);
    __free_pages(*(buffer->pages + i), 0U);
    i ++;
    }
  }
  while_365_break: /* CIL Label */ ;
  }
  {
  kfree((void const   *)buffer->pages);
  buffer->pages = (struct page **)((void *)0);
  }
  return;
}
}
struct fw_iso_context *fw_iso_context_create(struct fw_card *card , int type , int channel ,
                                             int speed , size_t header_size , void (*callback)(struct fw_iso_context *context ,
                                                                                               u32 cycle ,
                                                                                               size_t header_length ,
                                                                                               void *header ,
                                                                                               void *data ) ,
                                             void *callback_data ) 
{ struct fw_iso_context *ctx ;
  long tmp ;

  {
  {
  ctx = (*((card->driver)->allocate_iso_context))(card, type, channel, header_size);
  tmp = IS_ERR((void const   *)ctx);
  }
  if (tmp) {
    return (ctx);
  }
  {
  ctx->card = card;
  ctx->type = type;
  ctx->channel = channel;
  ctx->speed = speed;
  ctx->header_size = header_size;
  ctx->callback = callback;
  ctx->callback_data = callback_data;
  }
  return (ctx);
}
}
void fw_iso_context_destroy(struct fw_iso_context *ctx ) 
{ struct fw_card *card ;

  {
  {
  card = ctx->card;
  (*((card->driver)->free_iso_context))(ctx);
  }
  return;
}
}
int fw_iso_context_start(struct fw_iso_context *ctx , int cycle , int sync , int tags ) 
{ int tmp ;

  {
  {
  tmp = (*(((ctx->card)->driver)->start_iso))(ctx, cycle, (unsigned int )sync, (unsigned int )tags);
  }
  return (tmp);
}
}
int fw_iso_context_queue(struct fw_iso_context *ctx , struct fw_iso_packet *packet ,
                         struct fw_iso_buffer *buffer , unsigned long payload ) 
{ struct fw_card *card ;
  int tmp ;

  {
  {
  card = ctx->card;
  tmp = (*((card->driver)->queue_iso))(ctx, packet, buffer, payload);
  }
  return (tmp);
}
}
int fw_iso_context_stop(struct fw_iso_context *ctx ) 
{ int tmp ;

  {
  {
  tmp = (*(((ctx->card)->driver)->stop_iso))(ctx);
  }
  return (tmp);
}
}
static int manage_bandwidth(struct fw_card *card , int irm_id , int generation , int bandwidth ,
                            bool allocate ) 
{ __be32 data[2] ;
  int try ;
  int new ;
  int old ;
  int tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
  if (allocate) {
    {
    tmp = 4915;
    }
  } else {
    {
    tmp = 0;
    }
  }
  {
  old = tmp;
  try = 0;
  }
  {
  while (1) {
    while_366_continue: /* CIL Label */ ;
    if (! (try < 5)) {
      goto while_366_break;
    }
    if (allocate) {
      {
      new = old - bandwidth;
      }
    } else {
      {
      new = old + bandwidth;
      }
    }
    if (new < 0) {
      goto while_366_break;
    } else {
      if (new > 4915) {
        goto while_366_break;
      }
    }
    {
    tmp___0 = __fswab32((unsigned int )old);
    data[0] = tmp___0;
    tmp___1 = __fswab32((unsigned int )new);
    data[1] = tmp___1;
    tmp___2 = fw_run_transaction(card, 18, irm_id, generation, 0, 281474708275744ULL,
                                 (void *)(data), (unsigned int )sizeof(data));
    }
    if (tmp___2 == 19) {
      goto switch_367_19;
    } else {
      if (tmp___2 == 0) {
        goto switch_367_0;
      } else {
        if (0) {
          switch_367_19: /* CIL Label */ 
          if (allocate) {
            {
            tmp___3 = -11;
            }
          } else {
            {
            tmp___3 = bandwidth;
            }
          }
          return (tmp___3);
          switch_367_0: /* CIL Label */ 
          {
          tmp___4 = __be32_to_cpup((__be32 const   *)(data));
          }
          if (tmp___4 == (__u32 )old) {
            return (bandwidth);
          }
          {
          tmp___5 = __be32_to_cpup((__be32 const   *)(data));
          old = (int )tmp___5;
          }
        } else {
          switch_367_break: /* CIL Label */ ;
        }
      }
    }
    {
    try ++;
    }
  }
  while_366_break: /* CIL Label */ ;
  }
  return (-5);
}
}
static int manage_channel(struct fw_card *card , int irm_id , int generation , u32 channels_mask ,
                          u64 offset , bool allocate ) 
{ __be32 data[2] ;
  __be32 c ;
  __be32 all ;
  __be32 old ;
  int i ;
  int retry ;
  __u32 tmp ;
  __u32 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  retry = 5;
  }
  if (allocate) {
    {
    all = (((255U << 24) | (65280U << 8)) | (16711680U >> 8)) | (4278190080U >> 24);
    }
  } else {
    {
    all = 0U;
    }
  }
  {
  old = all;
  i = 0;
  }
  {
  while (1) {
    while_368_continue: /* CIL Label */ ;
    if (! (i < 32)) {
      goto while_368_break;
    }
    if (! (channels_mask & (unsigned int )(1 << i))) {
      goto __Cont;
    }
    {
    tmp___0 = __fswab32((unsigned int )(1 << (31 - i)));
    c = tmp___0;
    }
    if ((old & c) != (all & c)) {
      goto __Cont;
    }
    {
    data[0] = old;
    data[1] = old ^ c;
    tmp___1 = fw_run_transaction(card, 18, irm_id, generation, 0, offset, (void *)(data),
                                 (unsigned int )sizeof(data));
    }
    if (tmp___1 == 19) {
      goto switch_369_19;
    } else {
      if (tmp___1 == 0) {
        goto switch_369_0;
      } else {
        {
        goto switch_369_default;
        if (0) {
          switch_369_19: /* CIL Label */ 
          if (allocate) {
            {
            tmp___2 = -11;
            }
          } else {
            {
            tmp___2 = i;
            }
          }
          return (tmp___2);
          switch_369_0: /* CIL Label */ 
          if (data[0] == old) {
            return (i);
          }
          {
          old = data[0];
          }
          if ((data[0] & c) == (data[1] & c)) {
            goto __Cont;
          }
          switch_369_default: /* CIL Label */ 
          {
          tmp___3 = retry;
          retry --;
          }
          if (tmp___3) {
            {
            i --;
            }
          }
        } else {
          switch_369_break: /* CIL Label */ ;
        }
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_368_break: /* CIL Label */ ;
  }
  return (-5);
}
}
static void deallocate_channel(struct fw_card *card , int irm_id , int generation ,
                               int channel ) 
{ u32 mask ;
  u64 offset ;

  {
  if (channel < 32) {
    {
    mask = (unsigned int )(1 << channel);
    }
  } else {
    {
    mask = (unsigned int )(1 << (channel - 32));
    }
  }
  if (channel < 32) {
    {
    offset = 281474708275748ULL;
    }
  } else {
    {
    offset = 281474708275752ULL;
    }
  }
  {
  manage_channel(card, irm_id, generation, mask, offset, (_Bool)0);
  }
  return;
}
}
void fw_iso_resource_manage(struct fw_card *card , int generation , u64 channels_mask ,
                            int *channel , int *bandwidth , bool allocate ) 
{ u32 channels_hi ;
  u32 channels_lo ;
  int irm_id ;
  int ret ;
  int c ;

  {
  {
  channels_hi = (u32 )channels_mask;
  channels_lo = (u32 )(channels_mask >> 32);
  c = -22;
  _spin_lock_irq(& card->lock);
  irm_id = (int )(card->irm_node)->node_id;
  }
  {
  while (1) {
    while_370_continue: /* CIL Label */ ;
    {
    __raw_spin_unlock(& card->lock.raw_lock);
    }
    {
    while (1) {
      while_371_continue: /* CIL Label */ ;
      {
      while (1) {
        while_372_continue: /* CIL Label */ ;
        goto while_372_break;
      }
      while_372_break: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_371_break;
    }
    while_371_break: /* CIL Label */ ;
    }
    goto while_370_break;
  }
  while_370_break: /* CIL Label */ ;
  }
  if (channels_hi) {
    {
    c = manage_channel(card, irm_id, generation, channels_hi, 281474708275748ULL,
                       allocate);
    }
  }
  if (channels_lo) {
    if (c < 0) {
      {
      c = manage_channel(card, irm_id, generation, channels_lo, 281474708275752ULL,
                         allocate);
      }
      if (c >= 0) {
        {
        c += 32;
        }
      }
    }
  }
  {
  *channel = c;
  }
  if (allocate) {
    if (channels_mask != 0ULL) {
      if (c < 0) {
        {
        *bandwidth = 0;
        }
      }
    }
  }
  if (*bandwidth == 0) {
    return;
  }
  {
  ret = manage_bandwidth(card, irm_id, generation, *bandwidth, allocate);
  }
  if (ret < 0) {
    {
    *bandwidth = 0;
    }
  }
  if (allocate) {
    if (ret < 0) {
      if (c >= 0) {
        {
        deallocate_channel(card, irm_id, generation, c);
        *channel = ret;
        }
      }
    }
  }
  return;
}
}
static unsigned long __force_order___3  ;
__inline static unsigned long native_read_cr0___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static void native_write_cr0___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static void native_write_cr2___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static void native_write_cr3___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___3));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___3(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___3): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___3(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___3));
  }
  return;
}
}
__inline static void load_cr3___3(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___3((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___3(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___3();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___3((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___3(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___3();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___3((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___3(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___3 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___3(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___3(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___3(u64 ns ) ;
static union ktime  const  ktime_zero___3  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___3(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___3.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
static struct lock_class_key __key___4  ;
static u32 *count_ports(u32 *sid , int *total_port_count , int *child_port_count ) 
{ u32 q ;
  int port_type ;
  int shift ;
  int seq ;

  {
  {
  *total_port_count = 0;
  *child_port_count = 0;
  shift = 6;
  q = *sid;
  seq = 0;
  }
  {
  while (1) {
    while_373_continue: /* CIL Label */ ;
    {
    port_type = (int )((q >> shift) & 3U);
    }
    if (port_type == 3) {
      goto switch_374_3;
    } else {
      if (port_type == 2) {
        goto switch_374_2;
      } else {
        if (port_type == 1) {
          goto switch_374_2;
        } else {
          if (port_type == 0) {
            goto switch_374_0;
          } else {
            if (0) {
              switch_374_3: /* CIL Label */ 
              {
              (*child_port_count) ++;
              }
              switch_374_2: /* CIL Label */ 
              switch_374_1: /* CIL Label */ 
              {
              (*total_port_count) ++;
              }
              switch_374_0: /* CIL Label */ 
              goto switch_374_break;
            } else {
              switch_374_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
    {
    shift -= 2;
    }
    if (shift == 0) {
      if (! (q & 1U)) {
        return (sid + 1);
      }
      {
      shift = 16;
      sid ++;
      q = *sid;
      }
      if (! ((q >> 23) & 1U)) {
        return ((u32 *)((void *)0));
      } else {
        if ((unsigned int )seq != ((q >> 20) & 7U)) {
          return ((u32 *)((void *)0));
        }
      }
      {
      seq ++;
      }
    }
  }
  while_373_break: /* CIL Label */ ;
  }
}
}
static int get_port_type(u32 *sid , int port_index ) 
{ int index___0 ;
  int shift ;

  {
  {
  index___0 = (port_index + 5) / 8;
  shift = 16 - ((port_index + 5) & 7) * 2;
  }
  return ((int )((*(sid + index___0) >> shift) & 3U));
}
}
static struct fw_node *fw_node_create(u32 sid , int port_count , int color ) 
{ struct fw_node *node ;
  void *tmp ;

  {
  {
  tmp = kzalloc((unsigned int )(sizeof(*node) + (unsigned long )port_count * sizeof(node->ports[0])),
                32U);
  node = (struct fw_node *)tmp;
  }
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    return ((struct fw_node *)((void *)0));
  }
  {
  node->color = (unsigned char )color;
  node->node_id = (unsigned short )(65472U | ((sid >> 24) & 63U));
  node->link_on = (unsigned char )((sid >> 22) & 1U);
  node->phy_speed = (unsigned char )((sid >> 14) & 3U);
  node->initiated_reset = (unsigned char )((sid >> 1) & 1U);
  node->port_count = (unsigned char )port_count;
  node->ref_count.counter = (int volatile   )1;
  INIT_LIST_HEAD(& node->link);
  }
  return (node);
}
}
static void update_hop_count(struct fw_node *node ) 
{ int depths[2] ;
  int max_child_hops ;
  int i ;
  int _max1 ;
  int _max2 ;
  int tmp ;

  {
  {
  depths[0] = -1;
  depths[1] = -1;
  max_child_hops = 0;
  i = 0;
  }
  {
  while (1) {
    while_375_continue: /* CIL Label */ ;
    if (! (i < (int )node->port_count)) {
      goto while_375_break;
    }
    if ((unsigned long )node->ports[i] == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    if ((int )(node->ports[i])->max_hops > max_child_hops) {
      {
      max_child_hops = (int )(node->ports[i])->max_hops;
      }
    }
    if ((int )(node->ports[i])->max_depth > depths[0]) {
      {
      depths[1] = depths[0];
      depths[0] = (int )(node->ports[i])->max_depth;
      }
    } else {
      if ((int )(node->ports[i])->max_depth > depths[1]) {
        {
        depths[1] = (int )(node->ports[i])->max_depth;
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
    i ++;
    }
  }
  while_375_break: /* CIL Label */ ;
  }
  {
  node->max_depth = (unsigned char )(depths[0] + 1);
  _max1 = max_child_hops;
  _max2 = (depths[0] + depths[1]) + 2;
  }
  if (_max1 > _max2) {
    {
    tmp = _max1;
    }
  } else {
    {
    tmp = _max2;
    }
  }
  {
  node->max_hops = (unsigned char )tmp;
  }
  return;
}
}
__inline static struct fw_node *fw_node(struct list_head *l ) 
{ struct list_head  const  *__mptr ;

  {
  {
  __mptr = (struct list_head  const  *)l;
  }
  return ((struct fw_node *)((char *)__mptr - (unsigned int )(& ((struct fw_node *)0)->link)));
}
}
static struct fw_node *build_tree(struct fw_card *card , u32 *sid , int self_id_count ) 
{ struct fw_node *node ;
  struct fw_node *child ;
  struct fw_node *local_node ;
  struct fw_node *irm_node ;
  struct list_head stack ;
  struct list_head *h ;
  u32 *next_sid ;
  u32 *end ;
  u32 q ;
  int i ;
  int port_count ;
  int child_port_count ;
  int phy_id ;
  int parent_count ;
  int stack_depth ;
  int gap_count ;
  bool beta_repeaters_present ;
  int tmp ;

  {
  {
  local_node = (struct fw_node *)((void *)0);
  node = (struct fw_node *)((void *)0);
  INIT_LIST_HEAD(& stack);
  stack_depth = 0;
  end = sid + self_id_count;
  phy_id = 0;
  irm_node = (struct fw_node *)((void *)0);
  gap_count = (int )((*sid >> 16) & 63U);
  beta_repeaters_present = (_Bool)0;
  }
  {
  while (1) {
    while_376_continue: /* CIL Label */ ;
    if (! ((unsigned long )sid < (unsigned long )end)) {
      goto while_376_break;
    }
    {
    next_sid = count_ports(sid, & port_count, & child_port_count);
    }
    if ((unsigned long )next_sid == (unsigned long )((void *)0)) {
      {
      printk("<3>SomeModule: Inconsistent extended self IDs.\n");
      }
      return ((struct fw_node *)((void *)0));
    }
    {
    q = *sid;
    }
    if ((unsigned int )phy_id != ((q >> 24) & 63U)) {
      {
      printk("<3>SomeModule: PHY ID mismatch in self ID: %d != %d.\n", phy_id, (q >> 24) & 63U);
      }
      return ((struct fw_node *)((void *)0));
    }
    if (child_port_count > stack_depth) {
      {
      printk("<3>SomeModule: Topology stack underflow\n");
      }
      return ((struct fw_node *)((void *)0));
    }
    {
    i = 0;
    h = & stack;
    }
    {
    while (1) {
      while_377_continue: /* CIL Label */ ;
      if (! (i < child_port_count)) {
        goto while_377_break;
      }
      {
      h = h->prev;
      i ++;
      }
    }
    while_377_break: /* CIL Label */ ;
    }
    {
    child = fw_node(h);
    node = fw_node_create(q, port_count, (int )card->color);
    }
    if ((unsigned long )node == (unsigned long )((void *)0)) {
      {
      printk("<3>SomeModule: Out of memory while building topology.\n");
      }
      return ((struct fw_node *)((void *)0));
    }
    if (phy_id == (card->node_id & 63)) {
      {
      local_node = node;
      }
    }
    if ((q >> 11) & 1U) {
      {
      irm_node = node;
      }
    }
    {
    parent_count = 0;
    i = 0;
    }
    {
    while (1) {
      while_378_continue: /* CIL Label */ ;
      if (! (i < port_count)) {
        goto while_378_break;
      }
      {
      tmp = get_port_type(sid, i);
      }
      if (tmp == 2) {
        goto switch_379_2;
      } else {
        if (tmp == 3) {
          goto switch_379_3;
        } else {
          if (0) {
            switch_379_2: /* CIL Label */ 
            {
            parent_count ++;
            node->color = (unsigned char )i;
            }
            goto switch_379_break;
            switch_379_3: /* CIL Label */ 
            {
            node->ports[i] = child;
            child->ports[child->color] = node;
            child->color = card->color;
            child = fw_node(child->link.next);
            }
            goto switch_379_break;
          } else {
            switch_379_break: /* CIL Label */ ;
          }
        }
      }
      {
      i ++;
      }
    }
    while_378_break: /* CIL Label */ ;
    }
    if ((unsigned long )next_sid == (unsigned long )end) {
      if (parent_count != 0) {
        {
        printk("<3>SomeModule: Parent port inconsistency for node %d: parent_count=%d\n",
               phy_id, parent_count);
        }
        return ((struct fw_node *)((void *)0));
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if ((unsigned long )next_sid < (unsigned long )end) {
        if (parent_count != 1) {
          {
          printk("<3>SomeModule: Parent port inconsistency for node %d: parent_count=%d\n",
                 phy_id, parent_count);
          }
          return ((struct fw_node *)((void *)0));
        }
      }
    }
    {
    __list_del(h->prev, & stack);
    list_add_tail(& node->link, & stack);
    stack_depth += 1 - child_port_count;
    }
    if ((int )node->phy_speed == 3) {
      if (parent_count + child_port_count > 1) {
        {
        beta_repeaters_present = (_Bool)1;
        }
      }
    }
    if (((q >> 16) & 63U) != (unsigned int )gap_count) {
      {
      gap_count = 0;
      }
    }
    {
    update_hop_count(node);
    sid = next_sid;
    phy_id ++;
    }
  }
  while_376_break: /* CIL Label */ ;
  }
  {
  card->root_node = node;
  card->irm_node = irm_node;
  card->gap_count = gap_count;
  card->beta_repeaters_present = beta_repeaters_present;
  }
  return (local_node);
}
}
static void for_each_fw_node(struct fw_card *card , struct fw_node *root , void (*callback)(struct fw_card *card ,
                                                                                            struct fw_node *node ,
                                                                                            struct fw_node *parent ) ) 
{ struct list_head list ;
  struct fw_node *node ;
  struct fw_node *next ;
  struct fw_node *child ;
  struct fw_node *parent ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;

  {
  {
  INIT_LIST_HEAD(& list);
  fw_node_get(root);
  list_add_tail(& root->link, & list);
  parent = (struct fw_node *)((void *)0);
  __mptr = (struct list_head  const  *)list.next;
  node = (struct fw_node *)((char *)__mptr - (unsigned int )(& ((struct fw_node *)0)->link));
  }
  {
  while (1) {
    while_380_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)node->link.next);
    }
    if (! ((unsigned long )(& node->link) != (unsigned long )(& list))) {
      goto while_380_break;
    }
    {
    node->color = card->color;
    i = 0;
    }
    {
    while (1) {
      while_381_continue: /* CIL Label */ ;
      if (! (i < (int )node->port_count)) {
        goto while_381_break;
      }
      {
      child = node->ports[i];
      }
      if (! child) {
        goto __Cont;
      }
      if ((int )child->color == (int )card->color) {
        {
        parent = child;
        }
      } else {
        {
        fw_node_get(child);
        list_add_tail(& child->link, & list);
        }
      }
      __Cont: /* CIL Label */ 
      {
      i ++;
      }
    }
    while_381_break: /* CIL Label */ ;
    }
    {
    (*callback)(card, node, parent);
    __mptr___0 = (struct list_head  const  *)node->link.next;
    node = (struct fw_node *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_node *)0)->link));
    }
  }
  while_380_break: /* CIL Label */ ;
  }
  {
  __mptr___1 = (struct list_head  const  *)list.next;
  node = (struct fw_node *)((char *)__mptr___1 - (unsigned int )(& ((struct fw_node *)0)->link));
  __mptr___2 = (struct list_head  const  *)node->link.next;
  next = (struct fw_node *)((char *)__mptr___2 - (unsigned int )(& ((struct fw_node *)0)->link));
  }
  {
  while (1) {
    while_382_continue: /* CIL Label */ ;
    if (! ((unsigned long )(& node->link) != (unsigned long )(& list))) {
      goto while_382_break;
    }
    {
    fw_node_put(node);
    node = next;
    __mptr___3 = (struct list_head  const  *)next->link.next;
    next = (struct fw_node *)((char *)__mptr___3 - (unsigned int )(& ((struct fw_node *)0)->link));
    }
  }
  while_382_break: /* CIL Label */ ;
  }
  return;
}
}
static void report_lost_node(struct fw_card *card , struct fw_node *node , struct fw_node *parent ) 
{ 

  {
  {
  fw_node_event(card, node, 2);
  fw_node_put(node);
  card->bm_retries = 0;
  }
  return;
}
}
static void report_found_node(struct fw_card *card , struct fw_node *node , struct fw_node *parent ) 
{ int b_path ;
  int tmp ;

  {
  {
  b_path = (int )node->phy_speed == 3;
  }
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
    if ((int )parent->max_speed < (int )node->phy_speed) {
      {
      node->max_speed = parent->max_speed;
      }
    } else {
      {
      node->max_speed = node->phy_speed;
      }
    }
    if (parent->b_path) {
      if (b_path) {
        {
        tmp = 1;
        }
      } else {
        {
        tmp = 0;
        }
      }
    } else {
      {
      tmp = 0;
      }
    }
    {
    node->b_path = (unsigned char )tmp;
    }
  } else {
    {
    node->max_speed = node->phy_speed;
    node->b_path = (unsigned char )b_path;
    }
  }
  {
  fw_node_event(card, node, 0);
  card->bm_retries = 0;
  }
  return;
}
}
void fw_destroy_nodes(struct fw_card *card ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_383_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_383_break;
  }
  while_383_break: /* CIL Label */ ;
  }
  {
  card->color = (u8 )((int )card->color + 1);
  }
  if ((unsigned long )card->local_node != (unsigned long )((void *)0)) {
    {
    for_each_fw_node(card, card->local_node, & report_lost_node);
    }
  }
  {
  card->local_node = (struct fw_node *)((void *)0);
  }
  {
  while (1) {
    while_384_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_384_break;
  }
  while_384_break: /* CIL Label */ ;
  }
  return;
}
}
static void move_tree(struct fw_node *node0 , struct fw_node *node1 , int port ) 
{ struct fw_node *tree ;
  int i ;

  {
  {
  tree = node1->ports[port];
  node0->ports[port] = tree;
  i = 0;
  }
  {
  while (1) {
    while_385_continue: /* CIL Label */ ;
    if (! (i < (int )tree->port_count)) {
      goto while_385_break;
    }
    if ((unsigned long )tree->ports[i] == (unsigned long )node1) {
      {
      tree->ports[i] = node0;
      }
      goto while_385_break;
    }
    {
    i ++;
    }
  }
  while_385_break: /* CIL Label */ ;
  }
  return;
}
}
static void update_tree(struct fw_card *card , struct fw_node *root ) 
{ struct list_head list0 ;
  struct list_head list1 ;
  struct fw_node *node0 ;
  struct fw_node *node1 ;
  struct fw_node *next1 ;
  int i ;
  int event ;
  int __ret_warn_on ;
  long tmp ;

  {
  {
  INIT_LIST_HEAD(& list0);
  list_add_tail(& (card->local_node)->link, & list0);
  INIT_LIST_HEAD(& list1);
  list_add_tail(& root->link, & list1);
  node0 = fw_node(list0.next);
  node1 = fw_node(list1.next);
  }
  {
  while (1) {
    while_386_continue: /* CIL Label */ ;
    if (! ((unsigned long )(& node0->link) != (unsigned long )(& list0))) {
      goto while_386_break;
    }
    {
    __ret_warn_on = ! (! ((int )node0->port_count != (int )node1->port_count));
    tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
    if (tmp) {
      {
      warn_slowpath_null("fw-topology.c", 430);
      }
    }
    {
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
    if (node0->link_on) {
      if (! node1->link_on) {
        {
        event = 4;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      if (! node0->link_on) {
        if (node1->link_on) {
          {
          event = 3;
          }
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if (node1->initiated_reset) {
          if (node1->link_on) {
            {
            event = 5;
            }
          } else {
            {
            event = 1;
            }
          }
        } else {
          {
          event = 1;
          }
        }
      }
    }
    {
    node0->node_id = node1->node_id;
    node0->color = card->color;
    node0->link_on = node1->link_on;
    node0->initiated_reset = node1->initiated_reset;
    node0->max_hops = node1->max_hops;
    node1->color = card->color;
    fw_node_event(card, node0, event);
    }
    if ((unsigned long )card->root_node == (unsigned long )node1) {
      {
      card->root_node = node0;
      }
    }
    if ((unsigned long )card->irm_node == (unsigned long )node1) {
      {
      card->irm_node = node0;
      }
    }
    {
    i = 0;
    }
    {
    while (1) {
      while_387_continue: /* CIL Label */ ;
      if (! (i < (int )node0->port_count)) {
        goto while_387_break;
      }
      if (node0->ports[i]) {
        if (node1->ports[i]) {
          if ((int )(node0->ports[i])->color == (int )card->color) {
            goto __Cont;
          }
          {
          list_add_tail(& (node0->ports[i])->link, & list0);
          list_add_tail(& (node1->ports[i])->link, & list1);
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if (node0->ports[i]) {
          {
          for_each_fw_node(card, node0->ports[i], & report_lost_node);
          node0->ports[i] = (struct fw_node *)((void *)0);
          }
        } else {
          if (node1->ports[i]) {
            {
            move_tree(node0, node1, i);
            for_each_fw_node(card, node0->ports[i], & report_found_node);
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
      {
      i ++;
      }
    }
    while_387_break: /* CIL Label */ ;
    }
    {
    node0 = fw_node(node0->link.next);
    next1 = fw_node(node1->link.next);
    fw_node_put(node1);
    node1 = next1;
    }
  }
  while_386_break: /* CIL Label */ ;
  }
  return;
}
}
static void update_topology_map(struct fw_card *card , u32 *self_ids , int self_id_count ) 
{ int node_count ;

  {
  {
  (card->topology_map[1]) ++;
  node_count = ((int )(card->root_node)->node_id & 63) + 1;
  card->topology_map[2] = (unsigned int )((node_count << 16) | self_id_count);
  card->topology_map[0] = (unsigned int )((self_id_count + 2) << 16);
  __memcpy((void *)(& card->topology_map[3]), (void const   *)self_ids, (unsigned int )(self_id_count * 4));
  fw_compute_block_crc(card->topology_map);
  }
  return;
}
}
void fw_core_handle_bus_reset(struct fw_card *card , int node_id , int generation ,
                              int self_id_count , u32 *self_ids ) 
{ struct fw_node *local_node ;
  unsigned long flags ;
  bool tmp ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  tmp = is_next_generation(generation, card->generation);
  }
  if (! tmp) {
    if ((unsigned long )card->local_node != (unsigned long )((void *)0)) {
      {
      printk("<5>SomeModule: skipped bus generations, destroying all nodes\n");
      fw_destroy_nodes(card);
      card->bm_retries = 0;
      }
    }
  }
  {
  while (1) {
    while_388_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_388_break;
  }
  while_388_break: /* CIL Label */ ;
  }
  {
  card->broadcast_channel_allocated = (_Bool)0;
  card->node_id = node_id;
  __asm__  volatile   ("": : : "memory");
  card->generation = generation;
  card->reset_jiffies = (unsigned long )jiffies;
  fw_schedule_bm_work(card, 0UL);
  local_node = build_tree(card, self_ids, self_id_count);
  update_topology_map(card, self_ids, self_id_count);
  card->color = (u8 )((int )card->color + 1);
  }
  if ((unsigned long )local_node == (unsigned long )((void *)0)) {
    {
    printk("<3>SomeModule: topology build failed\n");
    }
  } else {
    if ((unsigned long )card->local_node == (unsigned long )((void *)0)) {
      {
      card->local_node = local_node;
      for_each_fw_node(card, local_node, & report_found_node);
      }
    } else {
      {
      update_tree(card, local_node);
      }
    }
  }
  {
  while (1) {
    while_389_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_389_break;
  }
  while_389_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_fw_core_handle_bus_reset[25]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'h',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'l',      (char const   )'e',      (char const   )'_',      (char const   )'b', 
        (char const   )'u',      (char const   )'s',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_core_handle_bus_reset  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_core_handle_bus_reset), __kstrtab_fw_core_handle_bus_reset};
static unsigned long __force_order___4  ;
__inline static unsigned long native_read_cr0___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr0,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static void native_write_cr0___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr0": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static unsigned long native_read_cr2___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr2,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static void native_write_cr2___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr2": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static unsigned long native_read_cr3___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr3,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static void native_write_cr3___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr3": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static unsigned long native_read_cr4___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("mov %%cr4,%0\n\t": "=r" (val), "=m" (__force_order___4));
  }
  return (val);
}
}
__inline static unsigned long native_read_cr4_safe___4(void) 
{ unsigned long val ;

  {
  {
  __asm__  volatile   ("1: mov %%cr4, %0\n"
                       "2:\n"
                       " .section __ex_table,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "1b"
                       ","
                       "2b"
                       "\n"
                       " .previous\n": "=r" (val), "=m" (__force_order___4): "0" (0));
  }
  return (val);
}
}
__inline static void native_write_cr4___4(unsigned long val ) 
{ 

  {
  {
  __asm__  volatile   ("mov %0,%%cr4": : "r" (val), "m" (__force_order___4));
  }
  return;
}
}
__inline static void load_cr3___4(pgd_t *pgdir ) 
{ 

  {
  {
  native_write_cr3___4((unsigned long )pgdir - 3221225472UL);
  }
  return;
}
}
__inline static void set_in_cr4___4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features |= mask;
  tmp = native_read_cr4___4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 | mask);
  native_write_cr4___4((unsigned long )cr4);
  }
  return;
}
}
__inline static void clear_in_cr4___4(unsigned long mask ) 
{ unsigned int cr4 ;
  unsigned long tmp ;

  {
  {
  mmu_cr4_features &= ~ mask;
  tmp = native_read_cr4___4();
  cr4 = (unsigned int )tmp;
  cr4 = (unsigned int )((unsigned long )cr4 & ~ mask);
  native_write_cr4___4((unsigned long )cr4);
  }
  return;
}
}
__inline static u64 div_u64_rem___4(u64 dividend , u32 divisor , u32 *remainder ) 
{ union __anonunion_d_37___4 d ;
  u32 upper ;

  {
  {
  d.v64 = dividend;
  upper = d.v32[1];
  d.v32[1] = 0U;
  }
  if (upper >= divisor) {
    {
    d.v32[1] = upper / divisor;
    upper %= divisor;
    }
  }
  {
  __asm__  ("divl %2": "=a" (d.v32[0]), "=d" (*remainder): "rm" (divisor), "0" (d.v32[0]),
            "1" (upper));
  }
  return (d.v64);
}
}
__inline static u64 div_u64___4(u64 dividend , u32 divisor ) 
{ u32 remainder ;
  u64 tmp ;

  {
  {
  tmp = div_u64_rem___4(dividend, divisor, & remainder);
  }
  return (tmp);
}
}
__inline static ktime_t ns_to_ktime___4(u64 ns ) ;
static union ktime  const  ktime_zero___4  =    {(s64 )0};
__inline static ktime_t ns_to_ktime___4(u64 ns ) 
{ ktime_t __constr_expr_0 ;

  {
  {
  __constr_expr_0.tv64 = (s64 )((u64 )ktime_zero___4.tv64 + ns);
  }
  return (__constr_expr_0);
}
}
extern int nr_irqs ;
extern struct irq_desc *irq_to_desc(unsigned int irq ) ;
__inline static void hrtimer_set_expires_range_ns___0(struct hrtimer *timer , ktime_t time ,
                                                      unsigned long delta ) 
{ ktime_t tmp ;

  {
  {
  timer->_softexpires = time;
  tmp = ns_to_ktime___4((unsigned long long )delta);
  timer->_expires = ktime_add_safe(time, tmp);
  }
  return;
}
}
extern int __reacquire_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void __release_kernel_lock(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static int reacquire_kernel_lock(struct task_struct *task ) 
{ int tmp ;
  long tmp___0 ;

  {
  {
  tmp___0 = __builtin_expect((long )(! (! (task->lock_depth >= 0))), 0L);
  }
  if (tmp___0) {
    {
    tmp = __reacquire_kernel_lock();
    }
    return (tmp);
  }
  return (0);
}
}
extern void lock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
extern void unlock_kernel(void)  __attribute__((__section__(".spinlock.text"))) ;
__inline static void cycle_kernel_lock(void) 
{ 

  {
  {
  lock_kernel();
  unlock_kernel();
  }
  return;
}
}
__inline static int irq_canonicalize(int irq ) 
{ int tmp ;

  {
  if (irq == 2) {
    {
    tmp = 9;
    }
  } else {
    {
    tmp = irq;
    }
  }
  return (tmp);
}
}
extern void fixup_irqs(void) ;
extern void (*generic_interrupt_extension)(void) ;
extern void init_IRQ(void) ;
extern void native_init_IRQ(void) ;
extern bool handle_irq(unsigned int irq , struct pt_regs *regs ) ;
extern unsigned int do_IRQ(struct pt_regs *regs ) ;
extern int vector_used_by_percpu_irq(unsigned int vector ) ;
extern struct pt_regs *per_cpu__irq_regs  __attribute__((__section__(".data.percpu"))) ;
__inline static struct pt_regs *get_irq_regs(void) 
{ struct pt_regs *ret__ ;

  {
  if ((int )sizeof(per_cpu__irq_regs) == 1) {
    goto switch_390_1;
  } else {
    if ((int )sizeof(per_cpu__irq_regs) == 2) {
      goto switch_390_2;
    } else {
      if ((int )sizeof(per_cpu__irq_regs) == 4) {
        goto switch_390_4;
      } else {
        if ((int )sizeof(per_cpu__irq_regs) == 8) {
          goto switch_390_8;
        } else {
          {
          goto switch_390_default;
          if (0) {
            switch_390_1: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "b "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=q" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_390_break;
            switch_390_2: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "w "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_390_break;
            switch_390_4: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "l "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_390_break;
            switch_390_8: /* CIL Label */ 
            {
            __asm__  ("mov"
                      "q "
                      "%%"
                      "fs"
                      ":%P"
                      "1"
                      ",%0": "=r" (ret__): "m" (per_cpu__irq_regs));
            }
            goto switch_390_break;
            switch_390_default: /* CIL Label */ 
            {
            __bad_percpu_size();
            }
          } else {
            switch_390_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  return (ret__);
}
}
__inline static struct pt_regs *set_irq_regs(struct pt_regs *new_regs ) 
{ struct pt_regs *old_regs ;
  T__ tmp__ ;

  {
  {
  old_regs = get_irq_regs();
  }
  {
  while (1) {
    while_391_continue: /* CIL Label */ ;
    if ((int )sizeof(per_cpu__irq_regs) == 1) {
      goto switch_392_1;
    } else {
      if ((int )sizeof(per_cpu__irq_regs) == 2) {
        goto switch_392_2;
      } else {
        if ((int )sizeof(per_cpu__irq_regs) == 4) {
          goto switch_392_4;
        } else {
          if ((int )sizeof(per_cpu__irq_regs) == 8) {
            goto switch_392_8;
          } else {
            {
            goto switch_392_default;
            if (0) {
              switch_392_1: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "b %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "qi" (new_regs));
              }
              goto switch_392_break;
              switch_392_2: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "w %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_392_break;
              switch_392_4: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "l %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "ri" (new_regs));
              }
              goto switch_392_break;
              switch_392_8: /* CIL Label */ 
              {
              __asm__  ("mov"
                        "q %1,"
                        "%%"
                        "fs"
                        ":%P"
                        "0": "+m" (per_cpu__irq_regs): "re" (new_regs));
              }
              goto switch_392_break;
              switch_392_default: /* CIL Label */ 
              {
              __bad_percpu_size();
              }
            } else {
              switch_392_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
    goto while_391_break;
  }
  while_391_break: /* CIL Label */ ;
  }
  return (old_regs);
}
}
extern void arch_init_copy_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ,
                                     int cpu ) ;
extern void arch_free_chip_data(struct irq_desc *old_desc , struct irq_desc *desc ) ;
extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc , int cpu ) ;
extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq , int cpu ) ;
__inline static struct irq_desc *irq_remap_to_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
  return (desc);
}
}
extern void create_prof_cpu_mask(struct proc_dir_entry *de ) ;
extern int create_proc_profile(void) ;
extern int prof_on  __attribute__((__section__(".data.read_mostly"))) ;
extern int profile_init(void) ;
extern int profile_setup(char *str ) ;
extern void profile_tick(int type ) ;
extern void profile_hits(int type , void *ip , unsigned int nr_hits ) ;
__inline static void profile_hit(int type , void *ip ) 
{ long tmp ;

  {
  {
  tmp = __builtin_expect((long )(! (! (prof_on == type))), 0L);
  }
  if (tmp) {
    {
    profile_hits(type, ip, 1U);
    }
  }
  return;
}
}
extern void profile_task_exit(struct task_struct *task ) ;
extern int profile_handoff_task(struct task_struct *task ) ;
extern void profile_munmap(unsigned long addr ) ;
extern int task_handoff_register(struct notifier_block *n ) ;
extern int task_handoff_unregister(struct notifier_block *n ) ;
extern int profile_event_register(enum profile_type  , struct notifier_block *n ) ;
extern int profile_event_unregister(enum profile_type  , struct notifier_block *n ) ;
extern int register_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern void unregister_timer_hook(int (*hook)(struct pt_regs * ) ) ;
extern char _text[] ;
extern char _stext[] ;
extern char _etext[] ;
extern char _data[] ;
extern char _sdata[] ;
extern char _edata[] ;
extern char __bss_start[] ;
extern char __bss_stop[] ;
extern char __init_begin[] ;
extern char __init_end[] ;
extern char _sinittext[] ;
extern char _einittext[] ;
extern char _end[] ;
extern char __per_cpu_load[] ;
extern char __per_cpu_start[] ;
extern char __per_cpu_end[] ;
extern char __kprobes_text_start[] ;
extern char __kprobes_text_end[] ;
extern char __initdata_begin[] ;
extern char __initdata_end[] ;
extern char __start_rodata[] ;
extern char __end_rodata[] ;
extern char __brk_base[] ;
extern char __brk_limit[] ;
extern void apic_timer_interrupt(void) ;
extern void generic_interrupt(void) ;
extern void error_interrupt(void) ;
extern void spurious_interrupt(void) ;
extern void thermal_interrupt(void) ;
extern void reschedule_interrupt(void) ;
extern void invalidate_interrupt(void) ;
extern void invalidate_interrupt0(void) ;
extern void invalidate_interrupt1(void) ;
extern void invalidate_interrupt2(void) ;
extern void invalidate_interrupt3(void) ;
extern void invalidate_interrupt4(void) ;
extern void invalidate_interrupt5(void) ;
extern void invalidate_interrupt6(void) ;
extern void invalidate_interrupt7(void) ;
extern void irq_move_cleanup_interrupt(void) ;
extern void threshold_interrupt(void) ;
extern void call_function_interrupt(void) ;
extern void call_function_single_interrupt(void) ;
extern void disable_8259A_irq(unsigned int irq ) ;
extern void enable_8259A_irq(unsigned int irq ) ;
extern int i8259A_irq_pending(unsigned int irq ) ;
extern void make_8259A_irq(unsigned int irq ) ;
extern void init_8259A(int aeoi ) ;
extern unsigned long io_apic_irqs ;
extern void init_VISWS_APIC_irqs(void) ;
extern void setup_IO_APIC(void) ;
extern void disable_IO_APIC(void) ;
extern int IO_APIC_get_PCI_irq_vector(int bus , int slot , int fn ) ;
extern void setup_ioapic_dest(void) ;
extern void enable_IO_APIC(void) ;
extern atomic_t irq_err_count ;
extern atomic_t irq_mis_count ;
extern void eisa_set_level_irq(unsigned int irq ) ;
extern void smp_apic_timer_interrupt(struct pt_regs * ) ;
extern void smp_spurious_interrupt(struct pt_regs * ) ;
extern void smp_error_interrupt(struct pt_regs * ) ;
extern void smp_reschedule_interrupt(struct pt_regs * ) ;
extern void smp_call_function_interrupt(struct pt_regs * ) ;
extern void smp_call_function_single_interrupt(struct pt_regs * ) ;
extern void smp_invalidate_interrupt(struct pt_regs * ) ;
extern void (*interrupt[224])(void)  __attribute__((__section__(".init.rodata"))) ;
extern vector_irq_t per_cpu__vector_irq  __attribute__((__section__(".data.percpu"))) ;
extern void lock_vector_lock(void) ;
extern void unlock_vector_lock(void) ;
extern void __setup_vector_irq(int cpu ) ;
extern int setup_irq(unsigned int irq , struct irqaction *new ) ;
extern void remove_irq(unsigned int irq , struct irqaction *act ) ;
extern void move_native_irq(int irq ) ;
extern void move_masked_irq(int irq ) ;
extern int no_irq_affinity ;
__inline static int irq_balancing_disabled(unsigned int irq ) 
{ struct irq_desc *desc ;

  {
  {
  desc = irq_to_desc(irq);
  }
  return ((int )(desc->status & 4194304U));
}
}
extern irqreturn_t handle_IRQ_event(unsigned int irq , struct irqaction *action ) ;
extern void handle_level_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_fasteoi_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_edge_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_simple_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_percpu_irq(unsigned int irq , struct irq_desc *desc ) ;
extern void handle_bad_irq(unsigned int irq , struct irq_desc *desc ) ;
__inline static void generic_handle_irq_desc(unsigned int irq , struct irq_desc *desc ) 
{ 

  {
  {
  (*(desc->handle_irq))(irq, desc);
  }
  return;
}
}
__inline static void generic_handle_irq(unsigned int irq ) 
{ struct irq_desc *tmp ;

  {
  {
  tmp = irq_to_desc(irq);
  generic_handle_irq_desc(irq, tmp);
  }
  return;
}
}
extern void note_interrupt(unsigned int irq , struct irq_desc *desc , irqreturn_t action_ret ) ;
extern void check_irq_resend(struct irq_desc *desc , unsigned int irq ) ;
extern int noirqdebug_setup(char *str ) ;
extern int can_request_irq(unsigned int irq , unsigned long irqflags ) ;
extern struct irq_chip no_irq_chip ;
extern struct irq_chip dummy_irq_chip ;
extern void set_irq_chip_and_handler(unsigned int irq , struct irq_chip *chip , void (*handle)(unsigned int irq ,
                                                                                               struct irq_desc *desc ) ) ;
extern void set_irq_chip_and_handler_name(unsigned int irq , struct irq_chip *chip ,
                                          void (*handle)(unsigned int irq , struct irq_desc *desc ) ,
                                          char const   *name ) ;
extern void __set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                struct irq_desc *desc ) ,
                              int is_chained , char const   *name ) ;
__inline static void __set_irq_handler_unlocked(int irq , void (*handler)(unsigned int irq ,
                                                                          struct irq_desc *desc ) ) 
{ struct irq_desc *desc ;

  {
  {
  desc = irq_to_desc((unsigned int )irq);
  desc->handle_irq = handler;
  }
  return;
}
}
__inline static void set_irq_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                       struct irq_desc *desc ) ) 
{ 

  {
  {
  __set_irq_handler(irq, handle, 0, (char const   *)((void *)0));
  }
  return;
}
}
__inline static void set_irq_chained_handler(unsigned int irq , void (*handle)(unsigned int irq ,
                                                                               struct irq_desc *desc ) ) 
{ 

  {
  {
  __set_irq_handler(irq, handle, 1, (char const   *)((void *)0));
  }
  return;
}
}
extern void set_irq_noprobe(unsigned int irq ) ;
extern void set_irq_probe(unsigned int irq ) ;
extern unsigned int create_irq_nr(unsigned int irq_want ) ;
extern int create_irq(void) ;
extern void destroy_irq(unsigned int irq ) ;
__inline static int irq_has_action(unsigned int irq ) 
{ struct irq_desc *desc ;
  struct irq_desc *tmp ;

  {
  {
  tmp = irq_to_desc(irq);
  desc = tmp;
  }
  return ((unsigned long )desc->action != (unsigned long )((void *)0));
}
}
extern void dynamic_irq_init(unsigned int irq ) ;
extern void dynamic_irq_cleanup(unsigned int irq ) ;
extern int set_irq_chip(unsigned int irq , struct irq_chip *chip ) ;
extern int set_irq_data(unsigned int irq , void *data ) ;
extern int set_irq_chip_data(unsigned int irq , void *data ) ;
extern int set_irq_type(unsigned int irq , unsigned int type ) ;
extern int set_irq_msi(unsigned int irq , struct msi_desc *entry ) ;
__inline static bool init_alloc_desc_masks(struct irq_desc *desc , int cpu , bool boot ) 
{ int node ;
  bool tmp ;
  bool tmp___0 ;

  {
  if (boot) {
    {
    alloc_bootmem_cpumask_var(& desc->affinity);
    cpumask_setall(desc->affinity);
    alloc_bootmem_cpumask_var(& desc->pending_mask);
    cpumask_clear(desc->pending_mask);
    }
    return ((_Bool)1);
  }
  {
  node = 0;
  tmp = alloc_cpumask_var_node(& desc->affinity, 32U, node);
  }
  if (! tmp) {
    return ((_Bool)0);
  }
  {
  cpumask_setall(desc->affinity);
  tmp___0 = alloc_cpumask_var_node(& desc->pending_mask, 32U, node);
  }
  if (! tmp___0) {
    {
    free_cpumask_var((struct cpumask *)(desc->affinity));
    }
    return ((_Bool)0);
  }
  {
  cpumask_clear(desc->pending_mask);
  }
  return ((_Bool)1);
}
}
__inline static void init_copy_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
  return;
}
}
__inline static void free_desc_masks(struct irq_desc *old_desc , struct irq_desc *new_desc ) 
{ 

  {
  {
  free_cpumask_var((struct cpumask *)(old_desc->affinity));
  free_cpumask_var((struct cpumask *)(old_desc->pending_mask));
  }
  return;
}
}
extern irq_cpustat_t per_cpu__irq_stat  __attribute__((__section__(".data.percpu.shared_aligned"),
__aligned__((1) <<  (5) ))) ;
extern void ack_bad_irq(unsigned int irq ) ;
extern u64 arch_irq_stat_cpu(unsigned int cpu ) ;
extern u64 arch_irq_stat(void) ;
extern void synchronize_irq(unsigned int irq ) ;
extern void rcu_irq_enter(void) ;
extern void rcu_irq_exit(void) ;
extern void rcu_nmi_enter(void) ;
extern void rcu_nmi_exit(void) ;
extern void irq_enter(void) ;
extern void irq_exit(void) ;
extern irqreturn_t no_action(int cpl , void *dev_id ) ;
extern int request_threaded_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                irqreturn_t (*thread_fn)(int  , void * ) , unsigned long flags ,
                                char const   *name , void *dev ) ;
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ int tmp ;

  {
  {
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                             flags, name, dev);
  }
  return (tmp);
}
}
extern void exit_irq_thread(void) ;
extern void free_irq(unsigned int  , void * ) ;
extern int devm_request_threaded_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     irqreturn_t (*thread_fn)(int  , void * ) , unsigned long irqflags ,
                                     char const   *devname , void *dev_id ) ;
__inline static int devm_request_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     unsigned long irqflags , char const   *devname ,
                                     void *dev_id ) 
{ int tmp ;

  {
  {
  tmp = devm_request_threaded_irq(dev, irq, handler, (irqreturn_t (*)(int  , void * ))((void *)0),
                                  irqflags, devname, dev_id);
  }
  return (tmp);
}
}
extern void devm_free_irq(struct device *dev , unsigned int irq , void *dev_id ) ;
extern void disable_irq_nosync(unsigned int irq ) ;
extern void disable_irq(unsigned int irq ) ;
extern void enable_irq(unsigned int irq ) ;
extern void suspend_device_irqs(void) ;
extern void resume_device_irqs(void) ;
extern int check_wakeup_irqs(void) ;
extern cpumask_var_t irq_default_affinity ;
extern int irq_set_affinity(unsigned int irq , struct cpumask  const  *cpumask ) ;
extern int irq_can_set_affinity(unsigned int irq ) ;
extern int irq_select_affinity(unsigned int irq ) ;
__inline static void disable_irq_nosync_lockdep(unsigned int irq ) 
{ 

  {
  {
  disable_irq_nosync(irq);
  }
  return;
}
}
__inline static void disable_irq_nosync_lockdep_irqsave(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
  disable_irq_nosync(irq);
  }
  return;
}
}
__inline static void disable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
  disable_irq(irq);
  }
  return;
}
}
__inline static void enable_irq_lockdep(unsigned int irq ) 
{ 

  {
  {
  enable_irq(irq);
  }
  return;
}
}
__inline static void enable_irq_lockdep_irqrestore(unsigned int irq , unsigned long *flags ) 
{ 

  {
  {
  enable_irq(irq);
  }
  return;
}
}
extern int set_irq_wake(unsigned int irq , unsigned int on ) ;
__inline static int enable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
  tmp = set_irq_wake(irq, 1U);
  }
  return (tmp);
}
}
__inline static int disable_irq_wake(unsigned int irq ) 
{ int tmp ;

  {
  {
  tmp = set_irq_wake(irq, 0U);
  }
  return (tmp);
}
}
extern char *softirq_to_name[9] ;
extern void ( __attribute__((__regparm__(0))) do_softirq)(void) ;
extern void ( __attribute__((__regparm__(0))) __do_softirq)(void) ;
extern void open_softirq(int nr , void (*action)(struct softirq_action * ) ) ;
extern void softirq_init(void) ;
extern void raise_softirq_irqoff(unsigned int nr ) ;
extern void raise_softirq(unsigned int nr ) ;
extern void wakeup_softirqd(void) ;
extern struct list_head per_cpu__softirq_work_list[9]  __attribute__((__section__(".data.percpu"))) ;
extern void send_remote_softirq(struct call_single_data *cp , int cpu , int softirq ) ;
extern void __send_remote_softirq(struct call_single_data *cp , int cpu , int this_cpu ,
                                  int softirq ) ;
__inline static int tasklet_trylock(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = test_and_set_bit(1, (unsigned long volatile   *)(& t->state));
  }
  if (tmp) {
    {
    tmp___0 = 0;
    }
  } else {
    {
    tmp___0 = 1;
    }
  }
  return (tmp___0);
}
}
__inline static void tasklet_unlock(struct tasklet_struct *t ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  clear_bit(1, (unsigned long volatile   *)(& t->state));
  }
  return;
}
}
__inline static void tasklet_unlock_wait(struct tasklet_struct *t ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  while (1) {
    while_393_continue: /* CIL Label */ ;
    {
    tmp = constant_test_bit(1U, (unsigned long const volatile   *)(& t->state));
    }
    if (! tmp) {
      goto while_393_break;
    }
    {
    __asm__  volatile   ("": : : "memory");
    }
  }
  while_393_break: /* CIL Label */ ;
  }
  return;
}
}
extern void __tasklet_schedule(struct tasklet_struct *t ) ;
__inline static void tasklet_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
  if (! tmp) {
    {
    __tasklet_schedule(t);
    }
  }
  return;
}
}
extern void __tasklet_hi_schedule(struct tasklet_struct *t ) ;
__inline static void tasklet_hi_schedule(struct tasklet_struct *t ) 
{ int tmp ;

  {
  {
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
  if (! tmp) {
    {
    __tasklet_hi_schedule(t);
    }
  }
  return;
}
}
__inline static void tasklet_disable_nosync(struct tasklet_struct *t ) 
{ 

  {
  {
  atomic_inc(& t->count);
  __asm__  volatile   ("": : : "memory");
  }
  return;
}
}
__inline static void tasklet_disable(struct tasklet_struct *t ) 
{ 

  {
  {
  tasklet_disable_nosync(t);
  tasklet_unlock_wait(t);
  __asm__  volatile   ("661:\n\t"
                       "lock; addl $0,0(%%esp)"
                       "\n662:\n"
                       ".section .altinstructions,\"a\"\n"
                       " "
                       ".balign 4"
                       " "
                       "\n"
                       " "
                       ".long"
                       " "
                       "661b\n"
                       " "
                       ".long"
                       " "
                       "663f\n"
                       "\t .byte %c0\n"
                       "\t .byte 662b-661b\n"
                       "\t .byte 664f-663f\n"
                       ".previous\n"
                       ".section .altinstr_replacement,\"ax\"\n"
                       "663:\n\t"
                       "mfence"
                       "\n664:\n"
                       ".previous": : "i" (26): "memory");
  }
  return;
}
}
__inline static void tasklet_enable(struct tasklet_struct *t ) 
{ 

  {
  {
  __asm__  volatile   ("": : : "memory");
  atomic_dec(& t->count);
  }
  return;
}
}
extern void tasklet_kill(struct tasklet_struct *t ) ;
extern void tasklet_kill_immediate(struct tasklet_struct *t , unsigned int cpu ) ;
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
extern unsigned long probe_irq_on(void) ;
extern int probe_irq_off(unsigned long  ) ;
extern unsigned int probe_irq_mask(unsigned long  ) ;
extern void init_irq_proc(void) ;
extern int show_interrupts(struct seq_file *p , void *v ) ;
extern int early_irq_init(void) ;
extern int arch_probe_nr_irqs(void) ;
extern int arch_early_irq_init(void) ;
extern int arch_init_chip_data(struct irq_desc *desc , int cpu ) ;
static struct lock_class_key __key___5  ;
extern void __iowrite32_copy(void *to , void const   *from , size_t count ) ;
extern void __iowrite64_copy(void *to , void const   *from , size_t count ) ;
extern int ioremap_page_range(unsigned long addr , unsigned long end , unsigned long phys_addr ,
                              pgprot_t prot ) ;
extern void *devm_ioport_map(struct device *dev , unsigned long port , unsigned int nr ) ;
extern void devm_ioport_unmap(struct device *dev , void *addr ) ;
extern void *devm_ioremap(struct device *dev , resource_size_t offset , unsigned long size ) ;
extern void *devm_ioremap_nocache(struct device *dev , resource_size_t offset , unsigned long size ) ;
extern void devm_iounmap(struct device *dev , void *addr ) ;
extern int check_signature(void const volatile   *io_addr , unsigned char const   *signature ,
                           int length ) ;
extern void devm_ioremap_release(struct device *dev , void *res ) ;
__inline static char const   *pci_slot_name(struct pci_slot  const  *slot ) 
{ char const   *tmp ;

  {
  {
  tmp = kobject_name(& slot->kobj);
  }
  return (tmp);
}
}
extern struct pci_dev *alloc_pci_dev(void) ;
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 

  {
  return (pdev->error_state != 1U);
}
}
__inline static struct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *pci_dev ,
                                                               char cap ) 
{ struct pci_cap_saved_state *tmp ;
  struct hlist_node *pos ;
  struct hlist_node  const  *__mptr ;

  {
  {
  pos = pci_dev->saved_cap_space.first;
  }
  {
  while (1) {
    while_394_continue: /* CIL Label */ ;
    if (pos) {
      {
      prefetch((void const   *)pos->next);
      __mptr = (struct hlist_node  const  *)pos;
      tmp = (struct pci_cap_saved_state *)((char *)__mptr - (unsigned int )(& ((struct pci_cap_saved_state *)0)->next));
      }
    } else {
      goto while_394_break;
    }
    if ((int )tmp->cap_nr == (int )cap) {
      return (tmp);
    }
    {
    pos = pos->next;
    }
  }
  while_394_break: /* CIL Label */ ;
  }
  return ((struct pci_cap_saved_state *)((void *)0));
}
}
__inline static void pci_add_saved_cap(struct pci_dev *pci_dev , struct pci_cap_saved_state *new_cap ) 
{ 

  {
  {
  hlist_add_head(& new_cap->next, & pci_dev->saved_cap_space);
  }
  return;
}
}
__inline static bool pci_is_root_bus(struct pci_bus *pbus ) 
{ 

  {
  return ((_Bool )(! pbus->parent));
}
}
__inline static bool pci_dev_msi_enabled(struct pci_dev *pci_dev ) 
{ int tmp ;

  {
  if (pci_dev->msi_enabled) {
    {
    tmp = 1;
    }
  } else {
    if (pci_dev->msix_enabled) {
      {
      tmp = 1;
      }
    } else {
      {
      tmp = 0;
      }
    }
  }
  return ((_Bool )tmp);
}
}
extern int raw_pci_read(unsigned int domain , unsigned int bus , unsigned int devfn ,
                        int reg , int len , u32 *val ) ;
extern int raw_pci_write(unsigned int domain , unsigned int bus , unsigned int devfn ,
                         int reg , int len , u32 val ) ;
extern struct bus_type pci_bus_type ;
extern struct list_head pci_root_buses ;
extern int no_pci_devices(void) ;
extern void pcibios_fixup_bus(struct pci_bus * ) ;
extern int pcibios_enable_device(struct pci_dev * , int mask ) ;
extern char *pcibios_setup(char *str ) ;
extern void pcibios_align_resource(void * , struct resource * , resource_size_t  ,
                                   resource_size_t  ) ;
extern void pcibios_update_irq(struct pci_dev * , int irq ) ;
extern struct pci_bus *pci_find_bus(int domain , int busnr ) ;
extern void pci_bus_add_devices(struct pci_bus  const  *bus ) ;
extern struct pci_bus *pci_scan_bus_parented(struct device *parent , int bus , struct pci_ops *ops ,
                                             void *sysdata ) ;
__inline static struct pci_bus *pci_scan_bus(int bus , struct pci_ops *ops , void *sysdata )  __attribute__((__section__(".devinit.text"))) ;
__inline static struct pci_bus *pci_scan_bus(int bus , struct pci_ops *ops , void *sysdata ) 
{ struct pci_bus *root_bus ;

  {
  {
  root_bus = pci_scan_bus_parented((struct device *)((void *)0), bus, ops, sysdata);
  }
  if (root_bus) {
    {
    pci_bus_add_devices((struct pci_bus  const  *)root_bus);
    }
  }
  return (root_bus);
}
}
extern struct pci_bus *pci_create_bus(struct device *parent , int bus , struct pci_ops *ops ,
                                      void *sysdata ) ;
extern struct pci_bus *pci_add_new_bus(struct pci_bus *parent , struct pci_dev *dev ,
                                       int busnr ) ;
extern struct pci_slot *pci_create_slot(struct pci_bus *parent , int slot_nr , char const   *name ,
                                        struct hotplug_slot *hotplug ) ;
extern void pci_destroy_slot(struct pci_slot *slot ) ;
extern void pci_renumber_slot(struct pci_slot *slot , int slot_nr ) ;
extern int pci_scan_slot(struct pci_bus *bus , int devfn ) ;
extern struct pci_dev *pci_scan_single_device(struct pci_bus *bus , int devfn ) ;
extern void pci_device_add(struct pci_dev *dev , struct pci_bus *bus ) ;
extern unsigned int pci_scan_child_bus(struct pci_bus *bus ) ;
extern int pci_bus_add_device(struct pci_dev *dev ) ;
extern void pci_read_bridge_bases(struct pci_bus *child ) ;
extern struct resource *pci_find_parent_resource(struct pci_dev  const  *dev , struct resource *res ) ;
extern u8 pci_swizzle_interrupt_pin(struct pci_dev *dev , u8 pin ) ;
extern int pci_get_interrupt_pin(struct pci_dev *dev , struct pci_dev **bridge ) ;
extern u8 pci_common_swizzle(struct pci_dev *dev , u8 *pinp ) ;
extern struct pci_dev *pci_dev_get(struct pci_dev *dev ) ;
extern void pci_dev_put(struct pci_dev *dev ) ;
extern void pci_remove_bus(struct pci_bus *b ) ;
extern void pci_remove_bus_device(struct pci_dev *dev ) ;
extern void pci_stop_bus_device(struct pci_dev *dev ) ;
extern void pci_setup_cardbus(struct pci_bus *bus ) ;
extern void pci_sort_breadthfirst(void) ;
extern enum pci_lost_interrupt_reason pci_lost_interrupt(struct pci_dev *dev ) ;
extern int pci_find_capability(struct pci_dev *dev , int cap ) ;
extern int pci_find_next_capability(struct pci_dev *dev , u8 pos , int cap ) ;
extern int pci_find_ext_capability(struct pci_dev *dev , int cap ) ;
extern int pci_find_ht_capability(struct pci_dev *dev , int ht_cap ) ;
extern int pci_find_next_ht_capability(struct pci_dev *dev , int pos , int ht_cap ) ;
extern struct pci_bus *pci_find_next_bus(struct pci_bus  const  *from ) ;
extern struct pci_dev *pci_get_device(unsigned int vendor , unsigned int device ,
                                      struct pci_dev *from ) ;
extern struct pci_dev *pci_get_subsys(unsigned int vendor , unsigned int device ,
                                      unsigned int ss_vendor , unsigned int ss_device ,
                                      struct pci_dev *from ) ;
extern struct pci_dev *pci_get_slot(struct pci_bus *bus , unsigned int devfn ) ;
extern struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) ;
extern struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
extern int pci_dev_present(struct pci_device_id  const  *ids ) ;
extern int pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u8 *val ) ;
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
extern int pci_bus_write_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u8 val ) ;
extern int pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u16 val ) ;
extern int pci_bus_write_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                      u32 val ) ;
__inline static int pci_read_config_byte(struct pci_dev *dev , int where , u8 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_read_config_dword(struct pci_dev *dev , int where , u32 *val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_byte(struct pci_dev *dev , int where , u8 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_word(struct pci_dev *dev , int where , u16 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
__inline static int pci_write_config_dword(struct pci_dev *dev , int where , u32 val ) 
{ int tmp ;

  {
  {
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  }
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev *dev ) ;
extern int pci_enable_device_io(struct pci_dev *dev ) ;
extern int pci_enable_device_mem(struct pci_dev *dev ) ;
extern int pci_reenable_device(struct pci_dev * ) ;
extern int pcim_enable_device(struct pci_dev *pdev ) ;
extern void pcim_pin_device(struct pci_dev *pdev ) ;
__inline static int pci_is_enabled(struct pci_dev *pdev ) 
{ 

  {
  return (pdev->enable_cnt.counter > (int volatile   )0);
}
}
__inline static int pci_is_managed(struct pci_dev *pdev ) 
{ 

  {
  return ((int )pdev->is_managed);
}
}
extern void pci_disable_device(struct pci_dev *dev ) ;
extern void pci_set_master(struct pci_dev *dev ) ;
extern void pci_clear_master(struct pci_dev *dev ) ;
extern int pci_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
extern int pci_set_mwi(struct pci_dev *dev ) ;
extern int pci_try_set_mwi(struct pci_dev *dev ) ;
extern void pci_clear_mwi(struct pci_dev *dev ) ;
extern void pci_intx(struct pci_dev *dev , int enable ) ;
extern void pci_msi_off(struct pci_dev *dev ) ;
extern int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) ;
extern int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) ;
extern int pci_set_dma_max_seg_size(struct pci_dev *dev , unsigned int size ) ;
extern int pci_set_dma_seg_boundary(struct pci_dev *dev , unsigned long mask ) ;
extern int pcix_get_max_mmrbc(struct pci_dev *dev ) ;
extern int pcix_get_mmrbc(struct pci_dev *dev ) ;
extern int pcix_set_mmrbc(struct pci_dev *dev , int mmrbc ) ;
extern int pcie_get_readrq(struct pci_dev *dev ) ;
extern int pcie_set_readrq(struct pci_dev *dev , int rq ) ;
extern int pci_reset_function(struct pci_dev *dev ) ;
extern int pci_execute_reset_function(struct pci_dev *dev ) ;
extern void pci_update_resource(struct pci_dev *dev , int resno ) ;
extern int pci_assign_resource(struct pci_dev *dev , int i ) ;
extern int pci_select_bars(struct pci_dev *dev , unsigned long flags ) ;
extern int pci_enable_rom(struct pci_dev *pdev ) ;
extern void pci_disable_rom(struct pci_dev *pdev ) ;
extern void *pci_map_rom(struct pci_dev *pdev , size_t *size ) ;
extern void pci_unmap_rom(struct pci_dev *pdev , void *rom ) ;
extern size_t pci_get_rom_size(struct pci_dev *pdev , void *rom , size_t size ) ;
extern int pci_save_state(struct pci_dev *dev ) ;
extern int pci_restore_state(struct pci_dev *dev ) ;
extern int __pci_complete_power_transition(struct pci_dev *dev , pci_power_t state ) ;
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
extern pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) ;
extern bool pci_pme_capable(struct pci_dev *dev , pci_power_t state ) ;
extern void pci_pme_active(struct pci_dev *dev , bool enable ) ;
extern int pci_enable_wake(struct pci_dev *dev , pci_power_t state , int enable ) ;
extern int pci_wake_from_d3(struct pci_dev *dev , bool enable ) ;
extern pci_power_t pci_target_state(struct pci_dev *dev ) ;
extern int pci_prepare_to_sleep(struct pci_dev *dev ) ;
extern int pci_back_from_sleep(struct pci_dev *dev ) ;
extern int pci_bus_find_capability(struct pci_bus *bus , unsigned int devfn , int cap ) ;
extern unsigned int pci_rescan_bus(struct pci_bus *bus ) ;
extern ssize_t pci_read_vpd(struct pci_dev *dev , loff_t pos , size_t count , void *buf ) ;
extern ssize_t pci_write_vpd(struct pci_dev *dev , loff_t pos , size_t count , void const   *buf ) ;
extern int pci_vpd_truncate(struct pci_dev *dev , size_t size ) ;
extern void pci_bus_assign_resources(struct pci_bus  const  *bus ) ;
extern void pci_bus_size_bridges(struct pci_bus *bus ) ;
extern int pci_claim_resource(struct pci_dev * , int  ) ;
extern void pci_assign_unassigned_resources(void) ;
extern void pdev_enable_device(struct pci_dev * ) ;
extern void pdev_sort_resources(struct pci_dev * , struct resource_list * ) ;
extern int pci_enable_resources(struct pci_dev * , int mask ) ;
extern void pci_fixup_irqs(u8 (*)(struct pci_dev * , u8 * ) , int (*)(struct pci_dev * ,
                                                                      u8  , u8  ) ) ;
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
extern int pci_request_regions_exclusive(struct pci_dev * , char const   * ) ;
extern void pci_release_regions(struct pci_dev * ) ;
extern int pci_request_region(struct pci_dev * , int  , char const   * ) ;
extern int pci_request_region_exclusive(struct pci_dev * , int  , char const   * ) ;
extern void pci_release_region(struct pci_dev * , int  ) ;
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
extern int pci_request_selected_regions_exclusive(struct pci_dev * , int  , char const   * ) ;
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
extern int pci_bus_alloc_resource(struct pci_bus *bus , struct resource *res , resource_size_t size ,
                                  resource_size_t align , resource_size_t min , unsigned int type_mask ,
                                  void (*alignf)(void * , struct resource * , resource_size_t  ,
                                                 resource_size_t  ) , void *alignf_data ) ;
extern void pci_enable_bridges(struct pci_bus *bus ) ;
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   *mod_name ) ;
extern void pci_unregister_driver(struct pci_driver *dev ) ;
extern void pci_remove_behind_bridge(struct pci_dev *dev ) ;
extern struct pci_driver *pci_dev_driver(struct pci_dev  const  *dev ) ;
extern struct pci_device_id  const  *pci_match_id(struct pci_device_id  const  *ids ,
                                                  struct pci_dev *dev ) ;
extern int pci_scan_bridge(struct pci_bus *bus , struct pci_dev *dev , int max , int pass ) ;
extern void pci_walk_bus(struct pci_bus *top , void (*cb)(struct pci_dev * , void * ) ,
                         void *userdata ) ;
extern int pci_cfg_space_size_ext(struct pci_dev *dev ) ;
extern int pci_cfg_space_size(struct pci_dev *dev ) ;
extern unsigned char pci_bus_max_busnr(struct pci_bus *bus ) ;
extern struct dma_pool *dma_pool_create(char const   *name , struct device *dev ,
                                        size_t size , size_t align , size_t allocation ) ;
extern void dma_pool_destroy(struct dma_pool *pool ) ;
extern void *dma_pool_alloc(struct dma_pool *pool , gfp_t mem_flags , dma_addr_t *handle ) ;
extern void dma_pool_free(struct dma_pool *pool , void *vaddr , dma_addr_t addr ) ;
extern struct dma_pool *dmam_pool_create(char const   *name , struct device *dev ,
                                         size_t size , size_t align , size_t allocation ) ;
extern void dmam_pool_destroy(struct dma_pool *pool ) ;
extern int pci_enable_msi_block(struct pci_dev *dev , unsigned int nvec ) ;
extern void pci_msi_shutdown(struct pci_dev *dev ) ;
extern void pci_disable_msi(struct pci_dev *dev ) ;
extern int pci_msix_table_size(struct pci_dev *dev ) ;
extern int pci_enable_msix(struct pci_dev *dev , struct msix_entry *entries , int nvec ) ;
extern void pci_msix_shutdown(struct pci_dev *dev ) ;
extern void pci_disable_msix(struct pci_dev *dev ) ;
extern void msi_remove_pci_irq_vectors(struct pci_dev *dev ) ;
extern void pci_restore_msi_state(struct pci_dev *dev ) ;
extern int pci_msi_enabled(void) ;
extern int ht_create_irq(struct pci_dev *dev , int idx ) ;
extern void ht_destroy_irq(unsigned int irq ) ;
extern void pci_block_user_cfg_access(struct pci_dev *dev ) ;
extern void pci_unblock_user_cfg_access(struct pci_dev *dev ) ;
extern int pci_domains_supported ;
extern int pci_routeirq ;
extern struct pci_bus *pci_scan_bus_on_node(int busno , struct pci_ops *ops , int node ) ;
extern struct pci_bus *pci_scan_bus_with_sysdata(int busno ) ;
__inline static int pci_domain_nr(struct pci_bus *bus ) 
{ struct pci_sysdata *sd ;

  {
  {
  sd = (struct pci_sysdata *)bus->sysdata;
  }
  return (sd->domain);
}
}
__inline static int pci_proc_domain(struct pci_bus *bus ) 
{ int tmp ;

  {
  {
  tmp = pci_domain_nr(bus);
  }
  return (tmp);
}
}
extern unsigned int pcibios_assign_all_busses(void) ;
extern unsigned long pci_mem_start ;
extern void pcibios_config_init(void) ;
extern struct pci_bus *pcibios_scan_root(int bus ) ;
extern void pcibios_set_master(struct pci_dev *dev ) ;
extern void pcibios_penalize_isa_irq(int irq , int active ) ;
extern struct irq_routing_table *pcibios_get_irq_routing_table(void) ;
extern int pcibios_set_irq_routing(struct pci_dev *dev , int pin , int irq ) ;
extern int pci_mmap_page_range(struct pci_dev *dev , struct vm_area_struct *vma ,
                               enum pci_mmap_state mmap_state , int write_combine ) ;
extern void early_quirks(void) ;
__inline static void pci_dma_burst_advice(struct pci_dev *pdev , enum pci_dma_burst_strategy *strat ,
                                          unsigned long *strategy_parameter ) 
{ 

  {
  {
  *strat = (enum pci_dma_burst_strategy )0;
  *strategy_parameter = ~ 0UL;
  }
  return;
}
}
extern void pci_iommu_alloc(void) ;
__inline static int pci_dma_supported(struct pci_dev *hwdev , u64 mask ) 
{ struct device *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_supported(tmp, mask);
  }
  return (tmp___0);
}
}
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ struct device *tmp ;
  void *tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_alloc_coherent(tmp, size, dma_handle, 32U);
  }
  return (tmp___0);
}
}
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_free_coherent(tmp, size, vaddr, dma_handle);
  }
  return;
}
}
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_map_single(tmp, ptr, size, (enum dma_data_direction )direction);
  }
  return (tmp___0);
}
}
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_unmap_single(tmp, dma_addr, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page ,
                                        unsigned long offset , size_t size , int direction ) 
{ struct device *tmp ;
  dma_addr_t tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_map_page(tmp, page, (unsigned int )offset, size, (enum dma_data_direction )direction);
  }
  return (tmp___0);
}
}
__inline static void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address ,
                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_unmap_page(tmp, dma_address, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static int pci_map_sg(struct pci_dev *hwdev , struct scatterlist *sg , int nents ,
                               int direction ) 
{ struct device *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  tmp___0 = dma_map_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  }
  return (tmp___0);
}
}
__inline static void pci_unmap_sg(struct pci_dev *hwdev , struct scatterlist *sg ,
                                  int nents , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_unmap_sg(tmp, sg, nents, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                 size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_single_for_cpu(tmp, dma_handle, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_single_for_device(struct pci_dev *hwdev , dma_addr_t dma_handle ,
                                                    size_t size , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_single_for_device(tmp, dma_handle, size, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev , struct scatterlist *sg ,
                                             int nelems , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_sg_for_cpu(tmp, sg, nelems, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static void pci_dma_sync_sg_for_device(struct pci_dev *hwdev , struct scatterlist *sg ,
                                                int nelems , int direction ) 
{ struct device *tmp ;

  {
  if ((unsigned long )hwdev == (unsigned long )((void *)0)) {
    {
    tmp = (struct device *)((void *)0);
    }
  } else {
    {
    tmp = & hwdev->dev;
    }
  }
  {
  dma_sync_sg_for_device(tmp, sg, nelems, (enum dma_data_direction )direction);
  }
  return;
}
}
__inline static int pci_dma_mapping_error(struct pci_dev *pdev , dma_addr_t dma_addr ) 
{ int tmp ;

  {
  {
  tmp = dma_mapping_error(& pdev->dev, dma_addr);
  }
  return (tmp);
}
}
__inline static void pcibios_resource_to_bus(struct pci_dev *dev , struct pci_bus_region *region ,
                                             struct resource *res ) 
{ 

  {
  {
  region->start = res->start;
  region->end = res->end;
  }
  return;
}
}
__inline static void pcibios_bus_to_resource(struct pci_dev *dev , struct resource *res ,
                                             struct pci_bus_region *region ) 
{ 

  {
  {
  res->start = region->start;
  res->end = region->end;
  }
  return;
}
}
__inline static struct resource *pcibios_select_root(struct pci_dev *pdev , struct resource *res ) 
{ struct resource *root ;

  {
  {
  root = (struct resource *)((void *)0);
  }
  if (res->flags & 256UL) {
    {
    root = & ioport_resource;
    }
  }
  if (res->flags & 512UL) {
    {
    root = & iomem_resource;
    }
  }
  return (root);
}
}
__inline static int pci_get_legacy_ide_irq(struct pci_dev *dev , int channel ) 
{ int tmp ;

  {
  if (channel) {
    {
    tmp = 15;
    }
  } else {
    {
    tmp = 14;
    }
  }
  return (tmp);
}
}
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ void *tmp ;

  {
  {
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 

  {
  {
  dev_set_drvdata(& pdev->dev, data);
  }
  return;
}
}
__inline static char const   *pci_name(struct pci_dev *pdev ) 
{ char const   *tmp ;

  {
  {
  tmp = dev_name((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
__inline static void pci_resource_to_user(struct pci_dev  const  *dev , int bar ,
                                          struct resource  const  *rsrc , resource_size_t *start ,
                                          resource_size_t *end ) 
{ 

  {
  {
  *start = (unsigned int )rsrc->start;
  *end = (unsigned int )rsrc->end;
  }
  return;
}
}
extern void pci_fixup_device(enum pci_fixup_pass pass , struct pci_dev *dev ) ;
extern void *pcim_iomap(struct pci_dev *pdev , int bar , unsigned long maxlen ) ;
extern void pcim_iounmap(struct pci_dev *pdev , void *addr ) ;
extern void * const  *pcim_iomap_table(struct pci_dev *pdev ) ;
extern int pcim_iomap_regions(struct pci_dev *pdev , u16 mask , char const   *name ) ;
extern int pcim_iomap_regions_request_all(struct pci_dev *pdev , u16 mask , char const   *name ) ;
extern void pcim_iounmap_regions(struct pci_dev *pdev , u16 mask ) ;
extern int pci_pci_problems ;
extern unsigned long pci_cardbus_io_size ;
extern unsigned long pci_cardbus_mem_size ;
extern int pcibios_add_platform_entries(struct pci_dev *dev ) ;
extern void pcibios_disable_device(struct pci_dev *dev ) ;
extern int pcibios_set_pcie_reset_state(struct pci_dev *dev , enum pcie_reset_state state ) ;
extern void pci_mmcfg_early_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
extern void pci_mmcfg_late_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
extern int pci_ext_cfg_avail(struct pci_dev *dev ) ;
extern void *pci_ioremap_bar(struct pci_dev *pdev , int bar ) ;
__inline static int pci_enable_sriov(struct pci_dev *dev , int nr_virtfn ) 
{ 

  {
  return (-19);
}
}
__inline static void pci_disable_sriov(struct pci_dev *dev ) 
{ 

  {
  return;
}
}
__inline static irqreturn_t pci_sriov_migration(struct pci_dev *dev ) 
{ 

  {
  return ((enum irqreturn )0);
}
}
extern struct task_struct *( /* format attribute */  kthread_create)(int (*threadfn)(void *data ) ,
                                                                     void *data ,
                                                                     char const   *namefmt 
                                                                     , ...) ;
extern void kthread_bind(struct task_struct *k , unsigned int cpu ) ;
extern int kthread_stop(struct task_struct *k ) ;
extern int kthread_should_stop(void) ;
extern int kthreadd(void *unused ) ;
extern struct task_struct *kthreadd_task ;
static int close_transaction(struct fw_transaction *transaction , struct fw_card *card ,
                             int rcode ) 
{ struct fw_transaction *t ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_395_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_395_break;
  }
  while_395_break: /* CIL Label */ ;
  }
  {
  __mptr = (struct list_head  const  *)card->transaction_list.next;
  t = (struct fw_transaction *)((char *)__mptr - (unsigned int )(& ((struct fw_transaction *)0)->link));
  }
  {
  while (1) {
    while_396_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)t->link.next);
    }
    if (! ((unsigned long )(& t->link) != (unsigned long )(& card->transaction_list))) {
      goto while_396_break;
    }
    if ((unsigned long )t == (unsigned long )transaction) {
      {
      list_del(& t->link);
      card->tlabel_mask &= ~ (1 << t->tlabel);
      }
      goto while_396_break;
    }
    {
    __mptr___0 = (struct list_head  const  *)t->link.next;
    t = (struct fw_transaction *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_transaction *)0)->link));
    }
  }
  while_396_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_397_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_397_break;
  }
  while_397_break: /* CIL Label */ ;
  }
  if ((unsigned long )(& t->link) != (unsigned long )(& card->transaction_list)) {
    {
    (*(t->callback))(card, rcode, (void *)0, 0U, t->callback_data);
    }
    return (0);
  }
  return (-2);
}
}
int fw_cancel_transaction(struct fw_card *card , struct fw_transaction *transaction ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = (*((card->driver)->cancel_packet))(card, & transaction->packet);
  }
  if (tmp == 0) {
    return (0);
  }
  {
  tmp___0 = close_transaction(transaction, card, 17);
  }
  return (tmp___0);
}
}
static char const   __kstrtab_fw_cancel_transaction[22]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'c',      (char const   )'e', 
        (char const   )'l',      (char const   )'_',      (char const   )'t',      (char const   )'r', 
        (char const   )'a',      (char const   )'n',      (char const   )'s',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_cancel_transaction  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_cancel_transaction), __kstrtab_fw_cancel_transaction};
static void transmit_complete_callback(struct fw_packet *packet , struct fw_card *card ,
                                       int status ) 
{ struct fw_transaction *t ;
  struct fw_packet  const  *__mptr ;

  {
  {
  __mptr = (struct fw_packet  const  *)packet;
  t = (struct fw_transaction *)((char *)__mptr - (unsigned int )(& ((struct fw_transaction *)0)->packet));
  }
  if (status == 1) {
    goto switch_398_1;
  } else {
    if (status == 2) {
      goto switch_398_2;
    } else {
      if (status == 4) {
        goto switch_398_4;
      } else {
        if (status == 5) {
          goto switch_398_4;
        } else {
          if (status == 6) {
            goto switch_398_4;
          } else {
            if (status == 13) {
              goto switch_398_13;
            } else {
              if (status == 14) {
                goto switch_398_14;
              } else {
                {
                goto switch_398_default;
                if (0) {
                  switch_398_1: /* CIL Label */ 
                  {
                  close_transaction(t, card, 0);
                  }
                  goto switch_398_break;
                  switch_398_2: /* CIL Label */ 
                  {
                  t->timestamp = (int )packet->timestamp;
                  }
                  goto switch_398_break;
                  switch_398_4: /* CIL Label */ 
                  switch_398_5: /* CIL Label */ 
                  switch_398_6: /* CIL Label */ 
                  {
                  close_transaction(t, card, 18);
                  }
                  goto switch_398_break;
                  switch_398_13: /* CIL Label */ 
                  {
                  close_transaction(t, card, 5);
                  }
                  goto switch_398_break;
                  switch_398_14: /* CIL Label */ 
                  {
                  close_transaction(t, card, 6);
                  }
                  goto switch_398_break;
                  switch_398_default: /* CIL Label */ 
                  {
                  close_transaction(t, card, status);
                  }
                  goto switch_398_break;
                } else {
                  switch_398_break: /* CIL Label */ ;
                }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
static void fw_fill_request(struct fw_packet *packet , int tcode , int tlabel , int destination_id ,
                            int source_id , int generation , int speed , unsigned long long offset ,
                            void *payload , size_t length ) 
{ int ext_tcode ;

  {
  if (tcode == 10) {
    {
    packet->header[0] = ((length << 16) | (unsigned int )destination_id) | (unsigned int )(10 << 4);
    packet->header_length = 4U;
    packet->payload = payload;
    packet->payload_length = length;
    }
    goto common;
  }
  if (tcode > 16) {
    {
    ext_tcode = tcode & -17;
    tcode = 9;
    }
  } else {
    {
    ext_tcode = 0;
    }
  }
  {
  packet->header[0] = (unsigned int )((((1 << 8) | (tlabel << 10)) | (tcode << 4)) | (destination_id << 16));
  packet->header[1] = (unsigned int )((offset >> 32) | (unsigned long long )(source_id << 16));
  packet->header[2] = (unsigned int )offset;
  }
  if (tcode == 0) {
    goto switch_399_0;
  } else {
    if (tcode == 9) {
      goto switch_399_9;
    } else {
      if (tcode == 1) {
        goto switch_399_9;
      } else {
        if (tcode == 4) {
          goto switch_399_4;
        } else {
          if (tcode == 5) {
            goto switch_399_5;
          } else {
            if (0) {
              switch_399_0: /* CIL Label */ 
              {
              packet->header[3] = *((u32 *)payload);
              packet->header_length = 16U;
              packet->payload_length = 0U;
              }
              goto switch_399_break;
              switch_399_9: /* CIL Label */ 
              switch_399_1: /* CIL Label */ 
              {
              packet->header[3] = (length << 16) | (unsigned int )ext_tcode;
              packet->header_length = 16U;
              packet->payload = payload;
              packet->payload_length = length;
              }
              goto switch_399_break;
              switch_399_4: /* CIL Label */ 
              {
              packet->header_length = 12U;
              packet->payload_length = 0U;
              }
              goto switch_399_break;
              switch_399_5: /* CIL Label */ 
              {
              packet->header[3] = (length << 16) | (unsigned int )ext_tcode;
              packet->header_length = 16U;
              packet->payload_length = 0U;
              }
              goto switch_399_break;
            } else {
              switch_399_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  common: 
  {
  packet->speed = speed;
  packet->generation = generation;
  packet->ack = 0;
  packet->payload_bus = 0U;
  }
  return;
}
}
void fw_send_request(struct fw_card *card , struct fw_transaction *t , int tcode ,
                     int destination_id , int generation , int speed , unsigned long long offset ,
                     void *payload , size_t length , void (*callback)(struct fw_card *card ,
                                                                      int rcode ,
                                                                      void *data ,
                                                                      size_t length ,
                                                                      void *callback_data ) ,
                     void *callback_data ) 
{ unsigned long flags ;
  int tlabel ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  unsigned long __dummy___1 ;
  unsigned long __dummy2___1 ;

  {
  {
  mod_timer(& card->flush_timer, (unsigned long )(jiffies + (unsigned long volatile   )100));
  }
  {
  while (1) {
    while_400_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_400_break;
  }
  while_400_break: /* CIL Label */ ;
  }
  {
  tlabel = card->current_tlabel;
  }
  if (card->tlabel_mask & (1 << tlabel)) {
    {
    while (1) {
      while_401_continue: /* CIL Label */ ;
      {
      _spin_unlock_irqrestore(& card->lock, flags);
      }
      goto while_401_break;
    }
    while_401_break: /* CIL Label */ ;
    }
    {
    (*callback)(card, 16, (void *)0, 0U, callback_data);
    }
    return;
  }
  {
  card->current_tlabel = (card->current_tlabel + 1) & 31;
  card->tlabel_mask |= 1 << tlabel;
  t->node_id = destination_id;
  t->tlabel = tlabel;
  t->callback = callback;
  t->callback_data = callback_data;
  fw_fill_request(& t->packet, tcode, t->tlabel, destination_id, card->node_id, generation,
                  speed, offset, payload, length);
  t->packet.callback = & transmit_complete_callback;
  list_add_tail(& t->link, & card->transaction_list);
  }
  {
  while (1) {
    while_402_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_402_break;
  }
  while_402_break: /* CIL Label */ ;
  }
  {
  (*((card->driver)->send_request))(card, & t->packet);
  }
  return;
}
}
static char const   __kstrtab_fw_send_request[16]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'q',      (char const   )'u', 
        (char const   )'e',      (char const   )'s',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_send_request  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_send_request), __kstrtab_fw_send_request};
static void transaction_callback(struct fw_card *card , int rcode , void *payload ,
                                 size_t length , void *data ) 
{ struct transaction_callback_data *d ;

  {
  {
  d = (struct transaction_callback_data *)data;
  }
  if (rcode == 0) {
    {
    __memcpy(d->payload, (void const   *)payload, length);
    }
  }
  {
  d->rcode = rcode;
  complete(& d->done);
  }
  return;
}
}
int fw_run_transaction(struct fw_card *card , int tcode , int destination_id , int generation ,
                       int speed , unsigned long long offset , void *payload , size_t length ) 
{ struct transaction_callback_data d ;
  struct fw_transaction t ;

  {
  {
  init_completion(& d.done);
  d.payload = payload;
  fw_send_request(card, & t, tcode, destination_id, generation, speed, offset, payload,
                  length, & transaction_callback, (void *)(& d));
  wait_for_completion(& d.done);
  }
  return (d.rcode);
}
}
static char const   __kstrtab_fw_run_transaction[19]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'r', 
        (char const   )'u',      (char const   )'n',      (char const   )'_',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'s', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_run_transaction  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_run_transaction), __kstrtab_fw_run_transaction};
static struct mutex phy_config_mutex  =    {{(int volatile   )1}, {{0U}}, {& phy_config_mutex.wait_list, & phy_config_mutex.wait_list},
    (struct thread_info *)0};
static struct completion phy_config_done  =    {0U, {{{0U}}, {& phy_config_done.wait.task_list, & phy_config_done.wait.task_list}}};
static void transmit_phy_packet_callback(struct fw_packet *packet ,
                                         struct fw_card *card , int status ) 
{ 

  {
  {
  complete(& phy_config_done);
  }
  return;
}
}
static struct fw_packet phy_config_packet  = 
     {0, 0, {0U, 0U, 0U, 0U}, (size_t )8, (void *)0, (size_t )0, 0U, 0U, & transmit_phy_packet_callback,
    0, {(struct list_head *)0, (struct list_head *)0}, (void *)0};
void fw_send_phy_config(struct fw_card *card , int node_id , int generation , int gap_count ) 
{ long timeout ;
  u32 data ;

  {
  {
  timeout = 100L;
  data = (u32 )((((node_id & 63) << 24) | (1 << 23)) | ((gap_count << 16) | (1 << 22)));
  mutex_lock(& phy_config_mutex);
  phy_config_packet.header[0] = data;
  phy_config_packet.header[1] = ~ data;
  phy_config_packet.generation = generation;
  phy_config_done.done = 0U;
  (*((card->driver)->send_request))(card, & phy_config_packet);
  wait_for_completion_timeout(& phy_config_done, (unsigned long )timeout);
  mutex_unlock(& phy_config_mutex);
  }
  return;
}
}
void fw_flush_transactions(struct fw_card *card ) 
{ struct fw_transaction *t ;
  struct fw_transaction *next ;
  struct list_head list ;
  unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  {
  INIT_LIST_HEAD(& list);
  }
  {
  while (1) {
    while_403_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_403_break;
  }
  while_403_break: /* CIL Label */ ;
  }
  {
  list_splice_init(& card->transaction_list, & list);
  card->tlabel_mask = 0;
  }
  {
  while (1) {
    while_404_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_404_break;
  }
  while_404_break: /* CIL Label */ ;
  }
  {
  __mptr = (struct list_head  const  *)list.next;
  t = (struct fw_transaction *)((char *)__mptr - (unsigned int )(& ((struct fw_transaction *)0)->link));
  __mptr___0 = (struct list_head  const  *)t->link.next;
  next = (struct fw_transaction *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_transaction *)0)->link));
  }
  {
  while (1) {
    while_405_continue: /* CIL Label */ ;
    if (! ((unsigned long )(& t->link) != (unsigned long )(& list))) {
      goto while_405_break;
    }
    {
    (*((card->driver)->cancel_packet))(card, & t->packet);
    (*(t->callback))(card, 17, (void *)0, 0U, t->callback_data);
    t = next;
    __mptr___1 = (struct list_head  const  *)next->link.next;
    next = (struct fw_transaction *)((char *)__mptr___1 - (unsigned int )(& ((struct fw_transaction *)0)->link));
    }
  }
  while_405_break: /* CIL Label */ ;
  }
  return;
}
}
static struct fw_address_handler *lookup_overlapping_address_handler(struct list_head *list ,
                                                                     unsigned long long offset ,
                                                                     size_t length ) 
{ struct fw_address_handler *handler ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  __mptr = (struct list_head  const  *)list->next;
  handler = (struct fw_address_handler *)((char *)__mptr - (unsigned int )(& ((struct fw_address_handler *)0)->link));
  }
  {
  while (1) {
    while_406_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)handler->link.next);
    }
    if (! ((unsigned long )(& handler->link) != (unsigned long )list)) {
      goto while_406_break;
    }
    if (handler->offset < offset + (unsigned long long )length) {
      if (offset < handler->offset + (u64 )handler->length) {
        return (handler);
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)handler->link.next;
    handler = (struct fw_address_handler *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_address_handler *)0)->link));
    }
  }
  while_406_break: /* CIL Label */ ;
  }
  return ((struct fw_address_handler *)((void *)0));
}
}
static struct fw_address_handler *lookup_enclosing_address_handler(struct list_head *list ,
                                                                   unsigned long long offset ,
                                                                   size_t length ) 
{ struct fw_address_handler *handler ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
  __mptr = (struct list_head  const  *)list->next;
  handler = (struct fw_address_handler *)((char *)__mptr - (unsigned int )(& ((struct fw_address_handler *)0)->link));
  }
  {
  while (1) {
    while_407_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)handler->link.next);
    }
    if (! ((unsigned long )(& handler->link) != (unsigned long )list)) {
      goto while_407_break;
    }
    if (handler->offset <= offset) {
      if (offset + (unsigned long long )length <= handler->offset + (u64 )handler->length) {
        return (handler);
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)handler->link.next;
    handler = (struct fw_address_handler *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_address_handler *)0)->link));
    }
  }
  while_407_break: /* CIL Label */ ;
  }
  return ((struct fw_address_handler *)((void *)0));
}
}
static spinlock_t address_handler_lock  =    {{0U}};
static struct list_head address_handler_list  =    {& address_handler_list, & address_handler_list};
struct fw_address_region  const  fw_high_memory_region  =    {4294967296ULL, 281474439839744ULL};
static char const   __kstrtab_fw_high_memory_region[22]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'h', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'_', 
        (char const   )'m',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'g',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_high_memory_region  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_high_memory_region), __kstrtab_fw_high_memory_region};
int fw_core_add_address_handler(struct fw_address_handler *handler , struct fw_address_region  const  *region ) 
{ struct fw_address_handler *other ;
  unsigned long flags ;
  int ret ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  ret = -16;
  }
  if (region->start & 0xffff000000000003ULL) {
    return (-22);
  } else {
    if (region->end & 0xffff000000000003ULL) {
      return (-22);
    } else {
      if (region->start >= region->end) {
        return (-22);
      } else {
        if (handler->length & 3U) {
          return (-22);
        } else {
          if (handler->length == 0U) {
            return (-22);
          }
        }
      }
    }
  }
  {
  while (1) {
    while_408_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& address_handler_lock);
    }
    goto while_408_break;
  }
  while_408_break: /* CIL Label */ ;
  }
  {
  handler->offset = (unsigned long long )region->start;
  }
  {
  while (1) {
    while_409_continue: /* CIL Label */ ;
    if (! (handler->offset + (u64 )handler->length <= (u64 )region->end)) {
      goto while_409_break;
    }
    {
    other = lookup_overlapping_address_handler(& address_handler_list, handler->offset,
                                               handler->length);
    }
    if ((unsigned long )other != (unsigned long )((void *)0)) {
      {
      handler->offset += (u64 )other->length;
      }
    } else {
      {
      list_add_tail(& handler->link, & address_handler_list);
      ret = 0;
      }
      goto while_409_break;
    }
  }
  while_409_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_410_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& address_handler_lock, flags);
    }
    goto while_410_break;
  }
  while_410_break: /* CIL Label */ ;
  }
  return (ret);
}
}
static char const   __kstrtab_fw_core_add_address_handler[28]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'_', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'_', 
        (char const   )'h',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'l',      (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_core_add_address_handler  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_core_add_address_handler), __kstrtab_fw_core_add_address_handler};
void fw_core_remove_address_handler(struct fw_address_handler *handler ) 
{ unsigned long flags ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  while (1) {
    while_411_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& address_handler_lock);
    }
    goto while_411_break;
  }
  while_411_break: /* CIL Label */ ;
  }
  {
  list_del(& handler->link);
  }
  {
  while (1) {
    while_412_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& address_handler_lock, flags);
    }
    goto while_412_break;
  }
  while_412_break: /* CIL Label */ ;
  }
  return;
}
}
static char const   __kstrtab_fw_core_remove_address_handler[31]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'_',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'_',      (char const   )'h', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'l', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_core_remove_address_handler  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_core_remove_address_handler), __kstrtab_fw_core_remove_address_handler};
static void free_response_callback(struct fw_packet *packet ,
                                   struct fw_card *card , int status ) 
{ struct fw_request *request ;
  struct fw_packet  const  *__mptr ;

  {
  {
  __mptr = (struct fw_packet  const  *)packet;
  request = (struct fw_request *)((char *)__mptr - (unsigned int )(& ((struct fw_request *)0)->response));
  kfree((void const   *)request);
  }
  return;
}
}
void fw_fill_response(struct fw_packet *response , u32 *request_header , int rcode ,
                      void *payload , size_t length ) 
{ int tcode ;
  int tlabel ;
  int extended_tcode ;
  int source ;
  int destination ;

  {
  {
  tcode = (int )((*(request_header + 0) >> 4) & 15U);
  tlabel = (int )((*(request_header + 0) >> 10) & 63U);
  source = (int )((*(request_header + 0) >> 16) & 65535U);
  destination = (int )((*(request_header + 1) >> 16) & 65535U);
  extended_tcode = (int )(*(request_header + 3) & 65535U);
  response->header[0] = (unsigned int )((tlabel << 10) | (destination << 16));
  response->header[1] = (unsigned int )((source << 16) | (rcode << 12));
  response->header[2] = 0U;
  }
  if (tcode == 0) {
    goto switch_413_0;
  } else {
    if (tcode == 1) {
      goto switch_413_0;
    } else {
      if (tcode == 4) {
        goto switch_413_4;
      } else {
        if (tcode == 5) {
          goto switch_413_5;
        } else {
          if (tcode == 9) {
            goto switch_413_5;
          } else {
            {
            goto switch_413_default;
            if (0) {
              switch_413_0: /* CIL Label */ 
              switch_413_1: /* CIL Label */ 
              {
              response->header[0] |= (unsigned int )(2 << 4);
              response->header_length = 12U;
              response->payload_length = 0U;
              }
              goto switch_413_break;
              switch_413_4: /* CIL Label */ 
              {
              response->header[0] |= (unsigned int )(6 << 4);
              }
              if ((unsigned long )payload != (unsigned long )((void *)0)) {
                {
                response->header[3] = *((u32 *)payload);
                }
              } else {
                {
                response->header[3] = 0U;
                }
              }
              {
              response->header_length = 16U;
              response->payload_length = 0U;
              }
              goto switch_413_break;
              switch_413_5: /* CIL Label */ 
              switch_413_9: /* CIL Label */ 
              {
              response->header[0] |= (unsigned int )((tcode + 2) << 4);
              response->header[3] = (length << 16) | (unsigned int )extended_tcode;
              response->header_length = 16U;
              response->payload = payload;
              response->payload_length = length;
              }
              goto switch_413_break;
              switch_413_default: /* CIL Label */ 
              {

              }
              {
              while (1) {
                while_414_continue: /* CIL Label */ ;
                {
                __asm__  volatile   ("1:\tud2\n"
                                     ".pushsection __bug_table,\"a\"\n"
                                     "2:\t.long 1b, %c0\n"
                                     "\t.word %c1, 0\n"
                                     "\t.org 2b+%c2\n"
                                     ".popsection": : "i" ("fw-transaction.c"), "i" (590),
                                     "i" (sizeof(struct bug_entry )));
                }
                {
                while (1) {
                  while_415_continue: /* CIL Label */ ;
                }
                while_415_break: /* CIL Label */ ;
                }
                goto while_414_break;
              }
              while_414_break: /* CIL Label */ ;
              }
              return;
            } else {
              switch_413_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
  }
  {
  response->payload_bus = 0U;
  }
  return;
}
}
static char const   __kstrtab_fw_fill_response[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'l',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'p', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_fill_response  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_fill_response), __kstrtab_fw_fill_response};
static struct fw_request *allocate_request(struct fw_packet *p ) 
{ struct fw_request *request ;
  u32 *data ;
  u32 length ;
  int request_tcode ;
  int t ;
  void *tmp ;

  {
  {
  request_tcode = (int )((p->header[0] >> 4) & 15U);
  }
  if (request_tcode == 0) {
    goto switch_416_0;
  } else {
    if (request_tcode == 1) {
      goto switch_416_1;
    } else {
      if (request_tcode == 9) {
        goto switch_416_1;
      } else {
        if (request_tcode == 4) {
          goto switch_416_4;
        } else {
          if (request_tcode == 5) {
            goto switch_416_5;
          } else {
            {
            goto switch_416_default;
            if (0) {
              switch_416_0: /* CIL Label */ 
              {
              data = & p->header[3];
              length = 4U;
              }
              goto switch_416_break;
              switch_416_1: /* CIL Label */ 
              switch_416_9: /* CIL Label */ 
              {
              data = (u32 *)p->payload;
              length = (p->header[3] >> 16) & 65535U;
              }
              goto switch_416_break;
              switch_416_4: /* CIL Label */ 
              {
              data = (u32 *)((void *)0);
              length = 4U;
              }
              goto switch_416_break;
              switch_416_5: /* CIL Label */ 
              {
              data = (u32 *)((void *)0);
              length = (p->header[3] >> 16) & 65535U;
              }
              goto switch_416_break;
              switch_416_default: /* CIL Label */ 
              {
              printk("<3>SomeModule: ERROR - corrupt request received - %08x %08x %08x\n",
                     p->header[0], p->header[1], p->header[2]);
              }
              return ((struct fw_request *)((void *)0));
            } else {
              switch_416_break: /* CIL Label */ ;
            }
            }
          }
        }
      }
    }
  }
  {
  tmp = kmalloc((unsigned int )(sizeof(*request) + (unsigned long )length), 32U);
  request = (struct fw_request *)tmp;
  }
  if ((unsigned long )request == (unsigned long )((void *)0)) {
    return ((struct fw_request *)((void *)0));
  }
  {
  t = (int )((p->timestamp & 8191U) + 4000U);
  }
  if (t >= 8000) {
    {
    t = (int )((((p->timestamp & 4294959104U) + 8192U) + (unsigned int )t) - 8000U);
    }
  } else {
    {
    t = (int )((p->timestamp & 4294959104U) + (unsigned int )t);
    }
  }
  {
  request->response.speed = p->speed;
  request->response.timestamp = (unsigned int )t;
  request->response.generation = p->generation;
  request->response.ack = 0;
  request->response.callback = & free_response_callback;
  request->ack = p->ack;
  request->length = length;
  }
  if (data) {
    {
    __memcpy((void *)(request->data), (void const   *)data, length);
    }
  }
  {
  __constant_memcpy((void *)(request->request_header), (void const   *)(p->header),
                    (unsigned int )sizeof(p->header));
  }
  return (request);
}
}
void fw_send_response(struct fw_card *card , struct fw_request *request , int rcode ) 
{ 

  {
  if (request->ack != 2) {
    {
    kfree((void const   *)request);
    }
    return;
  } else {
    if ((request->request_header[0] & (unsigned int )(63 << 16)) == (unsigned int )(63 << 16)) {
      {
      kfree((void const   *)request);
      }
      return;
    }
  }
  if (rcode == 0) {
    {
    fw_fill_response(& request->response, request->request_header, rcode, (void *)(request->data),
                     request->length);
    }
  } else {
    {
    fw_fill_response(& request->response, request->request_header, rcode, (void *)0,
                     0U);
    }
  }
  {
  (*((card->driver)->send_response))(card, & request->response);
  }
  return;
}
}
static char const   __kstrtab_fw_send_response[17]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'p', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_send_response  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_send_response), __kstrtab_fw_send_response};
void fw_core_handle_request(struct fw_card *card , struct fw_packet *p ) 
{ struct fw_address_handler *handler ;
  struct fw_request *request ;
  unsigned long long offset ;
  unsigned long flags ;
  int tcode ;
  int destination ;
  int source ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  if (p->ack != 2) {
    if (p->ack != 1) {
      return;
    }
  }
  {
  request = allocate_request(p);
  }
  if ((unsigned long )request == (unsigned long )((void *)0)) {
    return;
  }
  {
  offset = ((unsigned long long )(p->header[1] & 65535U) << 32) | (unsigned long long )p->header[2];
  tcode = (int )((p->header[0] >> 4) & 15U);
  destination = (int )((p->header[0] >> 16) & 65535U);
  source = (int )((p->header[1] >> 16) & 65535U);
  }
  {
  while (1) {
    while_417_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& address_handler_lock);
    }
    goto while_417_break;
  }
  while_417_break: /* CIL Label */ ;
  }
  {
  handler = lookup_enclosing_address_handler(& address_handler_list, offset, request->length);
  }
  {
  while (1) {
    while_418_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& address_handler_lock, flags);
    }
    goto while_418_break;
  }
  while_418_break: /* CIL Label */ ;
  }
  if ((unsigned long )handler == (unsigned long )((void *)0)) {
    {
    fw_send_response(card, request, 7);
    }
  } else {
    {
    (*(handler->address_callback))(card, request, tcode, destination, source, p->generation,
                                   p->speed, offset, (void *)(request->data), request->length,
                                   handler->callback_data);
    }
  }
  return;
}
}
static char const   __kstrtab_fw_core_handle_request[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'h',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'l',      (char const   )'e',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'q',      (char const   )'u',      (char const   )'e', 
        (char const   )'s',      (char const   )'t',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_core_handle_request  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_core_handle_request), __kstrtab_fw_core_handle_request};
void fw_core_handle_response(struct fw_card *card ,
                             struct fw_packet *p ) 
{ struct fw_transaction *t ;
  unsigned long flags ;
  u32 *data ;
  size_t data_length ;
  int tcode ;
  int tlabel ;
  int destination ;
  int source ;
  int rcode ;
  unsigned long __dummy ;
  unsigned long __dummy2 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned long __dummy___0 ;
  unsigned long __dummy2___0 ;

  {
  {
  tcode = (int )((p->header[0] >> 4) & 15U);
  tlabel = (int )((p->header[0] >> 10) & 63U);
  destination = (int )((p->header[0] >> 16) & 65535U);
  source = (int )((p->header[1] >> 16) & 65535U);
  rcode = (int )((p->header[1] >> 12) & 15U);
  }
  {
  while (1) {
    while_419_continue: /* CIL Label */ ;
    {
    flags = _spin_lock_irqsave(& card->lock);
    }
    goto while_419_break;
  }
  while_419_break: /* CIL Label */ ;
  }
  {
  __mptr = (struct list_head  const  *)card->transaction_list.next;
  t = (struct fw_transaction *)((char *)__mptr - (unsigned int )(& ((struct fw_transaction *)0)->link));
  }
  {
  while (1) {
    while_420_continue: /* CIL Label */ ;
    {
    prefetch((void const   *)t->link.next);
    }
    if (! ((unsigned long )(& t->link) != (unsigned long )(& card->transaction_list))) {
      goto while_420_break;
    }
    if (t->node_id == source) {
      if (t->tlabel == tlabel) {
        {
        list_del(& t->link);
        card->tlabel_mask &= ~ (1 << t->tlabel);
        }
        goto while_420_break;
      }
    }
    {
    __mptr___0 = (struct list_head  const  *)t->link.next;
    t = (struct fw_transaction *)((char *)__mptr___0 - (unsigned int )(& ((struct fw_transaction *)0)->link));
    }
  }
  while_420_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_421_continue: /* CIL Label */ ;
    {
    _spin_unlock_irqrestore(& card->lock, flags);
    }
    goto while_421_break;
  }
  while_421_break: /* CIL Label */ ;
  }
  if ((unsigned long )(& t->link) == (unsigned long )(& card->transaction_list)) {
    {
    printk("<5>SomeModule: Unsolicited response (source %x, tlabel %x)\n", source,
           tlabel);
    }
    return;
  }
  if (tcode == 6) {
    goto switch_422_6;
  } else {
    if (tcode == 2) {
      goto switch_422_2;
    } else {
      if (tcode == 7) {
        goto switch_422_7;
      } else {
        if (tcode == 11) {
          goto switch_422_7;
        } else {
          {
          goto switch_422_default;
          if (0) {
            switch_422_6: /* CIL Label */ 
            {
            data = & p->header[3];
            data_length = 4U;
            }
            goto switch_422_break;
            switch_422_2: /* CIL Label */ 
            {
            data = (u32 *)((void *)0);
            data_length = 0U;
            }
            goto switch_422_break;
            switch_422_7: /* CIL Label */ 
            switch_422_11: /* CIL Label */ 
            {
            data = (u32 *)p->payload;
            data_length = (p->header[3] >> 16) & 65535U;
            }
            goto switch_422_break;
            switch_422_default: /* CIL Label */ 
            {
            data = (u32 *)((void *)0);
            data_length = 0U;
            }
            goto switch_422_break;
          } else {
            switch_422_break: /* CIL Label */ ;
          }
          }
        }
      }
    }
  }
  {
  (*((card->driver)->cancel_packet))(card, & t->packet);
  (*(t->callback))(card, rcode, (void *)data, data_length, t->callback_data);
  }
  return;
}
}
static char const   __kstrtab_fw_core_handle_response[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
  {      (char const   )'f',      (char const   )'w',      (char const   )'_',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'h',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'l',      (char const   )'e',      (char const   )'_',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'p',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'\000'};
static struct kernel_symbol  const  __ksymtab_fw_core_handle_response  __attribute__((__unused__,
__section__("__ksymtab")))  =    {(unsigned long )(& fw_core_handle_response), __kstrtab_fw_core_handle_response};
static struct fw_address_region  const  topology_map_region  =    {281474708279296ULL,
    281474708280320ULL};
static void handle_topology_map(struct fw_card *card , struct fw_request *request ,
                                int tcode , int destination , int source , int generation ,
                                int speed , unsigned long long offset , void *payload ,
                                size_t length , void *callback_data ) 
{ int i ;
  int start ;
  int end ;
  __be32 *map ;
  __u32 tmp ;

  {
  if (! ((tcode & -2) == 4)) {
    {
    fw_send_response(card, request, 6);
    }
    return;
  }
  if ((offset & 3ULL) > 0ULL) {
    {
    fw_send_response(card, request, 7);
    }
    return;
  } else {
    if ((length & 3U) > 0U) {
      {
      fw_send_response(card, request, 7);
      }
      return;
    }
  }
  {
  start = (int )((offset - (unsigned long long )topology_map_region.start) / 4ULL);
  end = (int )((size_t )start + length / 4U);
  map = (__be32 *)payload;
  i = 0;
  }
  {
  while (1) {
    while_423_continue: /* CIL Label */ ;
    if (! ((size_t )i < length / 4U)) {
      goto while_423_break;
    }
    {
    tmp = __fswab32(card->topology_map[start + i]);
    *(map + i) = tmp;
    i ++;
    }
  }
  while_423_break: /* CIL Label */ ;
  }
  {
  fw_send_response(card, request, 0);
  }
  return;
}
}
static struct fw_address_handler topology_map  =    {0ULL, (size_t )512, & handle_topology_map, (void *)0, {(struct list_head *)0,
                                                           (struct list_head *)0}};
static struct fw_address_region  const  registers_region  =    {281474708275200ULL,
    281474708276224ULL};
static void handle_registers(struct fw_card *card , struct fw_request *request , int tcode ,
                             int destination , int source , int generation , int speed ,
                             unsigned long long offset , void *payload , size_t length ,
                             void *callback_data ) 
{ int reg ;
  unsigned long long bus_time ;
  __be32 *data ;
  int rcode ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
  {
  reg = (int )(offset & 0xffff00000fffffffULL);
  data = (__be32 *)payload;
  rcode = 0;
  }
  if (reg == 512) {
    goto switch_424_512;
  } else {
    if (reg == 516) {
      goto switch_424_512;
    } else {
      if (reg == 564) {
        goto switch_424_564;
      } else {
        if (reg == 540) {
          goto switch_424_540;
        } else {
          if (reg == 544) {
            goto switch_424_540;
          } else {
            if (reg == 548) {
              goto switch_424_540;
            } else {
              if (reg == 552) {
                goto switch_424_540;
              } else {
                if (reg == 528) {
                  goto switch_424_528;
                } else {
                  {
                  goto switch_424_528;
                  if (0) {
                    switch_424_512: /* CIL Label */ 
                    switch_424_516: /* CIL Label */ 
                    if (! ((tcode & -2) == 4)) {
                      {
                      rcode = 6;
                      }
                      goto switch_424_break;
                    } else {
                      if (length != 4U) {
                        {
                        rcode = 6;
                        }
                        goto switch_424_break;
                      }
                    }
                    {
                    bus_time = (*((card->driver)->get_bus_time))(card);
                    }
                    if (reg == 512) {
                      {
                      tmp = __fswab32((unsigned int )bus_time);
                      *data = tmp;
                      }
                    } else {
                      {
                      tmp___0 = __fswab32((unsigned int )(bus_time >> 25));
                      *data = tmp___0;
                      }
                    }
                    goto switch_424_break;
                    switch_424_564: /* CIL Label */ 
                    if (tcode == 4) {
                      {
                      tmp___1 = __fswab32(card->broadcast_channel);
                      *data = tmp___1;
                      }
                    } else {
                      if (tcode == 0) {
                        {
                        tmp___2 = __fswab32(*data);
                        card->broadcast_channel = (tmp___2 & (unsigned int )(1 << 30)) | (unsigned int )((1 << 31) | 31);
                        }
                      } else {
                        {
                        rcode = 6;
                        }
                      }
                    }
                    goto switch_424_break;
                    switch_424_540: /* CIL Label */ 
                    switch_424_544: /* CIL Label */ 
                    switch_424_548: /* CIL Label */ 
                    switch_424_552: /* CIL Label */ 
                    {
                    while (1) {
                      while_425_continue: /* CIL Label */ ;
                      {
                      __asm__  volatile   ("1:\tud2\n"
                                           ".pushsection __bug_table,\"a\"\n"
                                           "2:\t.long 1b, %c0\n"
                                           "\t.word %c1, 0\n"
                                           "\t.org 2b+%c2\n"
                                           ".popsection": : "i" ("fw-transaction.c"),
                                           "i" (884), "i" (sizeof(struct bug_entry )));
                      }
                      {
                      while (1) {
                        while_426_continue: /* CIL Label */ ;
                      }
                      while_426_break: /* CIL Label */ ;
                      }
                      goto while_425_break;
                    }
                    while_425_break: /* CIL Label */ ;
                    }
                    goto switch_424_break;
                    switch_424_528: /* CIL Label */ 
                    switch_424_default: /* CIL Label */ 
                    {
                    rcode = 7;
                    }
                    goto switch_424_break;
                  } else {
                    switch_424_break: /* CIL Label */ ;
                  }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
  fw_send_response(card, request, rcode);
  }
  return;
}
}
static struct fw_address_handler registers  =    {0ULL, (size_t )1024, & handle_registers, (void *)0, {(struct list_head *)0, (struct list_head *)0}};
static u32 const   vendor_textual_descriptor[7]  = {      (u32 const   )393216,      (u32 const   )0,      (u32 const   )0,      (u32 const   )1281977973, 
        (u32 const   )2015381097,      (u32 const   )1919252329,      (u32 const   )1919221760};
static u32 const   model_textual_descriptor[4]  = {      (u32 const   )196608,      (u32 const   )0,      (u32 const   )0,      (u32 const   )1249208949};
static struct fw_descriptor vendor_id_descriptor  =    {{(struct list_head *)0,
     (struct list_head *)0}, (size_t )(sizeof(vendor_textual_descriptor) / sizeof(vendor_textual_descriptor[0])),
    (u32 )63966494, 2164260864U, vendor_textual_descriptor};
static struct fw_descriptor model_id_descriptor  =    {{(struct list_head *)0, (struct list_head *)0}, (size_t )(sizeof(model_textual_descriptor) / sizeof(model_textual_descriptor[0])),
    (u32 )385875969, 2164260864U, model_textual_descriptor};
static int fw_core_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
static int fw_core_init(void) 
{ int ret ;

  {
  {
  ret = bus_register(& fw_bus_type);
  }
  if (ret < 0) {
    return (ret);
  }
  {
  fw_cdev_major = register_chrdev(0U, "firewire", & fw_device_ops);
  }
  if (fw_cdev_major < 0) {
    {
    bus_unregister(& fw_bus_type);
    }
    return (fw_cdev_major);
  }
  {
  fw_core_add_address_handler(& topology_map, & topology_map_region);
  fw_core_add_address_handler(& registers, & registers_region);
  fw_core_add_descriptor(& vendor_id_descriptor);
  fw_core_add_descriptor(& model_id_descriptor);
  }
  return (0);
}
}
static void fw_core_cleanup(void)  __attribute__((__section__(".exit.text"))) ;
static void fw_core_cleanup(void) 
{ 

  {
  {
  unregister_chrdev((unsigned int )fw_cdev_major, "firewire");
  bus_unregister(& fw_bus_type);
  idr_destroy(& fw_device_idr);
  }
  return;
}
}
static int (*__initcall_fw_core_init6)(void)  __attribute__((__section__(".initcall6.init")))  =    & fw_core_init;
static void (*__exitcall_fw_core_cleanup)(void)  __attribute__((__section__(".exitcall.exit")))  =    & fw_core_cleanup;
